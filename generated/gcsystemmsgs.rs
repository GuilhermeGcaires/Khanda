// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gcsystemmsgs.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ESOMsg)
pub enum ESOMsg {
    // @@protoc_insertion_point(enum_value:dota.ESOMsg.k_ESOMsg_Create)
    k_ESOMsg_Create = 21,
    // @@protoc_insertion_point(enum_value:dota.ESOMsg.k_ESOMsg_Update)
    k_ESOMsg_Update = 22,
    // @@protoc_insertion_point(enum_value:dota.ESOMsg.k_ESOMsg_Destroy)
    k_ESOMsg_Destroy = 23,
    // @@protoc_insertion_point(enum_value:dota.ESOMsg.k_ESOMsg_CacheSubscribed)
    k_ESOMsg_CacheSubscribed = 24,
    // @@protoc_insertion_point(enum_value:dota.ESOMsg.k_ESOMsg_CacheUnsubscribed)
    k_ESOMsg_CacheUnsubscribed = 25,
    // @@protoc_insertion_point(enum_value:dota.ESOMsg.k_ESOMsg_UpdateMultiple)
    k_ESOMsg_UpdateMultiple = 26,
    // @@protoc_insertion_point(enum_value:dota.ESOMsg.k_ESOMsg_CacheSubscriptionRefresh)
    k_ESOMsg_CacheSubscriptionRefresh = 28,
    // @@protoc_insertion_point(enum_value:dota.ESOMsg.k_ESOMsg_CacheSubscribedUpToDate)
    k_ESOMsg_CacheSubscribedUpToDate = 29,
}

impl ::protobuf::Enum for ESOMsg {
    const NAME: &'static str = "ESOMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESOMsg> {
        match value {
            21 => ::std::option::Option::Some(ESOMsg::k_ESOMsg_Create),
            22 => ::std::option::Option::Some(ESOMsg::k_ESOMsg_Update),
            23 => ::std::option::Option::Some(ESOMsg::k_ESOMsg_Destroy),
            24 => ::std::option::Option::Some(ESOMsg::k_ESOMsg_CacheSubscribed),
            25 => ::std::option::Option::Some(ESOMsg::k_ESOMsg_CacheUnsubscribed),
            26 => ::std::option::Option::Some(ESOMsg::k_ESOMsg_UpdateMultiple),
            28 => ::std::option::Option::Some(ESOMsg::k_ESOMsg_CacheSubscriptionRefresh),
            29 => ::std::option::Option::Some(ESOMsg::k_ESOMsg_CacheSubscribedUpToDate),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESOMsg> {
        match str {
            "k_ESOMsg_Create" => ::std::option::Option::Some(ESOMsg::k_ESOMsg_Create),
            "k_ESOMsg_Update" => ::std::option::Option::Some(ESOMsg::k_ESOMsg_Update),
            "k_ESOMsg_Destroy" => ::std::option::Option::Some(ESOMsg::k_ESOMsg_Destroy),
            "k_ESOMsg_CacheSubscribed" => ::std::option::Option::Some(ESOMsg::k_ESOMsg_CacheSubscribed),
            "k_ESOMsg_CacheUnsubscribed" => ::std::option::Option::Some(ESOMsg::k_ESOMsg_CacheUnsubscribed),
            "k_ESOMsg_UpdateMultiple" => ::std::option::Option::Some(ESOMsg::k_ESOMsg_UpdateMultiple),
            "k_ESOMsg_CacheSubscriptionRefresh" => ::std::option::Option::Some(ESOMsg::k_ESOMsg_CacheSubscriptionRefresh),
            "k_ESOMsg_CacheSubscribedUpToDate" => ::std::option::Option::Some(ESOMsg::k_ESOMsg_CacheSubscribedUpToDate),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESOMsg] = &[
        ESOMsg::k_ESOMsg_Create,
        ESOMsg::k_ESOMsg_Update,
        ESOMsg::k_ESOMsg_Destroy,
        ESOMsg::k_ESOMsg_CacheSubscribed,
        ESOMsg::k_ESOMsg_CacheUnsubscribed,
        ESOMsg::k_ESOMsg_UpdateMultiple,
        ESOMsg::k_ESOMsg_CacheSubscriptionRefresh,
        ESOMsg::k_ESOMsg_CacheSubscribedUpToDate,
    ];
}

impl ::protobuf::EnumFull for ESOMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESOMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ESOMsg::k_ESOMsg_Create => 0,
            ESOMsg::k_ESOMsg_Update => 1,
            ESOMsg::k_ESOMsg_Destroy => 2,
            ESOMsg::k_ESOMsg_CacheSubscribed => 3,
            ESOMsg::k_ESOMsg_CacheUnsubscribed => 4,
            ESOMsg::k_ESOMsg_UpdateMultiple => 5,
            ESOMsg::k_ESOMsg_CacheSubscriptionRefresh => 6,
            ESOMsg::k_ESOMsg_CacheSubscribedUpToDate => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ESOMsg {
    fn default() -> Self {
        ESOMsg::k_ESOMsg_Create
    }
}

impl ESOMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESOMsg>("ESOMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EGCBaseClientMsg)
pub enum EGCBaseClientMsg {
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCPingRequest)
    k_EMsgGCPingRequest = 3001,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCPingResponse)
    k_EMsgGCPingResponse = 3002,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCToClientPollConvarRequest)
    k_EMsgGCToClientPollConvarRequest = 3003,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCToClientPollConvarResponse)
    k_EMsgGCToClientPollConvarResponse = 3004,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCCompressedMsgToClient)
    k_EMsgGCCompressedMsgToClient = 3005,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCCompressedMsgToClient_Legacy)
    k_EMsgGCCompressedMsgToClient_Legacy = 523,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCToClientRequestDropped)
    k_EMsgGCToClientRequestDropped = 3006,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCClientWelcome)
    k_EMsgGCClientWelcome = 4004,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCServerWelcome)
    k_EMsgGCServerWelcome = 4005,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCClientHello)
    k_EMsgGCClientHello = 4006,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCServerHello)
    k_EMsgGCServerHello = 4007,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCClientConnectionStatus)
    k_EMsgGCClientConnectionStatus = 4009,
    // @@protoc_insertion_point(enum_value:dota.EGCBaseClientMsg.k_EMsgGCServerConnectionStatus)
    k_EMsgGCServerConnectionStatus = 4010,
}

impl ::protobuf::Enum for EGCBaseClientMsg {
    const NAME: &'static str = "EGCBaseClientMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseClientMsg> {
        match value {
            3001 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCPingRequest),
            3002 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCPingResponse),
            3003 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCToClientPollConvarRequest),
            3004 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCToClientPollConvarResponse),
            3005 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCCompressedMsgToClient),
            523 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCCompressedMsgToClient_Legacy),
            3006 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCToClientRequestDropped),
            4004 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCClientWelcome),
            4005 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCServerWelcome),
            4006 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCClientHello),
            4007 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCServerHello),
            4009 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCClientConnectionStatus),
            4010 => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCServerConnectionStatus),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCBaseClientMsg> {
        match str {
            "k_EMsgGCPingRequest" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCPingRequest),
            "k_EMsgGCPingResponse" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCPingResponse),
            "k_EMsgGCToClientPollConvarRequest" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCToClientPollConvarRequest),
            "k_EMsgGCToClientPollConvarResponse" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCToClientPollConvarResponse),
            "k_EMsgGCCompressedMsgToClient" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCCompressedMsgToClient),
            "k_EMsgGCCompressedMsgToClient_Legacy" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCCompressedMsgToClient_Legacy),
            "k_EMsgGCToClientRequestDropped" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCToClientRequestDropped),
            "k_EMsgGCClientWelcome" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCClientWelcome),
            "k_EMsgGCServerWelcome" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCServerWelcome),
            "k_EMsgGCClientHello" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCClientHello),
            "k_EMsgGCServerHello" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCServerHello),
            "k_EMsgGCClientConnectionStatus" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCClientConnectionStatus),
            "k_EMsgGCServerConnectionStatus" => ::std::option::Option::Some(EGCBaseClientMsg::k_EMsgGCServerConnectionStatus),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCBaseClientMsg] = &[
        EGCBaseClientMsg::k_EMsgGCPingRequest,
        EGCBaseClientMsg::k_EMsgGCPingResponse,
        EGCBaseClientMsg::k_EMsgGCToClientPollConvarRequest,
        EGCBaseClientMsg::k_EMsgGCToClientPollConvarResponse,
        EGCBaseClientMsg::k_EMsgGCCompressedMsgToClient,
        EGCBaseClientMsg::k_EMsgGCCompressedMsgToClient_Legacy,
        EGCBaseClientMsg::k_EMsgGCToClientRequestDropped,
        EGCBaseClientMsg::k_EMsgGCClientWelcome,
        EGCBaseClientMsg::k_EMsgGCServerWelcome,
        EGCBaseClientMsg::k_EMsgGCClientHello,
        EGCBaseClientMsg::k_EMsgGCServerHello,
        EGCBaseClientMsg::k_EMsgGCClientConnectionStatus,
        EGCBaseClientMsg::k_EMsgGCServerConnectionStatus,
    ];
}

impl ::protobuf::EnumFull for EGCBaseClientMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCBaseClientMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EGCBaseClientMsg::k_EMsgGCPingRequest => 0,
            EGCBaseClientMsg::k_EMsgGCPingResponse => 1,
            EGCBaseClientMsg::k_EMsgGCToClientPollConvarRequest => 2,
            EGCBaseClientMsg::k_EMsgGCToClientPollConvarResponse => 3,
            EGCBaseClientMsg::k_EMsgGCCompressedMsgToClient => 4,
            EGCBaseClientMsg::k_EMsgGCCompressedMsgToClient_Legacy => 5,
            EGCBaseClientMsg::k_EMsgGCToClientRequestDropped => 6,
            EGCBaseClientMsg::k_EMsgGCClientWelcome => 7,
            EGCBaseClientMsg::k_EMsgGCServerWelcome => 8,
            EGCBaseClientMsg::k_EMsgGCClientHello => 9,
            EGCBaseClientMsg::k_EMsgGCServerHello => 10,
            EGCBaseClientMsg::k_EMsgGCClientConnectionStatus => 11,
            EGCBaseClientMsg::k_EMsgGCServerConnectionStatus => 12,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseClientMsg {
    fn default() -> Self {
        EGCBaseClientMsg::k_EMsgGCPingRequest
    }
}

impl EGCBaseClientMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCBaseClientMsg>("EGCBaseClientMsg")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12gcsystemmsgs.proto\x12\x04dota*\xf0\x01\n\x06ESOMsg\x12\x13\n\x0fk\
    _ESOMsg_Create\x10\x15\x12\x13\n\x0fk_ESOMsg_Update\x10\x16\x12\x14\n\
    \x10k_ESOMsg_Destroy\x10\x17\x12\x1c\n\x18k_ESOMsg_CacheSubscribed\x10\
    \x18\x12\x1e\n\x1ak_ESOMsg_CacheUnsubscribed\x10\x19\x12\x1b\n\x17k_ESOM\
    sg_UpdateMultiple\x10\x1a\x12%\n!k_ESOMsg_CacheSubscriptionRefresh\x10\
    \x1c\x12$\n\x20k_ESOMsg_CacheSubscribedUpToDate\x10\x1d*\xc2\x03\n\x10EG\
    CBaseClientMsg\x12\x18\n\x13k_EMsgGCPingRequest\x10\xb9\x17\x12\x19\n\
    \x14k_EMsgGCPingResponse\x10\xba\x17\x12&\n!k_EMsgGCToClientPollConvarRe\
    quest\x10\xbb\x17\x12'\n\"k_EMsgGCToClientPollConvarResponse\x10\xbc\x17\
    \x12\"\n\x1dk_EMsgGCCompressedMsgToClient\x10\xbd\x17\x12)\n$k_EMsgGCCom\
    pressedMsgToClient_Legacy\x10\x8b\x04\x12#\n\x1ek_EMsgGCToClientRequestD\
    ropped\x10\xbe\x17\x12\x1a\n\x15k_EMsgGCClientWelcome\x10\xa4\x1f\x12\
    \x1a\n\x15k_EMsgGCServerWelcome\x10\xa5\x1f\x12\x18\n\x13k_EMsgGCClientH\
    ello\x10\xa6\x1f\x12\x18\n\x13k_EMsgGCServerHello\x10\xa7\x1f\x12#\n\x1e\
    k_EMsgGCClientConnectionStatus\x10\xa9\x1f\x12#\n\x1ek_EMsgGCServerConne\
    ctionStatus\x10\xaa\x1fB%Z#github.com/dotabuff/manta/dota;dotaJ\xbe\x07\
    \n\x06\x12\x04\0\0\x1e\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\
    \x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\
    \x0b\x12\x03\x03\0:\n\n\n\x02\x05\0\x12\x04\x05\0\x0e\x01\n\n\n\x03\x05\
    \0\x01\x12\x03\x05\x05\x0b\n\x0b\n\x04\x05\0\x02\0\x12\x03\x06\x08\x1d\n\
    \x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\x08\x17\n\x0c\n\x05\x05\0\x02\0\
    \x02\x12\x03\x06\x1a\x1c\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\x08\x1d\n\
    \x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x08\x17\n\x0c\n\x05\x05\0\x02\
    \x01\x02\x12\x03\x07\x1a\x1c\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\x08\
    \x1e\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x08\x08\x18\n\x0c\n\x05\x05\0\
    \x02\x02\x02\x12\x03\x08\x1b\x1d\n\x0b\n\x04\x05\0\x02\x03\x12\x03\t\x08\
    &\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\t\x08\x20\n\x0c\n\x05\x05\0\x02\
    \x03\x02\x12\x03\t#%\n\x0b\n\x04\x05\0\x02\x04\x12\x03\n\x08(\n\x0c\n\
    \x05\x05\0\x02\x04\x01\x12\x03\n\x08\"\n\x0c\n\x05\x05\0\x02\x04\x02\x12\
    \x03\n%'\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x0b\x08%\n\x0c\n\x05\x05\0\
    \x02\x05\x01\x12\x03\x0b\x08\x1f\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\
    \x0b\"$\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x0c\x08/\n\x0c\n\x05\x05\0\x02\
    \x06\x01\x12\x03\x0c\x08)\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0c,.\n\
    \x0b\n\x04\x05\0\x02\x07\x12\x03\r\x08.\n\x0c\n\x05\x05\0\x02\x07\x01\
    \x12\x03\r\x08(\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\r+-\n\n\n\x02\x05\
    \x01\x12\x04\x10\0\x1e\x01\n\n\n\x03\x05\x01\x01\x12\x03\x10\x05\x15\n\
    \x0b\n\x04\x05\x01\x02\0\x12\x03\x11\x08#\n\x0c\n\x05\x05\x01\x02\0\x01\
    \x12\x03\x11\x08\x1b\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x11\x1e\"\n\
    \x0b\n\x04\x05\x01\x02\x01\x12\x03\x12\x08$\n\x0c\n\x05\x05\x01\x02\x01\
    \x01\x12\x03\x12\x08\x1c\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x12\x1f\
    #\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\x13\x081\n\x0c\n\x05\x05\x01\x02\
    \x02\x01\x12\x03\x13\x08)\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\x13,0\
    \n\x0b\n\x04\x05\x01\x02\x03\x12\x03\x14\x082\n\x0c\n\x05\x05\x01\x02\
    \x03\x01\x12\x03\x14\x08*\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\x14-1\
    \n\x0b\n\x04\x05\x01\x02\x04\x12\x03\x15\x08-\n\x0c\n\x05\x05\x01\x02\
    \x04\x01\x12\x03\x15\x08%\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03\x15(,\
    \n\x0b\n\x04\x05\x01\x02\x05\x12\x03\x16\x083\n\x0c\n\x05\x05\x01\x02\
    \x05\x01\x12\x03\x16\x08,\n\x0c\n\x05\x05\x01\x02\x05\x02\x12\x03\x16/2\
    \n\x0b\n\x04\x05\x01\x02\x06\x12\x03\x17\x08.\n\x0c\n\x05\x05\x01\x02\
    \x06\x01\x12\x03\x17\x08&\n\x0c\n\x05\x05\x01\x02\x06\x02\x12\x03\x17)-\
    \n\x0b\n\x04\x05\x01\x02\x07\x12\x03\x18\x08%\n\x0c\n\x05\x05\x01\x02\
    \x07\x01\x12\x03\x18\x08\x1d\n\x0c\n\x05\x05\x01\x02\x07\x02\x12\x03\x18\
    \x20$\n\x0b\n\x04\x05\x01\x02\x08\x12\x03\x19\x08%\n\x0c\n\x05\x05\x01\
    \x02\x08\x01\x12\x03\x19\x08\x1d\n\x0c\n\x05\x05\x01\x02\x08\x02\x12\x03\
    \x19\x20$\n\x0b\n\x04\x05\x01\x02\t\x12\x03\x1a\x08#\n\x0c\n\x05\x05\x01\
    \x02\t\x01\x12\x03\x1a\x08\x1b\n\x0c\n\x05\x05\x01\x02\t\x02\x12\x03\x1a\
    \x1e\"\n\x0b\n\x04\x05\x01\x02\n\x12\x03\x1b\x08#\n\x0c\n\x05\x05\x01\
    \x02\n\x01\x12\x03\x1b\x08\x1b\n\x0c\n\x05\x05\x01\x02\n\x02\x12\x03\x1b\
    \x1e\"\n\x0b\n\x04\x05\x01\x02\x0b\x12\x03\x1c\x08.\n\x0c\n\x05\x05\x01\
    \x02\x0b\x01\x12\x03\x1c\x08&\n\x0c\n\x05\x05\x01\x02\x0b\x02\x12\x03\
    \x1c)-\n\x0b\n\x04\x05\x01\x02\x0c\x12\x03\x1d\x08.\n\x0c\n\x05\x05\x01\
    \x02\x0c\x01\x12\x03\x1d\x08&\n\x0c\n\x05\x05\x01\x02\x0c\x02\x12\x03\
    \x1d)-\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(0);
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(ESOMsg::generated_enum_descriptor_data());
            enums.push(EGCBaseClientMsg::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
