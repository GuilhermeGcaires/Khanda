// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_common_lobby.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgLobbyCoachFriendRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyCoachFriendRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyCoachFriendRequest.coach_account_id)
    pub coach_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyCoachFriendRequest.player_account_id)
    pub player_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyCoachFriendRequest.request_state)
    pub request_state: ::std::option::Option<::protobuf::EnumOrUnknown<ELobbyMemberCoachRequestState>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyCoachFriendRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyCoachFriendRequest {
    fn default() -> &'a CMsgLobbyCoachFriendRequest {
        <CMsgLobbyCoachFriendRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyCoachFriendRequest {
    pub fn new() -> CMsgLobbyCoachFriendRequest {
        ::std::default::Default::default()
    }

    // optional uint32 coach_account_id = 1;

    pub fn coach_account_id(&self) -> u32 {
        self.coach_account_id.unwrap_or(0)
    }

    pub fn clear_coach_account_id(&mut self) {
        self.coach_account_id = ::std::option::Option::None;
    }

    pub fn has_coach_account_id(&self) -> bool {
        self.coach_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_account_id(&mut self, v: u32) {
        self.coach_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 player_account_id = 2;

    pub fn player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    // optional .dota.ELobbyMemberCoachRequestState request_state = 3;

    pub fn request_state(&self) -> ELobbyMemberCoachRequestState {
        match self.request_state {
            Some(e) => e.enum_value_or(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None),
            None => ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None,
        }
    }

    pub fn clear_request_state(&mut self) {
        self.request_state = ::std::option::Option::None;
    }

    pub fn has_request_state(&self) -> bool {
        self.request_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_state(&mut self, v: ELobbyMemberCoachRequestState) {
        self.request_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coach_account_id",
            |m: &CMsgLobbyCoachFriendRequest| { &m.coach_account_id },
            |m: &mut CMsgLobbyCoachFriendRequest| { &mut m.coach_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_account_id",
            |m: &CMsgLobbyCoachFriendRequest| { &m.player_account_id },
            |m: &mut CMsgLobbyCoachFriendRequest| { &mut m.player_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_state",
            |m: &CMsgLobbyCoachFriendRequest| { &m.request_state },
            |m: &mut CMsgLobbyCoachFriendRequest| { &mut m.request_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyCoachFriendRequest>(
            "CMsgLobbyCoachFriendRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyCoachFriendRequest {
    const NAME: &'static str = "CMsgLobbyCoachFriendRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coach_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.request_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coach_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.request_state {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coach_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.request_state {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyCoachFriendRequest {
        CMsgLobbyCoachFriendRequest::new()
    }

    fn clear(&mut self) {
        self.coach_account_id = ::std::option::Option::None;
        self.player_account_id = ::std::option::Option::None;
        self.request_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyCoachFriendRequest {
        static instance: CMsgLobbyCoachFriendRequest = CMsgLobbyCoachFriendRequest {
            coach_account_id: ::std::option::Option::None,
            player_account_id: ::std::option::Option::None,
            request_state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyCoachFriendRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyCoachFriendRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyCoachFriendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyCoachFriendRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLobbyPlayerPlusSubscriptionData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyPlayerPlusSubscriptionData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyPlayerPlusSubscriptionData.hero_badges)
    pub hero_badges: ::std::vec::Vec<cmsg_lobby_player_plus_subscription_data::HeroBadge>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyPlayerPlusSubscriptionData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyPlayerPlusSubscriptionData {
    fn default() -> &'a CMsgLobbyPlayerPlusSubscriptionData {
        <CMsgLobbyPlayerPlusSubscriptionData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyPlayerPlusSubscriptionData {
    pub fn new() -> CMsgLobbyPlayerPlusSubscriptionData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hero_badges",
            |m: &CMsgLobbyPlayerPlusSubscriptionData| { &m.hero_badges },
            |m: &mut CMsgLobbyPlayerPlusSubscriptionData| { &mut m.hero_badges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyPlayerPlusSubscriptionData>(
            "CMsgLobbyPlayerPlusSubscriptionData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyPlayerPlusSubscriptionData {
    const NAME: &'static str = "CMsgLobbyPlayerPlusSubscriptionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hero_badges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_badges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hero_badges {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyPlayerPlusSubscriptionData {
        CMsgLobbyPlayerPlusSubscriptionData::new()
    }

    fn clear(&mut self) {
        self.hero_badges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyPlayerPlusSubscriptionData {
        static instance: CMsgLobbyPlayerPlusSubscriptionData = CMsgLobbyPlayerPlusSubscriptionData {
            hero_badges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyPlayerPlusSubscriptionData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyPlayerPlusSubscriptionData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyPlayerPlusSubscriptionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyPlayerPlusSubscriptionData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgLobbyPlayerPlusSubscriptionData`
pub mod cmsg_lobby_player_plus_subscription_data {
    // @@protoc_insertion_point(message:dota.CMsgLobbyPlayerPlusSubscriptionData.HeroBadge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroBadge {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgLobbyPlayerPlusSubscriptionData.HeroBadge.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyPlayerPlusSubscriptionData.HeroBadge.hero_badge_xp)
        pub hero_badge_xp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgLobbyPlayerPlusSubscriptionData.HeroBadge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroBadge {
        fn default() -> &'a HeroBadge {
            <HeroBadge as ::protobuf::Message>::default_instance()
        }
    }

    impl HeroBadge {
        pub fn new() -> HeroBadge {
            ::std::default::Default::default()
        }

        // optional uint32 hero_id = 1;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_badge_xp = 2;

        pub fn hero_badge_xp(&self) -> u32 {
            self.hero_badge_xp.unwrap_or(0)
        }

        pub fn clear_hero_badge_xp(&mut self) {
            self.hero_badge_xp = ::std::option::Option::None;
        }

        pub fn has_hero_badge_xp(&self) -> bool {
            self.hero_badge_xp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_badge_xp(&mut self, v: u32) {
            self.hero_badge_xp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &HeroBadge| { &m.hero_id },
                |m: &mut HeroBadge| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_badge_xp",
                |m: &HeroBadge| { &m.hero_badge_xp },
                |m: &mut HeroBadge| { &mut m.hero_badge_xp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroBadge>(
                "CMsgLobbyPlayerPlusSubscriptionData.HeroBadge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HeroBadge {
        const NAME: &'static str = "HeroBadge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_badge_xp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_badge_xp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_badge_xp {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroBadge {
            HeroBadge::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.hero_badge_xp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroBadge {
            static instance: HeroBadge = HeroBadge {
                hero_id: ::std::option::Option::None,
                hero_badge_xp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HeroBadge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLobbyPlayerPlusSubscriptionData.HeroBadge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HeroBadge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HeroBadge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgLobbyEventPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyEventPoints {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.account_points)
    pub account_points: ::std::vec::Vec<cmsg_lobby_event_points::AccountPoints>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyEventPoints.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyEventPoints {
    fn default() -> &'a CMsgLobbyEventPoints {
        <CMsgLobbyEventPoints as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyEventPoints {
    pub fn new() -> CMsgLobbyEventPoints {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgLobbyEventPoints| { &m.event_id },
            |m: &mut CMsgLobbyEventPoints| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_points",
            |m: &CMsgLobbyEventPoints| { &m.account_points },
            |m: &mut CMsgLobbyEventPoints| { &mut m.account_points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyEventPoints>(
            "CMsgLobbyEventPoints",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyEventPoints {
    const NAME: &'static str = "CMsgLobbyEventPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.account_points.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_points {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyEventPoints {
        CMsgLobbyEventPoints::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.account_points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyEventPoints {
        static instance: CMsgLobbyEventPoints = CMsgLobbyEventPoints {
            event_id: ::std::option::Option::None,
            account_points: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyEventPoints {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyEventPoints").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyEventPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyEventPoints {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgLobbyEventPoints`
pub mod cmsg_lobby_event_points {
    // @@protoc_insertion_point(message:dota.CMsgLobbyEventPoints.PeriodicResourceData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PeriodicResourceData {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.PeriodicResourceData.periodic_resource_id)
        pub periodic_resource_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.PeriodicResourceData.remaining)
        pub remaining: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.PeriodicResourceData.max)
        pub max: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgLobbyEventPoints.PeriodicResourceData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PeriodicResourceData {
        fn default() -> &'a PeriodicResourceData {
            <PeriodicResourceData as ::protobuf::Message>::default_instance()
        }
    }

    impl PeriodicResourceData {
        pub fn new() -> PeriodicResourceData {
            ::std::default::Default::default()
        }

        // optional uint32 periodic_resource_id = 1;

        pub fn periodic_resource_id(&self) -> u32 {
            self.periodic_resource_id.unwrap_or(0)
        }

        pub fn clear_periodic_resource_id(&mut self) {
            self.periodic_resource_id = ::std::option::Option::None;
        }

        pub fn has_periodic_resource_id(&self) -> bool {
            self.periodic_resource_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_periodic_resource_id(&mut self, v: u32) {
            self.periodic_resource_id = ::std::option::Option::Some(v);
        }

        // optional uint32 remaining = 2;

        pub fn remaining(&self) -> u32 {
            self.remaining.unwrap_or(0)
        }

        pub fn clear_remaining(&mut self) {
            self.remaining = ::std::option::Option::None;
        }

        pub fn has_remaining(&self) -> bool {
            self.remaining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_remaining(&mut self, v: u32) {
            self.remaining = ::std::option::Option::Some(v);
        }

        // optional uint32 max = 3;

        pub fn max(&self) -> u32 {
            self.max.unwrap_or(0)
        }

        pub fn clear_max(&mut self) {
            self.max = ::std::option::Option::None;
        }

        pub fn has_max(&self) -> bool {
            self.max.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max(&mut self, v: u32) {
            self.max = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "periodic_resource_id",
                |m: &PeriodicResourceData| { &m.periodic_resource_id },
                |m: &mut PeriodicResourceData| { &mut m.periodic_resource_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "remaining",
                |m: &PeriodicResourceData| { &m.remaining },
                |m: &mut PeriodicResourceData| { &mut m.remaining },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max",
                |m: &PeriodicResourceData| { &m.max },
                |m: &mut PeriodicResourceData| { &mut m.max },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeriodicResourceData>(
                "CMsgLobbyEventPoints.PeriodicResourceData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PeriodicResourceData {
        const NAME: &'static str = "PeriodicResourceData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.periodic_resource_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.remaining = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.max = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.periodic_resource_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.remaining {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.max {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.periodic_resource_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.remaining {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.max {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PeriodicResourceData {
            PeriodicResourceData::new()
        }

        fn clear(&mut self) {
            self.periodic_resource_id = ::std::option::Option::None;
            self.remaining = ::std::option::Option::None;
            self.max = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PeriodicResourceData {
            static instance: PeriodicResourceData = PeriodicResourceData {
                periodic_resource_id: ::std::option::Option::None,
                remaining: ::std::option::Option::None,
                max: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PeriodicResourceData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLobbyEventPoints.PeriodicResourceData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PeriodicResourceData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PeriodicResourceData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgLobbyEventPoints.NetworkedEventAction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NetworkedEventAction {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.NetworkedEventAction.action_id)
        pub action_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.NetworkedEventAction.times_granted)
        pub times_granted: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgLobbyEventPoints.NetworkedEventAction.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NetworkedEventAction {
        fn default() -> &'a NetworkedEventAction {
            <NetworkedEventAction as ::protobuf::Message>::default_instance()
        }
    }

    impl NetworkedEventAction {
        pub fn new() -> NetworkedEventAction {
            ::std::default::Default::default()
        }

        // optional uint32 action_id = 1;

        pub fn action_id(&self) -> u32 {
            self.action_id.unwrap_or(0)
        }

        pub fn clear_action_id(&mut self) {
            self.action_id = ::std::option::Option::None;
        }

        pub fn has_action_id(&self) -> bool {
            self.action_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action_id(&mut self, v: u32) {
            self.action_id = ::std::option::Option::Some(v);
        }

        // optional uint32 times_granted = 2;

        pub fn times_granted(&self) -> u32 {
            self.times_granted.unwrap_or(0)
        }

        pub fn clear_times_granted(&mut self) {
            self.times_granted = ::std::option::Option::None;
        }

        pub fn has_times_granted(&self) -> bool {
            self.times_granted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_times_granted(&mut self, v: u32) {
            self.times_granted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "action_id",
                |m: &NetworkedEventAction| { &m.action_id },
                |m: &mut NetworkedEventAction| { &mut m.action_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "times_granted",
                |m: &NetworkedEventAction| { &m.times_granted },
                |m: &mut NetworkedEventAction| { &mut m.times_granted },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkedEventAction>(
                "CMsgLobbyEventPoints.NetworkedEventAction",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NetworkedEventAction {
        const NAME: &'static str = "NetworkedEventAction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.times_granted = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.action_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.times_granted {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.action_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.times_granted {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NetworkedEventAction {
            NetworkedEventAction::new()
        }

        fn clear(&mut self) {
            self.action_id = ::std::option::Option::None;
            self.times_granted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NetworkedEventAction {
            static instance: NetworkedEventAction = NetworkedEventAction {
                action_id: ::std::option::Option::None,
                times_granted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NetworkedEventAction {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLobbyEventPoints.NetworkedEventAction").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NetworkedEventAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NetworkedEventAction {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgLobbyEventPoints.AccountPoints)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AccountPoints {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.normal_points)
        pub normal_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.premium_points)
        pub premium_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.owned)
        pub owned: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.active_effects_mask)
        pub active_effects_mask: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.wager_streak)
        pub wager_streak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.event_game_custom_actions)
        pub event_game_custom_actions: ::std::vec::Vec<NetworkedEventAction>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.tip_amount_index)
        pub tip_amount_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.active_event_season_id)
        pub active_event_season_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.teleport_fx_level)
        pub teleport_fx_level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.networked_event_actions)
        pub networked_event_actions: ::std::vec::Vec<NetworkedEventAction>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyEventPoints.AccountPoints.periodic_resources)
        pub periodic_resources: ::std::vec::Vec<PeriodicResourceData>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgLobbyEventPoints.AccountPoints.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AccountPoints {
        fn default() -> &'a AccountPoints {
            <AccountPoints as ::protobuf::Message>::default_instance()
        }
    }

    impl AccountPoints {
        pub fn new() -> AccountPoints {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 normal_points = 2;

        pub fn normal_points(&self) -> u32 {
            self.normal_points.unwrap_or(0)
        }

        pub fn clear_normal_points(&mut self) {
            self.normal_points = ::std::option::Option::None;
        }

        pub fn has_normal_points(&self) -> bool {
            self.normal_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_normal_points(&mut self, v: u32) {
            self.normal_points = ::std::option::Option::Some(v);
        }

        // optional uint32 premium_points = 3;

        pub fn premium_points(&self) -> u32 {
            self.premium_points.unwrap_or(0)
        }

        pub fn clear_premium_points(&mut self) {
            self.premium_points = ::std::option::Option::None;
        }

        pub fn has_premium_points(&self) -> bool {
            self.premium_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_premium_points(&mut self, v: u32) {
            self.premium_points = ::std::option::Option::Some(v);
        }

        // optional bool owned = 4;

        pub fn owned(&self) -> bool {
            self.owned.unwrap_or(false)
        }

        pub fn clear_owned(&mut self) {
            self.owned = ::std::option::Option::None;
        }

        pub fn has_owned(&self) -> bool {
            self.owned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owned(&mut self, v: bool) {
            self.owned = ::std::option::Option::Some(v);
        }

        // optional uint64 active_effects_mask = 12;

        pub fn active_effects_mask(&self) -> u64 {
            self.active_effects_mask.unwrap_or(0)
        }

        pub fn clear_active_effects_mask(&mut self) {
            self.active_effects_mask = ::std::option::Option::None;
        }

        pub fn has_active_effects_mask(&self) -> bool {
            self.active_effects_mask.is_some()
        }

        // Param is passed by value, moved
        pub fn set_active_effects_mask(&mut self, v: u64) {
            self.active_effects_mask = ::std::option::Option::Some(v);
        }

        // optional uint32 wager_streak = 23;

        pub fn wager_streak(&self) -> u32 {
            self.wager_streak.unwrap_or(0)
        }

        pub fn clear_wager_streak(&mut self) {
            self.wager_streak = ::std::option::Option::None;
        }

        pub fn has_wager_streak(&self) -> bool {
            self.wager_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager_streak(&mut self, v: u32) {
            self.wager_streak = ::std::option::Option::Some(v);
        }

        // optional uint32 tip_amount_index = 26;

        pub fn tip_amount_index(&self) -> u32 {
            self.tip_amount_index.unwrap_or(0)
        }

        pub fn clear_tip_amount_index(&mut self) {
            self.tip_amount_index = ::std::option::Option::None;
        }

        pub fn has_tip_amount_index(&self) -> bool {
            self.tip_amount_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tip_amount_index(&mut self, v: u32) {
            self.tip_amount_index = ::std::option::Option::Some(v);
        }

        // optional uint32 active_event_season_id = 27;

        pub fn active_event_season_id(&self) -> u32 {
            self.active_event_season_id.unwrap_or(0)
        }

        pub fn clear_active_event_season_id(&mut self) {
            self.active_event_season_id = ::std::option::Option::None;
        }

        pub fn has_active_event_season_id(&self) -> bool {
            self.active_event_season_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_active_event_season_id(&mut self, v: u32) {
            self.active_event_season_id = ::std::option::Option::Some(v);
        }

        // optional uint32 teleport_fx_level = 28;

        pub fn teleport_fx_level(&self) -> u32 {
            self.teleport_fx_level.unwrap_or(0)
        }

        pub fn clear_teleport_fx_level(&mut self) {
            self.teleport_fx_level = ::std::option::Option::None;
        }

        pub fn has_teleport_fx_level(&self) -> bool {
            self.teleport_fx_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teleport_fx_level(&mut self, v: u32) {
            self.teleport_fx_level = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(12);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &AccountPoints| { &m.account_id },
                |m: &mut AccountPoints| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "normal_points",
                |m: &AccountPoints| { &m.normal_points },
                |m: &mut AccountPoints| { &mut m.normal_points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "premium_points",
                |m: &AccountPoints| { &m.premium_points },
                |m: &mut AccountPoints| { &mut m.premium_points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "owned",
                |m: &AccountPoints| { &m.owned },
                |m: &mut AccountPoints| { &mut m.owned },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "active_effects_mask",
                |m: &AccountPoints| { &m.active_effects_mask },
                |m: &mut AccountPoints| { &mut m.active_effects_mask },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wager_streak",
                |m: &AccountPoints| { &m.wager_streak },
                |m: &mut AccountPoints| { &mut m.wager_streak },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "event_game_custom_actions",
                |m: &AccountPoints| { &m.event_game_custom_actions },
                |m: &mut AccountPoints| { &mut m.event_game_custom_actions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tip_amount_index",
                |m: &AccountPoints| { &m.tip_amount_index },
                |m: &mut AccountPoints| { &mut m.tip_amount_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "active_event_season_id",
                |m: &AccountPoints| { &m.active_event_season_id },
                |m: &mut AccountPoints| { &mut m.active_event_season_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teleport_fx_level",
                |m: &AccountPoints| { &m.teleport_fx_level },
                |m: &mut AccountPoints| { &mut m.teleport_fx_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "networked_event_actions",
                |m: &AccountPoints| { &m.networked_event_actions },
                |m: &mut AccountPoints| { &mut m.networked_event_actions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "periodic_resources",
                |m: &AccountPoints| { &m.periodic_resources },
                |m: &mut AccountPoints| { &mut m.periodic_resources },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountPoints>(
                "CMsgLobbyEventPoints.AccountPoints",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AccountPoints {
        const NAME: &'static str = "AccountPoints";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.normal_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.premium_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.owned = ::std::option::Option::Some(is.read_bool()?);
                    },
                    96 => {
                        self.active_effects_mask = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    184 => {
                        self.wager_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    202 => {
                        self.event_game_custom_actions.push(is.read_message()?);
                    },
                    208 => {
                        self.tip_amount_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    216 => {
                        self.active_event_season_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    224 => {
                        self.teleport_fx_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    242 => {
                        self.networked_event_actions.push(is.read_message()?);
                    },
                    250 => {
                        self.periodic_resources.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.normal_points {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.premium_points {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.owned {
                my_size += 1 + 1;
            }
            if let Some(v) = self.active_effects_mask {
                my_size += ::protobuf::rt::uint64_size(12, v);
            }
            if let Some(v) = self.wager_streak {
                my_size += ::protobuf::rt::uint32_size(23, v);
            }
            for value in &self.event_game_custom_actions {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.tip_amount_index {
                my_size += ::protobuf::rt::uint32_size(26, v);
            }
            if let Some(v) = self.active_event_season_id {
                my_size += ::protobuf::rt::uint32_size(27, v);
            }
            if let Some(v) = self.teleport_fx_level {
                my_size += ::protobuf::rt::uint32_size(28, v);
            }
            for value in &self.networked_event_actions {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.periodic_resources {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.normal_points {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.premium_points {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.owned {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.active_effects_mask {
                os.write_uint64(12, v)?;
            }
            if let Some(v) = self.wager_streak {
                os.write_uint32(23, v)?;
            }
            for v in &self.event_game_custom_actions {
                ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
            };
            if let Some(v) = self.tip_amount_index {
                os.write_uint32(26, v)?;
            }
            if let Some(v) = self.active_event_season_id {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.teleport_fx_level {
                os.write_uint32(28, v)?;
            }
            for v in &self.networked_event_actions {
                ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
            };
            for v in &self.periodic_resources {
                ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AccountPoints {
            AccountPoints::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.normal_points = ::std::option::Option::None;
            self.premium_points = ::std::option::Option::None;
            self.owned = ::std::option::Option::None;
            self.active_effects_mask = ::std::option::Option::None;
            self.wager_streak = ::std::option::Option::None;
            self.event_game_custom_actions.clear();
            self.tip_amount_index = ::std::option::Option::None;
            self.active_event_season_id = ::std::option::Option::None;
            self.teleport_fx_level = ::std::option::Option::None;
            self.networked_event_actions.clear();
            self.periodic_resources.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AccountPoints {
            static instance: AccountPoints = AccountPoints {
                account_id: ::std::option::Option::None,
                normal_points: ::std::option::Option::None,
                premium_points: ::std::option::Option::None,
                owned: ::std::option::Option::None,
                active_effects_mask: ::std::option::Option::None,
                wager_streak: ::std::option::Option::None,
                event_game_custom_actions: ::std::vec::Vec::new(),
                tip_amount_index: ::std::option::Option::None,
                active_event_season_id: ::std::option::Option::None,
                teleport_fx_level: ::std::option::Option::None,
                networked_event_actions: ::std::vec::Vec::new(),
                periodic_resources: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AccountPoints {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLobbyEventPoints.AccountPoints").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AccountPoints {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AccountPoints {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgLobbyEventGameData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyEventGameData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyEventGameData.game_seed)
    pub game_seed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLobbyEventGameData.event_window_start_time)
    pub event_window_start_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyEventGameData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyEventGameData {
    fn default() -> &'a CMsgLobbyEventGameData {
        <CMsgLobbyEventGameData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyEventGameData {
    pub fn new() -> CMsgLobbyEventGameData {
        ::std::default::Default::default()
    }

    // optional uint32 game_seed = 1;

    pub fn game_seed(&self) -> u32 {
        self.game_seed.unwrap_or(0)
    }

    pub fn clear_game_seed(&mut self) {
        self.game_seed = ::std::option::Option::None;
    }

    pub fn has_game_seed(&self) -> bool {
        self.game_seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_seed(&mut self, v: u32) {
        self.game_seed = ::std::option::Option::Some(v);
    }

    // optional uint32 event_window_start_time = 2;

    pub fn event_window_start_time(&self) -> u32 {
        self.event_window_start_time.unwrap_or(0)
    }

    pub fn clear_event_window_start_time(&mut self) {
        self.event_window_start_time = ::std::option::Option::None;
    }

    pub fn has_event_window_start_time(&self) -> bool {
        self.event_window_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_window_start_time(&mut self, v: u32) {
        self.event_window_start_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_seed",
            |m: &CMsgLobbyEventGameData| { &m.game_seed },
            |m: &mut CMsgLobbyEventGameData| { &mut m.game_seed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_window_start_time",
            |m: &CMsgLobbyEventGameData| { &m.event_window_start_time },
            |m: &mut CMsgLobbyEventGameData| { &mut m.event_window_start_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyEventGameData>(
            "CMsgLobbyEventGameData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyEventGameData {
    const NAME: &'static str = "CMsgLobbyEventGameData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_seed = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_window_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_seed {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_window_start_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_seed {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_window_start_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyEventGameData {
        CMsgLobbyEventGameData::new()
    }

    fn clear(&mut self) {
        self.game_seed = ::std::option::Option::None;
        self.event_window_start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyEventGameData {
        static instance: CMsgLobbyEventGameData = CMsgLobbyEventGameData {
            game_seed: ::std::option::Option::None,
            event_window_start_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyEventGameData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyEventGameData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyEventGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyEventGameData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSODOTALobbyInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTALobbyInvite {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.group_id)
    pub group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.sender_name)
    pub sender_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.members)
    pub members: ::std::vec::Vec<csodotalobby_invite::LobbyMember>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.invite_gid)
    pub invite_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTALobbyInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTALobbyInvite {
    fn default() -> &'a CSODOTALobbyInvite {
        <CSODOTALobbyInvite as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTALobbyInvite {
    pub fn new() -> CSODOTALobbyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;

    pub fn group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional string sender_name = 3;

    pub fn sender_name(&self) -> &str {
        match self.sender_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sender_name(&mut self) {
        self.sender_name = ::std::option::Option::None;
    }

    pub fn has_sender_name(&self) -> bool {
        self.sender_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_name(&mut self, v: ::std::string::String) {
        self.sender_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_name(&mut self) -> &mut ::std::string::String {
        if self.sender_name.is_none() {
            self.sender_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sender_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_name(&mut self) -> ::std::string::String {
        self.sender_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 custom_game_id = 5;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 invite_gid = 6;

    pub fn invite_gid(&self) -> u64 {
        self.invite_gid.unwrap_or(0)
    }

    pub fn clear_invite_gid(&mut self) {
        self.invite_gid = ::std::option::Option::None;
    }

    pub fn has_invite_gid(&self) -> bool {
        self.invite_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_gid(&mut self, v: u64) {
        self.invite_gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 custom_game_crc = 7;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 8;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_id",
            |m: &CSODOTALobbyInvite| { &m.group_id },
            |m: &mut CSODOTALobbyInvite| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_id",
            |m: &CSODOTALobbyInvite| { &m.sender_id },
            |m: &mut CSODOTALobbyInvite| { &mut m.sender_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_name",
            |m: &CSODOTALobbyInvite| { &m.sender_name },
            |m: &mut CSODOTALobbyInvite| { &mut m.sender_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CSODOTALobbyInvite| { &m.members },
            |m: &mut CSODOTALobbyInvite| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_id",
            |m: &CSODOTALobbyInvite| { &m.custom_game_id },
            |m: &mut CSODOTALobbyInvite| { &mut m.custom_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_gid",
            |m: &CSODOTALobbyInvite| { &m.invite_gid },
            |m: &mut CSODOTALobbyInvite| { &mut m.invite_gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_crc",
            |m: &CSODOTALobbyInvite| { &m.custom_game_crc },
            |m: &mut CSODOTALobbyInvite| { &mut m.custom_game_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_timestamp",
            |m: &CSODOTALobbyInvite| { &m.custom_game_timestamp },
            |m: &mut CSODOTALobbyInvite| { &mut m.custom_game_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTALobbyInvite>(
            "CSODOTALobbyInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTALobbyInvite {
    const NAME: &'static str = "CSODOTALobbyInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.sender_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.members.push(is.read_message()?);
                },
                40 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                49 => {
                    self.invite_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                57 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                69 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sender_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.invite_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.sender_name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.custom_game_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.invite_gid {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTALobbyInvite {
        CSODOTALobbyInvite::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.sender_name = ::std::option::Option::None;
        self.members.clear();
        self.custom_game_id = ::std::option::Option::None;
        self.invite_gid = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTALobbyInvite {
        static instance: CSODOTALobbyInvite = CSODOTALobbyInvite {
            group_id: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            sender_name: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            custom_game_id: ::std::option::Option::None,
            invite_gid: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTALobbyInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTALobbyInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTALobbyInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTALobbyInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSODOTALobbyInvite`
pub mod csodotalobby_invite {
    // @@protoc_insertion_point(message:dota.CSODOTALobbyInvite.LobbyMember)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LobbyMember {
        // message fields
        // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.LobbyMember.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CSODOTALobbyInvite.LobbyMember.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CSODOTALobbyInvite.LobbyMember.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LobbyMember {
        fn default() -> &'a LobbyMember {
            <LobbyMember as ::protobuf::Message>::default_instance()
        }
    }

    impl LobbyMember {
        pub fn new() -> LobbyMember {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 steam_id = 2;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &LobbyMember| { &m.name },
                |m: &mut LobbyMember| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &LobbyMember| { &m.steam_id },
                |m: &mut LobbyMember| { &mut m.steam_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LobbyMember>(
                "CSODOTALobbyInvite.LobbyMember",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LobbyMember {
        const NAME: &'static str = "LobbyMember";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    17 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.steam_id {
                os.write_fixed64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LobbyMember {
            LobbyMember::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.steam_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LobbyMember {
            static instance: LobbyMember = LobbyMember {
                name: ::std::option::Option::None,
                steam_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LobbyMember {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSODOTALobbyInvite.LobbyMember").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LobbyMember {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LobbyMember {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CSODOTALobbyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTALobbyMember {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.team)
    pub team: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.slot)
    pub slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.meta_level)
    pub meta_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.meta_xp)
    pub meta_xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.meta_xp_awarded)
    pub meta_xp_awarded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.leaver_status)
    pub leaver_status: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALeaverStatus_t>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.leaver_actions)
    pub leaver_actions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.disabled_hero_id)
    pub disabled_hero_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.enabled_hero_id)
    pub enabled_hero_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.coach_team)
    pub coach_team: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.coached_account_ids)
    pub coached_account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.coach_rating)
    pub coach_rating: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.pwrd_cyber_cafe_id)
    pub pwrd_cyber_cafe_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.pwrd_cyber_cafe_name)
    pub pwrd_cyber_cafe_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.disabled_random_hero_bits)
    pub disabled_random_hero_bits: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.rank_change)
    pub rank_change: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.cameraman)
    pub cameraman: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.custom_game_product_ids)
    pub custom_game_product_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.search_match_type)
    pub search_match_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchType>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.favorite_team_packed)
    pub favorite_team_packed: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.is_plus_subscriber)
    pub is_plus_subscriber: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.can_earn_rewards)
    pub can_earn_rewards: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.live_spectator_team)
    pub live_spectator_team: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.was_mvp_last_game)
    pub was_mvp_last_game: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.pending_awards)
    pub pending_awards: ::std::vec::Vec<super::dota_shared_enums::CMsgPendingEventAward>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.pending_awards_on_victory)
    pub pending_awards_on_victory: ::std::vec::Vec<super::dota_shared_enums::CMsgPendingEventAward>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.rank_mmr_boost_type)
    pub rank_mmr_boost_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EDOTAMMRBoostType>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.queue_point_adjustment)
    pub queue_point_adjustment: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.rank_tier)
    pub rank_tier: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.title)
    pub title: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.reports_available)
    pub reports_available: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.is_steam_china)
    pub is_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.live_spectator_account_id)
    pub live_spectator_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobbyMember.comms_reports_available)
    pub comms_reports_available: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTALobbyMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTALobbyMember {
    fn default() -> &'a CSODOTALobbyMember {
        <CSODOTALobbyMember as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTALobbyMember {
    pub fn new() -> CSODOTALobbyMember {
        ::std::default::Default::default()
    }

    // optional fixed64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 2;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GC_TEAM team = 3;

    pub fn team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string name = 6;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 slot = 7;

    pub fn slot(&self) -> u32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: u32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional uint64 party_id = 12;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional uint32 meta_level = 13;

    pub fn meta_level(&self) -> u32 {
        self.meta_level.unwrap_or(0)
    }

    pub fn clear_meta_level(&mut self) {
        self.meta_level = ::std::option::Option::None;
    }

    pub fn has_meta_level(&self) -> bool {
        self.meta_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_level(&mut self, v: u32) {
        self.meta_level = ::std::option::Option::Some(v);
    }

    // optional uint32 meta_xp = 14;

    pub fn meta_xp(&self) -> u32 {
        self.meta_xp.unwrap_or(0)
    }

    pub fn clear_meta_xp(&mut self) {
        self.meta_xp = ::std::option::Option::None;
    }

    pub fn has_meta_xp(&self) -> bool {
        self.meta_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_xp(&mut self, v: u32) {
        self.meta_xp = ::std::option::Option::Some(v);
    }

    // optional uint32 meta_xp_awarded = 15;

    pub fn meta_xp_awarded(&self) -> u32 {
        self.meta_xp_awarded.unwrap_or(0)
    }

    pub fn clear_meta_xp_awarded(&mut self) {
        self.meta_xp_awarded = ::std::option::Option::None;
    }

    pub fn has_meta_xp_awarded(&self) -> bool {
        self.meta_xp_awarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_xp_awarded(&mut self, v: u32) {
        self.meta_xp_awarded = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTALeaverStatus_t leaver_status = 16;

    pub fn leaver_status(&self) -> super::dota_shared_enums::DOTALeaverStatus_t {
        match self.leaver_status {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALeaverStatus_t::DOTA_LEAVER_NONE),
            None => super::dota_shared_enums::DOTALeaverStatus_t::DOTA_LEAVER_NONE,
        }
    }

    pub fn clear_leaver_status(&mut self) {
        self.leaver_status = ::std::option::Option::None;
    }

    pub fn has_leaver_status(&self) -> bool {
        self.leaver_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_status(&mut self, v: super::dota_shared_enums::DOTALeaverStatus_t) {
        self.leaver_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 leaver_actions = 28;

    pub fn leaver_actions(&self) -> u32 {
        self.leaver_actions.unwrap_or(0)
    }

    pub fn clear_leaver_actions(&mut self) {
        self.leaver_actions = ::std::option::Option::None;
    }

    pub fn has_leaver_actions(&self) -> bool {
        self.leaver_actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_actions(&mut self, v: u32) {
        self.leaver_actions = ::std::option::Option::Some(v);
    }

    // optional uint32 channel = 17;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GC_TEAM coach_team = 23;

    pub fn coach_team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.coach_team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_coach_team(&mut self) {
        self.coach_team = ::std::option::Option::None;
    }

    pub fn has_coach_team(&self) -> bool {
        self.coach_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.coach_team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 coach_rating = 42;

    pub fn coach_rating(&self) -> u32 {
        self.coach_rating.unwrap_or(0)
    }

    pub fn clear_coach_rating(&mut self) {
        self.coach_rating = ::std::option::Option::None;
    }

    pub fn has_coach_rating(&self) -> bool {
        self.coach_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_rating(&mut self, v: u32) {
        self.coach_rating = ::std::option::Option::Some(v);
    }

    // optional uint32 pwrd_cyber_cafe_id = 24;

    pub fn pwrd_cyber_cafe_id(&self) -> u32 {
        self.pwrd_cyber_cafe_id.unwrap_or(0)
    }

    pub fn clear_pwrd_cyber_cafe_id(&mut self) {
        self.pwrd_cyber_cafe_id = ::std::option::Option::None;
    }

    pub fn has_pwrd_cyber_cafe_id(&self) -> bool {
        self.pwrd_cyber_cafe_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pwrd_cyber_cafe_id(&mut self, v: u32) {
        self.pwrd_cyber_cafe_id = ::std::option::Option::Some(v);
    }

    // optional string pwrd_cyber_cafe_name = 25;

    pub fn pwrd_cyber_cafe_name(&self) -> &str {
        match self.pwrd_cyber_cafe_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pwrd_cyber_cafe_name(&mut self) {
        self.pwrd_cyber_cafe_name = ::std::option::Option::None;
    }

    pub fn has_pwrd_cyber_cafe_name(&self) -> bool {
        self.pwrd_cyber_cafe_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pwrd_cyber_cafe_name(&mut self, v: ::std::string::String) {
        self.pwrd_cyber_cafe_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pwrd_cyber_cafe_name(&mut self) -> &mut ::std::string::String {
        if self.pwrd_cyber_cafe_name.is_none() {
            self.pwrd_cyber_cafe_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pwrd_cyber_cafe_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_pwrd_cyber_cafe_name(&mut self) -> ::std::string::String {
        self.pwrd_cyber_cafe_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 rank_change = 29;

    pub fn rank_change(&self) -> i32 {
        self.rank_change.unwrap_or(0)
    }

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: i32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional bool cameraman = 30;

    pub fn cameraman(&self) -> bool {
        self.cameraman.unwrap_or(false)
    }

    pub fn clear_cameraman(&mut self) {
        self.cameraman = ::std::option::Option::None;
    }

    pub fn has_cameraman(&self) -> bool {
        self.cameraman.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cameraman(&mut self, v: bool) {
        self.cameraman = ::std::option::Option::Some(v);
    }

    // optional .dota.MatchType search_match_type = 33;

    pub fn search_match_type(&self) -> super::dota_shared_enums::MatchType {
        match self.search_match_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL),
            None => super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL,
        }
    }

    pub fn clear_search_match_type(&mut self) {
        self.search_match_type = ::std::option::Option::None;
    }

    pub fn has_search_match_type(&self) -> bool {
        self.search_match_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_match_type(&mut self, v: super::dota_shared_enums::MatchType) {
        self.search_match_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 favorite_team_packed = 35;

    pub fn favorite_team_packed(&self) -> u64 {
        self.favorite_team_packed.unwrap_or(0)
    }

    pub fn clear_favorite_team_packed(&mut self) {
        self.favorite_team_packed = ::std::option::Option::None;
    }

    pub fn has_favorite_team_packed(&self) -> bool {
        self.favorite_team_packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_packed(&mut self, v: u64) {
        self.favorite_team_packed = ::std::option::Option::Some(v);
    }

    // optional bool is_plus_subscriber = 36;

    pub fn is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.unwrap_or(false)
    }

    pub fn clear_is_plus_subscriber(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
    }

    pub fn has_is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_subscriber(&mut self, v: bool) {
        self.is_plus_subscriber = ::std::option::Option::Some(v);
    }

    // optional uint32 lane_selection_flags = 38;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional bool can_earn_rewards = 39;

    pub fn can_earn_rewards(&self) -> bool {
        self.can_earn_rewards.unwrap_or(false)
    }

    pub fn clear_can_earn_rewards(&mut self) {
        self.can_earn_rewards = ::std::option::Option::None;
    }

    pub fn has_can_earn_rewards(&self) -> bool {
        self.can_earn_rewards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_earn_rewards(&mut self, v: bool) {
        self.can_earn_rewards = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GC_TEAM live_spectator_team = 40;

    pub fn live_spectator_team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.live_spectator_team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_live_spectator_team(&mut self) {
        self.live_spectator_team = ::std::option::Option::None;
    }

    pub fn has_live_spectator_team(&self) -> bool {
        self.live_spectator_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live_spectator_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.live_spectator_team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool was_mvp_last_game = 43;

    pub fn was_mvp_last_game(&self) -> bool {
        self.was_mvp_last_game.unwrap_or(false)
    }

    pub fn clear_was_mvp_last_game(&mut self) {
        self.was_mvp_last_game = ::std::option::Option::None;
    }

    pub fn has_was_mvp_last_game(&self) -> bool {
        self.was_mvp_last_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_mvp_last_game(&mut self, v: bool) {
        self.was_mvp_last_game = ::std::option::Option::Some(v);
    }

    // optional .dota.EDOTAMMRBoostType rank_mmr_boost_type = 46;

    pub fn rank_mmr_boost_type(&self) -> super::dota_shared_enums::EDOTAMMRBoostType {
        match self.rank_mmr_boost_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EDOTAMMRBoostType::k_EDOTAMMRBoostType_None),
            None => super::dota_shared_enums::EDOTAMMRBoostType::k_EDOTAMMRBoostType_None,
        }
    }

    pub fn clear_rank_mmr_boost_type(&mut self) {
        self.rank_mmr_boost_type = ::std::option::Option::None;
    }

    pub fn has_rank_mmr_boost_type(&self) -> bool {
        self.rank_mmr_boost_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_mmr_boost_type(&mut self, v: super::dota_shared_enums::EDOTAMMRBoostType) {
        self.rank_mmr_boost_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional sint32 queue_point_adjustment = 47;

    pub fn queue_point_adjustment(&self) -> i32 {
        self.queue_point_adjustment.unwrap_or(0)
    }

    pub fn clear_queue_point_adjustment(&mut self) {
        self.queue_point_adjustment = ::std::option::Option::None;
    }

    pub fn has_queue_point_adjustment(&self) -> bool {
        self.queue_point_adjustment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_point_adjustment(&mut self, v: i32) {
        self.queue_point_adjustment = ::std::option::Option::Some(v);
    }

    // optional int32 rank_tier = 48;

    pub fn rank_tier(&self) -> i32 {
        self.rank_tier.unwrap_or(0)
    }

    pub fn clear_rank_tier(&mut self) {
        self.rank_tier = ::std::option::Option::None;
    }

    pub fn has_rank_tier(&self) -> bool {
        self.rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_tier(&mut self, v: i32) {
        self.rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 title = 50;

    pub fn title(&self) -> u32 {
        self.title.unwrap_or(0)
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: u32) {
        self.title = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_id = 51;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reports_available = 52;

    pub fn reports_available(&self) -> u32 {
        self.reports_available.unwrap_or(0)
    }

    pub fn clear_reports_available(&mut self) {
        self.reports_available = ::std::option::Option::None;
    }

    pub fn has_reports_available(&self) -> bool {
        self.reports_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reports_available(&mut self, v: u32) {
        self.reports_available = ::std::option::Option::Some(v);
    }

    // optional bool is_steam_china = 54;

    pub fn is_steam_china(&self) -> bool {
        self.is_steam_china.unwrap_or(false)
    }

    pub fn clear_is_steam_china(&mut self) {
        self.is_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_steam_china(&self) -> bool {
        self.is_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steam_china(&mut self, v: bool) {
        self.is_steam_china = ::std::option::Option::Some(v);
    }

    // optional uint32 live_spectator_account_id = 55;

    pub fn live_spectator_account_id(&self) -> u32 {
        self.live_spectator_account_id.unwrap_or(0)
    }

    pub fn clear_live_spectator_account_id(&mut self) {
        self.live_spectator_account_id = ::std::option::Option::None;
    }

    pub fn has_live_spectator_account_id(&self) -> bool {
        self.live_spectator_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live_spectator_account_id(&mut self, v: u32) {
        self.live_spectator_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 comms_reports_available = 56;

    pub fn comms_reports_available(&self) -> u32 {
        self.comms_reports_available.unwrap_or(0)
    }

    pub fn clear_comms_reports_available(&mut self) {
        self.comms_reports_available = ::std::option::Option::None;
    }

    pub fn has_comms_reports_available(&self) -> bool {
        self.comms_reports_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comms_reports_available(&mut self, v: u32) {
        self.comms_reports_available = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(41);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CSODOTALobbyMember| { &m.id },
            |m: &mut CSODOTALobbyMember| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CSODOTALobbyMember| { &m.hero_id },
            |m: &mut CSODOTALobbyMember| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CSODOTALobbyMember| { &m.team },
            |m: &mut CSODOTALobbyMember| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSODOTALobbyMember| { &m.name },
            |m: &mut CSODOTALobbyMember| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CSODOTALobbyMember| { &m.slot },
            |m: &mut CSODOTALobbyMember| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CSODOTALobbyMember| { &m.party_id },
            |m: &mut CSODOTALobbyMember| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "meta_level",
            |m: &CSODOTALobbyMember| { &m.meta_level },
            |m: &mut CSODOTALobbyMember| { &mut m.meta_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "meta_xp",
            |m: &CSODOTALobbyMember| { &m.meta_xp },
            |m: &mut CSODOTALobbyMember| { &mut m.meta_xp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "meta_xp_awarded",
            |m: &CSODOTALobbyMember| { &m.meta_xp_awarded },
            |m: &mut CSODOTALobbyMember| { &mut m.meta_xp_awarded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaver_status",
            |m: &CSODOTALobbyMember| { &m.leaver_status },
            |m: &mut CSODOTALobbyMember| { &mut m.leaver_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaver_actions",
            |m: &CSODOTALobbyMember| { &m.leaver_actions },
            |m: &mut CSODOTALobbyMember| { &mut m.leaver_actions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CSODOTALobbyMember| { &m.channel },
            |m: &mut CSODOTALobbyMember| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "disabled_hero_id",
            |m: &CSODOTALobbyMember| { &m.disabled_hero_id },
            |m: &mut CSODOTALobbyMember| { &mut m.disabled_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enabled_hero_id",
            |m: &CSODOTALobbyMember| { &m.enabled_hero_id },
            |m: &mut CSODOTALobbyMember| { &mut m.enabled_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coach_team",
            |m: &CSODOTALobbyMember| { &m.coach_team },
            |m: &mut CSODOTALobbyMember| { &mut m.coach_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "coached_account_ids",
            |m: &CSODOTALobbyMember| { &m.coached_account_ids },
            |m: &mut CSODOTALobbyMember| { &mut m.coached_account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coach_rating",
            |m: &CSODOTALobbyMember| { &m.coach_rating },
            |m: &mut CSODOTALobbyMember| { &mut m.coach_rating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pwrd_cyber_cafe_id",
            |m: &CSODOTALobbyMember| { &m.pwrd_cyber_cafe_id },
            |m: &mut CSODOTALobbyMember| { &mut m.pwrd_cyber_cafe_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pwrd_cyber_cafe_name",
            |m: &CSODOTALobbyMember| { &m.pwrd_cyber_cafe_name },
            |m: &mut CSODOTALobbyMember| { &mut m.pwrd_cyber_cafe_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "disabled_random_hero_bits",
            |m: &CSODOTALobbyMember| { &m.disabled_random_hero_bits },
            |m: &mut CSODOTALobbyMember| { &mut m.disabled_random_hero_bits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_change",
            |m: &CSODOTALobbyMember| { &m.rank_change },
            |m: &mut CSODOTALobbyMember| { &mut m.rank_change },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cameraman",
            |m: &CSODOTALobbyMember| { &m.cameraman },
            |m: &mut CSODOTALobbyMember| { &mut m.cameraman },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "custom_game_product_ids",
            |m: &CSODOTALobbyMember| { &m.custom_game_product_ids },
            |m: &mut CSODOTALobbyMember| { &mut m.custom_game_product_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_match_type",
            |m: &CSODOTALobbyMember| { &m.search_match_type },
            |m: &mut CSODOTALobbyMember| { &mut m.search_match_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "favorite_team_packed",
            |m: &CSODOTALobbyMember| { &m.favorite_team_packed },
            |m: &mut CSODOTALobbyMember| { &mut m.favorite_team_packed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_plus_subscriber",
            |m: &CSODOTALobbyMember| { &m.is_plus_subscriber },
            |m: &mut CSODOTALobbyMember| { &mut m.is_plus_subscriber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane_selection_flags",
            |m: &CSODOTALobbyMember| { &m.lane_selection_flags },
            |m: &mut CSODOTALobbyMember| { &mut m.lane_selection_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_earn_rewards",
            |m: &CSODOTALobbyMember| { &m.can_earn_rewards },
            |m: &mut CSODOTALobbyMember| { &mut m.can_earn_rewards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "live_spectator_team",
            |m: &CSODOTALobbyMember| { &m.live_spectator_team },
            |m: &mut CSODOTALobbyMember| { &mut m.live_spectator_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "was_mvp_last_game",
            |m: &CSODOTALobbyMember| { &m.was_mvp_last_game },
            |m: &mut CSODOTALobbyMember| { &mut m.was_mvp_last_game },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pending_awards",
            |m: &CSODOTALobbyMember| { &m.pending_awards },
            |m: &mut CSODOTALobbyMember| { &mut m.pending_awards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pending_awards_on_victory",
            |m: &CSODOTALobbyMember| { &m.pending_awards_on_victory },
            |m: &mut CSODOTALobbyMember| { &mut m.pending_awards_on_victory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_mmr_boost_type",
            |m: &CSODOTALobbyMember| { &m.rank_mmr_boost_type },
            |m: &mut CSODOTALobbyMember| { &mut m.rank_mmr_boost_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_point_adjustment",
            |m: &CSODOTALobbyMember| { &m.queue_point_adjustment },
            |m: &mut CSODOTALobbyMember| { &mut m.queue_point_adjustment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_tier",
            |m: &CSODOTALobbyMember| { &m.rank_tier },
            |m: &mut CSODOTALobbyMember| { &mut m.rank_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CSODOTALobbyMember| { &m.title },
            |m: &mut CSODOTALobbyMember| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CSODOTALobbyMember| { &m.guild_id },
            |m: &mut CSODOTALobbyMember| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reports_available",
            |m: &CSODOTALobbyMember| { &m.reports_available },
            |m: &mut CSODOTALobbyMember| { &mut m.reports_available },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_steam_china",
            |m: &CSODOTALobbyMember| { &m.is_steam_china },
            |m: &mut CSODOTALobbyMember| { &mut m.is_steam_china },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "live_spectator_account_id",
            |m: &CSODOTALobbyMember| { &m.live_spectator_account_id },
            |m: &mut CSODOTALobbyMember| { &mut m.live_spectator_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comms_reports_available",
            |m: &CSODOTALobbyMember| { &m.comms_reports_available },
            |m: &mut CSODOTALobbyMember| { &mut m.comms_reports_available },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTALobbyMember>(
            "CSODOTALobbyMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTALobbyMember {
    const NAME: &'static str = "CSODOTALobbyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                104 => {
                    self.meta_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.meta_xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.meta_xp_awarded = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.leaver_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                224 => {
                    self.leaver_actions = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                162 => {
                    is.read_repeated_packed_uint32_into(&mut self.disabled_hero_id)?;
                },
                160 => {
                    self.disabled_hero_id.push(is.read_uint32()?);
                },
                178 => {
                    is.read_repeated_packed_uint32_into(&mut self.enabled_hero_id)?;
                },
                176 => {
                    self.enabled_hero_id.push(is.read_uint32()?);
                },
                184 => {
                    self.coach_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                426 => {
                    is.read_repeated_packed_uint32_into(&mut self.coached_account_ids)?;
                },
                424 => {
                    self.coached_account_ids.push(is.read_uint32()?);
                },
                336 => {
                    self.coach_rating = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.pwrd_cyber_cafe_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                202 => {
                    self.pwrd_cyber_cafe_name = ::std::option::Option::Some(is.read_string()?);
                },
                330 => {
                    is.read_repeated_packed_fixed32_into(&mut self.disabled_random_hero_bits)?;
                },
                333 => {
                    self.disabled_random_hero_bits.push(is.read_fixed32()?);
                },
                232 => {
                    self.rank_change = ::std::option::Option::Some(is.read_sint32()?);
                },
                240 => {
                    self.cameraman = ::std::option::Option::Some(is.read_bool()?);
                },
                250 => {
                    is.read_repeated_packed_uint32_into(&mut self.custom_game_product_ids)?;
                },
                248 => {
                    self.custom_game_product_ids.push(is.read_uint32()?);
                },
                264 => {
                    self.search_match_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                280 => {
                    self.favorite_team_packed = ::std::option::Option::Some(is.read_uint64()?);
                },
                288 => {
                    self.is_plus_subscriber = ::std::option::Option::Some(is.read_bool()?);
                },
                304 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.can_earn_rewards = ::std::option::Option::Some(is.read_bool()?);
                },
                320 => {
                    self.live_spectator_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                344 => {
                    self.was_mvp_last_game = ::std::option::Option::Some(is.read_bool()?);
                },
                354 => {
                    self.pending_awards.push(is.read_message()?);
                },
                362 => {
                    self.pending_awards_on_victory.push(is.read_message()?);
                },
                368 => {
                    self.rank_mmr_boost_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                376 => {
                    self.queue_point_adjustment = ::std::option::Option::Some(is.read_sint32()?);
                },
                384 => {
                    self.rank_tier = ::std::option::Option::Some(is.read_int32()?);
                },
                400 => {
                    self.title = ::std::option::Option::Some(is.read_uint32()?);
                },
                408 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                416 => {
                    self.reports_available = ::std::option::Option::Some(is.read_uint32()?);
                },
                432 => {
                    self.is_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                440 => {
                    self.live_spectator_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                448 => {
                    self.comms_reports_available = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.party_id {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.meta_level {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.meta_xp {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.meta_xp_awarded {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.leaver_status {
            my_size += ::protobuf::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.leaver_actions {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        for value in &self.disabled_hero_id {
            my_size += ::protobuf::rt::uint32_size(20, *value);
        };
        for value in &self.enabled_hero_id {
            my_size += ::protobuf::rt::uint32_size(22, *value);
        };
        if let Some(v) = self.coach_team {
            my_size += ::protobuf::rt::int32_size(23, v.value());
        }
        for value in &self.coached_account_ids {
            my_size += ::protobuf::rt::uint32_size(53, *value);
        };
        if let Some(v) = self.coach_rating {
            my_size += ::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.pwrd_cyber_cafe_id {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.pwrd_cyber_cafe_name.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        my_size += 6 * self.disabled_random_hero_bits.len() as u64;
        if let Some(v) = self.rank_change {
            my_size += ::protobuf::rt::sint32_size(29, v);
        }
        if let Some(v) = self.cameraman {
            my_size += 2 + 1;
        }
        for value in &self.custom_game_product_ids {
            my_size += ::protobuf::rt::uint32_size(31, *value);
        };
        if let Some(v) = self.search_match_type {
            my_size += ::protobuf::rt::int32_size(33, v.value());
        }
        if let Some(v) = self.favorite_team_packed {
            my_size += ::protobuf::rt::uint64_size(35, v);
        }
        if let Some(v) = self.is_plus_subscriber {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lane_selection_flags {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.can_earn_rewards {
            my_size += 2 + 1;
        }
        if let Some(v) = self.live_spectator_team {
            my_size += ::protobuf::rt::int32_size(40, v.value());
        }
        if let Some(v) = self.was_mvp_last_game {
            my_size += 2 + 1;
        }
        for value in &self.pending_awards {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pending_awards_on_victory {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.rank_mmr_boost_type {
            my_size += ::protobuf::rt::int32_size(46, v.value());
        }
        if let Some(v) = self.queue_point_adjustment {
            my_size += ::protobuf::rt::sint32_size(47, v);
        }
        if let Some(v) = self.rank_tier {
            my_size += ::protobuf::rt::int32_size(48, v);
        }
        if let Some(v) = self.title {
            my_size += ::protobuf::rt::uint32_size(50, v);
        }
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(51, v);
        }
        if let Some(v) = self.reports_available {
            my_size += ::protobuf::rt::uint32_size(52, v);
        }
        if let Some(v) = self.is_steam_china {
            my_size += 2 + 1;
        }
        if let Some(v) = self.live_spectator_account_id {
            my_size += ::protobuf::rt::uint32_size(55, v);
        }
        if let Some(v) = self.comms_reports_available {
            my_size += ::protobuf::rt::uint32_size(56, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.team {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.slot {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.party_id {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.meta_level {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.meta_xp {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.meta_xp_awarded {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.leaver_status {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.leaver_actions {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.channel {
            os.write_uint32(17, v)?;
        }
        for v in &self.disabled_hero_id {
            os.write_uint32(20, *v)?;
        };
        for v in &self.enabled_hero_id {
            os.write_uint32(22, *v)?;
        };
        if let Some(v) = self.coach_team {
            os.write_enum(23, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.coached_account_ids {
            os.write_uint32(53, *v)?;
        };
        if let Some(v) = self.coach_rating {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.pwrd_cyber_cafe_id {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.pwrd_cyber_cafe_name.as_ref() {
            os.write_string(25, v)?;
        }
        for v in &self.disabled_random_hero_bits {
            os.write_fixed32(41, *v)?;
        };
        if let Some(v) = self.rank_change {
            os.write_sint32(29, v)?;
        }
        if let Some(v) = self.cameraman {
            os.write_bool(30, v)?;
        }
        for v in &self.custom_game_product_ids {
            os.write_uint32(31, *v)?;
        };
        if let Some(v) = self.search_match_type {
            os.write_enum(33, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.favorite_team_packed {
            os.write_uint64(35, v)?;
        }
        if let Some(v) = self.is_plus_subscriber {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.can_earn_rewards {
            os.write_bool(39, v)?;
        }
        if let Some(v) = self.live_spectator_team {
            os.write_enum(40, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.was_mvp_last_game {
            os.write_bool(43, v)?;
        }
        for v in &self.pending_awards {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        };
        for v in &self.pending_awards_on_victory {
            ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        };
        if let Some(v) = self.rank_mmr_boost_type {
            os.write_enum(46, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.queue_point_adjustment {
            os.write_sint32(47, v)?;
        }
        if let Some(v) = self.rank_tier {
            os.write_int32(48, v)?;
        }
        if let Some(v) = self.title {
            os.write_uint32(50, v)?;
        }
        if let Some(v) = self.guild_id {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.reports_available {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.is_steam_china {
            os.write_bool(54, v)?;
        }
        if let Some(v) = self.live_spectator_account_id {
            os.write_uint32(55, v)?;
        }
        if let Some(v) = self.comms_reports_available {
            os.write_uint32(56, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTALobbyMember {
        CSODOTALobbyMember::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.party_id = ::std::option::Option::None;
        self.meta_level = ::std::option::Option::None;
        self.meta_xp = ::std::option::Option::None;
        self.meta_xp_awarded = ::std::option::Option::None;
        self.leaver_status = ::std::option::Option::None;
        self.leaver_actions = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.disabled_hero_id.clear();
        self.enabled_hero_id.clear();
        self.coach_team = ::std::option::Option::None;
        self.coached_account_ids.clear();
        self.coach_rating = ::std::option::Option::None;
        self.pwrd_cyber_cafe_id = ::std::option::Option::None;
        self.pwrd_cyber_cafe_name = ::std::option::Option::None;
        self.disabled_random_hero_bits.clear();
        self.rank_change = ::std::option::Option::None;
        self.cameraman = ::std::option::Option::None;
        self.custom_game_product_ids.clear();
        self.search_match_type = ::std::option::Option::None;
        self.favorite_team_packed = ::std::option::Option::None;
        self.is_plus_subscriber = ::std::option::Option::None;
        self.lane_selection_flags = ::std::option::Option::None;
        self.can_earn_rewards = ::std::option::Option::None;
        self.live_spectator_team = ::std::option::Option::None;
        self.was_mvp_last_game = ::std::option::Option::None;
        self.pending_awards.clear();
        self.pending_awards_on_victory.clear();
        self.rank_mmr_boost_type = ::std::option::Option::None;
        self.queue_point_adjustment = ::std::option::Option::None;
        self.rank_tier = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.guild_id = ::std::option::Option::None;
        self.reports_available = ::std::option::Option::None;
        self.is_steam_china = ::std::option::Option::None;
        self.live_spectator_account_id = ::std::option::Option::None;
        self.comms_reports_available = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTALobbyMember {
        static instance: CSODOTALobbyMember = CSODOTALobbyMember {
            id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            team: ::std::option::Option::None,
            name: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            party_id: ::std::option::Option::None,
            meta_level: ::std::option::Option::None,
            meta_xp: ::std::option::Option::None,
            meta_xp_awarded: ::std::option::Option::None,
            leaver_status: ::std::option::Option::None,
            leaver_actions: ::std::option::Option::None,
            channel: ::std::option::Option::None,
            disabled_hero_id: ::std::vec::Vec::new(),
            enabled_hero_id: ::std::vec::Vec::new(),
            coach_team: ::std::option::Option::None,
            coached_account_ids: ::std::vec::Vec::new(),
            coach_rating: ::std::option::Option::None,
            pwrd_cyber_cafe_id: ::std::option::Option::None,
            pwrd_cyber_cafe_name: ::std::option::Option::None,
            disabled_random_hero_bits: ::std::vec::Vec::new(),
            rank_change: ::std::option::Option::None,
            cameraman: ::std::option::Option::None,
            custom_game_product_ids: ::std::vec::Vec::new(),
            search_match_type: ::std::option::Option::None,
            favorite_team_packed: ::std::option::Option::None,
            is_plus_subscriber: ::std::option::Option::None,
            lane_selection_flags: ::std::option::Option::None,
            can_earn_rewards: ::std::option::Option::None,
            live_spectator_team: ::std::option::Option::None,
            was_mvp_last_game: ::std::option::Option::None,
            pending_awards: ::std::vec::Vec::new(),
            pending_awards_on_victory: ::std::vec::Vec::new(),
            rank_mmr_boost_type: ::std::option::Option::None,
            queue_point_adjustment: ::std::option::Option::None,
            rank_tier: ::std::option::Option::None,
            title: ::std::option::Option::None,
            guild_id: ::std::option::Option::None,
            reports_available: ::std::option::Option::None,
            is_steam_china: ::std::option::Option::None,
            live_spectator_account_id: ::std::option::Option::None,
            comms_reports_available: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTALobbyMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTALobbyMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTALobbyMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTALobbyMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSODOTAServerLobbyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAServerLobbyMember {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAServerLobbyMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAServerLobbyMember {
    fn default() -> &'a CSODOTAServerLobbyMember {
        <CSODOTAServerLobbyMember as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAServerLobbyMember {
    pub fn new() -> CSODOTAServerLobbyMember {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAServerLobbyMember>(
            "CSODOTAServerLobbyMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAServerLobbyMember {
    const NAME: &'static str = "CSODOTAServerLobbyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAServerLobbyMember {
        CSODOTAServerLobbyMember::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAServerLobbyMember {
        static instance: CSODOTAServerLobbyMember = CSODOTAServerLobbyMember {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAServerLobbyMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAServerLobbyMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAServerLobbyMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAServerLobbyMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSODOTAStaticLobbyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAStaticLobbyMember {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAStaticLobbyMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAStaticLobbyMember {
    fn default() -> &'a CSODOTAStaticLobbyMember {
        <CSODOTAStaticLobbyMember as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAStaticLobbyMember {
    pub fn new() -> CSODOTAStaticLobbyMember {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAStaticLobbyMember>(
            "CSODOTAStaticLobbyMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAStaticLobbyMember {
    const NAME: &'static str = "CSODOTAStaticLobbyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAStaticLobbyMember {
        CSODOTAStaticLobbyMember::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAStaticLobbyMember {
        static instance: CSODOTAStaticLobbyMember = CSODOTAStaticLobbyMember {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAStaticLobbyMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAStaticLobbyMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAStaticLobbyMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAStaticLobbyMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSODOTAServerStaticLobbyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAServerStaticLobbyMember {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAServerStaticLobbyMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAServerStaticLobbyMember {
    fn default() -> &'a CSODOTAServerStaticLobbyMember {
        <CSODOTAServerStaticLobbyMember as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAServerStaticLobbyMember {
    pub fn new() -> CSODOTAServerStaticLobbyMember {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAServerStaticLobbyMember>(
            "CSODOTAServerStaticLobbyMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAServerStaticLobbyMember {
    const NAME: &'static str = "CSODOTAServerStaticLobbyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAServerStaticLobbyMember {
        CSODOTAServerStaticLobbyMember::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAServerStaticLobbyMember {
        static instance: CSODOTAServerStaticLobbyMember = CSODOTAServerStaticLobbyMember {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAServerStaticLobbyMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAServerStaticLobbyMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAServerStaticLobbyMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAServerStaticLobbyMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CLobbyTeamDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyTeamDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.team_name)
    pub team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.team_tag)
    pub team_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.team_logo)
    pub team_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.team_base_logo)
    pub team_base_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.team_banner_logo)
    pub team_banner_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.team_complete)
    pub team_complete: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.rank)
    pub rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.rank_change)
    pub rank_change: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.is_home_team)
    pub is_home_team: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.is_challenge_match)
    pub is_challenge_match: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.challenge_match_token_account)
    pub challenge_match_token_account: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.team_logo_url)
    pub team_logo_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CLobbyTeamDetails.team_abbreviation)
    pub team_abbreviation: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CLobbyTeamDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyTeamDetails {
    fn default() -> &'a CLobbyTeamDetails {
        <CLobbyTeamDetails as ::protobuf::Message>::default_instance()
    }
}

impl CLobbyTeamDetails {
    pub fn new() -> CLobbyTeamDetails {
        ::std::default::Default::default()
    }

    // optional string team_name = 1;

    pub fn team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_name(&mut self) {
        self.team_name = ::std::option::Option::None;
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_tag = 3;

    pub fn team_tag(&self) -> &str {
        match self.team_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_tag(&mut self) {
        self.team_tag = ::std::option::Option::None;
    }

    pub fn has_team_tag(&self) -> bool {
        self.team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_tag(&mut self, v: ::std::string::String) {
        self.team_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
        if self.team_tag.is_none() {
            self.team_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_tag(&mut self) -> ::std::string::String {
        self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 team_id = 4;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint64 team_logo = 5;

    pub fn team_logo(&self) -> u64 {
        self.team_logo.unwrap_or(0)
    }

    pub fn clear_team_logo(&mut self) {
        self.team_logo = ::std::option::Option::None;
    }

    pub fn has_team_logo(&self) -> bool {
        self.team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_logo(&mut self, v: u64) {
        self.team_logo = ::std::option::Option::Some(v);
    }

    // optional uint64 team_base_logo = 6;

    pub fn team_base_logo(&self) -> u64 {
        self.team_base_logo.unwrap_or(0)
    }

    pub fn clear_team_base_logo(&mut self) {
        self.team_base_logo = ::std::option::Option::None;
    }

    pub fn has_team_base_logo(&self) -> bool {
        self.team_base_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_base_logo(&mut self, v: u64) {
        self.team_base_logo = ::std::option::Option::Some(v);
    }

    // optional uint64 team_banner_logo = 7;

    pub fn team_banner_logo(&self) -> u64 {
        self.team_banner_logo.unwrap_or(0)
    }

    pub fn clear_team_banner_logo(&mut self) {
        self.team_banner_logo = ::std::option::Option::None;
    }

    pub fn has_team_banner_logo(&self) -> bool {
        self.team_banner_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_banner_logo(&mut self, v: u64) {
        self.team_banner_logo = ::std::option::Option::Some(v);
    }

    // optional bool team_complete = 8;

    pub fn team_complete(&self) -> bool {
        self.team_complete.unwrap_or(false)
    }

    pub fn clear_team_complete(&mut self) {
        self.team_complete = ::std::option::Option::None;
    }

    pub fn has_team_complete(&self) -> bool {
        self.team_complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_complete(&mut self, v: bool) {
        self.team_complete = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 15;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional sint32 rank_change = 16;

    pub fn rank_change(&self) -> i32 {
        self.rank_change.unwrap_or(0)
    }

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: i32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional bool is_home_team = 17;

    pub fn is_home_team(&self) -> bool {
        self.is_home_team.unwrap_or(false)
    }

    pub fn clear_is_home_team(&mut self) {
        self.is_home_team = ::std::option::Option::None;
    }

    pub fn has_is_home_team(&self) -> bool {
        self.is_home_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_home_team(&mut self, v: bool) {
        self.is_home_team = ::std::option::Option::Some(v);
    }

    // optional bool is_challenge_match = 18;

    pub fn is_challenge_match(&self) -> bool {
        self.is_challenge_match.unwrap_or(false)
    }

    pub fn clear_is_challenge_match(&mut self) {
        self.is_challenge_match = ::std::option::Option::None;
    }

    pub fn has_is_challenge_match(&self) -> bool {
        self.is_challenge_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_challenge_match(&mut self, v: bool) {
        self.is_challenge_match = ::std::option::Option::Some(v);
    }

    // optional uint64 challenge_match_token_account = 19;

    pub fn challenge_match_token_account(&self) -> u64 {
        self.challenge_match_token_account.unwrap_or(0)
    }

    pub fn clear_challenge_match_token_account(&mut self) {
        self.challenge_match_token_account = ::std::option::Option::None;
    }

    pub fn has_challenge_match_token_account(&self) -> bool {
        self.challenge_match_token_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_match_token_account(&mut self, v: u64) {
        self.challenge_match_token_account = ::std::option::Option::Some(v);
    }

    // optional string team_logo_url = 20;

    pub fn team_logo_url(&self) -> &str {
        match self.team_logo_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_logo_url(&mut self) {
        self.team_logo_url = ::std::option::Option::None;
    }

    pub fn has_team_logo_url(&self) -> bool {
        self.team_logo_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
        self.team_logo_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
        if self.team_logo_url.is_none() {
            self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_logo_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_logo_url(&mut self) -> ::std::string::String {
        self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_abbreviation = 21;

    pub fn team_abbreviation(&self) -> &str {
        match self.team_abbreviation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_abbreviation(&mut self) {
        self.team_abbreviation = ::std::option::Option::None;
    }

    pub fn has_team_abbreviation(&self) -> bool {
        self.team_abbreviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
        self.team_abbreviation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
        if self.team_abbreviation.is_none() {
            self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_abbreviation.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
        self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_name",
            |m: &CLobbyTeamDetails| { &m.team_name },
            |m: &mut CLobbyTeamDetails| { &mut m.team_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_tag",
            |m: &CLobbyTeamDetails| { &m.team_tag },
            |m: &mut CLobbyTeamDetails| { &mut m.team_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CLobbyTeamDetails| { &m.team_id },
            |m: &mut CLobbyTeamDetails| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_logo",
            |m: &CLobbyTeamDetails| { &m.team_logo },
            |m: &mut CLobbyTeamDetails| { &mut m.team_logo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_base_logo",
            |m: &CLobbyTeamDetails| { &m.team_base_logo },
            |m: &mut CLobbyTeamDetails| { &mut m.team_base_logo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_banner_logo",
            |m: &CLobbyTeamDetails| { &m.team_banner_logo },
            |m: &mut CLobbyTeamDetails| { &mut m.team_banner_logo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_complete",
            |m: &CLobbyTeamDetails| { &m.team_complete },
            |m: &mut CLobbyTeamDetails| { &mut m.team_complete },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &CLobbyTeamDetails| { &m.rank },
            |m: &mut CLobbyTeamDetails| { &mut m.rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_change",
            |m: &CLobbyTeamDetails| { &m.rank_change },
            |m: &mut CLobbyTeamDetails| { &mut m.rank_change },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_home_team",
            |m: &CLobbyTeamDetails| { &m.is_home_team },
            |m: &mut CLobbyTeamDetails| { &mut m.is_home_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_challenge_match",
            |m: &CLobbyTeamDetails| { &m.is_challenge_match },
            |m: &mut CLobbyTeamDetails| { &mut m.is_challenge_match },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_match_token_account",
            |m: &CLobbyTeamDetails| { &m.challenge_match_token_account },
            |m: &mut CLobbyTeamDetails| { &mut m.challenge_match_token_account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_logo_url",
            |m: &CLobbyTeamDetails| { &m.team_logo_url },
            |m: &mut CLobbyTeamDetails| { &mut m.team_logo_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_abbreviation",
            |m: &CLobbyTeamDetails| { &m.team_abbreviation },
            |m: &mut CLobbyTeamDetails| { &mut m.team_abbreviation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CLobbyTeamDetails>(
            "CLobbyTeamDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CLobbyTeamDetails {
    const NAME: &'static str = "CLobbyTeamDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.team_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.team_tag = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.team_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.team_base_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.team_banner_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.team_complete = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.rank_change = ::std::option::Option::Some(is.read_sint32()?);
                },
                136 => {
                    self.is_home_team = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.is_challenge_match = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.challenge_match_token_account = ::std::option::Option::Some(is.read_uint64()?);
                },
                162 => {
                    self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.team_logo {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.team_base_logo {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.team_banner_logo {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.team_complete {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.rank_change {
            my_size += ::protobuf::rt::sint32_size(16, v);
        }
        if let Some(v) = self.is_home_team {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_challenge_match {
            my_size += 2 + 1;
        }
        if let Some(v) = self.challenge_match_token_account {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        if let Some(v) = self.team_logo_url.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.team_abbreviation.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.team_tag.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.team_logo {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.team_base_logo {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.team_banner_logo {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.team_complete {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_sint32(16, v)?;
        }
        if let Some(v) = self.is_home_team {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.is_challenge_match {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.challenge_match_token_account {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.team_logo_url.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.team_abbreviation.as_ref() {
            os.write_string(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyTeamDetails {
        CLobbyTeamDetails::new()
    }

    fn clear(&mut self) {
        self.team_name = ::std::option::Option::None;
        self.team_tag = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.team_logo = ::std::option::Option::None;
        self.team_base_logo = ::std::option::Option::None;
        self.team_banner_logo = ::std::option::Option::None;
        self.team_complete = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.rank_change = ::std::option::Option::None;
        self.is_home_team = ::std::option::Option::None;
        self.is_challenge_match = ::std::option::Option::None;
        self.challenge_match_token_account = ::std::option::Option::None;
        self.team_logo_url = ::std::option::Option::None;
        self.team_abbreviation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyTeamDetails {
        static instance: CLobbyTeamDetails = CLobbyTeamDetails {
            team_name: ::std::option::Option::None,
            team_tag: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            team_logo: ::std::option::Option::None,
            team_base_logo: ::std::option::Option::None,
            team_banner_logo: ::std::option::Option::None,
            team_complete: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            rank_change: ::std::option::Option::None,
            is_home_team: ::std::option::Option::None,
            is_challenge_match: ::std::option::Option::None,
            challenge_match_token_account: ::std::option::Option::None,
            team_logo_url: ::std::option::Option::None,
            team_abbreviation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CLobbyTeamDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CLobbyTeamDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CLobbyTeamDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLobbyTeamDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CLobbyGuildDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyGuildDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_primary_color)
    pub guild_primary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_secondary_color)
    pub guild_secondary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_pattern)
    pub guild_pattern: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_logo)
    pub guild_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_points)
    pub guild_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_event)
    pub guild_event: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_flags)
    pub guild_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.team_for_guild)
    pub team_for_guild: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_tag)
    pub guild_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildDetails.guild_weekly_percentile)
    pub guild_weekly_percentile: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CLobbyGuildDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyGuildDetails {
    fn default() -> &'a CLobbyGuildDetails {
        <CLobbyGuildDetails as ::protobuf::Message>::default_instance()
    }
}

impl CLobbyGuildDetails {
    pub fn new() -> CLobbyGuildDetails {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_primary_color = 2;

    pub fn guild_primary_color(&self) -> u32 {
        self.guild_primary_color.unwrap_or(0)
    }

    pub fn clear_guild_primary_color(&mut self) {
        self.guild_primary_color = ::std::option::Option::None;
    }

    pub fn has_guild_primary_color(&self) -> bool {
        self.guild_primary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_primary_color(&mut self, v: u32) {
        self.guild_primary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_secondary_color = 3;

    pub fn guild_secondary_color(&self) -> u32 {
        self.guild_secondary_color.unwrap_or(0)
    }

    pub fn clear_guild_secondary_color(&mut self) {
        self.guild_secondary_color = ::std::option::Option::None;
    }

    pub fn has_guild_secondary_color(&self) -> bool {
        self.guild_secondary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_secondary_color(&mut self, v: u32) {
        self.guild_secondary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_pattern = 4;

    pub fn guild_pattern(&self) -> u32 {
        self.guild_pattern.unwrap_or(0)
    }

    pub fn clear_guild_pattern(&mut self) {
        self.guild_pattern = ::std::option::Option::None;
    }

    pub fn has_guild_pattern(&self) -> bool {
        self.guild_pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_pattern(&mut self, v: u32) {
        self.guild_pattern = ::std::option::Option::Some(v);
    }

    // optional uint64 guild_logo = 5;

    pub fn guild_logo(&self) -> u64 {
        self.guild_logo.unwrap_or(0)
    }

    pub fn clear_guild_logo(&mut self) {
        self.guild_logo = ::std::option::Option::None;
    }

    pub fn has_guild_logo(&self) -> bool {
        self.guild_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_logo(&mut self, v: u64) {
        self.guild_logo = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_points = 6;

    pub fn guild_points(&self) -> u32 {
        self.guild_points.unwrap_or(0)
    }

    pub fn clear_guild_points(&mut self) {
        self.guild_points = ::std::option::Option::None;
    }

    pub fn has_guild_points(&self) -> bool {
        self.guild_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_points(&mut self, v: u32) {
        self.guild_points = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_event = 7;

    pub fn guild_event(&self) -> u32 {
        self.guild_event.unwrap_or(0)
    }

    pub fn clear_guild_event(&mut self) {
        self.guild_event = ::std::option::Option::None;
    }

    pub fn has_guild_event(&self) -> bool {
        self.guild_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_event(&mut self, v: u32) {
        self.guild_event = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_flags = 8;

    pub fn guild_flags(&self) -> u32 {
        self.guild_flags.unwrap_or(0)
    }

    pub fn clear_guild_flags(&mut self) {
        self.guild_flags = ::std::option::Option::None;
    }

    pub fn has_guild_flags(&self) -> bool {
        self.guild_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_flags(&mut self, v: u32) {
        self.guild_flags = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GC_TEAM team_for_guild = 9;

    pub fn team_for_guild(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team_for_guild {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team_for_guild(&mut self) {
        self.team_for_guild = ::std::option::Option::None;
    }

    pub fn has_team_for_guild(&self) -> bool {
        self.team_for_guild.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_for_guild(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team_for_guild = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string guild_tag = 10;

    pub fn guild_tag(&self) -> &str {
        match self.guild_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_tag(&mut self) {
        self.guild_tag = ::std::option::Option::None;
    }

    pub fn has_guild_tag(&self) -> bool {
        self.guild_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_tag(&mut self, v: ::std::string::String) {
        self.guild_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_tag(&mut self) -> &mut ::std::string::String {
        if self.guild_tag.is_none() {
            self.guild_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_tag(&mut self) -> ::std::string::String {
        self.guild_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 guild_weekly_percentile = 11;

    pub fn guild_weekly_percentile(&self) -> u32 {
        self.guild_weekly_percentile.unwrap_or(0)
    }

    pub fn clear_guild_weekly_percentile(&mut self) {
        self.guild_weekly_percentile = ::std::option::Option::None;
    }

    pub fn has_guild_weekly_percentile(&self) -> bool {
        self.guild_weekly_percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_weekly_percentile(&mut self, v: u32) {
        self.guild_weekly_percentile = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CLobbyGuildDetails| { &m.guild_id },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_primary_color",
            |m: &CLobbyGuildDetails| { &m.guild_primary_color },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_primary_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_secondary_color",
            |m: &CLobbyGuildDetails| { &m.guild_secondary_color },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_secondary_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_pattern",
            |m: &CLobbyGuildDetails| { &m.guild_pattern },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_pattern },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_logo",
            |m: &CLobbyGuildDetails| { &m.guild_logo },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_logo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_points",
            |m: &CLobbyGuildDetails| { &m.guild_points },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_event",
            |m: &CLobbyGuildDetails| { &m.guild_event },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_flags",
            |m: &CLobbyGuildDetails| { &m.guild_flags },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_for_guild",
            |m: &CLobbyGuildDetails| { &m.team_for_guild },
            |m: &mut CLobbyGuildDetails| { &mut m.team_for_guild },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_tag",
            |m: &CLobbyGuildDetails| { &m.guild_tag },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_weekly_percentile",
            |m: &CLobbyGuildDetails| { &m.guild_weekly_percentile },
            |m: &mut CLobbyGuildDetails| { &mut m.guild_weekly_percentile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CLobbyGuildDetails>(
            "CLobbyGuildDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CLobbyGuildDetails {
    const NAME: &'static str = "CLobbyGuildDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.guild_primary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.guild_secondary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.guild_pattern = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.guild_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.guild_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.guild_event = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.guild_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.team_for_guild = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                82 => {
                    self.guild_tag = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.guild_weekly_percentile = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_primary_color {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.guild_secondary_color {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.guild_pattern {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.guild_logo {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.guild_points {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.guild_event {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.guild_flags {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.team_for_guild {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.guild_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.guild_weekly_percentile {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_primary_color {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.guild_secondary_color {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.guild_pattern {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.guild_logo {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.guild_points {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.guild_event {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.guild_flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.team_for_guild {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_tag.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.guild_weekly_percentile {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyGuildDetails {
        CLobbyGuildDetails::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_primary_color = ::std::option::Option::None;
        self.guild_secondary_color = ::std::option::Option::None;
        self.guild_pattern = ::std::option::Option::None;
        self.guild_logo = ::std::option::Option::None;
        self.guild_points = ::std::option::Option::None;
        self.guild_event = ::std::option::Option::None;
        self.guild_flags = ::std::option::Option::None;
        self.team_for_guild = ::std::option::Option::None;
        self.guild_tag = ::std::option::Option::None;
        self.guild_weekly_percentile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyGuildDetails {
        static instance: CLobbyGuildDetails = CLobbyGuildDetails {
            guild_id: ::std::option::Option::None,
            guild_primary_color: ::std::option::Option::None,
            guild_secondary_color: ::std::option::Option::None,
            guild_pattern: ::std::option::Option::None,
            guild_logo: ::std::option::Option::None,
            guild_points: ::std::option::Option::None,
            guild_event: ::std::option::Option::None,
            guild_flags: ::std::option::Option::None,
            team_for_guild: ::std::option::Option::None,
            guild_tag: ::std::option::Option::None,
            guild_weekly_percentile: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CLobbyGuildDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CLobbyGuildDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CLobbyGuildDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLobbyGuildDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CLobbyTimedRewardDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyTimedRewardDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CLobbyTimedRewardDetails.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyTimedRewardDetails.is_supply_crate)
    pub is_supply_crate: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CLobbyTimedRewardDetails.is_timed_drop)
    pub is_timed_drop: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CLobbyTimedRewardDetails.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyTimedRewardDetails.origin)
    pub origin: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CLobbyTimedRewardDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyTimedRewardDetails {
    fn default() -> &'a CLobbyTimedRewardDetails {
        <CLobbyTimedRewardDetails as ::protobuf::Message>::default_instance()
    }
}

impl CLobbyTimedRewardDetails {
    pub fn new() -> CLobbyTimedRewardDetails {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 2;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional bool is_supply_crate = 3;

    pub fn is_supply_crate(&self) -> bool {
        self.is_supply_crate.unwrap_or(false)
    }

    pub fn clear_is_supply_crate(&mut self) {
        self.is_supply_crate = ::std::option::Option::None;
    }

    pub fn has_is_supply_crate(&self) -> bool {
        self.is_supply_crate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_supply_crate(&mut self, v: bool) {
        self.is_supply_crate = ::std::option::Option::Some(v);
    }

    // optional bool is_timed_drop = 4;

    pub fn is_timed_drop(&self) -> bool {
        self.is_timed_drop.unwrap_or(false)
    }

    pub fn clear_is_timed_drop(&mut self) {
        self.is_timed_drop = ::std::option::Option::None;
    }

    pub fn has_is_timed_drop(&self) -> bool {
        self.is_timed_drop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_timed_drop(&mut self, v: bool) {
        self.is_timed_drop = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 5;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 6;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_index",
            |m: &CLobbyTimedRewardDetails| { &m.item_def_index },
            |m: &mut CLobbyTimedRewardDetails| { &mut m.item_def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_supply_crate",
            |m: &CLobbyTimedRewardDetails| { &m.is_supply_crate },
            |m: &mut CLobbyTimedRewardDetails| { &mut m.is_supply_crate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_timed_drop",
            |m: &CLobbyTimedRewardDetails| { &m.is_timed_drop },
            |m: &mut CLobbyTimedRewardDetails| { &mut m.is_timed_drop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CLobbyTimedRewardDetails| { &m.account_id },
            |m: &mut CLobbyTimedRewardDetails| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin",
            |m: &CLobbyTimedRewardDetails| { &m.origin },
            |m: &mut CLobbyTimedRewardDetails| { &mut m.origin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CLobbyTimedRewardDetails>(
            "CLobbyTimedRewardDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CLobbyTimedRewardDetails {
    const NAME: &'static str = "CLobbyTimedRewardDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_supply_crate = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_timed_drop = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_supply_crate {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_timed_drop {
            my_size += 1 + 1;
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_supply_crate {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_timed_drop {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyTimedRewardDetails {
        CLobbyTimedRewardDetails::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.is_supply_crate = ::std::option::Option::None;
        self.is_timed_drop = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyTimedRewardDetails {
        static instance: CLobbyTimedRewardDetails = CLobbyTimedRewardDetails {
            item_def_index: ::std::option::Option::None,
            is_supply_crate: ::std::option::Option::None,
            is_timed_drop: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CLobbyTimedRewardDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CLobbyTimedRewardDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CLobbyTimedRewardDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLobbyTimedRewardDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CLobbyBroadcastChannelInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyBroadcastChannelInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CLobbyBroadcastChannelInfo.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyBroadcastChannelInfo.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CLobbyBroadcastChannelInfo.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CLobbyBroadcastChannelInfo.language_code)
    pub language_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CLobbyBroadcastChannelInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyBroadcastChannelInfo {
    fn default() -> &'a CLobbyBroadcastChannelInfo {
        <CLobbyBroadcastChannelInfo as ::protobuf::Message>::default_instance()
    }
}

impl CLobbyBroadcastChannelInfo {
    pub fn new() -> CLobbyBroadcastChannelInfo {
        ::std::default::Default::default()
    }

    // optional uint32 channel_id = 1;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 3;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language_code = 4;

    pub fn language_code(&self) -> &str {
        match self.language_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language_code(&mut self) {
        self.language_code = ::std::option::Option::None;
    }

    pub fn has_language_code(&self) -> bool {
        self.language_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_code(&mut self, v: ::std::string::String) {
        self.language_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language_code(&mut self) -> &mut ::std::string::String {
        if self.language_code.is_none() {
            self.language_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_language_code(&mut self) -> ::std::string::String {
        self.language_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_id",
            |m: &CLobbyBroadcastChannelInfo| { &m.channel_id },
            |m: &mut CLobbyBroadcastChannelInfo| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CLobbyBroadcastChannelInfo| { &m.country_code },
            |m: &mut CLobbyBroadcastChannelInfo| { &mut m.country_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CLobbyBroadcastChannelInfo| { &m.description },
            |m: &mut CLobbyBroadcastChannelInfo| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language_code",
            |m: &CLobbyBroadcastChannelInfo| { &m.language_code },
            |m: &mut CLobbyBroadcastChannelInfo| { &mut m.language_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CLobbyBroadcastChannelInfo>(
            "CLobbyBroadcastChannelInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CLobbyBroadcastChannelInfo {
    const NAME: &'static str = "CLobbyBroadcastChannelInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.language_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.language_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.language_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyBroadcastChannelInfo {
        CLobbyBroadcastChannelInfo::new()
    }

    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.language_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyBroadcastChannelInfo {
        static instance: CLobbyBroadcastChannelInfo = CLobbyBroadcastChannelInfo {
            channel_id: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            description: ::std::option::Option::None,
            language_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CLobbyBroadcastChannelInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CLobbyBroadcastChannelInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CLobbyBroadcastChannelInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLobbyBroadcastChannelInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CLobbyGuildChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyGuildChallenge {
    // message fields
    // @@protoc_insertion_point(field:dota.CLobbyGuildChallenge.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildChallenge.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildChallenge.challenge_instance_id)
    pub challenge_instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildChallenge.challenge_parameter)
    pub challenge_parameter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildChallenge.challenge_timestamp)
    pub challenge_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildChallenge.challenge_period_serial)
    pub challenge_period_serial: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildChallenge.challenge_progress_at_start)
    pub challenge_progress_at_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CLobbyGuildChallenge.eligible_account_ids)
    pub eligible_account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CLobbyGuildChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyGuildChallenge {
    fn default() -> &'a CLobbyGuildChallenge {
        <CLobbyGuildChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CLobbyGuildChallenge {
    pub fn new() -> CLobbyGuildChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 challenge_instance_id = 3;

    pub fn challenge_instance_id(&self) -> u32 {
        self.challenge_instance_id.unwrap_or(0)
    }

    pub fn clear_challenge_instance_id(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
    }

    pub fn has_challenge_instance_id(&self) -> bool {
        self.challenge_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_instance_id(&mut self, v: u32) {
        self.challenge_instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_parameter = 4;

    pub fn challenge_parameter(&self) -> u32 {
        self.challenge_parameter.unwrap_or(0)
    }

    pub fn clear_challenge_parameter(&mut self) {
        self.challenge_parameter = ::std::option::Option::None;
    }

    pub fn has_challenge_parameter(&self) -> bool {
        self.challenge_parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_parameter(&mut self, v: u32) {
        self.challenge_parameter = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_timestamp = 5;

    pub fn challenge_timestamp(&self) -> u32 {
        self.challenge_timestamp.unwrap_or(0)
    }

    pub fn clear_challenge_timestamp(&mut self) {
        self.challenge_timestamp = ::std::option::Option::None;
    }

    pub fn has_challenge_timestamp(&self) -> bool {
        self.challenge_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_timestamp(&mut self, v: u32) {
        self.challenge_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_period_serial = 6;

    pub fn challenge_period_serial(&self) -> u32 {
        self.challenge_period_serial.unwrap_or(0)
    }

    pub fn clear_challenge_period_serial(&mut self) {
        self.challenge_period_serial = ::std::option::Option::None;
    }

    pub fn has_challenge_period_serial(&self) -> bool {
        self.challenge_period_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_period_serial(&mut self, v: u32) {
        self.challenge_period_serial = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_progress_at_start = 7;

    pub fn challenge_progress_at_start(&self) -> u32 {
        self.challenge_progress_at_start.unwrap_or(0)
    }

    pub fn clear_challenge_progress_at_start(&mut self) {
        self.challenge_progress_at_start = ::std::option::Option::None;
    }

    pub fn has_challenge_progress_at_start(&self) -> bool {
        self.challenge_progress_at_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_progress_at_start(&mut self, v: u32) {
        self.challenge_progress_at_start = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CLobbyGuildChallenge| { &m.guild_id },
            |m: &mut CLobbyGuildChallenge| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CLobbyGuildChallenge| { &m.event_id },
            |m: &mut CLobbyGuildChallenge| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_instance_id",
            |m: &CLobbyGuildChallenge| { &m.challenge_instance_id },
            |m: &mut CLobbyGuildChallenge| { &mut m.challenge_instance_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_parameter",
            |m: &CLobbyGuildChallenge| { &m.challenge_parameter },
            |m: &mut CLobbyGuildChallenge| { &mut m.challenge_parameter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_timestamp",
            |m: &CLobbyGuildChallenge| { &m.challenge_timestamp },
            |m: &mut CLobbyGuildChallenge| { &mut m.challenge_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_period_serial",
            |m: &CLobbyGuildChallenge| { &m.challenge_period_serial },
            |m: &mut CLobbyGuildChallenge| { &mut m.challenge_period_serial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_progress_at_start",
            |m: &CLobbyGuildChallenge| { &m.challenge_progress_at_start },
            |m: &mut CLobbyGuildChallenge| { &mut m.challenge_progress_at_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eligible_account_ids",
            |m: &CLobbyGuildChallenge| { &m.eligible_account_ids },
            |m: &mut CLobbyGuildChallenge| { &mut m.eligible_account_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CLobbyGuildChallenge>(
            "CLobbyGuildChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CLobbyGuildChallenge {
    const NAME: &'static str = "CLobbyGuildChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenge_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.challenge_period_serial = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.challenge_progress_at_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.eligible_account_ids)?;
                },
                64 => {
                    self.eligible_account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.challenge_instance_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.challenge_parameter {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenge_timestamp {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.challenge_period_serial {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.challenge_progress_at_start {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        for value in &self.eligible_account_ids {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.challenge_instance_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.challenge_parameter {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.challenge_period_serial {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.challenge_progress_at_start {
            os.write_uint32(7, v)?;
        }
        for v in &self.eligible_account_ids {
            os.write_uint32(8, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyGuildChallenge {
        CLobbyGuildChallenge::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.challenge_instance_id = ::std::option::Option::None;
        self.challenge_parameter = ::std::option::Option::None;
        self.challenge_timestamp = ::std::option::Option::None;
        self.challenge_period_serial = ::std::option::Option::None;
        self.challenge_progress_at_start = ::std::option::Option::None;
        self.eligible_account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyGuildChallenge {
        static instance: CLobbyGuildChallenge = CLobbyGuildChallenge {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            challenge_instance_id: ::std::option::Option::None,
            challenge_parameter: ::std::option::Option::None,
            challenge_timestamp: ::std::option::Option::None,
            challenge_period_serial: ::std::option::Option::None,
            challenge_progress_at_start: ::std::option::Option::None,
            eligible_account_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CLobbyGuildChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CLobbyGuildChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CLobbyGuildChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLobbyGuildChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSODOTALobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTALobby {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTALobby.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.all_members)
    pub all_members: ::std::vec::Vec<CSODOTALobbyMember>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.member_indices)
    pub member_indices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.left_member_indices)
    pub left_member_indices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.free_member_indices)
    pub free_member_indices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.leader_id)
    pub leader_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.server_id)
    pub server_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.pending_invites)
    pub pending_invites: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<csodotalobby::State>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.connect)
    pub connect: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.lobby_type)
    pub lobby_type: ::std::option::Option<::protobuf::EnumOrUnknown<csodotalobby::LobbyType>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.allow_cheats)
    pub allow_cheats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.fill_with_bots)
    pub fill_with_bots: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.intro_mode)
    pub intro_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.team_details)
    pub team_details: ::std::vec::Vec<CLobbyTeamDetails>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.tutorial_lesson)
    pub tutorial_lesson: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.tournament_game_id)
    pub tournament_game_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.game_state)
    pub game_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameState>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.num_spectators)
    pub num_spectators: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.matchgroup)
    pub matchgroup: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.cm_pick)
    pub cm_pick: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_CM_PICK>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.allow_spectating)
    pub allow_spectating: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.bot_difficulty_radiant)
    pub bot_difficulty_radiant: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.timed_reward_details)
    pub timed_reward_details: ::std::vec::Vec<CLobbyTimedRewardDetails>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.penalty_level_radiant)
    pub penalty_level_radiant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.penalty_level_dire)
    pub penalty_level_dire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.load_game_id)
    pub load_game_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.radiant_series_wins)
    pub radiant_series_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.dire_series_wins)
    pub dire_series_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.loot_generated)
    pub loot_generated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.loot_awarded)
    pub loot_awarded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.allchat)
    pub allchat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.dota_tv_delay)
    pub dota_tv_delay: ::std::option::Option<::protobuf::EnumOrUnknown<LobbyDotaTVDelay>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_game_mode)
    pub custom_game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_map_name)
    pub custom_map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_difficulty)
    pub custom_difficulty: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.lan)
    pub lan: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.broadcast_channel_info)
    pub broadcast_channel_info: ::std::vec::Vec<CLobbyBroadcastChannelInfo>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.first_leaver_accountid)
    pub first_leaver_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.series_id)
    pub series_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.low_priority)
    pub low_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.extra_messages)
    pub extra_messages: ::std::vec::Vec<csodotalobby::CExtraMsg>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.save_game)
    pub save_game: ::protobuf::MessageField<super::dota_shared_enums::CDOTASaveGame>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.first_blood_happened)
    pub first_blood_happened: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.match_outcome)
    pub match_outcome: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchOutcome>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.mass_disconnect)
    pub mass_disconnect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_min_players)
    pub custom_min_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_max_players)
    pub custom_max_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.visibility)
    pub visibility: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALobbyVisibility>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_game_auto_created_lobby)
    pub custom_game_auto_created_lobby: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.previous_series_matches)
    pub previous_series_matches: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.previous_match_override)
    pub previous_match_override: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.game_start_time)
    pub game_start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.pause_setting)
    pub pause_setting: ::std::option::Option<::protobuf::EnumOrUnknown<LobbyDotaPauseSetting>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.weekend_tourney_division_id)
    pub weekend_tourney_division_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.weekend_tourney_skill_level)
    pub weekend_tourney_skill_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.weekend_tourney_bracket_round)
    pub weekend_tourney_bracket_round: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.bot_difficulty_dire)
    pub bot_difficulty_dire: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.bot_radiant)
    pub bot_radiant: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.bot_dire)
    pub bot_dire: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.event_progression_enabled)
    pub event_progression_enabled: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.selection_priority_rules)
    pub selection_priority_rules: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTASelectionPriorityRules>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.series_previous_selection_priority_team_id)
    pub series_previous_selection_priority_team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.series_current_selection_priority_team_id)
    pub series_current_selection_priority_team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.series_current_priority_team_choice)
    pub series_current_priority_team_choice: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTASelectionPriorityChoice>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.series_current_non_priority_team_choice)
    pub series_current_non_priority_team_choice: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTASelectionPriorityChoice>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.series_current_selection_priority_used_coin_toss)
    pub series_current_selection_priority_used_coin_toss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.current_primary_event)
    pub current_primary_event: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.emergency_disabled_hero_ids)
    pub emergency_disabled_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_game_private_key)
    pub custom_game_private_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.custom_game_penalties)
    pub custom_game_penalties: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.lan_host_ping_location)
    pub lan_host_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.league_node_id)
    pub league_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.match_duration)
    pub match_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.league_phase)
    pub league_phase: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.record_detailed_stats)
    pub record_detailed_stats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.experimental_gameplay_enabled)
    pub experimental_gameplay_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.guild_challenges)
    pub guild_challenges: ::std::vec::Vec<CLobbyGuildChallenge>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.guild_details)
    pub guild_details: ::std::vec::Vec<CLobbyGuildDetails>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.lobby_event_points)
    pub lobby_event_points: ::std::vec::Vec<CMsgLobbyEventPoints>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.requested_hero_ids)
    pub requested_hero_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.coach_friend_requests)
    pub coach_friend_requests: ::std::vec::Vec<CMsgLobbyCoachFriendRequest>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.is_in_steam_china)
    pub is_in_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.with_scenario_save)
    pub with_scenario_save: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.lobby_creation_time)
    pub lobby_creation_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.event_game_definition)
    pub event_game_definition: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CSODOTALobby.extra_startup_messages)
    pub extra_startup_messages: ::std::vec::Vec<csodotalobby::CExtraMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTALobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTALobby {
    fn default() -> &'a CSODOTALobby {
        <CSODOTALobby as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTALobby {
    pub fn new() -> CSODOTALobby {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 leader_id = 11;

    pub fn leader_id(&self) -> u64 {
        self.leader_id.unwrap_or(0)
    }

    pub fn clear_leader_id(&mut self) {
        self.leader_id = ::std::option::Option::None;
    }

    pub fn has_leader_id(&self) -> bool {
        self.leader_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u64) {
        self.leader_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_id = 6;

    pub fn server_id(&self) -> u64 {
        self.server_id.unwrap_or(0)
    }

    pub fn clear_server_id(&mut self) {
        self.server_id = ::std::option::Option::None;
    }

    pub fn has_server_id(&self) -> bool {
        self.server_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_id(&mut self, v: u64) {
        self.server_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 3;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional .dota.CSODOTALobby.State state = 4;

    pub fn state(&self) -> csodotalobby::State {
        match self.state {
            Some(e) => e.enum_value_or(csodotalobby::State::UI),
            None => csodotalobby::State::UI,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: csodotalobby::State) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string connect = 5;

    pub fn connect(&self) -> &str {
        match self.connect.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connect(&mut self) {
        self.connect = ::std::option::Option::None;
    }

    pub fn has_connect(&self) -> bool {
        self.connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect(&mut self, v: ::std::string::String) {
        self.connect = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect(&mut self) -> &mut ::std::string::String {
        if self.connect.is_none() {
            self.connect = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connect.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect(&mut self) -> ::std::string::String {
        self.connect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .dota.CSODOTALobby.LobbyType lobby_type = 12;

    pub fn lobby_type(&self) -> csodotalobby::LobbyType {
        match self.lobby_type {
            Some(e) => e.enum_value_or(csodotalobby::LobbyType::INVALID),
            None => csodotalobby::LobbyType::INVALID,
        }
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: csodotalobby::LobbyType) {
        self.lobby_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool allow_cheats = 13;

    pub fn allow_cheats(&self) -> bool {
        self.allow_cheats.unwrap_or(false)
    }

    pub fn clear_allow_cheats(&mut self) {
        self.allow_cheats = ::std::option::Option::None;
    }

    pub fn has_allow_cheats(&self) -> bool {
        self.allow_cheats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_cheats(&mut self, v: bool) {
        self.allow_cheats = ::std::option::Option::Some(v);
    }

    // optional bool fill_with_bots = 14;

    pub fn fill_with_bots(&self) -> bool {
        self.fill_with_bots.unwrap_or(false)
    }

    pub fn clear_fill_with_bots(&mut self) {
        self.fill_with_bots = ::std::option::Option::None;
    }

    pub fn has_fill_with_bots(&self) -> bool {
        self.fill_with_bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fill_with_bots(&mut self, v: bool) {
        self.fill_with_bots = ::std::option::Option::Some(v);
    }

    // optional bool intro_mode = 15;

    pub fn intro_mode(&self) -> bool {
        self.intro_mode.unwrap_or(false)
    }

    pub fn clear_intro_mode(&mut self) {
        self.intro_mode = ::std::option::Option::None;
    }

    pub fn has_intro_mode(&self) -> bool {
        self.intro_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intro_mode(&mut self, v: bool) {
        self.intro_mode = ::std::option::Option::Some(v);
    }

    // optional string game_name = 16;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 tutorial_lesson = 18;

    pub fn tutorial_lesson(&self) -> u32 {
        self.tutorial_lesson.unwrap_or(0)
    }

    pub fn clear_tutorial_lesson(&mut self) {
        self.tutorial_lesson = ::std::option::Option::None;
    }

    pub fn has_tutorial_lesson(&self) -> bool {
        self.tutorial_lesson.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tutorial_lesson(&mut self, v: u32) {
        self.tutorial_lesson = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_id = 19;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_game_id = 20;

    pub fn tournament_game_id(&self) -> u32 {
        self.tournament_game_id.unwrap_or(0)
    }

    pub fn clear_tournament_game_id(&mut self) {
        self.tournament_game_id = ::std::option::Option::None;
    }

    pub fn has_tournament_game_id(&self) -> bool {
        self.tournament_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_game_id(&mut self, v: u32) {
        self.tournament_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 21;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GameState game_state = 22;

    pub fn game_state(&self) -> super::dota_shared_enums::DOTA_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            None => super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: super::dota_shared_enums::DOTA_GameState) {
        self.game_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 num_spectators = 23;

    pub fn num_spectators(&self) -> u32 {
        self.num_spectators.unwrap_or(0)
    }

    pub fn clear_num_spectators(&mut self) {
        self.num_spectators = ::std::option::Option::None;
    }

    pub fn has_num_spectators(&self) -> bool {
        self.num_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_spectators(&mut self, v: u32) {
        self.num_spectators = ::std::option::Option::Some(v);
    }

    // optional uint32 matchgroup = 25;

    pub fn matchgroup(&self) -> u32 {
        self.matchgroup.unwrap_or(0)
    }

    pub fn clear_matchgroup(&mut self) {
        self.matchgroup = ::std::option::Option::None;
    }

    pub fn has_matchgroup(&self) -> bool {
        self.matchgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroup(&mut self, v: u32) {
        self.matchgroup = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_CM_PICK cm_pick = 28;

    pub fn cm_pick(&self) -> super::dota_shared_enums::DOTA_CM_PICK {
        match self.cm_pick {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_CM_PICK::DOTA_CM_RANDOM),
            None => super::dota_shared_enums::DOTA_CM_PICK::DOTA_CM_RANDOM,
        }
    }

    pub fn clear_cm_pick(&mut self) {
        self.cm_pick = ::std::option::Option::None;
    }

    pub fn has_cm_pick(&self) -> bool {
        self.cm_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cm_pick(&mut self, v: super::dota_shared_enums::DOTA_CM_PICK) {
        self.cm_pick = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 30;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool allow_spectating = 31;

    pub fn allow_spectating(&self) -> bool {
        self.allow_spectating.unwrap_or(false)
    }

    pub fn clear_allow_spectating(&mut self) {
        self.allow_spectating = ::std::option::Option::None;
    }

    pub fn has_allow_spectating(&self) -> bool {
        self.allow_spectating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_spectating(&mut self, v: bool) {
        self.allow_spectating = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTABotDifficulty bot_difficulty_radiant = 36;

    pub fn bot_difficulty_radiant(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_radiant {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_radiant(&mut self) {
        self.bot_difficulty_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_radiant(&self) -> bool {
        self.bot_difficulty_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_radiant(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_radiant = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string pass_key = 39;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 leagueid = 42;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_level_radiant = 43;

    pub fn penalty_level_radiant(&self) -> u32 {
        self.penalty_level_radiant.unwrap_or(0)
    }

    pub fn clear_penalty_level_radiant(&mut self) {
        self.penalty_level_radiant = ::std::option::Option::None;
    }

    pub fn has_penalty_level_radiant(&self) -> bool {
        self.penalty_level_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_level_radiant(&mut self, v: u32) {
        self.penalty_level_radiant = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_level_dire = 44;

    pub fn penalty_level_dire(&self) -> u32 {
        self.penalty_level_dire.unwrap_or(0)
    }

    pub fn clear_penalty_level_dire(&mut self) {
        self.penalty_level_dire = ::std::option::Option::None;
    }

    pub fn has_penalty_level_dire(&self) -> bool {
        self.penalty_level_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_level_dire(&mut self, v: u32) {
        self.penalty_level_dire = ::std::option::Option::Some(v);
    }

    // optional uint32 load_game_id = 45;

    pub fn load_game_id(&self) -> u32 {
        self.load_game_id.unwrap_or(0)
    }

    pub fn clear_load_game_id(&mut self) {
        self.load_game_id = ::std::option::Option::None;
    }

    pub fn has_load_game_id(&self) -> bool {
        self.load_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_game_id(&mut self, v: u32) {
        self.load_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 46;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 radiant_series_wins = 47;

    pub fn radiant_series_wins(&self) -> u32 {
        self.radiant_series_wins.unwrap_or(0)
    }

    pub fn clear_radiant_series_wins(&mut self) {
        self.radiant_series_wins = ::std::option::Option::None;
    }

    pub fn has_radiant_series_wins(&self) -> bool {
        self.radiant_series_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_series_wins(&mut self, v: u32) {
        self.radiant_series_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_series_wins = 48;

    pub fn dire_series_wins(&self) -> u32 {
        self.dire_series_wins.unwrap_or(0)
    }

    pub fn clear_dire_series_wins(&mut self) {
        self.dire_series_wins = ::std::option::Option::None;
    }

    pub fn has_dire_series_wins(&self) -> bool {
        self.dire_series_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_series_wins(&mut self, v: u32) {
        self.dire_series_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 loot_generated = 49;

    pub fn loot_generated(&self) -> u32 {
        self.loot_generated.unwrap_or(0)
    }

    pub fn clear_loot_generated(&mut self) {
        self.loot_generated = ::std::option::Option::None;
    }

    pub fn has_loot_generated(&self) -> bool {
        self.loot_generated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_generated(&mut self, v: u32) {
        self.loot_generated = ::std::option::Option::Some(v);
    }

    // optional uint32 loot_awarded = 50;

    pub fn loot_awarded(&self) -> u32 {
        self.loot_awarded.unwrap_or(0)
    }

    pub fn clear_loot_awarded(&mut self) {
        self.loot_awarded = ::std::option::Option::None;
    }

    pub fn has_loot_awarded(&self) -> bool {
        self.loot_awarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_awarded(&mut self, v: u32) {
        self.loot_awarded = ::std::option::Option::Some(v);
    }

    // optional bool allchat = 51;

    pub fn allchat(&self) -> bool {
        self.allchat.unwrap_or(false)
    }

    pub fn clear_allchat(&mut self) {
        self.allchat = ::std::option::Option::None;
    }

    pub fn has_allchat(&self) -> bool {
        self.allchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allchat(&mut self, v: bool) {
        self.allchat = ::std::option::Option::Some(v);
    }

    // optional .dota.LobbyDotaTVDelay dota_tv_delay = 53;

    pub fn dota_tv_delay(&self) -> LobbyDotaTVDelay {
        match self.dota_tv_delay {
            Some(e) => e.enum_value_or(LobbyDotaTVDelay::LobbyDotaTV_10),
            None => LobbyDotaTVDelay::LobbyDotaTV_10,
        }
    }

    pub fn clear_dota_tv_delay(&mut self) {
        self.dota_tv_delay = ::std::option::Option::None;
    }

    pub fn has_dota_tv_delay(&self) -> bool {
        self.dota_tv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota_tv_delay(&mut self, v: LobbyDotaTVDelay) {
        self.dota_tv_delay = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string custom_game_mode = 54;

    pub fn custom_game_mode(&self) -> &str {
        match self.custom_game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_game_mode(&mut self) {
        self.custom_game_mode = ::std::option::Option::None;
    }

    pub fn has_custom_game_mode(&self) -> bool {
        self.custom_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_mode(&mut self, v: ::std::string::String) {
        self.custom_game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_mode(&mut self) -> &mut ::std::string::String {
        if self.custom_game_mode.is_none() {
            self.custom_game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_mode(&mut self) -> ::std::string::String {
        self.custom_game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_map_name = 55;

    pub fn custom_map_name(&self) -> &str {
        match self.custom_map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_map_name(&mut self) {
        self.custom_map_name = ::std::option::Option::None;
    }

    pub fn has_custom_map_name(&self) -> bool {
        self.custom_map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_map_name(&mut self, v: ::std::string::String) {
        self.custom_map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_map_name(&mut self) -> &mut ::std::string::String {
        if self.custom_map_name.is_none() {
            self.custom_map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_map_name(&mut self) -> ::std::string::String {
        self.custom_map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 custom_difficulty = 56;

    pub fn custom_difficulty(&self) -> u32 {
        self.custom_difficulty.unwrap_or(0)
    }

    pub fn clear_custom_difficulty(&mut self) {
        self.custom_difficulty = ::std::option::Option::None;
    }

    pub fn has_custom_difficulty(&self) -> bool {
        self.custom_difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_difficulty(&mut self, v: u32) {
        self.custom_difficulty = ::std::option::Option::Some(v);
    }

    // optional bool lan = 57;

    pub fn lan(&self) -> bool {
        self.lan.unwrap_or(false)
    }

    pub fn clear_lan(&mut self) {
        self.lan = ::std::option::Option::None;
    }

    pub fn has_lan(&self) -> bool {
        self.lan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan(&mut self, v: bool) {
        self.lan = ::std::option::Option::Some(v);
    }

    // optional uint32 first_leaver_accountid = 59;

    pub fn first_leaver_accountid(&self) -> u32 {
        self.first_leaver_accountid.unwrap_or(0)
    }

    pub fn clear_first_leaver_accountid(&mut self) {
        self.first_leaver_accountid = ::std::option::Option::None;
    }

    pub fn has_first_leaver_accountid(&self) -> bool {
        self.first_leaver_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_leaver_accountid(&mut self, v: u32) {
        self.first_leaver_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 series_id = 60;

    pub fn series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 61;

    pub fn low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    // optional bool first_blood_happened = 65;

    pub fn first_blood_happened(&self) -> bool {
        self.first_blood_happened.unwrap_or(false)
    }

    pub fn clear_first_blood_happened(&mut self) {
        self.first_blood_happened = ::std::option::Option::None;
    }

    pub fn has_first_blood_happened(&self) -> bool {
        self.first_blood_happened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_happened(&mut self, v: bool) {
        self.first_blood_happened = ::std::option::Option::Some(v);
    }

    // optional .dota.EMatchOutcome match_outcome = 70;

    pub fn match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        match self.match_outcome {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown),
            None => super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown,
        }
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool mass_disconnect = 67;

    pub fn mass_disconnect(&self) -> bool {
        self.mass_disconnect.unwrap_or(false)
    }

    pub fn clear_mass_disconnect(&mut self) {
        self.mass_disconnect = ::std::option::Option::None;
    }

    pub fn has_mass_disconnect(&self) -> bool {
        self.mass_disconnect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mass_disconnect(&mut self, v: bool) {
        self.mass_disconnect = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 68;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_min_players = 71;

    pub fn custom_min_players(&self) -> u32 {
        self.custom_min_players.unwrap_or(0)
    }

    pub fn clear_custom_min_players(&mut self) {
        self.custom_min_players = ::std::option::Option::None;
    }

    pub fn has_custom_min_players(&self) -> bool {
        self.custom_min_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_min_players(&mut self, v: u32) {
        self.custom_min_players = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_max_players = 72;

    pub fn custom_max_players(&self) -> u32 {
        self.custom_max_players.unwrap_or(0)
    }

    pub fn clear_custom_max_players(&mut self) {
        self.custom_max_players = ::std::option::Option::None;
    }

    pub fn has_custom_max_players(&self) -> bool {
        self.custom_max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_max_players(&mut self, v: u32) {
        self.custom_max_players = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTALobbyVisibility visibility = 75;

    pub fn visibility(&self) -> super::dota_shared_enums::DOTALobbyVisibility {
        match self.visibility {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALobbyVisibility::DOTALobbyVisibility_Public),
            None => super::dota_shared_enums::DOTALobbyVisibility::DOTALobbyVisibility_Public,
        }
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: super::dota_shared_enums::DOTALobbyVisibility) {
        self.visibility = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 custom_game_crc = 76;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional bool custom_game_auto_created_lobby = 77;

    pub fn custom_game_auto_created_lobby(&self) -> bool {
        self.custom_game_auto_created_lobby.unwrap_or(false)
    }

    pub fn clear_custom_game_auto_created_lobby(&mut self) {
        self.custom_game_auto_created_lobby = ::std::option::Option::None;
    }

    pub fn has_custom_game_auto_created_lobby(&self) -> bool {
        self.custom_game_auto_created_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_auto_created_lobby(&mut self, v: bool) {
        self.custom_game_auto_created_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 80;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 previous_match_override = 82;

    pub fn previous_match_override(&self) -> u64 {
        self.previous_match_override.unwrap_or(0)
    }

    pub fn clear_previous_match_override(&mut self) {
        self.previous_match_override = ::std::option::Option::None;
    }

    pub fn has_previous_match_override(&self) -> bool {
        self.previous_match_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous_match_override(&mut self, v: u64) {
        self.previous_match_override = ::std::option::Option::Some(v);
    }

    // optional uint32 game_start_time = 87;

    pub fn game_start_time(&self) -> u32 {
        self.game_start_time.unwrap_or(0)
    }

    pub fn clear_game_start_time(&mut self) {
        self.game_start_time = ::std::option::Option::None;
    }

    pub fn has_game_start_time(&self) -> bool {
        self.game_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_start_time(&mut self, v: u32) {
        self.game_start_time = ::std::option::Option::Some(v);
    }

    // optional .dota.LobbyDotaPauseSetting pause_setting = 88;

    pub fn pause_setting(&self) -> LobbyDotaPauseSetting {
        match self.pause_setting {
            Some(e) => e.enum_value_or(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited),
            None => LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited,
        }
    }

    pub fn clear_pause_setting(&mut self) {
        self.pause_setting = ::std::option::Option::None;
    }

    pub fn has_pause_setting(&self) -> bool {
        self.pause_setting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_setting(&mut self, v: LobbyDotaPauseSetting) {
        self.pause_setting = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 weekend_tourney_division_id = 90;

    pub fn weekend_tourney_division_id(&self) -> u32 {
        self.weekend_tourney_division_id.unwrap_or(0)
    }

    pub fn clear_weekend_tourney_division_id(&mut self) {
        self.weekend_tourney_division_id = ::std::option::Option::None;
    }

    pub fn has_weekend_tourney_division_id(&self) -> bool {
        self.weekend_tourney_division_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weekend_tourney_division_id(&mut self, v: u32) {
        self.weekend_tourney_division_id = ::std::option::Option::Some(v);
    }

    // optional uint32 weekend_tourney_skill_level = 91;

    pub fn weekend_tourney_skill_level(&self) -> u32 {
        self.weekend_tourney_skill_level.unwrap_or(0)
    }

    pub fn clear_weekend_tourney_skill_level(&mut self) {
        self.weekend_tourney_skill_level = ::std::option::Option::None;
    }

    pub fn has_weekend_tourney_skill_level(&self) -> bool {
        self.weekend_tourney_skill_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weekend_tourney_skill_level(&mut self, v: u32) {
        self.weekend_tourney_skill_level = ::std::option::Option::Some(v);
    }

    // optional uint32 weekend_tourney_bracket_round = 92;

    pub fn weekend_tourney_bracket_round(&self) -> u32 {
        self.weekend_tourney_bracket_round.unwrap_or(0)
    }

    pub fn clear_weekend_tourney_bracket_round(&mut self) {
        self.weekend_tourney_bracket_round = ::std::option::Option::None;
    }

    pub fn has_weekend_tourney_bracket_round(&self) -> bool {
        self.weekend_tourney_bracket_round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weekend_tourney_bracket_round(&mut self, v: u32) {
        self.weekend_tourney_bracket_round = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTABotDifficulty bot_difficulty_dire = 93;

    pub fn bot_difficulty_dire(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_dire {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_dire(&mut self) {
        self.bot_difficulty_dire = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_dire(&self) -> bool {
        self.bot_difficulty_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_dire(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_dire = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 bot_radiant = 94;

    pub fn bot_radiant(&self) -> u64 {
        self.bot_radiant.unwrap_or(0)
    }

    pub fn clear_bot_radiant(&mut self) {
        self.bot_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_radiant(&self) -> bool {
        self.bot_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_radiant(&mut self, v: u64) {
        self.bot_radiant = ::std::option::Option::Some(v);
    }

    // optional uint64 bot_dire = 95;

    pub fn bot_dire(&self) -> u64 {
        self.bot_dire.unwrap_or(0)
    }

    pub fn clear_bot_dire(&mut self) {
        self.bot_dire = ::std::option::Option::None;
    }

    pub fn has_bot_dire(&self) -> bool {
        self.bot_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_dire(&mut self, v: u64) {
        self.bot_dire = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTASelectionPriorityRules selection_priority_rules = 97;

    pub fn selection_priority_rules(&self) -> super::dota_shared_enums::DOTASelectionPriorityRules {
        match self.selection_priority_rules {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual),
            None => super::dota_shared_enums::DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual,
        }
    }

    pub fn clear_selection_priority_rules(&mut self) {
        self.selection_priority_rules = ::std::option::Option::None;
    }

    pub fn has_selection_priority_rules(&self) -> bool {
        self.selection_priority_rules.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_priority_rules(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityRules) {
        self.selection_priority_rules = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 series_previous_selection_priority_team_id = 98;

    pub fn series_previous_selection_priority_team_id(&self) -> u32 {
        self.series_previous_selection_priority_team_id.unwrap_or(0)
    }

    pub fn clear_series_previous_selection_priority_team_id(&mut self) {
        self.series_previous_selection_priority_team_id = ::std::option::Option::None;
    }

    pub fn has_series_previous_selection_priority_team_id(&self) -> bool {
        self.series_previous_selection_priority_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_previous_selection_priority_team_id(&mut self, v: u32) {
        self.series_previous_selection_priority_team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_current_selection_priority_team_id = 99;

    pub fn series_current_selection_priority_team_id(&self) -> u32 {
        self.series_current_selection_priority_team_id.unwrap_or(0)
    }

    pub fn clear_series_current_selection_priority_team_id(&mut self) {
        self.series_current_selection_priority_team_id = ::std::option::Option::None;
    }

    pub fn has_series_current_selection_priority_team_id(&self) -> bool {
        self.series_current_selection_priority_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_current_selection_priority_team_id(&mut self, v: u32) {
        self.series_current_selection_priority_team_id = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTASelectionPriorityChoice series_current_priority_team_choice = 100;

    pub fn series_current_priority_team_choice(&self) -> super::dota_shared_enums::DOTASelectionPriorityChoice {
        match self.series_current_priority_team_choice {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid),
            None => super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid,
        }
    }

    pub fn clear_series_current_priority_team_choice(&mut self) {
        self.series_current_priority_team_choice = ::std::option::Option::None;
    }

    pub fn has_series_current_priority_team_choice(&self) -> bool {
        self.series_current_priority_team_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_current_priority_team_choice(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityChoice) {
        self.series_current_priority_team_choice = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.DOTASelectionPriorityChoice series_current_non_priority_team_choice = 101;

    pub fn series_current_non_priority_team_choice(&self) -> super::dota_shared_enums::DOTASelectionPriorityChoice {
        match self.series_current_non_priority_team_choice {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid),
            None => super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid,
        }
    }

    pub fn clear_series_current_non_priority_team_choice(&mut self) {
        self.series_current_non_priority_team_choice = ::std::option::Option::None;
    }

    pub fn has_series_current_non_priority_team_choice(&self) -> bool {
        self.series_current_non_priority_team_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_current_non_priority_team_choice(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityChoice) {
        self.series_current_non_priority_team_choice = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool series_current_selection_priority_used_coin_toss = 102;

    pub fn series_current_selection_priority_used_coin_toss(&self) -> bool {
        self.series_current_selection_priority_used_coin_toss.unwrap_or(false)
    }

    pub fn clear_series_current_selection_priority_used_coin_toss(&mut self) {
        self.series_current_selection_priority_used_coin_toss = ::std::option::Option::None;
    }

    pub fn has_series_current_selection_priority_used_coin_toss(&self) -> bool {
        self.series_current_selection_priority_used_coin_toss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_current_selection_priority_used_coin_toss(&mut self, v: bool) {
        self.series_current_selection_priority_used_coin_toss = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent current_primary_event = 103;

    pub fn current_primary_event(&self) -> super::dota_shared_enums::EEvent {
        match self.current_primary_event {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_current_primary_event(&mut self) {
        self.current_primary_event = ::std::option::Option::None;
    }

    pub fn has_current_primary_event(&self) -> bool {
        self.current_primary_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_primary_event(&mut self, v: super::dota_shared_enums::EEvent) {
        self.current_primary_event = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 custom_game_private_key = 106;

    pub fn custom_game_private_key(&self) -> u64 {
        self.custom_game_private_key.unwrap_or(0)
    }

    pub fn clear_custom_game_private_key(&mut self) {
        self.custom_game_private_key = ::std::option::Option::None;
    }

    pub fn has_custom_game_private_key(&self) -> bool {
        self.custom_game_private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_private_key(&mut self, v: u64) {
        self.custom_game_private_key = ::std::option::Option::Some(v);
    }

    // optional bool custom_game_penalties = 107;

    pub fn custom_game_penalties(&self) -> bool {
        self.custom_game_penalties.unwrap_or(false)
    }

    pub fn clear_custom_game_penalties(&mut self) {
        self.custom_game_penalties = ::std::option::Option::None;
    }

    pub fn has_custom_game_penalties(&self) -> bool {
        self.custom_game_penalties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_penalties(&mut self, v: bool) {
        self.custom_game_penalties = ::std::option::Option::Some(v);
    }

    // optional string lan_host_ping_location = 109;

    pub fn lan_host_ping_location(&self) -> &str {
        match self.lan_host_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lan_host_ping_location(&mut self) {
        self.lan_host_ping_location = ::std::option::Option::None;
    }

    pub fn has_lan_host_ping_location(&self) -> bool {
        self.lan_host_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan_host_ping_location(&mut self, v: ::std::string::String) {
        self.lan_host_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lan_host_ping_location(&mut self) -> &mut ::std::string::String {
        if self.lan_host_ping_location.is_none() {
            self.lan_host_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lan_host_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_lan_host_ping_location(&mut self) -> ::std::string::String {
        self.lan_host_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 league_node_id = 110;

    pub fn league_node_id(&self) -> u32 {
        self.league_node_id.unwrap_or(0)
    }

    pub fn clear_league_node_id(&mut self) {
        self.league_node_id = ::std::option::Option::None;
    }

    pub fn has_league_node_id(&self) -> bool {
        self.league_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_node_id(&mut self, v: u32) {
        self.league_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 match_duration = 111;

    pub fn match_duration(&self) -> u32 {
        self.match_duration.unwrap_or(0)
    }

    pub fn clear_match_duration(&mut self) {
        self.match_duration = ::std::option::Option::None;
    }

    pub fn has_match_duration(&self) -> bool {
        self.match_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_duration(&mut self, v: u32) {
        self.match_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 league_phase = 113;

    pub fn league_phase(&self) -> u32 {
        self.league_phase.unwrap_or(0)
    }

    pub fn clear_league_phase(&mut self) {
        self.league_phase = ::std::option::Option::None;
    }

    pub fn has_league_phase(&self) -> bool {
        self.league_phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_phase(&mut self, v: u32) {
        self.league_phase = ::std::option::Option::Some(v);
    }

    // optional bool record_detailed_stats = 114;

    pub fn record_detailed_stats(&self) -> bool {
        self.record_detailed_stats.unwrap_or(false)
    }

    pub fn clear_record_detailed_stats(&mut self) {
        self.record_detailed_stats = ::std::option::Option::None;
    }

    pub fn has_record_detailed_stats(&self) -> bool {
        self.record_detailed_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record_detailed_stats(&mut self, v: bool) {
        self.record_detailed_stats = ::std::option::Option::Some(v);
    }

    // optional bool experimental_gameplay_enabled = 116;

    pub fn experimental_gameplay_enabled(&self) -> bool {
        self.experimental_gameplay_enabled.unwrap_or(false)
    }

    pub fn clear_experimental_gameplay_enabled(&mut self) {
        self.experimental_gameplay_enabled = ::std::option::Option::None;
    }

    pub fn has_experimental_gameplay_enabled(&self) -> bool {
        self.experimental_gameplay_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_gameplay_enabled(&mut self, v: bool) {
        self.experimental_gameplay_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_in_steam_china = 126;

    pub fn is_in_steam_china(&self) -> bool {
        self.is_in_steam_china.unwrap_or(false)
    }

    pub fn clear_is_in_steam_china(&mut self) {
        self.is_in_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_in_steam_china(&self) -> bool {
        self.is_in_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_in_steam_china(&mut self, v: bool) {
        self.is_in_steam_china = ::std::option::Option::Some(v);
    }

    // optional bool with_scenario_save = 127;

    pub fn with_scenario_save(&self) -> bool {
        self.with_scenario_save.unwrap_or(false)
    }

    pub fn clear_with_scenario_save(&mut self) {
        self.with_scenario_save = ::std::option::Option::None;
    }

    pub fn has_with_scenario_save(&self) -> bool {
        self.with_scenario_save.is_some()
    }

    // Param is passed by value, moved
    pub fn set_with_scenario_save(&mut self, v: bool) {
        self.with_scenario_save = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_creation_time = 128;

    pub fn lobby_creation_time(&self) -> u32 {
        self.lobby_creation_time.unwrap_or(0)
    }

    pub fn clear_lobby_creation_time(&mut self) {
        self.lobby_creation_time = ::std::option::Option::None;
    }

    pub fn has_lobby_creation_time(&self) -> bool {
        self.lobby_creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_creation_time(&mut self, v: u32) {
        self.lobby_creation_time = ::std::option::Option::Some(v);
    }

    // optional string event_game_definition = 129;

    pub fn event_game_definition(&self) -> &str {
        match self.event_game_definition.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_game_definition(&mut self) {
        self.event_game_definition = ::std::option::Option::None;
    }

    pub fn has_event_game_definition(&self) -> bool {
        self.event_game_definition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_game_definition(&mut self, v: ::std::string::String) {
        self.event_game_definition = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_game_definition(&mut self) -> &mut ::std::string::String {
        if self.event_game_definition.is_none() {
            self.event_game_definition = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_game_definition.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_game_definition(&mut self) -> ::std::string::String {
        self.event_game_definition.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(98);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CSODOTALobby| { &m.lobby_id },
            |m: &mut CSODOTALobby| { &mut m.lobby_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "all_members",
            |m: &CSODOTALobby| { &m.all_members },
            |m: &mut CSODOTALobby| { &mut m.all_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "member_indices",
            |m: &CSODOTALobby| { &m.member_indices },
            |m: &mut CSODOTALobby| { &mut m.member_indices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "left_member_indices",
            |m: &CSODOTALobby| { &m.left_member_indices },
            |m: &mut CSODOTALobby| { &mut m.left_member_indices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "free_member_indices",
            |m: &CSODOTALobby| { &m.free_member_indices },
            |m: &mut CSODOTALobby| { &mut m.free_member_indices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leader_id",
            |m: &CSODOTALobby| { &m.leader_id },
            |m: &mut CSODOTALobby| { &mut m.leader_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_id",
            |m: &CSODOTALobby| { &m.server_id },
            |m: &mut CSODOTALobby| { &mut m.server_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CSODOTALobby| { &m.game_mode },
            |m: &mut CSODOTALobby| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pending_invites",
            |m: &CSODOTALobby| { &m.pending_invites },
            |m: &mut CSODOTALobby| { &mut m.pending_invites },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CSODOTALobby| { &m.state },
            |m: &mut CSODOTALobby| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connect",
            |m: &CSODOTALobby| { &m.connect },
            |m: &mut CSODOTALobby| { &mut m.connect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CSODOTALobby| { &m.lobby_type },
            |m: &mut CSODOTALobby| { &mut m.lobby_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_cheats",
            |m: &CSODOTALobby| { &m.allow_cheats },
            |m: &mut CSODOTALobby| { &mut m.allow_cheats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fill_with_bots",
            |m: &CSODOTALobby| { &m.fill_with_bots },
            |m: &mut CSODOTALobby| { &mut m.fill_with_bots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "intro_mode",
            |m: &CSODOTALobby| { &m.intro_mode },
            |m: &mut CSODOTALobby| { &mut m.intro_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_name",
            |m: &CSODOTALobby| { &m.game_name },
            |m: &mut CSODOTALobby| { &mut m.game_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_details",
            |m: &CSODOTALobby| { &m.team_details },
            |m: &mut CSODOTALobby| { &mut m.team_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tutorial_lesson",
            |m: &CSODOTALobby| { &m.tutorial_lesson },
            |m: &mut CSODOTALobby| { &mut m.tutorial_lesson },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_id",
            |m: &CSODOTALobby| { &m.tournament_id },
            |m: &mut CSODOTALobby| { &mut m.tournament_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_game_id",
            |m: &CSODOTALobby| { &m.tournament_game_id },
            |m: &mut CSODOTALobby| { &mut m.tournament_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CSODOTALobby| { &m.server_region },
            |m: &mut CSODOTALobby| { &mut m.server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_state",
            |m: &CSODOTALobby| { &m.game_state },
            |m: &mut CSODOTALobby| { &mut m.game_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_spectators",
            |m: &CSODOTALobby| { &m.num_spectators },
            |m: &mut CSODOTALobby| { &mut m.num_spectators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchgroup",
            |m: &CSODOTALobby| { &m.matchgroup },
            |m: &mut CSODOTALobby| { &mut m.matchgroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cm_pick",
            |m: &CSODOTALobby| { &m.cm_pick },
            |m: &mut CSODOTALobby| { &mut m.cm_pick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CSODOTALobby| { &m.match_id },
            |m: &mut CSODOTALobby| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_spectating",
            |m: &CSODOTALobby| { &m.allow_spectating },
            |m: &mut CSODOTALobby| { &mut m.allow_spectating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_difficulty_radiant",
            |m: &CSODOTALobby| { &m.bot_difficulty_radiant },
            |m: &mut CSODOTALobby| { &mut m.bot_difficulty_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "timed_reward_details",
            |m: &CSODOTALobby| { &m.timed_reward_details },
            |m: &mut CSODOTALobby| { &mut m.timed_reward_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pass_key",
            |m: &CSODOTALobby| { &m.pass_key },
            |m: &mut CSODOTALobby| { &mut m.pass_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leagueid",
            |m: &CSODOTALobby| { &m.leagueid },
            |m: &mut CSODOTALobby| { &mut m.leagueid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_level_radiant",
            |m: &CSODOTALobby| { &m.penalty_level_radiant },
            |m: &mut CSODOTALobby| { &mut m.penalty_level_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_level_dire",
            |m: &CSODOTALobby| { &m.penalty_level_dire },
            |m: &mut CSODOTALobby| { &mut m.penalty_level_dire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "load_game_id",
            |m: &CSODOTALobby| { &m.load_game_id },
            |m: &mut CSODOTALobby| { &mut m.load_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_type",
            |m: &CSODOTALobby| { &m.series_type },
            |m: &mut CSODOTALobby| { &mut m.series_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_series_wins",
            |m: &CSODOTALobby| { &m.radiant_series_wins },
            |m: &mut CSODOTALobby| { &mut m.radiant_series_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_series_wins",
            |m: &CSODOTALobby| { &m.dire_series_wins },
            |m: &mut CSODOTALobby| { &mut m.dire_series_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loot_generated",
            |m: &CSODOTALobby| { &m.loot_generated },
            |m: &mut CSODOTALobby| { &mut m.loot_generated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loot_awarded",
            |m: &CSODOTALobby| { &m.loot_awarded },
            |m: &mut CSODOTALobby| { &mut m.loot_awarded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allchat",
            |m: &CSODOTALobby| { &m.allchat },
            |m: &mut CSODOTALobby| { &mut m.allchat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dota_tv_delay",
            |m: &CSODOTALobby| { &m.dota_tv_delay },
            |m: &mut CSODOTALobby| { &mut m.dota_tv_delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_mode",
            |m: &CSODOTALobby| { &m.custom_game_mode },
            |m: &mut CSODOTALobby| { &mut m.custom_game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_map_name",
            |m: &CSODOTALobby| { &m.custom_map_name },
            |m: &mut CSODOTALobby| { &mut m.custom_map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_difficulty",
            |m: &CSODOTALobby| { &m.custom_difficulty },
            |m: &mut CSODOTALobby| { &mut m.custom_difficulty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lan",
            |m: &CSODOTALobby| { &m.lan },
            |m: &mut CSODOTALobby| { &mut m.lan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcast_channel_info",
            |m: &CSODOTALobby| { &m.broadcast_channel_info },
            |m: &mut CSODOTALobby| { &mut m.broadcast_channel_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_leaver_accountid",
            |m: &CSODOTALobby| { &m.first_leaver_accountid },
            |m: &mut CSODOTALobby| { &mut m.first_leaver_accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_id",
            |m: &CSODOTALobby| { &m.series_id },
            |m: &mut CSODOTALobby| { &mut m.series_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_priority",
            |m: &CSODOTALobby| { &m.low_priority },
            |m: &mut CSODOTALobby| { &mut m.low_priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extra_messages",
            |m: &CSODOTALobby| { &m.extra_messages },
            |m: &mut CSODOTALobby| { &mut m.extra_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_shared_enums::CDOTASaveGame>(
            "save_game",
            |m: &CSODOTALobby| { &m.save_game },
            |m: &mut CSODOTALobby| { &mut m.save_game },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_blood_happened",
            |m: &CSODOTALobby| { &m.first_blood_happened },
            |m: &mut CSODOTALobby| { &mut m.first_blood_happened },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_outcome",
            |m: &CSODOTALobby| { &m.match_outcome },
            |m: &mut CSODOTALobby| { &mut m.match_outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mass_disconnect",
            |m: &CSODOTALobby| { &m.mass_disconnect },
            |m: &mut CSODOTALobby| { &mut m.mass_disconnect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_id",
            |m: &CSODOTALobby| { &m.custom_game_id },
            |m: &mut CSODOTALobby| { &mut m.custom_game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_min_players",
            |m: &CSODOTALobby| { &m.custom_min_players },
            |m: &mut CSODOTALobby| { &mut m.custom_min_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_max_players",
            |m: &CSODOTALobby| { &m.custom_max_players },
            |m: &mut CSODOTALobby| { &mut m.custom_max_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "visibility",
            |m: &CSODOTALobby| { &m.visibility },
            |m: &mut CSODOTALobby| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_crc",
            |m: &CSODOTALobby| { &m.custom_game_crc },
            |m: &mut CSODOTALobby| { &mut m.custom_game_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_auto_created_lobby",
            |m: &CSODOTALobby| { &m.custom_game_auto_created_lobby },
            |m: &mut CSODOTALobby| { &mut m.custom_game_auto_created_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_timestamp",
            |m: &CSODOTALobby| { &m.custom_game_timestamp },
            |m: &mut CSODOTALobby| { &mut m.custom_game_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "previous_series_matches",
            |m: &CSODOTALobby| { &m.previous_series_matches },
            |m: &mut CSODOTALobby| { &mut m.previous_series_matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "previous_match_override",
            |m: &CSODOTALobby| { &m.previous_match_override },
            |m: &mut CSODOTALobby| { &mut m.previous_match_override },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_start_time",
            |m: &CSODOTALobby| { &m.game_start_time },
            |m: &mut CSODOTALobby| { &mut m.game_start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pause_setting",
            |m: &CSODOTALobby| { &m.pause_setting },
            |m: &mut CSODOTALobby| { &mut m.pause_setting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weekend_tourney_division_id",
            |m: &CSODOTALobby| { &m.weekend_tourney_division_id },
            |m: &mut CSODOTALobby| { &mut m.weekend_tourney_division_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weekend_tourney_skill_level",
            |m: &CSODOTALobby| { &m.weekend_tourney_skill_level },
            |m: &mut CSODOTALobby| { &mut m.weekend_tourney_skill_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weekend_tourney_bracket_round",
            |m: &CSODOTALobby| { &m.weekend_tourney_bracket_round },
            |m: &mut CSODOTALobby| { &mut m.weekend_tourney_bracket_round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_difficulty_dire",
            |m: &CSODOTALobby| { &m.bot_difficulty_dire },
            |m: &mut CSODOTALobby| { &mut m.bot_difficulty_dire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_radiant",
            |m: &CSODOTALobby| { &m.bot_radiant },
            |m: &mut CSODOTALobby| { &mut m.bot_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_dire",
            |m: &CSODOTALobby| { &m.bot_dire },
            |m: &mut CSODOTALobby| { &mut m.bot_dire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_progression_enabled",
            |m: &CSODOTALobby| { &m.event_progression_enabled },
            |m: &mut CSODOTALobby| { &mut m.event_progression_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selection_priority_rules",
            |m: &CSODOTALobby| { &m.selection_priority_rules },
            |m: &mut CSODOTALobby| { &mut m.selection_priority_rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_previous_selection_priority_team_id",
            |m: &CSODOTALobby| { &m.series_previous_selection_priority_team_id },
            |m: &mut CSODOTALobby| { &mut m.series_previous_selection_priority_team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_current_selection_priority_team_id",
            |m: &CSODOTALobby| { &m.series_current_selection_priority_team_id },
            |m: &mut CSODOTALobby| { &mut m.series_current_selection_priority_team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_current_priority_team_choice",
            |m: &CSODOTALobby| { &m.series_current_priority_team_choice },
            |m: &mut CSODOTALobby| { &mut m.series_current_priority_team_choice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_current_non_priority_team_choice",
            |m: &CSODOTALobby| { &m.series_current_non_priority_team_choice },
            |m: &mut CSODOTALobby| { &mut m.series_current_non_priority_team_choice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_current_selection_priority_used_coin_toss",
            |m: &CSODOTALobby| { &m.series_current_selection_priority_used_coin_toss },
            |m: &mut CSODOTALobby| { &mut m.series_current_selection_priority_used_coin_toss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_primary_event",
            |m: &CSODOTALobby| { &m.current_primary_event },
            |m: &mut CSODOTALobby| { &mut m.current_primary_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "emergency_disabled_hero_ids",
            |m: &CSODOTALobby| { &m.emergency_disabled_hero_ids },
            |m: &mut CSODOTALobby| { &mut m.emergency_disabled_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_private_key",
            |m: &CSODOTALobby| { &m.custom_game_private_key },
            |m: &mut CSODOTALobby| { &mut m.custom_game_private_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_penalties",
            |m: &CSODOTALobby| { &m.custom_game_penalties },
            |m: &mut CSODOTALobby| { &mut m.custom_game_penalties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lan_host_ping_location",
            |m: &CSODOTALobby| { &m.lan_host_ping_location },
            |m: &mut CSODOTALobby| { &mut m.lan_host_ping_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_node_id",
            |m: &CSODOTALobby| { &m.league_node_id },
            |m: &mut CSODOTALobby| { &mut m.league_node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_duration",
            |m: &CSODOTALobby| { &m.match_duration },
            |m: &mut CSODOTALobby| { &mut m.match_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_phase",
            |m: &CSODOTALobby| { &m.league_phase },
            |m: &mut CSODOTALobby| { &mut m.league_phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "record_detailed_stats",
            |m: &CSODOTALobby| { &m.record_detailed_stats },
            |m: &mut CSODOTALobby| { &mut m.record_detailed_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimental_gameplay_enabled",
            |m: &CSODOTALobby| { &m.experimental_gameplay_enabled },
            |m: &mut CSODOTALobby| { &mut m.experimental_gameplay_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_challenges",
            |m: &CSODOTALobby| { &m.guild_challenges },
            |m: &mut CSODOTALobby| { &mut m.guild_challenges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_details",
            |m: &CSODOTALobby| { &m.guild_details },
            |m: &mut CSODOTALobby| { &mut m.guild_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lobby_event_points",
            |m: &CSODOTALobby| { &m.lobby_event_points },
            |m: &mut CSODOTALobby| { &mut m.lobby_event_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requested_hero_ids",
            |m: &CSODOTALobby| { &m.requested_hero_ids },
            |m: &mut CSODOTALobby| { &mut m.requested_hero_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "coach_friend_requests",
            |m: &CSODOTALobby| { &m.coach_friend_requests },
            |m: &mut CSODOTALobby| { &mut m.coach_friend_requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_in_steam_china",
            |m: &CSODOTALobby| { &m.is_in_steam_china },
            |m: &mut CSODOTALobby| { &mut m.is_in_steam_china },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "with_scenario_save",
            |m: &CSODOTALobby| { &m.with_scenario_save },
            |m: &mut CSODOTALobby| { &mut m.with_scenario_save },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_creation_time",
            |m: &CSODOTALobby| { &m.lobby_creation_time },
            |m: &mut CSODOTALobby| { &mut m.lobby_creation_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_game_definition",
            |m: &CSODOTALobby| { &m.event_game_definition },
            |m: &mut CSODOTALobby| { &mut m.event_game_definition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extra_startup_messages",
            |m: &CSODOTALobby| { &m.extra_startup_messages },
            |m: &mut CSODOTALobby| { &mut m.extra_startup_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTALobby>(
            "CSODOTALobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTALobby {
    const NAME: &'static str = "CSODOTALobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                962 => {
                    self.all_members.push(is.read_message()?);
                },
                970 => {
                    is.read_repeated_packed_uint32_into(&mut self.member_indices)?;
                },
                968 => {
                    self.member_indices.push(is.read_uint32()?);
                },
                978 => {
                    is.read_repeated_packed_uint32_into(&mut self.left_member_indices)?;
                },
                976 => {
                    self.left_member_indices.push(is.read_uint32()?);
                },
                986 => {
                    is.read_repeated_packed_uint32_into(&mut self.free_member_indices)?;
                },
                984 => {
                    self.free_member_indices.push(is.read_uint32()?);
                },
                89 => {
                    self.leader_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                49 => {
                    self.server_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_fixed64_into(&mut self.pending_invites)?;
                },
                81 => {
                    self.pending_invites.push(is.read_fixed64()?);
                },
                32 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.connect = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.allow_cheats = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.fill_with_bots = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.intro_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                130 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.team_details.push(is.read_message()?);
                },
                144 => {
                    self.tutorial_lesson = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.tournament_game_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                184 => {
                    self.num_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.matchgroup = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.cm_pick = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                240 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                248 => {
                    self.allow_spectating = ::std::option::Option::Some(is.read_bool()?);
                },
                288 => {
                    self.bot_difficulty_radiant = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                306 => {
                    self.timed_reward_details.push(is.read_message()?);
                },
                314 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                336 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                344 => {
                    self.penalty_level_radiant = ::std::option::Option::Some(is.read_uint32()?);
                },
                352 => {
                    self.penalty_level_dire = ::std::option::Option::Some(is.read_uint32()?);
                },
                360 => {
                    self.load_game_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.radiant_series_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                384 => {
                    self.dire_series_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                392 => {
                    self.loot_generated = ::std::option::Option::Some(is.read_uint32()?);
                },
                400 => {
                    self.loot_awarded = ::std::option::Option::Some(is.read_uint32()?);
                },
                408 => {
                    self.allchat = ::std::option::Option::Some(is.read_bool()?);
                },
                424 => {
                    self.dota_tv_delay = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                434 => {
                    self.custom_game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                442 => {
                    self.custom_map_name = ::std::option::Option::Some(is.read_string()?);
                },
                448 => {
                    self.custom_difficulty = ::std::option::Option::Some(is.read_uint32()?);
                },
                456 => {
                    self.lan = ::std::option::Option::Some(is.read_bool()?);
                },
                466 => {
                    self.broadcast_channel_info.push(is.read_message()?);
                },
                472 => {
                    self.first_leaver_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                480 => {
                    self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                488 => {
                    self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                498 => {
                    self.extra_messages.push(is.read_message()?);
                },
                506 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.save_game)?;
                },
                520 => {
                    self.first_blood_happened = ::std::option::Option::Some(is.read_bool()?);
                },
                560 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                536 => {
                    self.mass_disconnect = ::std::option::Option::Some(is.read_bool()?);
                },
                544 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                568 => {
                    self.custom_min_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.custom_max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                600 => {
                    self.visibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                609 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                616 => {
                    self.custom_game_auto_created_lobby = ::std::option::Option::Some(is.read_bool()?);
                },
                645 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                650 => {
                    is.read_repeated_packed_uint64_into(&mut self.previous_series_matches)?;
                },
                648 => {
                    self.previous_series_matches.push(is.read_uint64()?);
                },
                656 => {
                    self.previous_match_override = ::std::option::Option::Some(is.read_uint64()?);
                },
                696 => {
                    self.game_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                704 => {
                    self.pause_setting = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                720 => {
                    self.weekend_tourney_division_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                728 => {
                    self.weekend_tourney_skill_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                736 => {
                    self.weekend_tourney_bracket_round = ::std::option::Option::Some(is.read_uint32()?);
                },
                744 => {
                    self.bot_difficulty_dire = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                752 => {
                    self.bot_radiant = ::std::option::Option::Some(is.read_uint64()?);
                },
                760 => {
                    self.bot_dire = ::std::option::Option::Some(is.read_uint64()?);
                },
                768 => {
                    self.event_progression_enabled.push(is.read_enum_or_unknown()?);
                },
                770 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.event_progression_enabled)?
                },
                776 => {
                    self.selection_priority_rules = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                784 => {
                    self.series_previous_selection_priority_team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                792 => {
                    self.series_current_selection_priority_team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                800 => {
                    self.series_current_priority_team_choice = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                808 => {
                    self.series_current_non_priority_team_choice = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                816 => {
                    self.series_current_selection_priority_used_coin_toss = ::std::option::Option::Some(is.read_bool()?);
                },
                824 => {
                    self.current_primary_event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                842 => {
                    is.read_repeated_packed_uint32_into(&mut self.emergency_disabled_hero_ids)?;
                },
                840 => {
                    self.emergency_disabled_hero_ids.push(is.read_uint32()?);
                },
                849 => {
                    self.custom_game_private_key = ::std::option::Option::Some(is.read_fixed64()?);
                },
                856 => {
                    self.custom_game_penalties = ::std::option::Option::Some(is.read_bool()?);
                },
                874 => {
                    self.lan_host_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                880 => {
                    self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                888 => {
                    self.match_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                904 => {
                    self.league_phase = ::std::option::Option::Some(is.read_uint32()?);
                },
                912 => {
                    self.record_detailed_stats = ::std::option::Option::Some(is.read_bool()?);
                },
                928 => {
                    self.experimental_gameplay_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                938 => {
                    self.guild_challenges.push(is.read_message()?);
                },
                946 => {
                    self.guild_details.push(is.read_message()?);
                },
                954 => {
                    self.lobby_event_points.push(is.read_message()?);
                },
                994 => {
                    is.read_repeated_packed_uint32_into(&mut self.requested_hero_ids)?;
                },
                992 => {
                    self.requested_hero_ids.push(is.read_uint32()?);
                },
                1002 => {
                    self.coach_friend_requests.push(is.read_message()?);
                },
                1008 => {
                    self.is_in_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                1016 => {
                    self.with_scenario_save = ::std::option::Option::Some(is.read_bool()?);
                },
                1024 => {
                    self.lobby_creation_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                1034 => {
                    self.event_game_definition = ::std::option::Option::Some(is.read_string()?);
                },
                1042 => {
                    self.extra_startup_messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.all_members {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.member_indices {
            my_size += ::protobuf::rt::uint32_size(121, *value);
        };
        for value in &self.left_member_indices {
            my_size += ::protobuf::rt::uint32_size(122, *value);
        };
        for value in &self.free_member_indices {
            my_size += ::protobuf::rt::uint32_size(123, *value);
        };
        if let Some(v) = self.leader_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.server_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += 9 * self.pending_invites.len() as u64;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.connect.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.allow_cheats {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fill_with_bots {
            my_size += 1 + 1;
        }
        if let Some(v) = self.intro_mode {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        for value in &self.team_details {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tutorial_lesson {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.tournament_game_id {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.game_state {
            my_size += ::protobuf::rt::int32_size(22, v.value());
        }
        if let Some(v) = self.num_spectators {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.matchgroup {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.cm_pick {
            my_size += ::protobuf::rt::int32_size(28, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(30, v);
        }
        if let Some(v) = self.allow_spectating {
            my_size += 2 + 1;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            my_size += ::protobuf::rt::int32_size(36, v.value());
        }
        for value in &self.timed_reward_details {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.penalty_level_radiant {
            my_size += ::protobuf::rt::uint32_size(43, v);
        }
        if let Some(v) = self.penalty_level_dire {
            my_size += ::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.load_game_id {
            my_size += ::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.radiant_series_wins {
            my_size += ::protobuf::rt::uint32_size(47, v);
        }
        if let Some(v) = self.dire_series_wins {
            my_size += ::protobuf::rt::uint32_size(48, v);
        }
        if let Some(v) = self.loot_generated {
            my_size += ::protobuf::rt::uint32_size(49, v);
        }
        if let Some(v) = self.loot_awarded {
            my_size += ::protobuf::rt::uint32_size(50, v);
        }
        if let Some(v) = self.allchat {
            my_size += 2 + 1;
        }
        if let Some(v) = self.dota_tv_delay {
            my_size += ::protobuf::rt::int32_size(53, v.value());
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            my_size += ::protobuf::rt::string_size(54, &v);
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(55, &v);
        }
        if let Some(v) = self.custom_difficulty {
            my_size += ::protobuf::rt::uint32_size(56, v);
        }
        if let Some(v) = self.lan {
            my_size += 2 + 1;
        }
        for value in &self.broadcast_channel_info {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.first_leaver_accountid {
            my_size += ::protobuf::rt::uint32_size(59, v);
        }
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::uint32_size(60, v);
        }
        if let Some(v) = self.low_priority {
            my_size += 2 + 1;
        }
        for value in &self.extra_messages {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.save_game.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.first_blood_happened {
            my_size += 2 + 1;
        }
        if let Some(v) = self.match_outcome {
            my_size += ::protobuf::rt::int32_size(70, v.value());
        }
        if let Some(v) = self.mass_disconnect {
            my_size += 2 + 1;
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::uint64_size(68, v);
        }
        if let Some(v) = self.custom_min_players {
            my_size += ::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.custom_max_players {
            my_size += ::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::int32_size(75, v.value());
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 2 + 8;
        }
        if let Some(v) = self.custom_game_auto_created_lobby {
            my_size += 2 + 1;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 2 + 4;
        }
        for value in &self.previous_series_matches {
            my_size += ::protobuf::rt::uint64_size(81, *value);
        };
        if let Some(v) = self.previous_match_override {
            my_size += ::protobuf::rt::uint64_size(82, v);
        }
        if let Some(v) = self.game_start_time {
            my_size += ::protobuf::rt::uint32_size(87, v);
        }
        if let Some(v) = self.pause_setting {
            my_size += ::protobuf::rt::int32_size(88, v.value());
        }
        if let Some(v) = self.weekend_tourney_division_id {
            my_size += ::protobuf::rt::uint32_size(90, v);
        }
        if let Some(v) = self.weekend_tourney_skill_level {
            my_size += ::protobuf::rt::uint32_size(91, v);
        }
        if let Some(v) = self.weekend_tourney_bracket_round {
            my_size += ::protobuf::rt::uint32_size(92, v);
        }
        if let Some(v) = self.bot_difficulty_dire {
            my_size += ::protobuf::rt::int32_size(93, v.value());
        }
        if let Some(v) = self.bot_radiant {
            my_size += ::protobuf::rt::uint64_size(94, v);
        }
        if let Some(v) = self.bot_dire {
            my_size += ::protobuf::rt::uint64_size(95, v);
        }
        for value in &self.event_progression_enabled {
            my_size += ::protobuf::rt::int32_size(96, value.value());
        };
        if let Some(v) = self.selection_priority_rules {
            my_size += ::protobuf::rt::int32_size(97, v.value());
        }
        if let Some(v) = self.series_previous_selection_priority_team_id {
            my_size += ::protobuf::rt::uint32_size(98, v);
        }
        if let Some(v) = self.series_current_selection_priority_team_id {
            my_size += ::protobuf::rt::uint32_size(99, v);
        }
        if let Some(v) = self.series_current_priority_team_choice {
            my_size += ::protobuf::rt::int32_size(100, v.value());
        }
        if let Some(v) = self.series_current_non_priority_team_choice {
            my_size += ::protobuf::rt::int32_size(101, v.value());
        }
        if let Some(v) = self.series_current_selection_priority_used_coin_toss {
            my_size += 2 + 1;
        }
        if let Some(v) = self.current_primary_event {
            my_size += ::protobuf::rt::int32_size(103, v.value());
        }
        for value in &self.emergency_disabled_hero_ids {
            my_size += ::protobuf::rt::uint32_size(105, *value);
        };
        if let Some(v) = self.custom_game_private_key {
            my_size += 2 + 8;
        }
        if let Some(v) = self.custom_game_penalties {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            my_size += ::protobuf::rt::string_size(109, &v);
        }
        if let Some(v) = self.league_node_id {
            my_size += ::protobuf::rt::uint32_size(110, v);
        }
        if let Some(v) = self.match_duration {
            my_size += ::protobuf::rt::uint32_size(111, v);
        }
        if let Some(v) = self.league_phase {
            my_size += ::protobuf::rt::uint32_size(113, v);
        }
        if let Some(v) = self.record_detailed_stats {
            my_size += 2 + 1;
        }
        if let Some(v) = self.experimental_gameplay_enabled {
            my_size += 2 + 1;
        }
        for value in &self.guild_challenges {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.guild_details {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.lobby_event_points {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.requested_hero_ids {
            my_size += ::protobuf::rt::uint32_size(124, *value);
        };
        for value in &self.coach_friend_requests {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_in_steam_china {
            my_size += 2 + 1;
        }
        if let Some(v) = self.with_scenario_save {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lobby_creation_time {
            my_size += ::protobuf::rt::uint32_size(128, v);
        }
        if let Some(v) = self.event_game_definition.as_ref() {
            my_size += ::protobuf::rt::string_size(129, &v);
        }
        for value in &self.extra_startup_messages {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.all_members {
            ::protobuf::rt::write_message_field_with_cached_size(120, v, os)?;
        };
        for v in &self.member_indices {
            os.write_uint32(121, *v)?;
        };
        for v in &self.left_member_indices {
            os.write_uint32(122, *v)?;
        };
        for v in &self.free_member_indices {
            os.write_uint32(123, *v)?;
        };
        if let Some(v) = self.leader_id {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.server_id {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(3, v)?;
        }
        for v in &self.pending_invites {
            os.write_fixed64(10, *v)?;
        };
        if let Some(v) = self.state {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.connect.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.allow_cheats {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.fill_with_bots {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.intro_mode {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(16, v)?;
        }
        for v in &self.team_details {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.tutorial_lesson {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.tournament_game_id {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.game_state {
            os.write_enum(22, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.num_spectators {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.matchgroup {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.cm_pick {
            os.write_enum(28, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(30, v)?;
        }
        if let Some(v) = self.allow_spectating {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            os.write_enum(36, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.timed_reward_details {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        };
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.penalty_level_radiant {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.penalty_level_dire {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.load_game_id {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.radiant_series_wins {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.dire_series_wins {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.loot_generated {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.loot_awarded {
            os.write_uint32(50, v)?;
        }
        if let Some(v) = self.allchat {
            os.write_bool(51, v)?;
        }
        if let Some(v) = self.dota_tv_delay {
            os.write_enum(53, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            os.write_string(54, v)?;
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            os.write_string(55, v)?;
        }
        if let Some(v) = self.custom_difficulty {
            os.write_uint32(56, v)?;
        }
        if let Some(v) = self.lan {
            os.write_bool(57, v)?;
        }
        for v in &self.broadcast_channel_info {
            ::protobuf::rt::write_message_field_with_cached_size(58, v, os)?;
        };
        if let Some(v) = self.first_leaver_accountid {
            os.write_uint32(59, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(60, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(61, v)?;
        }
        for v in &self.extra_messages {
            ::protobuf::rt::write_message_field_with_cached_size(62, v, os)?;
        };
        if let Some(v) = self.save_game.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(63, v, os)?;
        }
        if let Some(v) = self.first_blood_happened {
            os.write_bool(65, v)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(70, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mass_disconnect {
            os.write_bool(67, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(68, v)?;
        }
        if let Some(v) = self.custom_min_players {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.custom_max_players {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_enum(75, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(76, v)?;
        }
        if let Some(v) = self.custom_game_auto_created_lobby {
            os.write_bool(77, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(80, v)?;
        }
        for v in &self.previous_series_matches {
            os.write_uint64(81, *v)?;
        };
        if let Some(v) = self.previous_match_override {
            os.write_uint64(82, v)?;
        }
        if let Some(v) = self.game_start_time {
            os.write_uint32(87, v)?;
        }
        if let Some(v) = self.pause_setting {
            os.write_enum(88, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.weekend_tourney_division_id {
            os.write_uint32(90, v)?;
        }
        if let Some(v) = self.weekend_tourney_skill_level {
            os.write_uint32(91, v)?;
        }
        if let Some(v) = self.weekend_tourney_bracket_round {
            os.write_uint32(92, v)?;
        }
        if let Some(v) = self.bot_difficulty_dire {
            os.write_enum(93, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bot_radiant {
            os.write_uint64(94, v)?;
        }
        if let Some(v) = self.bot_dire {
            os.write_uint64(95, v)?;
        }
        for v in &self.event_progression_enabled {
            os.write_enum(96, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.selection_priority_rules {
            os.write_enum(97, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.series_previous_selection_priority_team_id {
            os.write_uint32(98, v)?;
        }
        if let Some(v) = self.series_current_selection_priority_team_id {
            os.write_uint32(99, v)?;
        }
        if let Some(v) = self.series_current_priority_team_choice {
            os.write_enum(100, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.series_current_non_priority_team_choice {
            os.write_enum(101, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.series_current_selection_priority_used_coin_toss {
            os.write_bool(102, v)?;
        }
        if let Some(v) = self.current_primary_event {
            os.write_enum(103, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.emergency_disabled_hero_ids {
            os.write_uint32(105, *v)?;
        };
        if let Some(v) = self.custom_game_private_key {
            os.write_fixed64(106, v)?;
        }
        if let Some(v) = self.custom_game_penalties {
            os.write_bool(107, v)?;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            os.write_string(109, v)?;
        }
        if let Some(v) = self.league_node_id {
            os.write_uint32(110, v)?;
        }
        if let Some(v) = self.match_duration {
            os.write_uint32(111, v)?;
        }
        if let Some(v) = self.league_phase {
            os.write_uint32(113, v)?;
        }
        if let Some(v) = self.record_detailed_stats {
            os.write_bool(114, v)?;
        }
        if let Some(v) = self.experimental_gameplay_enabled {
            os.write_bool(116, v)?;
        }
        for v in &self.guild_challenges {
            ::protobuf::rt::write_message_field_with_cached_size(117, v, os)?;
        };
        for v in &self.guild_details {
            ::protobuf::rt::write_message_field_with_cached_size(118, v, os)?;
        };
        for v in &self.lobby_event_points {
            ::protobuf::rt::write_message_field_with_cached_size(119, v, os)?;
        };
        for v in &self.requested_hero_ids {
            os.write_uint32(124, *v)?;
        };
        for v in &self.coach_friend_requests {
            ::protobuf::rt::write_message_field_with_cached_size(125, v, os)?;
        };
        if let Some(v) = self.is_in_steam_china {
            os.write_bool(126, v)?;
        }
        if let Some(v) = self.with_scenario_save {
            os.write_bool(127, v)?;
        }
        if let Some(v) = self.lobby_creation_time {
            os.write_uint32(128, v)?;
        }
        if let Some(v) = self.event_game_definition.as_ref() {
            os.write_string(129, v)?;
        }
        for v in &self.extra_startup_messages {
            ::protobuf::rt::write_message_field_with_cached_size(130, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTALobby {
        CSODOTALobby::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.all_members.clear();
        self.member_indices.clear();
        self.left_member_indices.clear();
        self.free_member_indices.clear();
        self.leader_id = ::std::option::Option::None;
        self.server_id = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.pending_invites.clear();
        self.state = ::std::option::Option::None;
        self.connect = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.allow_cheats = ::std::option::Option::None;
        self.fill_with_bots = ::std::option::Option::None;
        self.intro_mode = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.team_details.clear();
        self.tutorial_lesson = ::std::option::Option::None;
        self.tournament_id = ::std::option::Option::None;
        self.tournament_game_id = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.game_state = ::std::option::Option::None;
        self.num_spectators = ::std::option::Option::None;
        self.matchgroup = ::std::option::Option::None;
        self.cm_pick = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.allow_spectating = ::std::option::Option::None;
        self.bot_difficulty_radiant = ::std::option::Option::None;
        self.timed_reward_details.clear();
        self.pass_key = ::std::option::Option::None;
        self.leagueid = ::std::option::Option::None;
        self.penalty_level_radiant = ::std::option::Option::None;
        self.penalty_level_dire = ::std::option::Option::None;
        self.load_game_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.radiant_series_wins = ::std::option::Option::None;
        self.dire_series_wins = ::std::option::Option::None;
        self.loot_generated = ::std::option::Option::None;
        self.loot_awarded = ::std::option::Option::None;
        self.allchat = ::std::option::Option::None;
        self.dota_tv_delay = ::std::option::Option::None;
        self.custom_game_mode = ::std::option::Option::None;
        self.custom_map_name = ::std::option::Option::None;
        self.custom_difficulty = ::std::option::Option::None;
        self.lan = ::std::option::Option::None;
        self.broadcast_channel_info.clear();
        self.first_leaver_accountid = ::std::option::Option::None;
        self.series_id = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.extra_messages.clear();
        self.save_game.clear();
        self.first_blood_happened = ::std::option::Option::None;
        self.match_outcome = ::std::option::Option::None;
        self.mass_disconnect = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.custom_min_players = ::std::option::Option::None;
        self.custom_max_players = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_auto_created_lobby = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.previous_series_matches.clear();
        self.previous_match_override = ::std::option::Option::None;
        self.game_start_time = ::std::option::Option::None;
        self.pause_setting = ::std::option::Option::None;
        self.weekend_tourney_division_id = ::std::option::Option::None;
        self.weekend_tourney_skill_level = ::std::option::Option::None;
        self.weekend_tourney_bracket_round = ::std::option::Option::None;
        self.bot_difficulty_dire = ::std::option::Option::None;
        self.bot_radiant = ::std::option::Option::None;
        self.bot_dire = ::std::option::Option::None;
        self.event_progression_enabled.clear();
        self.selection_priority_rules = ::std::option::Option::None;
        self.series_previous_selection_priority_team_id = ::std::option::Option::None;
        self.series_current_selection_priority_team_id = ::std::option::Option::None;
        self.series_current_priority_team_choice = ::std::option::Option::None;
        self.series_current_non_priority_team_choice = ::std::option::Option::None;
        self.series_current_selection_priority_used_coin_toss = ::std::option::Option::None;
        self.current_primary_event = ::std::option::Option::None;
        self.emergency_disabled_hero_ids.clear();
        self.custom_game_private_key = ::std::option::Option::None;
        self.custom_game_penalties = ::std::option::Option::None;
        self.lan_host_ping_location = ::std::option::Option::None;
        self.league_node_id = ::std::option::Option::None;
        self.match_duration = ::std::option::Option::None;
        self.league_phase = ::std::option::Option::None;
        self.record_detailed_stats = ::std::option::Option::None;
        self.experimental_gameplay_enabled = ::std::option::Option::None;
        self.guild_challenges.clear();
        self.guild_details.clear();
        self.lobby_event_points.clear();
        self.requested_hero_ids.clear();
        self.coach_friend_requests.clear();
        self.is_in_steam_china = ::std::option::Option::None;
        self.with_scenario_save = ::std::option::Option::None;
        self.lobby_creation_time = ::std::option::Option::None;
        self.event_game_definition = ::std::option::Option::None;
        self.extra_startup_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTALobby {
        static instance: CSODOTALobby = CSODOTALobby {
            lobby_id: ::std::option::Option::None,
            all_members: ::std::vec::Vec::new(),
            member_indices: ::std::vec::Vec::new(),
            left_member_indices: ::std::vec::Vec::new(),
            free_member_indices: ::std::vec::Vec::new(),
            leader_id: ::std::option::Option::None,
            server_id: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            pending_invites: ::std::vec::Vec::new(),
            state: ::std::option::Option::None,
            connect: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            allow_cheats: ::std::option::Option::None,
            fill_with_bots: ::std::option::Option::None,
            intro_mode: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            team_details: ::std::vec::Vec::new(),
            tutorial_lesson: ::std::option::Option::None,
            tournament_id: ::std::option::Option::None,
            tournament_game_id: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            game_state: ::std::option::Option::None,
            num_spectators: ::std::option::Option::None,
            matchgroup: ::std::option::Option::None,
            cm_pick: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            allow_spectating: ::std::option::Option::None,
            bot_difficulty_radiant: ::std::option::Option::None,
            timed_reward_details: ::std::vec::Vec::new(),
            pass_key: ::std::option::Option::None,
            leagueid: ::std::option::Option::None,
            penalty_level_radiant: ::std::option::Option::None,
            penalty_level_dire: ::std::option::Option::None,
            load_game_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            radiant_series_wins: ::std::option::Option::None,
            dire_series_wins: ::std::option::Option::None,
            loot_generated: ::std::option::Option::None,
            loot_awarded: ::std::option::Option::None,
            allchat: ::std::option::Option::None,
            dota_tv_delay: ::std::option::Option::None,
            custom_game_mode: ::std::option::Option::None,
            custom_map_name: ::std::option::Option::None,
            custom_difficulty: ::std::option::Option::None,
            lan: ::std::option::Option::None,
            broadcast_channel_info: ::std::vec::Vec::new(),
            first_leaver_accountid: ::std::option::Option::None,
            series_id: ::std::option::Option::None,
            low_priority: ::std::option::Option::None,
            extra_messages: ::std::vec::Vec::new(),
            save_game: ::protobuf::MessageField::none(),
            first_blood_happened: ::std::option::Option::None,
            match_outcome: ::std::option::Option::None,
            mass_disconnect: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            custom_min_players: ::std::option::Option::None,
            custom_max_players: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_auto_created_lobby: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            previous_series_matches: ::std::vec::Vec::new(),
            previous_match_override: ::std::option::Option::None,
            game_start_time: ::std::option::Option::None,
            pause_setting: ::std::option::Option::None,
            weekend_tourney_division_id: ::std::option::Option::None,
            weekend_tourney_skill_level: ::std::option::Option::None,
            weekend_tourney_bracket_round: ::std::option::Option::None,
            bot_difficulty_dire: ::std::option::Option::None,
            bot_radiant: ::std::option::Option::None,
            bot_dire: ::std::option::Option::None,
            event_progression_enabled: ::std::vec::Vec::new(),
            selection_priority_rules: ::std::option::Option::None,
            series_previous_selection_priority_team_id: ::std::option::Option::None,
            series_current_selection_priority_team_id: ::std::option::Option::None,
            series_current_priority_team_choice: ::std::option::Option::None,
            series_current_non_priority_team_choice: ::std::option::Option::None,
            series_current_selection_priority_used_coin_toss: ::std::option::Option::None,
            current_primary_event: ::std::option::Option::None,
            emergency_disabled_hero_ids: ::std::vec::Vec::new(),
            custom_game_private_key: ::std::option::Option::None,
            custom_game_penalties: ::std::option::Option::None,
            lan_host_ping_location: ::std::option::Option::None,
            league_node_id: ::std::option::Option::None,
            match_duration: ::std::option::Option::None,
            league_phase: ::std::option::Option::None,
            record_detailed_stats: ::std::option::Option::None,
            experimental_gameplay_enabled: ::std::option::Option::None,
            guild_challenges: ::std::vec::Vec::new(),
            guild_details: ::std::vec::Vec::new(),
            lobby_event_points: ::std::vec::Vec::new(),
            requested_hero_ids: ::std::vec::Vec::new(),
            coach_friend_requests: ::std::vec::Vec::new(),
            is_in_steam_china: ::std::option::Option::None,
            with_scenario_save: ::std::option::Option::None,
            lobby_creation_time: ::std::option::Option::None,
            event_game_definition: ::std::option::Option::None,
            extra_startup_messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTALobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTALobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTALobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTALobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSODOTALobby`
pub mod csodotalobby {
    // @@protoc_insertion_point(message:dota.CSODOTALobby.CExtraMsg)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CExtraMsg {
        // message fields
        // @@protoc_insertion_point(field:dota.CSODOTALobby.CExtraMsg.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CSODOTALobby.CExtraMsg.contents)
        pub contents: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CSODOTALobby.CExtraMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CExtraMsg {
        fn default() -> &'a CExtraMsg {
            <CExtraMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl CExtraMsg {
        pub fn new() -> CExtraMsg {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional bytes contents = 2;

        pub fn contents(&self) -> &[u8] {
            match self.contents.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_contents(&mut self) {
            self.contents = ::std::option::Option::None;
        }

        pub fn has_contents(&self) -> bool {
            self.contents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
            self.contents = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.contents.is_none() {
                self.contents = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.contents.as_mut().unwrap()
        }

        // Take field
        pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
            self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &CExtraMsg| { &m.id },
                |m: &mut CExtraMsg| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "contents",
                |m: &CExtraMsg| { &m.contents },
                |m: &mut CExtraMsg| { &mut m.contents },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CExtraMsg>(
                "CSODOTALobby.CExtraMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CExtraMsg {
        const NAME: &'static str = "CExtraMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.contents = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.contents.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.contents.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CExtraMsg {
            CExtraMsg::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.contents = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CExtraMsg {
            static instance: CExtraMsg = CExtraMsg {
                id: ::std::option::Option::None,
                contents: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CExtraMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSODOTALobby.CExtraMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CExtraMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CExtraMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CSODOTALobby.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.State.UI)
        UI = 0,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.State.READYUP)
        READYUP = 4,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.State.SERVERSETUP)
        SERVERSETUP = 1,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.State.RUN)
        RUN = 2,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.State.POSTGAME)
        POSTGAME = 3,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.State.NOTREADY)
        NOTREADY = 5,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.State.SERVERASSIGN)
        SERVERASSIGN = 6,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::UI),
                4 => ::std::option::Option::Some(State::READYUP),
                1 => ::std::option::Option::Some(State::SERVERSETUP),
                2 => ::std::option::Option::Some(State::RUN),
                3 => ::std::option::Option::Some(State::POSTGAME),
                5 => ::std::option::Option::Some(State::NOTREADY),
                6 => ::std::option::Option::Some(State::SERVERASSIGN),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<State> {
            match str {
                "UI" => ::std::option::Option::Some(State::UI),
                "READYUP" => ::std::option::Option::Some(State::READYUP),
                "SERVERSETUP" => ::std::option::Option::Some(State::SERVERSETUP),
                "RUN" => ::std::option::Option::Some(State::RUN),
                "POSTGAME" => ::std::option::Option::Some(State::POSTGAME),
                "NOTREADY" => ::std::option::Option::Some(State::NOTREADY),
                "SERVERASSIGN" => ::std::option::Option::Some(State::SERVERASSIGN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::UI,
            State::READYUP,
            State::SERVERSETUP,
            State::RUN,
            State::POSTGAME,
            State::NOTREADY,
            State::SERVERASSIGN,
        ];
    }

    impl ::protobuf::EnumFull for State {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CSODOTALobby.State").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                State::UI => 0,
                State::READYUP => 1,
                State::SERVERSETUP => 2,
                State::RUN => 3,
                State::POSTGAME => 4,
                State::NOTREADY => 5,
                State::SERVERASSIGN => 6,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::UI
        }
    }

    impl State {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<State>("CSODOTALobby.State")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CSODOTALobby.LobbyType)
    pub enum LobbyType {
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.INVALID)
        INVALID = -1,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.CASUAL_MATCH)
        CASUAL_MATCH = 0,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.PRACTICE)
        PRACTICE = 1,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.COOP_BOT_MATCH)
        COOP_BOT_MATCH = 4,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.COMPETITIVE_MATCH)
        COMPETITIVE_MATCH = 7,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.WEEKEND_TOURNEY)
        WEEKEND_TOURNEY = 9,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.LOCAL_BOT_MATCH)
        LOCAL_BOT_MATCH = 10,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.SPECTATOR)
        SPECTATOR = 11,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.EVENT_MATCH)
        EVENT_MATCH = 12,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.NEW_PLAYER_POOL)
        NEW_PLAYER_POOL = 14,
        // @@protoc_insertion_point(enum_value:dota.CSODOTALobby.LobbyType.FEATURED_GAMEMODE)
        FEATURED_GAMEMODE = 15,
    }

    impl ::protobuf::Enum for LobbyType {
        const NAME: &'static str = "LobbyType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<LobbyType> {
            match value {
                -1 => ::std::option::Option::Some(LobbyType::INVALID),
                0 => ::std::option::Option::Some(LobbyType::CASUAL_MATCH),
                1 => ::std::option::Option::Some(LobbyType::PRACTICE),
                4 => ::std::option::Option::Some(LobbyType::COOP_BOT_MATCH),
                7 => ::std::option::Option::Some(LobbyType::COMPETITIVE_MATCH),
                9 => ::std::option::Option::Some(LobbyType::WEEKEND_TOURNEY),
                10 => ::std::option::Option::Some(LobbyType::LOCAL_BOT_MATCH),
                11 => ::std::option::Option::Some(LobbyType::SPECTATOR),
                12 => ::std::option::Option::Some(LobbyType::EVENT_MATCH),
                14 => ::std::option::Option::Some(LobbyType::NEW_PLAYER_POOL),
                15 => ::std::option::Option::Some(LobbyType::FEATURED_GAMEMODE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<LobbyType> {
            match str {
                "INVALID" => ::std::option::Option::Some(LobbyType::INVALID),
                "CASUAL_MATCH" => ::std::option::Option::Some(LobbyType::CASUAL_MATCH),
                "PRACTICE" => ::std::option::Option::Some(LobbyType::PRACTICE),
                "COOP_BOT_MATCH" => ::std::option::Option::Some(LobbyType::COOP_BOT_MATCH),
                "COMPETITIVE_MATCH" => ::std::option::Option::Some(LobbyType::COMPETITIVE_MATCH),
                "WEEKEND_TOURNEY" => ::std::option::Option::Some(LobbyType::WEEKEND_TOURNEY),
                "LOCAL_BOT_MATCH" => ::std::option::Option::Some(LobbyType::LOCAL_BOT_MATCH),
                "SPECTATOR" => ::std::option::Option::Some(LobbyType::SPECTATOR),
                "EVENT_MATCH" => ::std::option::Option::Some(LobbyType::EVENT_MATCH),
                "NEW_PLAYER_POOL" => ::std::option::Option::Some(LobbyType::NEW_PLAYER_POOL),
                "FEATURED_GAMEMODE" => ::std::option::Option::Some(LobbyType::FEATURED_GAMEMODE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [LobbyType] = &[
            LobbyType::INVALID,
            LobbyType::CASUAL_MATCH,
            LobbyType::PRACTICE,
            LobbyType::COOP_BOT_MATCH,
            LobbyType::COMPETITIVE_MATCH,
            LobbyType::WEEKEND_TOURNEY,
            LobbyType::LOCAL_BOT_MATCH,
            LobbyType::SPECTATOR,
            LobbyType::EVENT_MATCH,
            LobbyType::NEW_PLAYER_POOL,
            LobbyType::FEATURED_GAMEMODE,
        ];
    }

    impl ::protobuf::EnumFull for LobbyType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CSODOTALobby.LobbyType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                LobbyType::INVALID => 0,
                LobbyType::CASUAL_MATCH => 1,
                LobbyType::PRACTICE => 2,
                LobbyType::COOP_BOT_MATCH => 3,
                LobbyType::COMPETITIVE_MATCH => 4,
                LobbyType::WEEKEND_TOURNEY => 5,
                LobbyType::LOCAL_BOT_MATCH => 6,
                LobbyType::SPECTATOR => 7,
                LobbyType::EVENT_MATCH => 8,
                LobbyType::NEW_PLAYER_POOL => 9,
                LobbyType::FEATURED_GAMEMODE => 10,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for LobbyType {
        fn default() -> Self {
            LobbyType::INVALID
        }
    }

    impl LobbyType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LobbyType>("CSODOTALobby.LobbyType")
        }
    }
}

// @@protoc_insertion_point(message:dota.CSODOTAServerLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAServerLobby {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTAServerLobby.all_members)
    pub all_members: ::std::vec::Vec<CSODOTAServerLobbyMember>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAServerLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAServerLobby {
    fn default() -> &'a CSODOTAServerLobby {
        <CSODOTAServerLobby as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAServerLobby {
    pub fn new() -> CSODOTAServerLobby {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "all_members",
            |m: &CSODOTAServerLobby| { &m.all_members },
            |m: &mut CSODOTAServerLobby| { &mut m.all_members },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAServerLobby>(
            "CSODOTAServerLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAServerLobby {
    const NAME: &'static str = "CSODOTAServerLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.all_members.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.all_members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.all_members {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAServerLobby {
        CSODOTAServerLobby::new()
    }

    fn clear(&mut self) {
        self.all_members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAServerLobby {
        static instance: CSODOTAServerLobby = CSODOTAServerLobby {
            all_members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAServerLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAServerLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAServerLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAServerLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSODOTAStaticLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAStaticLobby {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTAStaticLobby.all_members)
    pub all_members: ::std::vec::Vec<CSODOTAStaticLobbyMember>,
    // @@protoc_insertion_point(field:dota.CSODOTAStaticLobby.is_player_draft)
    pub is_player_draft: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAStaticLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAStaticLobby {
    fn default() -> &'a CSODOTAStaticLobby {
        <CSODOTAStaticLobby as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAStaticLobby {
    pub fn new() -> CSODOTAStaticLobby {
        ::std::default::Default::default()
    }

    // optional bool is_player_draft = 2;

    pub fn is_player_draft(&self) -> bool {
        self.is_player_draft.unwrap_or(false)
    }

    pub fn clear_is_player_draft(&mut self) {
        self.is_player_draft = ::std::option::Option::None;
    }

    pub fn has_is_player_draft(&self) -> bool {
        self.is_player_draft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_player_draft(&mut self, v: bool) {
        self.is_player_draft = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "all_members",
            |m: &CSODOTAStaticLobby| { &m.all_members },
            |m: &mut CSODOTAStaticLobby| { &mut m.all_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_player_draft",
            |m: &CSODOTAStaticLobby| { &m.is_player_draft },
            |m: &mut CSODOTAStaticLobby| { &mut m.is_player_draft },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAStaticLobby>(
            "CSODOTAStaticLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAStaticLobby {
    const NAME: &'static str = "CSODOTAStaticLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.all_members.push(is.read_message()?);
                },
                16 => {
                    self.is_player_draft = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.all_members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_player_draft {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.all_members {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.is_player_draft {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAStaticLobby {
        CSODOTAStaticLobby::new()
    }

    fn clear(&mut self) {
        self.all_members.clear();
        self.is_player_draft = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAStaticLobby {
        static instance: CSODOTAStaticLobby = CSODOTAStaticLobby {
            all_members: ::std::vec::Vec::new(),
            is_player_draft: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAStaticLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAStaticLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAStaticLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAStaticLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSODOTAServerStaticLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAServerStaticLobby {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTAServerStaticLobby.all_members)
    pub all_members: ::std::vec::Vec<CSODOTAServerStaticLobbyMember>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAServerStaticLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAServerStaticLobby {
    fn default() -> &'a CSODOTAServerStaticLobby {
        <CSODOTAServerStaticLobby as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAServerStaticLobby {
    pub fn new() -> CSODOTAServerStaticLobby {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "all_members",
            |m: &CSODOTAServerStaticLobby| { &m.all_members },
            |m: &mut CSODOTAServerStaticLobby| { &mut m.all_members },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAServerStaticLobby>(
            "CSODOTAServerStaticLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAServerStaticLobby {
    const NAME: &'static str = "CSODOTAServerStaticLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.all_members.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.all_members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.all_members {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAServerStaticLobby {
        CSODOTAServerStaticLobby::new()
    }

    fn clear(&mut self) {
        self.all_members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAServerStaticLobby {
        static instance: CSODOTAServerStaticLobby = CSODOTAServerStaticLobby {
            all_members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAServerStaticLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAServerStaticLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAServerStaticLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAServerStaticLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAdditionalLobbyStartupAccountData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAdditionalLobbyStartupAccountData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAdditionalLobbyStartupAccountData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAdditionalLobbyStartupAccountData.plus_data)
    pub plus_data: ::protobuf::MessageField<CMsgLobbyPlayerPlusSubscriptionData>,
    // @@protoc_insertion_point(field:dota.CMsgAdditionalLobbyStartupAccountData.unlocked_chat_wheel_message_ranges)
    pub unlocked_chat_wheel_message_ranges: ::std::vec::Vec<cmsg_additional_lobby_startup_account_data::ChatWheelMessageRange>,
    // @@protoc_insertion_point(field:dota.CMsgAdditionalLobbyStartupAccountData.unlocked_ping_wheel_message_ranges)
    pub unlocked_ping_wheel_message_ranges: ::std::vec::Vec<cmsg_additional_lobby_startup_account_data::PingWheelMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAdditionalLobbyStartupAccountData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdditionalLobbyStartupAccountData {
    fn default() -> &'a CMsgAdditionalLobbyStartupAccountData {
        <CMsgAdditionalLobbyStartupAccountData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdditionalLobbyStartupAccountData {
    pub fn new() -> CMsgAdditionalLobbyStartupAccountData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgAdditionalLobbyStartupAccountData| { &m.account_id },
            |m: &mut CMsgAdditionalLobbyStartupAccountData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgLobbyPlayerPlusSubscriptionData>(
            "plus_data",
            |m: &CMsgAdditionalLobbyStartupAccountData| { &m.plus_data },
            |m: &mut CMsgAdditionalLobbyStartupAccountData| { &mut m.plus_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unlocked_chat_wheel_message_ranges",
            |m: &CMsgAdditionalLobbyStartupAccountData| { &m.unlocked_chat_wheel_message_ranges },
            |m: &mut CMsgAdditionalLobbyStartupAccountData| { &mut m.unlocked_chat_wheel_message_ranges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unlocked_ping_wheel_message_ranges",
            |m: &CMsgAdditionalLobbyStartupAccountData| { &m.unlocked_ping_wheel_message_ranges },
            |m: &mut CMsgAdditionalLobbyStartupAccountData| { &mut m.unlocked_ping_wheel_message_ranges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAdditionalLobbyStartupAccountData>(
            "CMsgAdditionalLobbyStartupAccountData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAdditionalLobbyStartupAccountData {
    const NAME: &'static str = "CMsgAdditionalLobbyStartupAccountData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.plus_data)?;
                },
                26 => {
                    self.unlocked_chat_wheel_message_ranges.push(is.read_message()?);
                },
                34 => {
                    self.unlocked_ping_wheel_message_ranges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.plus_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.unlocked_chat_wheel_message_ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.unlocked_ping_wheel_message_ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.plus_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.unlocked_chat_wheel_message_ranges {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.unlocked_ping_wheel_message_ranges {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdditionalLobbyStartupAccountData {
        CMsgAdditionalLobbyStartupAccountData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.plus_data.clear();
        self.unlocked_chat_wheel_message_ranges.clear();
        self.unlocked_ping_wheel_message_ranges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdditionalLobbyStartupAccountData {
        static instance: CMsgAdditionalLobbyStartupAccountData = CMsgAdditionalLobbyStartupAccountData {
            account_id: ::std::option::Option::None,
            plus_data: ::protobuf::MessageField::none(),
            unlocked_chat_wheel_message_ranges: ::std::vec::Vec::new(),
            unlocked_ping_wheel_message_ranges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAdditionalLobbyStartupAccountData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAdditionalLobbyStartupAccountData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAdditionalLobbyStartupAccountData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdditionalLobbyStartupAccountData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgAdditionalLobbyStartupAccountData`
pub mod cmsg_additional_lobby_startup_account_data {
    // @@protoc_insertion_point(message:dota.CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatWheelMessageRange {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange.message_id_start)
        pub message_id_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange.message_id_end)
        pub message_id_end: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatWheelMessageRange {
        fn default() -> &'a ChatWheelMessageRange {
            <ChatWheelMessageRange as ::protobuf::Message>::default_instance()
        }
    }

    impl ChatWheelMessageRange {
        pub fn new() -> ChatWheelMessageRange {
            ::std::default::Default::default()
        }

        // optional uint32 message_id_start = 1;

        pub fn message_id_start(&self) -> u32 {
            self.message_id_start.unwrap_or(0)
        }

        pub fn clear_message_id_start(&mut self) {
            self.message_id_start = ::std::option::Option::None;
        }

        pub fn has_message_id_start(&self) -> bool {
            self.message_id_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message_id_start(&mut self, v: u32) {
            self.message_id_start = ::std::option::Option::Some(v);
        }

        // optional uint32 message_id_end = 2;

        pub fn message_id_end(&self) -> u32 {
            self.message_id_end.unwrap_or(0)
        }

        pub fn clear_message_id_end(&mut self) {
            self.message_id_end = ::std::option::Option::None;
        }

        pub fn has_message_id_end(&self) -> bool {
            self.message_id_end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message_id_end(&mut self, v: u32) {
            self.message_id_end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message_id_start",
                |m: &ChatWheelMessageRange| { &m.message_id_start },
                |m: &mut ChatWheelMessageRange| { &mut m.message_id_start },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message_id_end",
                |m: &ChatWheelMessageRange| { &m.message_id_end },
                |m: &mut ChatWheelMessageRange| { &mut m.message_id_end },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatWheelMessageRange>(
                "CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChatWheelMessageRange {
        const NAME: &'static str = "ChatWheelMessageRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.message_id_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.message_id_end = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.message_id_start {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.message_id_end {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.message_id_start {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.message_id_end {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatWheelMessageRange {
            ChatWheelMessageRange::new()
        }

        fn clear(&mut self) {
            self.message_id_start = ::std::option::Option::None;
            self.message_id_end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatWheelMessageRange {
            static instance: ChatWheelMessageRange = ChatWheelMessageRange {
                message_id_start: ::std::option::Option::None,
                message_id_end: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChatWheelMessageRange {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChatWheelMessageRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChatWheelMessageRange {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PingWheelMessageRange {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange.message_id_start)
        pub message_id_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange.message_id_end)
        pub message_id_end: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PingWheelMessageRange {
        fn default() -> &'a PingWheelMessageRange {
            <PingWheelMessageRange as ::protobuf::Message>::default_instance()
        }
    }

    impl PingWheelMessageRange {
        pub fn new() -> PingWheelMessageRange {
            ::std::default::Default::default()
        }

        // optional uint32 message_id_start = 1;

        pub fn message_id_start(&self) -> u32 {
            self.message_id_start.unwrap_or(0)
        }

        pub fn clear_message_id_start(&mut self) {
            self.message_id_start = ::std::option::Option::None;
        }

        pub fn has_message_id_start(&self) -> bool {
            self.message_id_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message_id_start(&mut self, v: u32) {
            self.message_id_start = ::std::option::Option::Some(v);
        }

        // optional uint32 message_id_end = 2;

        pub fn message_id_end(&self) -> u32 {
            self.message_id_end.unwrap_or(0)
        }

        pub fn clear_message_id_end(&mut self) {
            self.message_id_end = ::std::option::Option::None;
        }

        pub fn has_message_id_end(&self) -> bool {
            self.message_id_end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message_id_end(&mut self, v: u32) {
            self.message_id_end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message_id_start",
                |m: &PingWheelMessageRange| { &m.message_id_start },
                |m: &mut PingWheelMessageRange| { &mut m.message_id_start },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message_id_end",
                |m: &PingWheelMessageRange| { &m.message_id_end },
                |m: &mut PingWheelMessageRange| { &mut m.message_id_end },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingWheelMessageRange>(
                "CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PingWheelMessageRange {
        const NAME: &'static str = "PingWheelMessageRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.message_id_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.message_id_end = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.message_id_start {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.message_id_end {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.message_id_start {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.message_id_end {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PingWheelMessageRange {
            PingWheelMessageRange::new()
        }

        fn clear(&mut self) {
            self.message_id_start = ::std::option::Option::None;
            self.message_id_end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PingWheelMessageRange {
            static instance: PingWheelMessageRange = PingWheelMessageRange {
                message_id_start: ::std::option::Option::None,
                message_id_end: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PingWheelMessageRange {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PingWheelMessageRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PingWheelMessageRange {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgLobbyInitializationComplete)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyInitializationComplete {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyInitializationComplete.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyInitializationComplete {
    fn default() -> &'a CMsgLobbyInitializationComplete {
        <CMsgLobbyInitializationComplete as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyInitializationComplete {
    pub fn new() -> CMsgLobbyInitializationComplete {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyInitializationComplete>(
            "CMsgLobbyInitializationComplete",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyInitializationComplete {
    const NAME: &'static str = "CMsgLobbyInitializationComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyInitializationComplete {
        CMsgLobbyInitializationComplete::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyInitializationComplete {
        static instance: CMsgLobbyInitializationComplete = CMsgLobbyInitializationComplete {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyInitializationComplete {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyInitializationComplete").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyInitializationComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyInitializationComplete {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLobbyPlaytestDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyPlaytestDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyPlaytestDetails.json)
    pub json: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyPlaytestDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyPlaytestDetails {
    fn default() -> &'a CMsgLobbyPlaytestDetails {
        <CMsgLobbyPlaytestDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyPlaytestDetails {
    pub fn new() -> CMsgLobbyPlaytestDetails {
        ::std::default::Default::default()
    }

    // optional string json = 1;

    pub fn json(&self) -> &str {
        match self.json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json(&mut self) {
        self.json = ::std::option::Option::None;
    }

    pub fn has_json(&self) -> bool {
        self.json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json(&mut self, v: ::std::string::String) {
        self.json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json(&mut self) -> &mut ::std::string::String {
        if self.json.is_none() {
            self.json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json.as_mut().unwrap()
    }

    // Take field
    pub fn take_json(&mut self) -> ::std::string::String {
        self.json.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "json",
            |m: &CMsgLobbyPlaytestDetails| { &m.json },
            |m: &mut CMsgLobbyPlaytestDetails| { &mut m.json },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyPlaytestDetails>(
            "CMsgLobbyPlaytestDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyPlaytestDetails {
    const NAME: &'static str = "CMsgLobbyPlaytestDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.json = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.json.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.json.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyPlaytestDetails {
        CMsgLobbyPlaytestDetails::new()
    }

    fn clear(&mut self) {
        self.json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyPlaytestDetails {
        static instance: CMsgLobbyPlaytestDetails = CMsgLobbyPlaytestDetails {
            json: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyPlaytestDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyPlaytestDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyPlaytestDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyPlaytestDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLocalServerGuildData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLocalServerGuildData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLocalServerGuildData.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerGuildData.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerGuildData.guild_points)
    pub guild_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerGuildData.guild_logo)
    pub guild_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerGuildData.guild_primary_color)
    pub guild_primary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerGuildData.guild_secondary_color)
    pub guild_secondary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerGuildData.guild_pattern)
    pub guild_pattern: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerGuildData.guild_flags)
    pub guild_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerGuildData.guild_weekly_percentile)
    pub guild_weekly_percentile: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLocalServerGuildData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLocalServerGuildData {
    fn default() -> &'a CMsgLocalServerGuildData {
        <CMsgLocalServerGuildData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLocalServerGuildData {
    pub fn new() -> CMsgLocalServerGuildData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 guild_points = 3;

    pub fn guild_points(&self) -> u32 {
        self.guild_points.unwrap_or(0)
    }

    pub fn clear_guild_points(&mut self) {
        self.guild_points = ::std::option::Option::None;
    }

    pub fn has_guild_points(&self) -> bool {
        self.guild_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_points(&mut self, v: u32) {
        self.guild_points = ::std::option::Option::Some(v);
    }

    // optional uint64 guild_logo = 4;

    pub fn guild_logo(&self) -> u64 {
        self.guild_logo.unwrap_or(0)
    }

    pub fn clear_guild_logo(&mut self) {
        self.guild_logo = ::std::option::Option::None;
    }

    pub fn has_guild_logo(&self) -> bool {
        self.guild_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_logo(&mut self, v: u64) {
        self.guild_logo = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_primary_color = 5;

    pub fn guild_primary_color(&self) -> u32 {
        self.guild_primary_color.unwrap_or(0)
    }

    pub fn clear_guild_primary_color(&mut self) {
        self.guild_primary_color = ::std::option::Option::None;
    }

    pub fn has_guild_primary_color(&self) -> bool {
        self.guild_primary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_primary_color(&mut self, v: u32) {
        self.guild_primary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_secondary_color = 6;

    pub fn guild_secondary_color(&self) -> u32 {
        self.guild_secondary_color.unwrap_or(0)
    }

    pub fn clear_guild_secondary_color(&mut self) {
        self.guild_secondary_color = ::std::option::Option::None;
    }

    pub fn has_guild_secondary_color(&self) -> bool {
        self.guild_secondary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_secondary_color(&mut self, v: u32) {
        self.guild_secondary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_pattern = 7;

    pub fn guild_pattern(&self) -> u32 {
        self.guild_pattern.unwrap_or(0)
    }

    pub fn clear_guild_pattern(&mut self) {
        self.guild_pattern = ::std::option::Option::None;
    }

    pub fn has_guild_pattern(&self) -> bool {
        self.guild_pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_pattern(&mut self, v: u32) {
        self.guild_pattern = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_flags = 8;

    pub fn guild_flags(&self) -> u32 {
        self.guild_flags.unwrap_or(0)
    }

    pub fn clear_guild_flags(&mut self) {
        self.guild_flags = ::std::option::Option::None;
    }

    pub fn has_guild_flags(&self) -> bool {
        self.guild_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_flags(&mut self, v: u32) {
        self.guild_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_weekly_percentile = 9;

    pub fn guild_weekly_percentile(&self) -> u32 {
        self.guild_weekly_percentile.unwrap_or(0)
    }

    pub fn clear_guild_weekly_percentile(&mut self) {
        self.guild_weekly_percentile = ::std::option::Option::None;
    }

    pub fn has_guild_weekly_percentile(&self) -> bool {
        self.guild_weekly_percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_weekly_percentile(&mut self, v: u32) {
        self.guild_weekly_percentile = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgLocalServerGuildData| { &m.guild_id },
            |m: &mut CMsgLocalServerGuildData| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgLocalServerGuildData| { &m.event_id },
            |m: &mut CMsgLocalServerGuildData| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_points",
            |m: &CMsgLocalServerGuildData| { &m.guild_points },
            |m: &mut CMsgLocalServerGuildData| { &mut m.guild_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_logo",
            |m: &CMsgLocalServerGuildData| { &m.guild_logo },
            |m: &mut CMsgLocalServerGuildData| { &mut m.guild_logo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_primary_color",
            |m: &CMsgLocalServerGuildData| { &m.guild_primary_color },
            |m: &mut CMsgLocalServerGuildData| { &mut m.guild_primary_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_secondary_color",
            |m: &CMsgLocalServerGuildData| { &m.guild_secondary_color },
            |m: &mut CMsgLocalServerGuildData| { &mut m.guild_secondary_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_pattern",
            |m: &CMsgLocalServerGuildData| { &m.guild_pattern },
            |m: &mut CMsgLocalServerGuildData| { &mut m.guild_pattern },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_flags",
            |m: &CMsgLocalServerGuildData| { &m.guild_flags },
            |m: &mut CMsgLocalServerGuildData| { &mut m.guild_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_weekly_percentile",
            |m: &CMsgLocalServerGuildData| { &m.guild_weekly_percentile },
            |m: &mut CMsgLocalServerGuildData| { &mut m.guild_weekly_percentile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLocalServerGuildData>(
            "CMsgLocalServerGuildData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLocalServerGuildData {
    const NAME: &'static str = "CMsgLocalServerGuildData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.guild_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.guild_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.guild_primary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.guild_secondary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.guild_pattern = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.guild_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.guild_weekly_percentile = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.guild_points {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.guild_logo {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.guild_primary_color {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.guild_secondary_color {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.guild_pattern {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.guild_flags {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.guild_weekly_percentile {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.guild_logo {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.guild_primary_color {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.guild_secondary_color {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.guild_pattern {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.guild_flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.guild_weekly_percentile {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLocalServerGuildData {
        CMsgLocalServerGuildData::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.guild_points = ::std::option::Option::None;
        self.guild_logo = ::std::option::Option::None;
        self.guild_primary_color = ::std::option::Option::None;
        self.guild_secondary_color = ::std::option::Option::None;
        self.guild_pattern = ::std::option::Option::None;
        self.guild_flags = ::std::option::Option::None;
        self.guild_weekly_percentile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLocalServerGuildData {
        static instance: CMsgLocalServerGuildData = CMsgLocalServerGuildData {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            guild_points: ::std::option::Option::None,
            guild_logo: ::std::option::Option::None,
            guild_primary_color: ::std::option::Option::None,
            guild_secondary_color: ::std::option::Option::None,
            guild_pattern: ::std::option::Option::None,
            guild_flags: ::std::option::Option::None,
            guild_weekly_percentile: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLocalServerGuildData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLocalServerGuildData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLocalServerGuildData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLocalServerGuildData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLocalServerFakeLobbyData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLocalServerFakeLobbyData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLocalServerFakeLobbyData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerFakeLobbyData.event_points)
    pub event_points: ::std::vec::Vec<CMsgLobbyEventPoints>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerFakeLobbyData.is_plus_subscriber)
    pub is_plus_subscriber: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerFakeLobbyData.primary_event_id)
    pub primary_event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerFakeLobbyData.favorite_team)
    pub favorite_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerFakeLobbyData.favorite_team_quality)
    pub favorite_team_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerFakeLobbyData.guild_info)
    pub guild_info: ::protobuf::MessageField<CMsgLocalServerGuildData>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerFakeLobbyData.teleport_fx_level)
    pub teleport_fx_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgLocalServerFakeLobbyData.additional_data)
    pub additional_data: ::protobuf::MessageField<CMsgAdditionalLobbyStartupAccountData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLocalServerFakeLobbyData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLocalServerFakeLobbyData {
    fn default() -> &'a CMsgLocalServerFakeLobbyData {
        <CMsgLocalServerFakeLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLocalServerFakeLobbyData {
    pub fn new() -> CMsgLocalServerFakeLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool is_plus_subscriber = 3;

    pub fn is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.unwrap_or(false)
    }

    pub fn clear_is_plus_subscriber(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
    }

    pub fn has_is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_subscriber(&mut self, v: bool) {
        self.is_plus_subscriber = ::std::option::Option::Some(v);
    }

    // optional uint32 primary_event_id = 4;

    pub fn primary_event_id(&self) -> u32 {
        self.primary_event_id.unwrap_or(0)
    }

    pub fn clear_primary_event_id(&mut self) {
        self.primary_event_id = ::std::option::Option::None;
    }

    pub fn has_primary_event_id(&self) -> bool {
        self.primary_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_event_id(&mut self, v: u32) {
        self.primary_event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 favorite_team = 5;

    pub fn favorite_team(&self) -> u32 {
        self.favorite_team.unwrap_or(0)
    }

    pub fn clear_favorite_team(&mut self) {
        self.favorite_team = ::std::option::Option::None;
    }

    pub fn has_favorite_team(&self) -> bool {
        self.favorite_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team(&mut self, v: u32) {
        self.favorite_team = ::std::option::Option::Some(v);
    }

    // optional uint32 favorite_team_quality = 6;

    pub fn favorite_team_quality(&self) -> u32 {
        self.favorite_team_quality.unwrap_or(0)
    }

    pub fn clear_favorite_team_quality(&mut self) {
        self.favorite_team_quality = ::std::option::Option::None;
    }

    pub fn has_favorite_team_quality(&self) -> bool {
        self.favorite_team_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_quality(&mut self, v: u32) {
        self.favorite_team_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 teleport_fx_level = 8;

    pub fn teleport_fx_level(&self) -> u32 {
        self.teleport_fx_level.unwrap_or(0)
    }

    pub fn clear_teleport_fx_level(&mut self) {
        self.teleport_fx_level = ::std::option::Option::None;
    }

    pub fn has_teleport_fx_level(&self) -> bool {
        self.teleport_fx_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teleport_fx_level(&mut self, v: u32) {
        self.teleport_fx_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgLocalServerFakeLobbyData| { &m.account_id },
            |m: &mut CMsgLocalServerFakeLobbyData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_points",
            |m: &CMsgLocalServerFakeLobbyData| { &m.event_points },
            |m: &mut CMsgLocalServerFakeLobbyData| { &mut m.event_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_plus_subscriber",
            |m: &CMsgLocalServerFakeLobbyData| { &m.is_plus_subscriber },
            |m: &mut CMsgLocalServerFakeLobbyData| { &mut m.is_plus_subscriber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_event_id",
            |m: &CMsgLocalServerFakeLobbyData| { &m.primary_event_id },
            |m: &mut CMsgLocalServerFakeLobbyData| { &mut m.primary_event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "favorite_team",
            |m: &CMsgLocalServerFakeLobbyData| { &m.favorite_team },
            |m: &mut CMsgLocalServerFakeLobbyData| { &mut m.favorite_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "favorite_team_quality",
            |m: &CMsgLocalServerFakeLobbyData| { &m.favorite_team_quality },
            |m: &mut CMsgLocalServerFakeLobbyData| { &mut m.favorite_team_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgLocalServerGuildData>(
            "guild_info",
            |m: &CMsgLocalServerFakeLobbyData| { &m.guild_info },
            |m: &mut CMsgLocalServerFakeLobbyData| { &mut m.guild_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "teleport_fx_level",
            |m: &CMsgLocalServerFakeLobbyData| { &m.teleport_fx_level },
            |m: &mut CMsgLocalServerFakeLobbyData| { &mut m.teleport_fx_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgAdditionalLobbyStartupAccountData>(
            "additional_data",
            |m: &CMsgLocalServerFakeLobbyData| { &m.additional_data },
            |m: &mut CMsgLocalServerFakeLobbyData| { &mut m.additional_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLocalServerFakeLobbyData>(
            "CMsgLocalServerFakeLobbyData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLocalServerFakeLobbyData {
    const NAME: &'static str = "CMsgLocalServerFakeLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.event_points.push(is.read_message()?);
                },
                24 => {
                    self.is_plus_subscriber = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.primary_event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.favorite_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.favorite_team_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                64 => {
                    self.teleport_fx_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.additional_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.event_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_plus_subscriber {
            my_size += 1 + 1;
        }
        if let Some(v) = self.primary_event_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.favorite_team {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.favorite_team_quality {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.teleport_fx_level {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.additional_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.event_points {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.is_plus_subscriber {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.primary_event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.favorite_team {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.favorite_team_quality {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.guild_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.teleport_fx_level {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.additional_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLocalServerFakeLobbyData {
        CMsgLocalServerFakeLobbyData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_points.clear();
        self.is_plus_subscriber = ::std::option::Option::None;
        self.primary_event_id = ::std::option::Option::None;
        self.favorite_team = ::std::option::Option::None;
        self.favorite_team_quality = ::std::option::Option::None;
        self.guild_info.clear();
        self.teleport_fx_level = ::std::option::Option::None;
        self.additional_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLocalServerFakeLobbyData {
        static instance: CMsgLocalServerFakeLobbyData = CMsgLocalServerFakeLobbyData {
            account_id: ::std::option::Option::None,
            event_points: ::std::vec::Vec::new(),
            is_plus_subscriber: ::std::option::Option::None,
            primary_event_id: ::std::option::Option::None,
            favorite_team: ::std::option::Option::None,
            favorite_team_quality: ::std::option::Option::None,
            guild_info: ::protobuf::MessageField::none(),
            teleport_fx_level: ::std::option::Option::None,
            additional_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLocalServerFakeLobbyData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLocalServerFakeLobbyData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLocalServerFakeLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLocalServerFakeLobbyData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELobbyMemberCoachRequestState)
pub enum ELobbyMemberCoachRequestState {
    // @@protoc_insertion_point(enum_value:dota.ELobbyMemberCoachRequestState.k_eLobbyMemberCoachRequestState_None)
    k_eLobbyMemberCoachRequestState_None = 0,
    // @@protoc_insertion_point(enum_value:dota.ELobbyMemberCoachRequestState.k_eLobbyMemberCoachRequestState_Accepted)
    k_eLobbyMemberCoachRequestState_Accepted = 1,
    // @@protoc_insertion_point(enum_value:dota.ELobbyMemberCoachRequestState.k_eLobbyMemberCoachRequestState_Rejected)
    k_eLobbyMemberCoachRequestState_Rejected = 2,
}

impl ::protobuf::Enum for ELobbyMemberCoachRequestState {
    const NAME: &'static str = "ELobbyMemberCoachRequestState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELobbyMemberCoachRequestState> {
        match value {
            0 => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None),
            1 => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Accepted),
            2 => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Rejected),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELobbyMemberCoachRequestState> {
        match str {
            "k_eLobbyMemberCoachRequestState_None" => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None),
            "k_eLobbyMemberCoachRequestState_Accepted" => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Accepted),
            "k_eLobbyMemberCoachRequestState_Rejected" => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Rejected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELobbyMemberCoachRequestState] = &[
        ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None,
        ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Accepted,
        ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Rejected,
    ];
}

impl ::protobuf::EnumFull for ELobbyMemberCoachRequestState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELobbyMemberCoachRequestState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELobbyMemberCoachRequestState {
    fn default() -> Self {
        ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None
    }
}

impl ELobbyMemberCoachRequestState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELobbyMemberCoachRequestState>("ELobbyMemberCoachRequestState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.LobbyDotaTVDelay)
pub enum LobbyDotaTVDelay {
    // @@protoc_insertion_point(enum_value:dota.LobbyDotaTVDelay.LobbyDotaTV_10)
    LobbyDotaTV_10 = 0,
    // @@protoc_insertion_point(enum_value:dota.LobbyDotaTVDelay.LobbyDotaTV_120)
    LobbyDotaTV_120 = 1,
    // @@protoc_insertion_point(enum_value:dota.LobbyDotaTVDelay.LobbyDotaTV_300)
    LobbyDotaTV_300 = 2,
    // @@protoc_insertion_point(enum_value:dota.LobbyDotaTVDelay.LobbyDotaTV_900)
    LobbyDotaTV_900 = 3,
}

impl ::protobuf::Enum for LobbyDotaTVDelay {
    const NAME: &'static str = "LobbyDotaTVDelay";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LobbyDotaTVDelay> {
        match value {
            0 => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_10),
            1 => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_120),
            2 => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_300),
            3 => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_900),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LobbyDotaTVDelay> {
        match str {
            "LobbyDotaTV_10" => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_10),
            "LobbyDotaTV_120" => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_120),
            "LobbyDotaTV_300" => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_300),
            "LobbyDotaTV_900" => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_900),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LobbyDotaTVDelay] = &[
        LobbyDotaTVDelay::LobbyDotaTV_10,
        LobbyDotaTVDelay::LobbyDotaTV_120,
        LobbyDotaTVDelay::LobbyDotaTV_300,
        LobbyDotaTVDelay::LobbyDotaTV_900,
    ];
}

impl ::protobuf::EnumFull for LobbyDotaTVDelay {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LobbyDotaTVDelay").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LobbyDotaTVDelay {
    fn default() -> Self {
        LobbyDotaTVDelay::LobbyDotaTV_10
    }
}

impl LobbyDotaTVDelay {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LobbyDotaTVDelay>("LobbyDotaTVDelay")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.LobbyDotaPauseSetting)
pub enum LobbyDotaPauseSetting {
    // @@protoc_insertion_point(enum_value:dota.LobbyDotaPauseSetting.LobbyDotaPauseSetting_Unlimited)
    LobbyDotaPauseSetting_Unlimited = 0,
    // @@protoc_insertion_point(enum_value:dota.LobbyDotaPauseSetting.LobbyDotaPauseSetting_Limited)
    LobbyDotaPauseSetting_Limited = 1,
    // @@protoc_insertion_point(enum_value:dota.LobbyDotaPauseSetting.LobbyDotaPauseSetting_Disabled)
    LobbyDotaPauseSetting_Disabled = 2,
}

impl ::protobuf::Enum for LobbyDotaPauseSetting {
    const NAME: &'static str = "LobbyDotaPauseSetting";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LobbyDotaPauseSetting> {
        match value {
            0 => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited),
            1 => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Limited),
            2 => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Disabled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LobbyDotaPauseSetting> {
        match str {
            "LobbyDotaPauseSetting_Unlimited" => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited),
            "LobbyDotaPauseSetting_Limited" => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Limited),
            "LobbyDotaPauseSetting_Disabled" => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Disabled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LobbyDotaPauseSetting] = &[
        LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited,
        LobbyDotaPauseSetting::LobbyDotaPauseSetting_Limited,
        LobbyDotaPauseSetting::LobbyDotaPauseSetting_Disabled,
    ];
}

impl ::protobuf::EnumFull for LobbyDotaPauseSetting {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LobbyDotaPauseSetting").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LobbyDotaPauseSetting {
    fn default() -> Self {
        LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited
    }
}

impl LobbyDotaPauseSetting {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LobbyDotaPauseSetting>("LobbyDotaPauseSetting")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"dota_gcmessages_common_lobby.proto\x12\x04dota\x1a\x13steammessages.\
    proto\x1a\x17dota_shared_enums.proto\"\xbd\x01\n\x1bCMsgLobbyCoachFriend\
    Request\x12(\n\x10coach_account_id\x18\x01\x20\x01(\rR\x0ecoachAccountId\
    \x12*\n\x11player_account_id\x18\x02\x20\x01(\rR\x0fplayerAccountId\x12H\
    \n\rrequest_state\x18\x03\x20\x01(\x0e2#.dota.ELobbyMemberCoachRequestSt\
    ateR\x0crequestState\"\xc5\x01\n#CMsgLobbyPlayerPlusSubscriptionData\x12\
    T\n\x0bhero_badges\x18\x01\x20\x03(\x0b23.dota.CMsgLobbyPlayerPlusSubscr\
    iptionData.HeroBadgeR\nheroBadges\x1aH\n\tHeroBadge\x12\x17\n\x07hero_id\
    \x18\x01\x20\x01(\rR\x06heroId\x12\"\n\rhero_badge_xp\x18\x02\x20\x01(\r\
    R\x0bheroBadgeXp\"\xfc\x07\n\x14CMsgLobbyEventPoints\x12\x19\n\x08event_\
    id\x18\x01\x20\x01(\rR\x07eventId\x12O\n\x0eaccount_points\x18\x02\x20\
    \x03(\x0b2(.dota.CMsgLobbyEventPoints.AccountPointsR\raccountPoints\x1ax\
    \n\x14PeriodicResourceData\x120\n\x14periodic_resource_id\x18\x01\x20\
    \x01(\rR\x12periodicResourceId\x12\x1c\n\tremaining\x18\x02\x20\x01(\rR\
    \tremaining\x12\x10\n\x03max\x18\x03\x20\x01(\rR\x03max\x1aX\n\x14Networ\
    kedEventAction\x12\x1b\n\taction_id\x18\x01\x20\x01(\rR\x08actionId\x12#\
    \n\rtimes_granted\x18\x02\x20\x01(\rR\x0ctimesGranted\x1a\xa3\x05\n\rAcc\
    ountPoints\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12#\n\r\
    normal_points\x18\x02\x20\x01(\rR\x0cnormalPoints\x12%\n\x0epremium_poin\
    ts\x18\x03\x20\x01(\rR\rpremiumPoints\x12\x14\n\x05owned\x18\x04\x20\x01\
    (\x08R\x05owned\x12.\n\x13active_effects_mask\x18\x0c\x20\x01(\x04R\x11a\
    ctiveEffectsMask\x12!\n\x0cwager_streak\x18\x17\x20\x01(\rR\x0bwagerStre\
    ak\x12j\n\x19event_game_custom_actions\x18\x19\x20\x03(\x0b2/.dota.CMsgL\
    obbyEventPoints.NetworkedEventActionR\x16eventGameCustomActions\x12(\n\
    \x10tip_amount_index\x18\x1a\x20\x01(\rR\x0etipAmountIndex\x123\n\x16act\
    ive_event_season_id\x18\x1b\x20\x01(\rR\x13activeEventSeasonId\x12*\n\
    \x11teleport_fx_level\x18\x1c\x20\x01(\rR\x0fteleportFxLevel\x12g\n\x17n\
    etworked_event_actions\x18\x1e\x20\x03(\x0b2/.dota.CMsgLobbyEventPoints.\
    NetworkedEventActionR\x15networkedEventActions\x12^\n\x12periodic_resour\
    ces\x18\x1f\x20\x03(\x0b2/.dota.CMsgLobbyEventPoints.PeriodicResourceDat\
    aR\x11periodicResources\"l\n\x16CMsgLobbyEventGameData\x12\x1b\n\tgame_s\
    eed\x18\x01\x20\x01(\rR\x08gameSeed\x125\n\x17event_window_start_time\
    \x18\x02\x20\x01(\rR\x14eventWindowStartTime\"\x8c\x03\n\x12CSODOTALobby\
    Invite\x12\x19\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\x12\x1b\n\
    \tsender_id\x18\x02\x20\x01(\x06R\x08senderId\x12\x1f\n\x0bsender_name\
    \x18\x03\x20\x01(\tR\nsenderName\x12>\n\x07members\x18\x04\x20\x03(\x0b2\
    $.dota.CSODOTALobbyInvite.LobbyMemberR\x07members\x12$\n\x0ecustom_game_\
    id\x18\x05\x20\x01(\x04R\x0ccustomGameId\x12\x1d\n\ninvite_gid\x18\x06\
    \x20\x01(\x06R\tinviteGid\x12&\n\x0fcustom_game_crc\x18\x07\x20\x01(\x06\
    R\rcustomGameCrc\x122\n\x15custom_game_timestamp\x18\x08\x20\x01(\x07R\
    \x13customGameTimestamp\x1a<\n\x0bLobbyMember\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x19\n\x08steam_id\x18\x02\x20\x01(\x06R\x07stea\
    mId\"\x85\x0e\n\x12CSODOTALobbyMember\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \x06R\x02id\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\x12&\n\
    \x04team\x18\x03\x20\x01(\x0e2\x12.dota.DOTA_GC_TEAMR\x04team\x12\x12\n\
    \x04name\x18\x06\x20\x01(\tR\x04name\x12\x12\n\x04slot\x18\x07\x20\x01(\
    \rR\x04slot\x12\x19\n\x08party_id\x18\x0c\x20\x01(\x04R\x07partyId\x12\
    \x1d\n\nmeta_level\x18\r\x20\x01(\rR\tmetaLevel\x12\x17\n\x07meta_xp\x18\
    \x0e\x20\x01(\rR\x06metaXp\x12&\n\x0fmeta_xp_awarded\x18\x0f\x20\x01(\rR\
    \rmetaXpAwarded\x12=\n\rleaver_status\x18\x10\x20\x01(\x0e2\x18.dota.DOT\
    ALeaverStatus_tR\x0cleaverStatus\x12%\n\x0eleaver_actions\x18\x1c\x20\
    \x01(\rR\rleaverActions\x12\x18\n\x07channel\x18\x11\x20\x01(\rR\x07chan\
    nel\x12(\n\x10disabled_hero_id\x18\x14\x20\x03(\rR\x0edisabledHeroId\x12\
    &\n\x0fenabled_hero_id\x18\x16\x20\x03(\rR\renabledHeroId\x121\n\ncoach_\
    team\x18\x17\x20\x01(\x0e2\x12.dota.DOTA_GC_TEAMR\tcoachTeam\x12.\n\x13c\
    oached_account_ids\x185\x20\x03(\rR\x11coachedAccountIds\x12!\n\x0ccoach\
    _rating\x18*\x20\x01(\rR\x0bcoachRating\x12+\n\x12pwrd_cyber_cafe_id\x18\
    \x18\x20\x01(\rR\x0fpwrdCyberCafeId\x12/\n\x14pwrd_cyber_cafe_name\x18\
    \x19\x20\x01(\tR\x11pwrdCyberCafeName\x129\n\x19disabled_random_hero_bit\
    s\x18)\x20\x03(\x07R\x16disabledRandomHeroBits\x12\x1f\n\x0brank_change\
    \x18\x1d\x20\x01(\x11R\nrankChange\x12\x1c\n\tcameraman\x18\x1e\x20\x01(\
    \x08R\tcameraman\x125\n\x17custom_game_product_ids\x18\x1f\x20\x03(\rR\
    \x14customGameProductIds\x12;\n\x11search_match_type\x18!\x20\x01(\x0e2\
    \x0f.dota.MatchTypeR\x0fsearchMatchType\x120\n\x14favorite_team_packed\
    \x18#\x20\x01(\x04R\x12favoriteTeamPacked\x12,\n\x12is_plus_subscriber\
    \x18$\x20\x01(\x08R\x10isPlusSubscriber\x120\n\x14lane_selection_flags\
    \x18&\x20\x01(\rR\x12laneSelectionFlags\x12(\n\x10can_earn_rewards\x18'\
    \x20\x01(\x08R\x0ecanEarnRewards\x12B\n\x13live_spectator_team\x18(\x20\
    \x01(\x0e2\x12.dota.DOTA_GC_TEAMR\x11liveSpectatorTeam\x12)\n\x11was_mvp\
    _last_game\x18+\x20\x01(\x08R\x0ewasMvpLastGame\x12B\n\x0epending_awards\
    \x18,\x20\x03(\x0b2\x1b.dota.CMsgPendingEventAwardR\rpendingAwards\x12V\
    \n\x19pending_awards_on_victory\x18-\x20\x03(\x0b2\x1b.dota.CMsgPendingE\
    ventAwardR\x16pendingAwardsOnVictory\x12F\n\x13rank_mmr_boost_type\x18.\
    \x20\x01(\x0e2\x17.dota.EDOTAMMRBoostTypeR\x10rankMmrBoostType\x124\n\
    \x16queue_point_adjustment\x18/\x20\x01(\x11R\x14queuePointAdjustment\
    \x12\x1b\n\trank_tier\x180\x20\x01(\x05R\x08rankTier\x12\x14\n\x05title\
    \x182\x20\x01(\rR\x05title\x12\x19\n\x08guild_id\x183\x20\x01(\rR\x07gui\
    ldId\x12+\n\x11reports_available\x184\x20\x01(\rR\x10reportsAvailable\
    \x12$\n\x0eis_steam_china\x186\x20\x01(\x08R\x0cisSteamChina\x129\n\x19l\
    ive_spectator_account_id\x187\x20\x01(\rR\x16liveSpectatorAccountId\x126\
    \n\x17comms_reports_available\x188\x20\x01(\rR\x15commsReportsAvailable\
    \"\x1a\n\x18CSODOTAServerLobbyMember\"\x1a\n\x18CSODOTAStaticLobbyMember\
    \"\x20\n\x1eCSODOTAServerStaticLobbyMember\"\x8f\x04\n\x11CLobbyTeamDeta\
    ils\x12\x1b\n\tteam_name\x18\x01\x20\x01(\tR\x08teamName\x12\x19\n\x08te\
    am_tag\x18\x03\x20\x01(\tR\x07teamTag\x12\x17\n\x07team_id\x18\x04\x20\
    \x01(\rR\x06teamId\x12\x1b\n\tteam_logo\x18\x05\x20\x01(\x04R\x08teamLog\
    o\x12$\n\x0eteam_base_logo\x18\x06\x20\x01(\x04R\x0cteamBaseLogo\x12(\n\
    \x10team_banner_logo\x18\x07\x20\x01(\x04R\x0eteamBannerLogo\x12#\n\rtea\
    m_complete\x18\x08\x20\x01(\x08R\x0cteamComplete\x12\x12\n\x04rank\x18\
    \x0f\x20\x01(\rR\x04rank\x12\x1f\n\x0brank_change\x18\x10\x20\x01(\x11R\
    \nrankChange\x12\x20\n\x0cis_home_team\x18\x11\x20\x01(\x08R\nisHomeTeam\
    \x12,\n\x12is_challenge_match\x18\x12\x20\x01(\x08R\x10isChallengeMatch\
    \x12A\n\x1dchallenge_match_token_account\x18\x13\x20\x01(\x04R\x1achalle\
    ngeMatchTokenAccount\x12\"\n\rteam_logo_url\x18\x14\x20\x01(\tR\x0bteamL\
    ogoUrl\x12+\n\x11team_abbreviation\x18\x15\x20\x01(\tR\x10teamAbbreviati\
    on\"\xcb\x03\n\x12CLobbyGuildDetails\x12\x19\n\x08guild_id\x18\x01\x20\
    \x01(\rR\x07guildId\x12.\n\x13guild_primary_color\x18\x02\x20\x01(\rR\
    \x11guildPrimaryColor\x122\n\x15guild_secondary_color\x18\x03\x20\x01(\r\
    R\x13guildSecondaryColor\x12#\n\rguild_pattern\x18\x04\x20\x01(\rR\x0cgu\
    ildPattern\x12\x1d\n\nguild_logo\x18\x05\x20\x01(\x04R\tguildLogo\x12!\n\
    \x0cguild_points\x18\x06\x20\x01(\rR\x0bguildPoints\x12\x1f\n\x0bguild_e\
    vent\x18\x07\x20\x01(\rR\nguildEvent\x12\x1f\n\x0bguild_flags\x18\x08\
    \x20\x01(\rR\nguildFlags\x128\n\x0eteam_for_guild\x18\t\x20\x01(\x0e2\
    \x12.dota.DOTA_GC_TEAMR\x0cteamForGuild\x12\x1b\n\tguild_tag\x18\n\x20\
    \x01(\tR\x08guildTag\x126\n\x17guild_weekly_percentile\x18\x0b\x20\x01(\
    \rR\x15guildWeeklyPercentile\"\xc3\x01\n\x18CLobbyTimedRewardDetails\x12\
    $\n\x0eitem_def_index\x18\x02\x20\x01(\rR\x0citemDefIndex\x12&\n\x0fis_s\
    upply_crate\x18\x03\x20\x01(\x08R\risSupplyCrate\x12\"\n\ris_timed_drop\
    \x18\x04\x20\x01(\x08R\x0bisTimedDrop\x12\x1d\n\naccount_id\x18\x05\x20\
    \x01(\rR\taccountId\x12\x16\n\x06origin\x18\x06\x20\x01(\rR\x06origin\"\
    \xa5\x01\n\x1aCLobbyBroadcastChannelInfo\x12\x1d\n\nchannel_id\x18\x01\
    \x20\x01(\rR\tchannelId\x12!\n\x0ccountry_code\x18\x02\x20\x01(\tR\x0bco\
    untryCode\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\
    \x12#\n\rlanguage_code\x18\x04\x20\x01(\tR\x0clanguageCode\"\x99\x03\n\
    \x14CLobbyGuildChallenge\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07gu\
    ildId\x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\x07event\
    Id\x122\n\x15challenge_instance_id\x18\x03\x20\x01(\rR\x13challengeInsta\
    nceId\x12/\n\x13challenge_parameter\x18\x04\x20\x01(\rR\x12challengePara\
    meter\x12/\n\x13challenge_timestamp\x18\x05\x20\x01(\rR\x12challengeTime\
    stamp\x126\n\x17challenge_period_serial\x18\x06\x20\x01(\rR\x15challenge\
    PeriodSerial\x12=\n\x1bchallenge_progress_at_start\x18\x07\x20\x01(\rR\
    \x18challengeProgressAtStart\x120\n\x14eligible_account_ids\x18\x08\x20\
    \x03(\rR\x12eligibleAccountIds\"\xc1*\n\x0cCSODOTALobby\x12\x19\n\x08lob\
    by_id\x18\x01\x20\x01(\x04R\x07lobbyId\x129\n\x0ball_members\x18x\x20\
    \x03(\x0b2\x18.dota.CSODOTALobbyMemberR\nallMembers\x12%\n\x0emember_ind\
    ices\x18y\x20\x03(\rR\rmemberIndices\x12.\n\x13left_member_indices\x18z\
    \x20\x03(\rR\x11leftMemberIndices\x12.\n\x13free_member_indices\x18{\x20\
    \x03(\rR\x11freeMemberIndices\x12\x1b\n\tleader_id\x18\x0b\x20\x01(\x06R\
    \x08leaderId\x12\x1b\n\tserver_id\x18\x06\x20\x01(\x06R\x08serverId\x12\
    \x1b\n\tgame_mode\x18\x03\x20\x01(\rR\x08gameMode\x12'\n\x0fpending_invi\
    tes\x18\n\x20\x03(\x06R\x0ependingInvites\x12.\n\x05state\x18\x04\x20\
    \x01(\x0e2\x18.dota.CSODOTALobby.StateR\x05state\x12\x18\n\x07connect\
    \x18\x05\x20\x01(\tR\x07connect\x12;\n\nlobby_type\x18\x0c\x20\x01(\x0e2\
    \x1c.dota.CSODOTALobby.LobbyTypeR\tlobbyType\x12!\n\x0callow_cheats\x18\
    \r\x20\x01(\x08R\x0ballowCheats\x12$\n\x0efill_with_bots\x18\x0e\x20\x01\
    (\x08R\x0cfillWithBots\x12\x1d\n\nintro_mode\x18\x0f\x20\x01(\x08R\tintr\
    oMode\x12\x1b\n\tgame_name\x18\x10\x20\x01(\tR\x08gameName\x12:\n\x0ctea\
    m_details\x18\x11\x20\x03(\x0b2\x17.dota.CLobbyTeamDetailsR\x0bteamDetai\
    ls\x12'\n\x0ftutorial_lesson\x18\x12\x20\x01(\rR\x0etutorialLesson\x12#\
    \n\rtournament_id\x18\x13\x20\x01(\rR\x0ctournamentId\x12,\n\x12tourname\
    nt_game_id\x18\x14\x20\x01(\rR\x10tournamentGameId\x12#\n\rserver_region\
    \x18\x15\x20\x01(\rR\x0cserverRegion\x123\n\ngame_state\x18\x16\x20\x01(\
    \x0e2\x14.dota.DOTA_GameStateR\tgameState\x12%\n\x0enum_spectators\x18\
    \x17\x20\x01(\rR\rnumSpectators\x12\x1e\n\nmatchgroup\x18\x19\x20\x01(\r\
    R\nmatchgroup\x12+\n\x07cm_pick\x18\x1c\x20\x01(\x0e2\x12.dota.DOTA_CM_P\
    ICKR\x06cmPick\x12\x19\n\x08match_id\x18\x1e\x20\x01(\x04R\x07matchId\
    \x12)\n\x10allow_spectating\x18\x1f\x20\x01(\x08R\x0fallowSpectating\x12\
    M\n\x16bot_difficulty_radiant\x18$\x20\x01(\x0e2\x17.dota.DOTABotDifficu\
    ltyR\x14botDifficultyRadiant\x12P\n\x14timed_reward_details\x18&\x20\x03\
    (\x0b2\x1e.dota.CLobbyTimedRewardDetailsR\x12timedRewardDetails\x12\x19\
    \n\x08pass_key\x18'\x20\x01(\tR\x07passKey\x12\x1a\n\x08leagueid\x18*\
    \x20\x01(\rR\x08leagueid\x122\n\x15penalty_level_radiant\x18+\x20\x01(\r\
    R\x13penaltyLevelRadiant\x12,\n\x12penalty_level_dire\x18,\x20\x01(\rR\
    \x10penaltyLevelDire\x12\x20\n\x0cload_game_id\x18-\x20\x01(\rR\nloadGam\
    eId\x12\x1f\n\x0bseries_type\x18.\x20\x01(\rR\nseriesType\x12.\n\x13radi\
    ant_series_wins\x18/\x20\x01(\rR\x11radiantSeriesWins\x12(\n\x10dire_ser\
    ies_wins\x180\x20\x01(\rR\x0edireSeriesWins\x12%\n\x0eloot_generated\x18\
    1\x20\x01(\rR\rlootGenerated\x12!\n\x0cloot_awarded\x182\x20\x01(\rR\x0b\
    lootAwarded\x12\x18\n\x07allchat\x183\x20\x01(\x08R\x07allchat\x12:\n\rd\
    ota_tv_delay\x185\x20\x01(\x0e2\x16.dota.LobbyDotaTVDelayR\x0bdotaTvDela\
    y\x12(\n\x10custom_game_mode\x186\x20\x01(\tR\x0ecustomGameMode\x12&\n\
    \x0fcustom_map_name\x187\x20\x01(\tR\rcustomMapName\x12+\n\x11custom_dif\
    ficulty\x188\x20\x01(\rR\x10customDifficulty\x12\x10\n\x03lan\x189\x20\
    \x01(\x08R\x03lan\x12V\n\x16broadcast_channel_info\x18:\x20\x03(\x0b2\
    \x20.dota.CLobbyBroadcastChannelInfoR\x14broadcastChannelInfo\x124\n\x16\
    first_leaver_accountid\x18;\x20\x01(\rR\x14firstLeaverAccountid\x12\x1b\
    \n\tseries_id\x18<\x20\x01(\rR\x08seriesId\x12!\n\x0clow_priority\x18=\
    \x20\x01(\x08R\x0blowPriority\x12C\n\x0eextra_messages\x18>\x20\x03(\x0b\
    2\x1c.dota.CSODOTALobby.CExtraMsgR\rextraMessages\x120\n\tsave_game\x18?\
    \x20\x01(\x0b2\x13.dota.CDOTASaveGameR\x08saveGame\x120\n\x14first_blood\
    _happened\x18A\x20\x01(\x08R\x12firstBloodHappened\x128\n\rmatch_outcome\
    \x18F\x20\x01(\x0e2\x13.dota.EMatchOutcomeR\x0cmatchOutcome\x12'\n\x0fma\
    ss_disconnect\x18C\x20\x01(\x08R\x0emassDisconnect\x12$\n\x0ecustom_game\
    _id\x18D\x20\x01(\x04R\x0ccustomGameId\x12,\n\x12custom_min_players\x18G\
    \x20\x01(\rR\x10customMinPlayers\x12,\n\x12custom_max_players\x18H\x20\
    \x01(\rR\x10customMaxPlayers\x129\n\nvisibility\x18K\x20\x01(\x0e2\x19.d\
    ota.DOTALobbyVisibilityR\nvisibility\x12&\n\x0fcustom_game_crc\x18L\x20\
    \x01(\x06R\rcustomGameCrc\x12B\n\x1ecustom_game_auto_created_lobby\x18M\
    \x20\x01(\x08R\x1acustomGameAutoCreatedLobby\x122\n\x15custom_game_times\
    tamp\x18P\x20\x01(\x07R\x13customGameTimestamp\x126\n\x17previous_series\
    _matches\x18Q\x20\x03(\x04R\x15previousSeriesMatches\x126\n\x17previous_\
    match_override\x18R\x20\x01(\x04R\x15previousMatchOverride\x12&\n\x0fgam\
    e_start_time\x18W\x20\x01(\rR\rgameStartTime\x12@\n\rpause_setting\x18X\
    \x20\x01(\x0e2\x1b.dota.LobbyDotaPauseSettingR\x0cpauseSetting\x12=\n\
    \x1bweekend_tourney_division_id\x18Z\x20\x01(\rR\x18weekendTourneyDivisi\
    onId\x12=\n\x1bweekend_tourney_skill_level\x18[\x20\x01(\rR\x18weekendTo\
    urneySkillLevel\x12A\n\x1dweekend_tourney_bracket_round\x18\\\x20\x01(\r\
    R\x1aweekendTourneyBracketRound\x12G\n\x13bot_difficulty_dire\x18]\x20\
    \x01(\x0e2\x17.dota.DOTABotDifficultyR\x11botDifficultyDire\x12\x1f\n\
    \x0bbot_radiant\x18^\x20\x01(\x04R\nbotRadiant\x12\x19\n\x08bot_dire\x18\
    _\x20\x01(\x04R\x07botDire\x12H\n\x19event_progression_enabled\x18`\x20\
    \x03(\x0e2\x0c.dota.EEventR\x17eventProgressionEnabled\x12Z\n\x18selecti\
    on_priority_rules\x18a\x20\x01(\x0e2\x20.dota.DOTASelectionPriorityRules\
    R\x16selectionPriorityRules\x12Y\n*series_previous_selection_priority_te\
    am_id\x18b\x20\x01(\rR%seriesPreviousSelectionPriorityTeamId\x12W\n)seri\
    es_current_selection_priority_team_id\x18c\x20\x01(\rR$seriesCurrentSele\
    ctionPriorityTeamId\x12o\n#series_current_priority_team_choice\x18d\x20\
    \x01(\x0e2!.dota.DOTASelectionPriorityChoiceR\x1fseriesCurrentPriorityTe\
    amChoice\x12v\n'series_current_non_priority_team_choice\x18e\x20\x01(\
    \x0e2!.dota.DOTASelectionPriorityChoiceR\"seriesCurrentNonPriorityTeamCh\
    oice\x12d\n0series_current_selection_priority_used_coin_toss\x18f\x20\
    \x01(\x08R*seriesCurrentSelectionPriorityUsedCoinToss\x12@\n\x15current_\
    primary_event\x18g\x20\x01(\x0e2\x0c.dota.EEventR\x13currentPrimaryEvent\
    \x12=\n\x1bemergency_disabled_hero_ids\x18i\x20\x03(\rR\x18emergencyDisa\
    bledHeroIds\x125\n\x17custom_game_private_key\x18j\x20\x01(\x06R\x14cust\
    omGamePrivateKey\x122\n\x15custom_game_penalties\x18k\x20\x01(\x08R\x13c\
    ustomGamePenalties\x123\n\x16lan_host_ping_location\x18m\x20\x01(\tR\x13\
    lanHostPingLocation\x12$\n\x0eleague_node_id\x18n\x20\x01(\rR\x0cleagueN\
    odeId\x12%\n\x0ematch_duration\x18o\x20\x01(\rR\rmatchDuration\x12!\n\
    \x0cleague_phase\x18q\x20\x01(\rR\x0bleaguePhase\x122\n\x15record_detail\
    ed_stats\x18r\x20\x01(\x08R\x13recordDetailedStats\x12B\n\x1dexperimenta\
    l_gameplay_enabled\x18t\x20\x01(\x08R\x1bexperimentalGameplayEnabled\x12\
    E\n\x10guild_challenges\x18u\x20\x03(\x0b2\x1a.dota.CLobbyGuildChallenge\
    R\x0fguildChallenges\x12=\n\rguild_details\x18v\x20\x03(\x0b2\x18.dota.C\
    LobbyGuildDetailsR\x0cguildDetails\x12H\n\x12lobby_event_points\x18w\x20\
    \x03(\x0b2\x1a.dota.CMsgLobbyEventPointsR\x10lobbyEventPoints\x12,\n\x12\
    requested_hero_ids\x18|\x20\x03(\rR\x10requestedHeroIds\x12U\n\x15coach_\
    friend_requests\x18}\x20\x03(\x0b2!.dota.CMsgLobbyCoachFriendRequestR\
    \x13coachFriendRequests\x12)\n\x11is_in_steam_china\x18~\x20\x01(\x08R\
    \x0eisInSteamChina\x12,\n\x12with_scenario_save\x18\x7f\x20\x01(\x08R\
    \x10withScenarioSave\x12/\n\x13lobby_creation_time\x18\x80\x01\x20\x01(\
    \rR\x11lobbyCreationTime\x123\n\x15event_game_definition\x18\x81\x01\x20\
    \x01(\tR\x13eventGameDefinition\x12S\n\x16extra_startup_messages\x18\x82\
    \x01\x20\x03(\x0b2\x1c.dota.CSODOTALobby.CExtraMsgR\x14extraStartupMessa\
    ges\x1a7\n\tCExtraMsg\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x1a\
    \n\x08contents\x18\x02\x20\x01(\x0cR\x08contents\"d\n\x05State\x12\x06\n\
    \x02UI\x10\0\x12\x0b\n\x07READYUP\x10\x04\x12\x0f\n\x0bSERVERSETUP\x10\
    \x01\x12\x07\n\x03RUN\x10\x02\x12\x0c\n\x08POSTGAME\x10\x03\x12\x0c\n\
    \x08NOTREADY\x10\x05\x12\x10\n\x0cSERVERASSIGN\x10\x06\"\xe2\x01\n\tLobb\
    yType\x12\x14\n\x07INVALID\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\
    \x12\x10\n\x0cCASUAL_MATCH\x10\0\x12\x0c\n\x08PRACTICE\x10\x01\x12\x12\n\
    \x0eCOOP_BOT_MATCH\x10\x04\x12\x15\n\x11COMPETITIVE_MATCH\x10\x07\x12\
    \x13\n\x0fWEEKEND_TOURNEY\x10\t\x12\x13\n\x0fLOCAL_BOT_MATCH\x10\n\x12\r\
    \n\tSPECTATOR\x10\x0b\x12\x0f\n\x0bEVENT_MATCH\x10\x0c\x12\x13\n\x0fNEW_\
    PLAYER_POOL\x10\x0e\x12\x15\n\x11FEATURED_GAMEMODE\x10\x0f\"U\n\x12CSODO\
    TAServerLobby\x12?\n\x0ball_members\x18\x01\x20\x03(\x0b2\x1e.dota.CSODO\
    TAServerLobbyMemberR\nallMembers\"}\n\x12CSODOTAStaticLobby\x12?\n\x0bal\
    l_members\x18\x01\x20\x03(\x0b2\x1e.dota.CSODOTAStaticLobbyMemberR\nallM\
    embers\x12&\n\x0fis_player_draft\x18\x02\x20\x01(\x08R\risPlayerDraft\"a\
    \n\x18CSODOTAServerStaticLobby\x12E\n\x0ball_members\x18\x01\x20\x03(\
    \x0b2$.dota.CSODOTAServerStaticLobbyMemberR\nallMembers\"\x80\x05\n%CMsg\
    AdditionalLobbyStartupAccountData\x12\x1d\n\naccount_id\x18\x01\x20\x01(\
    \rR\taccountId\x12F\n\tplus_data\x18\x02\x20\x01(\x0b2).dota.CMsgLobbyPl\
    ayerPlusSubscriptionDataR\x08plusData\x12\x8d\x01\n\"unlocked_chat_wheel\
    _message_ranges\x18\x03\x20\x03(\x0b2A.dota.CMsgAdditionalLobbyStartupAc\
    countData.ChatWheelMessageRangeR\x1eunlockedChatWheelMessageRanges\x12\
    \x8d\x01\n\"unlocked_ping_wheel_message_ranges\x18\x04\x20\x03(\x0b2A.do\
    ta.CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRangeR\x1eunloc\
    kedPingWheelMessageRanges\x1ag\n\x15ChatWheelMessageRange\x12(\n\x10mess\
    age_id_start\x18\x01\x20\x01(\rR\x0emessageIdStart\x12$\n\x0emessage_id_\
    end\x18\x02\x20\x01(\rR\x0cmessageIdEnd\x1ag\n\x15PingWheelMessageRange\
    \x12(\n\x10message_id_start\x18\x01\x20\x01(\rR\x0emessageIdStart\x12$\n\
    \x0emessage_id_end\x18\x02\x20\x01(\rR\x0cmessageIdEnd\"!\n\x1fCMsgLobby\
    InitializationComplete\".\n\x18CMsgLobbyPlaytestDetails\x12\x12\n\x04jso\
    n\x18\x01\x20\x01(\tR\x04json\"\x82\x03\n\x18CMsgLocalServerGuildData\
    \x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12'\n\x08event_id\
    \x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x12!\n\x0cguild_point\
    s\x18\x03\x20\x01(\rR\x0bguildPoints\x12\x1d\n\nguild_logo\x18\x04\x20\
    \x01(\x04R\tguildLogo\x12.\n\x13guild_primary_color\x18\x05\x20\x01(\rR\
    \x11guildPrimaryColor\x122\n\x15guild_secondary_color\x18\x06\x20\x01(\r\
    R\x13guildSecondaryColor\x12#\n\rguild_pattern\x18\x07\x20\x01(\rR\x0cgu\
    ildPattern\x12\x1f\n\x0bguild_flags\x18\x08\x20\x01(\rR\nguildFlags\x126\
    \n\x17guild_weekly_percentile\x18\t\x20\x01(\rR\x15guildWeeklyPercentile\
    \"\xee\x03\n\x1cCMsgLocalServerFakeLobbyData\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12=\n\x0cevent_points\x18\x02\x20\x03(\x0b2\
    \x1a.dota.CMsgLobbyEventPointsR\x0beventPoints\x12,\n\x12is_plus_subscri\
    ber\x18\x03\x20\x01(\x08R\x10isPlusSubscriber\x12(\n\x10primary_event_id\
    \x18\x04\x20\x01(\rR\x0eprimaryEventId\x12#\n\rfavorite_team\x18\x05\x20\
    \x01(\rR\x0cfavoriteTeam\x122\n\x15favorite_team_quality\x18\x06\x20\x01\
    (\rR\x13favoriteTeamQuality\x12=\n\nguild_info\x18\x07\x20\x01(\x0b2\x1e\
    .dota.CMsgLocalServerGuildDataR\tguildInfo\x12*\n\x11teleport_fx_level\
    \x18\x08\x20\x01(\rR\x0fteleportFxLevel\x12T\n\x0fadditional_data\x18\t\
    \x20\x01(\x0b2+.dota.CMsgAdditionalLobbyStartupAccountDataR\x0eadditiona\
    lData*\xa5\x01\n\x1dELobbyMemberCoachRequestState\x12(\n$k_eLobbyMemberC\
    oachRequestState_None\x10\0\x12,\n(k_eLobbyMemberCoachRequestState_Accep\
    ted\x10\x01\x12,\n(k_eLobbyMemberCoachRequestState_Rejected\x10\x02*e\n\
    \x10LobbyDotaTVDelay\x12\x12\n\x0eLobbyDotaTV_10\x10\0\x12\x13\n\x0fLobb\
    yDotaTV_120\x10\x01\x12\x13\n\x0fLobbyDotaTV_300\x10\x02\x12\x13\n\x0fLo\
    bbyDotaTV_900\x10\x03*\x83\x01\n\x15LobbyDotaPauseSetting\x12#\n\x1fLobb\
    yDotaPauseSetting_Unlimited\x10\0\x12!\n\x1dLobbyDotaPauseSetting_Limite\
    d\x10\x01\x12\"\n\x1eLobbyDotaPauseSetting_Disabled\x10\x02B%Z#github.co\
    m/dotabuff/manta/dota;dotaJ\xef\xa2\x01\n\x07\x12\x05\0\0\x89\x03\x01\n\
    \x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0c\n\x08\
    \n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\
    \0\x12\x03\x05\x07\x1c\n\t\n\x02\x03\x01\x12\x03\x06\x07\x20\n\n\n\x02\
    \x05\0\x12\x04\x08\0\x0c\x01\n\n\n\x03\x05\0\x01\x12\x03\x08\x05\"\n\x0b\
    \n\x04\x05\0\x02\0\x12\x03\t\x081\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\t\
    \x08,\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\t/0\n\x0b\n\x04\x05\0\x02\x01\
    \x12\x03\n\x085\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\n\x080\n\x0c\n\x05\
    \x05\0\x02\x01\x02\x12\x03\n34\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x0b\x08\
    5\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x0b\x080\n\x0c\n\x05\x05\0\x02\
    \x02\x02\x12\x03\x0b34\n\n\n\x02\x05\x01\x12\x04\x0e\0\x13\x01\n\n\n\x03\
    \x05\x01\x01\x12\x03\x0e\x05\x15\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x0f\
    \x08\x1b\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x0f\x08\x16\n\x0c\n\x05\
    \x05\x01\x02\0\x02\x12\x03\x0f\x19\x1a\n\x0b\n\x04\x05\x01\x02\x01\x12\
    \x03\x10\x08\x1c\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\x10\x08\x17\n\
    \x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x10\x1a\x1b\n\x0b\n\x04\x05\x01\
    \x02\x02\x12\x03\x11\x08\x1c\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x11\
    \x08\x17\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\x11\x1a\x1b\n\x0b\n\x04\
    \x05\x01\x02\x03\x12\x03\x12\x08\x1c\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\
    \x03\x12\x08\x17\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\x12\x1a\x1b\n\n\
    \n\x02\x05\x02\x12\x04\x15\0\x19\x01\n\n\n\x03\x05\x02\x01\x12\x03\x15\
    \x05\x1a\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x16\x08,\n\x0c\n\x05\x05\x02\
    \x02\0\x01\x12\x03\x16\x08'\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\x16*+\
    \n\x0b\n\x04\x05\x02\x02\x01\x12\x03\x17\x08*\n\x0c\n\x05\x05\x02\x02\
    \x01\x01\x12\x03\x17\x08%\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03\x17()\
    \n\x0b\n\x04\x05\x02\x02\x02\x12\x03\x18\x08+\n\x0c\n\x05\x05\x02\x02\
    \x02\x01\x12\x03\x18\x08&\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03\x18)*\
    \n\n\n\x02\x04\0\x12\x04\x1b\0\x1f\x01\n\n\n\x03\x04\0\x01\x12\x03\x1b\
    \x08#\n\x0b\n\x04\x04\0\x02\0\x12\x03\x1c\x08-\n\x0c\n\x05\x04\0\x02\0\
    \x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x1c\x11\x17\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1c\x18(\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x1c+,\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x1d\x08.\n\x0c\n\
    \x05\x04\0\x02\x01\x04\x12\x03\x1d\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x03\x1d\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x1d\x18)\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1d,-\n\x0b\n\x04\x04\0\x02\x02\x12\
    \x03\x1e\x08A\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x1e\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x02\x06\x12\x03\x1e\x11.\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x03\x1e/<\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x1e?@\n\n\n\x02\x04\
    \x01\x12\x04!\0(\x01\n\n\n\x03\x04\x01\x01\x12\x03!\x08+\n\x0c\n\x04\x04\
    \x01\x03\0\x12\x04\"\x08%\t\n\x0c\n\x05\x04\x01\x03\0\x01\x12\x03\"\x10\
    \x19\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x03#\x10,\n\x0e\n\x07\x04\x01\x03\
    \0\x02\0\x04\x12\x03#\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\0\x05\x12\
    \x03#\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\0\x01\x12\x03#\x20'\n\x0e\n\
    \x07\x04\x01\x03\0\x02\0\x03\x12\x03#*+\n\r\n\x06\x04\x01\x03\0\x02\x01\
    \x12\x03$\x102\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x04\x12\x03$\x10\x18\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x01\x05\x12\x03$\x19\x1f\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x01\x01\x12\x03$\x20-\n\x0e\n\x07\x04\x01\x03\0\x02\x01\
    \x03\x12\x03$01\n\x0b\n\x04\x04\x01\x02\0\x12\x03'\x08O\n\x0c\n\x05\x04\
    \x01\x02\0\x04\x12\x03'\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03'\
    \x11>\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03'?J\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x03'MN\n\n\n\x02\x04\x02\x12\x04*\0G\x01\n\n\n\x03\x04\x02\x01\
    \x12\x03*\x08\x1c\n\x0c\n\x04\x04\x02\x03\0\x12\x04+\x08/\t\n\x0c\n\x05\
    \x04\x02\x03\0\x01\x12\x03+\x10$\n\r\n\x06\x04\x02\x03\0\x02\0\x12\x03,\
    \x109\n\x0e\n\x07\x04\x02\x03\0\x02\0\x04\x12\x03,\x10\x18\n\x0e\n\x07\
    \x04\x02\x03\0\x02\0\x05\x12\x03,\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\
    \0\x01\x12\x03,\x204\n\x0e\n\x07\x04\x02\x03\0\x02\0\x03\x12\x03,78\n\r\
    \n\x06\x04\x02\x03\0\x02\x01\x12\x03-\x10.\n\x0e\n\x07\x04\x02\x03\0\x02\
    \x01\x04\x12\x03-\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x05\x12\x03-\
    \x19\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x03-\x20)\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x01\x03\x12\x03-,-\n\r\n\x06\x04\x02\x03\0\x02\x02\
    \x12\x03.\x10(\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x03.\x10\x18\n\
    \x0e\n\x07\x04\x02\x03\0\x02\x02\x05\x12\x03.\x19\x1f\n\x0e\n\x07\x04\
    \x02\x03\0\x02\x02\x01\x12\x03.\x20#\n\x0e\n\x07\x04\x02\x03\0\x02\x02\
    \x03\x12\x03.&'\n\x0c\n\x04\x04\x02\x03\x01\x12\x041\x084\t\n\x0c\n\x05\
    \x04\x02\x03\x01\x01\x12\x031\x10$\n\r\n\x06\x04\x02\x03\x01\x02\0\x12\
    \x032\x10.\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x04\x12\x032\x10\x18\n\x0e\
    \n\x07\x04\x02\x03\x01\x02\0\x05\x12\x032\x19\x1f\n\x0e\n\x07\x04\x02\
    \x03\x01\x02\0\x01\x12\x032\x20)\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x03\
    \x12\x032,-\n\r\n\x06\x04\x02\x03\x01\x02\x01\x12\x033\x102\n\x0e\n\x07\
    \x04\x02\x03\x01\x02\x01\x04\x12\x033\x10\x18\n\x0e\n\x07\x04\x02\x03\
    \x01\x02\x01\x05\x12\x033\x19\x1f\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\
    \x01\x12\x033\x20-\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x03\x12\x03301\n\
    \x0c\n\x04\x04\x02\x03\x02\x12\x046\x08C\t\n\x0c\n\x05\x04\x02\x03\x02\
    \x01\x12\x036\x10\x1d\n\r\n\x06\x04\x02\x03\x02\x02\0\x12\x037\x10/\n\
    \x0e\n\x07\x04\x02\x03\x02\x02\0\x04\x12\x037\x10\x18\n\x0e\n\x07\x04\
    \x02\x03\x02\x02\0\x05\x12\x037\x19\x1f\n\x0e\n\x07\x04\x02\x03\x02\x02\
    \0\x01\x12\x037\x20*\n\x0e\n\x07\x04\x02\x03\x02\x02\0\x03\x12\x037-.\n\
    \r\n\x06\x04\x02\x03\x02\x02\x01\x12\x038\x102\n\x0e\n\x07\x04\x02\x03\
    \x02\x02\x01\x04\x12\x038\x10\x18\n\x0e\n\x07\x04\x02\x03\x02\x02\x01\
    \x05\x12\x038\x19\x1f\n\x0e\n\x07\x04\x02\x03\x02\x02\x01\x01\x12\x038\
    \x20-\n\x0e\n\x07\x04\x02\x03\x02\x02\x01\x03\x12\x03801\n\r\n\x06\x04\
    \x02\x03\x02\x02\x02\x12\x039\x103\n\x0e\n\x07\x04\x02\x03\x02\x02\x02\
    \x04\x12\x039\x10\x18\n\x0e\n\x07\x04\x02\x03\x02\x02\x02\x05\x12\x039\
    \x19\x1f\n\x0e\n\x07\x04\x02\x03\x02\x02\x02\x01\x12\x039\x20.\n\x0e\n\
    \x07\x04\x02\x03\x02\x02\x02\x03\x12\x03912\n\r\n\x06\x04\x02\x03\x02\
    \x02\x03\x12\x03:\x10(\n\x0e\n\x07\x04\x02\x03\x02\x02\x03\x04\x12\x03:\
    \x10\x18\n\x0e\n\x07\x04\x02\x03\x02\x02\x03\x05\x12\x03:\x19\x1d\n\x0e\
    \n\x07\x04\x02\x03\x02\x02\x03\x01\x12\x03:\x1e#\n\x0e\n\x07\x04\x02\x03\
    \x02\x02\x03\x03\x12\x03:&'\n\r\n\x06\x04\x02\x03\x02\x02\x04\x12\x03;\
    \x109\n\x0e\n\x07\x04\x02\x03\x02\x02\x04\x04\x12\x03;\x10\x18\n\x0e\n\
    \x07\x04\x02\x03\x02\x02\x04\x05\x12\x03;\x19\x1f\n\x0e\n\x07\x04\x02\
    \x03\x02\x02\x04\x01\x12\x03;\x203\n\x0e\n\x07\x04\x02\x03\x02\x02\x04\
    \x03\x12\x03;68\n\r\n\x06\x04\x02\x03\x02\x02\x05\x12\x03<\x102\n\x0e\n\
    \x07\x04\x02\x03\x02\x02\x05\x04\x12\x03<\x10\x18\n\x0e\n\x07\x04\x02\
    \x03\x02\x02\x05\x05\x12\x03<\x19\x1f\n\x0e\n\x07\x04\x02\x03\x02\x02\
    \x05\x01\x12\x03<\x20,\n\x0e\n\x07\x04\x02\x03\x02\x02\x05\x03\x12\x03</\
    1\n\r\n\x06\x04\x02\x03\x02\x02\x06\x12\x03=\x10b\n\x0e\n\x07\x04\x02\
    \x03\x02\x02\x06\x04\x12\x03=\x10\x18\n\x0e\n\x07\x04\x02\x03\x02\x02\
    \x06\x06\x12\x03=\x19B\n\x0e\n\x07\x04\x02\x03\x02\x02\x06\x01\x12\x03=C\
    \\\n\x0e\n\x07\x04\x02\x03\x02\x02\x06\x03\x12\x03=_a\n\r\n\x06\x04\x02\
    \x03\x02\x02\x07\x12\x03>\x106\n\x0e\n\x07\x04\x02\x03\x02\x02\x07\x04\
    \x12\x03>\x10\x18\n\x0e\n\x07\x04\x02\x03\x02\x02\x07\x05\x12\x03>\x19\
    \x1f\n\x0e\n\x07\x04\x02\x03\x02\x02\x07\x01\x12\x03>\x200\n\x0e\n\x07\
    \x04\x02\x03\x02\x02\x07\x03\x12\x03>35\n\r\n\x06\x04\x02\x03\x02\x02\
    \x08\x12\x03?\x10<\n\x0e\n\x07\x04\x02\x03\x02\x02\x08\x04\x12\x03?\x10\
    \x18\n\x0e\n\x07\x04\x02\x03\x02\x02\x08\x05\x12\x03?\x19\x1f\n\x0e\n\
    \x07\x04\x02\x03\x02\x02\x08\x01\x12\x03?\x206\n\x0e\n\x07\x04\x02\x03\
    \x02\x02\x08\x03\x12\x03?9;\n\r\n\x06\x04\x02\x03\x02\x02\t\x12\x03@\x10\
    7\n\x0e\n\x07\x04\x02\x03\x02\x02\t\x04\x12\x03@\x10\x18\n\x0e\n\x07\x04\
    \x02\x03\x02\x02\t\x05\x12\x03@\x19\x1f\n\x0e\n\x07\x04\x02\x03\x02\x02\
    \t\x01\x12\x03@\x201\n\x0e\n\x07\x04\x02\x03\x02\x02\t\x03\x12\x03@46\n\
    \r\n\x06\x04\x02\x03\x02\x02\n\x12\x03A\x10`\n\x0e\n\x07\x04\x02\x03\x02\
    \x02\n\x04\x12\x03A\x10\x18\n\x0e\n\x07\x04\x02\x03\x02\x02\n\x06\x12\
    \x03A\x19B\n\x0e\n\x07\x04\x02\x03\x02\x02\n\x01\x12\x03ACZ\n\x0e\n\x07\
    \x04\x02\x03\x02\x02\n\x03\x12\x03A]_\n\r\n\x06\x04\x02\x03\x02\x02\x0b\
    \x12\x03B\x10[\n\x0e\n\x07\x04\x02\x03\x02\x02\x0b\x04\x12\x03B\x10\x18\
    \n\x0e\n\x07\x04\x02\x03\x02\x02\x0b\x06\x12\x03B\x19B\n\x0e\n\x07\x04\
    \x02\x03\x02\x02\x0b\x01\x12\x03BCU\n\x0e\n\x07\x04\x02\x03\x02\x02\x0b\
    \x03\x12\x03BXZ\n\x0b\n\x04\x04\x02\x02\0\x12\x03E\x08%\n\x0c\n\x05\x04\
    \x02\x02\0\x04\x12\x03E\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03E\
    \x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03E\x18\x20\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03E#$\n\x0b\n\x04\x04\x02\x02\x01\x12\x03F\x08G\n\
    \x0c\n\x05\x04\x02\x02\x01\x04\x12\x03F\x08\x10\n\x0c\n\x05\x04\x02\x02\
    \x01\x06\x12\x03F\x113\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03F4B\n\x0c\
    \n\x05\x04\x02\x02\x01\x03\x12\x03FEF\n\n\n\x02\x04\x03\x12\x04I\0L\x01\
    \n\n\n\x03\x04\x03\x01\x12\x03I\x08\x1e\n\x0b\n\x04\x04\x03\x02\0\x12\
    \x03J\x08&\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03J\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\0\x05\x12\x03J\x11\x17\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03J\x18!\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03J$%\n\x0b\n\x04\x04\x03\
    \x02\x01\x12\x03K\x084\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03K\x08\x10\
    \n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03K\x11\x17\n\x0c\n\x05\x04\x03\
    \x02\x01\x01\x12\x03K\x18/\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03K23\n\
    \n\n\x02\x04\x04\x12\x04N\0\\\x01\n\n\n\x03\x04\x04\x01\x12\x03N\x08\x1a\
    \n\x0c\n\x04\x04\x04\x03\0\x12\x04O\x08R\t\n\x0c\n\x05\x04\x04\x03\0\x01\
    \x12\x03O\x10\x1b\n\r\n\x06\x04\x04\x03\0\x02\0\x12\x03P\x10)\n\x0e\n\
    \x07\x04\x04\x03\0\x02\0\x04\x12\x03P\x10\x18\n\x0e\n\x07\x04\x04\x03\0\
    \x02\0\x05\x12\x03P\x19\x1f\n\x0e\n\x07\x04\x04\x03\0\x02\0\x01\x12\x03P\
    \x20$\n\x0e\n\x07\x04\x04\x03\0\x02\0\x03\x12\x03P'(\n\r\n\x06\x04\x04\
    \x03\0\x02\x01\x12\x03Q\x10.\n\x0e\n\x07\x04\x04\x03\0\x02\x01\x04\x12\
    \x03Q\x10\x18\n\x0e\n\x07\x04\x04\x03\0\x02\x01\x05\x12\x03Q\x19\x20\n\
    \x0e\n\x07\x04\x04\x03\0\x02\x01\x01\x12\x03Q!)\n\x0e\n\x07\x04\x04\x03\
    \0\x02\x01\x03\x12\x03Q,-\n\x0b\n\x04\x04\x04\x02\0\x12\x03T\x08%\n\x0c\
    \n\x05\x04\x04\x02\0\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x03T\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03T\x18\x20\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03T#$\n\x0b\n\x04\x04\x04\x02\x01\x12\x03U\
    \x08'\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x01\x05\x12\x03U\x11\x18\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\
    \x03U\x19\"\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03U%&\n\x0b\n\x04\x04\
    \x04\x02\x02\x12\x03V\x08(\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03V\x08\
    \x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03V\x11\x17\n\x0c\n\x05\x04\
    \x04\x02\x02\x01\x12\x03V\x18#\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03V&\
    '\n\x0b\n\x04\x04\x04\x02\x03\x12\x03W\x08<\n\x0c\n\x05\x04\x04\x02\x03\
    \x04\x12\x03W\x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x06\x12\x03W\x11/\n\
    \x0c\n\x05\x04\x04\x02\x03\x01\x12\x03W07\n\x0c\n\x05\x04\x04\x02\x03\
    \x03\x12\x03W:;\n\x0b\n\x04\x04\x04\x02\x04\x12\x03X\x08+\n\x0c\n\x05\
    \x04\x04\x02\x04\x04\x12\x03X\x08\x10\n\x0c\n\x05\x04\x04\x02\x04\x05\
    \x12\x03X\x11\x17\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03X\x18&\n\x0c\n\
    \x05\x04\x04\x02\x04\x03\x12\x03X)*\n\x0b\n\x04\x04\x04\x02\x05\x12\x03Y\
    \x08(\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x05\x05\x12\x03Y\x11\x18\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\
    \x03Y\x19#\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03Y&'\n\x0b\n\x04\x04\
    \x04\x02\x06\x12\x03Z\x08-\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03Z\x08\
    \x10\n\x0c\n\x05\x04\x04\x02\x06\x05\x12\x03Z\x11\x18\n\x0c\n\x05\x04\
    \x04\x02\x06\x01\x12\x03Z\x19(\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03Z+\
    ,\n\x0b\n\x04\x04\x04\x02\x07\x12\x03[\x083\n\x0c\n\x05\x04\x04\x02\x07\
    \x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\x04\x02\x07\x05\x12\x03[\x11\x18\n\
    \x0c\n\x05\x04\x04\x02\x07\x01\x12\x03[\x19.\n\x0c\n\x05\x04\x04\x02\x07\
    \x03\x12\x03[12\n\x0b\n\x02\x04\x05\x12\x05^\0\x88\x01\x01\n\n\n\x03\x04\
    \x05\x01\x12\x03^\x08\x1a\n\x0b\n\x04\x04\x05\x02\0\x12\x03_\x08\x20\n\
    \x0c\n\x05\x04\x05\x02\0\x04\x12\x03_\x08\x10\n\x0c\n\x05\x04\x05\x02\0\
    \x05\x12\x03_\x11\x18\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03_\x19\x1b\n\
    \x0c\n\x05\x04\x05\x02\0\x03\x12\x03_\x1e\x1f\n\x0b\n\x04\x04\x05\x02\
    \x01\x12\x03`\x08$\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03`\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\x01\x05\x12\x03`\x11\x17\n\x0c\n\x05\x04\x05\x02\
    \x01\x01\x12\x03`\x18\x1f\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03`\"#\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x03a\x08'\n\x0c\n\x05\x04\x05\x02\x02\x04\
    \x12\x03a\x08\x10\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\x03a\x11\x1d\n\x0c\
    \n\x05\x04\x05\x02\x02\x01\x12\x03a\x1e\"\n\x0c\n\x05\x04\x05\x02\x02\
    \x03\x12\x03a%&\n\x0b\n\x04\x04\x05\x02\x03\x12\x03b\x08!\n\x0c\n\x05\
    \x04\x05\x02\x03\x04\x12\x03b\x08\x10\n\x0c\n\x05\x04\x05\x02\x03\x05\
    \x12\x03b\x11\x17\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03b\x18\x1c\n\x0c\
    \n\x05\x04\x05\x02\x03\x03\x12\x03b\x1f\x20\n\x0b\n\x04\x04\x05\x02\x04\
    \x12\x03c\x08!\n\x0c\n\x05\x04\x05\x02\x04\x04\x12\x03c\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\x04\x05\x12\x03c\x11\x17\n\x0c\n\x05\x04\x05\x02\x04\
    \x01\x12\x03c\x18\x1c\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03c\x1f\x20\n\
    \x0b\n\x04\x04\x05\x02\x05\x12\x03d\x08&\n\x0c\n\x05\x04\x05\x02\x05\x04\
    \x12\x03d\x08\x10\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\x03d\x11\x17\n\x0c\
    \n\x05\x04\x05\x02\x05\x01\x12\x03d\x18\x20\n\x0c\n\x05\x04\x05\x02\x05\
    \x03\x12\x03d#%\n\x0b\n\x04\x04\x05\x02\x06\x12\x03e\x08(\n\x0c\n\x05\
    \x04\x05\x02\x06\x04\x12\x03e\x08\x10\n\x0c\n\x05\x04\x05\x02\x06\x05\
    \x12\x03e\x11\x17\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03e\x18\"\n\x0c\n\
    \x05\x04\x05\x02\x06\x03\x12\x03e%'\n\x0b\n\x04\x04\x05\x02\x07\x12\x03f\
    \x08%\n\x0c\n\x05\x04\x05\x02\x07\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\
    \x05\x02\x07\x05\x12\x03f\x11\x17\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\
    \x03f\x18\x1f\n\x0c\n\x05\x04\x05\x02\x07\x03\x12\x03f\"$\n\x0b\n\x04\
    \x04\x05\x02\x08\x12\x03g\x08-\n\x0c\n\x05\x04\x05\x02\x08\x04\x12\x03g\
    \x08\x10\n\x0c\n\x05\x04\x05\x02\x08\x05\x12\x03g\x11\x17\n\x0c\n\x05\
    \x04\x05\x02\x08\x01\x12\x03g\x18'\n\x0c\n\x05\x04\x05\x02\x08\x03\x12\
    \x03g*,\n\x0b\n\x04\x04\x05\x02\t\x12\x03h\x087\n\x0c\n\x05\x04\x05\x02\
    \t\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\x05\x02\t\x06\x12\x03h\x11#\n\
    \x0c\n\x05\x04\x05\x02\t\x01\x12\x03h$1\n\x0c\n\x05\x04\x05\x02\t\x03\
    \x12\x03h46\n\x0b\n\x04\x04\x05\x02\n\x12\x03i\x08,\n\x0c\n\x05\x04\x05\
    \x02\n\x04\x12\x03i\x08\x10\n\x0c\n\x05\x04\x05\x02\n\x05\x12\x03i\x11\
    \x17\n\x0c\n\x05\x04\x05\x02\n\x01\x12\x03i\x18&\n\x0c\n\x05\x04\x05\x02\
    \n\x03\x12\x03i)+\n\x0b\n\x04\x04\x05\x02\x0b\x12\x03j\x08%\n\x0c\n\x05\
    \x04\x05\x02\x0b\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x05\x02\x0b\x05\
    \x12\x03j\x11\x17\n\x0c\n\x05\x04\x05\x02\x0b\x01\x12\x03j\x18\x1f\n\x0c\
    \n\x05\x04\x05\x02\x0b\x03\x12\x03j\"$\n\x0b\n\x04\x04\x05\x02\x0c\x12\
    \x03k\x08.\n\x0c\n\x05\x04\x05\x02\x0c\x04\x12\x03k\x08\x10\n\x0c\n\x05\
    \x04\x05\x02\x0c\x05\x12\x03k\x11\x17\n\x0c\n\x05\x04\x05\x02\x0c\x01\
    \x12\x03k\x18(\n\x0c\n\x05\x04\x05\x02\x0c\x03\x12\x03k+-\n\x0b\n\x04\
    \x04\x05\x02\r\x12\x03l\x08-\n\x0c\n\x05\x04\x05\x02\r\x04\x12\x03l\x08\
    \x10\n\x0c\n\x05\x04\x05\x02\r\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x05\
    \x02\r\x01\x12\x03l\x18'\n\x0c\n\x05\x04\x05\x02\r\x03\x12\x03l*,\n\x0b\
    \n\x04\x04\x05\x02\x0e\x12\x03m\x08.\n\x0c\n\x05\x04\x05\x02\x0e\x04\x12\
    \x03m\x08\x10\n\x0c\n\x05\x04\x05\x02\x0e\x06\x12\x03m\x11\x1d\n\x0c\n\
    \x05\x04\x05\x02\x0e\x01\x12\x03m\x1e(\n\x0c\n\x05\x04\x05\x02\x0e\x03\
    \x12\x03m+-\n\x0b\n\x04\x04\x05\x02\x0f\x12\x03n\x081\n\x0c\n\x05\x04\
    \x05\x02\x0f\x04\x12\x03n\x08\x10\n\x0c\n\x05\x04\x05\x02\x0f\x05\x12\
    \x03n\x11\x17\n\x0c\n\x05\x04\x05\x02\x0f\x01\x12\x03n\x18+\n\x0c\n\x05\
    \x04\x05\x02\x0f\x03\x12\x03n.0\n\x0b\n\x04\x04\x05\x02\x10\x12\x03o\x08\
    *\n\x0c\n\x05\x04\x05\x02\x10\x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x10\x05\x12\x03o\x11\x17\n\x0c\n\x05\x04\x05\x02\x10\x01\x12\x03o\
    \x18$\n\x0c\n\x05\x04\x05\x02\x10\x03\x12\x03o')\n\x0b\n\x04\x04\x05\x02\
    \x11\x12\x03p\x080\n\x0c\n\x05\x04\x05\x02\x11\x04\x12\x03p\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\x11\x05\x12\x03p\x11\x17\n\x0c\n\x05\x04\x05\x02\
    \x11\x01\x12\x03p\x18*\n\x0c\n\x05\x04\x05\x02\x11\x03\x12\x03p-/\n\x0b\
    \n\x04\x04\x05\x02\x12\x12\x03q\x082\n\x0c\n\x05\x04\x05\x02\x12\x04\x12\
    \x03q\x08\x10\n\x0c\n\x05\x04\x05\x02\x12\x05\x12\x03q\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\x12\x01\x12\x03q\x18,\n\x0c\n\x05\x04\x05\x02\x12\x03\
    \x12\x03q/1\n\x0b\n\x04\x04\x05\x02\x13\x12\x03r\x088\n\x0c\n\x05\x04\
    \x05\x02\x13\x04\x12\x03r\x08\x10\n\x0c\n\x05\x04\x05\x02\x13\x05\x12\
    \x03r\x11\x18\n\x0c\n\x05\x04\x05\x02\x13\x01\x12\x03r\x192\n\x0c\n\x05\
    \x04\x05\x02\x13\x03\x12\x03r57\n\x0b\n\x04\x04\x05\x02\x14\x12\x03s\x08\
    )\n\x0c\n\x05\x04\x05\x02\x14\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x14\x05\x12\x03s\x11\x17\n\x0c\n\x05\x04\x05\x02\x14\x01\x12\x03s\
    \x18#\n\x0c\n\x05\x04\x05\x02\x14\x03\x12\x03s&(\n\x0b\n\x04\x04\x05\x02\
    \x15\x12\x03t\x08%\n\x0c\n\x05\x04\x05\x02\x15\x04\x12\x03t\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\x15\x05\x12\x03t\x11\x15\n\x0c\n\x05\x04\x05\x02\
    \x15\x01\x12\x03t\x16\x1f\n\x0c\n\x05\x04\x05\x02\x15\x03\x12\x03t\"$\n\
    \x0b\n\x04\x04\x05\x02\x16\x12\x03u\x085\n\x0c\n\x05\x04\x05\x02\x16\x04\
    \x12\x03u\x08\x10\n\x0c\n\x05\x04\x05\x02\x16\x05\x12\x03u\x11\x17\n\x0c\
    \n\x05\x04\x05\x02\x16\x01\x12\x03u\x18/\n\x0c\n\x05\x04\x05\x02\x16\x03\
    \x12\x03u24\n\x0b\n\x04\x04\x05\x02\x17\x12\x03v\x082\n\x0c\n\x05\x04\
    \x05\x02\x17\x04\x12\x03v\x08\x10\n\x0c\n\x05\x04\x05\x02\x17\x06\x12\
    \x03v\x11\x1a\n\x0c\n\x05\x04\x05\x02\x17\x01\x12\x03v\x1b,\n\x0c\n\x05\
    \x04\x05\x02\x17\x03\x12\x03v/1\n\x0b\n\x04\x04\x05\x02\x18\x12\x03w\x08\
    2\n\x0c\n\x05\x04\x05\x02\x18\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x18\x05\x12\x03w\x11\x17\n\x0c\n\x05\x04\x05\x02\x18\x01\x12\x03w\
    \x18,\n\x0c\n\x05\x04\x05\x02\x18\x03\x12\x03w/1\n\x0b\n\x04\x04\x05\x02\
    \x19\x12\x03x\x08.\n\x0c\n\x05\x04\x05\x02\x19\x04\x12\x03x\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\x19\x05\x12\x03x\x11\x15\n\x0c\n\x05\x04\x05\x02\
    \x19\x01\x12\x03x\x16(\n\x0c\n\x05\x04\x05\x02\x19\x03\x12\x03x+-\n\x0b\
    \n\x04\x04\x05\x02\x1a\x12\x03y\x082\n\x0c\n\x05\x04\x05\x02\x1a\x04\x12\
    \x03y\x08\x10\n\x0c\n\x05\x04\x05\x02\x1a\x05\x12\x03y\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\x1a\x01\x12\x03y\x18,\n\x0c\n\x05\x04\x05\x02\x1a\x03\
    \x12\x03y/1\n\x0b\n\x04\x04\x05\x02\x1b\x12\x03z\x08,\n\x0c\n\x05\x04\
    \x05\x02\x1b\x04\x12\x03z\x08\x10\n\x0c\n\x05\x04\x05\x02\x1b\x05\x12\
    \x03z\x11\x15\n\x0c\n\x05\x04\x05\x02\x1b\x01\x12\x03z\x16&\n\x0c\n\x05\
    \x04\x05\x02\x1b\x03\x12\x03z)+\n\x0b\n\x04\x04\x05\x02\x1c\x12\x03{\x08\
    7\n\x0c\n\x05\x04\x05\x02\x1c\x04\x12\x03{\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x1c\x06\x12\x03{\x11\x1d\n\x0c\n\x05\x04\x05\x02\x1c\x01\x12\x03{\
    \x1e1\n\x0c\n\x05\x04\x05\x02\x1c\x03\x12\x03{46\n\x0b\n\x04\x04\x05\x02\
    \x1d\x12\x03|\x08-\n\x0c\n\x05\x04\x05\x02\x1d\x04\x12\x03|\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\x1d\x05\x12\x03|\x11\x15\n\x0c\n\x05\x04\x05\x02\
    \x1d\x01\x12\x03|\x16'\n\x0c\n\x05\x04\x05\x02\x1d\x03\x12\x03|*,\n\x0b\
    \n\x04\x04\x05\x02\x1e\x12\x03}\x08;\n\x0c\n\x05\x04\x05\x02\x1e\x04\x12\
    \x03}\x08\x10\n\x0c\n\x05\x04\x05\x02\x1e\x06\x12\x03}\x11&\n\x0c\n\x05\
    \x04\x05\x02\x1e\x01\x12\x03}'5\n\x0c\n\x05\x04\x05\x02\x1e\x03\x12\x03}\
    8:\n\x0b\n\x04\x04\x05\x02\x1f\x12\x03~\x08F\n\x0c\n\x05\x04\x05\x02\x1f\
    \x04\x12\x03~\x08\x10\n\x0c\n\x05\x04\x05\x02\x1f\x06\x12\x03~\x11&\n\
    \x0c\n\x05\x04\x05\x02\x1f\x01\x12\x03~'@\n\x0c\n\x05\x04\x05\x02\x1f\
    \x03\x12\x03~CE\n\x0b\n\x04\x04\x05\x02\x20\x12\x03\x7f\x08<\n\x0c\n\x05\
    \x04\x05\x02\x20\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\x05\x02\x20\x06\
    \x12\x03\x7f\x11\"\n\x0c\n\x05\x04\x05\x02\x20\x01\x12\x03\x7f#6\n\x0c\n\
    \x05\x04\x05\x02\x20\x03\x12\x03\x7f9;\n\x0c\n\x04\x04\x05\x02!\x12\x04\
    \x80\x01\x084\n\r\n\x05\x04\x05\x02!\x04\x12\x04\x80\x01\x08\x10\n\r\n\
    \x05\x04\x05\x02!\x05\x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\x05\x02!\x01\
    \x12\x04\x80\x01\x18.\n\r\n\x05\x04\x05\x02!\x03\x12\x04\x80\x0113\n\x0c\
    \n\x04\x04\x05\x02\"\x12\x04\x81\x01\x08&\n\r\n\x05\x04\x05\x02\"\x04\
    \x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\x05\x02\"\x05\x12\x04\x81\x01\x11\
    \x16\n\r\n\x05\x04\x05\x02\"\x01\x12\x04\x81\x01\x17\x20\n\r\n\x05\x04\
    \x05\x02\"\x03\x12\x04\x81\x01#%\n\x0c\n\x04\x04\x05\x02#\x12\x04\x82\
    \x01\x08#\n\r\n\x05\x04\x05\x02#\x04\x12\x04\x82\x01\x08\x10\n\r\n\x05\
    \x04\x05\x02#\x05\x12\x04\x82\x01\x11\x17\n\r\n\x05\x04\x05\x02#\x01\x12\
    \x04\x82\x01\x18\x1d\n\r\n\x05\x04\x05\x02#\x03\x12\x04\x82\x01\x20\"\n\
    \x0c\n\x04\x04\x05\x02$\x12\x04\x83\x01\x08&\n\r\n\x05\x04\x05\x02$\x04\
    \x12\x04\x83\x01\x08\x10\n\r\n\x05\x04\x05\x02$\x05\x12\x04\x83\x01\x11\
    \x17\n\r\n\x05\x04\x05\x02$\x01\x12\x04\x83\x01\x18\x20\n\r\n\x05\x04\
    \x05\x02$\x03\x12\x04\x83\x01#%\n\x0c\n\x04\x04\x05\x02%\x12\x04\x84\x01\
    \x08/\n\r\n\x05\x04\x05\x02%\x04\x12\x04\x84\x01\x08\x10\n\r\n\x05\x04\
    \x05\x02%\x05\x12\x04\x84\x01\x11\x17\n\r\n\x05\x04\x05\x02%\x01\x12\x04\
    \x84\x01\x18)\n\r\n\x05\x04\x05\x02%\x03\x12\x04\x84\x01,.\n\x0c\n\x04\
    \x04\x05\x02&\x12\x04\x85\x01\x08*\n\r\n\x05\x04\x05\x02&\x04\x12\x04\
    \x85\x01\x08\x10\n\r\n\x05\x04\x05\x02&\x05\x12\x04\x85\x01\x11\x15\n\r\
    \n\x05\x04\x05\x02&\x01\x12\x04\x85\x01\x16$\n\r\n\x05\x04\x05\x02&\x03\
    \x12\x04\x85\x01')\n\x0c\n\x04\x04\x05\x02'\x12\x04\x86\x01\x087\n\r\n\
    \x05\x04\x05\x02'\x04\x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\x05\x02'\x05\
    \x12\x04\x86\x01\x11\x17\n\r\n\x05\x04\x05\x02'\x01\x12\x04\x86\x01\x181\
    \n\r\n\x05\x04\x05\x02'\x03\x12\x04\x86\x0146\n\x0c\n\x04\x04\x05\x02(\
    \x12\x04\x87\x01\x085\n\r\n\x05\x04\x05\x02(\x04\x12\x04\x87\x01\x08\x10\
    \n\r\n\x05\x04\x05\x02(\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x05\
    \x02(\x01\x12\x04\x87\x01\x18/\n\r\n\x05\x04\x05\x02(\x03\x12\x04\x87\
    \x0124\n\x0c\n\x02\x04\x06\x12\x06\x8a\x01\0\x8b\x01\x01\n\x0b\n\x03\x04\
    \x06\x01\x12\x04\x8a\x01\x08\x20\n\x0c\n\x02\x04\x07\x12\x06\x8d\x01\0\
    \x8e\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x8d\x01\x08\x20\n\x0c\n\x02\
    \x04\x08\x12\x06\x90\x01\0\x91\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \x90\x01\x08&\n\x0c\n\x02\x04\t\x12\x06\x93\x01\0\xa2\x01\x01\n\x0b\n\
    \x03\x04\t\x01\x12\x04\x93\x01\x08\x19\n\x0c\n\x04\x04\t\x02\0\x12\x04\
    \x94\x01\x08&\n\r\n\x05\x04\t\x02\0\x04\x12\x04\x94\x01\x08\x10\n\r\n\
    \x05\x04\t\x02\0\x05\x12\x04\x94\x01\x11\x17\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\x94\x01\x18!\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x94\x01$%\n\x0c\
    \n\x04\x04\t\x02\x01\x12\x04\x95\x01\x08%\n\r\n\x05\x04\t\x02\x01\x04\
    \x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\x95\x01\x11\
    \x17\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x95\x01\x18\x20\n\r\n\x05\x04\t\
    \x02\x01\x03\x12\x04\x95\x01#$\n\x0c\n\x04\x04\t\x02\x02\x12\x04\x96\x01\
    \x08$\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\
    \t\x02\x02\x05\x12\x04\x96\x01\x11\x17\n\r\n\x05\x04\t\x02\x02\x01\x12\
    \x04\x96\x01\x18\x1f\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\x96\x01\"#\n\
    \x0c\n\x04\x04\t\x02\x03\x12\x04\x97\x01\x08&\n\r\n\x05\x04\t\x02\x03\
    \x04\x12\x04\x97\x01\x08\x10\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\x97\x01\
    \x11\x17\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\x97\x01\x18!\n\r\n\x05\x04\
    \t\x02\x03\x03\x12\x04\x97\x01$%\n\x0c\n\x04\x04\t\x02\x04\x12\x04\x98\
    \x01\x08+\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\
    \x04\t\x02\x04\x05\x12\x04\x98\x01\x11\x17\n\r\n\x05\x04\t\x02\x04\x01\
    \x12\x04\x98\x01\x18&\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\x98\x01)*\n\
    \x0c\n\x04\x04\t\x02\x05\x12\x04\x99\x01\x08-\n\r\n\x05\x04\t\x02\x05\
    \x04\x12\x04\x99\x01\x08\x10\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\x99\x01\
    \x11\x17\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\x99\x01\x18(\n\r\n\x05\x04\
    \t\x02\x05\x03\x12\x04\x99\x01+,\n\x0c\n\x04\x04\t\x02\x06\x12\x04\x9a\
    \x01\x08(\n\r\n\x05\x04\t\x02\x06\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\
    \x04\t\x02\x06\x05\x12\x04\x9a\x01\x11\x15\n\r\n\x05\x04\t\x02\x06\x01\
    \x12\x04\x9a\x01\x16#\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\x9a\x01&'\n\
    \x0c\n\x04\x04\t\x02\x07\x12\x04\x9b\x01\x08\"\n\r\n\x05\x04\t\x02\x07\
    \x04\x12\x04\x9b\x01\x08\x10\n\r\n\x05\x04\t\x02\x07\x05\x12\x04\x9b\x01\
    \x11\x17\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\x9b\x01\x18\x1c\n\r\n\x05\
    \x04\t\x02\x07\x03\x12\x04\x9b\x01\x1f!\n\x0c\n\x04\x04\t\x02\x08\x12\
    \x04\x9c\x01\x08)\n\r\n\x05\x04\t\x02\x08\x04\x12\x04\x9c\x01\x08\x10\n\
    \r\n\x05\x04\t\x02\x08\x05\x12\x04\x9c\x01\x11\x17\n\r\n\x05\x04\t\x02\
    \x08\x01\x12\x04\x9c\x01\x18#\n\r\n\x05\x04\t\x02\x08\x03\x12\x04\x9c\
    \x01&(\n\x0c\n\x04\x04\t\x02\t\x12\x04\x9d\x01\x08(\n\r\n\x05\x04\t\x02\
    \t\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\t\x02\t\x05\x12\x04\x9d\x01\
    \x11\x15\n\r\n\x05\x04\t\x02\t\x01\x12\x04\x9d\x01\x16\"\n\r\n\x05\x04\t\
    \x02\t\x03\x12\x04\x9d\x01%'\n\x0c\n\x04\x04\t\x02\n\x12\x04\x9e\x01\x08\
    .\n\r\n\x05\x04\t\x02\n\x04\x12\x04\x9e\x01\x08\x10\n\r\n\x05\x04\t\x02\
    \n\x05\x12\x04\x9e\x01\x11\x15\n\r\n\x05\x04\t\x02\n\x01\x12\x04\x9e\x01\
    \x16(\n\r\n\x05\x04\t\x02\n\x03\x12\x04\x9e\x01+-\n\x0c\n\x04\x04\t\x02\
    \x0b\x12\x04\x9f\x01\x08;\n\r\n\x05\x04\t\x02\x0b\x04\x12\x04\x9f\x01\
    \x08\x10\n\r\n\x05\x04\t\x02\x0b\x05\x12\x04\x9f\x01\x11\x17\n\r\n\x05\
    \x04\t\x02\x0b\x01\x12\x04\x9f\x01\x185\n\r\n\x05\x04\t\x02\x0b\x03\x12\
    \x04\x9f\x018:\n\x0c\n\x04\x04\t\x02\x0c\x12\x04\xa0\x01\x08+\n\r\n\x05\
    \x04\t\x02\x0c\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\t\x02\x0c\x05\
    \x12\x04\xa0\x01\x11\x17\n\r\n\x05\x04\t\x02\x0c\x01\x12\x04\xa0\x01\x18\
    %\n\r\n\x05\x04\t\x02\x0c\x03\x12\x04\xa0\x01(*\n\x0c\n\x04\x04\t\x02\r\
    \x12\x04\xa1\x01\x08/\n\r\n\x05\x04\t\x02\r\x04\x12\x04\xa1\x01\x08\x10\
    \n\r\n\x05\x04\t\x02\r\x05\x12\x04\xa1\x01\x11\x17\n\r\n\x05\x04\t\x02\r\
    \x01\x12\x04\xa1\x01\x18)\n\r\n\x05\x04\t\x02\r\x03\x12\x04\xa1\x01,.\n\
    \x0c\n\x02\x04\n\x12\x06\xa4\x01\0\xb0\x01\x01\n\x0b\n\x03\x04\n\x01\x12\
    \x04\xa4\x01\x08\x1a\n\x0c\n\x04\x04\n\x02\0\x12\x04\xa5\x01\x08%\n\r\n\
    \x05\x04\n\x02\0\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\
    \x12\x04\xa5\x01\x11\x17\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xa5\x01\x18\
    \x20\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xa5\x01#$\n\x0c\n\x04\x04\n\x02\
    \x01\x12\x04\xa6\x01\x080\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xa6\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xa6\x01\x11\x17\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\xa6\x01\x18+\n\r\n\x05\x04\n\x02\x01\x03\x12\
    \x04\xa6\x01./\n\x0c\n\x04\x04\n\x02\x02\x12\x04\xa7\x01\x082\n\r\n\x05\
    \x04\n\x02\x02\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\n\x02\x02\x05\
    \x12\x04\xa7\x01\x11\x17\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xa7\x01\x18\
    -\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xa7\x0101\n\x0c\n\x04\x04\n\x02\
    \x03\x12\x04\xa8\x01\x08*\n\r\n\x05\x04\n\x02\x03\x04\x12\x04\xa8\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xa8\x01\x11\x17\n\r\n\x05\
    \x04\n\x02\x03\x01\x12\x04\xa8\x01\x18%\n\r\n\x05\x04\n\x02\x03\x03\x12\
    \x04\xa8\x01()\n\x0c\n\x04\x04\n\x02\x04\x12\x04\xa9\x01\x08'\n\r\n\x05\
    \x04\n\x02\x04\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\n\x02\x04\x05\
    \x12\x04\xa9\x01\x11\x17\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xa9\x01\x18\
    \"\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xa9\x01%&\n\x0c\n\x04\x04\n\x02\
    \x05\x12\x04\xaa\x01\x08)\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\xaa\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\x05\x05\x12\x04\xaa\x01\x11\x17\n\r\n\x05\
    \x04\n\x02\x05\x01\x12\x04\xaa\x01\x18$\n\r\n\x05\x04\n\x02\x05\x03\x12\
    \x04\xaa\x01'(\n\x0c\n\x04\x04\n\x02\x06\x12\x04\xab\x01\x08(\n\r\n\x05\
    \x04\n\x02\x06\x04\x12\x04\xab\x01\x08\x10\n\r\n\x05\x04\n\x02\x06\x05\
    \x12\x04\xab\x01\x11\x17\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\xab\x01\x18\
    #\n\r\n\x05\x04\n\x02\x06\x03\x12\x04\xab\x01&'\n\x0c\n\x04\x04\n\x02\
    \x07\x12\x04\xac\x01\x08(\n\r\n\x05\x04\n\x02\x07\x04\x12\x04\xac\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\x07\x05\x12\x04\xac\x01\x11\x17\n\r\n\x05\
    \x04\n\x02\x07\x01\x12\x04\xac\x01\x18#\n\r\n\x05\x04\n\x02\x07\x03\x12\
    \x04\xac\x01&'\n\x0c\n\x04\x04\n\x02\x08\x12\x04\xad\x01\x081\n\r\n\x05\
    \x04\n\x02\x08\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\n\x02\x08\x06\
    \x12\x04\xad\x01\x11\x1d\n\r\n\x05\x04\n\x02\x08\x01\x12\x04\xad\x01\x1e\
    ,\n\r\n\x05\x04\n\x02\x08\x03\x12\x04\xad\x01/0\n\x0c\n\x04\x04\n\x02\t\
    \x12\x04\xae\x01\x08'\n\r\n\x05\x04\n\x02\t\x04\x12\x04\xae\x01\x08\x10\
    \n\r\n\x05\x04\n\x02\t\x05\x12\x04\xae\x01\x11\x17\n\r\n\x05\x04\n\x02\t\
    \x01\x12\x04\xae\x01\x18!\n\r\n\x05\x04\n\x02\t\x03\x12\x04\xae\x01$&\n\
    \x0c\n\x04\x04\n\x02\n\x12\x04\xaf\x01\x085\n\r\n\x05\x04\n\x02\n\x04\
    \x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\n\x02\n\x05\x12\x04\xaf\x01\x11\
    \x17\n\r\n\x05\x04\n\x02\n\x01\x12\x04\xaf\x01\x18/\n\r\n\x05\x04\n\x02\
    \n\x03\x12\x04\xaf\x0124\n\x0c\n\x02\x04\x0b\x12\x06\xb2\x01\0\xb8\x01\
    \x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xb2\x01\x08\x20\n\x0c\n\x04\x04\x0b\
    \x02\0\x12\x04\xb3\x01\x08+\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xb3\x01\
    \x08\x10\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xb3\x01\x11\x17\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\xb3\x01\x18&\n\r\n\x05\x04\x0b\x02\0\x03\x12\
    \x04\xb3\x01)*\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xb4\x01\x08*\n\r\n\
    \x05\x04\x0b\x02\x01\x04\x12\x04\xb4\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x01\x05\x12\x04\xb4\x01\x11\x15\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\
    \xb4\x01\x16%\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xb4\x01()\n\x0c\n\
    \x04\x04\x0b\x02\x02\x12\x04\xb5\x01\x08(\n\r\n\x05\x04\x0b\x02\x02\x04\
    \x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xb5\x01\
    \x11\x15\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xb5\x01\x16#\n\r\n\x05\
    \x04\x0b\x02\x02\x03\x12\x04\xb5\x01&'\n\x0c\n\x04\x04\x0b\x02\x03\x12\
    \x04\xb6\x01\x08'\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\xb6\x01\x08\x10\
    \n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xb6\x01\x11\x17\n\r\n\x05\x04\x0b\
    \x02\x03\x01\x12\x04\xb6\x01\x18\"\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\
    \xb6\x01%&\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\xb7\x01\x08#\n\r\n\x05\
    \x04\x0b\x02\x04\x04\x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x04\
    \x05\x12\x04\xb7\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xb7\
    \x01\x18\x1e\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\xb7\x01!\"\n\x0c\n\
    \x02\x04\x0c\x12\x06\xba\x01\0\xbf\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\
    \x04\xba\x01\x08\"\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xbb\x01\x08'\n\r\n\
    \x05\x04\x0c\x02\0\x04\x12\x04\xbb\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\xbb\x01\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xbb\x01\
    \x18\"\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xbb\x01%&\n\x0c\n\x04\x04\x0c\
    \x02\x01\x12\x04\xbc\x01\x08)\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xbc\
    \x01\x08\x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xbc\x01\x11\x17\n\r\n\
    \x05\x04\x0c\x02\x01\x01\x12\x04\xbc\x01\x18$\n\r\n\x05\x04\x0c\x02\x01\
    \x03\x12\x04\xbc\x01'(\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xbd\x01\x08(\
    \n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xbd\x01\x08\x10\n\r\n\x05\x04\x0c\
    \x02\x02\x05\x12\x04\xbd\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x02\x01\x12\
    \x04\xbd\x01\x18#\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xbd\x01&'\n\x0c\
    \n\x04\x04\x0c\x02\x03\x12\x04\xbe\x01\x08*\n\r\n\x05\x04\x0c\x02\x03\
    \x04\x12\x04\xbe\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xbe\
    \x01\x11\x17\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xbe\x01\x18%\n\r\n\
    \x05\x04\x0c\x02\x03\x03\x12\x04\xbe\x01()\n\x0c\n\x02\x04\r\x12\x06\xc1\
    \x01\0\xca\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xc1\x01\x08\x1c\n\x0c\n\
    \x04\x04\r\x02\0\x12\x04\xc2\x01\x08%\n\r\n\x05\x04\r\x02\0\x04\x12\x04\
    \xc2\x01\x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xc2\x01\x11\x17\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\xc2\x01\x18\x20\n\r\n\x05\x04\r\x02\0\x03\
    \x12\x04\xc2\x01#$\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xc3\x01\x08%\n\r\n\
    \x05\x04\r\x02\x01\x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\
    \x06\x12\x04\xc3\x01\x11\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xc3\x01\
    \x18\x20\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xc3\x01#$\n\x0c\n\x04\x04\r\
    \x02\x02\x12\x04\xc4\x01\x082\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xc4\
    \x01\x08\x10\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xc4\x01\x11\x17\n\r\n\
    \x05\x04\r\x02\x02\x01\x12\x04\xc4\x01\x18-\n\r\n\x05\x04\r\x02\x02\x03\
    \x12\x04\xc4\x0101\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xc5\x01\x080\n\r\n\
    \x05\x04\r\x02\x03\x04\x12\x04\xc5\x01\x08\x10\n\r\n\x05\x04\r\x02\x03\
    \x05\x12\x04\xc5\x01\x11\x17\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xc5\x01\
    \x18+\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xc5\x01./\n\x0c\n\x04\x04\r\
    \x02\x04\x12\x04\xc6\x01\x080\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\xc6\
    \x01\x08\x10\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xc6\x01\x11\x17\n\r\n\
    \x05\x04\r\x02\x04\x01\x12\x04\xc6\x01\x18+\n\r\n\x05\x04\r\x02\x04\x03\
    \x12\x04\xc6\x01./\n\x0c\n\x04\x04\r\x02\x05\x12\x04\xc7\x01\x084\n\r\n\
    \x05\x04\r\x02\x05\x04\x12\x04\xc7\x01\x08\x10\n\r\n\x05\x04\r\x02\x05\
    \x05\x12\x04\xc7\x01\x11\x17\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\xc7\x01\
    \x18/\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\xc7\x0123\n\x0c\n\x04\x04\r\
    \x02\x06\x12\x04\xc8\x01\x088\n\r\n\x05\x04\r\x02\x06\x04\x12\x04\xc8\
    \x01\x08\x10\n\r\n\x05\x04\r\x02\x06\x05\x12\x04\xc8\x01\x11\x17\n\r\n\
    \x05\x04\r\x02\x06\x01\x12\x04\xc8\x01\x183\n\r\n\x05\x04\r\x02\x06\x03\
    \x12\x04\xc8\x0167\n\x0c\n\x04\x04\r\x02\x07\x12\x04\xc9\x01\x081\n\r\n\
    \x05\x04\r\x02\x07\x04\x12\x04\xc9\x01\x08\x10\n\r\n\x05\x04\r\x02\x07\
    \x05\x12\x04\xc9\x01\x11\x17\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\xc9\x01\
    \x18,\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\xc9\x01/0\n\x0c\n\x02\x04\x0e\
    \x12\x06\xcc\x01\0\xcc\x02\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xcc\x01\
    \x08\x14\n\x0e\n\x04\x04\x0e\x03\0\x12\x06\xcd\x01\x08\xd0\x01\t\n\r\n\
    \x05\x04\x0e\x03\0\x01\x12\x04\xcd\x01\x10\x19\n\x0e\n\x06\x04\x0e\x03\0\
    \x02\0\x12\x04\xce\x01\x10'\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x04\x12\x04\
    \xce\x01\x10\x18\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x05\x12\x04\xce\x01\x19\
    \x1f\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x01\x12\x04\xce\x01\x20\"\n\x0f\n\
    \x07\x04\x0e\x03\0\x02\0\x03\x12\x04\xce\x01%&\n\x0e\n\x06\x04\x0e\x03\0\
    \x02\x01\x12\x04\xcf\x01\x10,\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x04\x12\
    \x04\xcf\x01\x10\x18\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x05\x12\x04\xcf\
    \x01\x19\x1e\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x01\x12\x04\xcf\x01\x1f'\
    \n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x03\x12\x04\xcf\x01*+\n\x0e\n\x04\x04\
    \x0e\x04\0\x12\x06\xd2\x01\x08\xda\x01\t\n\r\n\x05\x04\x0e\x04\0\x01\x12\
    \x04\xd2\x01\r\x12\n\x0e\n\x06\x04\x0e\x04\0\x02\0\x12\x04\xd3\x01\x10\
    \x17\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x01\x12\x04\xd3\x01\x10\x12\n\x0f\n\
    \x07\x04\x0e\x04\0\x02\0\x02\x12\x04\xd3\x01\x15\x16\n\x0e\n\x06\x04\x0e\
    \x04\0\x02\x01\x12\x04\xd4\x01\x10\x1c\n\x0f\n\x07\x04\x0e\x04\0\x02\x01\
    \x01\x12\x04\xd4\x01\x10\x17\n\x0f\n\x07\x04\x0e\x04\0\x02\x01\x02\x12\
    \x04\xd4\x01\x1a\x1b\n\x0e\n\x06\x04\x0e\x04\0\x02\x02\x12\x04\xd5\x01\
    \x10\x20\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x01\x12\x04\xd5\x01\x10\x1b\n\
    \x0f\n\x07\x04\x0e\x04\0\x02\x02\x02\x12\x04\xd5\x01\x1e\x1f\n\x0e\n\x06\
    \x04\x0e\x04\0\x02\x03\x12\x04\xd6\x01\x10\x18\n\x0f\n\x07\x04\x0e\x04\0\
    \x02\x03\x01\x12\x04\xd6\x01\x10\x13\n\x0f\n\x07\x04\x0e\x04\0\x02\x03\
    \x02\x12\x04\xd6\x01\x16\x17\n\x0e\n\x06\x04\x0e\x04\0\x02\x04\x12\x04\
    \xd7\x01\x10\x1d\n\x0f\n\x07\x04\x0e\x04\0\x02\x04\x01\x12\x04\xd7\x01\
    \x10\x18\n\x0f\n\x07\x04\x0e\x04\0\x02\x04\x02\x12\x04\xd7\x01\x1b\x1c\n\
    \x0e\n\x06\x04\x0e\x04\0\x02\x05\x12\x04\xd8\x01\x10\x1d\n\x0f\n\x07\x04\
    \x0e\x04\0\x02\x05\x01\x12\x04\xd8\x01\x10\x18\n\x0f\n\x07\x04\x0e\x04\0\
    \x02\x05\x02\x12\x04\xd8\x01\x1b\x1c\n\x0e\n\x06\x04\x0e\x04\0\x02\x06\
    \x12\x04\xd9\x01\x10!\n\x0f\n\x07\x04\x0e\x04\0\x02\x06\x01\x12\x04\xd9\
    \x01\x10\x1c\n\x0f\n\x07\x04\x0e\x04\0\x02\x06\x02\x12\x04\xd9\x01\x1f\
    \x20\n\x0e\n\x04\x04\x0e\x04\x01\x12\x06\xdc\x01\x08\xe8\x01\t\n\r\n\x05\
    \x04\x0e\x04\x01\x01\x12\x04\xdc\x01\r\x16\n\x0e\n\x06\x04\x0e\x04\x01\
    \x02\0\x12\x04\xdd\x01\x10\x1d\n\x0f\n\x07\x04\x0e\x04\x01\x02\0\x01\x12\
    \x04\xdd\x01\x10\x17\n\x0f\n\x07\x04\x0e\x04\x01\x02\0\x02\x12\x04\xdd\
    \x01\x1a\x1c\n\x0e\n\x06\x04\x0e\x04\x01\x02\x01\x12\x04\xde\x01\x10!\n\
    \x0f\n\x07\x04\x0e\x04\x01\x02\x01\x01\x12\x04\xde\x01\x10\x1c\n\x0f\n\
    \x07\x04\x0e\x04\x01\x02\x01\x02\x12\x04\xde\x01\x1f\x20\n\x0e\n\x06\x04\
    \x0e\x04\x01\x02\x02\x12\x04\xdf\x01\x10\x1d\n\x0f\n\x07\x04\x0e\x04\x01\
    \x02\x02\x01\x12\x04\xdf\x01\x10\x18\n\x0f\n\x07\x04\x0e\x04\x01\x02\x02\
    \x02\x12\x04\xdf\x01\x1b\x1c\n\x0e\n\x06\x04\x0e\x04\x01\x02\x03\x12\x04\
    \xe0\x01\x10#\n\x0f\n\x07\x04\x0e\x04\x01\x02\x03\x01\x12\x04\xe0\x01\
    \x10\x1e\n\x0f\n\x07\x04\x0e\x04\x01\x02\x03\x02\x12\x04\xe0\x01!\"\n\
    \x0e\n\x06\x04\x0e\x04\x01\x02\x04\x12\x04\xe1\x01\x10&\n\x0f\n\x07\x04\
    \x0e\x04\x01\x02\x04\x01\x12\x04\xe1\x01\x10!\n\x0f\n\x07\x04\x0e\x04\
    \x01\x02\x04\x02\x12\x04\xe1\x01$%\n\x0e\n\x06\x04\x0e\x04\x01\x02\x05\
    \x12\x04\xe2\x01\x10$\n\x0f\n\x07\x04\x0e\x04\x01\x02\x05\x01\x12\x04\
    \xe2\x01\x10\x1f\n\x0f\n\x07\x04\x0e\x04\x01\x02\x05\x02\x12\x04\xe2\x01\
    \"#\n\x0e\n\x06\x04\x0e\x04\x01\x02\x06\x12\x04\xe3\x01\x10%\n\x0f\n\x07\
    \x04\x0e\x04\x01\x02\x06\x01\x12\x04\xe3\x01\x10\x1f\n\x0f\n\x07\x04\x0e\
    \x04\x01\x02\x06\x02\x12\x04\xe3\x01\"$\n\x0e\n\x06\x04\x0e\x04\x01\x02\
    \x07\x12\x04\xe4\x01\x10\x1f\n\x0f\n\x07\x04\x0e\x04\x01\x02\x07\x01\x12\
    \x04\xe4\x01\x10\x19\n\x0f\n\x07\x04\x0e\x04\x01\x02\x07\x02\x12\x04\xe4\
    \x01\x1c\x1e\n\x0e\n\x06\x04\x0e\x04\x01\x02\x08\x12\x04\xe5\x01\x10!\n\
    \x0f\n\x07\x04\x0e\x04\x01\x02\x08\x01\x12\x04\xe5\x01\x10\x1b\n\x0f\n\
    \x07\x04\x0e\x04\x01\x02\x08\x02\x12\x04\xe5\x01\x1e\x20\n\x0e\n\x06\x04\
    \x0e\x04\x01\x02\t\x12\x04\xe6\x01\x10%\n\x0f\n\x07\x04\x0e\x04\x01\x02\
    \t\x01\x12\x04\xe6\x01\x10\x1f\n\x0f\n\x07\x04\x0e\x04\x01\x02\t\x02\x12\
    \x04\xe6\x01\"$\n\x0e\n\x06\x04\x0e\x04\x01\x02\n\x12\x04\xe7\x01\x10'\n\
    \x0f\n\x07\x04\x0e\x04\x01\x02\n\x01\x12\x04\xe7\x01\x10!\n\x0f\n\x07\
    \x04\x0e\x04\x01\x02\n\x02\x12\x04\xe7\x01$&\n\x0c\n\x04\x04\x0e\x02\0\
    \x12\x04\xea\x01\x08%\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xea\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xea\x01\x11\x17\n\r\n\x05\x04\
    \x0e\x02\0\x01\x12\x04\xea\x01\x18\x20\n\r\n\x05\x04\x0e\x02\0\x03\x12\
    \x04\xea\x01#$\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xeb\x01\x086\n\r\n\
    \x05\x04\x0e\x02\x01\x04\x12\x04\xeb\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x01\x06\x12\x04\xeb\x01\x11#\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xeb\
    \x01$/\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xeb\x0125\n\x0c\n\x04\x04\
    \x0e\x02\x02\x12\x04\xec\x01\x08-\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\
    \xec\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xec\x01\x11\x17\n\
    \r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xec\x01\x18&\n\r\n\x05\x04\x0e\x02\
    \x02\x03\x12\x04\xec\x01),\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xed\x01\
    \x082\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xed\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x03\x05\x12\x04\xed\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x03\
    \x01\x12\x04\xed\x01\x18+\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xed\x01.\
    1\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\xee\x01\x082\n\r\n\x05\x04\x0e\x02\
    \x04\x04\x12\x04\xee\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\
    \xee\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xee\x01\x18+\n\r\
    \n\x05\x04\x0e\x02\x04\x03\x12\x04\xee\x01.1\n\x0c\n\x04\x04\x0e\x02\x05\
    \x12\x04\xef\x01\x08(\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\xef\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xef\x01\x11\x18\n\r\n\x05\x04\
    \x0e\x02\x05\x01\x12\x04\xef\x01\x19\"\n\r\n\x05\x04\x0e\x02\x05\x03\x12\
    \x04\xef\x01%'\n\x0c\n\x04\x04\x0e\x02\x06\x12\x04\xf0\x01\x08'\n\r\n\
    \x05\x04\x0e\x02\x06\x04\x12\x04\xf0\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x06\x05\x12\x04\xf0\x01\x11\x18\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\
    \xf0\x01\x19\"\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xf0\x01%&\n\x0c\n\
    \x04\x04\x0e\x02\x07\x12\x04\xf1\x01\x08&\n\r\n\x05\x04\x0e\x02\x07\x04\
    \x12\x04\xf1\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x07\x05\x12\x04\xf1\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xf1\x01\x18!\n\r\n\x05\
    \x04\x0e\x02\x07\x03\x12\x04\xf1\x01$%\n\x0c\n\x04\x04\x0e\x02\x08\x12\
    \x04\xf2\x01\x08.\n\r\n\x05\x04\x0e\x02\x08\x04\x12\x04\xf2\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\xf2\x01\x11\x18\n\r\n\x05\x04\x0e\
    \x02\x08\x01\x12\x04\xf2\x01\x19(\n\r\n\x05\x04\x0e\x02\x08\x03\x12\x04\
    \xf2\x01+-\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\xf3\x01\x08.\n\r\n\x05\x04\
    \x0e\x02\t\x04\x12\x04\xf3\x01\x08\x10\n\r\n\x05\x04\x0e\x02\t\x06\x12\
    \x04\xf3\x01\x11#\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\xf3\x01$)\n\r\n\
    \x05\x04\x0e\x02\t\x03\x12\x04\xf3\x01,-\n\x0c\n\x04\x04\x0e\x02\n\x12\
    \x04\xf4\x01\x08$\n\r\n\x05\x04\x0e\x02\n\x04\x12\x04\xf4\x01\x08\x10\n\
    \r\n\x05\x04\x0e\x02\n\x05\x12\x04\xf4\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \n\x01\x12\x04\xf4\x01\x18\x1f\n\r\n\x05\x04\x0e\x02\n\x03\x12\x04\xf4\
    \x01\"#\n\x0c\n\x04\x04\x0e\x02\x0b\x12\x04\xf5\x01\x088\n\r\n\x05\x04\
    \x0e\x02\x0b\x04\x12\x04\xf5\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x0b\x06\
    \x12\x04\xf5\x01\x11'\n\r\n\x05\x04\x0e\x02\x0b\x01\x12\x04\xf5\x01(2\n\
    \r\n\x05\x04\x0e\x02\x0b\x03\x12\x04\xf5\x0157\n\x0c\n\x04\x04\x0e\x02\
    \x0c\x12\x04\xf6\x01\x08(\n\r\n\x05\x04\x0e\x02\x0c\x04\x12\x04\xf6\x01\
    \x08\x10\n\r\n\x05\x04\x0e\x02\x0c\x05\x12\x04\xf6\x01\x11\x15\n\r\n\x05\
    \x04\x0e\x02\x0c\x01\x12\x04\xf6\x01\x16\"\n\r\n\x05\x04\x0e\x02\x0c\x03\
    \x12\x04\xf6\x01%'\n\x0c\n\x04\x04\x0e\x02\r\x12\x04\xf7\x01\x08*\n\r\n\
    \x05\x04\x0e\x02\r\x04\x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\x0e\x02\r\
    \x05\x12\x04\xf7\x01\x11\x15\n\r\n\x05\x04\x0e\x02\r\x01\x12\x04\xf7\x01\
    \x16$\n\r\n\x05\x04\x0e\x02\r\x03\x12\x04\xf7\x01')\n\x0c\n\x04\x04\x0e\
    \x02\x0e\x12\x04\xf8\x01\x08&\n\r\n\x05\x04\x0e\x02\x0e\x04\x12\x04\xf8\
    \x01\x08\x10\n\r\n\x05\x04\x0e\x02\x0e\x05\x12\x04\xf8\x01\x11\x15\n\r\n\
    \x05\x04\x0e\x02\x0e\x01\x12\x04\xf8\x01\x16\x20\n\r\n\x05\x04\x0e\x02\
    \x0e\x03\x12\x04\xf8\x01#%\n\x0c\n\x04\x04\x0e\x02\x0f\x12\x04\xf9\x01\
    \x08'\n\r\n\x05\x04\x0e\x02\x0f\x04\x12\x04\xf9\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x0f\x05\x12\x04\xf9\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x0f\
    \x01\x12\x04\xf9\x01\x18!\n\r\n\x05\x04\x0e\x02\x0f\x03\x12\x04\xf9\x01$\
    &\n\x0c\n\x04\x04\x0e\x02\x10\x12\x04\xfa\x01\x085\n\r\n\x05\x04\x0e\x02\
    \x10\x04\x12\x04\xfa\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x10\x06\x12\x04\
    \xfa\x01\x11\"\n\r\n\x05\x04\x0e\x02\x10\x01\x12\x04\xfa\x01#/\n\r\n\x05\
    \x04\x0e\x02\x10\x03\x12\x04\xfa\x0124\n\x0c\n\x04\x04\x0e\x02\x11\x12\
    \x04\xfb\x01\x08-\n\r\n\x05\x04\x0e\x02\x11\x04\x12\x04\xfb\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x11\x05\x12\x04\xfb\x01\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x11\x01\x12\x04\xfb\x01\x18'\n\r\n\x05\x04\x0e\x02\x11\x03\x12\x04\
    \xfb\x01*,\n\x0c\n\x04\x04\x0e\x02\x12\x12\x04\xfc\x01\x08+\n\r\n\x05\
    \x04\x0e\x02\x12\x04\x12\x04\xfc\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x12\
    \x05\x12\x04\xfc\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x12\x01\x12\x04\xfc\
    \x01\x18%\n\r\n\x05\x04\x0e\x02\x12\x03\x12\x04\xfc\x01(*\n\x0c\n\x04\
    \x04\x0e\x02\x13\x12\x04\xfd\x01\x080\n\r\n\x05\x04\x0e\x02\x13\x04\x12\
    \x04\xfd\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x13\x05\x12\x04\xfd\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x13\x01\x12\x04\xfd\x01\x18*\n\r\n\x05\x04\
    \x0e\x02\x13\x03\x12\x04\xfd\x01-/\n\x0c\n\x04\x04\x0e\x02\x14\x12\x04\
    \xfe\x01\x08+\n\r\n\x05\x04\x0e\x02\x14\x04\x12\x04\xfe\x01\x08\x10\n\r\
    \n\x05\x04\x0e\x02\x14\x05\x12\x04\xfe\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \x14\x01\x12\x04\xfe\x01\x18%\n\r\n\x05\x04\x0e\x02\x14\x03\x12\x04\xfe\
    \x01(*\n\x0c\n\x04\x04\x0e\x02\x15\x12\x04\xff\x01\x080\n\r\n\x05\x04\
    \x0e\x02\x15\x04\x12\x04\xff\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x15\x06\
    \x12\x04\xff\x01\x11\x1f\n\r\n\x05\x04\x0e\x02\x15\x01\x12\x04\xff\x01\
    \x20*\n\r\n\x05\x04\x0e\x02\x15\x03\x12\x04\xff\x01-/\n\x0c\n\x04\x04\
    \x0e\x02\x16\x12\x04\x80\x02\x08,\n\r\n\x05\x04\x0e\x02\x16\x04\x12\x04\
    \x80\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x16\x05\x12\x04\x80\x02\x11\x17\n\
    \r\n\x05\x04\x0e\x02\x16\x01\x12\x04\x80\x02\x18&\n\r\n\x05\x04\x0e\x02\
    \x16\x03\x12\x04\x80\x02)+\n\x0c\n\x04\x04\x0e\x02\x17\x12\x04\x81\x02\
    \x08(\n\r\n\x05\x04\x0e\x02\x17\x04\x12\x04\x81\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x17\x05\x12\x04\x81\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x17\
    \x01\x12\x04\x81\x02\x18\"\n\r\n\x05\x04\x0e\x02\x17\x03\x12\x04\x81\x02\
    %'\n\x0c\n\x04\x04\x0e\x02\x18\x12\x04\x82\x02\x08+\n\r\n\x05\x04\x0e\
    \x02\x18\x04\x12\x04\x82\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x18\x06\x12\
    \x04\x82\x02\x11\x1d\n\r\n\x05\x04\x0e\x02\x18\x01\x12\x04\x82\x02\x1e%\
    \n\r\n\x05\x04\x0e\x02\x18\x03\x12\x04\x82\x02(*\n\x0c\n\x04\x04\x0e\x02\
    \x19\x12\x04\x83\x02\x08&\n\r\n\x05\x04\x0e\x02\x19\x04\x12\x04\x83\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x02\x19\x05\x12\x04\x83\x02\x11\x17\n\r\n\x05\
    \x04\x0e\x02\x19\x01\x12\x04\x83\x02\x18\x20\n\r\n\x05\x04\x0e\x02\x19\
    \x03\x12\x04\x83\x02#%\n\x0c\n\x04\x04\x0e\x02\x1a\x12\x04\x84\x02\x08,\
    \n\r\n\x05\x04\x0e\x02\x1a\x04\x12\x04\x84\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02\x1a\x05\x12\x04\x84\x02\x11\x15\n\r\n\x05\x04\x0e\x02\x1a\x01\x12\
    \x04\x84\x02\x16&\n\r\n\x05\x04\x0e\x02\x1a\x03\x12\x04\x84\x02)+\n\x0c\
    \n\x04\x04\x0e\x02\x1b\x12\x04\x85\x02\x08?\n\r\n\x05\x04\x0e\x02\x1b\
    \x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x1b\x06\x12\x04\x85\
    \x02\x11\"\n\r\n\x05\x04\x0e\x02\x1b\x01\x12\x04\x85\x02#9\n\r\n\x05\x04\
    \x0e\x02\x1b\x03\x12\x04\x85\x02<>\n\x0c\n\x04\x04\x0e\x02\x1c\x12\x04\
    \x86\x02\x08D\n\r\n\x05\x04\x0e\x02\x1c\x04\x12\x04\x86\x02\x08\x10\n\r\
    \n\x05\x04\x0e\x02\x1c\x06\x12\x04\x86\x02\x11)\n\r\n\x05\x04\x0e\x02\
    \x1c\x01\x12\x04\x86\x02*>\n\r\n\x05\x04\x0e\x02\x1c\x03\x12\x04\x86\x02\
    AC\n\x0c\n\x04\x04\x0e\x02\x1d\x12\x04\x87\x02\x08&\n\r\n\x05\x04\x0e\
    \x02\x1d\x04\x12\x04\x87\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x1d\x05\x12\
    \x04\x87\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x1d\x01\x12\x04\x87\x02\x18\
    \x20\n\r\n\x05\x04\x0e\x02\x1d\x03\x12\x04\x87\x02#%\n\x0c\n\x04\x04\x0e\
    \x02\x1e\x12\x04\x88\x02\x08&\n\r\n\x05\x04\x0e\x02\x1e\x04\x12\x04\x88\
    \x02\x08\x10\n\r\n\x05\x04\x0e\x02\x1e\x05\x12\x04\x88\x02\x11\x17\n\r\n\
    \x05\x04\x0e\x02\x1e\x01\x12\x04\x88\x02\x18\x20\n\r\n\x05\x04\x0e\x02\
    \x1e\x03\x12\x04\x88\x02#%\n\x0c\n\x04\x04\x0e\x02\x1f\x12\x04\x89\x02\
    \x083\n\r\n\x05\x04\x0e\x02\x1f\x04\x12\x04\x89\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x1f\x05\x12\x04\x89\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x1f\
    \x01\x12\x04\x89\x02\x18-\n\r\n\x05\x04\x0e\x02\x1f\x03\x12\x04\x89\x020\
    2\n\x0c\n\x04\x04\x0e\x02\x20\x12\x04\x8a\x02\x080\n\r\n\x05\x04\x0e\x02\
    \x20\x04\x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x20\x05\x12\x04\
    \x8a\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x20\x01\x12\x04\x8a\x02\x18*\n\r\
    \n\x05\x04\x0e\x02\x20\x03\x12\x04\x8a\x02-/\n\x0c\n\x04\x04\x0e\x02!\
    \x12\x04\x8b\x02\x08*\n\r\n\x05\x04\x0e\x02!\x04\x12\x04\x8b\x02\x08\x10\
    \n\r\n\x05\x04\x0e\x02!\x05\x12\x04\x8b\x02\x11\x17\n\r\n\x05\x04\x0e\
    \x02!\x01\x12\x04\x8b\x02\x18$\n\r\n\x05\x04\x0e\x02!\x03\x12\x04\x8b\
    \x02')\n\x0c\n\x04\x04\x0e\x02\"\x12\x04\x8c\x02\x08)\n\r\n\x05\x04\x0e\
    \x02\"\x04\x12\x04\x8c\x02\x08\x10\n\r\n\x05\x04\x0e\x02\"\x05\x12\x04\
    \x8c\x02\x11\x17\n\r\n\x05\x04\x0e\x02\"\x01\x12\x04\x8c\x02\x18#\n\r\n\
    \x05\x04\x0e\x02\"\x03\x12\x04\x8c\x02&(\n\x0c\n\x04\x04\x0e\x02#\x12\
    \x04\x8d\x02\x081\n\r\n\x05\x04\x0e\x02#\x04\x12\x04\x8d\x02\x08\x10\n\r\
    \n\x05\x04\x0e\x02#\x05\x12\x04\x8d\x02\x11\x17\n\r\n\x05\x04\x0e\x02#\
    \x01\x12\x04\x8d\x02\x18+\n\r\n\x05\x04\x0e\x02#\x03\x12\x04\x8d\x02.0\n\
    \x0c\n\x04\x04\x0e\x02$\x12\x04\x8e\x02\x08.\n\r\n\x05\x04\x0e\x02$\x04\
    \x12\x04\x8e\x02\x08\x10\n\r\n\x05\x04\x0e\x02$\x05\x12\x04\x8e\x02\x11\
    \x17\n\r\n\x05\x04\x0e\x02$\x01\x12\x04\x8e\x02\x18(\n\r\n\x05\x04\x0e\
    \x02$\x03\x12\x04\x8e\x02+-\n\x0c\n\x04\x04\x0e\x02%\x12\x04\x8f\x02\x08\
    ,\n\r\n\x05\x04\x0e\x02%\x04\x12\x04\x8f\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02%\x05\x12\x04\x8f\x02\x11\x17\n\r\n\x05\x04\x0e\x02%\x01\x12\x04\x8f\
    \x02\x18&\n\r\n\x05\x04\x0e\x02%\x03\x12\x04\x8f\x02)+\n\x0c\n\x04\x04\
    \x0e\x02&\x12\x04\x90\x02\x08*\n\r\n\x05\x04\x0e\x02&\x04\x12\x04\x90\
    \x02\x08\x10\n\r\n\x05\x04\x0e\x02&\x05\x12\x04\x90\x02\x11\x17\n\r\n\
    \x05\x04\x0e\x02&\x01\x12\x04\x90\x02\x18$\n\r\n\x05\x04\x0e\x02&\x03\
    \x12\x04\x90\x02')\n\x0c\n\x04\x04\x0e\x02'\x12\x04\x91\x02\x08#\n\r\n\
    \x05\x04\x0e\x02'\x04\x12\x04\x91\x02\x08\x10\n\r\n\x05\x04\x0e\x02'\x05\
    \x12\x04\x91\x02\x11\x15\n\r\n\x05\x04\x0e\x02'\x01\x12\x04\x91\x02\x16\
    \x1d\n\r\n\x05\x04\x0e\x02'\x03\x12\x04\x91\x02\x20\"\n\x0c\n\x04\x04\
    \x0e\x02(\x12\x04\x92\x02\x085\n\r\n\x05\x04\x0e\x02(\x04\x12\x04\x92\
    \x02\x08\x10\n\r\n\x05\x04\x0e\x02(\x06\x12\x04\x92\x02\x11!\n\r\n\x05\
    \x04\x0e\x02(\x01\x12\x04\x92\x02\"/\n\r\n\x05\x04\x0e\x02(\x03\x12\x04\
    \x92\x0224\n\x0c\n\x04\x04\x0e\x02)\x12\x04\x93\x02\x08.\n\r\n\x05\x04\
    \x0e\x02)\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\x0e\x02)\x05\x12\x04\
    \x93\x02\x11\x17\n\r\n\x05\x04\x0e\x02)\x01\x12\x04\x93\x02\x18(\n\r\n\
    \x05\x04\x0e\x02)\x03\x12\x04\x93\x02+-\n\x0c\n\x04\x04\x0e\x02*\x12\x04\
    \x94\x02\x08-\n\r\n\x05\x04\x0e\x02*\x04\x12\x04\x94\x02\x08\x10\n\r\n\
    \x05\x04\x0e\x02*\x05\x12\x04\x94\x02\x11\x17\n\r\n\x05\x04\x0e\x02*\x01\
    \x12\x04\x94\x02\x18'\n\r\n\x05\x04\x0e\x02*\x03\x12\x04\x94\x02*,\n\x0c\
    \n\x04\x04\x0e\x02+\x12\x04\x95\x02\x08/\n\r\n\x05\x04\x0e\x02+\x04\x12\
    \x04\x95\x02\x08\x10\n\r\n\x05\x04\x0e\x02+\x05\x12\x04\x95\x02\x11\x17\
    \n\r\n\x05\x04\x0e\x02+\x01\x12\x04\x95\x02\x18)\n\r\n\x05\x04\x0e\x02+\
    \x03\x12\x04\x95\x02,.\n\x0c\n\x04\x04\x0e\x02,\x12\x04\x96\x02\x08\x1f\
    \n\r\n\x05\x04\x0e\x02,\x04\x12\x04\x96\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02,\x05\x12\x04\x96\x02\x11\x15\n\r\n\x05\x04\x0e\x02,\x01\x12\x04\x96\
    \x02\x16\x19\n\r\n\x05\x04\x0e\x02,\x03\x12\x04\x96\x02\x1c\x1e\n\x0c\n\
    \x04\x04\x0e\x02-\x12\x04\x97\x02\x08H\n\r\n\x05\x04\x0e\x02-\x04\x12\
    \x04\x97\x02\x08\x10\n\r\n\x05\x04\x0e\x02-\x06\x12\x04\x97\x02\x11+\n\r\
    \n\x05\x04\x0e\x02-\x01\x12\x04\x97\x02,B\n\r\n\x05\x04\x0e\x02-\x03\x12\
    \x04\x97\x02EG\n\x0c\n\x04\x04\x0e\x02.\x12\x04\x98\x02\x084\n\r\n\x05\
    \x04\x0e\x02.\x04\x12\x04\x98\x02\x08\x10\n\r\n\x05\x04\x0e\x02.\x05\x12\
    \x04\x98\x02\x11\x17\n\r\n\x05\x04\x0e\x02.\x01\x12\x04\x98\x02\x18.\n\r\
    \n\x05\x04\x0e\x02.\x03\x12\x04\x98\x0213\n\x0c\n\x04\x04\x0e\x02/\x12\
    \x04\x99\x02\x08'\n\r\n\x05\x04\x0e\x02/\x04\x12\x04\x99\x02\x08\x10\n\r\
    \n\x05\x04\x0e\x02/\x05\x12\x04\x99\x02\x11\x17\n\r\n\x05\x04\x0e\x02/\
    \x01\x12\x04\x99\x02\x18!\n\r\n\x05\x04\x0e\x02/\x03\x12\x04\x99\x02$&\n\
    \x0c\n\x04\x04\x0e\x020\x12\x04\x9a\x02\x08(\n\r\n\x05\x04\x0e\x020\x04\
    \x12\x04\x9a\x02\x08\x10\n\r\n\x05\x04\x0e\x020\x05\x12\x04\x9a\x02\x11\
    \x15\n\r\n\x05\x04\x0e\x020\x01\x12\x04\x9a\x02\x16\"\n\r\n\x05\x04\x0e\
    \x020\x03\x12\x04\x9a\x02%'\n\x0c\n\x04\x04\x0e\x021\x12\x04\x9b\x02\x08\
    <\n\r\n\x05\x04\x0e\x021\x04\x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x021\x06\x12\x04\x9b\x02\x11'\n\r\n\x05\x04\x0e\x021\x01\x12\x04\x9b\
    \x02(6\n\r\n\x05\x04\x0e\x021\x03\x12\x04\x9b\x029;\n\x0c\n\x04\x04\x0e\
    \x022\x12\x04\x9c\x02\x08.\n\r\n\x05\x04\x0e\x022\x04\x12\x04\x9c\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x022\x06\x12\x04\x9c\x02\x11\x1e\n\r\n\x05\
    \x04\x0e\x022\x01\x12\x04\x9c\x02\x1f(\n\r\n\x05\x04\x0e\x022\x03\x12\
    \x04\x9c\x02+-\n\x0c\n\x04\x04\x0e\x023\x12\x04\x9d\x02\x080\n\r\n\x05\
    \x04\x0e\x023\x04\x12\x04\x9d\x02\x08\x10\n\r\n\x05\x04\x0e\x023\x05\x12\
    \x04\x9d\x02\x11\x15\n\r\n\x05\x04\x0e\x023\x01\x12\x04\x9d\x02\x16*\n\r\
    \n\x05\x04\x0e\x023\x03\x12\x04\x9d\x02-/\n\x0c\n\x04\x04\x0e\x024\x12\
    \x04\x9e\x02\x082\n\r\n\x05\x04\x0e\x024\x04\x12\x04\x9e\x02\x08\x10\n\r\
    \n\x05\x04\x0e\x024\x06\x12\x04\x9e\x02\x11\x1e\n\r\n\x05\x04\x0e\x024\
    \x01\x12\x04\x9e\x02\x1f,\n\r\n\x05\x04\x0e\x024\x03\x12\x04\x9e\x02/1\n\
    \x0c\n\x04\x04\x0e\x025\x12\x04\x9f\x02\x08+\n\r\n\x05\x04\x0e\x025\x04\
    \x12\x04\x9f\x02\x08\x10\n\r\n\x05\x04\x0e\x025\x05\x12\x04\x9f\x02\x11\
    \x15\n\r\n\x05\x04\x0e\x025\x01\x12\x04\x9f\x02\x16%\n\r\n\x05\x04\x0e\
    \x025\x03\x12\x04\x9f\x02(*\n\x0c\n\x04\x04\x0e\x026\x12\x04\xa0\x02\x08\
    ,\n\r\n\x05\x04\x0e\x026\x04\x12\x04\xa0\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x026\x05\x12\x04\xa0\x02\x11\x17\n\r\n\x05\x04\x0e\x026\x01\x12\x04\xa0\
    \x02\x18&\n\r\n\x05\x04\x0e\x026\x03\x12\x04\xa0\x02)+\n\x0c\n\x04\x04\
    \x0e\x027\x12\x04\xa1\x02\x080\n\r\n\x05\x04\x0e\x027\x04\x12\x04\xa1\
    \x02\x08\x10\n\r\n\x05\x04\x0e\x027\x05\x12\x04\xa1\x02\x11\x17\n\r\n\
    \x05\x04\x0e\x027\x01\x12\x04\xa1\x02\x18*\n\r\n\x05\x04\x0e\x027\x03\
    \x12\x04\xa1\x02-/\n\x0c\n\x04\x04\x0e\x028\x12\x04\xa2\x02\x080\n\r\n\
    \x05\x04\x0e\x028\x04\x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04\x0e\x028\x05\
    \x12\x04\xa2\x02\x11\x17\n\r\n\x05\x04\x0e\x028\x01\x12\x04\xa2\x02\x18*\
    \n\r\n\x05\x04\x0e\x028\x03\x12\x04\xa2\x02-/\n\x0c\n\x04\x04\x0e\x029\
    \x12\x04\xa3\x02\x085\n\r\n\x05\x04\x0e\x029\x04\x12\x04\xa3\x02\x08\x10\
    \n\r\n\x05\x04\x0e\x029\x06\x12\x04\xa3\x02\x11$\n\r\n\x05\x04\x0e\x029\
    \x01\x12\x04\xa3\x02%/\n\r\n\x05\x04\x0e\x029\x03\x12\x04\xa3\x0224\n\
    \x0c\n\x04\x04\x0e\x02:\x12\x04\xa4\x02\x08.\n\r\n\x05\x04\x0e\x02:\x04\
    \x12\x04\xa4\x02\x08\x10\n\r\n\x05\x04\x0e\x02:\x05\x12\x04\xa4\x02\x11\
    \x18\n\r\n\x05\x04\x0e\x02:\x01\x12\x04\xa4\x02\x19(\n\r\n\x05\x04\x0e\
    \x02:\x03\x12\x04\xa4\x02+-\n\x0c\n\x04\x04\x0e\x02;\x12\x04\xa5\x02\x08\
    :\n\r\n\x05\x04\x0e\x02;\x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02;\x05\x12\x04\xa5\x02\x11\x15\n\r\n\x05\x04\x0e\x02;\x01\x12\x04\xa5\
    \x02\x164\n\r\n\x05\x04\x0e\x02;\x03\x12\x04\xa5\x0279\n\x0c\n\x04\x04\
    \x0e\x02<\x12\x04\xa6\x02\x084\n\r\n\x05\x04\x0e\x02<\x04\x12\x04\xa6\
    \x02\x08\x10\n\r\n\x05\x04\x0e\x02<\x05\x12\x04\xa6\x02\x11\x18\n\r\n\
    \x05\x04\x0e\x02<\x01\x12\x04\xa6\x02\x19.\n\r\n\x05\x04\x0e\x02<\x03\
    \x12\x04\xa6\x0213\n\x0c\n\x04\x04\x0e\x02=\x12\x04\xa7\x02\x085\n\r\n\
    \x05\x04\x0e\x02=\x04\x12\x04\xa7\x02\x08\x10\n\r\n\x05\x04\x0e\x02=\x05\
    \x12\x04\xa7\x02\x11\x17\n\r\n\x05\x04\x0e\x02=\x01\x12\x04\xa7\x02\x18/\
    \n\r\n\x05\x04\x0e\x02=\x03\x12\x04\xa7\x0224\n\x0c\n\x04\x04\x0e\x02>\
    \x12\x04\xa8\x02\x085\n\r\n\x05\x04\x0e\x02>\x04\x12\x04\xa8\x02\x08\x10\
    \n\r\n\x05\x04\x0e\x02>\x05\x12\x04\xa8\x02\x11\x17\n\r\n\x05\x04\x0e\
    \x02>\x01\x12\x04\xa8\x02\x18/\n\r\n\x05\x04\x0e\x02>\x03\x12\x04\xa8\
    \x0224\n\x0c\n\x04\x04\x0e\x02?\x12\x04\xa9\x02\x08-\n\r\n\x05\x04\x0e\
    \x02?\x04\x12\x04\xa9\x02\x08\x10\n\r\n\x05\x04\x0e\x02?\x05\x12\x04\xa9\
    \x02\x11\x17\n\r\n\x05\x04\x0e\x02?\x01\x12\x04\xa9\x02\x18'\n\r\n\x05\
    \x04\x0e\x02?\x03\x12\x04\xa9\x02*,\n\x0c\n\x04\x04\x0e\x02@\x12\x04\xaa\
    \x02\x08:\n\r\n\x05\x04\x0e\x02@\x04\x12\x04\xaa\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02@\x06\x12\x04\xaa\x02\x11&\n\r\n\x05\x04\x0e\x02@\x01\x12\
    \x04\xaa\x02'4\n\r\n\x05\x04\x0e\x02@\x03\x12\x04\xaa\x0279\n\x0c\n\x04\
    \x04\x0e\x02A\x12\x04\xab\x02\x089\n\r\n\x05\x04\x0e\x02A\x04\x12\x04\
    \xab\x02\x08\x10\n\r\n\x05\x04\x0e\x02A\x05\x12\x04\xab\x02\x11\x17\n\r\
    \n\x05\x04\x0e\x02A\x01\x12\x04\xab\x02\x183\n\r\n\x05\x04\x0e\x02A\x03\
    \x12\x04\xab\x0268\n\x0c\n\x04\x04\x0e\x02B\x12\x04\xac\x02\x089\n\r\n\
    \x05\x04\x0e\x02B\x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04\x0e\x02B\x05\
    \x12\x04\xac\x02\x11\x17\n\r\n\x05\x04\x0e\x02B\x01\x12\x04\xac\x02\x183\
    \n\r\n\x05\x04\x0e\x02B\x03\x12\x04\xac\x0268\n\x0c\n\x04\x04\x0e\x02C\
    \x12\x04\xad\x02\x08;\n\r\n\x05\x04\x0e\x02C\x04\x12\x04\xad\x02\x08\x10\
    \n\r\n\x05\x04\x0e\x02C\x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04\x0e\
    \x02C\x01\x12\x04\xad\x02\x185\n\r\n\x05\x04\x0e\x02C\x03\x12\x04\xad\
    \x028:\n\x0c\n\x04\x04\x0e\x02D\x12\x04\xae\x02\x08<\n\r\n\x05\x04\x0e\
    \x02D\x04\x12\x04\xae\x02\x08\x10\n\r\n\x05\x04\x0e\x02D\x06\x12\x04\xae\
    \x02\x11\"\n\r\n\x05\x04\x0e\x02D\x01\x12\x04\xae\x02#6\n\r\n\x05\x04\
    \x0e\x02D\x03\x12\x04\xae\x029;\n\x0c\n\x04\x04\x0e\x02E\x12\x04\xaf\x02\
    \x08)\n\r\n\x05\x04\x0e\x02E\x04\x12\x04\xaf\x02\x08\x10\n\r\n\x05\x04\
    \x0e\x02E\x05\x12\x04\xaf\x02\x11\x17\n\r\n\x05\x04\x0e\x02E\x01\x12\x04\
    \xaf\x02\x18#\n\r\n\x05\x04\x0e\x02E\x03\x12\x04\xaf\x02&(\n\x0c\n\x04\
    \x04\x0e\x02F\x12\x04\xb0\x02\x08&\n\r\n\x05\x04\x0e\x02F\x04\x12\x04\
    \xb0\x02\x08\x10\n\r\n\x05\x04\x0e\x02F\x05\x12\x04\xb0\x02\x11\x17\n\r\
    \n\x05\x04\x0e\x02F\x01\x12\x04\xb0\x02\x18\x20\n\r\n\x05\x04\x0e\x02F\
    \x03\x12\x04\xb0\x02#%\n\x0c\n\x04\x04\x0e\x02G\x12\x04\xb1\x02\x087\n\r\
    \n\x05\x04\x0e\x02G\x04\x12\x04\xb1\x02\x08\x10\n\r\n\x05\x04\x0e\x02G\
    \x06\x12\x04\xb1\x02\x11\x17\n\r\n\x05\x04\x0e\x02G\x01\x12\x04\xb1\x02\
    \x181\n\r\n\x05\x04\x0e\x02G\x03\x12\x04\xb1\x0246\n\x0c\n\x04\x04\x0e\
    \x02H\x12\x04\xb2\x02\x08J\n\r\n\x05\x04\x0e\x02H\x04\x12\x04\xb2\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x02H\x06\x12\x04\xb2\x02\x11+\n\r\n\x05\x04\
    \x0e\x02H\x01\x12\x04\xb2\x02,D\n\r\n\x05\x04\x0e\x02H\x03\x12\x04\xb2\
    \x02GI\n\x0c\n\x04\x04\x0e\x02I\x12\x04\xb3\x02\x08H\n\r\n\x05\x04\x0e\
    \x02I\x04\x12\x04\xb3\x02\x08\x10\n\r\n\x05\x04\x0e\x02I\x05\x12\x04\xb3\
    \x02\x11\x17\n\r\n\x05\x04\x0e\x02I\x01\x12\x04\xb3\x02\x18B\n\r\n\x05\
    \x04\x0e\x02I\x03\x12\x04\xb3\x02EG\n\x0c\n\x04\x04\x0e\x02J\x12\x04\xb4\
    \x02\x08G\n\r\n\x05\x04\x0e\x02J\x04\x12\x04\xb4\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02J\x05\x12\x04\xb4\x02\x11\x17\n\r\n\x05\x04\x0e\x02J\x01\x12\
    \x04\xb4\x02\x18A\n\r\n\x05\x04\x0e\x02J\x03\x12\x04\xb4\x02DF\n\x0c\n\
    \x04\x04\x0e\x02K\x12\x04\xb5\x02\x08W\n\r\n\x05\x04\x0e\x02K\x04\x12\
    \x04\xb5\x02\x08\x10\n\r\n\x05\x04\x0e\x02K\x06\x12\x04\xb5\x02\x11,\n\r\
    \n\x05\x04\x0e\x02K\x01\x12\x04\xb5\x02-P\n\r\n\x05\x04\x0e\x02K\x03\x12\
    \x04\xb5\x02SV\n\x0c\n\x04\x04\x0e\x02L\x12\x04\xb6\x02\x08[\n\r\n\x05\
    \x04\x0e\x02L\x04\x12\x04\xb6\x02\x08\x10\n\r\n\x05\x04\x0e\x02L\x06\x12\
    \x04\xb6\x02\x11,\n\r\n\x05\x04\x0e\x02L\x01\x12\x04\xb6\x02-T\n\r\n\x05\
    \x04\x0e\x02L\x03\x12\x04\xb6\x02WZ\n\x0c\n\x04\x04\x0e\x02M\x12\x04\xb7\
    \x02\x08M\n\r\n\x05\x04\x0e\x02M\x04\x12\x04\xb7\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02M\x05\x12\x04\xb7\x02\x11\x15\n\r\n\x05\x04\x0e\x02M\x01\x12\
    \x04\xb7\x02\x16F\n\r\n\x05\x04\x0e\x02M\x03\x12\x04\xb7\x02IL\n\x0c\n\
    \x04\x04\x0e\x02N\x12\x04\xb8\x02\x084\n\r\n\x05\x04\x0e\x02N\x04\x12\
    \x04\xb8\x02\x08\x10\n\r\n\x05\x04\x0e\x02N\x06\x12\x04\xb8\x02\x11\x17\
    \n\r\n\x05\x04\x0e\x02N\x01\x12\x04\xb8\x02\x18-\n\r\n\x05\x04\x0e\x02N\
    \x03\x12\x04\xb8\x0203\n\x0c\n\x04\x04\x0e\x02O\x12\x04\xb9\x02\x08:\n\r\
    \n\x05\x04\x0e\x02O\x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04\x0e\x02O\
    \x05\x12\x04\xb9\x02\x11\x17\n\r\n\x05\x04\x0e\x02O\x01\x12\x04\xb9\x02\
    \x183\n\r\n\x05\x04\x0e\x02O\x03\x12\x04\xb9\x0269\n\x0c\n\x04\x04\x0e\
    \x02P\x12\x04\xba\x02\x087\n\r\n\x05\x04\x0e\x02P\x04\x12\x04\xba\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x02P\x05\x12\x04\xba\x02\x11\x18\n\r\n\x05\
    \x04\x0e\x02P\x01\x12\x04\xba\x02\x190\n\r\n\x05\x04\x0e\x02P\x03\x12\
    \x04\xba\x0236\n\x0c\n\x04\x04\x0e\x02Q\x12\x04\xbb\x02\x082\n\r\n\x05\
    \x04\x0e\x02Q\x04\x12\x04\xbb\x02\x08\x10\n\r\n\x05\x04\x0e\x02Q\x05\x12\
    \x04\xbb\x02\x11\x15\n\r\n\x05\x04\x0e\x02Q\x01\x12\x04\xbb\x02\x16+\n\r\
    \n\x05\x04\x0e\x02Q\x03\x12\x04\xbb\x02.1\n\x0c\n\x04\x04\x0e\x02R\x12\
    \x04\xbc\x02\x085\n\r\n\x05\x04\x0e\x02R\x04\x12\x04\xbc\x02\x08\x10\n\r\
    \n\x05\x04\x0e\x02R\x05\x12\x04\xbc\x02\x11\x17\n\r\n\x05\x04\x0e\x02R\
    \x01\x12\x04\xbc\x02\x18.\n\r\n\x05\x04\x0e\x02R\x03\x12\x04\xbc\x0214\n\
    \x0c\n\x04\x04\x0e\x02S\x12\x04\xbd\x02\x08-\n\r\n\x05\x04\x0e\x02S\x04\
    \x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04\x0e\x02S\x05\x12\x04\xbd\x02\x11\
    \x17\n\r\n\x05\x04\x0e\x02S\x01\x12\x04\xbd\x02\x18&\n\r\n\x05\x04\x0e\
    \x02S\x03\x12\x04\xbd\x02),\n\x0c\n\x04\x04\x0e\x02T\x12\x04\xbe\x02\x08\
    -\n\r\n\x05\x04\x0e\x02T\x04\x12\x04\xbe\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02T\x05\x12\x04\xbe\x02\x11\x17\n\r\n\x05\x04\x0e\x02T\x01\x12\x04\xbe\
    \x02\x18&\n\r\n\x05\x04\x0e\x02T\x03\x12\x04\xbe\x02),\n\x0c\n\x04\x04\
    \x0e\x02U\x12\x04\xbf\x02\x08+\n\r\n\x05\x04\x0e\x02U\x04\x12\x04\xbf\
    \x02\x08\x10\n\r\n\x05\x04\x0e\x02U\x05\x12\x04\xbf\x02\x11\x17\n\r\n\
    \x05\x04\x0e\x02U\x01\x12\x04\xbf\x02\x18$\n\r\n\x05\x04\x0e\x02U\x03\
    \x12\x04\xbf\x02'*\n\x0c\n\x04\x04\x0e\x02V\x12\x04\xc0\x02\x082\n\r\n\
    \x05\x04\x0e\x02V\x04\x12\x04\xc0\x02\x08\x10\n\r\n\x05\x04\x0e\x02V\x05\
    \x12\x04\xc0\x02\x11\x15\n\r\n\x05\x04\x0e\x02V\x01\x12\x04\xc0\x02\x16+\
    \n\r\n\x05\x04\x0e\x02V\x03\x12\x04\xc0\x02.1\n\x0c\n\x04\x04\x0e\x02W\
    \x12\x04\xc1\x02\x08:\n\r\n\x05\x04\x0e\x02W\x04\x12\x04\xc1\x02\x08\x10\
    \n\r\n\x05\x04\x0e\x02W\x05\x12\x04\xc1\x02\x11\x15\n\r\n\x05\x04\x0e\
    \x02W\x01\x12\x04\xc1\x02\x163\n\r\n\x05\x04\x0e\x02W\x03\x12\x04\xc1\
    \x0269\n\x0c\n\x04\x04\x0e\x02X\x12\x04\xc2\x02\x08=\n\r\n\x05\x04\x0e\
    \x02X\x04\x12\x04\xc2\x02\x08\x10\n\r\n\x05\x04\x0e\x02X\x06\x12\x04\xc2\
    \x02\x11%\n\r\n\x05\x04\x0e\x02X\x01\x12\x04\xc2\x02&6\n\r\n\x05\x04\x0e\
    \x02X\x03\x12\x04\xc2\x029<\n\x0c\n\x04\x04\x0e\x02Y\x12\x04\xc3\x02\x08\
    8\n\r\n\x05\x04\x0e\x02Y\x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02Y\x06\x12\x04\xc3\x02\x11#\n\r\n\x05\x04\x0e\x02Y\x01\x12\x04\xc3\
    \x02$1\n\r\n\x05\x04\x0e\x02Y\x03\x12\x04\xc3\x0247\n\x0c\n\x04\x04\x0e\
    \x02Z\x12\x04\xc4\x02\x08?\n\r\n\x05\x04\x0e\x02Z\x04\x12\x04\xc4\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x02Z\x06\x12\x04\xc4\x02\x11%\n\r\n\x05\x04\
    \x0e\x02Z\x01\x12\x04\xc4\x02&8\n\r\n\x05\x04\x0e\x02Z\x03\x12\x04\xc4\
    \x02;>\n\x0c\n\x04\x04\x0e\x02[\x12\x04\xc5\x02\x081\n\r\n\x05\x04\x0e\
    \x02[\x04\x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04\x0e\x02[\x05\x12\x04\xc5\
    \x02\x11\x17\n\r\n\x05\x04\x0e\x02[\x01\x12\x04\xc5\x02\x18*\n\r\n\x05\
    \x04\x0e\x02[\x03\x12\x04\xc5\x02-0\n\x0c\n\x04\x04\x0e\x02\\\x12\x04\
    \xc6\x02\x08I\n\r\n\x05\x04\x0e\x02\\\x04\x12\x04\xc6\x02\x08\x10\n\r\n\
    \x05\x04\x0e\x02\\\x06\x12\x04\xc6\x02\x11,\n\r\n\x05\x04\x0e\x02\\\x01\
    \x12\x04\xc6\x02-B\n\r\n\x05\x04\x0e\x02\\\x03\x12\x04\xc6\x02EH\n\x0c\n\
    \x04\x04\x0e\x02]\x12\x04\xc7\x02\x08.\n\r\n\x05\x04\x0e\x02]\x04\x12\
    \x04\xc7\x02\x08\x10\n\r\n\x05\x04\x0e\x02]\x05\x12\x04\xc7\x02\x11\x15\
    \n\r\n\x05\x04\x0e\x02]\x01\x12\x04\xc7\x02\x16'\n\r\n\x05\x04\x0e\x02]\
    \x03\x12\x04\xc7\x02*-\n\x0c\n\x04\x04\x0e\x02^\x12\x04\xc8\x02\x08/\n\r\
    \n\x05\x04\x0e\x02^\x04\x12\x04\xc8\x02\x08\x10\n\r\n\x05\x04\x0e\x02^\
    \x05\x12\x04\xc8\x02\x11\x15\n\r\n\x05\x04\x0e\x02^\x01\x12\x04\xc8\x02\
    \x16(\n\r\n\x05\x04\x0e\x02^\x03\x12\x04\xc8\x02+.\n\x0c\n\x04\x04\x0e\
    \x02_\x12\x04\xc9\x02\x082\n\r\n\x05\x04\x0e\x02_\x04\x12\x04\xc9\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x02_\x05\x12\x04\xc9\x02\x11\x17\n\r\n\x05\
    \x04\x0e\x02_\x01\x12\x04\xc9\x02\x18+\n\r\n\x05\x04\x0e\x02_\x03\x12\
    \x04\xc9\x02.1\n\x0c\n\x04\x04\x0e\x02`\x12\x04\xca\x02\x084\n\r\n\x05\
    \x04\x0e\x02`\x04\x12\x04\xca\x02\x08\x10\n\r\n\x05\x04\x0e\x02`\x05\x12\
    \x04\xca\x02\x11\x17\n\r\n\x05\x04\x0e\x02`\x01\x12\x04\xca\x02\x18-\n\r\
    \n\x05\x04\x0e\x02`\x03\x12\x04\xca\x0203\n\x0c\n\x04\x04\x0e\x02a\x12\
    \x04\xcb\x02\x08E\n\r\n\x05\x04\x0e\x02a\x04\x12\x04\xcb\x02\x08\x10\n\r\
    \n\x05\x04\x0e\x02a\x06\x12\x04\xcb\x02\x11'\n\r\n\x05\x04\x0e\x02a\x01\
    \x12\x04\xcb\x02(>\n\r\n\x05\x04\x0e\x02a\x03\x12\x04\xcb\x02AD\n\x0c\n\
    \x02\x04\x0f\x12\x06\xce\x02\0\xd0\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\xce\x02\x08\x1a\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xcf\x02\x08:\n\r\
    \n\x05\x04\x0f\x02\0\x04\x12\x04\xcf\x02\x08\x10\n\r\n\x05\x04\x0f\x02\0\
    \x06\x12\x04\xcf\x02\x11)\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xcf\x02*5\
    \n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xcf\x0289\n\x0c\n\x02\x04\x10\x12\
    \x06\xd2\x02\0\xd5\x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xd2\x02\x08\
    \x1a\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xd3\x02\x08:\n\r\n\x05\x04\x10\
    \x02\0\x04\x12\x04\xd3\x02\x08\x10\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\
    \xd3\x02\x11)\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xd3\x02*5\n\r\n\x05\
    \x04\x10\x02\0\x03\x12\x04\xd3\x0289\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\
    \xd4\x02\x08*\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xd4\x02\x08\x10\n\r\
    \n\x05\x04\x10\x02\x01\x05\x12\x04\xd4\x02\x11\x15\n\r\n\x05\x04\x10\x02\
    \x01\x01\x12\x04\xd4\x02\x16%\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xd4\
    \x02()\n\x0c\n\x02\x04\x11\x12\x06\xd7\x02\0\xd9\x02\x01\n\x0b\n\x03\x04\
    \x11\x01\x12\x04\xd7\x02\x08\x20\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xd8\
    \x02\x08@\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\
    \x04\x11\x02\0\x06\x12\x04\xd8\x02\x11/\n\r\n\x05\x04\x11\x02\0\x01\x12\
    \x04\xd8\x020;\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xd8\x02>?\n\x0c\n\x02\
    \x04\x12\x12\x06\xdb\x02\0\xea\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\
    \xdb\x02\x08-\n\x0e\n\x04\x04\x12\x03\0\x12\x06\xdc\x02\x08\xdf\x02\t\n\
    \r\n\x05\x04\x12\x03\0\x01\x12\x04\xdc\x02\x10%\n\x0e\n\x06\x04\x12\x03\
    \0\x02\0\x12\x04\xdd\x02\x105\n\x0f\n\x07\x04\x12\x03\0\x02\0\x04\x12\
    \x04\xdd\x02\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\0\x05\x12\x04\xdd\x02\
    \x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\0\x01\x12\x04\xdd\x02\x200\n\x0f\
    \n\x07\x04\x12\x03\0\x02\0\x03\x12\x04\xdd\x0234\n\x0e\n\x06\x04\x12\x03\
    \0\x02\x01\x12\x04\xde\x02\x103\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x04\
    \x12\x04\xde\x02\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x05\x12\x04\
    \xde\x02\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x01\x12\x04\xde\x02\
    \x20.\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x03\x12\x04\xde\x0212\n\x0e\n\
    \x04\x04\x12\x03\x01\x12\x06\xe1\x02\x08\xe4\x02\t\n\r\n\x05\x04\x12\x03\
    \x01\x01\x12\x04\xe1\x02\x10%\n\x0e\n\x06\x04\x12\x03\x01\x02\0\x12\x04\
    \xe2\x02\x105\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x04\x12\x04\xe2\x02\x10\
    \x18\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x05\x12\x04\xe2\x02\x19\x1f\n\x0f\
    \n\x07\x04\x12\x03\x01\x02\0\x01\x12\x04\xe2\x02\x200\n\x0f\n\x07\x04\
    \x12\x03\x01\x02\0\x03\x12\x04\xe2\x0234\n\x0e\n\x06\x04\x12\x03\x01\x02\
    \x01\x12\x04\xe3\x02\x103\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x04\x12\
    \x04\xe3\x02\x10\x18\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x05\x12\x04\xe3\
    \x02\x19\x1f\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x01\x12\x04\xe3\x02\x20\
    .\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x03\x12\x04\xe3\x0212\n\x0c\n\x04\
    \x04\x12\x02\0\x12\x04\xe6\x02\x08'\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\
    \xe6\x02\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xe6\x02\x11\x17\n\r\
    \n\x05\x04\x12\x02\0\x01\x12\x04\xe6\x02\x18\"\n\r\n\x05\x04\x12\x02\0\
    \x03\x12\x04\xe6\x02%&\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xe7\x02\x08C\
    \n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xe7\x02\x08\x10\n\r\n\x05\x04\x12\
    \x02\x01\x06\x12\x04\xe7\x02\x114\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\
    \xe7\x025>\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xe7\x02AB\n\x0c\n\x04\
    \x04\x12\x02\x02\x12\x04\xe8\x02\x08t\n\r\n\x05\x04\x12\x02\x02\x04\x12\
    \x04\xe8\x02\x08\x10\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\xe8\x02\x11L\
    \n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xe8\x02Mo\n\r\n\x05\x04\x12\x02\
    \x02\x03\x12\x04\xe8\x02rs\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xe9\x02\
    \x08t\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\
    \x04\x12\x02\x03\x06\x12\x04\xe9\x02\x11L\n\r\n\x05\x04\x12\x02\x03\x01\
    \x12\x04\xe9\x02Mo\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xe9\x02rs\n\x0c\
    \n\x02\x04\x13\x12\x06\xec\x02\0\xed\x02\x01\n\x0b\n\x03\x04\x13\x01\x12\
    \x04\xec\x02\x08'\n\x0c\n\x02\x04\x14\x12\x06\xef\x02\0\xf1\x02\x01\n\
    \x0b\n\x03\x04\x14\x01\x12\x04\xef\x02\x08\x20\n\x0c\n\x04\x04\x14\x02\0\
    \x12\x04\xf0\x02\x08!\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xf0\x02\x08\
    \x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xf0\x02\x11\x17\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\xf0\x02\x18\x1c\n\r\n\x05\x04\x14\x02\0\x03\x12\
    \x04\xf0\x02\x1f\x20\n\x0c\n\x02\x04\x15\x12\x06\xf3\x02\0\xfd\x02\x01\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xf3\x02\x08\x20\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\xf4\x02\x08%\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xf4\x02\x08\
    \x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xf4\x02\x11\x17\n\r\n\x05\x04\
    \x15\x02\0\x01\x12\x04\xf4\x02\x18\x20\n\r\n\x05\x04\x15\x02\0\x03\x12\
    \x04\xf4\x02#$\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xf5\x02\x08%\n\r\n\
    \x05\x04\x15\x02\x01\x04\x12\x04\xf5\x02\x08\x10\n\r\n\x05\x04\x15\x02\
    \x01\x06\x12\x04\xf5\x02\x11\x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\
    \xf5\x02\x18\x20\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xf5\x02#$\n\x0c\n\
    \x04\x04\x15\x02\x02\x12\x04\xf6\x02\x08)\n\r\n\x05\x04\x15\x02\x02\x04\
    \x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xf6\x02\
    \x11\x17\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xf6\x02\x18$\n\r\n\x05\
    \x04\x15\x02\x02\x03\x12\x04\xf6\x02'(\n\x0c\n\x04\x04\x15\x02\x03\x12\
    \x04\xf7\x02\x08'\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\xf7\x02\x08\x10\
    \n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xf7\x02\x11\x17\n\r\n\x05\x04\x15\
    \x02\x03\x01\x12\x04\xf7\x02\x18\"\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\
    \xf7\x02%&\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\xf8\x02\x080\n\r\n\x05\
    \x04\x15\x02\x04\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x04\x15\x02\x04\
    \x05\x12\x04\xf8\x02\x11\x17\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\xf8\
    \x02\x18+\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\xf8\x02./\n\x0c\n\x04\
    \x04\x15\x02\x05\x12\x04\xf9\x02\x082\n\r\n\x05\x04\x15\x02\x05\x04\x12\
    \x04\xf9\x02\x08\x10\n\r\n\x05\x04\x15\x02\x05\x05\x12\x04\xf9\x02\x11\
    \x17\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\xf9\x02\x18-\n\r\n\x05\x04\
    \x15\x02\x05\x03\x12\x04\xf9\x0201\n\x0c\n\x04\x04\x15\x02\x06\x12\x04\
    \xfa\x02\x08*\n\r\n\x05\x04\x15\x02\x06\x04\x12\x04\xfa\x02\x08\x10\n\r\
    \n\x05\x04\x15\x02\x06\x05\x12\x04\xfa\x02\x11\x17\n\r\n\x05\x04\x15\x02\
    \x06\x01\x12\x04\xfa\x02\x18%\n\r\n\x05\x04\x15\x02\x06\x03\x12\x04\xfa\
    \x02()\n\x0c\n\x04\x04\x15\x02\x07\x12\x04\xfb\x02\x08(\n\r\n\x05\x04\
    \x15\x02\x07\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\x04\x15\x02\x07\x05\
    \x12\x04\xfb\x02\x11\x17\n\r\n\x05\x04\x15\x02\x07\x01\x12\x04\xfb\x02\
    \x18#\n\r\n\x05\x04\x15\x02\x07\x03\x12\x04\xfb\x02&'\n\x0c\n\x04\x04\
    \x15\x02\x08\x12\x04\xfc\x02\x084\n\r\n\x05\x04\x15\x02\x08\x04\x12\x04\
    \xfc\x02\x08\x10\n\r\n\x05\x04\x15\x02\x08\x05\x12\x04\xfc\x02\x11\x17\n\
    \r\n\x05\x04\x15\x02\x08\x01\x12\x04\xfc\x02\x18/\n\r\n\x05\x04\x15\x02\
    \x08\x03\x12\x04\xfc\x0223\n\x0c\n\x02\x04\x16\x12\x06\xff\x02\0\x89\x03\
    \x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xff\x02\x08$\n\x0c\n\x04\x04\x16\
    \x02\0\x12\x04\x80\x03\x08'\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\x80\x03\
    \x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x80\x03\x11\x17\n\r\n\x05\
    \x04\x16\x02\0\x01\x12\x04\x80\x03\x18\"\n\r\n\x05\x04\x16\x02\0\x03\x12\
    \x04\x80\x03%&\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x81\x03\x087\n\r\n\
    \x05\x04\x16\x02\x01\x04\x12\x04\x81\x03\x08\x10\n\r\n\x05\x04\x16\x02\
    \x01\x06\x12\x04\x81\x03\x11%\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x81\
    \x03&2\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x81\x0356\n\x0c\n\x04\x04\
    \x16\x02\x02\x12\x04\x82\x03\x08-\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\
    \x82\x03\x08\x10\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\x82\x03\x11\x15\n\
    \r\n\x05\x04\x16\x02\x02\x01\x12\x04\x82\x03\x16(\n\r\n\x05\x04\x16\x02\
    \x02\x03\x12\x04\x82\x03+,\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\x83\x03\
    \x08-\n\r\n\x05\x04\x16\x02\x03\x04\x12\x04\x83\x03\x08\x10\n\r\n\x05\
    \x04\x16\x02\x03\x05\x12\x04\x83\x03\x11\x17\n\r\n\x05\x04\x16\x02\x03\
    \x01\x12\x04\x83\x03\x18(\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\x83\x03+\
    ,\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\x84\x03\x08*\n\r\n\x05\x04\x16\x02\
    \x04\x04\x12\x04\x84\x03\x08\x10\n\r\n\x05\x04\x16\x02\x04\x05\x12\x04\
    \x84\x03\x11\x17\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\x84\x03\x18%\n\r\
    \n\x05\x04\x16\x02\x04\x03\x12\x04\x84\x03()\n\x0c\n\x04\x04\x16\x02\x05\
    \x12\x04\x85\x03\x082\n\r\n\x05\x04\x16\x02\x05\x04\x12\x04\x85\x03\x08\
    \x10\n\r\n\x05\x04\x16\x02\x05\x05\x12\x04\x85\x03\x11\x17\n\r\n\x05\x04\
    \x16\x02\x05\x01\x12\x04\x85\x03\x18-\n\r\n\x05\x04\x16\x02\x05\x03\x12\
    \x04\x85\x0301\n\x0c\n\x04\x04\x16\x02\x06\x12\x04\x86\x03\x089\n\r\n\
    \x05\x04\x16\x02\x06\x04\x12\x04\x86\x03\x08\x10\n\r\n\x05\x04\x16\x02\
    \x06\x06\x12\x04\x86\x03\x11)\n\r\n\x05\x04\x16\x02\x06\x01\x12\x04\x86\
    \x03*4\n\r\n\x05\x04\x16\x02\x06\x03\x12\x04\x86\x0378\n\x0c\n\x04\x04\
    \x16\x02\x07\x12\x04\x87\x03\x08.\n\r\n\x05\x04\x16\x02\x07\x04\x12\x04\
    \x87\x03\x08\x10\n\r\n\x05\x04\x16\x02\x07\x05\x12\x04\x87\x03\x11\x17\n\
    \r\n\x05\x04\x16\x02\x07\x01\x12\x04\x87\x03\x18)\n\r\n\x05\x04\x16\x02\
    \x07\x03\x12\x04\x87\x03,-\n\x0c\n\x04\x04\x16\x02\x08\x12\x04\x88\x03\
    \x08K\n\r\n\x05\x04\x16\x02\x08\x04\x12\x04\x88\x03\x08\x10\n\r\n\x05\
    \x04\x16\x02\x08\x06\x12\x04\x88\x03\x116\n\r\n\x05\x04\x16\x02\x08\x01\
    \x12\x04\x88\x037F\n\r\n\x05\x04\x16\x02\x08\x03\x12\x04\x88\x03IJ\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(31);
            messages.push(CMsgLobbyCoachFriendRequest::generated_message_descriptor_data());
            messages.push(CMsgLobbyPlayerPlusSubscriptionData::generated_message_descriptor_data());
            messages.push(CMsgLobbyEventPoints::generated_message_descriptor_data());
            messages.push(CMsgLobbyEventGameData::generated_message_descriptor_data());
            messages.push(CSODOTALobbyInvite::generated_message_descriptor_data());
            messages.push(CSODOTALobbyMember::generated_message_descriptor_data());
            messages.push(CSODOTAServerLobbyMember::generated_message_descriptor_data());
            messages.push(CSODOTAStaticLobbyMember::generated_message_descriptor_data());
            messages.push(CSODOTAServerStaticLobbyMember::generated_message_descriptor_data());
            messages.push(CLobbyTeamDetails::generated_message_descriptor_data());
            messages.push(CLobbyGuildDetails::generated_message_descriptor_data());
            messages.push(CLobbyTimedRewardDetails::generated_message_descriptor_data());
            messages.push(CLobbyBroadcastChannelInfo::generated_message_descriptor_data());
            messages.push(CLobbyGuildChallenge::generated_message_descriptor_data());
            messages.push(CSODOTALobby::generated_message_descriptor_data());
            messages.push(CSODOTAServerLobby::generated_message_descriptor_data());
            messages.push(CSODOTAStaticLobby::generated_message_descriptor_data());
            messages.push(CSODOTAServerStaticLobby::generated_message_descriptor_data());
            messages.push(CMsgAdditionalLobbyStartupAccountData::generated_message_descriptor_data());
            messages.push(CMsgLobbyInitializationComplete::generated_message_descriptor_data());
            messages.push(CMsgLobbyPlaytestDetails::generated_message_descriptor_data());
            messages.push(CMsgLocalServerGuildData::generated_message_descriptor_data());
            messages.push(CMsgLocalServerFakeLobbyData::generated_message_descriptor_data());
            messages.push(cmsg_lobby_player_plus_subscription_data::HeroBadge::generated_message_descriptor_data());
            messages.push(cmsg_lobby_event_points::PeriodicResourceData::generated_message_descriptor_data());
            messages.push(cmsg_lobby_event_points::NetworkedEventAction::generated_message_descriptor_data());
            messages.push(cmsg_lobby_event_points::AccountPoints::generated_message_descriptor_data());
            messages.push(csodotalobby_invite::LobbyMember::generated_message_descriptor_data());
            messages.push(csodotalobby::CExtraMsg::generated_message_descriptor_data());
            messages.push(cmsg_additional_lobby_startup_account_data::ChatWheelMessageRange::generated_message_descriptor_data());
            messages.push(cmsg_additional_lobby_startup_account_data::PingWheelMessageRange::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(ELobbyMemberCoachRequestState::generated_enum_descriptor_data());
            enums.push(LobbyDotaTVDelay::generated_enum_descriptor_data());
            enums.push(LobbyDotaPauseSetting::generated_enum_descriptor_data());
            enums.push(csodotalobby::State::generated_enum_descriptor_data());
            enums.push(csodotalobby::LobbyType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
