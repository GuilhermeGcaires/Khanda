// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_common.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CSODOTAGameAccountClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAGameAccountClient {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.wins)
    pub wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.losses)
    pub losses: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.xp)
    pub xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.level)
    pub level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.initial_skill)
    pub initial_skill: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.leaver_count)
    pub leaver_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.secondary_leaver_count)
    pub secondary_leaver_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.low_priority_until_date)
    pub low_priority_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.prevent_text_chat_until_date)
    pub prevent_text_chat_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.prevent_voice_until_date)
    pub prevent_voice_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.prevent_public_text_chat_until_date)
    pub prevent_public_text_chat_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.prevent_new_player_chat_until_date)
    pub prevent_new_player_chat_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.last_abandoned_game_date)
    pub last_abandoned_game_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.last_secondary_abandoned_game_date)
    pub last_secondary_abandoned_game_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.leaver_penalty_count)
    pub leaver_penalty_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.completed_game_streak)
    pub completed_game_streak: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.account_disabled_until_date)
    pub account_disabled_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.account_disabled_count)
    pub account_disabled_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.match_disabled_until_date)
    pub match_disabled_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.match_disabled_count)
    pub match_disabled_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.shutdownlawterminatetimestamp)
    pub shutdownlawterminatetimestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.low_priority_games_remaining)
    pub low_priority_games_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.recruitment_level)
    pub recruitment_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.has_new_notifications)
    pub has_new_notifications: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.is_league_admin)
    pub is_league_admin: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.casual_games_played)
    pub casual_games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.solo_competitive_games_played)
    pub solo_competitive_games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.party_competitive_games_played)
    pub party_competitive_games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.casual_1v1_games_played)
    pub casual_1v1_games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.curr_all_hero_challenge_id)
    pub curr_all_hero_challenge_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.play_time_points)
    pub play_time_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.account_flags)
    pub account_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.play_time_level)
    pub play_time_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.player_behavior_seq_num_last_report)
    pub player_behavior_seq_num_last_report: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.player_behavior_score_last_report)
    pub player_behavior_score_last_report: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.player_behavior_report_old_data)
    pub player_behavior_report_old_data: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.tourney_skill_level)
    pub tourney_skill_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.tourney_recent_participation_date)
    pub tourney_recent_participation_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.anchored_phone_number_id)
    pub anchored_phone_number_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.ranked_matchmaking_ban_until_date)
    pub ranked_matchmaking_ban_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.recent_game_time_1)
    pub recent_game_time_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.recent_game_time_2)
    pub recent_game_time_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.recent_game_time_3)
    pub recent_game_time_3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.favorite_team_packed)
    pub favorite_team_packed: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.recent_report_time)
    pub recent_report_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.custom_game_disabled_until_date)
    pub custom_game_disabled_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.recent_win_time_1)
    pub recent_win_time_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.recent_win_time_2)
    pub recent_win_time_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.recent_win_time_3)
    pub recent_win_time_3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.coach_rating)
    pub coach_rating: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.queue_points)
    pub queue_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.role_handicaps)
    pub role_handicaps: ::std::vec::Vec<csodotagame_account_client::RoleHandicap>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.event_mode_recent_time)
    pub event_mode_recent_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.mmr_recalibration_time)
    pub mmr_recalibration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAGameAccountClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAGameAccountClient {
    fn default() -> &'a CSODOTAGameAccountClient {
        <CSODOTAGameAccountClient as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAGameAccountClient {
    pub fn new() -> CSODOTAGameAccountClient {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 wins = 3;

    pub fn wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    // optional uint32 losses = 4;

    pub fn losses(&self) -> u32 {
        self.losses.unwrap_or(0)
    }

    pub fn clear_losses(&mut self) {
        self.losses = ::std::option::Option::None;
    }

    pub fn has_losses(&self) -> bool {
        self.losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losses(&mut self, v: u32) {
        self.losses = ::std::option::Option::Some(v);
    }

    // optional uint32 xp = 12;

    pub fn xp(&self) -> u32 {
        self.xp.unwrap_or(0)
    }

    pub fn clear_xp(&mut self) {
        self.xp = ::std::option::Option::None;
    }

    pub fn has_xp(&self) -> bool {
        self.xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp(&mut self, v: u32) {
        self.xp = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 13;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_skill = 14;

    pub fn initial_skill(&self) -> u32 {
        self.initial_skill.unwrap_or(0)
    }

    pub fn clear_initial_skill(&mut self) {
        self.initial_skill = ::std::option::Option::None;
    }

    pub fn has_initial_skill(&self) -> bool {
        self.initial_skill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_skill(&mut self, v: u32) {
        self.initial_skill = ::std::option::Option::Some(v);
    }

    // optional uint32 leaver_count = 15;

    pub fn leaver_count(&self) -> u32 {
        self.leaver_count.unwrap_or(0)
    }

    pub fn clear_leaver_count(&mut self) {
        self.leaver_count = ::std::option::Option::None;
    }

    pub fn has_leaver_count(&self) -> bool {
        self.leaver_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_count(&mut self, v: u32) {
        self.leaver_count = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary_leaver_count = 58;

    pub fn secondary_leaver_count(&self) -> u32 {
        self.secondary_leaver_count.unwrap_or(0)
    }

    pub fn clear_secondary_leaver_count(&mut self) {
        self.secondary_leaver_count = ::std::option::Option::None;
    }

    pub fn has_secondary_leaver_count(&self) -> bool {
        self.secondary_leaver_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_leaver_count(&mut self, v: u32) {
        self.secondary_leaver_count = ::std::option::Option::Some(v);
    }

    // optional uint32 low_priority_until_date = 18;

    pub fn low_priority_until_date(&self) -> u32 {
        self.low_priority_until_date.unwrap_or(0)
    }

    pub fn clear_low_priority_until_date(&mut self) {
        self.low_priority_until_date = ::std::option::Option::None;
    }

    pub fn has_low_priority_until_date(&self) -> bool {
        self.low_priority_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority_until_date(&mut self, v: u32) {
        self.low_priority_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 prevent_text_chat_until_date = 20;

    pub fn prevent_text_chat_until_date(&self) -> u32 {
        self.prevent_text_chat_until_date.unwrap_or(0)
    }

    pub fn clear_prevent_text_chat_until_date(&mut self) {
        self.prevent_text_chat_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_text_chat_until_date(&self) -> bool {
        self.prevent_text_chat_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_text_chat_until_date(&mut self, v: u32) {
        self.prevent_text_chat_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 prevent_voice_until_date = 21;

    pub fn prevent_voice_until_date(&self) -> u32 {
        self.prevent_voice_until_date.unwrap_or(0)
    }

    pub fn clear_prevent_voice_until_date(&mut self) {
        self.prevent_voice_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_voice_until_date(&self) -> bool {
        self.prevent_voice_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_voice_until_date(&mut self, v: u32) {
        self.prevent_voice_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 prevent_public_text_chat_until_date = 86;

    pub fn prevent_public_text_chat_until_date(&self) -> u32 {
        self.prevent_public_text_chat_until_date.unwrap_or(0)
    }

    pub fn clear_prevent_public_text_chat_until_date(&mut self) {
        self.prevent_public_text_chat_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_public_text_chat_until_date(&self) -> bool {
        self.prevent_public_text_chat_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_public_text_chat_until_date(&mut self, v: u32) {
        self.prevent_public_text_chat_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 prevent_new_player_chat_until_date = 122;

    pub fn prevent_new_player_chat_until_date(&self) -> u32 {
        self.prevent_new_player_chat_until_date.unwrap_or(0)
    }

    pub fn clear_prevent_new_player_chat_until_date(&mut self) {
        self.prevent_new_player_chat_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_new_player_chat_until_date(&self) -> bool {
        self.prevent_new_player_chat_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_new_player_chat_until_date(&mut self, v: u32) {
        self.prevent_new_player_chat_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 last_abandoned_game_date = 22;

    pub fn last_abandoned_game_date(&self) -> u32 {
        self.last_abandoned_game_date.unwrap_or(0)
    }

    pub fn clear_last_abandoned_game_date(&mut self) {
        self.last_abandoned_game_date = ::std::option::Option::None;
    }

    pub fn has_last_abandoned_game_date(&self) -> bool {
        self.last_abandoned_game_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_abandoned_game_date(&mut self, v: u32) {
        self.last_abandoned_game_date = ::std::option::Option::Some(v);
    }

    // optional uint32 last_secondary_abandoned_game_date = 59;

    pub fn last_secondary_abandoned_game_date(&self) -> u32 {
        self.last_secondary_abandoned_game_date.unwrap_or(0)
    }

    pub fn clear_last_secondary_abandoned_game_date(&mut self) {
        self.last_secondary_abandoned_game_date = ::std::option::Option::None;
    }

    pub fn has_last_secondary_abandoned_game_date(&self) -> bool {
        self.last_secondary_abandoned_game_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_secondary_abandoned_game_date(&mut self, v: u32) {
        self.last_secondary_abandoned_game_date = ::std::option::Option::Some(v);
    }

    // optional uint32 leaver_penalty_count = 23;

    pub fn leaver_penalty_count(&self) -> u32 {
        self.leaver_penalty_count.unwrap_or(0)
    }

    pub fn clear_leaver_penalty_count(&mut self) {
        self.leaver_penalty_count = ::std::option::Option::None;
    }

    pub fn has_leaver_penalty_count(&self) -> bool {
        self.leaver_penalty_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_penalty_count(&mut self, v: u32) {
        self.leaver_penalty_count = ::std::option::Option::Some(v);
    }

    // optional uint32 completed_game_streak = 24;

    pub fn completed_game_streak(&self) -> u32 {
        self.completed_game_streak.unwrap_or(0)
    }

    pub fn clear_completed_game_streak(&mut self) {
        self.completed_game_streak = ::std::option::Option::None;
    }

    pub fn has_completed_game_streak(&self) -> bool {
        self.completed_game_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_game_streak(&mut self, v: u32) {
        self.completed_game_streak = ::std::option::Option::Some(v);
    }

    // optional uint32 account_disabled_until_date = 38;

    pub fn account_disabled_until_date(&self) -> u32 {
        self.account_disabled_until_date.unwrap_or(0)
    }

    pub fn clear_account_disabled_until_date(&mut self) {
        self.account_disabled_until_date = ::std::option::Option::None;
    }

    pub fn has_account_disabled_until_date(&self) -> bool {
        self.account_disabled_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_disabled_until_date(&mut self, v: u32) {
        self.account_disabled_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 account_disabled_count = 39;

    pub fn account_disabled_count(&self) -> u32 {
        self.account_disabled_count.unwrap_or(0)
    }

    pub fn clear_account_disabled_count(&mut self) {
        self.account_disabled_count = ::std::option::Option::None;
    }

    pub fn has_account_disabled_count(&self) -> bool {
        self.account_disabled_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_disabled_count(&mut self, v: u32) {
        self.account_disabled_count = ::std::option::Option::Some(v);
    }

    // optional uint32 match_disabled_until_date = 41;

    pub fn match_disabled_until_date(&self) -> u32 {
        self.match_disabled_until_date.unwrap_or(0)
    }

    pub fn clear_match_disabled_until_date(&mut self) {
        self.match_disabled_until_date = ::std::option::Option::None;
    }

    pub fn has_match_disabled_until_date(&self) -> bool {
        self.match_disabled_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_disabled_until_date(&mut self, v: u32) {
        self.match_disabled_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 match_disabled_count = 42;

    pub fn match_disabled_count(&self) -> u32 {
        self.match_disabled_count.unwrap_or(0)
    }

    pub fn clear_match_disabled_count(&mut self) {
        self.match_disabled_count = ::std::option::Option::None;
    }

    pub fn has_match_disabled_count(&self) -> bool {
        self.match_disabled_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_disabled_count(&mut self, v: u32) {
        self.match_disabled_count = ::std::option::Option::Some(v);
    }

    // optional uint32 shutdownlawterminatetimestamp = 47;

    pub fn shutdownlawterminatetimestamp(&self) -> u32 {
        self.shutdownlawterminatetimestamp.unwrap_or(0)
    }

    pub fn clear_shutdownlawterminatetimestamp(&mut self) {
        self.shutdownlawterminatetimestamp = ::std::option::Option::None;
    }

    pub fn has_shutdownlawterminatetimestamp(&self) -> bool {
        self.shutdownlawterminatetimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shutdownlawterminatetimestamp(&mut self, v: u32) {
        self.shutdownlawterminatetimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 low_priority_games_remaining = 48;

    pub fn low_priority_games_remaining(&self) -> u32 {
        self.low_priority_games_remaining.unwrap_or(0)
    }

    pub fn clear_low_priority_games_remaining(&mut self) {
        self.low_priority_games_remaining = ::std::option::Option::None;
    }

    pub fn has_low_priority_games_remaining(&self) -> bool {
        self.low_priority_games_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority_games_remaining(&mut self, v: u32) {
        self.low_priority_games_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 recruitment_level = 55;

    pub fn recruitment_level(&self) -> u32 {
        self.recruitment_level.unwrap_or(0)
    }

    pub fn clear_recruitment_level(&mut self) {
        self.recruitment_level = ::std::option::Option::None;
    }

    pub fn has_recruitment_level(&self) -> bool {
        self.recruitment_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recruitment_level(&mut self, v: u32) {
        self.recruitment_level = ::std::option::Option::Some(v);
    }

    // optional bool has_new_notifications = 56;

    pub fn has_new_notifications(&self) -> bool {
        self.has_new_notifications.unwrap_or(false)
    }

    pub fn clear_has_new_notifications(&mut self) {
        self.has_new_notifications = ::std::option::Option::None;
    }

    pub fn has_has_new_notifications(&self) -> bool {
        self.has_new_notifications.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_new_notifications(&mut self, v: bool) {
        self.has_new_notifications = ::std::option::Option::Some(v);
    }

    // optional bool is_league_admin = 57;

    pub fn is_league_admin(&self) -> bool {
        self.is_league_admin.unwrap_or(false)
    }

    pub fn clear_is_league_admin(&mut self) {
        self.is_league_admin = ::std::option::Option::None;
    }

    pub fn has_is_league_admin(&self) -> bool {
        self.is_league_admin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_league_admin(&mut self, v: bool) {
        self.is_league_admin = ::std::option::Option::Some(v);
    }

    // optional uint32 casual_games_played = 60;

    pub fn casual_games_played(&self) -> u32 {
        self.casual_games_played.unwrap_or(0)
    }

    pub fn clear_casual_games_played(&mut self) {
        self.casual_games_played = ::std::option::Option::None;
    }

    pub fn has_casual_games_played(&self) -> bool {
        self.casual_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_games_played(&mut self, v: u32) {
        self.casual_games_played = ::std::option::Option::Some(v);
    }

    // optional uint32 solo_competitive_games_played = 61;

    pub fn solo_competitive_games_played(&self) -> u32 {
        self.solo_competitive_games_played.unwrap_or(0)
    }

    pub fn clear_solo_competitive_games_played(&mut self) {
        self.solo_competitive_games_played = ::std::option::Option::None;
    }

    pub fn has_solo_competitive_games_played(&self) -> bool {
        self.solo_competitive_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_competitive_games_played(&mut self, v: u32) {
        self.solo_competitive_games_played = ::std::option::Option::Some(v);
    }

    // optional uint32 party_competitive_games_played = 62;

    pub fn party_competitive_games_played(&self) -> u32 {
        self.party_competitive_games_played.unwrap_or(0)
    }

    pub fn clear_party_competitive_games_played(&mut self) {
        self.party_competitive_games_played = ::std::option::Option::None;
    }

    pub fn has_party_competitive_games_played(&self) -> bool {
        self.party_competitive_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_competitive_games_played(&mut self, v: u32) {
        self.party_competitive_games_played = ::std::option::Option::Some(v);
    }

    // optional uint32 casual_1v1_games_played = 65;

    pub fn casual_1v1_games_played(&self) -> u32 {
        self.casual_1v1_games_played.unwrap_or(0)
    }

    pub fn clear_casual_1v1_games_played(&mut self) {
        self.casual_1v1_games_played = ::std::option::Option::None;
    }

    pub fn has_casual_1v1_games_played(&self) -> bool {
        self.casual_1v1_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_1v1_games_played(&mut self, v: u32) {
        self.casual_1v1_games_played = ::std::option::Option::Some(v);
    }

    // optional uint32 curr_all_hero_challenge_id = 67;

    pub fn curr_all_hero_challenge_id(&self) -> u32 {
        self.curr_all_hero_challenge_id.unwrap_or(0)
    }

    pub fn clear_curr_all_hero_challenge_id(&mut self) {
        self.curr_all_hero_challenge_id = ::std::option::Option::None;
    }

    pub fn has_curr_all_hero_challenge_id(&self) -> bool {
        self.curr_all_hero_challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_all_hero_challenge_id(&mut self, v: u32) {
        self.curr_all_hero_challenge_id = ::std::option::Option::Some(v);
    }

    // optional uint32 play_time_points = 68;

    pub fn play_time_points(&self) -> u32 {
        self.play_time_points.unwrap_or(0)
    }

    pub fn clear_play_time_points(&mut self) {
        self.play_time_points = ::std::option::Option::None;
    }

    pub fn has_play_time_points(&self) -> bool {
        self.play_time_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_time_points(&mut self, v: u32) {
        self.play_time_points = ::std::option::Option::Some(v);
    }

    // optional uint32 account_flags = 69;

    pub fn account_flags(&self) -> u32 {
        self.account_flags.unwrap_or(0)
    }

    pub fn clear_account_flags(&mut self) {
        self.account_flags = ::std::option::Option::None;
    }

    pub fn has_account_flags(&self) -> bool {
        self.account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_flags(&mut self, v: u32) {
        self.account_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 play_time_level = 70;

    pub fn play_time_level(&self) -> u32 {
        self.play_time_level.unwrap_or(0)
    }

    pub fn clear_play_time_level(&mut self) {
        self.play_time_level = ::std::option::Option::None;
    }

    pub fn has_play_time_level(&self) -> bool {
        self.play_time_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_time_level(&mut self, v: u32) {
        self.play_time_level = ::std::option::Option::Some(v);
    }

    // optional uint32 player_behavior_seq_num_last_report = 71;

    pub fn player_behavior_seq_num_last_report(&self) -> u32 {
        self.player_behavior_seq_num_last_report.unwrap_or(0)
    }

    pub fn clear_player_behavior_seq_num_last_report(&mut self) {
        self.player_behavior_seq_num_last_report = ::std::option::Option::None;
    }

    pub fn has_player_behavior_seq_num_last_report(&self) -> bool {
        self.player_behavior_seq_num_last_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_behavior_seq_num_last_report(&mut self, v: u32) {
        self.player_behavior_seq_num_last_report = ::std::option::Option::Some(v);
    }

    // optional uint32 player_behavior_score_last_report = 72;

    pub fn player_behavior_score_last_report(&self) -> u32 {
        self.player_behavior_score_last_report.unwrap_or(0)
    }

    pub fn clear_player_behavior_score_last_report(&mut self) {
        self.player_behavior_score_last_report = ::std::option::Option::None;
    }

    pub fn has_player_behavior_score_last_report(&self) -> bool {
        self.player_behavior_score_last_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_behavior_score_last_report(&mut self, v: u32) {
        self.player_behavior_score_last_report = ::std::option::Option::Some(v);
    }

    // optional bool player_behavior_report_old_data = 73;

    pub fn player_behavior_report_old_data(&self) -> bool {
        self.player_behavior_report_old_data.unwrap_or(false)
    }

    pub fn clear_player_behavior_report_old_data(&mut self) {
        self.player_behavior_report_old_data = ::std::option::Option::None;
    }

    pub fn has_player_behavior_report_old_data(&self) -> bool {
        self.player_behavior_report_old_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_behavior_report_old_data(&mut self, v: bool) {
        self.player_behavior_report_old_data = ::std::option::Option::Some(v);
    }

    // optional uint32 tourney_skill_level = 74;

    pub fn tourney_skill_level(&self) -> u32 {
        self.tourney_skill_level.unwrap_or(0)
    }

    pub fn clear_tourney_skill_level(&mut self) {
        self.tourney_skill_level = ::std::option::Option::None;
    }

    pub fn has_tourney_skill_level(&self) -> bool {
        self.tourney_skill_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_skill_level(&mut self, v: u32) {
        self.tourney_skill_level = ::std::option::Option::Some(v);
    }

    // optional uint32 tourney_recent_participation_date = 85;

    pub fn tourney_recent_participation_date(&self) -> u32 {
        self.tourney_recent_participation_date.unwrap_or(0)
    }

    pub fn clear_tourney_recent_participation_date(&mut self) {
        self.tourney_recent_participation_date = ::std::option::Option::None;
    }

    pub fn has_tourney_recent_participation_date(&self) -> bool {
        self.tourney_recent_participation_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_recent_participation_date(&mut self, v: u32) {
        self.tourney_recent_participation_date = ::std::option::Option::Some(v);
    }

    // optional uint64 anchored_phone_number_id = 88;

    pub fn anchored_phone_number_id(&self) -> u64 {
        self.anchored_phone_number_id.unwrap_or(0)
    }

    pub fn clear_anchored_phone_number_id(&mut self) {
        self.anchored_phone_number_id = ::std::option::Option::None;
    }

    pub fn has_anchored_phone_number_id(&self) -> bool {
        self.anchored_phone_number_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anchored_phone_number_id(&mut self, v: u64) {
        self.anchored_phone_number_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ranked_matchmaking_ban_until_date = 89;

    pub fn ranked_matchmaking_ban_until_date(&self) -> u32 {
        self.ranked_matchmaking_ban_until_date.unwrap_or(0)
    }

    pub fn clear_ranked_matchmaking_ban_until_date(&mut self) {
        self.ranked_matchmaking_ban_until_date = ::std::option::Option::None;
    }

    pub fn has_ranked_matchmaking_ban_until_date(&self) -> bool {
        self.ranked_matchmaking_ban_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_matchmaking_ban_until_date(&mut self, v: u32) {
        self.ranked_matchmaking_ban_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_game_time_1 = 90;

    pub fn recent_game_time_1(&self) -> u32 {
        self.recent_game_time_1.unwrap_or(0)
    }

    pub fn clear_recent_game_time_1(&mut self) {
        self.recent_game_time_1 = ::std::option::Option::None;
    }

    pub fn has_recent_game_time_1(&self) -> bool {
        self.recent_game_time_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_game_time_1(&mut self, v: u32) {
        self.recent_game_time_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_game_time_2 = 91;

    pub fn recent_game_time_2(&self) -> u32 {
        self.recent_game_time_2.unwrap_or(0)
    }

    pub fn clear_recent_game_time_2(&mut self) {
        self.recent_game_time_2 = ::std::option::Option::None;
    }

    pub fn has_recent_game_time_2(&self) -> bool {
        self.recent_game_time_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_game_time_2(&mut self, v: u32) {
        self.recent_game_time_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_game_time_3 = 92;

    pub fn recent_game_time_3(&self) -> u32 {
        self.recent_game_time_3.unwrap_or(0)
    }

    pub fn clear_recent_game_time_3(&mut self) {
        self.recent_game_time_3 = ::std::option::Option::None;
    }

    pub fn has_recent_game_time_3(&self) -> bool {
        self.recent_game_time_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_game_time_3(&mut self, v: u32) {
        self.recent_game_time_3 = ::std::option::Option::Some(v);
    }

    // optional uint64 favorite_team_packed = 103;

    pub fn favorite_team_packed(&self) -> u64 {
        self.favorite_team_packed.unwrap_or(0)
    }

    pub fn clear_favorite_team_packed(&mut self) {
        self.favorite_team_packed = ::std::option::Option::None;
    }

    pub fn has_favorite_team_packed(&self) -> bool {
        self.favorite_team_packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_packed(&mut self, v: u64) {
        self.favorite_team_packed = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_report_time = 104;

    pub fn recent_report_time(&self) -> u32 {
        self.recent_report_time.unwrap_or(0)
    }

    pub fn clear_recent_report_time(&mut self) {
        self.recent_report_time = ::std::option::Option::None;
    }

    pub fn has_recent_report_time(&self) -> bool {
        self.recent_report_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_report_time(&mut self, v: u32) {
        self.recent_report_time = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_game_disabled_until_date = 105;

    pub fn custom_game_disabled_until_date(&self) -> u32 {
        self.custom_game_disabled_until_date.unwrap_or(0)
    }

    pub fn clear_custom_game_disabled_until_date(&mut self) {
        self.custom_game_disabled_until_date = ::std::option::Option::None;
    }

    pub fn has_custom_game_disabled_until_date(&self) -> bool {
        self.custom_game_disabled_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_disabled_until_date(&mut self, v: u32) {
        self.custom_game_disabled_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_win_time_1 = 106;

    pub fn recent_win_time_1(&self) -> u32 {
        self.recent_win_time_1.unwrap_or(0)
    }

    pub fn clear_recent_win_time_1(&mut self) {
        self.recent_win_time_1 = ::std::option::Option::None;
    }

    pub fn has_recent_win_time_1(&self) -> bool {
        self.recent_win_time_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_win_time_1(&mut self, v: u32) {
        self.recent_win_time_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_win_time_2 = 107;

    pub fn recent_win_time_2(&self) -> u32 {
        self.recent_win_time_2.unwrap_or(0)
    }

    pub fn clear_recent_win_time_2(&mut self) {
        self.recent_win_time_2 = ::std::option::Option::None;
    }

    pub fn has_recent_win_time_2(&self) -> bool {
        self.recent_win_time_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_win_time_2(&mut self, v: u32) {
        self.recent_win_time_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_win_time_3 = 108;

    pub fn recent_win_time_3(&self) -> u32 {
        self.recent_win_time_3.unwrap_or(0)
    }

    pub fn clear_recent_win_time_3(&mut self) {
        self.recent_win_time_3 = ::std::option::Option::None;
    }

    pub fn has_recent_win_time_3(&self) -> bool {
        self.recent_win_time_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_win_time_3(&mut self, v: u32) {
        self.recent_win_time_3 = ::std::option::Option::Some(v);
    }

    // optional uint32 coach_rating = 109;

    pub fn coach_rating(&self) -> u32 {
        self.coach_rating.unwrap_or(0)
    }

    pub fn clear_coach_rating(&mut self) {
        self.coach_rating = ::std::option::Option::None;
    }

    pub fn has_coach_rating(&self) -> bool {
        self.coach_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_rating(&mut self, v: u32) {
        self.coach_rating = ::std::option::Option::Some(v);
    }

    // optional uint32 queue_points = 114;

    pub fn queue_points(&self) -> u32 {
        self.queue_points.unwrap_or(0)
    }

    pub fn clear_queue_points(&mut self) {
        self.queue_points = ::std::option::Option::None;
    }

    pub fn has_queue_points(&self) -> bool {
        self.queue_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_points(&mut self, v: u32) {
        self.queue_points = ::std::option::Option::Some(v);
    }

    // optional uint32 event_mode_recent_time = 120;

    pub fn event_mode_recent_time(&self) -> u32 {
        self.event_mode_recent_time.unwrap_or(0)
    }

    pub fn clear_event_mode_recent_time(&mut self) {
        self.event_mode_recent_time = ::std::option::Option::None;
    }

    pub fn has_event_mode_recent_time(&self) -> bool {
        self.event_mode_recent_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_mode_recent_time(&mut self, v: u32) {
        self.event_mode_recent_time = ::std::option::Option::Some(v);
    }

    // optional uint32 mmr_recalibration_time = 121;

    pub fn mmr_recalibration_time(&self) -> u32 {
        self.mmr_recalibration_time.unwrap_or(0)
    }

    pub fn clear_mmr_recalibration_time(&mut self) {
        self.mmr_recalibration_time = ::std::option::Option::None;
    }

    pub fn has_mmr_recalibration_time(&self) -> bool {
        self.mmr_recalibration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr_recalibration_time(&mut self, v: u32) {
        self.mmr_recalibration_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(55);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSODOTAGameAccountClient| { &m.account_id },
            |m: &mut CSODOTAGameAccountClient| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wins",
            |m: &CSODOTAGameAccountClient| { &m.wins },
            |m: &mut CSODOTAGameAccountClient| { &mut m.wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "losses",
            |m: &CSODOTAGameAccountClient| { &m.losses },
            |m: &mut CSODOTAGameAccountClient| { &mut m.losses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xp",
            |m: &CSODOTAGameAccountClient| { &m.xp },
            |m: &mut CSODOTAGameAccountClient| { &mut m.xp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level",
            |m: &CSODOTAGameAccountClient| { &m.level },
            |m: &mut CSODOTAGameAccountClient| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_skill",
            |m: &CSODOTAGameAccountClient| { &m.initial_skill },
            |m: &mut CSODOTAGameAccountClient| { &mut m.initial_skill },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaver_count",
            |m: &CSODOTAGameAccountClient| { &m.leaver_count },
            |m: &mut CSODOTAGameAccountClient| { &mut m.leaver_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secondary_leaver_count",
            |m: &CSODOTAGameAccountClient| { &m.secondary_leaver_count },
            |m: &mut CSODOTAGameAccountClient| { &mut m.secondary_leaver_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_priority_until_date",
            |m: &CSODOTAGameAccountClient| { &m.low_priority_until_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.low_priority_until_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prevent_text_chat_until_date",
            |m: &CSODOTAGameAccountClient| { &m.prevent_text_chat_until_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.prevent_text_chat_until_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prevent_voice_until_date",
            |m: &CSODOTAGameAccountClient| { &m.prevent_voice_until_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.prevent_voice_until_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prevent_public_text_chat_until_date",
            |m: &CSODOTAGameAccountClient| { &m.prevent_public_text_chat_until_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.prevent_public_text_chat_until_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prevent_new_player_chat_until_date",
            |m: &CSODOTAGameAccountClient| { &m.prevent_new_player_chat_until_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.prevent_new_player_chat_until_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_abandoned_game_date",
            |m: &CSODOTAGameAccountClient| { &m.last_abandoned_game_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.last_abandoned_game_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_secondary_abandoned_game_date",
            |m: &CSODOTAGameAccountClient| { &m.last_secondary_abandoned_game_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.last_secondary_abandoned_game_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaver_penalty_count",
            |m: &CSODOTAGameAccountClient| { &m.leaver_penalty_count },
            |m: &mut CSODOTAGameAccountClient| { &mut m.leaver_penalty_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "completed_game_streak",
            |m: &CSODOTAGameAccountClient| { &m.completed_game_streak },
            |m: &mut CSODOTAGameAccountClient| { &mut m.completed_game_streak },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_disabled_until_date",
            |m: &CSODOTAGameAccountClient| { &m.account_disabled_until_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.account_disabled_until_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_disabled_count",
            |m: &CSODOTAGameAccountClient| { &m.account_disabled_count },
            |m: &mut CSODOTAGameAccountClient| { &mut m.account_disabled_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_disabled_until_date",
            |m: &CSODOTAGameAccountClient| { &m.match_disabled_until_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.match_disabled_until_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_disabled_count",
            |m: &CSODOTAGameAccountClient| { &m.match_disabled_count },
            |m: &mut CSODOTAGameAccountClient| { &mut m.match_disabled_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shutdownlawterminatetimestamp",
            |m: &CSODOTAGameAccountClient| { &m.shutdownlawterminatetimestamp },
            |m: &mut CSODOTAGameAccountClient| { &mut m.shutdownlawterminatetimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_priority_games_remaining",
            |m: &CSODOTAGameAccountClient| { &m.low_priority_games_remaining },
            |m: &mut CSODOTAGameAccountClient| { &mut m.low_priority_games_remaining },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recruitment_level",
            |m: &CSODOTAGameAccountClient| { &m.recruitment_level },
            |m: &mut CSODOTAGameAccountClient| { &mut m.recruitment_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_new_notifications",
            |m: &CSODOTAGameAccountClient| { &m.has_new_notifications },
            |m: &mut CSODOTAGameAccountClient| { &mut m.has_new_notifications },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_league_admin",
            |m: &CSODOTAGameAccountClient| { &m.is_league_admin },
            |m: &mut CSODOTAGameAccountClient| { &mut m.is_league_admin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "casual_games_played",
            |m: &CSODOTAGameAccountClient| { &m.casual_games_played },
            |m: &mut CSODOTAGameAccountClient| { &mut m.casual_games_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "solo_competitive_games_played",
            |m: &CSODOTAGameAccountClient| { &m.solo_competitive_games_played },
            |m: &mut CSODOTAGameAccountClient| { &mut m.solo_competitive_games_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_competitive_games_played",
            |m: &CSODOTAGameAccountClient| { &m.party_competitive_games_played },
            |m: &mut CSODOTAGameAccountClient| { &mut m.party_competitive_games_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "casual_1v1_games_played",
            |m: &CSODOTAGameAccountClient| { &m.casual_1v1_games_played },
            |m: &mut CSODOTAGameAccountClient| { &mut m.casual_1v1_games_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "curr_all_hero_challenge_id",
            |m: &CSODOTAGameAccountClient| { &m.curr_all_hero_challenge_id },
            |m: &mut CSODOTAGameAccountClient| { &mut m.curr_all_hero_challenge_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "play_time_points",
            |m: &CSODOTAGameAccountClient| { &m.play_time_points },
            |m: &mut CSODOTAGameAccountClient| { &mut m.play_time_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_flags",
            |m: &CSODOTAGameAccountClient| { &m.account_flags },
            |m: &mut CSODOTAGameAccountClient| { &mut m.account_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "play_time_level",
            |m: &CSODOTAGameAccountClient| { &m.play_time_level },
            |m: &mut CSODOTAGameAccountClient| { &mut m.play_time_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_behavior_seq_num_last_report",
            |m: &CSODOTAGameAccountClient| { &m.player_behavior_seq_num_last_report },
            |m: &mut CSODOTAGameAccountClient| { &mut m.player_behavior_seq_num_last_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_behavior_score_last_report",
            |m: &CSODOTAGameAccountClient| { &m.player_behavior_score_last_report },
            |m: &mut CSODOTAGameAccountClient| { &mut m.player_behavior_score_last_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_behavior_report_old_data",
            |m: &CSODOTAGameAccountClient| { &m.player_behavior_report_old_data },
            |m: &mut CSODOTAGameAccountClient| { &mut m.player_behavior_report_old_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tourney_skill_level",
            |m: &CSODOTAGameAccountClient| { &m.tourney_skill_level },
            |m: &mut CSODOTAGameAccountClient| { &mut m.tourney_skill_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tourney_recent_participation_date",
            |m: &CSODOTAGameAccountClient| { &m.tourney_recent_participation_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.tourney_recent_participation_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "anchored_phone_number_id",
            |m: &CSODOTAGameAccountClient| { &m.anchored_phone_number_id },
            |m: &mut CSODOTAGameAccountClient| { &mut m.anchored_phone_number_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ranked_matchmaking_ban_until_date",
            |m: &CSODOTAGameAccountClient| { &m.ranked_matchmaking_ban_until_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.ranked_matchmaking_ban_until_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_game_time_1",
            |m: &CSODOTAGameAccountClient| { &m.recent_game_time_1 },
            |m: &mut CSODOTAGameAccountClient| { &mut m.recent_game_time_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_game_time_2",
            |m: &CSODOTAGameAccountClient| { &m.recent_game_time_2 },
            |m: &mut CSODOTAGameAccountClient| { &mut m.recent_game_time_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_game_time_3",
            |m: &CSODOTAGameAccountClient| { &m.recent_game_time_3 },
            |m: &mut CSODOTAGameAccountClient| { &mut m.recent_game_time_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "favorite_team_packed",
            |m: &CSODOTAGameAccountClient| { &m.favorite_team_packed },
            |m: &mut CSODOTAGameAccountClient| { &mut m.favorite_team_packed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_report_time",
            |m: &CSODOTAGameAccountClient| { &m.recent_report_time },
            |m: &mut CSODOTAGameAccountClient| { &mut m.recent_report_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_game_disabled_until_date",
            |m: &CSODOTAGameAccountClient| { &m.custom_game_disabled_until_date },
            |m: &mut CSODOTAGameAccountClient| { &mut m.custom_game_disabled_until_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_win_time_1",
            |m: &CSODOTAGameAccountClient| { &m.recent_win_time_1 },
            |m: &mut CSODOTAGameAccountClient| { &mut m.recent_win_time_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_win_time_2",
            |m: &CSODOTAGameAccountClient| { &m.recent_win_time_2 },
            |m: &mut CSODOTAGameAccountClient| { &mut m.recent_win_time_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_win_time_3",
            |m: &CSODOTAGameAccountClient| { &m.recent_win_time_3 },
            |m: &mut CSODOTAGameAccountClient| { &mut m.recent_win_time_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coach_rating",
            |m: &CSODOTAGameAccountClient| { &m.coach_rating },
            |m: &mut CSODOTAGameAccountClient| { &mut m.coach_rating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_points",
            |m: &CSODOTAGameAccountClient| { &m.queue_points },
            |m: &mut CSODOTAGameAccountClient| { &mut m.queue_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_handicaps",
            |m: &CSODOTAGameAccountClient| { &m.role_handicaps },
            |m: &mut CSODOTAGameAccountClient| { &mut m.role_handicaps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_mode_recent_time",
            |m: &CSODOTAGameAccountClient| { &m.event_mode_recent_time },
            |m: &mut CSODOTAGameAccountClient| { &mut m.event_mode_recent_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mmr_recalibration_time",
            |m: &CSODOTAGameAccountClient| { &m.mmr_recalibration_time },
            |m: &mut CSODOTAGameAccountClient| { &mut m.mmr_recalibration_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAGameAccountClient>(
            "CSODOTAGameAccountClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAGameAccountClient {
    const NAME: &'static str = "CSODOTAGameAccountClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.losses = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.initial_skill = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.leaver_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                464 => {
                    self.secondary_leaver_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.low_priority_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.prevent_text_chat_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.prevent_voice_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                688 => {
                    self.prevent_public_text_chat_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                976 => {
                    self.prevent_new_player_chat_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.last_abandoned_game_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                472 => {
                    self.last_secondary_abandoned_game_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.leaver_penalty_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.completed_game_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                304 => {
                    self.account_disabled_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.account_disabled_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                328 => {
                    self.match_disabled_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                336 => {
                    self.match_disabled_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.shutdownlawterminatetimestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                384 => {
                    self.low_priority_games_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                440 => {
                    self.recruitment_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                448 => {
                    self.has_new_notifications = ::std::option::Option::Some(is.read_bool()?);
                },
                456 => {
                    self.is_league_admin = ::std::option::Option::Some(is.read_bool()?);
                },
                480 => {
                    self.casual_games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                488 => {
                    self.solo_competitive_games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                496 => {
                    self.party_competitive_games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                520 => {
                    self.casual_1v1_games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                536 => {
                    self.curr_all_hero_challenge_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                544 => {
                    self.play_time_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                552 => {
                    self.account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                560 => {
                    self.play_time_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                568 => {
                    self.player_behavior_seq_num_last_report = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.player_behavior_score_last_report = ::std::option::Option::Some(is.read_uint32()?);
                },
                584 => {
                    self.player_behavior_report_old_data = ::std::option::Option::Some(is.read_bool()?);
                },
                592 => {
                    self.tourney_skill_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                680 => {
                    self.tourney_recent_participation_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                704 => {
                    self.anchored_phone_number_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                712 => {
                    self.ranked_matchmaking_ban_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                720 => {
                    self.recent_game_time_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                728 => {
                    self.recent_game_time_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                736 => {
                    self.recent_game_time_3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                824 => {
                    self.favorite_team_packed = ::std::option::Option::Some(is.read_uint64()?);
                },
                832 => {
                    self.recent_report_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                840 => {
                    self.custom_game_disabled_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                848 => {
                    self.recent_win_time_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                856 => {
                    self.recent_win_time_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                864 => {
                    self.recent_win_time_3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                872 => {
                    self.coach_rating = ::std::option::Option::Some(is.read_uint32()?);
                },
                912 => {
                    self.queue_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                922 => {
                    self.role_handicaps.push(is.read_message()?);
                },
                960 => {
                    self.event_mode_recent_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                968 => {
                    self.mmr_recalibration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.losses {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.xp {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.initial_skill {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.leaver_count {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.secondary_leaver_count {
            my_size += ::protobuf::rt::uint32_size(58, v);
        }
        if let Some(v) = self.low_priority_until_date {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.prevent_text_chat_until_date {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.prevent_voice_until_date {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.prevent_public_text_chat_until_date {
            my_size += ::protobuf::rt::uint32_size(86, v);
        }
        if let Some(v) = self.prevent_new_player_chat_until_date {
            my_size += ::protobuf::rt::uint32_size(122, v);
        }
        if let Some(v) = self.last_abandoned_game_date {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.last_secondary_abandoned_game_date {
            my_size += ::protobuf::rt::uint32_size(59, v);
        }
        if let Some(v) = self.leaver_penalty_count {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.completed_game_streak {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.account_disabled_until_date {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.account_disabled_count {
            my_size += ::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.match_disabled_until_date {
            my_size += ::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.match_disabled_count {
            my_size += ::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.shutdownlawterminatetimestamp {
            my_size += ::protobuf::rt::uint32_size(47, v);
        }
        if let Some(v) = self.low_priority_games_remaining {
            my_size += ::protobuf::rt::uint32_size(48, v);
        }
        if let Some(v) = self.recruitment_level {
            my_size += ::protobuf::rt::uint32_size(55, v);
        }
        if let Some(v) = self.has_new_notifications {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_league_admin {
            my_size += 2 + 1;
        }
        if let Some(v) = self.casual_games_played {
            my_size += ::protobuf::rt::uint32_size(60, v);
        }
        if let Some(v) = self.solo_competitive_games_played {
            my_size += ::protobuf::rt::uint32_size(61, v);
        }
        if let Some(v) = self.party_competitive_games_played {
            my_size += ::protobuf::rt::uint32_size(62, v);
        }
        if let Some(v) = self.casual_1v1_games_played {
            my_size += ::protobuf::rt::uint32_size(65, v);
        }
        if let Some(v) = self.curr_all_hero_challenge_id {
            my_size += ::protobuf::rt::uint32_size(67, v);
        }
        if let Some(v) = self.play_time_points {
            my_size += ::protobuf::rt::uint32_size(68, v);
        }
        if let Some(v) = self.account_flags {
            my_size += ::protobuf::rt::uint32_size(69, v);
        }
        if let Some(v) = self.play_time_level {
            my_size += ::protobuf::rt::uint32_size(70, v);
        }
        if let Some(v) = self.player_behavior_seq_num_last_report {
            my_size += ::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.player_behavior_score_last_report {
            my_size += ::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.player_behavior_report_old_data {
            my_size += 2 + 1;
        }
        if let Some(v) = self.tourney_skill_level {
            my_size += ::protobuf::rt::uint32_size(74, v);
        }
        if let Some(v) = self.tourney_recent_participation_date {
            my_size += ::protobuf::rt::uint32_size(85, v);
        }
        if let Some(v) = self.anchored_phone_number_id {
            my_size += ::protobuf::rt::uint64_size(88, v);
        }
        if let Some(v) = self.ranked_matchmaking_ban_until_date {
            my_size += ::protobuf::rt::uint32_size(89, v);
        }
        if let Some(v) = self.recent_game_time_1 {
            my_size += ::protobuf::rt::uint32_size(90, v);
        }
        if let Some(v) = self.recent_game_time_2 {
            my_size += ::protobuf::rt::uint32_size(91, v);
        }
        if let Some(v) = self.recent_game_time_3 {
            my_size += ::protobuf::rt::uint32_size(92, v);
        }
        if let Some(v) = self.favorite_team_packed {
            my_size += ::protobuf::rt::uint64_size(103, v);
        }
        if let Some(v) = self.recent_report_time {
            my_size += ::protobuf::rt::uint32_size(104, v);
        }
        if let Some(v) = self.custom_game_disabled_until_date {
            my_size += ::protobuf::rt::uint32_size(105, v);
        }
        if let Some(v) = self.recent_win_time_1 {
            my_size += ::protobuf::rt::uint32_size(106, v);
        }
        if let Some(v) = self.recent_win_time_2 {
            my_size += ::protobuf::rt::uint32_size(107, v);
        }
        if let Some(v) = self.recent_win_time_3 {
            my_size += ::protobuf::rt::uint32_size(108, v);
        }
        if let Some(v) = self.coach_rating {
            my_size += ::protobuf::rt::uint32_size(109, v);
        }
        if let Some(v) = self.queue_points {
            my_size += ::protobuf::rt::uint32_size(114, v);
        }
        for value in &self.role_handicaps {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_mode_recent_time {
            my_size += ::protobuf::rt::uint32_size(120, v);
        }
        if let Some(v) = self.mmr_recalibration_time {
            my_size += ::protobuf::rt::uint32_size(121, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.losses {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.xp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.initial_skill {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.leaver_count {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.secondary_leaver_count {
            os.write_uint32(58, v)?;
        }
        if let Some(v) = self.low_priority_until_date {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.prevent_text_chat_until_date {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.prevent_voice_until_date {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.prevent_public_text_chat_until_date {
            os.write_uint32(86, v)?;
        }
        if let Some(v) = self.prevent_new_player_chat_until_date {
            os.write_uint32(122, v)?;
        }
        if let Some(v) = self.last_abandoned_game_date {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.last_secondary_abandoned_game_date {
            os.write_uint32(59, v)?;
        }
        if let Some(v) = self.leaver_penalty_count {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.completed_game_streak {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.account_disabled_until_date {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.account_disabled_count {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.match_disabled_until_date {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.match_disabled_count {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.shutdownlawterminatetimestamp {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.low_priority_games_remaining {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.recruitment_level {
            os.write_uint32(55, v)?;
        }
        if let Some(v) = self.has_new_notifications {
            os.write_bool(56, v)?;
        }
        if let Some(v) = self.is_league_admin {
            os.write_bool(57, v)?;
        }
        if let Some(v) = self.casual_games_played {
            os.write_uint32(60, v)?;
        }
        if let Some(v) = self.solo_competitive_games_played {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.party_competitive_games_played {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.casual_1v1_games_played {
            os.write_uint32(65, v)?;
        }
        if let Some(v) = self.curr_all_hero_challenge_id {
            os.write_uint32(67, v)?;
        }
        if let Some(v) = self.play_time_points {
            os.write_uint32(68, v)?;
        }
        if let Some(v) = self.account_flags {
            os.write_uint32(69, v)?;
        }
        if let Some(v) = self.play_time_level {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.player_behavior_seq_num_last_report {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.player_behavior_score_last_report {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.player_behavior_report_old_data {
            os.write_bool(73, v)?;
        }
        if let Some(v) = self.tourney_skill_level {
            os.write_uint32(74, v)?;
        }
        if let Some(v) = self.tourney_recent_participation_date {
            os.write_uint32(85, v)?;
        }
        if let Some(v) = self.anchored_phone_number_id {
            os.write_uint64(88, v)?;
        }
        if let Some(v) = self.ranked_matchmaking_ban_until_date {
            os.write_uint32(89, v)?;
        }
        if let Some(v) = self.recent_game_time_1 {
            os.write_uint32(90, v)?;
        }
        if let Some(v) = self.recent_game_time_2 {
            os.write_uint32(91, v)?;
        }
        if let Some(v) = self.recent_game_time_3 {
            os.write_uint32(92, v)?;
        }
        if let Some(v) = self.favorite_team_packed {
            os.write_uint64(103, v)?;
        }
        if let Some(v) = self.recent_report_time {
            os.write_uint32(104, v)?;
        }
        if let Some(v) = self.custom_game_disabled_until_date {
            os.write_uint32(105, v)?;
        }
        if let Some(v) = self.recent_win_time_1 {
            os.write_uint32(106, v)?;
        }
        if let Some(v) = self.recent_win_time_2 {
            os.write_uint32(107, v)?;
        }
        if let Some(v) = self.recent_win_time_3 {
            os.write_uint32(108, v)?;
        }
        if let Some(v) = self.coach_rating {
            os.write_uint32(109, v)?;
        }
        if let Some(v) = self.queue_points {
            os.write_uint32(114, v)?;
        }
        for v in &self.role_handicaps {
            ::protobuf::rt::write_message_field_with_cached_size(115, v, os)?;
        };
        if let Some(v) = self.event_mode_recent_time {
            os.write_uint32(120, v)?;
        }
        if let Some(v) = self.mmr_recalibration_time {
            os.write_uint32(121, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAGameAccountClient {
        CSODOTAGameAccountClient::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.wins = ::std::option::Option::None;
        self.losses = ::std::option::Option::None;
        self.xp = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.initial_skill = ::std::option::Option::None;
        self.leaver_count = ::std::option::Option::None;
        self.secondary_leaver_count = ::std::option::Option::None;
        self.low_priority_until_date = ::std::option::Option::None;
        self.prevent_text_chat_until_date = ::std::option::Option::None;
        self.prevent_voice_until_date = ::std::option::Option::None;
        self.prevent_public_text_chat_until_date = ::std::option::Option::None;
        self.prevent_new_player_chat_until_date = ::std::option::Option::None;
        self.last_abandoned_game_date = ::std::option::Option::None;
        self.last_secondary_abandoned_game_date = ::std::option::Option::None;
        self.leaver_penalty_count = ::std::option::Option::None;
        self.completed_game_streak = ::std::option::Option::None;
        self.account_disabled_until_date = ::std::option::Option::None;
        self.account_disabled_count = ::std::option::Option::None;
        self.match_disabled_until_date = ::std::option::Option::None;
        self.match_disabled_count = ::std::option::Option::None;
        self.shutdownlawterminatetimestamp = ::std::option::Option::None;
        self.low_priority_games_remaining = ::std::option::Option::None;
        self.recruitment_level = ::std::option::Option::None;
        self.has_new_notifications = ::std::option::Option::None;
        self.is_league_admin = ::std::option::Option::None;
        self.casual_games_played = ::std::option::Option::None;
        self.solo_competitive_games_played = ::std::option::Option::None;
        self.party_competitive_games_played = ::std::option::Option::None;
        self.casual_1v1_games_played = ::std::option::Option::None;
        self.curr_all_hero_challenge_id = ::std::option::Option::None;
        self.play_time_points = ::std::option::Option::None;
        self.account_flags = ::std::option::Option::None;
        self.play_time_level = ::std::option::Option::None;
        self.player_behavior_seq_num_last_report = ::std::option::Option::None;
        self.player_behavior_score_last_report = ::std::option::Option::None;
        self.player_behavior_report_old_data = ::std::option::Option::None;
        self.tourney_skill_level = ::std::option::Option::None;
        self.tourney_recent_participation_date = ::std::option::Option::None;
        self.anchored_phone_number_id = ::std::option::Option::None;
        self.ranked_matchmaking_ban_until_date = ::std::option::Option::None;
        self.recent_game_time_1 = ::std::option::Option::None;
        self.recent_game_time_2 = ::std::option::Option::None;
        self.recent_game_time_3 = ::std::option::Option::None;
        self.favorite_team_packed = ::std::option::Option::None;
        self.recent_report_time = ::std::option::Option::None;
        self.custom_game_disabled_until_date = ::std::option::Option::None;
        self.recent_win_time_1 = ::std::option::Option::None;
        self.recent_win_time_2 = ::std::option::Option::None;
        self.recent_win_time_3 = ::std::option::Option::None;
        self.coach_rating = ::std::option::Option::None;
        self.queue_points = ::std::option::Option::None;
        self.role_handicaps.clear();
        self.event_mode_recent_time = ::std::option::Option::None;
        self.mmr_recalibration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAGameAccountClient {
        static instance: CSODOTAGameAccountClient = CSODOTAGameAccountClient {
            account_id: ::std::option::Option::None,
            wins: ::std::option::Option::None,
            losses: ::std::option::Option::None,
            xp: ::std::option::Option::None,
            level: ::std::option::Option::None,
            initial_skill: ::std::option::Option::None,
            leaver_count: ::std::option::Option::None,
            secondary_leaver_count: ::std::option::Option::None,
            low_priority_until_date: ::std::option::Option::None,
            prevent_text_chat_until_date: ::std::option::Option::None,
            prevent_voice_until_date: ::std::option::Option::None,
            prevent_public_text_chat_until_date: ::std::option::Option::None,
            prevent_new_player_chat_until_date: ::std::option::Option::None,
            last_abandoned_game_date: ::std::option::Option::None,
            last_secondary_abandoned_game_date: ::std::option::Option::None,
            leaver_penalty_count: ::std::option::Option::None,
            completed_game_streak: ::std::option::Option::None,
            account_disabled_until_date: ::std::option::Option::None,
            account_disabled_count: ::std::option::Option::None,
            match_disabled_until_date: ::std::option::Option::None,
            match_disabled_count: ::std::option::Option::None,
            shutdownlawterminatetimestamp: ::std::option::Option::None,
            low_priority_games_remaining: ::std::option::Option::None,
            recruitment_level: ::std::option::Option::None,
            has_new_notifications: ::std::option::Option::None,
            is_league_admin: ::std::option::Option::None,
            casual_games_played: ::std::option::Option::None,
            solo_competitive_games_played: ::std::option::Option::None,
            party_competitive_games_played: ::std::option::Option::None,
            casual_1v1_games_played: ::std::option::Option::None,
            curr_all_hero_challenge_id: ::std::option::Option::None,
            play_time_points: ::std::option::Option::None,
            account_flags: ::std::option::Option::None,
            play_time_level: ::std::option::Option::None,
            player_behavior_seq_num_last_report: ::std::option::Option::None,
            player_behavior_score_last_report: ::std::option::Option::None,
            player_behavior_report_old_data: ::std::option::Option::None,
            tourney_skill_level: ::std::option::Option::None,
            tourney_recent_participation_date: ::std::option::Option::None,
            anchored_phone_number_id: ::std::option::Option::None,
            ranked_matchmaking_ban_until_date: ::std::option::Option::None,
            recent_game_time_1: ::std::option::Option::None,
            recent_game_time_2: ::std::option::Option::None,
            recent_game_time_3: ::std::option::Option::None,
            favorite_team_packed: ::std::option::Option::None,
            recent_report_time: ::std::option::Option::None,
            custom_game_disabled_until_date: ::std::option::Option::None,
            recent_win_time_1: ::std::option::Option::None,
            recent_win_time_2: ::std::option::Option::None,
            recent_win_time_3: ::std::option::Option::None,
            coach_rating: ::std::option::Option::None,
            queue_points: ::std::option::Option::None,
            role_handicaps: ::std::vec::Vec::new(),
            event_mode_recent_time: ::std::option::Option::None,
            mmr_recalibration_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAGameAccountClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAGameAccountClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAGameAccountClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAGameAccountClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSODOTAGameAccountClient`
pub mod csodotagame_account_client {
    // @@protoc_insertion_point(message:dota.CSODOTAGameAccountClient.RoleHandicap)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RoleHandicap {
        // message fields
        // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.RoleHandicap.role)
        pub role: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CSODOTAGameAccountClient.RoleHandicap.handicap)
        pub handicap: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CSODOTAGameAccountClient.RoleHandicap.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RoleHandicap {
        fn default() -> &'a RoleHandicap {
            <RoleHandicap as ::protobuf::Message>::default_instance()
        }
    }

    impl RoleHandicap {
        pub fn new() -> RoleHandicap {
            ::std::default::Default::default()
        }

        // optional uint32 role = 1;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }

        // optional float handicap = 2;

        pub fn handicap(&self) -> f32 {
            self.handicap.unwrap_or(0.)
        }

        pub fn clear_handicap(&mut self) {
            self.handicap = ::std::option::Option::None;
        }

        pub fn has_handicap(&self) -> bool {
            self.handicap.is_some()
        }

        // Param is passed by value, moved
        pub fn set_handicap(&mut self, v: f32) {
            self.handicap = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "role",
                |m: &RoleHandicap| { &m.role },
                |m: &mut RoleHandicap| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "handicap",
                |m: &RoleHandicap| { &m.handicap },
                |m: &mut RoleHandicap| { &mut m.handicap },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoleHandicap>(
                "CSODOTAGameAccountClient.RoleHandicap",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RoleHandicap {
        const NAME: &'static str = "RoleHandicap";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.handicap = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.role {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.handicap {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.role {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.handicap {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RoleHandicap {
            RoleHandicap::new()
        }

        fn clear(&mut self) {
            self.role = ::std::option::Option::None;
            self.handicap = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RoleHandicap {
            static instance: RoleHandicap = RoleHandicap {
                role: ::std::option::Option::None,
                handicap: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RoleHandicap {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSODOTAGameAccountClient.RoleHandicap").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RoleHandicap {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RoleHandicap {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CSODOTAGameAccountPlus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAGameAccountPlus {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountPlus.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountPlus.original_start_date)
    pub original_start_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountPlus.plus_flags)
    pub plus_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountPlus.plus_status)
    pub plus_status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountPlus.prepaid_time_start)
    pub prepaid_time_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountPlus.prepaid_time_balance)
    pub prepaid_time_balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountPlus.next_payment_date)
    pub next_payment_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAGameAccountPlus.steam_agreement_id)
    pub steam_agreement_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAGameAccountPlus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAGameAccountPlus {
    fn default() -> &'a CSODOTAGameAccountPlus {
        <CSODOTAGameAccountPlus as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAGameAccountPlus {
    pub fn new() -> CSODOTAGameAccountPlus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 original_start_date = 2;

    pub fn original_start_date(&self) -> u32 {
        self.original_start_date.unwrap_or(0)
    }

    pub fn clear_original_start_date(&mut self) {
        self.original_start_date = ::std::option::Option::None;
    }

    pub fn has_original_start_date(&self) -> bool {
        self.original_start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_start_date(&mut self, v: u32) {
        self.original_start_date = ::std::option::Option::Some(v);
    }

    // optional uint32 plus_flags = 3;

    pub fn plus_flags(&self) -> u32 {
        self.plus_flags.unwrap_or(0)
    }

    pub fn clear_plus_flags(&mut self) {
        self.plus_flags = ::std::option::Option::None;
    }

    pub fn has_plus_flags(&self) -> bool {
        self.plus_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plus_flags(&mut self, v: u32) {
        self.plus_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 plus_status = 4;

    pub fn plus_status(&self) -> u32 {
        self.plus_status.unwrap_or(0)
    }

    pub fn clear_plus_status(&mut self) {
        self.plus_status = ::std::option::Option::None;
    }

    pub fn has_plus_status(&self) -> bool {
        self.plus_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plus_status(&mut self, v: u32) {
        self.plus_status = ::std::option::Option::Some(v);
    }

    // optional uint32 prepaid_time_start = 5;

    pub fn prepaid_time_start(&self) -> u32 {
        self.prepaid_time_start.unwrap_or(0)
    }

    pub fn clear_prepaid_time_start(&mut self) {
        self.prepaid_time_start = ::std::option::Option::None;
    }

    pub fn has_prepaid_time_start(&self) -> bool {
        self.prepaid_time_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepaid_time_start(&mut self, v: u32) {
        self.prepaid_time_start = ::std::option::Option::Some(v);
    }

    // optional uint32 prepaid_time_balance = 6;

    pub fn prepaid_time_balance(&self) -> u32 {
        self.prepaid_time_balance.unwrap_or(0)
    }

    pub fn clear_prepaid_time_balance(&mut self) {
        self.prepaid_time_balance = ::std::option::Option::None;
    }

    pub fn has_prepaid_time_balance(&self) -> bool {
        self.prepaid_time_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepaid_time_balance(&mut self, v: u32) {
        self.prepaid_time_balance = ::std::option::Option::Some(v);
    }

    // optional fixed32 next_payment_date = 7;

    pub fn next_payment_date(&self) -> u32 {
        self.next_payment_date.unwrap_or(0)
    }

    pub fn clear_next_payment_date(&mut self) {
        self.next_payment_date = ::std::option::Option::None;
    }

    pub fn has_next_payment_date(&self) -> bool {
        self.next_payment_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_payment_date(&mut self, v: u32) {
        self.next_payment_date = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_agreement_id = 8;

    pub fn steam_agreement_id(&self) -> u64 {
        self.steam_agreement_id.unwrap_or(0)
    }

    pub fn clear_steam_agreement_id(&mut self) {
        self.steam_agreement_id = ::std::option::Option::None;
    }

    pub fn has_steam_agreement_id(&self) -> bool {
        self.steam_agreement_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_agreement_id(&mut self, v: u64) {
        self.steam_agreement_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSODOTAGameAccountPlus| { &m.account_id },
            |m: &mut CSODOTAGameAccountPlus| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_start_date",
            |m: &CSODOTAGameAccountPlus| { &m.original_start_date },
            |m: &mut CSODOTAGameAccountPlus| { &mut m.original_start_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plus_flags",
            |m: &CSODOTAGameAccountPlus| { &m.plus_flags },
            |m: &mut CSODOTAGameAccountPlus| { &mut m.plus_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plus_status",
            |m: &CSODOTAGameAccountPlus| { &m.plus_status },
            |m: &mut CSODOTAGameAccountPlus| { &mut m.plus_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prepaid_time_start",
            |m: &CSODOTAGameAccountPlus| { &m.prepaid_time_start },
            |m: &mut CSODOTAGameAccountPlus| { &mut m.prepaid_time_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prepaid_time_balance",
            |m: &CSODOTAGameAccountPlus| { &m.prepaid_time_balance },
            |m: &mut CSODOTAGameAccountPlus| { &mut m.prepaid_time_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "next_payment_date",
            |m: &CSODOTAGameAccountPlus| { &m.next_payment_date },
            |m: &mut CSODOTAGameAccountPlus| { &mut m.next_payment_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_agreement_id",
            |m: &CSODOTAGameAccountPlus| { &m.steam_agreement_id },
            |m: &mut CSODOTAGameAccountPlus| { &mut m.steam_agreement_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAGameAccountPlus>(
            "CSODOTAGameAccountPlus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAGameAccountPlus {
    const NAME: &'static str = "CSODOTAGameAccountPlus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.original_start_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.plus_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.plus_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.prepaid_time_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.prepaid_time_balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.next_payment_date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                65 => {
                    self.steam_agreement_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.original_start_date {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.plus_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.plus_status {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.prepaid_time_start {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.prepaid_time_balance {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.next_payment_date {
            my_size += 1 + 4;
        }
        if let Some(v) = self.steam_agreement_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.original_start_date {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.plus_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.plus_status {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.prepaid_time_start {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.prepaid_time_balance {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.next_payment_date {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.steam_agreement_id {
            os.write_fixed64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAGameAccountPlus {
        CSODOTAGameAccountPlus::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.original_start_date = ::std::option::Option::None;
        self.plus_flags = ::std::option::Option::None;
        self.plus_status = ::std::option::Option::None;
        self.prepaid_time_start = ::std::option::Option::None;
        self.prepaid_time_balance = ::std::option::Option::None;
        self.next_payment_date = ::std::option::Option::None;
        self.steam_agreement_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAGameAccountPlus {
        static instance: CSODOTAGameAccountPlus = CSODOTAGameAccountPlus {
            account_id: ::std::option::Option::None,
            original_start_date: ::std::option::Option::None,
            plus_flags: ::std::option::Option::None,
            plus_status: ::std::option::Option::None,
            prepaid_time_start: ::std::option::Option::None,
            prepaid_time_balance: ::std::option::Option::None,
            next_payment_date: ::std::option::Option::None,
            steam_agreement_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAGameAccountPlus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAGameAccountPlus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAGameAccountPlus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAGameAccountPlus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLobbyFeaturedGamemodeProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyFeaturedGamemodeProgress {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyFeaturedGamemodeProgress.accounts)
    pub accounts: ::std::vec::Vec<cmsg_lobby_featured_gamemode_progress::AccountProgress>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyFeaturedGamemodeProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyFeaturedGamemodeProgress {
    fn default() -> &'a CMsgLobbyFeaturedGamemodeProgress {
        <CMsgLobbyFeaturedGamemodeProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyFeaturedGamemodeProgress {
    pub fn new() -> CMsgLobbyFeaturedGamemodeProgress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accounts",
            |m: &CMsgLobbyFeaturedGamemodeProgress| { &m.accounts },
            |m: &mut CMsgLobbyFeaturedGamemodeProgress| { &mut m.accounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyFeaturedGamemodeProgress>(
            "CMsgLobbyFeaturedGamemodeProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyFeaturedGamemodeProgress {
    const NAME: &'static str = "CMsgLobbyFeaturedGamemodeProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accounts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.accounts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyFeaturedGamemodeProgress {
        CMsgLobbyFeaturedGamemodeProgress::new()
    }

    fn clear(&mut self) {
        self.accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyFeaturedGamemodeProgress {
        static instance: CMsgLobbyFeaturedGamemodeProgress = CMsgLobbyFeaturedGamemodeProgress {
            accounts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyFeaturedGamemodeProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyFeaturedGamemodeProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyFeaturedGamemodeProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyFeaturedGamemodeProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgLobbyFeaturedGamemodeProgress`
pub mod cmsg_lobby_featured_gamemode_progress {
    // @@protoc_insertion_point(message:dota.CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AccountProgress {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgLobbyFeaturedGamemodeProgress.AccountProgress.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyFeaturedGamemodeProgress.AccountProgress.current_value)
        pub current_value: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLobbyFeaturedGamemodeProgress.AccountProgress.max_value)
        pub max_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgLobbyFeaturedGamemodeProgress.AccountProgress.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AccountProgress {
        fn default() -> &'a AccountProgress {
            <AccountProgress as ::protobuf::Message>::default_instance()
        }
    }

    impl AccountProgress {
        pub fn new() -> AccountProgress {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 current_value = 2;

        pub fn current_value(&self) -> u32 {
            self.current_value.unwrap_or(0)
        }

        pub fn clear_current_value(&mut self) {
            self.current_value = ::std::option::Option::None;
        }

        pub fn has_current_value(&self) -> bool {
            self.current_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_current_value(&mut self, v: u32) {
            self.current_value = ::std::option::Option::Some(v);
        }

        // optional uint32 max_value = 3;

        pub fn max_value(&self) -> u32 {
            self.max_value.unwrap_or(0)
        }

        pub fn clear_max_value(&mut self) {
            self.max_value = ::std::option::Option::None;
        }

        pub fn has_max_value(&self) -> bool {
            self.max_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_value(&mut self, v: u32) {
            self.max_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &AccountProgress| { &m.account_id },
                |m: &mut AccountProgress| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "current_value",
                |m: &AccountProgress| { &m.current_value },
                |m: &mut AccountProgress| { &mut m.current_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_value",
                |m: &AccountProgress| { &m.max_value },
                |m: &mut AccountProgress| { &mut m.max_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountProgress>(
                "CMsgLobbyFeaturedGamemodeProgress.AccountProgress",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AccountProgress {
        const NAME: &'static str = "AccountProgress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.current_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.max_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.current_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.max_value {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.current_value {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.max_value {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AccountProgress {
            AccountProgress::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.current_value = ::std::option::Option::None;
            self.max_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AccountProgress {
            static instance: AccountProgress = AccountProgress {
                account_id: ::std::option::Option::None,
                current_value: ::std::option::Option::None,
                max_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AccountProgress {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLobbyFeaturedGamemodeProgress.AccountProgress").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AccountProgress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AccountProgress {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgBattleCupVictory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleCupVictory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBattleCupVictory.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleCupVictory.win_date)
    pub win_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleCupVictory.valid_until)
    pub valid_until: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleCupVictory.skill_level)
    pub skill_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleCupVictory.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleCupVictory.division_id)
    pub division_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleCupVictory.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleCupVictory.streak)
    pub streak: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleCupVictory.trophy_id)
    pub trophy_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBattleCupVictory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleCupVictory {
    fn default() -> &'a CMsgBattleCupVictory {
        <CMsgBattleCupVictory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleCupVictory {
    pub fn new() -> CMsgBattleCupVictory {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 win_date = 2;

    pub fn win_date(&self) -> u32 {
        self.win_date.unwrap_or(0)
    }

    pub fn clear_win_date(&mut self) {
        self.win_date = ::std::option::Option::None;
    }

    pub fn has_win_date(&self) -> bool {
        self.win_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_date(&mut self, v: u32) {
        self.win_date = ::std::option::Option::Some(v);
    }

    // optional uint32 valid_until = 3;

    pub fn valid_until(&self) -> u32 {
        self.valid_until.unwrap_or(0)
    }

    pub fn clear_valid_until(&mut self) {
        self.valid_until = ::std::option::Option::None;
    }

    pub fn has_valid_until(&self) -> bool {
        self.valid_until.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valid_until(&mut self, v: u32) {
        self.valid_until = ::std::option::Option::Some(v);
    }

    // optional uint32 skill_level = 4;

    pub fn skill_level(&self) -> u32 {
        self.skill_level.unwrap_or(0)
    }

    pub fn clear_skill_level(&mut self) {
        self.skill_level = ::std::option::Option::None;
    }

    pub fn has_skill_level(&self) -> bool {
        self.skill_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_level(&mut self, v: u32) {
        self.skill_level = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_id = 5;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional uint32 division_id = 6;

    pub fn division_id(&self) -> u32 {
        self.division_id.unwrap_or(0)
    }

    pub fn clear_division_id(&mut self) {
        self.division_id = ::std::option::Option::None;
    }

    pub fn has_division_id(&self) -> bool {
        self.division_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_division_id(&mut self, v: u32) {
        self.division_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 7;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 streak = 8;

    pub fn streak(&self) -> u32 {
        self.streak.unwrap_or(0)
    }

    pub fn clear_streak(&mut self) {
        self.streak = ::std::option::Option::None;
    }

    pub fn has_streak(&self) -> bool {
        self.streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streak(&mut self, v: u32) {
        self.streak = ::std::option::Option::Some(v);
    }

    // optional uint32 trophy_id = 9;

    pub fn trophy_id(&self) -> u32 {
        self.trophy_id.unwrap_or(0)
    }

    pub fn clear_trophy_id(&mut self) {
        self.trophy_id = ::std::option::Option::None;
    }

    pub fn has_trophy_id(&self) -> bool {
        self.trophy_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_id(&mut self, v: u32) {
        self.trophy_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgBattleCupVictory| { &m.account_id },
            |m: &mut CMsgBattleCupVictory| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "win_date",
            |m: &CMsgBattleCupVictory| { &m.win_date },
            |m: &mut CMsgBattleCupVictory| { &mut m.win_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "valid_until",
            |m: &CMsgBattleCupVictory| { &m.valid_until },
            |m: &mut CMsgBattleCupVictory| { &mut m.valid_until },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skill_level",
            |m: &CMsgBattleCupVictory| { &m.skill_level },
            |m: &mut CMsgBattleCupVictory| { &mut m.skill_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_id",
            |m: &CMsgBattleCupVictory| { &m.tournament_id },
            |m: &mut CMsgBattleCupVictory| { &mut m.tournament_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "division_id",
            |m: &CMsgBattleCupVictory| { &m.division_id },
            |m: &mut CMsgBattleCupVictory| { &mut m.division_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CMsgBattleCupVictory| { &m.team_id },
            |m: &mut CMsgBattleCupVictory| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "streak",
            |m: &CMsgBattleCupVictory| { &m.streak },
            |m: &mut CMsgBattleCupVictory| { &mut m.streak },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trophy_id",
            |m: &CMsgBattleCupVictory| { &m.trophy_id },
            |m: &mut CMsgBattleCupVictory| { &mut m.trophy_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleCupVictory>(
            "CMsgBattleCupVictory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBattleCupVictory {
    const NAME: &'static str = "CMsgBattleCupVictory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.win_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.valid_until = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.skill_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.division_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.trophy_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.win_date {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.valid_until {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.skill_level {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.division_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.streak {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.trophy_id {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.win_date {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.valid_until {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.skill_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.division_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.streak {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.trophy_id {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleCupVictory {
        CMsgBattleCupVictory::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.win_date = ::std::option::Option::None;
        self.valid_until = ::std::option::Option::None;
        self.skill_level = ::std::option::Option::None;
        self.tournament_id = ::std::option::Option::None;
        self.division_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.streak = ::std::option::Option::None;
        self.trophy_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleCupVictory {
        static instance: CMsgBattleCupVictory = CMsgBattleCupVictory {
            account_id: ::std::option::Option::None,
            win_date: ::std::option::Option::None,
            valid_until: ::std::option::Option::None,
            skill_level: ::std::option::Option::None,
            tournament_id: ::std::option::Option::None,
            division_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            streak: ::std::option::Option::None,
            trophy_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBattleCupVictory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBattleCupVictory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBattleCupVictory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleCupVictory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLobbyBattleCupVictoryList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyBattleCupVictoryList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyBattleCupVictoryList.winners)
    pub winners: ::std::vec::Vec<CMsgBattleCupVictory>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyBattleCupVictoryList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyBattleCupVictoryList {
    fn default() -> &'a CMsgLobbyBattleCupVictoryList {
        <CMsgLobbyBattleCupVictoryList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyBattleCupVictoryList {
    pub fn new() -> CMsgLobbyBattleCupVictoryList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "winners",
            |m: &CMsgLobbyBattleCupVictoryList| { &m.winners },
            |m: &mut CMsgLobbyBattleCupVictoryList| { &mut m.winners },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyBattleCupVictoryList>(
            "CMsgLobbyBattleCupVictoryList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyBattleCupVictoryList {
    const NAME: &'static str = "CMsgLobbyBattleCupVictoryList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.winners.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.winners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.winners {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyBattleCupVictoryList {
        CMsgLobbyBattleCupVictoryList::new()
    }

    fn clear(&mut self) {
        self.winners.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyBattleCupVictoryList {
        static instance: CMsgLobbyBattleCupVictoryList = CMsgLobbyBattleCupVictoryList {
            winners: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyBattleCupVictoryList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyBattleCupVictoryList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyBattleCupVictoryList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyBattleCupVictoryList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTABroadcastNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTABroadcastNotification {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTABroadcastNotification.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTABroadcastNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTABroadcastNotification {
    fn default() -> &'a CMsgDOTABroadcastNotification {
        <CMsgDOTABroadcastNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTABroadcastNotification {
    pub fn new() -> CMsgDOTABroadcastNotification {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgDOTABroadcastNotification| { &m.message },
            |m: &mut CMsgDOTABroadcastNotification| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTABroadcastNotification>(
            "CMsgDOTABroadcastNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTABroadcastNotification {
    const NAME: &'static str = "CMsgDOTABroadcastNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTABroadcastNotification {
        CMsgDOTABroadcastNotification::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTABroadcastNotification {
        static instance: CMsgDOTABroadcastNotification = CMsgDOTABroadcastNotification {
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTABroadcastNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTABroadcastNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTABroadcastNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTABroadcastNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CProtoItemHeroStatue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemHeroStatue {
    // message fields
    // @@protoc_insertion_point(field:dota.CProtoItemHeroStatue.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemHeroStatue.status_effect_index)
    pub status_effect_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemHeroStatue.sequence_name)
    pub sequence_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CProtoItemHeroStatue.cycle)
    pub cycle: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CProtoItemHeroStatue.wearable)
    pub wearable: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemHeroStatue.inscription)
    pub inscription: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CProtoItemHeroStatue.style)
    pub style: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CProtoItemHeroStatue.tournament_drop)
    pub tournament_drop: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CProtoItemHeroStatue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemHeroStatue {
    fn default() -> &'a CProtoItemHeroStatue {
        <CProtoItemHeroStatue as ::protobuf::Message>::default_instance()
    }
}

impl CProtoItemHeroStatue {
    pub fn new() -> CProtoItemHeroStatue {
        ::std::default::Default::default()
    }

    // optional uint32 hero_id = 1;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 status_effect_index = 2;

    pub fn status_effect_index(&self) -> u32 {
        self.status_effect_index.unwrap_or(0)
    }

    pub fn clear_status_effect_index(&mut self) {
        self.status_effect_index = ::std::option::Option::None;
    }

    pub fn has_status_effect_index(&self) -> bool {
        self.status_effect_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_effect_index(&mut self, v: u32) {
        self.status_effect_index = ::std::option::Option::Some(v);
    }

    // optional string sequence_name = 3;

    pub fn sequence_name(&self) -> &str {
        match self.sequence_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sequence_name(&mut self) {
        self.sequence_name = ::std::option::Option::None;
    }

    pub fn has_sequence_name(&self) -> bool {
        self.sequence_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_name(&mut self, v: ::std::string::String) {
        self.sequence_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_name(&mut self) -> &mut ::std::string::String {
        if self.sequence_name.is_none() {
            self.sequence_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sequence_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence_name(&mut self) -> ::std::string::String {
        self.sequence_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float cycle = 4;

    pub fn cycle(&self) -> f32 {
        self.cycle.unwrap_or(0.)
    }

    pub fn clear_cycle(&mut self) {
        self.cycle = ::std::option::Option::None;
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: f32) {
        self.cycle = ::std::option::Option::Some(v);
    }

    // optional string inscription = 6;

    pub fn inscription(&self) -> &str {
        match self.inscription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_inscription(&mut self) {
        self.inscription = ::std::option::Option::None;
    }

    pub fn has_inscription(&self) -> bool {
        self.inscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inscription(&mut self, v: ::std::string::String) {
        self.inscription = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inscription(&mut self) -> &mut ::std::string::String {
        if self.inscription.is_none() {
            self.inscription = ::std::option::Option::Some(::std::string::String::new());
        }
        self.inscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_inscription(&mut self) -> ::std::string::String {
        self.inscription.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool tournament_drop = 8;

    pub fn tournament_drop(&self) -> bool {
        self.tournament_drop.unwrap_or(false)
    }

    pub fn clear_tournament_drop(&mut self) {
        self.tournament_drop = ::std::option::Option::None;
    }

    pub fn has_tournament_drop(&self) -> bool {
        self.tournament_drop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_drop(&mut self, v: bool) {
        self.tournament_drop = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CProtoItemHeroStatue| { &m.hero_id },
            |m: &mut CProtoItemHeroStatue| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_effect_index",
            |m: &CProtoItemHeroStatue| { &m.status_effect_index },
            |m: &mut CProtoItemHeroStatue| { &mut m.status_effect_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_name",
            |m: &CProtoItemHeroStatue| { &m.sequence_name },
            |m: &mut CProtoItemHeroStatue| { &mut m.sequence_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cycle",
            |m: &CProtoItemHeroStatue| { &m.cycle },
            |m: &mut CProtoItemHeroStatue| { &mut m.cycle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "wearable",
            |m: &CProtoItemHeroStatue| { &m.wearable },
            |m: &mut CProtoItemHeroStatue| { &mut m.wearable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inscription",
            |m: &CProtoItemHeroStatue| { &m.inscription },
            |m: &mut CProtoItemHeroStatue| { &mut m.inscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "style",
            |m: &CProtoItemHeroStatue| { &m.style },
            |m: &mut CProtoItemHeroStatue| { &mut m.style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_drop",
            |m: &CProtoItemHeroStatue| { &m.tournament_drop },
            |m: &mut CProtoItemHeroStatue| { &mut m.tournament_drop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProtoItemHeroStatue>(
            "CProtoItemHeroStatue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProtoItemHeroStatue {
    const NAME: &'static str = "CProtoItemHeroStatue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.status_effect_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.sequence_name = ::std::option::Option::Some(is.read_string()?);
                },
                37 => {
                    self.cycle = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.wearable)?;
                },
                40 => {
                    self.wearable.push(is.read_uint32()?);
                },
                50 => {
                    self.inscription = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.style)?;
                },
                56 => {
                    self.style.push(is.read_uint32()?);
                },
                64 => {
                    self.tournament_drop = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.status_effect_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.sequence_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.cycle {
            my_size += 1 + 4;
        }
        for value in &self.wearable {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        if let Some(v) = self.inscription.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.style {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        if let Some(v) = self.tournament_drop {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.status_effect_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sequence_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.cycle {
            os.write_float(4, v)?;
        }
        for v in &self.wearable {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.inscription.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.style {
            os.write_uint32(7, *v)?;
        };
        if let Some(v) = self.tournament_drop {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemHeroStatue {
        CProtoItemHeroStatue::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.status_effect_index = ::std::option::Option::None;
        self.sequence_name = ::std::option::Option::None;
        self.cycle = ::std::option::Option::None;
        self.wearable.clear();
        self.inscription = ::std::option::Option::None;
        self.style.clear();
        self.tournament_drop = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemHeroStatue {
        static instance: CProtoItemHeroStatue = CProtoItemHeroStatue {
            hero_id: ::std::option::Option::None,
            status_effect_index: ::std::option::Option::None,
            sequence_name: ::std::option::Option::None,
            cycle: ::std::option::Option::None,
            wearable: ::std::vec::Vec::new(),
            inscription: ::std::option::Option::None,
            style: ::std::vec::Vec::new(),
            tournament_drop: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProtoItemHeroStatue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProtoItemHeroStatue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProtoItemHeroStatue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemHeroStatue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMatchPlayerAbilityUpgrade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerAbilityUpgrade {
    // message fields
    // @@protoc_insertion_point(field:dota.CMatchPlayerAbilityUpgrade.ability)
    pub ability: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerAbilityUpgrade.time)
    pub time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMatchPlayerAbilityUpgrade.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerAbilityUpgrade {
    fn default() -> &'a CMatchPlayerAbilityUpgrade {
        <CMatchPlayerAbilityUpgrade as ::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerAbilityUpgrade {
    pub fn new() -> CMatchPlayerAbilityUpgrade {
        ::std::default::Default::default()
    }

    // optional int32 ability = 1;

    pub fn ability(&self) -> i32 {
        self.ability.unwrap_or(0)
    }

    pub fn clear_ability(&mut self) {
        self.ability = ::std::option::Option::None;
    }

    pub fn has_ability(&self) -> bool {
        self.ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability(&mut self, v: i32) {
        self.ability = ::std::option::Option::Some(v);
    }

    // optional uint32 time = 2;

    pub fn time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability",
            |m: &CMatchPlayerAbilityUpgrade| { &m.ability },
            |m: &mut CMatchPlayerAbilityUpgrade| { &mut m.ability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &CMatchPlayerAbilityUpgrade| { &m.time },
            |m: &mut CMatchPlayerAbilityUpgrade| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMatchPlayerAbilityUpgrade>(
            "CMatchPlayerAbilityUpgrade",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMatchPlayerAbilityUpgrade {
    const NAME: &'static str = "CMatchPlayerAbilityUpgrade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerAbilityUpgrade {
        CMatchPlayerAbilityUpgrade::new()
    }

    fn clear(&mut self) {
        self.ability = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerAbilityUpgrade {
        static instance: CMatchPlayerAbilityUpgrade = CMatchPlayerAbilityUpgrade {
            ability: ::std::option::Option::None,
            time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMatchPlayerAbilityUpgrade {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMatchPlayerAbilityUpgrade").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMatchPlayerAbilityUpgrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchPlayerAbilityUpgrade {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMatchPlayerTimedCustomStat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerTimedCustomStat {
    // message fields
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedCustomStat.stat)
    pub stat: ::std::option::Option<::protobuf::EnumOrUnknown<EDOTAMatchPlayerTimeCustomStat>>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedCustomStat.value)
    pub value: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMatchPlayerTimedCustomStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerTimedCustomStat {
    fn default() -> &'a CMatchPlayerTimedCustomStat {
        <CMatchPlayerTimedCustomStat as ::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerTimedCustomStat {
    pub fn new() -> CMatchPlayerTimedCustomStat {
        ::std::default::Default::default()
    }

    // optional .dota.EDOTAMatchPlayerTimeCustomStat stat = 2;

    pub fn stat(&self) -> EDOTAMatchPlayerTimeCustomStat {
        match self.stat {
            Some(e) => e.enum_value_or(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers),
            None => EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers,
        }
    }

    pub fn clear_stat(&mut self) {
        self.stat = ::std::option::Option::None;
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: EDOTAMatchPlayerTimeCustomStat) {
        self.stat = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional float value = 3;

    pub fn value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stat",
            |m: &CMatchPlayerTimedCustomStat| { &m.stat },
            |m: &mut CMatchPlayerTimedCustomStat| { &mut m.stat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMatchPlayerTimedCustomStat| { &m.value },
            |m: &mut CMatchPlayerTimedCustomStat| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMatchPlayerTimedCustomStat>(
            "CMatchPlayerTimedCustomStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMatchPlayerTimedCustomStat {
    const NAME: &'static str = "CMatchPlayerTimedCustomStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.stat = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                29 => {
                    self.value = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stat {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.value {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stat {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.value {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerTimedCustomStat {
        CMatchPlayerTimedCustomStat::new()
    }

    fn clear(&mut self) {
        self.stat = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerTimedCustomStat {
        static instance: CMatchPlayerTimedCustomStat = CMatchPlayerTimedCustomStat {
            stat: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMatchPlayerTimedCustomStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMatchPlayerTimedCustomStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMatchPlayerTimedCustomStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchPlayerTimedCustomStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMatchPlayerTimedStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerTimedStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.time)
    pub time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.assists)
    pub assists: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.net_worth)
    pub net_worth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.xp)
    pub xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.denies)
    pub denies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.bounty_rune_gold)
    pub bounty_rune_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.range_creep_upgrade_gold)
    pub range_creep_upgrade_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.observer_wards_dewarded)
    pub observer_wards_dewarded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.reliable_gold_earned)
    pub reliable_gold_earned: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.gold_loss_prevented)
    pub gold_loss_prevented: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.hero_kill_gold)
    pub hero_kill_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.creep_kill_gold)
    pub creep_kill_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.building_gold)
    pub building_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.other_gold)
    pub other_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.comeback_gold)
    pub comeback_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.experimental_gold)
    pub experimental_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.experimental2_gold)
    pub experimental2_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.creep_deny_gold)
    pub creep_deny_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.tp_scrolls_purchased_1)
    pub tp_scrolls_purchased_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.tp_scrolls_purchased_2)
    pub tp_scrolls_purchased_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.tp_scrolls_purchased_3)
    pub tp_scrolls_purchased_3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.tp_scrolls_purchased_4)
    pub tp_scrolls_purchased_4: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.tp_scrolls_purchased_5)
    pub tp_scrolls_purchased_5: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.neutral_gold)
    pub neutral_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.courier_gold)
    pub courier_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.roshan_gold)
    pub roshan_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.income_gold)
    pub income_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.item_value)
    pub item_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.support_gold_spent)
    pub support_gold_spent: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.camps_stacked)
    pub camps_stacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.wards_placed)
    pub wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.triple_kills)
    pub triple_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.rampages)
    pub rampages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerTimedStats.custom_stats)
    pub custom_stats: ::std::vec::Vec<CMatchPlayerTimedCustomStat>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMatchPlayerTimedStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerTimedStats {
    fn default() -> &'a CMatchPlayerTimedStats {
        <CMatchPlayerTimedStats as ::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerTimedStats {
    pub fn new() -> CMatchPlayerTimedStats {
        ::std::default::Default::default()
    }

    // optional uint32 time = 1;

    pub fn time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 2;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 3;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 4;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional uint32 net_worth = 5;

    pub fn net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional uint32 xp = 6;

    pub fn xp(&self) -> u32 {
        self.xp.unwrap_or(0)
    }

    pub fn clear_xp(&mut self) {
        self.xp = ::std::option::Option::None;
    }

    pub fn has_xp(&self) -> bool {
        self.xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp(&mut self, v: u32) {
        self.xp = ::std::option::Option::Some(v);
    }

    // optional uint32 last_hits = 7;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 denies = 8;

    pub fn denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    // optional uint32 bounty_rune_gold = 9;

    pub fn bounty_rune_gold(&self) -> u32 {
        self.bounty_rune_gold.unwrap_or(0)
    }

    pub fn clear_bounty_rune_gold(&mut self) {
        self.bounty_rune_gold = ::std::option::Option::None;
    }

    pub fn has_bounty_rune_gold(&self) -> bool {
        self.bounty_rune_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounty_rune_gold(&mut self, v: u32) {
        self.bounty_rune_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 range_creep_upgrade_gold = 10;

    pub fn range_creep_upgrade_gold(&self) -> u32 {
        self.range_creep_upgrade_gold.unwrap_or(0)
    }

    pub fn clear_range_creep_upgrade_gold(&mut self) {
        self.range_creep_upgrade_gold = ::std::option::Option::None;
    }

    pub fn has_range_creep_upgrade_gold(&self) -> bool {
        self.range_creep_upgrade_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_creep_upgrade_gold(&mut self, v: u32) {
        self.range_creep_upgrade_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 observer_wards_dewarded = 11;

    pub fn observer_wards_dewarded(&self) -> u32 {
        self.observer_wards_dewarded.unwrap_or(0)
    }

    pub fn clear_observer_wards_dewarded(&mut self) {
        self.observer_wards_dewarded = ::std::option::Option::None;
    }

    pub fn has_observer_wards_dewarded(&self) -> bool {
        self.observer_wards_dewarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_wards_dewarded(&mut self, v: u32) {
        self.observer_wards_dewarded = ::std::option::Option::Some(v);
    }

    // optional uint32 reliable_gold_earned = 12;

    pub fn reliable_gold_earned(&self) -> u32 {
        self.reliable_gold_earned.unwrap_or(0)
    }

    pub fn clear_reliable_gold_earned(&mut self) {
        self.reliable_gold_earned = ::std::option::Option::None;
    }

    pub fn has_reliable_gold_earned(&self) -> bool {
        self.reliable_gold_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_gold_earned(&mut self, v: u32) {
        self.reliable_gold_earned = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_loss_prevented = 13;

    pub fn gold_loss_prevented(&self) -> u32 {
        self.gold_loss_prevented.unwrap_or(0)
    }

    pub fn clear_gold_loss_prevented(&mut self) {
        self.gold_loss_prevented = ::std::option::Option::None;
    }

    pub fn has_gold_loss_prevented(&self) -> bool {
        self.gold_loss_prevented.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_loss_prevented(&mut self, v: u32) {
        self.gold_loss_prevented = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_kill_gold = 14;

    pub fn hero_kill_gold(&self) -> u32 {
        self.hero_kill_gold.unwrap_or(0)
    }

    pub fn clear_hero_kill_gold(&mut self) {
        self.hero_kill_gold = ::std::option::Option::None;
    }

    pub fn has_hero_kill_gold(&self) -> bool {
        self.hero_kill_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_kill_gold(&mut self, v: u32) {
        self.hero_kill_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 creep_kill_gold = 15;

    pub fn creep_kill_gold(&self) -> u32 {
        self.creep_kill_gold.unwrap_or(0)
    }

    pub fn clear_creep_kill_gold(&mut self) {
        self.creep_kill_gold = ::std::option::Option::None;
    }

    pub fn has_creep_kill_gold(&self) -> bool {
        self.creep_kill_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creep_kill_gold(&mut self, v: u32) {
        self.creep_kill_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 building_gold = 16;

    pub fn building_gold(&self) -> u32 {
        self.building_gold.unwrap_or(0)
    }

    pub fn clear_building_gold(&mut self) {
        self.building_gold = ::std::option::Option::None;
    }

    pub fn has_building_gold(&self) -> bool {
        self.building_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_gold(&mut self, v: u32) {
        self.building_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 other_gold = 17;

    pub fn other_gold(&self) -> u32 {
        self.other_gold.unwrap_or(0)
    }

    pub fn clear_other_gold(&mut self) {
        self.other_gold = ::std::option::Option::None;
    }

    pub fn has_other_gold(&self) -> bool {
        self.other_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_gold(&mut self, v: u32) {
        self.other_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 comeback_gold = 18;

    pub fn comeback_gold(&self) -> u32 {
        self.comeback_gold.unwrap_or(0)
    }

    pub fn clear_comeback_gold(&mut self) {
        self.comeback_gold = ::std::option::Option::None;
    }

    pub fn has_comeback_gold(&self) -> bool {
        self.comeback_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comeback_gold(&mut self, v: u32) {
        self.comeback_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 experimental_gold = 19;

    pub fn experimental_gold(&self) -> u32 {
        self.experimental_gold.unwrap_or(0)
    }

    pub fn clear_experimental_gold(&mut self) {
        self.experimental_gold = ::std::option::Option::None;
    }

    pub fn has_experimental_gold(&self) -> bool {
        self.experimental_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_gold(&mut self, v: u32) {
        self.experimental_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 experimental2_gold = 20;

    pub fn experimental2_gold(&self) -> u32 {
        self.experimental2_gold.unwrap_or(0)
    }

    pub fn clear_experimental2_gold(&mut self) {
        self.experimental2_gold = ::std::option::Option::None;
    }

    pub fn has_experimental2_gold(&self) -> bool {
        self.experimental2_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental2_gold(&mut self, v: u32) {
        self.experimental2_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 creep_deny_gold = 21;

    pub fn creep_deny_gold(&self) -> u32 {
        self.creep_deny_gold.unwrap_or(0)
    }

    pub fn clear_creep_deny_gold(&mut self) {
        self.creep_deny_gold = ::std::option::Option::None;
    }

    pub fn has_creep_deny_gold(&self) -> bool {
        self.creep_deny_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creep_deny_gold(&mut self, v: u32) {
        self.creep_deny_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_1 = 22;

    pub fn tp_scrolls_purchased_1(&self) -> u32 {
        self.tp_scrolls_purchased_1.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_1(&mut self) {
        self.tp_scrolls_purchased_1 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_1(&self) -> bool {
        self.tp_scrolls_purchased_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_1(&mut self, v: u32) {
        self.tp_scrolls_purchased_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_2 = 23;

    pub fn tp_scrolls_purchased_2(&self) -> u32 {
        self.tp_scrolls_purchased_2.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_2(&mut self) {
        self.tp_scrolls_purchased_2 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_2(&self) -> bool {
        self.tp_scrolls_purchased_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_2(&mut self, v: u32) {
        self.tp_scrolls_purchased_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_3 = 24;

    pub fn tp_scrolls_purchased_3(&self) -> u32 {
        self.tp_scrolls_purchased_3.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_3(&mut self) {
        self.tp_scrolls_purchased_3 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_3(&self) -> bool {
        self.tp_scrolls_purchased_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_3(&mut self, v: u32) {
        self.tp_scrolls_purchased_3 = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_4 = 25;

    pub fn tp_scrolls_purchased_4(&self) -> u32 {
        self.tp_scrolls_purchased_4.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_4(&mut self) {
        self.tp_scrolls_purchased_4 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_4(&self) -> bool {
        self.tp_scrolls_purchased_4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_4(&mut self, v: u32) {
        self.tp_scrolls_purchased_4 = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_5 = 26;

    pub fn tp_scrolls_purchased_5(&self) -> u32 {
        self.tp_scrolls_purchased_5.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_5(&mut self) {
        self.tp_scrolls_purchased_5 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_5(&self) -> bool {
        self.tp_scrolls_purchased_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_5(&mut self, v: u32) {
        self.tp_scrolls_purchased_5 = ::std::option::Option::Some(v);
    }

    // optional uint32 neutral_gold = 27;

    pub fn neutral_gold(&self) -> u32 {
        self.neutral_gold.unwrap_or(0)
    }

    pub fn clear_neutral_gold(&mut self) {
        self.neutral_gold = ::std::option::Option::None;
    }

    pub fn has_neutral_gold(&self) -> bool {
        self.neutral_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_gold(&mut self, v: u32) {
        self.neutral_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 courier_gold = 28;

    pub fn courier_gold(&self) -> u32 {
        self.courier_gold.unwrap_or(0)
    }

    pub fn clear_courier_gold(&mut self) {
        self.courier_gold = ::std::option::Option::None;
    }

    pub fn has_courier_gold(&self) -> bool {
        self.courier_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_courier_gold(&mut self, v: u32) {
        self.courier_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 roshan_gold = 29;

    pub fn roshan_gold(&self) -> u32 {
        self.roshan_gold.unwrap_or(0)
    }

    pub fn clear_roshan_gold(&mut self) {
        self.roshan_gold = ::std::option::Option::None;
    }

    pub fn has_roshan_gold(&self) -> bool {
        self.roshan_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_gold(&mut self, v: u32) {
        self.roshan_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 income_gold = 30;

    pub fn income_gold(&self) -> u32 {
        self.income_gold.unwrap_or(0)
    }

    pub fn clear_income_gold(&mut self) {
        self.income_gold = ::std::option::Option::None;
    }

    pub fn has_income_gold(&self) -> bool {
        self.income_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_income_gold(&mut self, v: u32) {
        self.income_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 item_value = 36;

    pub fn item_value(&self) -> u32 {
        self.item_value.unwrap_or(0)
    }

    pub fn clear_item_value(&mut self) {
        self.item_value = ::std::option::Option::None;
    }

    pub fn has_item_value(&self) -> bool {
        self.item_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_value(&mut self, v: u32) {
        self.item_value = ::std::option::Option::Some(v);
    }

    // optional uint32 support_gold_spent = 37;

    pub fn support_gold_spent(&self) -> u32 {
        self.support_gold_spent.unwrap_or(0)
    }

    pub fn clear_support_gold_spent(&mut self) {
        self.support_gold_spent = ::std::option::Option::None;
    }

    pub fn has_support_gold_spent(&self) -> bool {
        self.support_gold_spent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold_spent(&mut self, v: u32) {
        self.support_gold_spent = ::std::option::Option::Some(v);
    }

    // optional uint32 camps_stacked = 38;

    pub fn camps_stacked(&self) -> u32 {
        self.camps_stacked.unwrap_or(0)
    }

    pub fn clear_camps_stacked(&mut self) {
        self.camps_stacked = ::std::option::Option::None;
    }

    pub fn has_camps_stacked(&self) -> bool {
        self.camps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camps_stacked(&mut self, v: u32) {
        self.camps_stacked = ::std::option::Option::Some(v);
    }

    // optional uint32 wards_placed = 39;

    pub fn wards_placed(&self) -> u32 {
        self.wards_placed.unwrap_or(0)
    }

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: u32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 triple_kills = 40;

    pub fn triple_kills(&self) -> u32 {
        self.triple_kills.unwrap_or(0)
    }

    pub fn clear_triple_kills(&mut self) {
        self.triple_kills = ::std::option::Option::None;
    }

    pub fn has_triple_kills(&self) -> bool {
        self.triple_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triple_kills(&mut self, v: u32) {
        self.triple_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 rampages = 41;

    pub fn rampages(&self) -> u32 {
        self.rampages.unwrap_or(0)
    }

    pub fn clear_rampages(&mut self) {
        self.rampages = ::std::option::Option::None;
    }

    pub fn has_rampages(&self) -> bool {
        self.rampages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampages(&mut self, v: u32) {
        self.rampages = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(37);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &CMatchPlayerTimedStats| { &m.time },
            |m: &mut CMatchPlayerTimedStats| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills",
            |m: &CMatchPlayerTimedStats| { &m.kills },
            |m: &mut CMatchPlayerTimedStats| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaths",
            |m: &CMatchPlayerTimedStats| { &m.deaths },
            |m: &mut CMatchPlayerTimedStats| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assists",
            |m: &CMatchPlayerTimedStats| { &m.assists },
            |m: &mut CMatchPlayerTimedStats| { &mut m.assists },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_worth",
            |m: &CMatchPlayerTimedStats| { &m.net_worth },
            |m: &mut CMatchPlayerTimedStats| { &mut m.net_worth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xp",
            |m: &CMatchPlayerTimedStats| { &m.xp },
            |m: &mut CMatchPlayerTimedStats| { &mut m.xp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_hits",
            |m: &CMatchPlayerTimedStats| { &m.last_hits },
            |m: &mut CMatchPlayerTimedStats| { &mut m.last_hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "denies",
            |m: &CMatchPlayerTimedStats| { &m.denies },
            |m: &mut CMatchPlayerTimedStats| { &mut m.denies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bounty_rune_gold",
            |m: &CMatchPlayerTimedStats| { &m.bounty_rune_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.bounty_rune_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "range_creep_upgrade_gold",
            |m: &CMatchPlayerTimedStats| { &m.range_creep_upgrade_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.range_creep_upgrade_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observer_wards_dewarded",
            |m: &CMatchPlayerTimedStats| { &m.observer_wards_dewarded },
            |m: &mut CMatchPlayerTimedStats| { &mut m.observer_wards_dewarded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reliable_gold_earned",
            |m: &CMatchPlayerTimedStats| { &m.reliable_gold_earned },
            |m: &mut CMatchPlayerTimedStats| { &mut m.reliable_gold_earned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gold_loss_prevented",
            |m: &CMatchPlayerTimedStats| { &m.gold_loss_prevented },
            |m: &mut CMatchPlayerTimedStats| { &mut m.gold_loss_prevented },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_kill_gold",
            |m: &CMatchPlayerTimedStats| { &m.hero_kill_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.hero_kill_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creep_kill_gold",
            |m: &CMatchPlayerTimedStats| { &m.creep_kill_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.creep_kill_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "building_gold",
            |m: &CMatchPlayerTimedStats| { &m.building_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.building_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_gold",
            |m: &CMatchPlayerTimedStats| { &m.other_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.other_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comeback_gold",
            |m: &CMatchPlayerTimedStats| { &m.comeback_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.comeback_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimental_gold",
            |m: &CMatchPlayerTimedStats| { &m.experimental_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.experimental_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimental2_gold",
            |m: &CMatchPlayerTimedStats| { &m.experimental2_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.experimental2_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creep_deny_gold",
            |m: &CMatchPlayerTimedStats| { &m.creep_deny_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.creep_deny_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tp_scrolls_purchased_1",
            |m: &CMatchPlayerTimedStats| { &m.tp_scrolls_purchased_1 },
            |m: &mut CMatchPlayerTimedStats| { &mut m.tp_scrolls_purchased_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tp_scrolls_purchased_2",
            |m: &CMatchPlayerTimedStats| { &m.tp_scrolls_purchased_2 },
            |m: &mut CMatchPlayerTimedStats| { &mut m.tp_scrolls_purchased_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tp_scrolls_purchased_3",
            |m: &CMatchPlayerTimedStats| { &m.tp_scrolls_purchased_3 },
            |m: &mut CMatchPlayerTimedStats| { &mut m.tp_scrolls_purchased_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tp_scrolls_purchased_4",
            |m: &CMatchPlayerTimedStats| { &m.tp_scrolls_purchased_4 },
            |m: &mut CMatchPlayerTimedStats| { &mut m.tp_scrolls_purchased_4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tp_scrolls_purchased_5",
            |m: &CMatchPlayerTimedStats| { &m.tp_scrolls_purchased_5 },
            |m: &mut CMatchPlayerTimedStats| { &mut m.tp_scrolls_purchased_5 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "neutral_gold",
            |m: &CMatchPlayerTimedStats| { &m.neutral_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.neutral_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "courier_gold",
            |m: &CMatchPlayerTimedStats| { &m.courier_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.courier_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roshan_gold",
            |m: &CMatchPlayerTimedStats| { &m.roshan_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.roshan_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "income_gold",
            |m: &CMatchPlayerTimedStats| { &m.income_gold },
            |m: &mut CMatchPlayerTimedStats| { &mut m.income_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_value",
            |m: &CMatchPlayerTimedStats| { &m.item_value },
            |m: &mut CMatchPlayerTimedStats| { &mut m.item_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support_gold_spent",
            |m: &CMatchPlayerTimedStats| { &m.support_gold_spent },
            |m: &mut CMatchPlayerTimedStats| { &mut m.support_gold_spent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "camps_stacked",
            |m: &CMatchPlayerTimedStats| { &m.camps_stacked },
            |m: &mut CMatchPlayerTimedStats| { &mut m.camps_stacked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wards_placed",
            |m: &CMatchPlayerTimedStats| { &m.wards_placed },
            |m: &mut CMatchPlayerTimedStats| { &mut m.wards_placed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "triple_kills",
            |m: &CMatchPlayerTimedStats| { &m.triple_kills },
            |m: &mut CMatchPlayerTimedStats| { &mut m.triple_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rampages",
            |m: &CMatchPlayerTimedStats| { &m.rampages },
            |m: &mut CMatchPlayerTimedStats| { &mut m.rampages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "custom_stats",
            |m: &CMatchPlayerTimedStats| { &m.custom_stats },
            |m: &mut CMatchPlayerTimedStats| { &mut m.custom_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMatchPlayerTimedStats>(
            "CMatchPlayerTimedStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMatchPlayerTimedStats {
    const NAME: &'static str = "CMatchPlayerTimedStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.denies = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.bounty_rune_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.range_creep_upgrade_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.observer_wards_dewarded = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.reliable_gold_earned = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.gold_loss_prevented = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.hero_kill_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.creep_kill_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.building_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.other_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.comeback_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.experimental_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.experimental2_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.creep_deny_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.tp_scrolls_purchased_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.tp_scrolls_purchased_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.tp_scrolls_purchased_3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.tp_scrolls_purchased_4 = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.tp_scrolls_purchased_5 = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.neutral_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.courier_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.roshan_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.income_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.item_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                296 => {
                    self.support_gold_spent = ::std::option::Option::Some(is.read_uint32()?);
                },
                304 => {
                    self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                320 => {
                    self.triple_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                328 => {
                    self.rampages = ::std::option::Option::Some(is.read_uint32()?);
                },
                338 => {
                    self.custom_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.net_worth {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.xp {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.denies {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.bounty_rune_gold {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.range_creep_upgrade_gold {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.observer_wards_dewarded {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.reliable_gold_earned {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.gold_loss_prevented {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.hero_kill_gold {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.creep_kill_gold {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.building_gold {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.other_gold {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.comeback_gold {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.experimental_gold {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.experimental2_gold {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.creep_deny_gold {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_1 {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_2 {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_3 {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_4 {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_5 {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.neutral_gold {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.courier_gold {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.roshan_gold {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.income_gold {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.item_value {
            my_size += ::protobuf::rt::uint32_size(36, v);
        }
        if let Some(v) = self.support_gold_spent {
            my_size += ::protobuf::rt::uint32_size(37, v);
        }
        if let Some(v) = self.camps_stacked {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.wards_placed {
            my_size += ::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.triple_kills {
            my_size += ::protobuf::rt::uint32_size(40, v);
        }
        if let Some(v) = self.rampages {
            my_size += ::protobuf::rt::uint32_size(41, v);
        }
        for value in &self.custom_stats {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.xp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.bounty_rune_gold {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.range_creep_upgrade_gold {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.observer_wards_dewarded {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reliable_gold_earned {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.gold_loss_prevented {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.hero_kill_gold {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.creep_kill_gold {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.building_gold {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.other_gold {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.comeback_gold {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.experimental_gold {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.experimental2_gold {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.creep_deny_gold {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_1 {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_2 {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_3 {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_4 {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_5 {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.neutral_gold {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.courier_gold {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.roshan_gold {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.income_gold {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.item_value {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.support_gold_spent {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.camps_stacked {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.triple_kills {
            os.write_uint32(40, v)?;
        }
        if let Some(v) = self.rampages {
            os.write_uint32(41, v)?;
        }
        for v in &self.custom_stats {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerTimedStats {
        CMatchPlayerTimedStats::new()
    }

    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.xp = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.denies = ::std::option::Option::None;
        self.bounty_rune_gold = ::std::option::Option::None;
        self.range_creep_upgrade_gold = ::std::option::Option::None;
        self.observer_wards_dewarded = ::std::option::Option::None;
        self.reliable_gold_earned = ::std::option::Option::None;
        self.gold_loss_prevented = ::std::option::Option::None;
        self.hero_kill_gold = ::std::option::Option::None;
        self.creep_kill_gold = ::std::option::Option::None;
        self.building_gold = ::std::option::Option::None;
        self.other_gold = ::std::option::Option::None;
        self.comeback_gold = ::std::option::Option::None;
        self.experimental_gold = ::std::option::Option::None;
        self.experimental2_gold = ::std::option::Option::None;
        self.creep_deny_gold = ::std::option::Option::None;
        self.tp_scrolls_purchased_1 = ::std::option::Option::None;
        self.tp_scrolls_purchased_2 = ::std::option::Option::None;
        self.tp_scrolls_purchased_3 = ::std::option::Option::None;
        self.tp_scrolls_purchased_4 = ::std::option::Option::None;
        self.tp_scrolls_purchased_5 = ::std::option::Option::None;
        self.neutral_gold = ::std::option::Option::None;
        self.courier_gold = ::std::option::Option::None;
        self.roshan_gold = ::std::option::Option::None;
        self.income_gold = ::std::option::Option::None;
        self.item_value = ::std::option::Option::None;
        self.support_gold_spent = ::std::option::Option::None;
        self.camps_stacked = ::std::option::Option::None;
        self.wards_placed = ::std::option::Option::None;
        self.triple_kills = ::std::option::Option::None;
        self.rampages = ::std::option::Option::None;
        self.custom_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerTimedStats {
        static instance: CMatchPlayerTimedStats = CMatchPlayerTimedStats {
            time: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            xp: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            denies: ::std::option::Option::None,
            bounty_rune_gold: ::std::option::Option::None,
            range_creep_upgrade_gold: ::std::option::Option::None,
            observer_wards_dewarded: ::std::option::Option::None,
            reliable_gold_earned: ::std::option::Option::None,
            gold_loss_prevented: ::std::option::Option::None,
            hero_kill_gold: ::std::option::Option::None,
            creep_kill_gold: ::std::option::Option::None,
            building_gold: ::std::option::Option::None,
            other_gold: ::std::option::Option::None,
            comeback_gold: ::std::option::Option::None,
            experimental_gold: ::std::option::Option::None,
            experimental2_gold: ::std::option::Option::None,
            creep_deny_gold: ::std::option::Option::None,
            tp_scrolls_purchased_1: ::std::option::Option::None,
            tp_scrolls_purchased_2: ::std::option::Option::None,
            tp_scrolls_purchased_3: ::std::option::Option::None,
            tp_scrolls_purchased_4: ::std::option::Option::None,
            tp_scrolls_purchased_5: ::std::option::Option::None,
            neutral_gold: ::std::option::Option::None,
            courier_gold: ::std::option::Option::None,
            roshan_gold: ::std::option::Option::None,
            income_gold: ::std::option::Option::None,
            item_value: ::std::option::Option::None,
            support_gold_spent: ::std::option::Option::None,
            camps_stacked: ::std::option::Option::None,
            wards_placed: ::std::option::Option::None,
            triple_kills: ::std::option::Option::None,
            rampages: ::std::option::Option::None,
            custom_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMatchPlayerTimedStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMatchPlayerTimedStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMatchPlayerTimedStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchPlayerTimedStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMatchTeamTimedStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchTeamTimedStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMatchTeamTimedStats.time)
    pub time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchTeamTimedStats.enemy_towers_killed)
    pub enemy_towers_killed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchTeamTimedStats.enemy_barracks_killed)
    pub enemy_barracks_killed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchTeamTimedStats.enemy_towers_status)
    pub enemy_towers_status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchTeamTimedStats.enemy_barracks_status)
    pub enemy_barracks_status: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMatchTeamTimedStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchTeamTimedStats {
    fn default() -> &'a CMatchTeamTimedStats {
        <CMatchTeamTimedStats as ::protobuf::Message>::default_instance()
    }
}

impl CMatchTeamTimedStats {
    pub fn new() -> CMatchTeamTimedStats {
        ::std::default::Default::default()
    }

    // optional uint32 time = 1;

    pub fn time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_towers_killed = 2;

    pub fn enemy_towers_killed(&self) -> u32 {
        self.enemy_towers_killed.unwrap_or(0)
    }

    pub fn clear_enemy_towers_killed(&mut self) {
        self.enemy_towers_killed = ::std::option::Option::None;
    }

    pub fn has_enemy_towers_killed(&self) -> bool {
        self.enemy_towers_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_towers_killed(&mut self, v: u32) {
        self.enemy_towers_killed = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_barracks_killed = 3;

    pub fn enemy_barracks_killed(&self) -> u32 {
        self.enemy_barracks_killed.unwrap_or(0)
    }

    pub fn clear_enemy_barracks_killed(&mut self) {
        self.enemy_barracks_killed = ::std::option::Option::None;
    }

    pub fn has_enemy_barracks_killed(&self) -> bool {
        self.enemy_barracks_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_barracks_killed(&mut self, v: u32) {
        self.enemy_barracks_killed = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_towers_status = 4;

    pub fn enemy_towers_status(&self) -> u32 {
        self.enemy_towers_status.unwrap_or(0)
    }

    pub fn clear_enemy_towers_status(&mut self) {
        self.enemy_towers_status = ::std::option::Option::None;
    }

    pub fn has_enemy_towers_status(&self) -> bool {
        self.enemy_towers_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_towers_status(&mut self, v: u32) {
        self.enemy_towers_status = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_barracks_status = 5;

    pub fn enemy_barracks_status(&self) -> u32 {
        self.enemy_barracks_status.unwrap_or(0)
    }

    pub fn clear_enemy_barracks_status(&mut self) {
        self.enemy_barracks_status = ::std::option::Option::None;
    }

    pub fn has_enemy_barracks_status(&self) -> bool {
        self.enemy_barracks_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_barracks_status(&mut self, v: u32) {
        self.enemy_barracks_status = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &CMatchTeamTimedStats| { &m.time },
            |m: &mut CMatchTeamTimedStats| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_towers_killed",
            |m: &CMatchTeamTimedStats| { &m.enemy_towers_killed },
            |m: &mut CMatchTeamTimedStats| { &mut m.enemy_towers_killed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_barracks_killed",
            |m: &CMatchTeamTimedStats| { &m.enemy_barracks_killed },
            |m: &mut CMatchTeamTimedStats| { &mut m.enemy_barracks_killed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_towers_status",
            |m: &CMatchTeamTimedStats| { &m.enemy_towers_status },
            |m: &mut CMatchTeamTimedStats| { &mut m.enemy_towers_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_barracks_status",
            |m: &CMatchTeamTimedStats| { &m.enemy_barracks_status },
            |m: &mut CMatchTeamTimedStats| { &mut m.enemy_barracks_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMatchTeamTimedStats>(
            "CMatchTeamTimedStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMatchTeamTimedStats {
    const NAME: &'static str = "CMatchTeamTimedStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.enemy_towers_killed = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.enemy_barracks_killed = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.enemy_towers_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.enemy_barracks_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.enemy_towers_killed {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.enemy_barracks_killed {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.enemy_towers_status {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.enemy_barracks_status {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.enemy_towers_killed {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.enemy_barracks_killed {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.enemy_towers_status {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.enemy_barracks_status {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchTeamTimedStats {
        CMatchTeamTimedStats::new()
    }

    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.enemy_towers_killed = ::std::option::Option::None;
        self.enemy_barracks_killed = ::std::option::Option::None;
        self.enemy_towers_status = ::std::option::Option::None;
        self.enemy_barracks_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchTeamTimedStats {
        static instance: CMatchTeamTimedStats = CMatchTeamTimedStats {
            time: ::std::option::Option::None,
            enemy_towers_killed: ::std::option::Option::None,
            enemy_barracks_killed: ::std::option::Option::None,
            enemy_towers_status: ::std::option::Option::None,
            enemy_barracks_status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMatchTeamTimedStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMatchTeamTimedStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMatchTeamTimedStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchTeamTimedStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMatchAdditionalUnitInventory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchAdditionalUnitInventory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMatchAdditionalUnitInventory.unit_name)
    pub unit_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMatchAdditionalUnitInventory.items)
    pub items: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMatchAdditionalUnitInventory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchAdditionalUnitInventory {
    fn default() -> &'a CMatchAdditionalUnitInventory {
        <CMatchAdditionalUnitInventory as ::protobuf::Message>::default_instance()
    }
}

impl CMatchAdditionalUnitInventory {
    pub fn new() -> CMatchAdditionalUnitInventory {
        ::std::default::Default::default()
    }

    // optional string unit_name = 1;

    pub fn unit_name(&self) -> &str {
        match self.unit_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unit_name(&mut self) {
        self.unit_name = ::std::option::Option::None;
    }

    pub fn has_unit_name(&self) -> bool {
        self.unit_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_name(&mut self, v: ::std::string::String) {
        self.unit_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_name(&mut self) -> &mut ::std::string::String {
        if self.unit_name.is_none() {
            self.unit_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unit_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_name(&mut self) -> ::std::string::String {
        self.unit_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_name",
            |m: &CMatchAdditionalUnitInventory| { &m.unit_name },
            |m: &mut CMatchAdditionalUnitInventory| { &mut m.unit_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMatchAdditionalUnitInventory| { &m.items },
            |m: &mut CMatchAdditionalUnitInventory| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMatchAdditionalUnitInventory>(
            "CMatchAdditionalUnitInventory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMatchAdditionalUnitInventory {
    const NAME: &'static str = "CMatchAdditionalUnitInventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unit_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.items)?;
                },
                16 => {
                    self.items.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.items {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.items {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchAdditionalUnitInventory {
        CMatchAdditionalUnitInventory::new()
    }

    fn clear(&mut self) {
        self.unit_name = ::std::option::Option::None;
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchAdditionalUnitInventory {
        static instance: CMatchAdditionalUnitInventory = CMatchAdditionalUnitInventory {
            unit_name: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMatchAdditionalUnitInventory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMatchAdditionalUnitInventory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMatchAdditionalUnitInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchAdditionalUnitInventory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMatchPlayerPermanentBuff)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerPermanentBuff {
    // message fields
    // @@protoc_insertion_point(field:dota.CMatchPlayerPermanentBuff.permanent_buff)
    pub permanent_buff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerPermanentBuff.stack_count)
    pub stack_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchPlayerPermanentBuff.grant_time)
    pub grant_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMatchPlayerPermanentBuff.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerPermanentBuff {
    fn default() -> &'a CMatchPlayerPermanentBuff {
        <CMatchPlayerPermanentBuff as ::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerPermanentBuff {
    pub fn new() -> CMatchPlayerPermanentBuff {
        ::std::default::Default::default()
    }

    // optional uint32 permanent_buff = 1;

    pub fn permanent_buff(&self) -> u32 {
        self.permanent_buff.unwrap_or(0)
    }

    pub fn clear_permanent_buff(&mut self) {
        self.permanent_buff = ::std::option::Option::None;
    }

    pub fn has_permanent_buff(&self) -> bool {
        self.permanent_buff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permanent_buff(&mut self, v: u32) {
        self.permanent_buff = ::std::option::Option::Some(v);
    }

    // optional uint32 stack_count = 2;

    pub fn stack_count(&self) -> u32 {
        self.stack_count.unwrap_or(0)
    }

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: u32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    // optional uint32 grant_time = 3;

    pub fn grant_time(&self) -> u32 {
        self.grant_time.unwrap_or(0)
    }

    pub fn clear_grant_time(&mut self) {
        self.grant_time = ::std::option::Option::None;
    }

    pub fn has_grant_time(&self) -> bool {
        self.grant_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grant_time(&mut self, v: u32) {
        self.grant_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permanent_buff",
            |m: &CMatchPlayerPermanentBuff| { &m.permanent_buff },
            |m: &mut CMatchPlayerPermanentBuff| { &mut m.permanent_buff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_count",
            |m: &CMatchPlayerPermanentBuff| { &m.stack_count },
            |m: &mut CMatchPlayerPermanentBuff| { &mut m.stack_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "grant_time",
            |m: &CMatchPlayerPermanentBuff| { &m.grant_time },
            |m: &mut CMatchPlayerPermanentBuff| { &mut m.grant_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMatchPlayerPermanentBuff>(
            "CMatchPlayerPermanentBuff",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMatchPlayerPermanentBuff {
    const NAME: &'static str = "CMatchPlayerPermanentBuff";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permanent_buff = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.stack_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.grant_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permanent_buff {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.stack_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.grant_time {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permanent_buff {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.grant_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerPermanentBuff {
        CMatchPlayerPermanentBuff::new()
    }

    fn clear(&mut self) {
        self.permanent_buff = ::std::option::Option::None;
        self.stack_count = ::std::option::Option::None;
        self.grant_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerPermanentBuff {
        static instance: CMatchPlayerPermanentBuff = CMatchPlayerPermanentBuff {
            permanent_buff: ::std::option::Option::None,
            stack_count: ::std::option::Option::None,
            grant_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMatchPlayerPermanentBuff {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMatchPlayerPermanentBuff").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMatchPlayerPermanentBuff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchPlayerPermanentBuff {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMatchHeroSelectEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchHeroSelectEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CMatchHeroSelectEvent.is_pick)
    pub is_pick: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMatchHeroSelectEvent.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchHeroSelectEvent.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMatchHeroSelectEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchHeroSelectEvent {
    fn default() -> &'a CMatchHeroSelectEvent {
        <CMatchHeroSelectEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMatchHeroSelectEvent {
    pub fn new() -> CMatchHeroSelectEvent {
        ::std::default::Default::default()
    }

    // optional bool is_pick = 1;

    pub fn is_pick(&self) -> bool {
        self.is_pick.unwrap_or(false)
    }

    pub fn clear_is_pick(&mut self) {
        self.is_pick = ::std::option::Option::None;
    }

    pub fn has_is_pick(&self) -> bool {
        self.is_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_pick(&mut self, v: bool) {
        self.is_pick = ::std::option::Option::Some(v);
    }

    // optional uint32 team = 2;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 3;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_pick",
            |m: &CMatchHeroSelectEvent| { &m.is_pick },
            |m: &mut CMatchHeroSelectEvent| { &mut m.is_pick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CMatchHeroSelectEvent| { &m.team },
            |m: &mut CMatchHeroSelectEvent| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMatchHeroSelectEvent| { &m.hero_id },
            |m: &mut CMatchHeroSelectEvent| { &mut m.hero_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMatchHeroSelectEvent>(
            "CMatchHeroSelectEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMatchHeroSelectEvent {
    const NAME: &'static str = "CMatchHeroSelectEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_pick = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_pick {
            my_size += 1 + 1;
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_pick {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchHeroSelectEvent {
        CMatchHeroSelectEvent::new()
    }

    fn clear(&mut self) {
        self.is_pick = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchHeroSelectEvent {
        static instance: CMatchHeroSelectEvent = CMatchHeroSelectEvent {
            is_pick: ::std::option::Option::None,
            team: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMatchHeroSelectEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMatchHeroSelectEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMatchHeroSelectEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchHeroSelectEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMatchClip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchClip {
    // message fields
    // @@protoc_insertion_point(field:dota.CMatchClip.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMatchClip.player_account_id)
    pub player_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchClip.game_time_seconds)
    pub game_time_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchClip.duration_seconds)
    pub duration_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchClip.player_id)
    pub player_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchClip.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchClip.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMatchClip.camera_mode)
    pub camera_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMatchClip.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMatchClip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchClip {
    fn default() -> &'a CMatchClip {
        <CMatchClip as ::protobuf::Message>::default_instance()
    }
}

impl CMatchClip {
    pub fn new() -> CMatchClip {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 player_account_id = 2;

    pub fn player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_time_seconds = 3;

    pub fn game_time_seconds(&self) -> u32 {
        self.game_time_seconds.unwrap_or(0)
    }

    pub fn clear_game_time_seconds(&mut self) {
        self.game_time_seconds = ::std::option::Option::None;
    }

    pub fn has_game_time_seconds(&self) -> bool {
        self.game_time_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time_seconds(&mut self, v: u32) {
        self.game_time_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 duration_seconds = 4;

    pub fn duration_seconds(&self) -> u32 {
        self.duration_seconds.unwrap_or(0)
    }

    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = ::std::option::Option::None;
    }

    pub fn has_duration_seconds(&self) -> bool {
        self.duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: u32) {
        self.duration_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 player_id = 5;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 6;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 7;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 camera_mode = 8;

    pub fn camera_mode(&self) -> u32 {
        self.camera_mode.unwrap_or(0)
    }

    pub fn clear_camera_mode(&mut self) {
        self.camera_mode = ::std::option::Option::None;
    }

    pub fn has_camera_mode(&self) -> bool {
        self.camera_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_mode(&mut self, v: u32) {
        self.camera_mode = ::std::option::Option::Some(v);
    }

    // optional string comment = 9;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMatchClip| { &m.match_id },
            |m: &mut CMatchClip| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_account_id",
            |m: &CMatchClip| { &m.player_account_id },
            |m: &mut CMatchClip| { &mut m.player_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_time_seconds",
            |m: &CMatchClip| { &m.game_time_seconds },
            |m: &mut CMatchClip| { &mut m.game_time_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration_seconds",
            |m: &CMatchClip| { &m.duration_seconds },
            |m: &mut CMatchClip| { &mut m.duration_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CMatchClip| { &m.player_id },
            |m: &mut CMatchClip| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMatchClip| { &m.hero_id },
            |m: &mut CMatchClip| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &CMatchClip| { &m.ability_id },
            |m: &mut CMatchClip| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "camera_mode",
            |m: &CMatchClip| { &m.camera_mode },
            |m: &mut CMatchClip| { &mut m.camera_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment",
            |m: &CMatchClip| { &m.comment },
            |m: &mut CMatchClip| { &mut m.comment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMatchClip>(
            "CMatchClip",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMatchClip {
    const NAME: &'static str = "CMatchClip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.game_time_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.duration_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.camera_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.game_time_seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.duration_seconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.camera_mode {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.player_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_time_seconds {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.duration_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.camera_mode {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchClip {
        CMatchClip::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.player_account_id = ::std::option::Option::None;
        self.game_time_seconds = ::std::option::Option::None;
        self.duration_seconds = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.camera_mode = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchClip {
        static instance: CMatchClip = CMatchClip {
            match_id: ::std::option::Option::None,
            player_account_id: ::std::option::Option::None,
            game_time_seconds: ::std::option::Option::None,
            duration_seconds: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            camera_mode: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMatchClip {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMatchClip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMatchClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchClip {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CPartySearchClientParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CPartySearchClientParty {
    // message fields
    // @@protoc_insertion_point(field:dota.CPartySearchClientParty.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CPartySearchClientParty.beacon_type)
    pub beacon_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CPartySearchClientParty.party_members)
    pub party_members: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CPartySearchClientParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPartySearchClientParty {
    fn default() -> &'a CPartySearchClientParty {
        <CPartySearchClientParty as ::protobuf::Message>::default_instance()
    }
}

impl CPartySearchClientParty {
    pub fn new() -> CPartySearchClientParty {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional int32 beacon_type = 2;

    pub fn beacon_type(&self) -> i32 {
        self.beacon_type.unwrap_or(0)
    }

    pub fn clear_beacon_type(&mut self) {
        self.beacon_type = ::std::option::Option::None;
    }

    pub fn has_beacon_type(&self) -> bool {
        self.beacon_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_type(&mut self, v: i32) {
        self.beacon_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CPartySearchClientParty| { &m.party_id },
            |m: &mut CPartySearchClientParty| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "beacon_type",
            |m: &CPartySearchClientParty| { &m.beacon_type },
            |m: &mut CPartySearchClientParty| { &mut m.beacon_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "party_members",
            |m: &CPartySearchClientParty| { &m.party_members },
            |m: &mut CPartySearchClientParty| { &mut m.party_members },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CPartySearchClientParty>(
            "CPartySearchClientParty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CPartySearchClientParty {
    const NAME: &'static str = "CPartySearchClientParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.beacon_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_fixed32_into(&mut self.party_members)?;
                },
                29 => {
                    self.party_members.push(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.beacon_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += 5 * self.party_members.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.beacon_type {
            os.write_int32(2, v)?;
        }
        for v in &self.party_members {
            os.write_fixed32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPartySearchClientParty {
        CPartySearchClientParty::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.beacon_type = ::std::option::Option::None;
        self.party_members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPartySearchClientParty {
        static instance: CPartySearchClientParty = CPartySearchClientParty {
            party_id: ::std::option::Option::None,
            beacon_type: ::std::option::Option::None,
            party_members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CPartySearchClientParty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CPartySearchClientParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CPartySearchClientParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPartySearchClientParty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAHasItemQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAHasItemQuery {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAHasItemQuery.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAHasItemQuery.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAHasItemQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAHasItemQuery {
    fn default() -> &'a CMsgDOTAHasItemQuery {
        <CMsgDOTAHasItemQuery as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAHasItemQuery {
    pub fn new() -> CMsgDOTAHasItemQuery {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgDOTAHasItemQuery| { &m.account_id },
            |m: &mut CMsgDOTAHasItemQuery| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgDOTAHasItemQuery| { &m.item_id },
            |m: &mut CMsgDOTAHasItemQuery| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAHasItemQuery>(
            "CMsgDOTAHasItemQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAHasItemQuery {
    const NAME: &'static str = "CMsgDOTAHasItemQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAHasItemQuery {
        CMsgDOTAHasItemQuery::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAHasItemQuery {
        static instance: CMsgDOTAHasItemQuery = CMsgDOTAHasItemQuery {
            account_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAHasItemQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAHasItemQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAHasItemQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHasItemQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAHasItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAHasItemResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAHasItemResponse.has_item)
    pub has_item: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAHasItemResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAHasItemResponse {
    fn default() -> &'a CMsgDOTAHasItemResponse {
        <CMsgDOTAHasItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAHasItemResponse {
    pub fn new() -> CMsgDOTAHasItemResponse {
        ::std::default::Default::default()
    }

    // optional bool has_item = 1;

    pub fn has_item(&self) -> bool {
        self.has_item.unwrap_or(false)
    }

    pub fn clear_has_item(&mut self) {
        self.has_item = ::std::option::Option::None;
    }

    pub fn has_has_item(&self) -> bool {
        self.has_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_item(&mut self, v: bool) {
        self.has_item = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_item",
            |m: &CMsgDOTAHasItemResponse| { &m.has_item },
            |m: &mut CMsgDOTAHasItemResponse| { &mut m.has_item },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAHasItemResponse>(
            "CMsgDOTAHasItemResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAHasItemResponse {
    const NAME: &'static str = "CMsgDOTAHasItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_item = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.has_item {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.has_item {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAHasItemResponse {
        CMsgDOTAHasItemResponse::new()
    }

    fn clear(&mut self) {
        self.has_item = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAHasItemResponse {
        static instance: CMsgDOTAHasItemResponse = CMsgDOTAHasItemResponse {
            has_item: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAHasItemResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAHasItemResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAHasItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHasItemResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCGetPlayerCardItemInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetPlayerCardItemInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCGetPlayerCardItemInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCGetPlayerCardItemInfo.player_card_item_ids)
    pub player_card_item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCGetPlayerCardItemInfo.all_for_event)
    pub all_for_event: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCGetPlayerCardItemInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetPlayerCardItemInfo {
    fn default() -> &'a CMsgGCGetPlayerCardItemInfo {
        <CMsgGCGetPlayerCardItemInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetPlayerCardItemInfo {
    pub fn new() -> CMsgGCGetPlayerCardItemInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 all_for_event = 3;

    pub fn all_for_event(&self) -> u32 {
        self.all_for_event.unwrap_or(0)
    }

    pub fn clear_all_for_event(&mut self) {
        self.all_for_event = ::std::option::Option::None;
    }

    pub fn has_all_for_event(&self) -> bool {
        self.all_for_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_for_event(&mut self, v: u32) {
        self.all_for_event = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCGetPlayerCardItemInfo| { &m.account_id },
            |m: &mut CMsgGCGetPlayerCardItemInfo| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_card_item_ids",
            |m: &CMsgGCGetPlayerCardItemInfo| { &m.player_card_item_ids },
            |m: &mut CMsgGCGetPlayerCardItemInfo| { &mut m.player_card_item_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "all_for_event",
            |m: &CMsgGCGetPlayerCardItemInfo| { &m.all_for_event },
            |m: &mut CMsgGCGetPlayerCardItemInfo| { &mut m.all_for_event },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCGetPlayerCardItemInfo>(
            "CMsgGCGetPlayerCardItemInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCGetPlayerCardItemInfo {
    const NAME: &'static str = "CMsgGCGetPlayerCardItemInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.player_card_item_ids)?;
                },
                16 => {
                    self.player_card_item_ids.push(is.read_uint64()?);
                },
                24 => {
                    self.all_for_event = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.player_card_item_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.all_for_event {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.player_card_item_ids {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.all_for_event {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetPlayerCardItemInfo {
        CMsgGCGetPlayerCardItemInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.player_card_item_ids.clear();
        self.all_for_event = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetPlayerCardItemInfo {
        static instance: CMsgGCGetPlayerCardItemInfo = CMsgGCGetPlayerCardItemInfo {
            account_id: ::std::option::Option::None,
            player_card_item_ids: ::std::vec::Vec::new(),
            all_for_event: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCGetPlayerCardItemInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCGetPlayerCardItemInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCGetPlayerCardItemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetPlayerCardItemInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCGetPlayerCardItemInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetPlayerCardItemInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCGetPlayerCardItemInfoResponse.player_card_infos)
    pub player_card_infos: ::std::vec::Vec<cmsg_gcget_player_card_item_info_response::PlayerCardInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCGetPlayerCardItemInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetPlayerCardItemInfoResponse {
    fn default() -> &'a CMsgGCGetPlayerCardItemInfoResponse {
        <CMsgGCGetPlayerCardItemInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetPlayerCardItemInfoResponse {
    pub fn new() -> CMsgGCGetPlayerCardItemInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_card_infos",
            |m: &CMsgGCGetPlayerCardItemInfoResponse| { &m.player_card_infos },
            |m: &mut CMsgGCGetPlayerCardItemInfoResponse| { &mut m.player_card_infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCGetPlayerCardItemInfoResponse>(
            "CMsgGCGetPlayerCardItemInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCGetPlayerCardItemInfoResponse {
    const NAME: &'static str = "CMsgGCGetPlayerCardItemInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_card_infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_card_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_card_infos {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetPlayerCardItemInfoResponse {
        CMsgGCGetPlayerCardItemInfoResponse::new()
    }

    fn clear(&mut self) {
        self.player_card_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetPlayerCardItemInfoResponse {
        static instance: CMsgGCGetPlayerCardItemInfoResponse = CMsgGCGetPlayerCardItemInfoResponse {
            player_card_infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCGetPlayerCardItemInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCGetPlayerCardItemInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCGetPlayerCardItemInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetPlayerCardItemInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCGetPlayerCardItemInfoResponse`
pub mod cmsg_gcget_player_card_item_info_response {
    // @@protoc_insertion_point(message:dota.CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCardInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo.player_card_item_id)
        pub player_card_item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo.packed_bonuses)
        pub packed_bonuses: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCardInfo {
        fn default() -> &'a PlayerCardInfo {
            <PlayerCardInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCardInfo {
        pub fn new() -> PlayerCardInfo {
            ::std::default::Default::default()
        }

        // optional uint64 player_card_item_id = 1;

        pub fn player_card_item_id(&self) -> u64 {
            self.player_card_item_id.unwrap_or(0)
        }

        pub fn clear_player_card_item_id(&mut self) {
            self.player_card_item_id = ::std::option::Option::None;
        }

        pub fn has_player_card_item_id(&self) -> bool {
            self.player_card_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_card_item_id(&mut self, v: u64) {
            self.player_card_item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 2;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint64 packed_bonuses = 3;

        pub fn packed_bonuses(&self) -> u64 {
            self.packed_bonuses.unwrap_or(0)
        }

        pub fn clear_packed_bonuses(&mut self) {
            self.packed_bonuses = ::std::option::Option::None;
        }

        pub fn has_packed_bonuses(&self) -> bool {
            self.packed_bonuses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packed_bonuses(&mut self, v: u64) {
            self.packed_bonuses = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_card_item_id",
                |m: &PlayerCardInfo| { &m.player_card_item_id },
                |m: &mut PlayerCardInfo| { &mut m.player_card_item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PlayerCardInfo| { &m.account_id },
                |m: &mut PlayerCardInfo| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "packed_bonuses",
                |m: &PlayerCardInfo| { &m.packed_bonuses },
                |m: &mut PlayerCardInfo| { &mut m.packed_bonuses },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerCardInfo>(
                "CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerCardInfo {
        const NAME: &'static str = "PlayerCardInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_card_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.packed_bonuses = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_card_item_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.packed_bonuses {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_card_item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.packed_bonuses {
                os.write_uint64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCardInfo {
            PlayerCardInfo::new()
        }

        fn clear(&mut self) {
            self.player_card_item_id = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.packed_bonuses = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCardInfo {
            static instance: PlayerCardInfo = PlayerCardInfo {
                player_card_item_id: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                packed_bonuses: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerCardInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerCardInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerCardInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CSODOTAMapLocationState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAMapLocationState {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTAMapLocationState.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAMapLocationState.location_id)
    pub location_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CSODOTAMapLocationState.completed)
    pub completed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAMapLocationState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAMapLocationState {
    fn default() -> &'a CSODOTAMapLocationState {
        <CSODOTAMapLocationState as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAMapLocationState {
    pub fn new() -> CSODOTAMapLocationState {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 location_id = 2;

    pub fn location_id(&self) -> i32 {
        self.location_id.unwrap_or(0)
    }

    pub fn clear_location_id(&mut self) {
        self.location_id = ::std::option::Option::None;
    }

    pub fn has_location_id(&self) -> bool {
        self.location_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_id(&mut self, v: i32) {
        self.location_id = ::std::option::Option::Some(v);
    }

    // optional bool completed = 3;

    pub fn completed(&self) -> bool {
        self.completed.unwrap_or(false)
    }

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: bool) {
        self.completed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSODOTAMapLocationState| { &m.account_id },
            |m: &mut CSODOTAMapLocationState| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location_id",
            |m: &CSODOTAMapLocationState| { &m.location_id },
            |m: &mut CSODOTAMapLocationState| { &mut m.location_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "completed",
            |m: &CSODOTAMapLocationState| { &m.completed },
            |m: &mut CSODOTAMapLocationState| { &mut m.completed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAMapLocationState>(
            "CSODOTAMapLocationState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAMapLocationState {
    const NAME: &'static str = "CSODOTAMapLocationState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.location_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.completed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.location_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.completed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.location_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.completed {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAMapLocationState {
        CSODOTAMapLocationState::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.location_id = ::std::option::Option::None;
        self.completed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAMapLocationState {
        static instance: CSODOTAMapLocationState = CSODOTAMapLocationState {
            account_id: ::std::option::Option::None,
            location_id: ::std::option::Option::None,
            completed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAMapLocationState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAMapLocationState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAMapLocationState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAMapLocationState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgLeagueAdminList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeagueAdminList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLeagueAdminList.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLeagueAdminList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeagueAdminList {
    fn default() -> &'a CMsgLeagueAdminList {
        <CMsgLeagueAdminList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLeagueAdminList {
    pub fn new() -> CMsgLeagueAdminList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgLeagueAdminList| { &m.account_ids },
            |m: &mut CMsgLeagueAdminList| { &mut m.account_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLeagueAdminList>(
            "CMsgLeagueAdminList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLeagueAdminList {
    const NAME: &'static str = "CMsgLeagueAdminList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeagueAdminList {
        CMsgLeagueAdminList::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeagueAdminList {
        static instance: CMsgLeagueAdminList = CMsgLeagueAdminList {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLeagueAdminList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLeagueAdminList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLeagueAdminList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeagueAdminList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAProfileCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAProfileCard {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.slots)
    pub slots: ::std::vec::Vec<cmsg_dotaprofile_card::Slot>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.badge_points)
    pub badge_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.event_points)
    pub event_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.recent_battle_cup_victory)
    pub recent_battle_cup_victory: ::protobuf::MessageField<CMsgBattleCupVictory>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.rank_tier)
    pub rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.leaderboard_rank)
    pub leaderboard_rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.is_plus_subscriber)
    pub is_plus_subscriber: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.plus_original_start_date)
    pub plus_original_start_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.rank_tier_score)
    pub rank_tier_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.leaderboard_rank_core)
    pub leaderboard_rank_core: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.title)
    pub title: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.favorite_team_packed)
    pub favorite_team_packed: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.lifetime_games)
    pub lifetime_games: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAProfileCard.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAProfileCard {
    fn default() -> &'a CMsgDOTAProfileCard {
        <CMsgDOTAProfileCard as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAProfileCard {
    pub fn new() -> CMsgDOTAProfileCard {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_points = 4;

    pub fn badge_points(&self) -> u32 {
        self.badge_points.unwrap_or(0)
    }

    pub fn clear_badge_points(&mut self) {
        self.badge_points = ::std::option::Option::None;
    }

    pub fn has_badge_points(&self) -> bool {
        self.badge_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_points(&mut self, v: u32) {
        self.badge_points = ::std::option::Option::Some(v);
    }

    // optional uint32 event_points = 5;

    pub fn event_points(&self) -> u32 {
        self.event_points.unwrap_or(0)
    }

    pub fn clear_event_points(&mut self) {
        self.event_points = ::std::option::Option::None;
    }

    pub fn has_event_points(&self) -> bool {
        self.event_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_points(&mut self, v: u32) {
        self.event_points = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 6;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_tier = 8;

    pub fn rank_tier(&self) -> u32 {
        self.rank_tier.unwrap_or(0)
    }

    pub fn clear_rank_tier(&mut self) {
        self.rank_tier = ::std::option::Option::None;
    }

    pub fn has_rank_tier(&self) -> bool {
        self.rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_tier(&mut self, v: u32) {
        self.rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 leaderboard_rank = 9;

    pub fn leaderboard_rank(&self) -> u32 {
        self.leaderboard_rank.unwrap_or(0)
    }

    pub fn clear_leaderboard_rank(&mut self) {
        self.leaderboard_rank = ::std::option::Option::None;
    }

    pub fn has_leaderboard_rank(&self) -> bool {
        self.leaderboard_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_rank(&mut self, v: u32) {
        self.leaderboard_rank = ::std::option::Option::Some(v);
    }

    // optional bool is_plus_subscriber = 10;

    pub fn is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.unwrap_or(false)
    }

    pub fn clear_is_plus_subscriber(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
    }

    pub fn has_is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_subscriber(&mut self, v: bool) {
        self.is_plus_subscriber = ::std::option::Option::Some(v);
    }

    // optional uint32 plus_original_start_date = 11;

    pub fn plus_original_start_date(&self) -> u32 {
        self.plus_original_start_date.unwrap_or(0)
    }

    pub fn clear_plus_original_start_date(&mut self) {
        self.plus_original_start_date = ::std::option::Option::None;
    }

    pub fn has_plus_original_start_date(&self) -> bool {
        self.plus_original_start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plus_original_start_date(&mut self, v: u32) {
        self.plus_original_start_date = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_tier_score = 12;

    pub fn rank_tier_score(&self) -> u32 {
        self.rank_tier_score.unwrap_or(0)
    }

    pub fn clear_rank_tier_score(&mut self) {
        self.rank_tier_score = ::std::option::Option::None;
    }

    pub fn has_rank_tier_score(&self) -> bool {
        self.rank_tier_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_tier_score(&mut self, v: u32) {
        self.rank_tier_score = ::std::option::Option::Some(v);
    }

    // optional uint32 leaderboard_rank_core = 17;

    pub fn leaderboard_rank_core(&self) -> u32 {
        self.leaderboard_rank_core.unwrap_or(0)
    }

    pub fn clear_leaderboard_rank_core(&mut self) {
        self.leaderboard_rank_core = ::std::option::Option::None;
    }

    pub fn has_leaderboard_rank_core(&self) -> bool {
        self.leaderboard_rank_core.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_rank_core(&mut self, v: u32) {
        self.leaderboard_rank_core = ::std::option::Option::Some(v);
    }

    // optional uint32 title = 23;

    pub fn title(&self) -> u32 {
        self.title.unwrap_or(0)
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: u32) {
        self.title = ::std::option::Option::Some(v);
    }

    // optional uint64 favorite_team_packed = 24;

    pub fn favorite_team_packed(&self) -> u64 {
        self.favorite_team_packed.unwrap_or(0)
    }

    pub fn clear_favorite_team_packed(&mut self) {
        self.favorite_team_packed = ::std::option::Option::None;
    }

    pub fn has_favorite_team_packed(&self) -> bool {
        self.favorite_team_packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_packed(&mut self, v: u64) {
        self.favorite_team_packed = ::std::option::Option::Some(v);
    }

    // optional uint32 lifetime_games = 25;

    pub fn lifetime_games(&self) -> u32 {
        self.lifetime_games.unwrap_or(0)
    }

    pub fn clear_lifetime_games(&mut self) {
        self.lifetime_games = ::std::option::Option::None;
    }

    pub fn has_lifetime_games(&self) -> bool {
        self.lifetime_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_games(&mut self, v: u32) {
        self.lifetime_games = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgDOTAProfileCard| { &m.account_id },
            |m: &mut CMsgDOTAProfileCard| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "slots",
            |m: &CMsgDOTAProfileCard| { &m.slots },
            |m: &mut CMsgDOTAProfileCard| { &mut m.slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "badge_points",
            |m: &CMsgDOTAProfileCard| { &m.badge_points },
            |m: &mut CMsgDOTAProfileCard| { &mut m.badge_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_points",
            |m: &CMsgDOTAProfileCard| { &m.event_points },
            |m: &mut CMsgDOTAProfileCard| { &mut m.event_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgDOTAProfileCard| { &m.event_id },
            |m: &mut CMsgDOTAProfileCard| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleCupVictory>(
            "recent_battle_cup_victory",
            |m: &CMsgDOTAProfileCard| { &m.recent_battle_cup_victory },
            |m: &mut CMsgDOTAProfileCard| { &mut m.recent_battle_cup_victory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_tier",
            |m: &CMsgDOTAProfileCard| { &m.rank_tier },
            |m: &mut CMsgDOTAProfileCard| { &mut m.rank_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_rank",
            |m: &CMsgDOTAProfileCard| { &m.leaderboard_rank },
            |m: &mut CMsgDOTAProfileCard| { &mut m.leaderboard_rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_plus_subscriber",
            |m: &CMsgDOTAProfileCard| { &m.is_plus_subscriber },
            |m: &mut CMsgDOTAProfileCard| { &mut m.is_plus_subscriber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plus_original_start_date",
            |m: &CMsgDOTAProfileCard| { &m.plus_original_start_date },
            |m: &mut CMsgDOTAProfileCard| { &mut m.plus_original_start_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_tier_score",
            |m: &CMsgDOTAProfileCard| { &m.rank_tier_score },
            |m: &mut CMsgDOTAProfileCard| { &mut m.rank_tier_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_rank_core",
            |m: &CMsgDOTAProfileCard| { &m.leaderboard_rank_core },
            |m: &mut CMsgDOTAProfileCard| { &mut m.leaderboard_rank_core },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgDOTAProfileCard| { &m.title },
            |m: &mut CMsgDOTAProfileCard| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "favorite_team_packed",
            |m: &CMsgDOTAProfileCard| { &m.favorite_team_packed },
            |m: &mut CMsgDOTAProfileCard| { &mut m.favorite_team_packed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lifetime_games",
            |m: &CMsgDOTAProfileCard| { &m.lifetime_games },
            |m: &mut CMsgDOTAProfileCard| { &mut m.lifetime_games },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAProfileCard>(
            "CMsgDOTAProfileCard",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAProfileCard {
    const NAME: &'static str = "CMsgDOTAProfileCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.slots.push(is.read_message()?);
                },
                32 => {
                    self.badge_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.event_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_battle_cup_victory)?;
                },
                64 => {
                    self.rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.leaderboard_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.is_plus_subscriber = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.plus_original_start_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.rank_tier_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.leaderboard_rank_core = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.title = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.favorite_team_packed = ::std::option::Option::Some(is.read_uint64()?);
                },
                200 => {
                    self.lifetime_games = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.badge_points {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_points {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.recent_battle_cup_victory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rank_tier {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.leaderboard_rank {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.is_plus_subscriber {
            my_size += 1 + 1;
        }
        if let Some(v) = self.plus_original_start_date {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.rank_tier_score {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.leaderboard_rank_core {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.title {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.favorite_team_packed {
            my_size += ::protobuf::rt::uint64_size(24, v);
        }
        if let Some(v) = self.lifetime_games {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.slots {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.badge_points {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_points {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.recent_battle_cup_victory.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.rank_tier {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.leaderboard_rank {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.is_plus_subscriber {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.plus_original_start_date {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.rank_tier_score {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.leaderboard_rank_core {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.title {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.favorite_team_packed {
            os.write_uint64(24, v)?;
        }
        if let Some(v) = self.lifetime_games {
            os.write_uint32(25, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAProfileCard {
        CMsgDOTAProfileCard::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.slots.clear();
        self.badge_points = ::std::option::Option::None;
        self.event_points = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.recent_battle_cup_victory.clear();
        self.rank_tier = ::std::option::Option::None;
        self.leaderboard_rank = ::std::option::Option::None;
        self.is_plus_subscriber = ::std::option::Option::None;
        self.plus_original_start_date = ::std::option::Option::None;
        self.rank_tier_score = ::std::option::Option::None;
        self.leaderboard_rank_core = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.favorite_team_packed = ::std::option::Option::None;
        self.lifetime_games = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAProfileCard {
        static instance: CMsgDOTAProfileCard = CMsgDOTAProfileCard {
            account_id: ::std::option::Option::None,
            slots: ::std::vec::Vec::new(),
            badge_points: ::std::option::Option::None,
            event_points: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            recent_battle_cup_victory: ::protobuf::MessageField::none(),
            rank_tier: ::std::option::Option::None,
            leaderboard_rank: ::std::option::Option::None,
            is_plus_subscriber: ::std::option::Option::None,
            plus_original_start_date: ::std::option::Option::None,
            rank_tier_score: ::std::option::Option::None,
            leaderboard_rank_core: ::std::option::Option::None,
            title: ::std::option::Option::None,
            favorite_team_packed: ::std::option::Option::None,
            lifetime_games: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAProfileCard {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAProfileCard").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAProfileCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTAProfileCard`
pub mod cmsg_dotaprofile_card {
    // @@protoc_insertion_point(message:dota.CMsgDOTAProfileCard.Slot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Slot {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.trophy)
        pub trophy: ::protobuf::MessageField<slot::Trophy>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.stat)
        pub stat: ::protobuf::MessageField<slot::Stat>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.item)
        pub item: ::protobuf::MessageField<slot::Item>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.hero)
        pub hero: ::protobuf::MessageField<slot::Hero>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.emoticon)
        pub emoticon: ::protobuf::MessageField<slot::Emoticon>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.team)
        pub team: ::protobuf::MessageField<slot::Team>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAProfileCard.Slot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Slot {
        fn default() -> &'a Slot {
            <Slot as ::protobuf::Message>::default_instance()
        }
    }

    impl Slot {
        pub fn new() -> Slot {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot_id",
                |m: &Slot| { &m.slot_id },
                |m: &mut Slot| { &mut m.slot_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, slot::Trophy>(
                "trophy",
                |m: &Slot| { &m.trophy },
                |m: &mut Slot| { &mut m.trophy },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, slot::Stat>(
                "stat",
                |m: &Slot| { &m.stat },
                |m: &mut Slot| { &mut m.stat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, slot::Item>(
                "item",
                |m: &Slot| { &m.item },
                |m: &mut Slot| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, slot::Hero>(
                "hero",
                |m: &Slot| { &m.hero },
                |m: &mut Slot| { &mut m.hero },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, slot::Emoticon>(
                "emoticon",
                |m: &Slot| { &m.emoticon },
                |m: &mut Slot| { &mut m.emoticon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, slot::Team>(
                "team",
                |m: &Slot| { &m.team },
                |m: &mut Slot| { &mut m.team },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Slot>(
                "CMsgDOTAProfileCard.Slot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Slot {
        const NAME: &'static str = "Slot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.trophy)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stat)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.hero)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.emoticon)?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.team)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.trophy.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.stat.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.item.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.hero.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.emoticon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.team.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.trophy.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.stat.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.item.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.hero.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.emoticon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.team.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Slot {
            Slot::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.trophy.clear();
            self.stat.clear();
            self.item.clear();
            self.hero.clear();
            self.emoticon.clear();
            self.team.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Slot {
            static instance: Slot = Slot {
                slot_id: ::std::option::Option::None,
                trophy: ::protobuf::MessageField::none(),
                stat: ::protobuf::MessageField::none(),
                item: ::protobuf::MessageField::none(),
                hero: ::protobuf::MessageField::none(),
                emoticon: ::protobuf::MessageField::none(),
                team: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Slot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAProfileCard.Slot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Slot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Slot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Slot`
    pub mod slot {
        // @@protoc_insertion_point(message:dota.CMsgDOTAProfileCard.Slot.Trophy)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Trophy {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Trophy.trophy_id)
            pub trophy_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Trophy.trophy_score)
            pub trophy_score: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTAProfileCard.Slot.Trophy.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Trophy {
            fn default() -> &'a Trophy {
                <Trophy as ::protobuf::Message>::default_instance()
            }
        }

        impl Trophy {
            pub fn new() -> Trophy {
                ::std::default::Default::default()
            }

            // optional uint32 trophy_id = 1;

            pub fn trophy_id(&self) -> u32 {
                self.trophy_id.unwrap_or(0)
            }

            pub fn clear_trophy_id(&mut self) {
                self.trophy_id = ::std::option::Option::None;
            }

            pub fn has_trophy_id(&self) -> bool {
                self.trophy_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trophy_id(&mut self, v: u32) {
                self.trophy_id = ::std::option::Option::Some(v);
            }

            // optional uint32 trophy_score = 2;

            pub fn trophy_score(&self) -> u32 {
                self.trophy_score.unwrap_or(0)
            }

            pub fn clear_trophy_score(&mut self) {
                self.trophy_score = ::std::option::Option::None;
            }

            pub fn has_trophy_score(&self) -> bool {
                self.trophy_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trophy_score(&mut self, v: u32) {
                self.trophy_score = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "trophy_id",
                    |m: &Trophy| { &m.trophy_id },
                    |m: &mut Trophy| { &mut m.trophy_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "trophy_score",
                    |m: &Trophy| { &m.trophy_score },
                    |m: &mut Trophy| { &mut m.trophy_score },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Trophy>(
                    "CMsgDOTAProfileCard.Slot.Trophy",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Trophy {
            const NAME: &'static str = "Trophy";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.trophy_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.trophy_score = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.trophy_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.trophy_score {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.trophy_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.trophy_score {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Trophy {
                Trophy::new()
            }

            fn clear(&mut self) {
                self.trophy_id = ::std::option::Option::None;
                self.trophy_score = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Trophy {
                static instance: Trophy = Trophy {
                    trophy_id: ::std::option::Option::None,
                    trophy_score: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Trophy {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTAProfileCard.Slot.Trophy").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Trophy {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Trophy {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CMsgDOTAProfileCard.Slot.Stat)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Stat {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Stat.stat_id)
            pub stat_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::EStatID>>,
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Stat.stat_score)
            pub stat_score: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTAProfileCard.Slot.Stat.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Stat {
            fn default() -> &'a Stat {
                <Stat as ::protobuf::Message>::default_instance()
            }
        }

        impl Stat {
            pub fn new() -> Stat {
                ::std::default::Default::default()
            }

            // optional .dota.CMsgDOTAProfileCard.EStatID stat_id = 1;

            pub fn stat_id(&self) -> super::EStatID {
                match self.stat_id {
                    Some(e) => e.enum_value_or(super::EStatID::k_eStat_Wins),
                    None => super::EStatID::k_eStat_Wins,
                }
            }

            pub fn clear_stat_id(&mut self) {
                self.stat_id = ::std::option::Option::None;
            }

            pub fn has_stat_id(&self) -> bool {
                self.stat_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stat_id(&mut self, v: super::EStatID) {
                self.stat_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional uint32 stat_score = 2;

            pub fn stat_score(&self) -> u32 {
                self.stat_score.unwrap_or(0)
            }

            pub fn clear_stat_score(&mut self) {
                self.stat_score = ::std::option::Option::None;
            }

            pub fn has_stat_score(&self) -> bool {
                self.stat_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stat_score(&mut self, v: u32) {
                self.stat_score = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "stat_id",
                    |m: &Stat| { &m.stat_id },
                    |m: &mut Stat| { &mut m.stat_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "stat_score",
                    |m: &Stat| { &m.stat_score },
                    |m: &mut Stat| { &mut m.stat_score },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stat>(
                    "CMsgDOTAProfileCard.Slot.Stat",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Stat {
            const NAME: &'static str = "Stat";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.stat_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        16 => {
                            self.stat_score = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.stat_id {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                }
                if let Some(v) = self.stat_score {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.stat_id {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.stat_score {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Stat {
                Stat::new()
            }

            fn clear(&mut self) {
                self.stat_id = ::std::option::Option::None;
                self.stat_score = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Stat {
                static instance: Stat = Stat {
                    stat_id: ::std::option::Option::None,
                    stat_score: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Stat {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTAProfileCard.Slot.Stat").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Stat {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Stat {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CMsgDOTAProfileCard.Slot.Item)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Item {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Item.serialized_item)
            pub serialized_item: ::std::option::Option<::std::vec::Vec<u8>>,
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Item.item_id)
            pub item_id: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTAProfileCard.Slot.Item.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Item {
            fn default() -> &'a Item {
                <Item as ::protobuf::Message>::default_instance()
            }
        }

        impl Item {
            pub fn new() -> Item {
                ::std::default::Default::default()
            }

            // optional bytes serialized_item = 1;

            pub fn serialized_item(&self) -> &[u8] {
                match self.serialized_item.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_serialized_item(&mut self) {
                self.serialized_item = ::std::option::Option::None;
            }

            pub fn has_serialized_item(&self) -> bool {
                self.serialized_item.is_some()
            }

            // Param is passed by value, moved
            pub fn set_serialized_item(&mut self, v: ::std::vec::Vec<u8>) {
                self.serialized_item = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_serialized_item(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.serialized_item.is_none() {
                    self.serialized_item = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.serialized_item.as_mut().unwrap()
            }

            // Take field
            pub fn take_serialized_item(&mut self) -> ::std::vec::Vec<u8> {
                self.serialized_item.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            // optional uint64 item_id = 2;

            pub fn item_id(&self) -> u64 {
                self.item_id.unwrap_or(0)
            }

            pub fn clear_item_id(&mut self) {
                self.item_id = ::std::option::Option::None;
            }

            pub fn has_item_id(&self) -> bool {
                self.item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item_id(&mut self, v: u64) {
                self.item_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "serialized_item",
                    |m: &Item| { &m.serialized_item },
                    |m: &mut Item| { &mut m.serialized_item },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "item_id",
                    |m: &Item| { &m.item_id },
                    |m: &mut Item| { &mut m.item_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
                    "CMsgDOTAProfileCard.Slot.Item",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Item {
            const NAME: &'static str = "Item";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.serialized_item = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        16 => {
                            self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.serialized_item.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                }
                if let Some(v) = self.item_id {
                    my_size += ::protobuf::rt::uint64_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.serialized_item.as_ref() {
                    os.write_bytes(1, v)?;
                }
                if let Some(v) = self.item_id {
                    os.write_uint64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Item {
                Item::new()
            }

            fn clear(&mut self) {
                self.serialized_item = ::std::option::Option::None;
                self.item_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Item {
                static instance: Item = Item {
                    serialized_item: ::std::option::Option::None,
                    item_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Item {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTAProfileCard.Slot.Item").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Item {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Item {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CMsgDOTAProfileCard.Slot.Hero)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Hero {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Hero.hero_id)
            pub hero_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Hero.hero_wins)
            pub hero_wins: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Hero.hero_losses)
            pub hero_losses: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTAProfileCard.Slot.Hero.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Hero {
            fn default() -> &'a Hero {
                <Hero as ::protobuf::Message>::default_instance()
            }
        }

        impl Hero {
            pub fn new() -> Hero {
                ::std::default::Default::default()
            }

            // optional uint32 hero_id = 1;

            pub fn hero_id(&self) -> u32 {
                self.hero_id.unwrap_or(0)
            }

            pub fn clear_hero_id(&mut self) {
                self.hero_id = ::std::option::Option::None;
            }

            pub fn has_hero_id(&self) -> bool {
                self.hero_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_id(&mut self, v: u32) {
                self.hero_id = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_wins = 2;

            pub fn hero_wins(&self) -> u32 {
                self.hero_wins.unwrap_or(0)
            }

            pub fn clear_hero_wins(&mut self) {
                self.hero_wins = ::std::option::Option::None;
            }

            pub fn has_hero_wins(&self) -> bool {
                self.hero_wins.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_wins(&mut self, v: u32) {
                self.hero_wins = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_losses = 3;

            pub fn hero_losses(&self) -> u32 {
                self.hero_losses.unwrap_or(0)
            }

            pub fn clear_hero_losses(&mut self) {
                self.hero_losses = ::std::option::Option::None;
            }

            pub fn has_hero_losses(&self) -> bool {
                self.hero_losses.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_losses(&mut self, v: u32) {
                self.hero_losses = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_id",
                    |m: &Hero| { &m.hero_id },
                    |m: &mut Hero| { &mut m.hero_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_wins",
                    |m: &Hero| { &m.hero_wins },
                    |m: &mut Hero| { &mut m.hero_wins },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_losses",
                    |m: &Hero| { &m.hero_losses },
                    |m: &mut Hero| { &mut m.hero_losses },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hero>(
                    "CMsgDOTAProfileCard.Slot.Hero",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Hero {
            const NAME: &'static str = "Hero";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.hero_wins = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.hero_losses = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.hero_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.hero_wins {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.hero_losses {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.hero_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.hero_wins {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.hero_losses {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Hero {
                Hero::new()
            }

            fn clear(&mut self) {
                self.hero_id = ::std::option::Option::None;
                self.hero_wins = ::std::option::Option::None;
                self.hero_losses = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Hero {
                static instance: Hero = Hero {
                    hero_id: ::std::option::Option::None,
                    hero_wins: ::std::option::Option::None,
                    hero_losses: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Hero {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTAProfileCard.Slot.Hero").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Hero {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Hero {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CMsgDOTAProfileCard.Slot.Emoticon)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Emoticon {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Emoticon.emoticon_id)
            pub emoticon_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTAProfileCard.Slot.Emoticon.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Emoticon {
            fn default() -> &'a Emoticon {
                <Emoticon as ::protobuf::Message>::default_instance()
            }
        }

        impl Emoticon {
            pub fn new() -> Emoticon {
                ::std::default::Default::default()
            }

            // optional uint32 emoticon_id = 1;

            pub fn emoticon_id(&self) -> u32 {
                self.emoticon_id.unwrap_or(0)
            }

            pub fn clear_emoticon_id(&mut self) {
                self.emoticon_id = ::std::option::Option::None;
            }

            pub fn has_emoticon_id(&self) -> bool {
                self.emoticon_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_emoticon_id(&mut self, v: u32) {
                self.emoticon_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "emoticon_id",
                    |m: &Emoticon| { &m.emoticon_id },
                    |m: &mut Emoticon| { &mut m.emoticon_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Emoticon>(
                    "CMsgDOTAProfileCard.Slot.Emoticon",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Emoticon {
            const NAME: &'static str = "Emoticon";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.emoticon_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.emoticon_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.emoticon_id {
                    os.write_uint32(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Emoticon {
                Emoticon::new()
            }

            fn clear(&mut self) {
                self.emoticon_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Emoticon {
                static instance: Emoticon = Emoticon {
                    emoticon_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Emoticon {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTAProfileCard.Slot.Emoticon").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Emoticon {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Emoticon {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CMsgDOTAProfileCard.Slot.Team)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Team {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTAProfileCard.Slot.Team.team_id)
            pub team_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTAProfileCard.Slot.Team.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Team {
            fn default() -> &'a Team {
                <Team as ::protobuf::Message>::default_instance()
            }
        }

        impl Team {
            pub fn new() -> Team {
                ::std::default::Default::default()
            }

            // optional uint32 team_id = 1;

            pub fn team_id(&self) -> u32 {
                self.team_id.unwrap_or(0)
            }

            pub fn clear_team_id(&mut self) {
                self.team_id = ::std::option::Option::None;
            }

            pub fn has_team_id(&self) -> bool {
                self.team_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_id(&mut self, v: u32) {
                self.team_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_id",
                    |m: &Team| { &m.team_id },
                    |m: &mut Team| { &mut m.team_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Team>(
                    "CMsgDOTAProfileCard.Slot.Team",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Team {
            const NAME: &'static str = "Team";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.team_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.team_id {
                    os.write_uint32(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Team {
                Team::new()
            }

            fn clear(&mut self) {
                self.team_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Team {
                static instance: Team = Team {
                    team_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Team {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTAProfileCard.Slot.Team").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Team {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Team {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgDOTAProfileCard.EStatID)
    pub enum EStatID {
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTAProfileCard.EStatID.k_eStat_Wins)
        k_eStat_Wins = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTAProfileCard.EStatID.k_eStat_Commends)
        k_eStat_Commends = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTAProfileCard.EStatID.k_eStat_GamesPlayed)
        k_eStat_GamesPlayed = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTAProfileCard.EStatID.k_eStat_FirstMatchDate)
        k_eStat_FirstMatchDate = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTAProfileCard.EStatID.k_eStat_PreviousSeasonRank)
        k_eStat_PreviousSeasonRank = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTAProfileCard.EStatID.k_eStat_GamesMVP)
        k_eStat_GamesMVP = 8,
    }

    impl ::protobuf::Enum for EStatID {
        const NAME: &'static str = "EStatID";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EStatID> {
            match value {
                3 => ::std::option::Option::Some(EStatID::k_eStat_Wins),
                4 => ::std::option::Option::Some(EStatID::k_eStat_Commends),
                5 => ::std::option::Option::Some(EStatID::k_eStat_GamesPlayed),
                6 => ::std::option::Option::Some(EStatID::k_eStat_FirstMatchDate),
                7 => ::std::option::Option::Some(EStatID::k_eStat_PreviousSeasonRank),
                8 => ::std::option::Option::Some(EStatID::k_eStat_GamesMVP),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EStatID> {
            match str {
                "k_eStat_Wins" => ::std::option::Option::Some(EStatID::k_eStat_Wins),
                "k_eStat_Commends" => ::std::option::Option::Some(EStatID::k_eStat_Commends),
                "k_eStat_GamesPlayed" => ::std::option::Option::Some(EStatID::k_eStat_GamesPlayed),
                "k_eStat_FirstMatchDate" => ::std::option::Option::Some(EStatID::k_eStat_FirstMatchDate),
                "k_eStat_PreviousSeasonRank" => ::std::option::Option::Some(EStatID::k_eStat_PreviousSeasonRank),
                "k_eStat_GamesMVP" => ::std::option::Option::Some(EStatID::k_eStat_GamesMVP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EStatID] = &[
            EStatID::k_eStat_Wins,
            EStatID::k_eStat_Commends,
            EStatID::k_eStat_GamesPlayed,
            EStatID::k_eStat_FirstMatchDate,
            EStatID::k_eStat_PreviousSeasonRank,
            EStatID::k_eStat_GamesMVP,
        ];
    }

    impl ::protobuf::EnumFull for EStatID {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgDOTAProfileCard.EStatID").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                EStatID::k_eStat_Wins => 0,
                EStatID::k_eStat_Commends => 1,
                EStatID::k_eStat_GamesPlayed => 2,
                EStatID::k_eStat_FirstMatchDate => 3,
                EStatID::k_eStat_PreviousSeasonRank => 4,
                EStatID::k_eStat_GamesMVP => 5,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EStatID {
        fn default() -> Self {
            EStatID::k_eStat_Wins
        }
    }

    impl EStatID {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStatID>("CMsgDOTAProfileCard.EStatID")
        }
    }
}

// @@protoc_insertion_point(message:dota.CSODOTAPlayerChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAPlayerChallenge {
    // message fields
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.int_param_0)
    pub int_param_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.int_param_1)
    pub int_param_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.created_time)
    pub created_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.completed)
    pub completed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.sequence_id)
    pub sequence_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.challenge_tier)
    pub challenge_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.attempts)
    pub attempts: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.complete_limit)
    pub complete_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.quest_rank)
    pub quest_rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.max_quest_rank)
    pub max_quest_rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.instance_id)
    pub instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSODOTAPlayerChallenge.template_id)
    pub template_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSODOTAPlayerChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAPlayerChallenge {
    fn default() -> &'a CSODOTAPlayerChallenge {
        <CSODOTAPlayerChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CSODOTAPlayerChallenge {
    pub fn new() -> CSODOTAPlayerChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 3;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 int_param_0 = 5;

    pub fn int_param_0(&self) -> u32 {
        self.int_param_0.unwrap_or(0)
    }

    pub fn clear_int_param_0(&mut self) {
        self.int_param_0 = ::std::option::Option::None;
    }

    pub fn has_int_param_0(&self) -> bool {
        self.int_param_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param_0(&mut self, v: u32) {
        self.int_param_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 int_param_1 = 6;

    pub fn int_param_1(&self) -> u32 {
        self.int_param_1.unwrap_or(0)
    }

    pub fn clear_int_param_1(&mut self) {
        self.int_param_1 = ::std::option::Option::None;
    }

    pub fn has_int_param_1(&self) -> bool {
        self.int_param_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param_1(&mut self, v: u32) {
        self.int_param_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 created_time = 7;

    pub fn created_time(&self) -> u32 {
        self.created_time.unwrap_or(0)
    }

    pub fn clear_created_time(&mut self) {
        self.created_time = ::std::option::Option::None;
    }

    pub fn has_created_time(&self) -> bool {
        self.created_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_time(&mut self, v: u32) {
        self.created_time = ::std::option::Option::Some(v);
    }

    // optional uint32 completed = 8;

    pub fn completed(&self) -> u32 {
        self.completed.unwrap_or(0)
    }

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: u32) {
        self.completed = ::std::option::Option::Some(v);
    }

    // optional uint32 sequence_id = 9;

    pub fn sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_tier = 10;

    pub fn challenge_tier(&self) -> u32 {
        self.challenge_tier.unwrap_or(0)
    }

    pub fn clear_challenge_tier(&mut self) {
        self.challenge_tier = ::std::option::Option::None;
    }

    pub fn has_challenge_tier(&self) -> bool {
        self.challenge_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_tier(&mut self, v: u32) {
        self.challenge_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 11;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 attempts = 12;

    pub fn attempts(&self) -> u32 {
        self.attempts.unwrap_or(0)
    }

    pub fn clear_attempts(&mut self) {
        self.attempts = ::std::option::Option::None;
    }

    pub fn has_attempts(&self) -> bool {
        self.attempts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attempts(&mut self, v: u32) {
        self.attempts = ::std::option::Option::Some(v);
    }

    // optional uint32 complete_limit = 13;

    pub fn complete_limit(&self) -> u32 {
        self.complete_limit.unwrap_or(0)
    }

    pub fn clear_complete_limit(&mut self) {
        self.complete_limit = ::std::option::Option::None;
    }

    pub fn has_complete_limit(&self) -> bool {
        self.complete_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_complete_limit(&mut self, v: u32) {
        self.complete_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_rank = 14;

    pub fn quest_rank(&self) -> u32 {
        self.quest_rank.unwrap_or(0)
    }

    pub fn clear_quest_rank(&mut self) {
        self.quest_rank = ::std::option::Option::None;
    }

    pub fn has_quest_rank(&self) -> bool {
        self.quest_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_rank(&mut self, v: u32) {
        self.quest_rank = ::std::option::Option::Some(v);
    }

    // optional uint32 max_quest_rank = 15;

    pub fn max_quest_rank(&self) -> u32 {
        self.max_quest_rank.unwrap_or(0)
    }

    pub fn clear_max_quest_rank(&mut self) {
        self.max_quest_rank = ::std::option::Option::None;
    }

    pub fn has_max_quest_rank(&self) -> bool {
        self.max_quest_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_quest_rank(&mut self, v: u32) {
        self.max_quest_rank = ::std::option::Option::Some(v);
    }

    // optional uint32 instance_id = 16;

    pub fn instance_id(&self) -> u32 {
        self.instance_id.unwrap_or(0)
    }

    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 17;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 template_id = 18;

    pub fn template_id(&self) -> u32 {
        self.template_id.unwrap_or(0)
    }

    pub fn clear_template_id(&mut self) {
        self.template_id = ::std::option::Option::None;
    }

    pub fn has_template_id(&self) -> bool {
        self.template_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_id(&mut self, v: u32) {
        self.template_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSODOTAPlayerChallenge| { &m.account_id },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CSODOTAPlayerChallenge| { &m.event_id },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_id",
            |m: &CSODOTAPlayerChallenge| { &m.slot_id },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.slot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_param_0",
            |m: &CSODOTAPlayerChallenge| { &m.int_param_0 },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.int_param_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_param_1",
            |m: &CSODOTAPlayerChallenge| { &m.int_param_1 },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.int_param_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "created_time",
            |m: &CSODOTAPlayerChallenge| { &m.created_time },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.created_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "completed",
            |m: &CSODOTAPlayerChallenge| { &m.completed },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_id",
            |m: &CSODOTAPlayerChallenge| { &m.sequence_id },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.sequence_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_tier",
            |m: &CSODOTAPlayerChallenge| { &m.challenge_tier },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.challenge_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSODOTAPlayerChallenge| { &m.flags },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attempts",
            |m: &CSODOTAPlayerChallenge| { &m.attempts },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.attempts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "complete_limit",
            |m: &CSODOTAPlayerChallenge| { &m.complete_limit },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.complete_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_rank",
            |m: &CSODOTAPlayerChallenge| { &m.quest_rank },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.quest_rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_quest_rank",
            |m: &CSODOTAPlayerChallenge| { &m.max_quest_rank },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.max_quest_rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "instance_id",
            |m: &CSODOTAPlayerChallenge| { &m.instance_id },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.instance_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CSODOTAPlayerChallenge| { &m.hero_id },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "template_id",
            |m: &CSODOTAPlayerChallenge| { &m.template_id },
            |m: &mut CSODOTAPlayerChallenge| { &mut m.template_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSODOTAPlayerChallenge>(
            "CSODOTAPlayerChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSODOTAPlayerChallenge {
    const NAME: &'static str = "CSODOTAPlayerChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.int_param_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.int_param_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.created_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.completed = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.challenge_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.attempts = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.complete_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.quest_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.max_quest_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.template_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.int_param_0 {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.int_param_1 {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.created_time {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.completed {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.challenge_tier {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.attempts {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.complete_limit {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.quest_rank {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.max_quest_rank {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.instance_id {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.template_id {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.int_param_0 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.int_param_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.created_time {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.completed {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.challenge_tier {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.attempts {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.complete_limit {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.quest_rank {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.max_quest_rank {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.template_id {
            os.write_uint32(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAPlayerChallenge {
        CSODOTAPlayerChallenge::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.int_param_0 = ::std::option::Option::None;
        self.int_param_1 = ::std::option::Option::None;
        self.created_time = ::std::option::Option::None;
        self.completed = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.challenge_tier = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.attempts = ::std::option::Option::None;
        self.complete_limit = ::std::option::Option::None;
        self.quest_rank = ::std::option::Option::None;
        self.max_quest_rank = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.template_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAPlayerChallenge {
        static instance: CSODOTAPlayerChallenge = CSODOTAPlayerChallenge {
            account_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            int_param_0: ::std::option::Option::None,
            int_param_1: ::std::option::Option::None,
            created_time: ::std::option::Option::None,
            completed: ::std::option::Option::None,
            sequence_id: ::std::option::Option::None,
            challenge_tier: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            attempts: ::std::option::Option::None,
            complete_limit: ::std::option::Option::None,
            quest_rank: ::std::option::Option::None,
            max_quest_rank: ::std::option::Option::None,
            instance_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            template_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSODOTAPlayerChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSODOTAPlayerChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSODOTAPlayerChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAPlayerChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRerollPlayerChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRerollPlayerChallenge {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRerollPlayerChallenge.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRerollPlayerChallenge.sequence_id)
    pub sequence_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRerollPlayerChallenge.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRerollPlayerChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRerollPlayerChallenge {
    fn default() -> &'a CMsgClientToGCRerollPlayerChallenge {
        <CMsgClientToGCRerollPlayerChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRerollPlayerChallenge {
    pub fn new() -> CMsgClientToGCRerollPlayerChallenge {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 sequence_id = 3;

    pub fn sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 4;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgClientToGCRerollPlayerChallenge| { &m.event_id },
            |m: &mut CMsgClientToGCRerollPlayerChallenge| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_id",
            |m: &CMsgClientToGCRerollPlayerChallenge| { &m.sequence_id },
            |m: &mut CMsgClientToGCRerollPlayerChallenge| { &mut m.sequence_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgClientToGCRerollPlayerChallenge| { &m.hero_id },
            |m: &mut CMsgClientToGCRerollPlayerChallenge| { &mut m.hero_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRerollPlayerChallenge>(
            "CMsgClientToGCRerollPlayerChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRerollPlayerChallenge {
    const NAME: &'static str = "CMsgClientToGCRerollPlayerChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRerollPlayerChallenge {
        CMsgClientToGCRerollPlayerChallenge::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRerollPlayerChallenge {
        static instance: CMsgClientToGCRerollPlayerChallenge = CMsgClientToGCRerollPlayerChallenge {
            event_id: ::std::option::Option::None,
            sequence_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRerollPlayerChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRerollPlayerChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRerollPlayerChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRerollPlayerChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCRerollPlayerChallengeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRerollPlayerChallengeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCRerollPlayerChallengeResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_gcreroll_player_challenge_response::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCRerollPlayerChallengeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRerollPlayerChallengeResponse {
    fn default() -> &'a CMsgGCRerollPlayerChallengeResponse {
        <CMsgGCRerollPlayerChallengeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRerollPlayerChallengeResponse {
    pub fn new() -> CMsgGCRerollPlayerChallengeResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgGCRerollPlayerChallengeResponse.EResult result = 1;

    pub fn result(&self) -> cmsg_gcreroll_player_challenge_response::EResult {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_gcreroll_player_challenge_response::EResult::eResult_Success),
            None => cmsg_gcreroll_player_challenge_response::EResult::eResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_gcreroll_player_challenge_response::EResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCRerollPlayerChallengeResponse| { &m.result },
            |m: &mut CMsgGCRerollPlayerChallengeResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRerollPlayerChallengeResponse>(
            "CMsgGCRerollPlayerChallengeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRerollPlayerChallengeResponse {
    const NAME: &'static str = "CMsgGCRerollPlayerChallengeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRerollPlayerChallengeResponse {
        CMsgGCRerollPlayerChallengeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRerollPlayerChallengeResponse {
        static instance: CMsgGCRerollPlayerChallengeResponse = CMsgGCRerollPlayerChallengeResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRerollPlayerChallengeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRerollPlayerChallengeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRerollPlayerChallengeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRerollPlayerChallengeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCRerollPlayerChallengeResponse`
pub mod cmsg_gcreroll_player_challenge_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgGCRerollPlayerChallengeResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:dota.CMsgGCRerollPlayerChallengeResponse.EResult.eResult_Success)
        eResult_Success = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgGCRerollPlayerChallengeResponse.EResult.eResult_Dropped)
        eResult_Dropped = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgGCRerollPlayerChallengeResponse.EResult.eResult_NotFound)
        eResult_NotFound = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgGCRerollPlayerChallengeResponse.EResult.eResult_CantReroll)
        eResult_CantReroll = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgGCRerollPlayerChallengeResponse.EResult.eResult_ServerError)
        eResult_ServerError = 4,
    }

    impl ::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::eResult_Success),
                1 => ::std::option::Option::Some(EResult::eResult_Dropped),
                2 => ::std::option::Option::Some(EResult::eResult_NotFound),
                3 => ::std::option::Option::Some(EResult::eResult_CantReroll),
                4 => ::std::option::Option::Some(EResult::eResult_ServerError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "eResult_Success" => ::std::option::Option::Some(EResult::eResult_Success),
                "eResult_Dropped" => ::std::option::Option::Some(EResult::eResult_Dropped),
                "eResult_NotFound" => ::std::option::Option::Some(EResult::eResult_NotFound),
                "eResult_CantReroll" => ::std::option::Option::Some(EResult::eResult_CantReroll),
                "eResult_ServerError" => ::std::option::Option::Some(EResult::eResult_ServerError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::eResult_Success,
            EResult::eResult_Dropped,
            EResult::eResult_NotFound,
            EResult::eResult_CantReroll,
            EResult::eResult_ServerError,
        ];
    }

    impl ::protobuf::EnumFull for EResult {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGCRerollPlayerChallengeResponse.EResult").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::eResult_Success
        }
    }

    impl EResult {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResult>("CMsgGCRerollPlayerChallengeResponse.EResult")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCTopCustomGamesList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCTopCustomGamesList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCTopCustomGamesList.top_custom_games)
    pub top_custom_games: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCTopCustomGamesList.game_of_the_day)
    pub game_of_the_day: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCTopCustomGamesList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCTopCustomGamesList {
    fn default() -> &'a CMsgGCTopCustomGamesList {
        <CMsgGCTopCustomGamesList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCTopCustomGamesList {
    pub fn new() -> CMsgGCTopCustomGamesList {
        ::std::default::Default::default()
    }

    // optional uint64 game_of_the_day = 2;

    pub fn game_of_the_day(&self) -> u64 {
        self.game_of_the_day.unwrap_or(0)
    }

    pub fn clear_game_of_the_day(&mut self) {
        self.game_of_the_day = ::std::option::Option::None;
    }

    pub fn has_game_of_the_day(&self) -> bool {
        self.game_of_the_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_of_the_day(&mut self, v: u64) {
        self.game_of_the_day = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "top_custom_games",
            |m: &CMsgGCTopCustomGamesList| { &m.top_custom_games },
            |m: &mut CMsgGCTopCustomGamesList| { &mut m.top_custom_games },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_of_the_day",
            |m: &CMsgGCTopCustomGamesList| { &m.game_of_the_day },
            |m: &mut CMsgGCTopCustomGamesList| { &mut m.game_of_the_day },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCTopCustomGamesList>(
            "CMsgGCTopCustomGamesList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCTopCustomGamesList {
    const NAME: &'static str = "CMsgGCTopCustomGamesList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.top_custom_games)?;
                },
                8 => {
                    self.top_custom_games.push(is.read_uint64()?);
                },
                16 => {
                    self.game_of_the_day = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.top_custom_games {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        if let Some(v) = self.game_of_the_day {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.top_custom_games {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.game_of_the_day {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCTopCustomGamesList {
        CMsgGCTopCustomGamesList::new()
    }

    fn clear(&mut self) {
        self.top_custom_games.clear();
        self.game_of_the_day = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCTopCustomGamesList {
        static instance: CMsgGCTopCustomGamesList = CMsgGCTopCustomGamesList {
            top_custom_games: ::std::vec::Vec::new(),
            game_of_the_day: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCTopCustomGamesList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCTopCustomGamesList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCTopCustomGamesList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCTopCustomGamesList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTARealtimeGameStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.match)
    pub match_: ::protobuf::MessageField<cmsg_dotarealtime_game_stats::MatchDetails>,
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.teams)
    pub teams: ::std::vec::Vec<cmsg_dotarealtime_game_stats::TeamDetails>,
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.buildings)
    pub buildings: ::std::vec::Vec<cmsg_dotarealtime_game_stats::BuildingDetails>,
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.graph_data)
    pub graph_data: ::protobuf::MessageField<cmsg_dotarealtime_game_stats::GraphData>,
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.delta_frame)
    pub delta_frame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTARealtimeGameStats {
    fn default() -> &'a CMsgDOTARealtimeGameStats {
        <CMsgDOTARealtimeGameStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTARealtimeGameStats {
    pub fn new() -> CMsgDOTARealtimeGameStats {
        ::std::default::Default::default()
    }

    // optional bool delta_frame = 5;

    pub fn delta_frame(&self) -> bool {
        self.delta_frame.unwrap_or(false)
    }

    pub fn clear_delta_frame(&mut self) {
        self.delta_frame = ::std::option::Option::None;
    }

    pub fn has_delta_frame(&self) -> bool {
        self.delta_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_frame(&mut self, v: bool) {
        self.delta_frame = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotarealtime_game_stats::MatchDetails>(
            "match",
            |m: &CMsgDOTARealtimeGameStats| { &m.match_ },
            |m: &mut CMsgDOTARealtimeGameStats| { &mut m.match_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CMsgDOTARealtimeGameStats| { &m.teams },
            |m: &mut CMsgDOTARealtimeGameStats| { &mut m.teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buildings",
            |m: &CMsgDOTARealtimeGameStats| { &m.buildings },
            |m: &mut CMsgDOTARealtimeGameStats| { &mut m.buildings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotarealtime_game_stats::GraphData>(
            "graph_data",
            |m: &CMsgDOTARealtimeGameStats| { &m.graph_data },
            |m: &mut CMsgDOTARealtimeGameStats| { &mut m.graph_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta_frame",
            |m: &CMsgDOTARealtimeGameStats| { &m.delta_frame },
            |m: &mut CMsgDOTARealtimeGameStats| { &mut m.delta_frame },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTARealtimeGameStats>(
            "CMsgDOTARealtimeGameStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats {
    const NAME: &'static str = "CMsgDOTARealtimeGameStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_)?;
                },
                18 => {
                    self.teams.push(is.read_message()?);
                },
                26 => {
                    self.buildings.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.graph_data)?;
                },
                40 => {
                    self.delta_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.graph_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.delta_frame {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.buildings {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.graph_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.delta_frame {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTARealtimeGameStats {
        CMsgDOTARealtimeGameStats::new()
    }

    fn clear(&mut self) {
        self.match_.clear();
        self.teams.clear();
        self.buildings.clear();
        self.graph_data.clear();
        self.delta_frame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTARealtimeGameStats {
        static instance: CMsgDOTARealtimeGameStats = CMsgDOTARealtimeGameStats {
            match_: ::protobuf::MessageField::none(),
            teams: ::std::vec::Vec::new(),
            buildings: ::std::vec::Vec::new(),
            graph_data: ::protobuf::MessageField::none(),
            delta_frame: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTARealtimeGameStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTARealtimeGameStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTARealtimeGameStats`
pub mod cmsg_dotarealtime_game_stats {
    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.TeamDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.team_number)
        pub team_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.team_tag)
        pub team_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.players)
        pub players: ::std::vec::Vec<PlayerDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.only_team)
        pub only_team: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.cheers)
        pub cheers: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.TeamDetails.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.TeamDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamDetails {
        fn default() -> &'a TeamDetails {
            <TeamDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamDetails {
        pub fn new() -> TeamDetails {
            ::std::default::Default::default()
        }

        // optional uint32 team_number = 1;

        pub fn team_number(&self) -> u32 {
            self.team_number.unwrap_or(0)
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: u32) {
            self.team_number = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 3;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 team_logo = 4;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional string team_tag = 10;

        pub fn team_tag(&self) -> &str {
            match self.team_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_tag(&mut self) {
            self.team_tag = ::std::option::Option::None;
        }

        pub fn has_team_tag(&self) -> bool {
            self.team_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_tag(&mut self, v: ::std::string::String) {
            self.team_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
            if self.team_tag.is_none() {
                self.team_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_tag(&mut self) -> ::std::string::String {
            self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 score = 5;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 9;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional bool only_team = 7;

        pub fn only_team(&self) -> bool {
            self.only_team.unwrap_or(false)
        }

        pub fn clear_only_team(&mut self) {
            self.only_team = ::std::option::Option::None;
        }

        pub fn has_only_team(&self) -> bool {
            self.only_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_only_team(&mut self, v: bool) {
            self.only_team = ::std::option::Option::Some(v);
        }

        // optional uint32 cheers = 8;

        pub fn cheers(&self) -> u32 {
            self.cheers.unwrap_or(0)
        }

        pub fn clear_cheers(&mut self) {
            self.cheers = ::std::option::Option::None;
        }

        pub fn has_cheers(&self) -> bool {
            self.cheers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cheers(&mut self, v: u32) {
            self.cheers = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 11;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_number",
                |m: &TeamDetails| { &m.team_number },
                |m: &mut TeamDetails| { &mut m.team_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &TeamDetails| { &m.team_id },
                |m: &mut TeamDetails| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_name",
                |m: &TeamDetails| { &m.team_name },
                |m: &mut TeamDetails| { &mut m.team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo",
                |m: &TeamDetails| { &m.team_logo },
                |m: &mut TeamDetails| { &mut m.team_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_tag",
                |m: &TeamDetails| { &m.team_tag },
                |m: &mut TeamDetails| { &mut m.team_tag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &TeamDetails| { &m.score },
                |m: &mut TeamDetails| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "net_worth",
                |m: &TeamDetails| { &m.net_worth },
                |m: &mut TeamDetails| { &mut m.net_worth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "players",
                |m: &TeamDetails| { &m.players },
                |m: &mut TeamDetails| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "only_team",
                |m: &TeamDetails| { &m.only_team },
                |m: &mut TeamDetails| { &mut m.only_team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cheers",
                |m: &TeamDetails| { &m.cheers },
                |m: &mut TeamDetails| { &mut m.cheers },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo_url",
                |m: &TeamDetails| { &m.team_logo_url },
                |m: &mut TeamDetails| { &mut m.team_logo_url },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamDetails>(
                "CMsgDOTARealtimeGameStats.TeamDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamDetails {
        const NAME: &'static str = "TeamDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    82 => {
                        self.team_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.players.push(is.read_message()?);
                    },
                    56 => {
                        self.only_team = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.cheers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    90 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_number {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += 1 + 8;
            }
            if let Some(v) = self.team_tag.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.only_team {
                my_size += 1 + 1;
            }
            if let Some(v) = self.cheers {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::protobuf::rt::string_size(11, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team_number {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.team_tag.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(9, v)?;
            }
            for v in &self.players {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.only_team {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.cheers {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamDetails {
            TeamDetails::new()
        }

        fn clear(&mut self) {
            self.team_number = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.team_tag = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.players.clear();
            self.only_team = ::std::option::Option::None;
            self.cheers = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamDetails {
            static instance: TeamDetails = TeamDetails {
                team_number: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                team_tag: ::std::option::Option::None,
                score: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                players: ::std::vec::Vec::new(),
                only_team: ::std::option::Option::None,
                cheers: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.TeamDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.ItemDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.ItemDetails.item_ability_id)
        pub item_ability_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.ItemDetails.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.ItemDetails.time)
        pub time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.ItemDetails.sold)
        pub sold: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.ItemDetails.stackcount)
        pub stackcount: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.ItemDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDetails {
        fn default() -> &'a ItemDetails {
            <ItemDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemDetails {
        pub fn new() -> ItemDetails {
            ::std::default::Default::default()
        }

        // optional int32 item_ability_id = 1;

        pub fn item_ability_id(&self) -> i32 {
            self.item_ability_id.unwrap_or(0)
        }

        pub fn clear_item_ability_id(&mut self) {
            self.item_ability_id = ::std::option::Option::None;
        }

        pub fn has_item_ability_id(&self) -> bool {
            self.item_ability_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_ability_id(&mut self, v: i32) {
            self.item_ability_id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 time = 3;

        pub fn time(&self) -> i32 {
            self.time.unwrap_or(0)
        }

        pub fn clear_time(&mut self) {
            self.time = ::std::option::Option::None;
        }

        pub fn has_time(&self) -> bool {
            self.time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time(&mut self, v: i32) {
            self.time = ::std::option::Option::Some(v);
        }

        // optional bool sold = 4;

        pub fn sold(&self) -> bool {
            self.sold.unwrap_or(false)
        }

        pub fn clear_sold(&mut self) {
            self.sold = ::std::option::Option::None;
        }

        pub fn has_sold(&self) -> bool {
            self.sold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sold(&mut self, v: bool) {
            self.sold = ::std::option::Option::Some(v);
        }

        // optional uint32 stackcount = 5;

        pub fn stackcount(&self) -> u32 {
            self.stackcount.unwrap_or(0)
        }

        pub fn clear_stackcount(&mut self) {
            self.stackcount = ::std::option::Option::None;
        }

        pub fn has_stackcount(&self) -> bool {
            self.stackcount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stackcount(&mut self, v: u32) {
            self.stackcount = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_ability_id",
                |m: &ItemDetails| { &m.item_ability_id },
                |m: &mut ItemDetails| { &mut m.item_ability_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &ItemDetails| { &m.name },
                |m: &mut ItemDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time",
                |m: &ItemDetails| { &m.time },
                |m: &mut ItemDetails| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sold",
                |m: &ItemDetails| { &m.sold },
                |m: &mut ItemDetails| { &mut m.sold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stackcount",
                |m: &ItemDetails| { &m.stackcount },
                |m: &mut ItemDetails| { &mut m.stackcount },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemDetails>(
                "CMsgDOTARealtimeGameStats.ItemDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemDetails {
        const NAME: &'static str = "ItemDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.sold = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.stackcount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_ability_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.time {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.sold {
                my_size += 1 + 1;
            }
            if let Some(v) = self.stackcount {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_ability_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.time {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.sold {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.stackcount {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDetails {
            ItemDetails::new()
        }

        fn clear(&mut self) {
            self.item_ability_id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.time = ::std::option::Option::None;
            self.sold = ::std::option::Option::None;
            self.stackcount = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDetails {
            static instance: ItemDetails = ItemDetails {
                item_ability_id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                time: ::std::option::Option::None,
                sold: ::std::option::Option::None,
                stackcount: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.ItemDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.AbilityDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AbilityDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.AbilityDetails.id)
        pub id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.AbilityDetails.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.AbilityDetails.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.AbilityDetails.cooldown)
        pub cooldown: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.AbilityDetails.cooldown_max)
        pub cooldown_max: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.AbilityDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AbilityDetails {
        fn default() -> &'a AbilityDetails {
            <AbilityDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl AbilityDetails {
        pub fn new() -> AbilityDetails {
            ::std::default::Default::default()
        }

        // optional int32 id = 1;

        pub fn id(&self) -> i32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: i32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 level = 3;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional float cooldown = 4;

        pub fn cooldown(&self) -> f32 {
            self.cooldown.unwrap_or(0.)
        }

        pub fn clear_cooldown(&mut self) {
            self.cooldown = ::std::option::Option::None;
        }

        pub fn has_cooldown(&self) -> bool {
            self.cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cooldown(&mut self, v: f32) {
            self.cooldown = ::std::option::Option::Some(v);
        }

        // optional float cooldown_max = 5;

        pub fn cooldown_max(&self) -> f32 {
            self.cooldown_max.unwrap_or(0.)
        }

        pub fn clear_cooldown_max(&mut self) {
            self.cooldown_max = ::std::option::Option::None;
        }

        pub fn has_cooldown_max(&self) -> bool {
            self.cooldown_max.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cooldown_max(&mut self, v: f32) {
            self.cooldown_max = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &AbilityDetails| { &m.id },
                |m: &mut AbilityDetails| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &AbilityDetails| { &m.name },
                |m: &mut AbilityDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &AbilityDetails| { &m.level },
                |m: &mut AbilityDetails| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cooldown",
                |m: &AbilityDetails| { &m.cooldown },
                |m: &mut AbilityDetails| { &mut m.cooldown },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cooldown_max",
                |m: &AbilityDetails| { &m.cooldown_max },
                |m: &mut AbilityDetails| { &mut m.cooldown_max },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AbilityDetails>(
                "CMsgDOTARealtimeGameStats.AbilityDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AbilityDetails {
        const NAME: &'static str = "AbilityDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    37 => {
                        self.cooldown = ::std::option::Option::Some(is.read_float()?);
                    },
                    45 => {
                        self.cooldown_max = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.cooldown {
                my_size += 1 + 4;
            }
            if let Some(v) = self.cooldown_max {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.cooldown {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.cooldown_max {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AbilityDetails {
            AbilityDetails::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.cooldown = ::std::option::Option::None;
            self.cooldown_max = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AbilityDetails {
            static instance: AbilityDetails = AbilityDetails {
                id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                level: ::std::option::Option::None,
                cooldown: ::std::option::Option::None,
                cooldown_max: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AbilityDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.AbilityDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AbilityDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AbilityDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.HeroToHeroStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroToHeroStats {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.HeroToHeroStats.victimid)
        pub victimid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.HeroToHeroStats.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.HeroToHeroStats.assists)
        pub assists: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.HeroToHeroStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroToHeroStats {
        fn default() -> &'a HeroToHeroStats {
            <HeroToHeroStats as ::protobuf::Message>::default_instance()
        }
    }

    impl HeroToHeroStats {
        pub fn new() -> HeroToHeroStats {
            ::std::default::Default::default()
        }

        // optional int32 victimid = 1;

        pub fn victimid(&self) -> i32 {
            self.victimid.unwrap_or(0)
        }

        pub fn clear_victimid(&mut self) {
            self.victimid = ::std::option::Option::None;
        }

        pub fn has_victimid(&self) -> bool {
            self.victimid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_victimid(&mut self, v: i32) {
            self.victimid = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 2;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 assists = 3;

        pub fn assists(&self) -> u32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: u32) {
            self.assists = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "victimid",
                |m: &HeroToHeroStats| { &m.victimid },
                |m: &mut HeroToHeroStats| { &mut m.victimid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills",
                |m: &HeroToHeroStats| { &m.kills },
                |m: &mut HeroToHeroStats| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "assists",
                |m: &HeroToHeroStats| { &m.assists },
                |m: &mut HeroToHeroStats| { &mut m.assists },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroToHeroStats>(
                "CMsgDOTARealtimeGameStats.HeroToHeroStats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HeroToHeroStats {
        const NAME: &'static str = "HeroToHeroStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.victimid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.victimid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.kills {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.assists {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.victimid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.assists {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroToHeroStats {
            HeroToHeroStats::new()
        }

        fn clear(&mut self) {
            self.victimid = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroToHeroStats {
            static instance: HeroToHeroStats = HeroToHeroStats {
                victimid: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HeroToHeroStats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.HeroToHeroStats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HeroToHeroStats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HeroToHeroStats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.AbilityList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AbilityList {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.AbilityList.id)
        pub id: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.AbilityList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AbilityList {
        fn default() -> &'a AbilityList {
            <AbilityList as ::protobuf::Message>::default_instance()
        }
    }

    impl AbilityList {
        pub fn new() -> AbilityList {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "id",
                |m: &AbilityList| { &m.id },
                |m: &mut AbilityList| { &mut m.id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AbilityList>(
                "CMsgDOTARealtimeGameStats.AbilityList",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AbilityList {
        const NAME: &'static str = "AbilityList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.id)?;
                    },
                    8 => {
                        self.id.push(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.id {
                my_size += ::protobuf::rt::int32_size(1, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.id {
                os.write_int32(1, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AbilityList {
            AbilityList::new()
        }

        fn clear(&mut self) {
            self.id.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AbilityList {
            static instance: AbilityList = AbilityList {
                id: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AbilityList {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.AbilityList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AbilityList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AbilityList {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.PlayerDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.playerid)
        pub playerid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.heroid)
        pub heroid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.healthpoints)
        pub healthpoints: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.maxhealthpoints)
        pub maxhealthpoints: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.healthregenrate)
        pub healthregenrate: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.manapoints)
        pub manapoints: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.maxmanapoints)
        pub maxmanapoints: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.manaregenrate)
        pub manaregenrate: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.base_strength)
        pub base_strength: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.base_agility)
        pub base_agility: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.base_intelligence)
        pub base_intelligence: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.base_armor)
        pub base_armor: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.base_movespeed)
        pub base_movespeed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.base_damage)
        pub base_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.strength)
        pub strength: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.agility)
        pub agility: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.intelligence)
        pub intelligence: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.armor)
        pub armor: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.movespeed)
        pub movespeed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.damage)
        pub damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.hero_damage)
        pub hero_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.tower_damage)
        pub tower_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.abilities)
        pub abilities: ::std::vec::Vec<AbilityDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.kill_count)
        pub kill_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.death_count)
        pub death_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.assists_count)
        pub assists_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.denies_count)
        pub denies_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.lh_count)
        pub lh_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.hero_healing)
        pub hero_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.gold_per_min)
        pub gold_per_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.xp_per_min)
        pub xp_per_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.net_gold)
        pub net_gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.gold)
        pub gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.y)
        pub y: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.respawn_time)
        pub respawn_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.ultimate_cooldown)
        pub ultimate_cooldown: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.has_buyback)
        pub has_buyback: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.items)
        pub items: ::std::vec::Vec<ItemDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.stashitems)
        pub stashitems: ::std::vec::Vec<ItemDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.itemshoppinglist)
        pub itemshoppinglist: ::std::vec::Vec<ItemDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.levelpoints)
        pub levelpoints: ::std::vec::Vec<AbilityList>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.hero_to_hero_stats)
        pub hero_to_hero_stats: ::std::vec::Vec<HeroToHeroStats>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.has_ultimate)
        pub has_ultimate: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.has_ultimate_mana)
        pub has_ultimate_mana: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.PlayerDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerDetails {
        fn default() -> &'a PlayerDetails {
            <PlayerDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerDetails {
        pub fn new() -> PlayerDetails {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional int32 playerid = 2;

        pub fn playerid(&self) -> i32 {
            self.playerid.unwrap_or(0)
        }

        pub fn clear_playerid(&mut self) {
            self.playerid = ::std::option::Option::None;
        }

        pub fn has_playerid(&self) -> bool {
            self.playerid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playerid(&mut self, v: i32) {
            self.playerid = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team = 4;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 heroid = 5;

        pub fn heroid(&self) -> u32 {
            self.heroid.unwrap_or(0)
        }

        pub fn clear_heroid(&mut self) {
            self.heroid = ::std::option::Option::None;
        }

        pub fn has_heroid(&self) -> bool {
            self.heroid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_heroid(&mut self, v: u32) {
            self.heroid = ::std::option::Option::Some(v);
        }

        // optional uint32 healthpoints = 6;

        pub fn healthpoints(&self) -> u32 {
            self.healthpoints.unwrap_or(0)
        }

        pub fn clear_healthpoints(&mut self) {
            self.healthpoints = ::std::option::Option::None;
        }

        pub fn has_healthpoints(&self) -> bool {
            self.healthpoints.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healthpoints(&mut self, v: u32) {
            self.healthpoints = ::std::option::Option::Some(v);
        }

        // optional uint32 maxhealthpoints = 7;

        pub fn maxhealthpoints(&self) -> u32 {
            self.maxhealthpoints.unwrap_or(0)
        }

        pub fn clear_maxhealthpoints(&mut self) {
            self.maxhealthpoints = ::std::option::Option::None;
        }

        pub fn has_maxhealthpoints(&self) -> bool {
            self.maxhealthpoints.is_some()
        }

        // Param is passed by value, moved
        pub fn set_maxhealthpoints(&mut self, v: u32) {
            self.maxhealthpoints = ::std::option::Option::Some(v);
        }

        // optional float healthregenrate = 8;

        pub fn healthregenrate(&self) -> f32 {
            self.healthregenrate.unwrap_or(0.)
        }

        pub fn clear_healthregenrate(&mut self) {
            self.healthregenrate = ::std::option::Option::None;
        }

        pub fn has_healthregenrate(&self) -> bool {
            self.healthregenrate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healthregenrate(&mut self, v: f32) {
            self.healthregenrate = ::std::option::Option::Some(v);
        }

        // optional uint32 manapoints = 9;

        pub fn manapoints(&self) -> u32 {
            self.manapoints.unwrap_or(0)
        }

        pub fn clear_manapoints(&mut self) {
            self.manapoints = ::std::option::Option::None;
        }

        pub fn has_manapoints(&self) -> bool {
            self.manapoints.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manapoints(&mut self, v: u32) {
            self.manapoints = ::std::option::Option::Some(v);
        }

        // optional uint32 maxmanapoints = 10;

        pub fn maxmanapoints(&self) -> u32 {
            self.maxmanapoints.unwrap_or(0)
        }

        pub fn clear_maxmanapoints(&mut self) {
            self.maxmanapoints = ::std::option::Option::None;
        }

        pub fn has_maxmanapoints(&self) -> bool {
            self.maxmanapoints.is_some()
        }

        // Param is passed by value, moved
        pub fn set_maxmanapoints(&mut self, v: u32) {
            self.maxmanapoints = ::std::option::Option::Some(v);
        }

        // optional float manaregenrate = 11;

        pub fn manaregenrate(&self) -> f32 {
            self.manaregenrate.unwrap_or(0.)
        }

        pub fn clear_manaregenrate(&mut self) {
            self.manaregenrate = ::std::option::Option::None;
        }

        pub fn has_manaregenrate(&self) -> bool {
            self.manaregenrate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manaregenrate(&mut self, v: f32) {
            self.manaregenrate = ::std::option::Option::Some(v);
        }

        // optional uint32 base_strength = 12;

        pub fn base_strength(&self) -> u32 {
            self.base_strength.unwrap_or(0)
        }

        pub fn clear_base_strength(&mut self) {
            self.base_strength = ::std::option::Option::None;
        }

        pub fn has_base_strength(&self) -> bool {
            self.base_strength.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_strength(&mut self, v: u32) {
            self.base_strength = ::std::option::Option::Some(v);
        }

        // optional uint32 base_agility = 13;

        pub fn base_agility(&self) -> u32 {
            self.base_agility.unwrap_or(0)
        }

        pub fn clear_base_agility(&mut self) {
            self.base_agility = ::std::option::Option::None;
        }

        pub fn has_base_agility(&self) -> bool {
            self.base_agility.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_agility(&mut self, v: u32) {
            self.base_agility = ::std::option::Option::Some(v);
        }

        // optional uint32 base_intelligence = 14;

        pub fn base_intelligence(&self) -> u32 {
            self.base_intelligence.unwrap_or(0)
        }

        pub fn clear_base_intelligence(&mut self) {
            self.base_intelligence = ::std::option::Option::None;
        }

        pub fn has_base_intelligence(&self) -> bool {
            self.base_intelligence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_intelligence(&mut self, v: u32) {
            self.base_intelligence = ::std::option::Option::Some(v);
        }

        // optional int32 base_armor = 15;

        pub fn base_armor(&self) -> i32 {
            self.base_armor.unwrap_or(0)
        }

        pub fn clear_base_armor(&mut self) {
            self.base_armor = ::std::option::Option::None;
        }

        pub fn has_base_armor(&self) -> bool {
            self.base_armor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_armor(&mut self, v: i32) {
            self.base_armor = ::std::option::Option::Some(v);
        }

        // optional uint32 base_movespeed = 16;

        pub fn base_movespeed(&self) -> u32 {
            self.base_movespeed.unwrap_or(0)
        }

        pub fn clear_base_movespeed(&mut self) {
            self.base_movespeed = ::std::option::Option::None;
        }

        pub fn has_base_movespeed(&self) -> bool {
            self.base_movespeed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_movespeed(&mut self, v: u32) {
            self.base_movespeed = ::std::option::Option::Some(v);
        }

        // optional uint32 base_damage = 17;

        pub fn base_damage(&self) -> u32 {
            self.base_damage.unwrap_or(0)
        }

        pub fn clear_base_damage(&mut self) {
            self.base_damage = ::std::option::Option::None;
        }

        pub fn has_base_damage(&self) -> bool {
            self.base_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_damage(&mut self, v: u32) {
            self.base_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 strength = 18;

        pub fn strength(&self) -> u32 {
            self.strength.unwrap_or(0)
        }

        pub fn clear_strength(&mut self) {
            self.strength = ::std::option::Option::None;
        }

        pub fn has_strength(&self) -> bool {
            self.strength.is_some()
        }

        // Param is passed by value, moved
        pub fn set_strength(&mut self, v: u32) {
            self.strength = ::std::option::Option::Some(v);
        }

        // optional uint32 agility = 19;

        pub fn agility(&self) -> u32 {
            self.agility.unwrap_or(0)
        }

        pub fn clear_agility(&mut self) {
            self.agility = ::std::option::Option::None;
        }

        pub fn has_agility(&self) -> bool {
            self.agility.is_some()
        }

        // Param is passed by value, moved
        pub fn set_agility(&mut self, v: u32) {
            self.agility = ::std::option::Option::Some(v);
        }

        // optional uint32 intelligence = 20;

        pub fn intelligence(&self) -> u32 {
            self.intelligence.unwrap_or(0)
        }

        pub fn clear_intelligence(&mut self) {
            self.intelligence = ::std::option::Option::None;
        }

        pub fn has_intelligence(&self) -> bool {
            self.intelligence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_intelligence(&mut self, v: u32) {
            self.intelligence = ::std::option::Option::Some(v);
        }

        // optional int32 armor = 21;

        pub fn armor(&self) -> i32 {
            self.armor.unwrap_or(0)
        }

        pub fn clear_armor(&mut self) {
            self.armor = ::std::option::Option::None;
        }

        pub fn has_armor(&self) -> bool {
            self.armor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_armor(&mut self, v: i32) {
            self.armor = ::std::option::Option::Some(v);
        }

        // optional uint32 movespeed = 22;

        pub fn movespeed(&self) -> u32 {
            self.movespeed.unwrap_or(0)
        }

        pub fn clear_movespeed(&mut self) {
            self.movespeed = ::std::option::Option::None;
        }

        pub fn has_movespeed(&self) -> bool {
            self.movespeed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_movespeed(&mut self, v: u32) {
            self.movespeed = ::std::option::Option::Some(v);
        }

        // optional uint32 damage = 23;

        pub fn damage(&self) -> u32 {
            self.damage.unwrap_or(0)
        }

        pub fn clear_damage(&mut self) {
            self.damage = ::std::option::Option::None;
        }

        pub fn has_damage(&self) -> bool {
            self.damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_damage(&mut self, v: u32) {
            self.damage = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_damage = 24;

        pub fn hero_damage(&self) -> u32 {
            self.hero_damage.unwrap_or(0)
        }

        pub fn clear_hero_damage(&mut self) {
            self.hero_damage = ::std::option::Option::None;
        }

        pub fn has_hero_damage(&self) -> bool {
            self.hero_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_damage(&mut self, v: u32) {
            self.hero_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 tower_damage = 25;

        pub fn tower_damage(&self) -> u32 {
            self.tower_damage.unwrap_or(0)
        }

        pub fn clear_tower_damage(&mut self) {
            self.tower_damage = ::std::option::Option::None;
        }

        pub fn has_tower_damage(&self) -> bool {
            self.tower_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_damage(&mut self, v: u32) {
            self.tower_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 27;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 kill_count = 28;

        pub fn kill_count(&self) -> u32 {
            self.kill_count.unwrap_or(0)
        }

        pub fn clear_kill_count(&mut self) {
            self.kill_count = ::std::option::Option::None;
        }

        pub fn has_kill_count(&self) -> bool {
            self.kill_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kill_count(&mut self, v: u32) {
            self.kill_count = ::std::option::Option::Some(v);
        }

        // optional uint32 death_count = 29;

        pub fn death_count(&self) -> u32 {
            self.death_count.unwrap_or(0)
        }

        pub fn clear_death_count(&mut self) {
            self.death_count = ::std::option::Option::None;
        }

        pub fn has_death_count(&self) -> bool {
            self.death_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_death_count(&mut self, v: u32) {
            self.death_count = ::std::option::Option::Some(v);
        }

        // optional uint32 assists_count = 30;

        pub fn assists_count(&self) -> u32 {
            self.assists_count.unwrap_or(0)
        }

        pub fn clear_assists_count(&mut self) {
            self.assists_count = ::std::option::Option::None;
        }

        pub fn has_assists_count(&self) -> bool {
            self.assists_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists_count(&mut self, v: u32) {
            self.assists_count = ::std::option::Option::Some(v);
        }

        // optional uint32 denies_count = 31;

        pub fn denies_count(&self) -> u32 {
            self.denies_count.unwrap_or(0)
        }

        pub fn clear_denies_count(&mut self) {
            self.denies_count = ::std::option::Option::None;
        }

        pub fn has_denies_count(&self) -> bool {
            self.denies_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies_count(&mut self, v: u32) {
            self.denies_count = ::std::option::Option::Some(v);
        }

        // optional uint32 lh_count = 32;

        pub fn lh_count(&self) -> u32 {
            self.lh_count.unwrap_or(0)
        }

        pub fn clear_lh_count(&mut self) {
            self.lh_count = ::std::option::Option::None;
        }

        pub fn has_lh_count(&self) -> bool {
            self.lh_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lh_count(&mut self, v: u32) {
            self.lh_count = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_healing = 33;

        pub fn hero_healing(&self) -> u32 {
            self.hero_healing.unwrap_or(0)
        }

        pub fn clear_hero_healing(&mut self) {
            self.hero_healing = ::std::option::Option::None;
        }

        pub fn has_hero_healing(&self) -> bool {
            self.hero_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_healing(&mut self, v: u32) {
            self.hero_healing = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_per_min = 34;

        pub fn gold_per_min(&self) -> u32 {
            self.gold_per_min.unwrap_or(0)
        }

        pub fn clear_gold_per_min(&mut self) {
            self.gold_per_min = ::std::option::Option::None;
        }

        pub fn has_gold_per_min(&self) -> bool {
            self.gold_per_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_per_min(&mut self, v: u32) {
            self.gold_per_min = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_per_min = 35;

        pub fn xp_per_min(&self) -> u32 {
            self.xp_per_min.unwrap_or(0)
        }

        pub fn clear_xp_per_min(&mut self) {
            self.xp_per_min = ::std::option::Option::None;
        }

        pub fn has_xp_per_min(&self) -> bool {
            self.xp_per_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_per_min(&mut self, v: u32) {
            self.xp_per_min = ::std::option::Option::Some(v);
        }

        // optional uint32 net_gold = 36;

        pub fn net_gold(&self) -> u32 {
            self.net_gold.unwrap_or(0)
        }

        pub fn clear_net_gold(&mut self) {
            self.net_gold = ::std::option::Option::None;
        }

        pub fn has_net_gold(&self) -> bool {
            self.net_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_gold(&mut self, v: u32) {
            self.net_gold = ::std::option::Option::Some(v);
        }

        // optional uint32 gold = 37;

        pub fn gold(&self) -> u32 {
            self.gold.unwrap_or(0)
        }

        pub fn clear_gold(&mut self) {
            self.gold = ::std::option::Option::None;
        }

        pub fn has_gold(&self) -> bool {
            self.gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold(&mut self, v: u32) {
            self.gold = ::std::option::Option::Some(v);
        }

        // optional float x = 38;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 39;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional int32 respawn_time = 40;

        pub fn respawn_time(&self) -> i32 {
            self.respawn_time.unwrap_or(0)
        }

        pub fn clear_respawn_time(&mut self) {
            self.respawn_time = ::std::option::Option::None;
        }

        pub fn has_respawn_time(&self) -> bool {
            self.respawn_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_respawn_time(&mut self, v: i32) {
            self.respawn_time = ::std::option::Option::Some(v);
        }

        // optional uint32 ultimate_cooldown = 41;

        pub fn ultimate_cooldown(&self) -> u32 {
            self.ultimate_cooldown.unwrap_or(0)
        }

        pub fn clear_ultimate_cooldown(&mut self) {
            self.ultimate_cooldown = ::std::option::Option::None;
        }

        pub fn has_ultimate_cooldown(&self) -> bool {
            self.ultimate_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ultimate_cooldown(&mut self, v: u32) {
            self.ultimate_cooldown = ::std::option::Option::Some(v);
        }

        // optional bool has_buyback = 42;

        pub fn has_buyback(&self) -> bool {
            self.has_buyback.unwrap_or(false)
        }

        pub fn clear_has_buyback(&mut self) {
            self.has_buyback = ::std::option::Option::None;
        }

        pub fn has_has_buyback(&self) -> bool {
            self.has_buyback.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_buyback(&mut self, v: bool) {
            self.has_buyback = ::std::option::Option::Some(v);
        }

        // optional bool has_ultimate = 48;

        pub fn has_ultimate(&self) -> bool {
            self.has_ultimate.unwrap_or(false)
        }

        pub fn clear_has_ultimate(&mut self) {
            self.has_ultimate = ::std::option::Option::None;
        }

        pub fn has_has_ultimate(&self) -> bool {
            self.has_ultimate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_ultimate(&mut self, v: bool) {
            self.has_ultimate = ::std::option::Option::Some(v);
        }

        // optional bool has_ultimate_mana = 49;

        pub fn has_ultimate_mana(&self) -> bool {
            self.has_ultimate_mana.unwrap_or(false)
        }

        pub fn clear_has_ultimate_mana(&mut self) {
            self.has_ultimate_mana = ::std::option::Option::None;
        }

        pub fn has_has_ultimate_mana(&self) -> bool {
            self.has_ultimate_mana.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_ultimate_mana(&mut self, v: bool) {
            self.has_ultimate_mana = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(49);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &PlayerDetails| { &m.accountid },
                |m: &mut PlayerDetails| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "playerid",
                |m: &PlayerDetails| { &m.playerid },
                |m: &mut PlayerDetails| { &mut m.playerid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &PlayerDetails| { &m.name },
                |m: &mut PlayerDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &PlayerDetails| { &m.team },
                |m: &mut PlayerDetails| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "heroid",
                |m: &PlayerDetails| { &m.heroid },
                |m: &mut PlayerDetails| { &mut m.heroid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "healthpoints",
                |m: &PlayerDetails| { &m.healthpoints },
                |m: &mut PlayerDetails| { &mut m.healthpoints },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "maxhealthpoints",
                |m: &PlayerDetails| { &m.maxhealthpoints },
                |m: &mut PlayerDetails| { &mut m.maxhealthpoints },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "healthregenrate",
                |m: &PlayerDetails| { &m.healthregenrate },
                |m: &mut PlayerDetails| { &mut m.healthregenrate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "manapoints",
                |m: &PlayerDetails| { &m.manapoints },
                |m: &mut PlayerDetails| { &mut m.manapoints },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "maxmanapoints",
                |m: &PlayerDetails| { &m.maxmanapoints },
                |m: &mut PlayerDetails| { &mut m.maxmanapoints },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "manaregenrate",
                |m: &PlayerDetails| { &m.manaregenrate },
                |m: &mut PlayerDetails| { &mut m.manaregenrate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_strength",
                |m: &PlayerDetails| { &m.base_strength },
                |m: &mut PlayerDetails| { &mut m.base_strength },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_agility",
                |m: &PlayerDetails| { &m.base_agility },
                |m: &mut PlayerDetails| { &mut m.base_agility },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_intelligence",
                |m: &PlayerDetails| { &m.base_intelligence },
                |m: &mut PlayerDetails| { &mut m.base_intelligence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_armor",
                |m: &PlayerDetails| { &m.base_armor },
                |m: &mut PlayerDetails| { &mut m.base_armor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_movespeed",
                |m: &PlayerDetails| { &m.base_movespeed },
                |m: &mut PlayerDetails| { &mut m.base_movespeed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_damage",
                |m: &PlayerDetails| { &m.base_damage },
                |m: &mut PlayerDetails| { &mut m.base_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "strength",
                |m: &PlayerDetails| { &m.strength },
                |m: &mut PlayerDetails| { &mut m.strength },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "agility",
                |m: &PlayerDetails| { &m.agility },
                |m: &mut PlayerDetails| { &mut m.agility },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "intelligence",
                |m: &PlayerDetails| { &m.intelligence },
                |m: &mut PlayerDetails| { &mut m.intelligence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "armor",
                |m: &PlayerDetails| { &m.armor },
                |m: &mut PlayerDetails| { &mut m.armor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "movespeed",
                |m: &PlayerDetails| { &m.movespeed },
                |m: &mut PlayerDetails| { &mut m.movespeed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "damage",
                |m: &PlayerDetails| { &m.damage },
                |m: &mut PlayerDetails| { &mut m.damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_damage",
                |m: &PlayerDetails| { &m.hero_damage },
                |m: &mut PlayerDetails| { &mut m.hero_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tower_damage",
                |m: &PlayerDetails| { &m.tower_damage },
                |m: &mut PlayerDetails| { &mut m.tower_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "abilities",
                |m: &PlayerDetails| { &m.abilities },
                |m: &mut PlayerDetails| { &mut m.abilities },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &PlayerDetails| { &m.level },
                |m: &mut PlayerDetails| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kill_count",
                |m: &PlayerDetails| { &m.kill_count },
                |m: &mut PlayerDetails| { &mut m.kill_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "death_count",
                |m: &PlayerDetails| { &m.death_count },
                |m: &mut PlayerDetails| { &mut m.death_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "assists_count",
                |m: &PlayerDetails| { &m.assists_count },
                |m: &mut PlayerDetails| { &mut m.assists_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "denies_count",
                |m: &PlayerDetails| { &m.denies_count },
                |m: &mut PlayerDetails| { &mut m.denies_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lh_count",
                |m: &PlayerDetails| { &m.lh_count },
                |m: &mut PlayerDetails| { &mut m.lh_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_healing",
                |m: &PlayerDetails| { &m.hero_healing },
                |m: &mut PlayerDetails| { &mut m.hero_healing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_per_min",
                |m: &PlayerDetails| { &m.gold_per_min },
                |m: &mut PlayerDetails| { &mut m.gold_per_min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xp_per_min",
                |m: &PlayerDetails| { &m.xp_per_min },
                |m: &mut PlayerDetails| { &mut m.xp_per_min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "net_gold",
                |m: &PlayerDetails| { &m.net_gold },
                |m: &mut PlayerDetails| { &mut m.net_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold",
                |m: &PlayerDetails| { &m.gold },
                |m: &mut PlayerDetails| { &mut m.gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &PlayerDetails| { &m.x },
                |m: &mut PlayerDetails| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &PlayerDetails| { &m.y },
                |m: &mut PlayerDetails| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "respawn_time",
                |m: &PlayerDetails| { &m.respawn_time },
                |m: &mut PlayerDetails| { &mut m.respawn_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ultimate_cooldown",
                |m: &PlayerDetails| { &m.ultimate_cooldown },
                |m: &mut PlayerDetails| { &mut m.ultimate_cooldown },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_buyback",
                |m: &PlayerDetails| { &m.has_buyback },
                |m: &mut PlayerDetails| { &mut m.has_buyback },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "items",
                |m: &PlayerDetails| { &m.items },
                |m: &mut PlayerDetails| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "stashitems",
                |m: &PlayerDetails| { &m.stashitems },
                |m: &mut PlayerDetails| { &mut m.stashitems },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "itemshoppinglist",
                |m: &PlayerDetails| { &m.itemshoppinglist },
                |m: &mut PlayerDetails| { &mut m.itemshoppinglist },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "levelpoints",
                |m: &PlayerDetails| { &m.levelpoints },
                |m: &mut PlayerDetails| { &mut m.levelpoints },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hero_to_hero_stats",
                |m: &PlayerDetails| { &m.hero_to_hero_stats },
                |m: &mut PlayerDetails| { &mut m.hero_to_hero_stats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_ultimate",
                |m: &PlayerDetails| { &m.has_ultimate },
                |m: &mut PlayerDetails| { &mut m.has_ultimate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_ultimate_mana",
                |m: &PlayerDetails| { &m.has_ultimate_mana },
                |m: &mut PlayerDetails| { &mut m.has_ultimate_mana },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerDetails>(
                "CMsgDOTARealtimeGameStats.PlayerDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerDetails {
        const NAME: &'static str = "PlayerDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.playerid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.heroid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.healthpoints = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.maxhealthpoints = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    69 => {
                        self.healthregenrate = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.manapoints = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.maxmanapoints = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    93 => {
                        self.manaregenrate = ::std::option::Option::Some(is.read_float()?);
                    },
                    96 => {
                        self.base_strength = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.base_agility = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.base_intelligence = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.base_armor = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.base_movespeed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.base_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.strength = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.agility = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.intelligence = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.armor = ::std::option::Option::Some(is.read_int32()?);
                    },
                    176 => {
                        self.movespeed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    184 => {
                        self.damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    192 => {
                        self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    200 => {
                        self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    210 => {
                        self.abilities.push(is.read_message()?);
                    },
                    216 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    224 => {
                        self.kill_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    232 => {
                        self.death_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    240 => {
                        self.assists_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    248 => {
                        self.denies_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    256 => {
                        self.lh_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    264 => {
                        self.hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    272 => {
                        self.gold_per_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    280 => {
                        self.xp_per_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    288 => {
                        self.net_gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    296 => {
                        self.gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    309 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    317 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    320 => {
                        self.respawn_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    328 => {
                        self.ultimate_cooldown = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    336 => {
                        self.has_buyback = ::std::option::Option::Some(is.read_bool()?);
                    },
                    346 => {
                        self.items.push(is.read_message()?);
                    },
                    354 => {
                        self.stashitems.push(is.read_message()?);
                    },
                    362 => {
                        self.itemshoppinglist.push(is.read_message()?);
                    },
                    370 => {
                        self.levelpoints.push(is.read_message()?);
                    },
                    378 => {
                        self.hero_to_hero_stats.push(is.read_message()?);
                    },
                    384 => {
                        self.has_ultimate = ::std::option::Option::Some(is.read_bool()?);
                    },
                    392 => {
                        self.has_ultimate_mana = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.playerid {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.heroid {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.healthpoints {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.maxhealthpoints {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.healthregenrate {
                my_size += 1 + 4;
            }
            if let Some(v) = self.manapoints {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.maxmanapoints {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.manaregenrate {
                my_size += 1 + 4;
            }
            if let Some(v) = self.base_strength {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.base_agility {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.base_intelligence {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.base_armor {
                my_size += ::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.base_movespeed {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.base_damage {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.strength {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.agility {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.intelligence {
                my_size += ::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.armor {
                my_size += ::protobuf::rt::int32_size(21, v);
            }
            if let Some(v) = self.movespeed {
                my_size += ::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.damage {
                my_size += ::protobuf::rt::uint32_size(23, v);
            }
            if let Some(v) = self.hero_damage {
                my_size += ::protobuf::rt::uint32_size(24, v);
            }
            if let Some(v) = self.tower_damage {
                my_size += ::protobuf::rt::uint32_size(25, v);
            }
            for value in &self.abilities {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(27, v);
            }
            if let Some(v) = self.kill_count {
                my_size += ::protobuf::rt::uint32_size(28, v);
            }
            if let Some(v) = self.death_count {
                my_size += ::protobuf::rt::uint32_size(29, v);
            }
            if let Some(v) = self.assists_count {
                my_size += ::protobuf::rt::uint32_size(30, v);
            }
            if let Some(v) = self.denies_count {
                my_size += ::protobuf::rt::uint32_size(31, v);
            }
            if let Some(v) = self.lh_count {
                my_size += ::protobuf::rt::uint32_size(32, v);
            }
            if let Some(v) = self.hero_healing {
                my_size += ::protobuf::rt::uint32_size(33, v);
            }
            if let Some(v) = self.gold_per_min {
                my_size += ::protobuf::rt::uint32_size(34, v);
            }
            if let Some(v) = self.xp_per_min {
                my_size += ::protobuf::rt::uint32_size(35, v);
            }
            if let Some(v) = self.net_gold {
                my_size += ::protobuf::rt::uint32_size(36, v);
            }
            if let Some(v) = self.gold {
                my_size += ::protobuf::rt::uint32_size(37, v);
            }
            if let Some(v) = self.x {
                my_size += 2 + 4;
            }
            if let Some(v) = self.y {
                my_size += 2 + 4;
            }
            if let Some(v) = self.respawn_time {
                my_size += ::protobuf::rt::int32_size(40, v);
            }
            if let Some(v) = self.ultimate_cooldown {
                my_size += ::protobuf::rt::uint32_size(41, v);
            }
            if let Some(v) = self.has_buyback {
                my_size += 2 + 1;
            }
            for value in &self.items {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.stashitems {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.itemshoppinglist {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.levelpoints {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.hero_to_hero_stats {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.has_ultimate {
                my_size += 2 + 1;
            }
            if let Some(v) = self.has_ultimate_mana {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.playerid {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.heroid {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.healthpoints {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.maxhealthpoints {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.healthregenrate {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.manapoints {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.maxmanapoints {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.manaregenrate {
                os.write_float(11, v)?;
            }
            if let Some(v) = self.base_strength {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.base_agility {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.base_intelligence {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.base_armor {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.base_movespeed {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.base_damage {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.strength {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.agility {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.intelligence {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.armor {
                os.write_int32(21, v)?;
            }
            if let Some(v) = self.movespeed {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.damage {
                os.write_uint32(23, v)?;
            }
            if let Some(v) = self.hero_damage {
                os.write_uint32(24, v)?;
            }
            if let Some(v) = self.tower_damage {
                os.write_uint32(25, v)?;
            }
            for v in &self.abilities {
                ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
            };
            if let Some(v) = self.level {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.kill_count {
                os.write_uint32(28, v)?;
            }
            if let Some(v) = self.death_count {
                os.write_uint32(29, v)?;
            }
            if let Some(v) = self.assists_count {
                os.write_uint32(30, v)?;
            }
            if let Some(v) = self.denies_count {
                os.write_uint32(31, v)?;
            }
            if let Some(v) = self.lh_count {
                os.write_uint32(32, v)?;
            }
            if let Some(v) = self.hero_healing {
                os.write_uint32(33, v)?;
            }
            if let Some(v) = self.gold_per_min {
                os.write_uint32(34, v)?;
            }
            if let Some(v) = self.xp_per_min {
                os.write_uint32(35, v)?;
            }
            if let Some(v) = self.net_gold {
                os.write_uint32(36, v)?;
            }
            if let Some(v) = self.gold {
                os.write_uint32(37, v)?;
            }
            if let Some(v) = self.x {
                os.write_float(38, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(39, v)?;
            }
            if let Some(v) = self.respawn_time {
                os.write_int32(40, v)?;
            }
            if let Some(v) = self.ultimate_cooldown {
                os.write_uint32(41, v)?;
            }
            if let Some(v) = self.has_buyback {
                os.write_bool(42, v)?;
            }
            for v in &self.items {
                ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
            };
            for v in &self.stashitems {
                ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
            };
            for v in &self.itemshoppinglist {
                ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
            };
            for v in &self.levelpoints {
                ::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
            };
            for v in &self.hero_to_hero_stats {
                ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
            };
            if let Some(v) = self.has_ultimate {
                os.write_bool(48, v)?;
            }
            if let Some(v) = self.has_ultimate_mana {
                os.write_bool(49, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerDetails {
            PlayerDetails::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.playerid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.heroid = ::std::option::Option::None;
            self.healthpoints = ::std::option::Option::None;
            self.maxhealthpoints = ::std::option::Option::None;
            self.healthregenrate = ::std::option::Option::None;
            self.manapoints = ::std::option::Option::None;
            self.maxmanapoints = ::std::option::Option::None;
            self.manaregenrate = ::std::option::Option::None;
            self.base_strength = ::std::option::Option::None;
            self.base_agility = ::std::option::Option::None;
            self.base_intelligence = ::std::option::Option::None;
            self.base_armor = ::std::option::Option::None;
            self.base_movespeed = ::std::option::Option::None;
            self.base_damage = ::std::option::Option::None;
            self.strength = ::std::option::Option::None;
            self.agility = ::std::option::Option::None;
            self.intelligence = ::std::option::Option::None;
            self.armor = ::std::option::Option::None;
            self.movespeed = ::std::option::Option::None;
            self.damage = ::std::option::Option::None;
            self.hero_damage = ::std::option::Option::None;
            self.tower_damage = ::std::option::Option::None;
            self.abilities.clear();
            self.level = ::std::option::Option::None;
            self.kill_count = ::std::option::Option::None;
            self.death_count = ::std::option::Option::None;
            self.assists_count = ::std::option::Option::None;
            self.denies_count = ::std::option::Option::None;
            self.lh_count = ::std::option::Option::None;
            self.hero_healing = ::std::option::Option::None;
            self.gold_per_min = ::std::option::Option::None;
            self.xp_per_min = ::std::option::Option::None;
            self.net_gold = ::std::option::Option::None;
            self.gold = ::std::option::Option::None;
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.respawn_time = ::std::option::Option::None;
            self.ultimate_cooldown = ::std::option::Option::None;
            self.has_buyback = ::std::option::Option::None;
            self.items.clear();
            self.stashitems.clear();
            self.itemshoppinglist.clear();
            self.levelpoints.clear();
            self.hero_to_hero_stats.clear();
            self.has_ultimate = ::std::option::Option::None;
            self.has_ultimate_mana = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerDetails {
            static instance: PlayerDetails = PlayerDetails {
                accountid: ::std::option::Option::None,
                playerid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                team: ::std::option::Option::None,
                heroid: ::std::option::Option::None,
                healthpoints: ::std::option::Option::None,
                maxhealthpoints: ::std::option::Option::None,
                healthregenrate: ::std::option::Option::None,
                manapoints: ::std::option::Option::None,
                maxmanapoints: ::std::option::Option::None,
                manaregenrate: ::std::option::Option::None,
                base_strength: ::std::option::Option::None,
                base_agility: ::std::option::Option::None,
                base_intelligence: ::std::option::Option::None,
                base_armor: ::std::option::Option::None,
                base_movespeed: ::std::option::Option::None,
                base_damage: ::std::option::Option::None,
                strength: ::std::option::Option::None,
                agility: ::std::option::Option::None,
                intelligence: ::std::option::Option::None,
                armor: ::std::option::Option::None,
                movespeed: ::std::option::Option::None,
                damage: ::std::option::Option::None,
                hero_damage: ::std::option::Option::None,
                tower_damage: ::std::option::Option::None,
                abilities: ::std::vec::Vec::new(),
                level: ::std::option::Option::None,
                kill_count: ::std::option::Option::None,
                death_count: ::std::option::Option::None,
                assists_count: ::std::option::Option::None,
                denies_count: ::std::option::Option::None,
                lh_count: ::std::option::Option::None,
                hero_healing: ::std::option::Option::None,
                gold_per_min: ::std::option::Option::None,
                xp_per_min: ::std::option::Option::None,
                net_gold: ::std::option::Option::None,
                gold: ::std::option::Option::None,
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                respawn_time: ::std::option::Option::None,
                ultimate_cooldown: ::std::option::Option::None,
                has_buyback: ::std::option::Option::None,
                items: ::std::vec::Vec::new(),
                stashitems: ::std::vec::Vec::new(),
                itemshoppinglist: ::std::vec::Vec::new(),
                levelpoints: ::std::vec::Vec::new(),
                hero_to_hero_stats: ::std::vec::Vec::new(),
                has_ultimate: ::std::option::Option::None,
                has_ultimate_mana: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.PlayerDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.BuildingDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BuildingDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.BuildingDetails.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.BuildingDetails.heading)
        pub heading: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.BuildingDetails.lane)
        pub lane: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.BuildingDetails.tier)
        pub tier: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.BuildingDetails.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.BuildingDetails.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.BuildingDetails.y)
        pub y: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.BuildingDetails.destroyed)
        pub destroyed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.BuildingDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BuildingDetails {
        fn default() -> &'a BuildingDetails {
            <BuildingDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl BuildingDetails {
        pub fn new() -> BuildingDetails {
            ::std::default::Default::default()
        }

        // optional uint32 team = 2;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional float heading = 3;

        pub fn heading(&self) -> f32 {
            self.heading.unwrap_or(0.)
        }

        pub fn clear_heading(&mut self) {
            self.heading = ::std::option::Option::None;
        }

        pub fn has_heading(&self) -> bool {
            self.heading.is_some()
        }

        // Param is passed by value, moved
        pub fn set_heading(&mut self, v: f32) {
            self.heading = ::std::option::Option::Some(v);
        }

        // optional uint32 lane = 4;

        pub fn lane(&self) -> u32 {
            self.lane.unwrap_or(0)
        }

        pub fn clear_lane(&mut self) {
            self.lane = ::std::option::Option::None;
        }

        pub fn has_lane(&self) -> bool {
            self.lane.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane(&mut self, v: u32) {
            self.lane = ::std::option::Option::Some(v);
        }

        // optional uint32 tier = 5;

        pub fn tier(&self) -> u32 {
            self.tier.unwrap_or(0)
        }

        pub fn clear_tier(&mut self) {
            self.tier = ::std::option::Option::None;
        }

        pub fn has_tier(&self) -> bool {
            self.tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tier(&mut self, v: u32) {
            self.tier = ::std::option::Option::Some(v);
        }

        // optional uint32 type = 6;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional float x = 7;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 8;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional bool destroyed = 9;

        pub fn destroyed(&self) -> bool {
            self.destroyed.unwrap_or(false)
        }

        pub fn clear_destroyed(&mut self) {
            self.destroyed = ::std::option::Option::None;
        }

        pub fn has_destroyed(&self) -> bool {
            self.destroyed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroyed(&mut self, v: bool) {
            self.destroyed = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &BuildingDetails| { &m.team },
                |m: &mut BuildingDetails| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "heading",
                |m: &BuildingDetails| { &m.heading },
                |m: &mut BuildingDetails| { &mut m.heading },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lane",
                |m: &BuildingDetails| { &m.lane },
                |m: &mut BuildingDetails| { &mut m.lane },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tier",
                |m: &BuildingDetails| { &m.tier },
                |m: &mut BuildingDetails| { &mut m.tier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &BuildingDetails| { &m.type_ },
                |m: &mut BuildingDetails| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &BuildingDetails| { &m.x },
                |m: &mut BuildingDetails| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &BuildingDetails| { &m.y },
                |m: &mut BuildingDetails| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "destroyed",
                |m: &BuildingDetails| { &m.destroyed },
                |m: &mut BuildingDetails| { &mut m.destroyed },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildingDetails>(
                "CMsgDOTARealtimeGameStats.BuildingDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BuildingDetails {
        const NAME: &'static str = "BuildingDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    16 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    29 => {
                        self.heading = ::std::option::Option::Some(is.read_float()?);
                    },
                    32 => {
                        self.lane = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.tier = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    61 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    69 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.destroyed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.heading {
                my_size += 1 + 4;
            }
            if let Some(v) = self.lane {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.tier {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.x {
                my_size += 1 + 4;
            }
            if let Some(v) = self.y {
                my_size += 1 + 4;
            }
            if let Some(v) = self.destroyed {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.heading {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.lane {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.tier {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.x {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.destroyed {
                os.write_bool(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BuildingDetails {
            BuildingDetails::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.heading = ::std::option::Option::None;
            self.lane = ::std::option::Option::None;
            self.tier = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.destroyed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BuildingDetails {
            static instance: BuildingDetails = BuildingDetails {
                team: ::std::option::Option::None,
                heading: ::std::option::Option::None,
                lane: ::std::option::Option::None,
                tier: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                destroyed: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BuildingDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.BuildingDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BuildingDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BuildingDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.KillDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KillDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.KillDetails.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.KillDetails.death_time)
        pub death_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.KillDetails.killer_player_id)
        pub killer_player_id: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.KillDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KillDetails {
        fn default() -> &'a KillDetails {
            <KillDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl KillDetails {
        pub fn new() -> KillDetails {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 death_time = 2;

        pub fn death_time(&self) -> i32 {
            self.death_time.unwrap_or(0)
        }

        pub fn clear_death_time(&mut self) {
            self.death_time = ::std::option::Option::None;
        }

        pub fn has_death_time(&self) -> bool {
            self.death_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_death_time(&mut self, v: i32) {
            self.death_time = ::std::option::Option::Some(v);
        }

        // optional int32 killer_player_id = 3;

        pub fn killer_player_id(&self) -> i32 {
            self.killer_player_id.unwrap_or(0)
        }

        pub fn clear_killer_player_id(&mut self) {
            self.killer_player_id = ::std::option::Option::None;
        }

        pub fn has_killer_player_id(&self) -> bool {
            self.killer_player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_killer_player_id(&mut self, v: i32) {
            self.killer_player_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &KillDetails| { &m.player_id },
                |m: &mut KillDetails| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "death_time",
                |m: &KillDetails| { &m.death_time },
                |m: &mut KillDetails| { &mut m.death_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "killer_player_id",
                |m: &KillDetails| { &m.killer_player_id },
                |m: &mut KillDetails| { &mut m.killer_player_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KillDetails>(
                "CMsgDOTARealtimeGameStats.KillDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KillDetails {
        const NAME: &'static str = "KillDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.death_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.killer_player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.death_time {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.killer_player_id {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.death_time {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.killer_player_id {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KillDetails {
            KillDetails::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.death_time = ::std::option::Option::None;
            self.killer_player_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KillDetails {
            static instance: KillDetails = KillDetails {
                player_id: ::std::option::Option::None,
                death_time: ::std::option::Option::None,
                killer_player_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KillDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.KillDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KillDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KillDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.BroadcasterDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BroadcasterDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.BroadcasterDetails.player_id)
        pub player_id: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.BroadcasterDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BroadcasterDetails {
        fn default() -> &'a BroadcasterDetails {
            <BroadcasterDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl BroadcasterDetails {
        pub fn new() -> BroadcasterDetails {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &BroadcasterDetails| { &m.player_id },
                |m: &mut BroadcasterDetails| { &mut m.player_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BroadcasterDetails>(
                "CMsgDOTARealtimeGameStats.BroadcasterDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BroadcasterDetails {
        const NAME: &'static str = "BroadcasterDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BroadcasterDetails {
            BroadcasterDetails::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BroadcasterDetails {
            static instance: BroadcasterDetails = BroadcasterDetails {
                player_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BroadcasterDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.BroadcasterDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BroadcasterDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BroadcasterDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.PickBanDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PickBanDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PickBanDetails.hero)
        pub hero: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.PickBanDetails.team)
        pub team: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.PickBanDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PickBanDetails {
        fn default() -> &'a PickBanDetails {
            <PickBanDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl PickBanDetails {
        pub fn new() -> PickBanDetails {
            ::std::default::Default::default()
        }

        // optional uint32 hero = 1;

        pub fn hero(&self) -> u32 {
            self.hero.unwrap_or(0)
        }

        pub fn clear_hero(&mut self) {
            self.hero = ::std::option::Option::None;
        }

        pub fn has_hero(&self) -> bool {
            self.hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero(&mut self, v: u32) {
            self.hero = ::std::option::Option::Some(v);
        }

        // optional uint32 team = 2;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero",
                |m: &PickBanDetails| { &m.hero },
                |m: &mut PickBanDetails| { &mut m.hero },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &PickBanDetails| { &m.team },
                |m: &mut PickBanDetails| { &mut m.team },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PickBanDetails>(
                "CMsgDOTARealtimeGameStats.PickBanDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PickBanDetails {
        const NAME: &'static str = "PickBanDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PickBanDetails {
            PickBanDetails::new()
        }

        fn clear(&mut self) {
            self.hero = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PickBanDetails {
            static instance: PickBanDetails = PickBanDetails {
                hero: ::std::option::Option::None,
                team: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PickBanDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.PickBanDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PickBanDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PickBanDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.MatchDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.server_steam_id)
        pub server_steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.time_of_day)
        pub time_of_day: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.is_nightstalker_night)
        pub is_nightstalker_night: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.game_time)
        pub game_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.game_state)
        pub game_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.teamid_radiant)
        pub teamid_radiant: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.teamid_dire)
        pub teamid_dire: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.picks)
        pub picks: ::std::vec::Vec<PickBanDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.bans)
        pub bans: ::std::vec::Vec<PickBanDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.kills)
        pub kills: ::std::vec::Vec<KillDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.broadcasters)
        pub broadcasters: ::std::vec::Vec<BroadcasterDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.game_mode)
        pub game_mode: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.league_node_id)
        pub league_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.single_team)
        pub single_team: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.cheers_peak)
        pub cheers_peak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.lobby_type)
        pub lobby_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.MatchDetails.start_timestamp)
        pub start_timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.MatchDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchDetails {
        fn default() -> &'a MatchDetails {
            <MatchDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl MatchDetails {
        pub fn new() -> MatchDetails {
            ::std::default::Default::default()
        }

        // optional fixed64 server_steam_id = 1;

        pub fn server_steam_id(&self) -> u64 {
            self.server_steam_id.unwrap_or(0)
        }

        pub fn clear_server_steam_id(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
        }

        pub fn has_server_steam_id(&self) -> bool {
            self.server_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_steam_id(&mut self, v: u64) {
            self.server_steam_id = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 2;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 3;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional float time_of_day = 4;

        pub fn time_of_day(&self) -> f32 {
            self.time_of_day.unwrap_or(0.)
        }

        pub fn clear_time_of_day(&mut self) {
            self.time_of_day = ::std::option::Option::None;
        }

        pub fn has_time_of_day(&self) -> bool {
            self.time_of_day.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_of_day(&mut self, v: f32) {
            self.time_of_day = ::std::option::Option::Some(v);
        }

        // optional bool is_nightstalker_night = 5;

        pub fn is_nightstalker_night(&self) -> bool {
            self.is_nightstalker_night.unwrap_or(false)
        }

        pub fn clear_is_nightstalker_night(&mut self) {
            self.is_nightstalker_night = ::std::option::Option::None;
        }

        pub fn has_is_nightstalker_night(&self) -> bool {
            self.is_nightstalker_night.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_nightstalker_night(&mut self, v: bool) {
            self.is_nightstalker_night = ::std::option::Option::Some(v);
        }

        // optional int32 game_time = 6;

        pub fn game_time(&self) -> i32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: i32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        // optional uint32 game_state = 19;

        pub fn game_state(&self) -> u32 {
            self.game_state.unwrap_or(0)
        }

        pub fn clear_game_state(&mut self) {
            self.game_state = ::std::option::Option::None;
        }

        pub fn has_game_state(&self) -> bool {
            self.game_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_state(&mut self, v: u32) {
            self.game_state = ::std::option::Option::Some(v);
        }

        // optional uint32 teamid_radiant = 8;

        pub fn teamid_radiant(&self) -> u32 {
            self.teamid_radiant.unwrap_or(0)
        }

        pub fn clear_teamid_radiant(&mut self) {
            self.teamid_radiant = ::std::option::Option::None;
        }

        pub fn has_teamid_radiant(&self) -> bool {
            self.teamid_radiant.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamid_radiant(&mut self, v: u32) {
            self.teamid_radiant = ::std::option::Option::Some(v);
        }

        // optional uint32 teamid_dire = 9;

        pub fn teamid_dire(&self) -> u32 {
            self.teamid_dire.unwrap_or(0)
        }

        pub fn clear_teamid_dire(&mut self) {
            self.teamid_dire = ::std::option::Option::None;
        }

        pub fn has_teamid_dire(&self) -> bool {
            self.teamid_dire.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamid_dire(&mut self, v: u32) {
            self.teamid_dire = ::std::option::Option::Some(v);
        }

        // optional uint32 game_mode = 14;

        pub fn game_mode(&self) -> u32 {
            self.game_mode.unwrap_or(0)
        }

        pub fn clear_game_mode(&mut self) {
            self.game_mode = ::std::option::Option::None;
        }

        pub fn has_game_mode(&self) -> bool {
            self.game_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_mode(&mut self, v: u32) {
            self.game_mode = ::std::option::Option::Some(v);
        }

        // optional uint32 league_id = 15;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 league_node_id = 18;

        pub fn league_node_id(&self) -> u32 {
            self.league_node_id.unwrap_or(0)
        }

        pub fn clear_league_node_id(&mut self) {
            self.league_node_id = ::std::option::Option::None;
        }

        pub fn has_league_node_id(&self) -> bool {
            self.league_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_node_id(&mut self, v: u32) {
            self.league_node_id = ::std::option::Option::Some(v);
        }

        // optional bool single_team = 16;

        pub fn single_team(&self) -> bool {
            self.single_team.unwrap_or(false)
        }

        pub fn clear_single_team(&mut self) {
            self.single_team = ::std::option::Option::None;
        }

        pub fn has_single_team(&self) -> bool {
            self.single_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_single_team(&mut self, v: bool) {
            self.single_team = ::std::option::Option::Some(v);
        }

        // optional uint32 cheers_peak = 17;

        pub fn cheers_peak(&self) -> u32 {
            self.cheers_peak.unwrap_or(0)
        }

        pub fn clear_cheers_peak(&mut self) {
            self.cheers_peak = ::std::option::Option::None;
        }

        pub fn has_cheers_peak(&self) -> bool {
            self.cheers_peak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cheers_peak(&mut self, v: u32) {
            self.cheers_peak = ::std::option::Option::Some(v);
        }

        // optional uint32 lobby_type = 20;

        pub fn lobby_type(&self) -> u32 {
            self.lobby_type.unwrap_or(0)
        }

        pub fn clear_lobby_type(&mut self) {
            self.lobby_type = ::std::option::Option::None;
        }

        pub fn has_lobby_type(&self) -> bool {
            self.lobby_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_type(&mut self, v: u32) {
            self.lobby_type = ::std::option::Option::Some(v);
        }

        // optional uint32 start_timestamp = 21;

        pub fn start_timestamp(&self) -> u32 {
            self.start_timestamp.unwrap_or(0)
        }

        pub fn clear_start_timestamp(&mut self) {
            self.start_timestamp = ::std::option::Option::None;
        }

        pub fn has_start_timestamp(&self) -> bool {
            self.start_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_timestamp(&mut self, v: u32) {
            self.start_timestamp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(20);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_steam_id",
                |m: &MatchDetails| { &m.server_steam_id },
                |m: &mut MatchDetails| { &mut m.server_steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &MatchDetails| { &m.match_id },
                |m: &mut MatchDetails| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &MatchDetails| { &m.timestamp },
                |m: &mut MatchDetails| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_of_day",
                |m: &MatchDetails| { &m.time_of_day },
                |m: &mut MatchDetails| { &mut m.time_of_day },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_nightstalker_night",
                |m: &MatchDetails| { &m.is_nightstalker_night },
                |m: &mut MatchDetails| { &mut m.is_nightstalker_night },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_time",
                |m: &MatchDetails| { &m.game_time },
                |m: &mut MatchDetails| { &mut m.game_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_state",
                |m: &MatchDetails| { &m.game_state },
                |m: &mut MatchDetails| { &mut m.game_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teamid_radiant",
                |m: &MatchDetails| { &m.teamid_radiant },
                |m: &mut MatchDetails| { &mut m.teamid_radiant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teamid_dire",
                |m: &MatchDetails| { &m.teamid_dire },
                |m: &mut MatchDetails| { &mut m.teamid_dire },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "picks",
                |m: &MatchDetails| { &m.picks },
                |m: &mut MatchDetails| { &mut m.picks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bans",
                |m: &MatchDetails| { &m.bans },
                |m: &mut MatchDetails| { &mut m.bans },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "kills",
                |m: &MatchDetails| { &m.kills },
                |m: &mut MatchDetails| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "broadcasters",
                |m: &MatchDetails| { &m.broadcasters },
                |m: &mut MatchDetails| { &mut m.broadcasters },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_mode",
                |m: &MatchDetails| { &m.game_mode },
                |m: &mut MatchDetails| { &mut m.game_mode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &MatchDetails| { &m.league_id },
                |m: &mut MatchDetails| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_node_id",
                |m: &MatchDetails| { &m.league_node_id },
                |m: &mut MatchDetails| { &mut m.league_node_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "single_team",
                |m: &MatchDetails| { &m.single_team },
                |m: &mut MatchDetails| { &mut m.single_team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cheers_peak",
                |m: &MatchDetails| { &m.cheers_peak },
                |m: &mut MatchDetails| { &mut m.cheers_peak },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lobby_type",
                |m: &MatchDetails| { &m.lobby_type },
                |m: &mut MatchDetails| { &mut m.lobby_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_timestamp",
                |m: &MatchDetails| { &m.start_timestamp },
                |m: &mut MatchDetails| { &mut m.start_timestamp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchDetails>(
                "CMsgDOTARealtimeGameStats.MatchDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MatchDetails {
        const NAME: &'static str = "MatchDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    37 => {
                        self.time_of_day = ::std::option::Option::Some(is.read_float()?);
                    },
                    40 => {
                        self.is_nightstalker_night = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.game_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    152 => {
                        self.game_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.teamid_radiant = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.teamid_dire = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    82 => {
                        self.picks.push(is.read_message()?);
                    },
                    90 => {
                        self.bans.push(is.read_message()?);
                    },
                    98 => {
                        self.kills.push(is.read_message()?);
                    },
                    106 => {
                        self.broadcasters.push(is.read_message()?);
                    },
                    112 => {
                        self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.single_team = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.cheers_peak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.time_of_day {
                my_size += 1 + 4;
            }
            if let Some(v) = self.is_nightstalker_night {
                my_size += 1 + 1;
            }
            if let Some(v) = self.game_time {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.game_state {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.teamid_radiant {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.teamid_dire {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            for value in &self.picks {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.bans {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.kills {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.broadcasters {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.game_mode {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.league_node_id {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.single_team {
                my_size += 2 + 1;
            }
            if let Some(v) = self.cheers_peak {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.lobby_type {
                my_size += ::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.start_timestamp {
                my_size += ::protobuf::rt::uint32_size(21, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server_steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.time_of_day {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.is_nightstalker_night {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.game_state {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.teamid_radiant {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.teamid_dire {
                os.write_uint32(9, v)?;
            }
            for v in &self.picks {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            };
            for v in &self.bans {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            };
            for v in &self.kills {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            };
            for v in &self.broadcasters {
                ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
            };
            if let Some(v) = self.game_mode {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.league_node_id {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.single_team {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.cheers_peak {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.lobby_type {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.start_timestamp {
                os.write_uint32(21, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchDetails {
            MatchDetails::new()
        }

        fn clear(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.time_of_day = ::std::option::Option::None;
            self.is_nightstalker_night = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.game_state = ::std::option::Option::None;
            self.teamid_radiant = ::std::option::Option::None;
            self.teamid_dire = ::std::option::Option::None;
            self.picks.clear();
            self.bans.clear();
            self.kills.clear();
            self.broadcasters.clear();
            self.game_mode = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.league_node_id = ::std::option::Option::None;
            self.single_team = ::std::option::Option::None;
            self.cheers_peak = ::std::option::Option::None;
            self.lobby_type = ::std::option::Option::None;
            self.start_timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchDetails {
            static instance: MatchDetails = MatchDetails {
                server_steam_id: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                time_of_day: ::std::option::Option::None,
                is_nightstalker_night: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                game_state: ::std::option::Option::None,
                teamid_radiant: ::std::option::Option::None,
                teamid_dire: ::std::option::Option::None,
                picks: ::std::vec::Vec::new(),
                bans: ::std::vec::Vec::new(),
                kills: ::std::vec::Vec::new(),
                broadcasters: ::std::vec::Vec::new(),
                game_mode: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                league_node_id: ::std::option::Option::None,
                single_team: ::std::option::Option::None,
                cheers_peak: ::std::option::Option::None,
                lobby_type: ::std::option::Option::None,
                start_timestamp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MatchDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.MatchDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MatchDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MatchDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.GraphData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GraphData {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.GraphData.graph_gold)
        pub graph_gold: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.GraphData.graph_xp)
        pub graph_xp: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.GraphData.graph_kill)
        pub graph_kill: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.GraphData.graph_tower)
        pub graph_tower: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.GraphData.graph_rax)
        pub graph_rax: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.GraphData.team_loc_stats)
        pub team_loc_stats: ::std::vec::Vec<graph_data::TeamLocationStats>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.GraphData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GraphData {
        fn default() -> &'a GraphData {
            <GraphData as ::protobuf::Message>::default_instance()
        }
    }

    impl GraphData {
        pub fn new() -> GraphData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "graph_gold",
                |m: &GraphData| { &m.graph_gold },
                |m: &mut GraphData| { &mut m.graph_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "graph_xp",
                |m: &GraphData| { &m.graph_xp },
                |m: &mut GraphData| { &mut m.graph_xp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "graph_kill",
                |m: &GraphData| { &m.graph_kill },
                |m: &mut GraphData| { &mut m.graph_kill },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "graph_tower",
                |m: &GraphData| { &m.graph_tower },
                |m: &mut GraphData| { &mut m.graph_tower },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "graph_rax",
                |m: &GraphData| { &m.graph_rax },
                |m: &mut GraphData| { &mut m.graph_rax },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "team_loc_stats",
                |m: &GraphData| { &m.team_loc_stats },
                |m: &mut GraphData| { &mut m.team_loc_stats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GraphData>(
                "CMsgDOTARealtimeGameStats.GraphData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GraphData {
        const NAME: &'static str = "GraphData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_gold)?;
                    },
                    8 => {
                        self.graph_gold.push(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_xp)?;
                    },
                    16 => {
                        self.graph_xp.push(is.read_int32()?);
                    },
                    26 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_kill)?;
                    },
                    24 => {
                        self.graph_kill.push(is.read_int32()?);
                    },
                    34 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_tower)?;
                    },
                    32 => {
                        self.graph_tower.push(is.read_int32()?);
                    },
                    42 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_rax)?;
                    },
                    40 => {
                        self.graph_rax.push(is.read_int32()?);
                    },
                    50 => {
                        self.team_loc_stats.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.graph_gold {
                my_size += ::protobuf::rt::int32_size(1, *value);
            };
            for value in &self.graph_xp {
                my_size += ::protobuf::rt::int32_size(2, *value);
            };
            for value in &self.graph_kill {
                my_size += ::protobuf::rt::int32_size(3, *value);
            };
            for value in &self.graph_tower {
                my_size += ::protobuf::rt::int32_size(4, *value);
            };
            for value in &self.graph_rax {
                my_size += ::protobuf::rt::int32_size(5, *value);
            };
            for value in &self.team_loc_stats {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.graph_gold {
                os.write_int32(1, *v)?;
            };
            for v in &self.graph_xp {
                os.write_int32(2, *v)?;
            };
            for v in &self.graph_kill {
                os.write_int32(3, *v)?;
            };
            for v in &self.graph_tower {
                os.write_int32(4, *v)?;
            };
            for v in &self.graph_rax {
                os.write_int32(5, *v)?;
            };
            for v in &self.team_loc_stats {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GraphData {
            GraphData::new()
        }

        fn clear(&mut self) {
            self.graph_gold.clear();
            self.graph_xp.clear();
            self.graph_kill.clear();
            self.graph_tower.clear();
            self.graph_rax.clear();
            self.team_loc_stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GraphData {
            static instance: GraphData = GraphData {
                graph_gold: ::std::vec::Vec::new(),
                graph_xp: ::std::vec::Vec::new(),
                graph_kill: ::std::vec::Vec::new(),
                graph_tower: ::std::vec::Vec::new(),
                graph_rax: ::std::vec::Vec::new(),
                team_loc_stats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GraphData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.GraphData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GraphData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GraphData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `GraphData`
    pub mod graph_data {
        // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.GraphData.LocationStats)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct LocationStats {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.GraphData.LocationStats.stats)
            pub stats: ::std::vec::Vec<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.GraphData.LocationStats.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a LocationStats {
            fn default() -> &'a LocationStats {
                <LocationStats as ::protobuf::Message>::default_instance()
            }
        }

        impl LocationStats {
            pub fn new() -> LocationStats {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "stats",
                    |m: &LocationStats| { &m.stats },
                    |m: &mut LocationStats| { &mut m.stats },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocationStats>(
                    "CMsgDOTARealtimeGameStats.GraphData.LocationStats",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for LocationStats {
            const NAME: &'static str = "LocationStats";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            is.read_repeated_packed_int32_into(&mut self.stats)?;
                        },
                        8 => {
                            self.stats.push(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.stats {
                    my_size += ::protobuf::rt::int32_size(1, *value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.stats {
                    os.write_int32(1, *v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> LocationStats {
                LocationStats::new()
            }

            fn clear(&mut self) {
                self.stats.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static LocationStats {
                static instance: LocationStats = LocationStats {
                    stats: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for LocationStats {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.GraphData.LocationStats").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for LocationStats {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for LocationStats {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TeamLocationStats {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats.loc_stats)
            pub loc_stats: ::std::vec::Vec<LocationStats>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TeamLocationStats {
            fn default() -> &'a TeamLocationStats {
                <TeamLocationStats as ::protobuf::Message>::default_instance()
            }
        }

        impl TeamLocationStats {
            pub fn new() -> TeamLocationStats {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "loc_stats",
                    |m: &TeamLocationStats| { &m.loc_stats },
                    |m: &mut TeamLocationStats| { &mut m.loc_stats },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamLocationStats>(
                    "CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TeamLocationStats {
            const NAME: &'static str = "TeamLocationStats";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.loc_stats.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.loc_stats {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.loc_stats {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TeamLocationStats {
                TeamLocationStats::new()
            }

            fn clear(&mut self) {
                self.loc_stats.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TeamLocationStats {
                static instance: TeamLocationStats = TeamLocationStats {
                    loc_stats: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for TeamLocationStats {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TeamLocationStats {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TeamLocationStats {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:dota.CMsgDOTARealtimeGameStats.GraphData.eStat)
        pub enum EStat {
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eStat.CreepGoldEarned)
            CreepGoldEarned = 0,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eStat.KillGoldEarned)
            KillGoldEarned = 1,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eStat.DeathAndBuybackGoldLost)
            DeathAndBuybackGoldLost = 2,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eStat.XPEarned)
            XPEarned = 3,
        }

        impl ::protobuf::Enum for EStat {
            const NAME: &'static str = "eStat";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EStat> {
                match value {
                    0 => ::std::option::Option::Some(EStat::CreepGoldEarned),
                    1 => ::std::option::Option::Some(EStat::KillGoldEarned),
                    2 => ::std::option::Option::Some(EStat::DeathAndBuybackGoldLost),
                    3 => ::std::option::Option::Some(EStat::XPEarned),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EStat> {
                match str {
                    "CreepGoldEarned" => ::std::option::Option::Some(EStat::CreepGoldEarned),
                    "KillGoldEarned" => ::std::option::Option::Some(EStat::KillGoldEarned),
                    "DeathAndBuybackGoldLost" => ::std::option::Option::Some(EStat::DeathAndBuybackGoldLost),
                    "XPEarned" => ::std::option::Option::Some(EStat::XPEarned),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EStat] = &[
                EStat::CreepGoldEarned,
                EStat::KillGoldEarned,
                EStat::DeathAndBuybackGoldLost,
                EStat::XPEarned,
            ];
        }

        impl ::protobuf::EnumFull for EStat {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CMsgDOTARealtimeGameStats.GraphData.eStat").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for EStat {
            fn default() -> Self {
                EStat::CreepGoldEarned
            }
        }

        impl EStat {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStat>("CMsgDOTARealtimeGameStats.GraphData.eStat")
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:dota.CMsgDOTARealtimeGameStats.GraphData.eLocation)
        pub enum ELocation {
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eLocation.BotLane)
            BotLane = 0,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eLocation.MidLane)
            MidLane = 1,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eLocation.TopLane)
            TopLane = 2,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eLocation.Jungle)
            Jungle = 3,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eLocation.Ancients)
            Ancients = 4,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTARealtimeGameStats.GraphData.eLocation.Other)
            Other = 5,
        }

        impl ::protobuf::Enum for ELocation {
            const NAME: &'static str = "eLocation";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ELocation> {
                match value {
                    0 => ::std::option::Option::Some(ELocation::BotLane),
                    1 => ::std::option::Option::Some(ELocation::MidLane),
                    2 => ::std::option::Option::Some(ELocation::TopLane),
                    3 => ::std::option::Option::Some(ELocation::Jungle),
                    4 => ::std::option::Option::Some(ELocation::Ancients),
                    5 => ::std::option::Option::Some(ELocation::Other),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<ELocation> {
                match str {
                    "BotLane" => ::std::option::Option::Some(ELocation::BotLane),
                    "MidLane" => ::std::option::Option::Some(ELocation::MidLane),
                    "TopLane" => ::std::option::Option::Some(ELocation::TopLane),
                    "Jungle" => ::std::option::Option::Some(ELocation::Jungle),
                    "Ancients" => ::std::option::Option::Some(ELocation::Ancients),
                    "Other" => ::std::option::Option::Some(ELocation::Other),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ELocation] = &[
                ELocation::BotLane,
                ELocation::MidLane,
                ELocation::TopLane,
                ELocation::Jungle,
                ELocation::Ancients,
                ELocation::Other,
            ];
        }

        impl ::protobuf::EnumFull for ELocation {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CMsgDOTARealtimeGameStats.GraphData.eLocation").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for ELocation {
            fn default() -> Self {
                ELocation::BotLane
            }
        }

        impl ELocation {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELocation>("CMsgDOTARealtimeGameStats.GraphData.eLocation")
            }
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStatsTerse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTARealtimeGameStatsTerse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.match)
    pub match_: ::protobuf::MessageField<cmsg_dotarealtime_game_stats_terse::MatchDetails>,
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.teams)
    pub teams: ::std::vec::Vec<cmsg_dotarealtime_game_stats_terse::TeamDetails>,
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.buildings)
    pub buildings: ::std::vec::Vec<cmsg_dotarealtime_game_stats_terse::BuildingDetails>,
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.graph_data)
    pub graph_data: ::protobuf::MessageField<cmsg_dotarealtime_game_stats_terse::GraphData>,
    // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.delta_frame)
    pub delta_frame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStatsTerse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTARealtimeGameStatsTerse {
    fn default() -> &'a CMsgDOTARealtimeGameStatsTerse {
        <CMsgDOTARealtimeGameStatsTerse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTARealtimeGameStatsTerse {
    pub fn new() -> CMsgDOTARealtimeGameStatsTerse {
        ::std::default::Default::default()
    }

    // optional bool delta_frame = 5;

    pub fn delta_frame(&self) -> bool {
        self.delta_frame.unwrap_or(false)
    }

    pub fn clear_delta_frame(&mut self) {
        self.delta_frame = ::std::option::Option::None;
    }

    pub fn has_delta_frame(&self) -> bool {
        self.delta_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_frame(&mut self, v: bool) {
        self.delta_frame = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotarealtime_game_stats_terse::MatchDetails>(
            "match",
            |m: &CMsgDOTARealtimeGameStatsTerse| { &m.match_ },
            |m: &mut CMsgDOTARealtimeGameStatsTerse| { &mut m.match_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CMsgDOTARealtimeGameStatsTerse| { &m.teams },
            |m: &mut CMsgDOTARealtimeGameStatsTerse| { &mut m.teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buildings",
            |m: &CMsgDOTARealtimeGameStatsTerse| { &m.buildings },
            |m: &mut CMsgDOTARealtimeGameStatsTerse| { &mut m.buildings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotarealtime_game_stats_terse::GraphData>(
            "graph_data",
            |m: &CMsgDOTARealtimeGameStatsTerse| { &m.graph_data },
            |m: &mut CMsgDOTARealtimeGameStatsTerse| { &mut m.graph_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta_frame",
            |m: &CMsgDOTARealtimeGameStatsTerse| { &m.delta_frame },
            |m: &mut CMsgDOTARealtimeGameStatsTerse| { &mut m.delta_frame },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTARealtimeGameStatsTerse>(
            "CMsgDOTARealtimeGameStatsTerse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStatsTerse {
    const NAME: &'static str = "CMsgDOTARealtimeGameStatsTerse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_)?;
                },
                18 => {
                    self.teams.push(is.read_message()?);
                },
                26 => {
                    self.buildings.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.graph_data)?;
                },
                40 => {
                    self.delta_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.graph_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.delta_frame {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.buildings {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.graph_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.delta_frame {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTARealtimeGameStatsTerse {
        CMsgDOTARealtimeGameStatsTerse::new()
    }

    fn clear(&mut self) {
        self.match_.clear();
        self.teams.clear();
        self.buildings.clear();
        self.graph_data.clear();
        self.delta_frame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTARealtimeGameStatsTerse {
        static instance: CMsgDOTARealtimeGameStatsTerse = CMsgDOTARealtimeGameStatsTerse {
            match_: ::protobuf::MessageField::none(),
            teams: ::std::vec::Vec::new(),
            buildings: ::std::vec::Vec::new(),
            graph_data: ::protobuf::MessageField::none(),
            delta_frame: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTARealtimeGameStatsTerse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStatsTerse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTARealtimeGameStatsTerse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStatsTerse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTARealtimeGameStatsTerse`
pub mod cmsg_dotarealtime_game_stats_terse {
    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_number)
        pub team_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_tag)
        pub team_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.players)
        pub players: ::std::vec::Vec<PlayerDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStatsTerse.TeamDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamDetails {
        fn default() -> &'a TeamDetails {
            <TeamDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamDetails {
        pub fn new() -> TeamDetails {
            ::std::default::Default::default()
        }

        // optional uint32 team_number = 1;

        pub fn team_number(&self) -> u32 {
            self.team_number.unwrap_or(0)
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: u32) {
            self.team_number = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 3;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_tag = 8;

        pub fn team_tag(&self) -> &str {
            match self.team_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_tag(&mut self) {
            self.team_tag = ::std::option::Option::None;
        }

        pub fn has_team_tag(&self) -> bool {
            self.team_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_tag(&mut self, v: ::std::string::String) {
            self.team_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
            if self.team_tag.is_none() {
                self.team_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_tag(&mut self) -> ::std::string::String {
            self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 team_logo = 4;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 5;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 7;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 9;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_number",
                |m: &TeamDetails| { &m.team_number },
                |m: &mut TeamDetails| { &mut m.team_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &TeamDetails| { &m.team_id },
                |m: &mut TeamDetails| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_name",
                |m: &TeamDetails| { &m.team_name },
                |m: &mut TeamDetails| { &mut m.team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_tag",
                |m: &TeamDetails| { &m.team_tag },
                |m: &mut TeamDetails| { &mut m.team_tag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo",
                |m: &TeamDetails| { &m.team_logo },
                |m: &mut TeamDetails| { &mut m.team_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &TeamDetails| { &m.score },
                |m: &mut TeamDetails| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "net_worth",
                |m: &TeamDetails| { &m.net_worth },
                |m: &mut TeamDetails| { &mut m.net_worth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo_url",
                |m: &TeamDetails| { &m.team_logo_url },
                |m: &mut TeamDetails| { &mut m.team_logo_url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "players",
                |m: &TeamDetails| { &m.players },
                |m: &mut TeamDetails| { &mut m.players },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamDetails>(
                "CMsgDOTARealtimeGameStatsTerse.TeamDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamDetails {
        const NAME: &'static str = "TeamDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.team_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    40 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    74 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.players.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_number {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_tag.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += 1 + 8;
            }
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team_number {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_tag.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(9, v)?;
            }
            for v in &self.players {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamDetails {
            TeamDetails::new()
        }

        fn clear(&mut self) {
            self.team_number = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_tag = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.players.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamDetails {
            static instance: TeamDetails = TeamDetails {
                team_number: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_tag: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                score: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                players: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStatsTerse.TeamDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.playerid)
        pub playerid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.heroid)
        pub heroid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.kill_count)
        pub kill_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.death_count)
        pub death_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.assists_count)
        pub assists_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.denies_count)
        pub denies_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.lh_count)
        pub lh_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.gold)
        pub gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.y)
        pub y: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.abilities)
        pub abilities: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.items)
        pub items: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerDetails {
        fn default() -> &'a PlayerDetails {
            <PlayerDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerDetails {
        pub fn new() -> PlayerDetails {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional int32 playerid = 2;

        pub fn playerid(&self) -> i32 {
            self.playerid.unwrap_or(0)
        }

        pub fn clear_playerid(&mut self) {
            self.playerid = ::std::option::Option::None;
        }

        pub fn has_playerid(&self) -> bool {
            self.playerid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playerid(&mut self, v: i32) {
            self.playerid = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team = 4;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 heroid = 5;

        pub fn heroid(&self) -> u32 {
            self.heroid.unwrap_or(0)
        }

        pub fn clear_heroid(&mut self) {
            self.heroid = ::std::option::Option::None;
        }

        pub fn has_heroid(&self) -> bool {
            self.heroid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_heroid(&mut self, v: u32) {
            self.heroid = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 6;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 kill_count = 7;

        pub fn kill_count(&self) -> u32 {
            self.kill_count.unwrap_or(0)
        }

        pub fn clear_kill_count(&mut self) {
            self.kill_count = ::std::option::Option::None;
        }

        pub fn has_kill_count(&self) -> bool {
            self.kill_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kill_count(&mut self, v: u32) {
            self.kill_count = ::std::option::Option::Some(v);
        }

        // optional uint32 death_count = 8;

        pub fn death_count(&self) -> u32 {
            self.death_count.unwrap_or(0)
        }

        pub fn clear_death_count(&mut self) {
            self.death_count = ::std::option::Option::None;
        }

        pub fn has_death_count(&self) -> bool {
            self.death_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_death_count(&mut self, v: u32) {
            self.death_count = ::std::option::Option::Some(v);
        }

        // optional uint32 assists_count = 9;

        pub fn assists_count(&self) -> u32 {
            self.assists_count.unwrap_or(0)
        }

        pub fn clear_assists_count(&mut self) {
            self.assists_count = ::std::option::Option::None;
        }

        pub fn has_assists_count(&self) -> bool {
            self.assists_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists_count(&mut self, v: u32) {
            self.assists_count = ::std::option::Option::Some(v);
        }

        // optional uint32 denies_count = 10;

        pub fn denies_count(&self) -> u32 {
            self.denies_count.unwrap_or(0)
        }

        pub fn clear_denies_count(&mut self) {
            self.denies_count = ::std::option::Option::None;
        }

        pub fn has_denies_count(&self) -> bool {
            self.denies_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies_count(&mut self, v: u32) {
            self.denies_count = ::std::option::Option::Some(v);
        }

        // optional uint32 lh_count = 11;

        pub fn lh_count(&self) -> u32 {
            self.lh_count.unwrap_or(0)
        }

        pub fn clear_lh_count(&mut self) {
            self.lh_count = ::std::option::Option::None;
        }

        pub fn has_lh_count(&self) -> bool {
            self.lh_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lh_count(&mut self, v: u32) {
            self.lh_count = ::std::option::Option::Some(v);
        }

        // optional uint32 gold = 12;

        pub fn gold(&self) -> u32 {
            self.gold.unwrap_or(0)
        }

        pub fn clear_gold(&mut self) {
            self.gold = ::std::option::Option::None;
        }

        pub fn has_gold(&self) -> bool {
            self.gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold(&mut self, v: u32) {
            self.gold = ::std::option::Option::Some(v);
        }

        // optional float x = 13;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 14;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 15;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(17);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &PlayerDetails| { &m.accountid },
                |m: &mut PlayerDetails| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "playerid",
                |m: &PlayerDetails| { &m.playerid },
                |m: &mut PlayerDetails| { &mut m.playerid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &PlayerDetails| { &m.name },
                |m: &mut PlayerDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &PlayerDetails| { &m.team },
                |m: &mut PlayerDetails| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "heroid",
                |m: &PlayerDetails| { &m.heroid },
                |m: &mut PlayerDetails| { &mut m.heroid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &PlayerDetails| { &m.level },
                |m: &mut PlayerDetails| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kill_count",
                |m: &PlayerDetails| { &m.kill_count },
                |m: &mut PlayerDetails| { &mut m.kill_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "death_count",
                |m: &PlayerDetails| { &m.death_count },
                |m: &mut PlayerDetails| { &mut m.death_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "assists_count",
                |m: &PlayerDetails| { &m.assists_count },
                |m: &mut PlayerDetails| { &mut m.assists_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "denies_count",
                |m: &PlayerDetails| { &m.denies_count },
                |m: &mut PlayerDetails| { &mut m.denies_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lh_count",
                |m: &PlayerDetails| { &m.lh_count },
                |m: &mut PlayerDetails| { &mut m.lh_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold",
                |m: &PlayerDetails| { &m.gold },
                |m: &mut PlayerDetails| { &mut m.gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &PlayerDetails| { &m.x },
                |m: &mut PlayerDetails| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &PlayerDetails| { &m.y },
                |m: &mut PlayerDetails| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "net_worth",
                |m: &PlayerDetails| { &m.net_worth },
                |m: &mut PlayerDetails| { &mut m.net_worth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "abilities",
                |m: &PlayerDetails| { &m.abilities },
                |m: &mut PlayerDetails| { &mut m.abilities },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "items",
                |m: &PlayerDetails| { &m.items },
                |m: &mut PlayerDetails| { &mut m.items },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerDetails>(
                "CMsgDOTARealtimeGameStatsTerse.PlayerDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerDetails {
        const NAME: &'static str = "PlayerDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.playerid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.heroid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.kill_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.death_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.assists_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.denies_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.lh_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    109 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    117 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    120 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    130 => {
                        is.read_repeated_packed_int32_into(&mut self.abilities)?;
                    },
                    128 => {
                        self.abilities.push(is.read_int32()?);
                    },
                    138 => {
                        is.read_repeated_packed_int32_into(&mut self.items)?;
                    },
                    136 => {
                        self.items.push(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.playerid {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.heroid {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.kill_count {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.death_count {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.assists_count {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.denies_count {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.lh_count {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.gold {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.x {
                my_size += 1 + 4;
            }
            if let Some(v) = self.y {
                my_size += 1 + 4;
            }
            if let Some(v) = self.net_worth {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            for value in &self.abilities {
                my_size += ::protobuf::rt::int32_size(16, *value);
            };
            for value in &self.items {
                my_size += ::protobuf::rt::int32_size(17, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.playerid {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.heroid {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.kill_count {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.death_count {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.assists_count {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.denies_count {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.lh_count {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.gold {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.x {
                os.write_float(13, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(14, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(15, v)?;
            }
            for v in &self.abilities {
                os.write_int32(16, *v)?;
            };
            for v in &self.items {
                os.write_int32(17, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerDetails {
            PlayerDetails::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.playerid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.heroid = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.kill_count = ::std::option::Option::None;
            self.death_count = ::std::option::Option::None;
            self.assists_count = ::std::option::Option::None;
            self.denies_count = ::std::option::Option::None;
            self.lh_count = ::std::option::Option::None;
            self.gold = ::std::option::Option::None;
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.abilities.clear();
            self.items.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerDetails {
            static instance: PlayerDetails = PlayerDetails {
                accountid: ::std::option::Option::None,
                playerid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                team: ::std::option::Option::None,
                heroid: ::std::option::Option::None,
                level: ::std::option::Option::None,
                kill_count: ::std::option::Option::None,
                death_count: ::std::option::Option::None,
                assists_count: ::std::option::Option::None,
                denies_count: ::std::option::Option::None,
                lh_count: ::std::option::Option::None,
                gold: ::std::option::Option::None,
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                abilities: ::std::vec::Vec::new(),
                items: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStatsTerse.PlayerDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BuildingDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails.heading)
        pub heading: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails.lane)
        pub lane: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails.tier)
        pub tier: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails.y)
        pub y: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails.destroyed)
        pub destroyed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BuildingDetails {
        fn default() -> &'a BuildingDetails {
            <BuildingDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl BuildingDetails {
        pub fn new() -> BuildingDetails {
            ::std::default::Default::default()
        }

        // optional uint32 team = 1;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional float heading = 2;

        pub fn heading(&self) -> f32 {
            self.heading.unwrap_or(0.)
        }

        pub fn clear_heading(&mut self) {
            self.heading = ::std::option::Option::None;
        }

        pub fn has_heading(&self) -> bool {
            self.heading.is_some()
        }

        // Param is passed by value, moved
        pub fn set_heading(&mut self, v: f32) {
            self.heading = ::std::option::Option::Some(v);
        }

        // optional uint32 type = 3;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint32 lane = 4;

        pub fn lane(&self) -> u32 {
            self.lane.unwrap_or(0)
        }

        pub fn clear_lane(&mut self) {
            self.lane = ::std::option::Option::None;
        }

        pub fn has_lane(&self) -> bool {
            self.lane.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane(&mut self, v: u32) {
            self.lane = ::std::option::Option::Some(v);
        }

        // optional uint32 tier = 5;

        pub fn tier(&self) -> u32 {
            self.tier.unwrap_or(0)
        }

        pub fn clear_tier(&mut self) {
            self.tier = ::std::option::Option::None;
        }

        pub fn has_tier(&self) -> bool {
            self.tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tier(&mut self, v: u32) {
            self.tier = ::std::option::Option::Some(v);
        }

        // optional float x = 6;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 7;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional bool destroyed = 8;

        pub fn destroyed(&self) -> bool {
            self.destroyed.unwrap_or(false)
        }

        pub fn clear_destroyed(&mut self) {
            self.destroyed = ::std::option::Option::None;
        }

        pub fn has_destroyed(&self) -> bool {
            self.destroyed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroyed(&mut self, v: bool) {
            self.destroyed = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &BuildingDetails| { &m.team },
                |m: &mut BuildingDetails| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "heading",
                |m: &BuildingDetails| { &m.heading },
                |m: &mut BuildingDetails| { &mut m.heading },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &BuildingDetails| { &m.type_ },
                |m: &mut BuildingDetails| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lane",
                |m: &BuildingDetails| { &m.lane },
                |m: &mut BuildingDetails| { &mut m.lane },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tier",
                |m: &BuildingDetails| { &m.tier },
                |m: &mut BuildingDetails| { &mut m.tier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &BuildingDetails| { &m.x },
                |m: &mut BuildingDetails| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &BuildingDetails| { &m.y },
                |m: &mut BuildingDetails| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "destroyed",
                |m: &BuildingDetails| { &m.destroyed },
                |m: &mut BuildingDetails| { &mut m.destroyed },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildingDetails>(
                "CMsgDOTARealtimeGameStatsTerse.BuildingDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BuildingDetails {
        const NAME: &'static str = "BuildingDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.heading = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.lane = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.tier = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    53 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    61 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    64 => {
                        self.destroyed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.heading {
                my_size += 1 + 4;
            }
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.lane {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.tier {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.x {
                my_size += 1 + 4;
            }
            if let Some(v) = self.y {
                my_size += 1 + 4;
            }
            if let Some(v) = self.destroyed {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.heading {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.lane {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.tier {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.x {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.destroyed {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BuildingDetails {
            BuildingDetails::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.heading = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.lane = ::std::option::Option::None;
            self.tier = ::std::option::Option::None;
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.destroyed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BuildingDetails {
            static instance: BuildingDetails = BuildingDetails {
                team: ::std::option::Option::None,
                heading: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                lane: ::std::option::Option::None,
                tier: ::std::option::Option::None,
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                destroyed: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BuildingDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStatsTerse.BuildingDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BuildingDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BuildingDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PickBanDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PickBanDetails.hero)
        pub hero: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.PickBanDetails.team)
        pub team: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStatsTerse.PickBanDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PickBanDetails {
        fn default() -> &'a PickBanDetails {
            <PickBanDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl PickBanDetails {
        pub fn new() -> PickBanDetails {
            ::std::default::Default::default()
        }

        // optional uint32 hero = 1;

        pub fn hero(&self) -> u32 {
            self.hero.unwrap_or(0)
        }

        pub fn clear_hero(&mut self) {
            self.hero = ::std::option::Option::None;
        }

        pub fn has_hero(&self) -> bool {
            self.hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero(&mut self, v: u32) {
            self.hero = ::std::option::Option::Some(v);
        }

        // optional uint32 team = 2;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero",
                |m: &PickBanDetails| { &m.hero },
                |m: &mut PickBanDetails| { &mut m.hero },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &PickBanDetails| { &m.team },
                |m: &mut PickBanDetails| { &mut m.team },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PickBanDetails>(
                "CMsgDOTARealtimeGameStatsTerse.PickBanDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PickBanDetails {
        const NAME: &'static str = "PickBanDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PickBanDetails {
            PickBanDetails::new()
        }

        fn clear(&mut self) {
            self.hero = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PickBanDetails {
            static instance: PickBanDetails = PickBanDetails {
                hero: ::std::option::Option::None,
                team: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PickBanDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStatsTerse.PickBanDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PickBanDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PickBanDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.server_steam_id)
        pub server_steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.game_time)
        pub game_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.steam_broadcaster_account_ids)
        pub steam_broadcaster_account_ids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.game_mode)
        pub game_mode: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.league_node_id)
        pub league_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.game_state)
        pub game_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.picks)
        pub picks: ::std::vec::Vec<PickBanDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.bans)
        pub bans: ::std::vec::Vec<PickBanDetails>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.lobby_type)
        pub lobby_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.start_timestamp)
        pub start_timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchDetails {
        fn default() -> &'a MatchDetails {
            <MatchDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl MatchDetails {
        pub fn new() -> MatchDetails {
            ::std::default::Default::default()
        }

        // optional fixed64 server_steam_id = 1;

        pub fn server_steam_id(&self) -> u64 {
            self.server_steam_id.unwrap_or(0)
        }

        pub fn clear_server_steam_id(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
        }

        pub fn has_server_steam_id(&self) -> bool {
            self.server_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_steam_id(&mut self, v: u64) {
            self.server_steam_id = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 2;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 3;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional int32 game_time = 4;

        pub fn game_time(&self) -> i32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: i32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        // optional uint32 game_mode = 7;

        pub fn game_mode(&self) -> u32 {
            self.game_mode.unwrap_or(0)
        }

        pub fn clear_game_mode(&mut self) {
            self.game_mode = ::std::option::Option::None;
        }

        pub fn has_game_mode(&self) -> bool {
            self.game_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_mode(&mut self, v: u32) {
            self.game_mode = ::std::option::Option::Some(v);
        }

        // optional uint32 league_id = 8;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 league_node_id = 9;

        pub fn league_node_id(&self) -> u32 {
            self.league_node_id.unwrap_or(0)
        }

        pub fn clear_league_node_id(&mut self) {
            self.league_node_id = ::std::option::Option::None;
        }

        pub fn has_league_node_id(&self) -> bool {
            self.league_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_node_id(&mut self, v: u32) {
            self.league_node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 game_state = 10;

        pub fn game_state(&self) -> u32 {
            self.game_state.unwrap_or(0)
        }

        pub fn clear_game_state(&mut self) {
            self.game_state = ::std::option::Option::None;
        }

        pub fn has_game_state(&self) -> bool {
            self.game_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_state(&mut self, v: u32) {
            self.game_state = ::std::option::Option::Some(v);
        }

        // optional uint32 lobby_type = 13;

        pub fn lobby_type(&self) -> u32 {
            self.lobby_type.unwrap_or(0)
        }

        pub fn clear_lobby_type(&mut self) {
            self.lobby_type = ::std::option::Option::None;
        }

        pub fn has_lobby_type(&self) -> bool {
            self.lobby_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_type(&mut self, v: u32) {
            self.lobby_type = ::std::option::Option::Some(v);
        }

        // optional uint32 start_timestamp = 14;

        pub fn start_timestamp(&self) -> u32 {
            self.start_timestamp.unwrap_or(0)
        }

        pub fn clear_start_timestamp(&mut self) {
            self.start_timestamp = ::std::option::Option::None;
        }

        pub fn has_start_timestamp(&self) -> bool {
            self.start_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_timestamp(&mut self, v: u32) {
            self.start_timestamp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_steam_id",
                |m: &MatchDetails| { &m.server_steam_id },
                |m: &mut MatchDetails| { &mut m.server_steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &MatchDetails| { &m.match_id },
                |m: &mut MatchDetails| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &MatchDetails| { &m.timestamp },
                |m: &mut MatchDetails| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_time",
                |m: &MatchDetails| { &m.game_time },
                |m: &mut MatchDetails| { &mut m.game_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "steam_broadcaster_account_ids",
                |m: &MatchDetails| { &m.steam_broadcaster_account_ids },
                |m: &mut MatchDetails| { &mut m.steam_broadcaster_account_ids },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_mode",
                |m: &MatchDetails| { &m.game_mode },
                |m: &mut MatchDetails| { &mut m.game_mode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &MatchDetails| { &m.league_id },
                |m: &mut MatchDetails| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_node_id",
                |m: &MatchDetails| { &m.league_node_id },
                |m: &mut MatchDetails| { &mut m.league_node_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_state",
                |m: &MatchDetails| { &m.game_state },
                |m: &mut MatchDetails| { &mut m.game_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "picks",
                |m: &MatchDetails| { &m.picks },
                |m: &mut MatchDetails| { &mut m.picks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bans",
                |m: &MatchDetails| { &m.bans },
                |m: &mut MatchDetails| { &mut m.bans },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lobby_type",
                |m: &MatchDetails| { &m.lobby_type },
                |m: &mut MatchDetails| { &mut m.lobby_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_timestamp",
                |m: &MatchDetails| { &m.start_timestamp },
                |m: &mut MatchDetails| { &mut m.start_timestamp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchDetails>(
                "CMsgDOTARealtimeGameStatsTerse.MatchDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MatchDetails {
        const NAME: &'static str = "MatchDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.steam_broadcaster_account_ids)?;
                    },
                    48 => {
                        self.steam_broadcaster_account_ids.push(is.read_uint32()?);
                    },
                    56 => {
                        self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.game_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    90 => {
                        self.picks.push(is.read_message()?);
                    },
                    98 => {
                        self.bans.push(is.read_message()?);
                    },
                    104 => {
                        self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_time {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            for value in &self.steam_broadcaster_account_ids {
                my_size += ::protobuf::rt::uint32_size(6, *value);
            };
            if let Some(v) = self.game_mode {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.league_node_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.game_state {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            for value in &self.picks {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.bans {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.lobby_type {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.start_timestamp {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server_steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_int32(4, v)?;
            }
            for v in &self.steam_broadcaster_account_ids {
                os.write_uint32(6, *v)?;
            };
            if let Some(v) = self.game_mode {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.league_node_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.game_state {
                os.write_uint32(10, v)?;
            }
            for v in &self.picks {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            };
            for v in &self.bans {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            };
            if let Some(v) = self.lobby_type {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.start_timestamp {
                os.write_uint32(14, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchDetails {
            MatchDetails::new()
        }

        fn clear(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.steam_broadcaster_account_ids.clear();
            self.game_mode = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.league_node_id = ::std::option::Option::None;
            self.game_state = ::std::option::Option::None;
            self.picks.clear();
            self.bans.clear();
            self.lobby_type = ::std::option::Option::None;
            self.start_timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchDetails {
            static instance: MatchDetails = MatchDetails {
                server_steam_id: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                steam_broadcaster_account_ids: ::std::vec::Vec::new(),
                game_mode: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                league_node_id: ::std::option::Option::None,
                game_state: ::std::option::Option::None,
                picks: ::std::vec::Vec::new(),
                bans: ::std::vec::Vec::new(),
                lobby_type: ::std::option::Option::None,
                start_timestamp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MatchDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStatsTerse.MatchDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MatchDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MatchDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTARealtimeGameStatsTerse.GraphData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GraphData {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTARealtimeGameStatsTerse.GraphData.graph_gold)
        pub graph_gold: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTARealtimeGameStatsTerse.GraphData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GraphData {
        fn default() -> &'a GraphData {
            <GraphData as ::protobuf::Message>::default_instance()
        }
    }

    impl GraphData {
        pub fn new() -> GraphData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "graph_gold",
                |m: &GraphData| { &m.graph_gold },
                |m: &mut GraphData| { &mut m.graph_gold },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GraphData>(
                "CMsgDOTARealtimeGameStatsTerse.GraphData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GraphData {
        const NAME: &'static str = "GraphData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_gold)?;
                    },
                    8 => {
                        self.graph_gold.push(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.graph_gold {
                my_size += ::protobuf::rt::int32_size(1, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.graph_gold {
                os.write_int32(1, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GraphData {
            GraphData::new()
        }

        fn clear(&mut self) {
            self.graph_gold.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GraphData {
            static instance: GraphData = GraphData {
                graph_gold: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GraphData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTARealtimeGameStatsTerse.GraphData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GraphData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GraphData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTABroadcastTimelineEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTABroadcastTimelineEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTABroadcastTimelineEvent.event)
    pub event: ::std::option::Option<::protobuf::EnumOrUnknown<EBroadcastTimelineEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABroadcastTimelineEvent.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABroadcastTimelineEvent.data)
    pub data: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABroadcastTimelineEvent.string_data)
    pub string_data: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTABroadcastTimelineEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTABroadcastTimelineEvent {
    fn default() -> &'a CMsgDOTABroadcastTimelineEvent {
        <CMsgDOTABroadcastTimelineEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTABroadcastTimelineEvent {
    pub fn new() -> CMsgDOTABroadcastTimelineEvent {
        ::std::default::Default::default()
    }

    // optional .dota.EBroadcastTimelineEvent event = 1;

    pub fn event(&self) -> EBroadcastTimelineEvent {
        match self.event {
            Some(e) => e.enum_value_or(EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted),
            None => EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted,
        }
    }

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: EBroadcastTimelineEvent) {
        self.event = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 data = 3;

    pub fn data(&self) -> u32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(v);
    }

    // optional string string_data = 4;

    pub fn string_data(&self) -> &str {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::std::string::String) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::std::string::String {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::std::string::String {
        self.string_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event",
            |m: &CMsgDOTABroadcastTimelineEvent| { &m.event },
            |m: &mut CMsgDOTABroadcastTimelineEvent| { &mut m.event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgDOTABroadcastTimelineEvent| { &m.timestamp },
            |m: &mut CMsgDOTABroadcastTimelineEvent| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CMsgDOTABroadcastTimelineEvent| { &m.data },
            |m: &mut CMsgDOTABroadcastTimelineEvent| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_data",
            |m: &CMsgDOTABroadcastTimelineEvent| { &m.string_data },
            |m: &mut CMsgDOTABroadcastTimelineEvent| { &mut m.string_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTABroadcastTimelineEvent>(
            "CMsgDOTABroadcastTimelineEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTABroadcastTimelineEvent {
    const NAME: &'static str = "CMsgDOTABroadcastTimelineEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                21 => {
                    self.timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.data = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.string_data = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.data {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTABroadcastTimelineEvent {
        CMsgDOTABroadcastTimelineEvent::new()
    }

    fn clear(&mut self) {
        self.event = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTABroadcastTimelineEvent {
        static instance: CMsgDOTABroadcastTimelineEvent = CMsgDOTABroadcastTimelineEvent {
            event: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            data: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTABroadcastTimelineEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTABroadcastTimelineEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTABroadcastTimelineEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTABroadcastTimelineEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientMatchGroupsVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientMatchGroupsVersion {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientMatchGroupsVersion.matchgroups_version)
    pub matchgroups_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientMatchGroupsVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientMatchGroupsVersion {
    fn default() -> &'a CMsgGCToClientMatchGroupsVersion {
        <CMsgGCToClientMatchGroupsVersion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientMatchGroupsVersion {
    pub fn new() -> CMsgGCToClientMatchGroupsVersion {
        ::std::default::Default::default()
    }

    // optional uint32 matchgroups_version = 1;

    pub fn matchgroups_version(&self) -> u32 {
        self.matchgroups_version.unwrap_or(0)
    }

    pub fn clear_matchgroups_version(&mut self) {
        self.matchgroups_version = ::std::option::Option::None;
    }

    pub fn has_matchgroups_version(&self) -> bool {
        self.matchgroups_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroups_version(&mut self, v: u32) {
        self.matchgroups_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchgroups_version",
            |m: &CMsgGCToClientMatchGroupsVersion| { &m.matchgroups_version },
            |m: &mut CMsgGCToClientMatchGroupsVersion| { &mut m.matchgroups_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientMatchGroupsVersion>(
            "CMsgGCToClientMatchGroupsVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientMatchGroupsVersion {
    const NAME: &'static str = "CMsgGCToClientMatchGroupsVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.matchgroups_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matchgroups_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matchgroups_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientMatchGroupsVersion {
        CMsgGCToClientMatchGroupsVersion::new()
    }

    fn clear(&mut self) {
        self.matchgroups_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientMatchGroupsVersion {
        static instance: CMsgGCToClientMatchGroupsVersion = CMsgGCToClientMatchGroupsVersion {
            matchgroups_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientMatchGroupsVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientMatchGroupsVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientMatchGroupsVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientMatchGroupsVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTASDOHeroStatsHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASDOHeroStatsHistory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.won)
    pub won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.gpm)
    pub gpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.xpm)
    pub xpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASDOHeroStatsHistory.assists)
    pub assists: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTASDOHeroStatsHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASDOHeroStatsHistory {
    fn default() -> &'a CMsgDOTASDOHeroStatsHistory {
        <CMsgDOTASDOHeroStatsHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASDOHeroStatsHistory {
    pub fn new() -> CMsgDOTASDOHeroStatsHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 2;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 3;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 4;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional bool won = 5;

    pub fn won(&self) -> bool {
        self.won.unwrap_or(false)
    }

    pub fn clear_won(&mut self) {
        self.won = ::std::option::Option::None;
    }

    pub fn has_won(&self) -> bool {
        self.won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_won(&mut self, v: bool) {
        self.won = ::std::option::Option::Some(v);
    }

    // optional uint32 gpm = 6;

    pub fn gpm(&self) -> u32 {
        self.gpm.unwrap_or(0)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: u32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional uint32 xpm = 7;

    pub fn xpm(&self) -> u32 {
        self.xpm.unwrap_or(0)
    }

    pub fn clear_xpm(&mut self) {
        self.xpm = ::std::option::Option::None;
    }

    pub fn has_xpm(&self) -> bool {
        self.xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpm(&mut self, v: u32) {
        self.xpm = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 8;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 9;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 10;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.match_id },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.game_mode },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.lobby_type },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.lobby_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.start_time },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "won",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.won },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.won },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpm",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.gpm },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.gpm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xpm",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.xpm },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.xpm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.kills },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaths",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.deaths },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assists",
            |m: &CMsgDOTASDOHeroStatsHistory| { &m.assists },
            |m: &mut CMsgDOTASDOHeroStatsHistory| { &mut m.assists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTASDOHeroStatsHistory>(
            "CMsgDOTASDOHeroStatsHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTASDOHeroStatsHistory {
    const NAME: &'static str = "CMsgDOTASDOHeroStatsHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.won = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.gpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.xpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.gpm {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.xpm {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.won {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.xpm {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASDOHeroStatsHistory {
        CMsgDOTASDOHeroStatsHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.won = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.xpm = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASDOHeroStatsHistory {
        static instance: CMsgDOTASDOHeroStatsHistory = CMsgDOTASDOHeroStatsHistory {
            match_id: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            won: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            xpm: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTASDOHeroStatsHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTASDOHeroStatsHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTASDOHeroStatsHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASDOHeroStatsHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPredictionChoice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPredictionChoice {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPredictionChoice.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPredictionChoice.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgPredictionChoice.min_raw_value)
    pub min_raw_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPredictionChoice.max_raw_value)
    pub max_raw_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPredictionChoice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPredictionChoice {
    fn default() -> &'a CMsgPredictionChoice {
        <CMsgPredictionChoice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPredictionChoice {
    pub fn new() -> CMsgPredictionChoice {
        ::std::default::Default::default()
    }

    // optional uint32 value = 1;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 min_raw_value = 3;

    pub fn min_raw_value(&self) -> u32 {
        self.min_raw_value.unwrap_or(0)
    }

    pub fn clear_min_raw_value(&mut self) {
        self.min_raw_value = ::std::option::Option::None;
    }

    pub fn has_min_raw_value(&self) -> bool {
        self.min_raw_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_raw_value(&mut self, v: u32) {
        self.min_raw_value = ::std::option::Option::Some(v);
    }

    // optional uint32 max_raw_value = 4;

    pub fn max_raw_value(&self) -> u32 {
        self.max_raw_value.unwrap_or(0)
    }

    pub fn clear_max_raw_value(&mut self) {
        self.max_raw_value = ::std::option::Option::None;
    }

    pub fn has_max_raw_value(&self) -> bool {
        self.max_raw_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_raw_value(&mut self, v: u32) {
        self.max_raw_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgPredictionChoice| { &m.value },
            |m: &mut CMsgPredictionChoice| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgPredictionChoice| { &m.name },
            |m: &mut CMsgPredictionChoice| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_raw_value",
            |m: &CMsgPredictionChoice| { &m.min_raw_value },
            |m: &mut CMsgPredictionChoice| { &mut m.min_raw_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_raw_value",
            |m: &CMsgPredictionChoice| { &m.max_raw_value },
            |m: &mut CMsgPredictionChoice| { &mut m.max_raw_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPredictionChoice>(
            "CMsgPredictionChoice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPredictionChoice {
    const NAME: &'static str = "CMsgPredictionChoice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.min_raw_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.max_raw_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.min_raw_value {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.max_raw_value {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.min_raw_value {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.max_raw_value {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPredictionChoice {
        CMsgPredictionChoice::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.min_raw_value = ::std::option::Option::None;
        self.max_raw_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPredictionChoice {
        static instance: CMsgPredictionChoice = CMsgPredictionChoice {
            value: ::std::option::Option::None,
            name: ::std::option::Option::None,
            min_raw_value: ::std::option::Option::None,
            max_raw_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPredictionChoice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPredictionChoice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPredictionChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPredictionChoice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgInGamePrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInGamePrediction {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_in_game_prediction::EPredictionType>>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.group)
    pub group: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_in_game_prediction::ERandomSelectionGroup_t>>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.question)
    pub question: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.choices)
    pub choices: ::std::vec::Vec<CMsgPredictionChoice>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.required_heroes)
    pub required_heroes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.query_name)
    pub query_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.query_values)
    pub query_values: ::std::vec::Vec<cmsg_in_game_prediction::QueryKeyValues>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.answer_resolution_type)
    pub answer_resolution_type: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_in_game_prediction::EResolutionType_t>>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.points_to_grant)
    pub points_to_grant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.reward_action)
    pub reward_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.debug_force_selection)
    pub debug_force_selection: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.raw_value_type)
    pub raw_value_type: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_in_game_prediction::ERawValueType_t>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgInGamePrediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInGamePrediction {
    fn default() -> &'a CMsgInGamePrediction {
        <CMsgInGamePrediction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInGamePrediction {
    pub fn new() -> CMsgInGamePrediction {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .dota.CMsgInGamePrediction.EPredictionType type = 3;

    pub fn type_(&self) -> cmsg_in_game_prediction::EPredictionType {
        match self.type_ {
            Some(e) => e.enum_value_or(cmsg_in_game_prediction::EPredictionType::Generic),
            None => cmsg_in_game_prediction::EPredictionType::Generic,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: cmsg_in_game_prediction::EPredictionType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.CMsgInGamePrediction.ERandomSelectionGroup_t group = 4;

    pub fn group(&self) -> cmsg_in_game_prediction::ERandomSelectionGroup_t {
        match self.group {
            Some(e) => e.enum_value_or(cmsg_in_game_prediction::ERandomSelectionGroup_t::EarlyGame),
            None => cmsg_in_game_prediction::ERandomSelectionGroup_t::EarlyGame,
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: cmsg_in_game_prediction::ERandomSelectionGroup_t) {
        self.group = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string question = 5;

    pub fn question(&self) -> &str {
        match self.question.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_question(&mut self) {
        self.question = ::std::option::Option::None;
    }

    pub fn has_question(&self) -> bool {
        self.question.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question(&mut self, v: ::std::string::String) {
        self.question = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_question(&mut self) -> &mut ::std::string::String {
        if self.question.is_none() {
            self.question = ::std::option::Option::Some(::std::string::String::new());
        }
        self.question.as_mut().unwrap()
    }

    // Take field
    pub fn take_question(&mut self) -> ::std::string::String {
        self.question.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string query_name = 8;

    pub fn query_name(&self) -> &str {
        match self.query_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_query_name(&mut self) {
        self.query_name = ::std::option::Option::None;
    }

    pub fn has_query_name(&self) -> bool {
        self.query_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_name(&mut self, v: ::std::string::String) {
        self.query_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query_name(&mut self) -> &mut ::std::string::String {
        if self.query_name.is_none() {
            self.query_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.query_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_query_name(&mut self) -> ::std::string::String {
        self.query_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .dota.CMsgInGamePrediction.EResolutionType_t answer_resolution_type = 10;

    pub fn answer_resolution_type(&self) -> cmsg_in_game_prediction::EResolutionType_t {
        match self.answer_resolution_type {
            Some(e) => e.enum_value_or(cmsg_in_game_prediction::EResolutionType_t::InvalidQuery),
            None => cmsg_in_game_prediction::EResolutionType_t::InvalidQuery,
        }
    }

    pub fn clear_answer_resolution_type(&mut self) {
        self.answer_resolution_type = ::std::option::Option::None;
    }

    pub fn has_answer_resolution_type(&self) -> bool {
        self.answer_resolution_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_resolution_type(&mut self, v: cmsg_in_game_prediction::EResolutionType_t) {
        self.answer_resolution_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 points_to_grant = 11;

    pub fn points_to_grant(&self) -> u32 {
        self.points_to_grant.unwrap_or(0)
    }

    pub fn clear_points_to_grant(&mut self) {
        self.points_to_grant = ::std::option::Option::None;
    }

    pub fn has_points_to_grant(&self) -> bool {
        self.points_to_grant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_to_grant(&mut self, v: u32) {
        self.points_to_grant = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_action = 12;

    pub fn reward_action(&self) -> u32 {
        self.reward_action.unwrap_or(0)
    }

    pub fn clear_reward_action(&mut self) {
        self.reward_action = ::std::option::Option::None;
    }

    pub fn has_reward_action(&self) -> bool {
        self.reward_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_action(&mut self, v: u32) {
        self.reward_action = ::std::option::Option::Some(v);
    }

    // optional uint32 debug_force_selection = 13;

    pub fn debug_force_selection(&self) -> u32 {
        self.debug_force_selection.unwrap_or(0)
    }

    pub fn clear_debug_force_selection(&mut self) {
        self.debug_force_selection = ::std::option::Option::None;
    }

    pub fn has_debug_force_selection(&self) -> bool {
        self.debug_force_selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_force_selection(&mut self, v: u32) {
        self.debug_force_selection = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgInGamePrediction.ERawValueType_t raw_value_type = 14;

    pub fn raw_value_type(&self) -> cmsg_in_game_prediction::ERawValueType_t {
        match self.raw_value_type {
            Some(e) => e.enum_value_or(cmsg_in_game_prediction::ERawValueType_t::Number),
            None => cmsg_in_game_prediction::ERawValueType_t::Number,
        }
    }

    pub fn clear_raw_value_type(&mut self) {
        self.raw_value_type = ::std::option::Option::None;
    }

    pub fn has_raw_value_type(&self) -> bool {
        self.raw_value_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_value_type(&mut self, v: cmsg_in_game_prediction::ERawValueType_t) {
        self.raw_value_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgInGamePrediction| { &m.id },
            |m: &mut CMsgInGamePrediction| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgInGamePrediction| { &m.name },
            |m: &mut CMsgInGamePrediction| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgInGamePrediction| { &m.type_ },
            |m: &mut CMsgInGamePrediction| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &CMsgInGamePrediction| { &m.group },
            |m: &mut CMsgInGamePrediction| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "question",
            |m: &CMsgInGamePrediction| { &m.question },
            |m: &mut CMsgInGamePrediction| { &mut m.question },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "choices",
            |m: &CMsgInGamePrediction| { &m.choices },
            |m: &mut CMsgInGamePrediction| { &mut m.choices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "required_heroes",
            |m: &CMsgInGamePrediction| { &m.required_heroes },
            |m: &mut CMsgInGamePrediction| { &mut m.required_heroes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "query_name",
            |m: &CMsgInGamePrediction| { &m.query_name },
            |m: &mut CMsgInGamePrediction| { &mut m.query_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "query_values",
            |m: &CMsgInGamePrediction| { &m.query_values },
            |m: &mut CMsgInGamePrediction| { &mut m.query_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "answer_resolution_type",
            |m: &CMsgInGamePrediction| { &m.answer_resolution_type },
            |m: &mut CMsgInGamePrediction| { &mut m.answer_resolution_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_to_grant",
            |m: &CMsgInGamePrediction| { &m.points_to_grant },
            |m: &mut CMsgInGamePrediction| { &mut m.points_to_grant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_action",
            |m: &CMsgInGamePrediction| { &m.reward_action },
            |m: &mut CMsgInGamePrediction| { &mut m.reward_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_force_selection",
            |m: &CMsgInGamePrediction| { &m.debug_force_selection },
            |m: &mut CMsgInGamePrediction| { &mut m.debug_force_selection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_value_type",
            |m: &CMsgInGamePrediction| { &m.raw_value_type },
            |m: &mut CMsgInGamePrediction| { &mut m.raw_value_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgInGamePrediction>(
            "CMsgInGamePrediction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgInGamePrediction {
    const NAME: &'static str = "CMsgInGamePrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.question = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.choices.push(is.read_message()?);
                },
                58 => {
                    self.required_heroes.push(is.read_string()?);
                },
                66 => {
                    self.query_name = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.query_values.push(is.read_message()?);
                },
                80 => {
                    self.answer_resolution_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.points_to_grant = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.reward_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.debug_force_selection = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.raw_value_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.group {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.question.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.choices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.required_heroes {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.query_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.query_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.answer_resolution_type {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.points_to_grant {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.reward_action {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.debug_force_selection {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.raw_value_type {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.group {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.question.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.choices {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.required_heroes {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.query_name.as_ref() {
            os.write_string(8, v)?;
        }
        for v in &self.query_values {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.answer_resolution_type {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.points_to_grant {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reward_action {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.debug_force_selection {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.raw_value_type {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInGamePrediction {
        CMsgInGamePrediction::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.group = ::std::option::Option::None;
        self.question = ::std::option::Option::None;
        self.choices.clear();
        self.required_heroes.clear();
        self.query_name = ::std::option::Option::None;
        self.query_values.clear();
        self.answer_resolution_type = ::std::option::Option::None;
        self.points_to_grant = ::std::option::Option::None;
        self.reward_action = ::std::option::Option::None;
        self.debug_force_selection = ::std::option::Option::None;
        self.raw_value_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInGamePrediction {
        static instance: CMsgInGamePrediction = CMsgInGamePrediction {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            group: ::std::option::Option::None,
            question: ::std::option::Option::None,
            choices: ::std::vec::Vec::new(),
            required_heroes: ::std::vec::Vec::new(),
            query_name: ::std::option::Option::None,
            query_values: ::std::vec::Vec::new(),
            answer_resolution_type: ::std::option::Option::None,
            points_to_grant: ::std::option::Option::None,
            reward_action: ::std::option::Option::None,
            debug_force_selection: ::std::option::Option::None,
            raw_value_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgInGamePrediction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgInGamePrediction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgInGamePrediction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInGamePrediction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgInGamePrediction`
pub mod cmsg_in_game_prediction {
    // @@protoc_insertion_point(message:dota.CMsgInGamePrediction.QueryKeyValues)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QueryKeyValues {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.QueryKeyValues.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgInGamePrediction.QueryKeyValues.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgInGamePrediction.QueryKeyValues.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QueryKeyValues {
        fn default() -> &'a QueryKeyValues {
            <QueryKeyValues as ::protobuf::Message>::default_instance()
        }
    }

    impl QueryKeyValues {
        pub fn new() -> QueryKeyValues {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &QueryKeyValues| { &m.name },
                |m: &mut QueryKeyValues| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &QueryKeyValues| { &m.value },
                |m: &mut QueryKeyValues| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryKeyValues>(
                "CMsgInGamePrediction.QueryKeyValues",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QueryKeyValues {
        const NAME: &'static str = "QueryKeyValues";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QueryKeyValues {
            QueryKeyValues::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QueryKeyValues {
            static instance: QueryKeyValues = QueryKeyValues {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for QueryKeyValues {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgInGamePrediction.QueryKeyValues").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QueryKeyValues {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QueryKeyValues {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgInGamePrediction.ERawValueType_t)
    pub enum ERawValueType_t {
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.ERawValueType_t.Number)
        Number = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.ERawValueType_t.Time)
        Time = 1,
    }

    impl ::protobuf::Enum for ERawValueType_t {
        const NAME: &'static str = "ERawValueType_t";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ERawValueType_t> {
            match value {
                0 => ::std::option::Option::Some(ERawValueType_t::Number),
                1 => ::std::option::Option::Some(ERawValueType_t::Time),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ERawValueType_t> {
            match str {
                "Number" => ::std::option::Option::Some(ERawValueType_t::Number),
                "Time" => ::std::option::Option::Some(ERawValueType_t::Time),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ERawValueType_t] = &[
            ERawValueType_t::Number,
            ERawValueType_t::Time,
        ];
    }

    impl ::protobuf::EnumFull for ERawValueType_t {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgInGamePrediction.ERawValueType_t").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ERawValueType_t {
        fn default() -> Self {
            ERawValueType_t::Number
        }
    }

    impl ERawValueType_t {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERawValueType_t>("CMsgInGamePrediction.ERawValueType_t")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgInGamePrediction.EPredictionType)
    pub enum EPredictionType {
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EPredictionType.Generic)
        Generic = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EPredictionType.Hero)
        Hero = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EPredictionType.Team)
        Team = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EPredictionType.Player)
        Player = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EPredictionType.Special)
        Special = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EPredictionType.YesNo)
        YesNo = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EPredictionType.QualifiersTeam)
        QualifiersTeam = 6,
    }

    impl ::protobuf::Enum for EPredictionType {
        const NAME: &'static str = "EPredictionType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EPredictionType> {
            match value {
                0 => ::std::option::Option::Some(EPredictionType::Generic),
                1 => ::std::option::Option::Some(EPredictionType::Hero),
                2 => ::std::option::Option::Some(EPredictionType::Team),
                3 => ::std::option::Option::Some(EPredictionType::Player),
                4 => ::std::option::Option::Some(EPredictionType::Special),
                5 => ::std::option::Option::Some(EPredictionType::YesNo),
                6 => ::std::option::Option::Some(EPredictionType::QualifiersTeam),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EPredictionType> {
            match str {
                "Generic" => ::std::option::Option::Some(EPredictionType::Generic),
                "Hero" => ::std::option::Option::Some(EPredictionType::Hero),
                "Team" => ::std::option::Option::Some(EPredictionType::Team),
                "Player" => ::std::option::Option::Some(EPredictionType::Player),
                "Special" => ::std::option::Option::Some(EPredictionType::Special),
                "YesNo" => ::std::option::Option::Some(EPredictionType::YesNo),
                "QualifiersTeam" => ::std::option::Option::Some(EPredictionType::QualifiersTeam),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EPredictionType] = &[
            EPredictionType::Generic,
            EPredictionType::Hero,
            EPredictionType::Team,
            EPredictionType::Player,
            EPredictionType::Special,
            EPredictionType::YesNo,
            EPredictionType::QualifiersTeam,
        ];
    }

    impl ::protobuf::EnumFull for EPredictionType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgInGamePrediction.EPredictionType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EPredictionType {
        fn default() -> Self {
            EPredictionType::Generic
        }
    }

    impl EPredictionType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPredictionType>("CMsgInGamePrediction.EPredictionType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgInGamePrediction.EResolutionType_t)
    pub enum EResolutionType_t {
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EResolutionType_t.InvalidQuery)
        InvalidQuery = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EResolutionType_t.FirstToPassQuery)
        FirstToPassQuery = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EResolutionType_t.LastToPassQuery)
        LastToPassQuery = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EResolutionType_t.LastRemainingQuery)
        LastRemainingQuery = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EResolutionType_t.MaxToPassQuery)
        MaxToPassQuery = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EResolutionType_t.MinToPassQuery)
        MinToPassQuery = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EResolutionType_t.SumQuery)
        SumQuery = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EResolutionType_t.MaxTeamSumToPassQuery)
        MaxTeamSumToPassQuery = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.EResolutionType_t.MinTeamSumToPassQuery)
        MinTeamSumToPassQuery = 8,
    }

    impl ::protobuf::Enum for EResolutionType_t {
        const NAME: &'static str = "EResolutionType_t";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResolutionType_t> {
            match value {
                0 => ::std::option::Option::Some(EResolutionType_t::InvalidQuery),
                1 => ::std::option::Option::Some(EResolutionType_t::FirstToPassQuery),
                2 => ::std::option::Option::Some(EResolutionType_t::LastToPassQuery),
                3 => ::std::option::Option::Some(EResolutionType_t::LastRemainingQuery),
                4 => ::std::option::Option::Some(EResolutionType_t::MaxToPassQuery),
                5 => ::std::option::Option::Some(EResolutionType_t::MinToPassQuery),
                6 => ::std::option::Option::Some(EResolutionType_t::SumQuery),
                7 => ::std::option::Option::Some(EResolutionType_t::MaxTeamSumToPassQuery),
                8 => ::std::option::Option::Some(EResolutionType_t::MinTeamSumToPassQuery),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResolutionType_t> {
            match str {
                "InvalidQuery" => ::std::option::Option::Some(EResolutionType_t::InvalidQuery),
                "FirstToPassQuery" => ::std::option::Option::Some(EResolutionType_t::FirstToPassQuery),
                "LastToPassQuery" => ::std::option::Option::Some(EResolutionType_t::LastToPassQuery),
                "LastRemainingQuery" => ::std::option::Option::Some(EResolutionType_t::LastRemainingQuery),
                "MaxToPassQuery" => ::std::option::Option::Some(EResolutionType_t::MaxToPassQuery),
                "MinToPassQuery" => ::std::option::Option::Some(EResolutionType_t::MinToPassQuery),
                "SumQuery" => ::std::option::Option::Some(EResolutionType_t::SumQuery),
                "MaxTeamSumToPassQuery" => ::std::option::Option::Some(EResolutionType_t::MaxTeamSumToPassQuery),
                "MinTeamSumToPassQuery" => ::std::option::Option::Some(EResolutionType_t::MinTeamSumToPassQuery),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResolutionType_t] = &[
            EResolutionType_t::InvalidQuery,
            EResolutionType_t::FirstToPassQuery,
            EResolutionType_t::LastToPassQuery,
            EResolutionType_t::LastRemainingQuery,
            EResolutionType_t::MaxToPassQuery,
            EResolutionType_t::MinToPassQuery,
            EResolutionType_t::SumQuery,
            EResolutionType_t::MaxTeamSumToPassQuery,
            EResolutionType_t::MinTeamSumToPassQuery,
        ];
    }

    impl ::protobuf::EnumFull for EResolutionType_t {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgInGamePrediction.EResolutionType_t").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResolutionType_t {
        fn default() -> Self {
            EResolutionType_t::InvalidQuery
        }
    }

    impl EResolutionType_t {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResolutionType_t>("CMsgInGamePrediction.EResolutionType_t")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgInGamePrediction.ERandomSelectionGroup_t)
    pub enum ERandomSelectionGroup_t {
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.ERandomSelectionGroup_t.EarlyGame)
        EarlyGame = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.ERandomSelectionGroup_t.MidGame)
        MidGame = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.ERandomSelectionGroup_t.LateGame)
        LateGame = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgInGamePrediction.ERandomSelectionGroup_t.Count)
        Count = 3,
    }

    impl ::protobuf::Enum for ERandomSelectionGroup_t {
        const NAME: &'static str = "ERandomSelectionGroup_t";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ERandomSelectionGroup_t> {
            match value {
                0 => ::std::option::Option::Some(ERandomSelectionGroup_t::EarlyGame),
                1 => ::std::option::Option::Some(ERandomSelectionGroup_t::MidGame),
                2 => ::std::option::Option::Some(ERandomSelectionGroup_t::LateGame),
                3 => ::std::option::Option::Some(ERandomSelectionGroup_t::Count),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ERandomSelectionGroup_t> {
            match str {
                "EarlyGame" => ::std::option::Option::Some(ERandomSelectionGroup_t::EarlyGame),
                "MidGame" => ::std::option::Option::Some(ERandomSelectionGroup_t::MidGame),
                "LateGame" => ::std::option::Option::Some(ERandomSelectionGroup_t::LateGame),
                "Count" => ::std::option::Option::Some(ERandomSelectionGroup_t::Count),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ERandomSelectionGroup_t] = &[
            ERandomSelectionGroup_t::EarlyGame,
            ERandomSelectionGroup_t::MidGame,
            ERandomSelectionGroup_t::LateGame,
            ERandomSelectionGroup_t::Count,
        ];
    }

    impl ::protobuf::EnumFull for ERandomSelectionGroup_t {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgInGamePrediction.ERandomSelectionGroup_t").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ERandomSelectionGroup_t {
        fn default() -> Self {
            ERandomSelectionGroup_t::EarlyGame
        }
    }

    impl ERandomSelectionGroup_t {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERandomSelectionGroup_t>("CMsgInGamePrediction.ERandomSelectionGroup_t")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTASeasonPredictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASeasonPredictions {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.predictions)
    pub predictions: ::std::vec::Vec<cmsg_dotaseason_predictions::Prediction>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.in_game_predictions)
    pub in_game_predictions: ::std::vec::Vec<CMsgInGamePrediction>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.in_game_prediction_count_per_game)
    pub in_game_prediction_count_per_game: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.in_game_prediction_voting_period_minutes)
    pub in_game_prediction_voting_period_minutes: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTASeasonPredictions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASeasonPredictions {
    fn default() -> &'a CMsgDOTASeasonPredictions {
        <CMsgDOTASeasonPredictions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASeasonPredictions {
    pub fn new() -> CMsgDOTASeasonPredictions {
        ::std::default::Default::default()
    }

    // optional uint32 in_game_prediction_count_per_game = 3;

    pub fn in_game_prediction_count_per_game(&self) -> u32 {
        self.in_game_prediction_count_per_game.unwrap_or(0)
    }

    pub fn clear_in_game_prediction_count_per_game(&mut self) {
        self.in_game_prediction_count_per_game = ::std::option::Option::None;
    }

    pub fn has_in_game_prediction_count_per_game(&self) -> bool {
        self.in_game_prediction_count_per_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_prediction_count_per_game(&mut self, v: u32) {
        self.in_game_prediction_count_per_game = ::std::option::Option::Some(v);
    }

    // optional uint32 in_game_prediction_voting_period_minutes = 4;

    pub fn in_game_prediction_voting_period_minutes(&self) -> u32 {
        self.in_game_prediction_voting_period_minutes.unwrap_or(0)
    }

    pub fn clear_in_game_prediction_voting_period_minutes(&mut self) {
        self.in_game_prediction_voting_period_minutes = ::std::option::Option::None;
    }

    pub fn has_in_game_prediction_voting_period_minutes(&self) -> bool {
        self.in_game_prediction_voting_period_minutes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_prediction_voting_period_minutes(&mut self, v: u32) {
        self.in_game_prediction_voting_period_minutes = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "predictions",
            |m: &CMsgDOTASeasonPredictions| { &m.predictions },
            |m: &mut CMsgDOTASeasonPredictions| { &mut m.predictions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "in_game_predictions",
            |m: &CMsgDOTASeasonPredictions| { &m.in_game_predictions },
            |m: &mut CMsgDOTASeasonPredictions| { &mut m.in_game_predictions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_game_prediction_count_per_game",
            |m: &CMsgDOTASeasonPredictions| { &m.in_game_prediction_count_per_game },
            |m: &mut CMsgDOTASeasonPredictions| { &mut m.in_game_prediction_count_per_game },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_game_prediction_voting_period_minutes",
            |m: &CMsgDOTASeasonPredictions| { &m.in_game_prediction_voting_period_minutes },
            |m: &mut CMsgDOTASeasonPredictions| { &mut m.in_game_prediction_voting_period_minutes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTASeasonPredictions>(
            "CMsgDOTASeasonPredictions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTASeasonPredictions {
    const NAME: &'static str = "CMsgDOTASeasonPredictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.predictions.push(is.read_message()?);
                },
                18 => {
                    self.in_game_predictions.push(is.read_message()?);
                },
                24 => {
                    self.in_game_prediction_count_per_game = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.in_game_prediction_voting_period_minutes = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.in_game_predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.in_game_prediction_count_per_game {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.in_game_prediction_voting_period_minutes {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.predictions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.in_game_predictions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.in_game_prediction_count_per_game {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_game_prediction_voting_period_minutes {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASeasonPredictions {
        CMsgDOTASeasonPredictions::new()
    }

    fn clear(&mut self) {
        self.predictions.clear();
        self.in_game_predictions.clear();
        self.in_game_prediction_count_per_game = ::std::option::Option::None;
        self.in_game_prediction_voting_period_minutes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASeasonPredictions {
        static instance: CMsgDOTASeasonPredictions = CMsgDOTASeasonPredictions {
            predictions: ::std::vec::Vec::new(),
            in_game_predictions: ::std::vec::Vec::new(),
            in_game_prediction_count_per_game: ::std::option::Option::None,
            in_game_prediction_voting_period_minutes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTASeasonPredictions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTASeasonPredictions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTASeasonPredictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTASeasonPredictions`
pub mod cmsg_dotaseason_predictions {
    // @@protoc_insertion_point(message:dota.CMsgDOTASeasonPredictions.Prediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Prediction {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.type)
        pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<prediction::EPredictionType>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.question)
        pub question: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.choices)
        pub choices: ::std::vec::Vec<super::CMsgPredictionChoice>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.selection_id)
        pub selection_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.start_date)
        pub start_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.lock_date)
        pub lock_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.reward)
        pub reward: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.answer_type)
        pub answer_type: ::std::option::Option<::protobuf::EnumOrUnknown<prediction::EAnswerType>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.answer_id)
        pub answer_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.answers)
        pub answers: ::std::vec::Vec<prediction::Answers>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.query_name)
        pub query_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.lock_on_selection_id)
        pub lock_on_selection_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.lock_on_selection_value)
        pub lock_on_selection_value: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.lock_on_selection_set)
        pub lock_on_selection_set: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.use_answer_value_ranges)
        pub use_answer_value_ranges: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.region)
        pub region: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueRegion>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.phases)
        pub phases: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeaguePhase>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.reward_event)
        pub reward_event: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTASeasonPredictions.Prediction.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Prediction {
        fn default() -> &'a Prediction {
            <Prediction as ::protobuf::Message>::default_instance()
        }
    }

    impl Prediction {
        pub fn new() -> Prediction {
            ::std::default::Default::default()
        }

        // optional .dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType type = 1;

        pub fn type_(&self) -> prediction::EPredictionType {
            match self.type_ {
                Some(e) => e.enum_value_or(prediction::EPredictionType::Generic),
                None => prediction::EPredictionType::Generic,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: prediction::EPredictionType) {
            self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string question = 2;

        pub fn question(&self) -> &str {
            match self.question.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_question(&mut self) {
            self.question = ::std::option::Option::None;
        }

        pub fn has_question(&self) -> bool {
            self.question.is_some()
        }

        // Param is passed by value, moved
        pub fn set_question(&mut self, v: ::std::string::String) {
            self.question = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_question(&mut self) -> &mut ::std::string::String {
            if self.question.is_none() {
                self.question = ::std::option::Option::Some(::std::string::String::new());
            }
            self.question.as_mut().unwrap()
        }

        // Take field
        pub fn take_question(&mut self) -> ::std::string::String {
            self.question.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 selection_id = 4;

        pub fn selection_id(&self) -> u32 {
            self.selection_id.unwrap_or(0)
        }

        pub fn clear_selection_id(&mut self) {
            self.selection_id = ::std::option::Option::None;
        }

        pub fn has_selection_id(&self) -> bool {
            self.selection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selection_id(&mut self, v: u32) {
            self.selection_id = ::std::option::Option::Some(v);
        }

        // optional uint32 start_date = 5;

        pub fn start_date(&self) -> u32 {
            self.start_date.unwrap_or(0)
        }

        pub fn clear_start_date(&mut self) {
            self.start_date = ::std::option::Option::None;
        }

        pub fn has_start_date(&self) -> bool {
            self.start_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_date(&mut self, v: u32) {
            self.start_date = ::std::option::Option::Some(v);
        }

        // optional uint32 lock_date = 6;

        pub fn lock_date(&self) -> u32 {
            self.lock_date.unwrap_or(0)
        }

        pub fn clear_lock_date(&mut self) {
            self.lock_date = ::std::option::Option::None;
        }

        pub fn has_lock_date(&self) -> bool {
            self.lock_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lock_date(&mut self, v: u32) {
            self.lock_date = ::std::option::Option::Some(v);
        }

        // optional uint32 reward = 7;

        pub fn reward(&self) -> u32 {
            self.reward.unwrap_or(0)
        }

        pub fn clear_reward(&mut self) {
            self.reward = ::std::option::Option::None;
        }

        pub fn has_reward(&self) -> bool {
            self.reward.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reward(&mut self, v: u32) {
            self.reward = ::std::option::Option::Some(v);
        }

        // optional .dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType answer_type = 8;

        pub fn answer_type(&self) -> prediction::EAnswerType {
            match self.answer_type {
                Some(e) => e.enum_value_or(prediction::EAnswerType::SingleInt),
                None => prediction::EAnswerType::SingleInt,
            }
        }

        pub fn clear_answer_type(&mut self) {
            self.answer_type = ::std::option::Option::None;
        }

        pub fn has_answer_type(&self) -> bool {
            self.answer_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_type(&mut self, v: prediction::EAnswerType) {
            self.answer_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 answer_id = 9;

        pub fn answer_id(&self) -> u32 {
            self.answer_id.unwrap_or(0)
        }

        pub fn clear_answer_id(&mut self) {
            self.answer_id = ::std::option::Option::None;
        }

        pub fn has_answer_id(&self) -> bool {
            self.answer_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_id(&mut self, v: u32) {
            self.answer_id = ::std::option::Option::Some(v);
        }

        // optional string query_name = 11;

        pub fn query_name(&self) -> &str {
            match self.query_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_query_name(&mut self) {
            self.query_name = ::std::option::Option::None;
        }

        pub fn has_query_name(&self) -> bool {
            self.query_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_query_name(&mut self, v: ::std::string::String) {
            self.query_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_query_name(&mut self) -> &mut ::std::string::String {
            if self.query_name.is_none() {
                self.query_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.query_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_query_name(&mut self) -> ::std::string::String {
            self.query_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 lock_on_selection_id = 13;

        pub fn lock_on_selection_id(&self) -> u32 {
            self.lock_on_selection_id.unwrap_or(0)
        }

        pub fn clear_lock_on_selection_id(&mut self) {
            self.lock_on_selection_id = ::std::option::Option::None;
        }

        pub fn has_lock_on_selection_id(&self) -> bool {
            self.lock_on_selection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lock_on_selection_id(&mut self, v: u32) {
            self.lock_on_selection_id = ::std::option::Option::Some(v);
        }

        // optional uint32 lock_on_selection_value = 14;

        pub fn lock_on_selection_value(&self) -> u32 {
            self.lock_on_selection_value.unwrap_or(0)
        }

        pub fn clear_lock_on_selection_value(&mut self) {
            self.lock_on_selection_value = ::std::option::Option::None;
        }

        pub fn has_lock_on_selection_value(&self) -> bool {
            self.lock_on_selection_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lock_on_selection_value(&mut self, v: u32) {
            self.lock_on_selection_value = ::std::option::Option::Some(v);
        }

        // optional bool lock_on_selection_set = 15;

        pub fn lock_on_selection_set(&self) -> bool {
            self.lock_on_selection_set.unwrap_or(false)
        }

        pub fn clear_lock_on_selection_set(&mut self) {
            self.lock_on_selection_set = ::std::option::Option::None;
        }

        pub fn has_lock_on_selection_set(&self) -> bool {
            self.lock_on_selection_set.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lock_on_selection_set(&mut self, v: bool) {
            self.lock_on_selection_set = ::std::option::Option::Some(v);
        }

        // optional bool use_answer_value_ranges = 16;

        pub fn use_answer_value_ranges(&self) -> bool {
            self.use_answer_value_ranges.unwrap_or(false)
        }

        pub fn clear_use_answer_value_ranges(&mut self) {
            self.use_answer_value_ranges = ::std::option::Option::None;
        }

        pub fn has_use_answer_value_ranges(&self) -> bool {
            self.use_answer_value_ranges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use_answer_value_ranges(&mut self, v: bool) {
            self.use_answer_value_ranges = ::std::option::Option::Some(v);
        }

        // optional .dota.ELeagueRegion region = 17;

        pub fn region(&self) -> super::super::dota_shared_enums::ELeagueRegion {
            match self.region {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
                None => super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
            }
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: super::super::dota_shared_enums::ELeagueRegion) {
            self.region = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .dota.EEvent reward_event = 19;

        pub fn reward_event(&self) -> super::super::dota_shared_enums::EEvent {
            match self.reward_event {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_reward_event(&mut self) {
            self.reward_event = ::std::option::Option::None;
        }

        pub fn has_reward_event(&self) -> bool {
            self.reward_event.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reward_event(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.reward_event = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(18);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Prediction| { &m.type_ },
                |m: &mut Prediction| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "question",
                |m: &Prediction| { &m.question },
                |m: &mut Prediction| { &mut m.question },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "choices",
                |m: &Prediction| { &m.choices },
                |m: &mut Prediction| { &mut m.choices },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "selection_id",
                |m: &Prediction| { &m.selection_id },
                |m: &mut Prediction| { &mut m.selection_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_date",
                |m: &Prediction| { &m.start_date },
                |m: &mut Prediction| { &mut m.start_date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lock_date",
                |m: &Prediction| { &m.lock_date },
                |m: &mut Prediction| { &mut m.lock_date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "reward",
                |m: &Prediction| { &m.reward },
                |m: &mut Prediction| { &mut m.reward },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "answer_type",
                |m: &Prediction| { &m.answer_type },
                |m: &mut Prediction| { &mut m.answer_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "answer_id",
                |m: &Prediction| { &m.answer_id },
                |m: &mut Prediction| { &mut m.answer_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "answers",
                |m: &Prediction| { &m.answers },
                |m: &mut Prediction| { &mut m.answers },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "query_name",
                |m: &Prediction| { &m.query_name },
                |m: &mut Prediction| { &mut m.query_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lock_on_selection_id",
                |m: &Prediction| { &m.lock_on_selection_id },
                |m: &mut Prediction| { &mut m.lock_on_selection_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lock_on_selection_value",
                |m: &Prediction| { &m.lock_on_selection_value },
                |m: &mut Prediction| { &mut m.lock_on_selection_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lock_on_selection_set",
                |m: &Prediction| { &m.lock_on_selection_set },
                |m: &mut Prediction| { &mut m.lock_on_selection_set },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "use_answer_value_ranges",
                |m: &Prediction| { &m.use_answer_value_ranges },
                |m: &mut Prediction| { &mut m.use_answer_value_ranges },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "region",
                |m: &Prediction| { &m.region },
                |m: &mut Prediction| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "phases",
                |m: &Prediction| { &m.phases },
                |m: &mut Prediction| { &mut m.phases },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "reward_event",
                |m: &Prediction| { &m.reward_event },
                |m: &mut Prediction| { &mut m.reward_event },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Prediction>(
                "CMsgDOTASeasonPredictions.Prediction",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Prediction {
        const NAME: &'static str = "Prediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.question = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.choices.push(is.read_message()?);
                    },
                    32 => {
                        self.selection_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.start_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.lock_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.reward = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.answer_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    72 => {
                        self.answer_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    82 => {
                        self.answers.push(is.read_message()?);
                    },
                    90 => {
                        self.query_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    104 => {
                        self.lock_on_selection_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.lock_on_selection_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.lock_on_selection_set = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.use_answer_value_ranges = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    144 => {
                        self.phases.push(is.read_enum_or_unknown()?);
                    },
                    146 => {
                        ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.phases)?
                    },
                    152 => {
                        self.reward_event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.question.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            for value in &self.choices {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.selection_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.start_date {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.lock_date {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.reward {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.answer_type {
                my_size += ::protobuf::rt::int32_size(8, v.value());
            }
            if let Some(v) = self.answer_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            for value in &self.answers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.query_name.as_ref() {
                my_size += ::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.lock_on_selection_id {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.lock_on_selection_value {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.lock_on_selection_set {
                my_size += 1 + 1;
            }
            if let Some(v) = self.use_answer_value_ranges {
                my_size += 2 + 1;
            }
            if let Some(v) = self.region {
                my_size += ::protobuf::rt::int32_size(17, v.value());
            }
            for value in &self.phases {
                my_size += ::protobuf::rt::int32_size(18, value.value());
            };
            if let Some(v) = self.reward_event {
                my_size += ::protobuf::rt::int32_size(19, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.question.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.choices {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.selection_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.start_date {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.lock_date {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.reward {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.answer_type {
                os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.answer_id {
                os.write_uint32(9, v)?;
            }
            for v in &self.answers {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            };
            if let Some(v) = self.query_name.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.lock_on_selection_id {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.lock_on_selection_value {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.lock_on_selection_set {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.use_answer_value_ranges {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.region {
                os.write_enum(17, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.phases {
                os.write_enum(18, ::protobuf::EnumOrUnknown::value(v))?;
            };
            if let Some(v) = self.reward_event {
                os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Prediction {
            Prediction::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.question = ::std::option::Option::None;
            self.choices.clear();
            self.selection_id = ::std::option::Option::None;
            self.start_date = ::std::option::Option::None;
            self.lock_date = ::std::option::Option::None;
            self.reward = ::std::option::Option::None;
            self.answer_type = ::std::option::Option::None;
            self.answer_id = ::std::option::Option::None;
            self.answers.clear();
            self.query_name = ::std::option::Option::None;
            self.lock_on_selection_id = ::std::option::Option::None;
            self.lock_on_selection_value = ::std::option::Option::None;
            self.lock_on_selection_set = ::std::option::Option::None;
            self.use_answer_value_ranges = ::std::option::Option::None;
            self.region = ::std::option::Option::None;
            self.phases.clear();
            self.reward_event = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Prediction {
            static instance: Prediction = Prediction {
                type_: ::std::option::Option::None,
                question: ::std::option::Option::None,
                choices: ::std::vec::Vec::new(),
                selection_id: ::std::option::Option::None,
                start_date: ::std::option::Option::None,
                lock_date: ::std::option::Option::None,
                reward: ::std::option::Option::None,
                answer_type: ::std::option::Option::None,
                answer_id: ::std::option::Option::None,
                answers: ::std::vec::Vec::new(),
                query_name: ::std::option::Option::None,
                lock_on_selection_id: ::std::option::Option::None,
                lock_on_selection_value: ::std::option::Option::None,
                lock_on_selection_set: ::std::option::Option::None,
                use_answer_value_ranges: ::std::option::Option::None,
                region: ::std::option::Option::None,
                phases: ::std::vec::Vec::new(),
                reward_event: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Prediction {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTASeasonPredictions.Prediction").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Prediction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Prediction {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Prediction`
    pub mod prediction {
        // @@protoc_insertion_point(message:dota.CMsgDOTASeasonPredictions.Prediction.Answers)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Answers {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTASeasonPredictions.Prediction.Answers.answer_id)
            pub answer_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTASeasonPredictions.Prediction.Answers.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Answers {
            fn default() -> &'a Answers {
                <Answers as ::protobuf::Message>::default_instance()
            }
        }

        impl Answers {
            pub fn new() -> Answers {
                ::std::default::Default::default()
            }

            // optional uint32 answer_id = 1;

            pub fn answer_id(&self) -> u32 {
                self.answer_id.unwrap_or(0)
            }

            pub fn clear_answer_id(&mut self) {
                self.answer_id = ::std::option::Option::None;
            }

            pub fn has_answer_id(&self) -> bool {
                self.answer_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_answer_id(&mut self, v: u32) {
                self.answer_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "answer_id",
                    |m: &Answers| { &m.answer_id },
                    |m: &mut Answers| { &mut m.answer_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Answers>(
                    "CMsgDOTASeasonPredictions.Prediction.Answers",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Answers {
            const NAME: &'static str = "Answers";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.answer_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.answer_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.answer_id {
                    os.write_uint32(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Answers {
                Answers::new()
            }

            fn clear(&mut self) {
                self.answer_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Answers {
                static instance: Answers = Answers {
                    answer_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Answers {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTASeasonPredictions.Prediction.Answers").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Answers {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Answers {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType)
        pub enum EPredictionType {
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType.Generic)
            Generic = 0,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType.Hero)
            Hero = 1,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType.Team)
            Team = 2,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType.Player)
            Player = 3,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType.Special)
            Special = 4,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType.YesNo)
            YesNo = 5,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType.QualifiersTeam)
            QualifiersTeam = 6,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EPredictionType.LastChanceTeam)
            LastChanceTeam = 7,
        }

        impl ::protobuf::Enum for EPredictionType {
            const NAME: &'static str = "EPredictionType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EPredictionType> {
                match value {
                    0 => ::std::option::Option::Some(EPredictionType::Generic),
                    1 => ::std::option::Option::Some(EPredictionType::Hero),
                    2 => ::std::option::Option::Some(EPredictionType::Team),
                    3 => ::std::option::Option::Some(EPredictionType::Player),
                    4 => ::std::option::Option::Some(EPredictionType::Special),
                    5 => ::std::option::Option::Some(EPredictionType::YesNo),
                    6 => ::std::option::Option::Some(EPredictionType::QualifiersTeam),
                    7 => ::std::option::Option::Some(EPredictionType::LastChanceTeam),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EPredictionType> {
                match str {
                    "Generic" => ::std::option::Option::Some(EPredictionType::Generic),
                    "Hero" => ::std::option::Option::Some(EPredictionType::Hero),
                    "Team" => ::std::option::Option::Some(EPredictionType::Team),
                    "Player" => ::std::option::Option::Some(EPredictionType::Player),
                    "Special" => ::std::option::Option::Some(EPredictionType::Special),
                    "YesNo" => ::std::option::Option::Some(EPredictionType::YesNo),
                    "QualifiersTeam" => ::std::option::Option::Some(EPredictionType::QualifiersTeam),
                    "LastChanceTeam" => ::std::option::Option::Some(EPredictionType::LastChanceTeam),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EPredictionType] = &[
                EPredictionType::Generic,
                EPredictionType::Hero,
                EPredictionType::Team,
                EPredictionType::Player,
                EPredictionType::Special,
                EPredictionType::YesNo,
                EPredictionType::QualifiersTeam,
                EPredictionType::LastChanceTeam,
            ];
        }

        impl ::protobuf::EnumFull for EPredictionType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CMsgDOTASeasonPredictions.Prediction.EPredictionType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for EPredictionType {
            fn default() -> Self {
                EPredictionType::Generic
            }
        }

        impl EPredictionType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPredictionType>("CMsgDOTASeasonPredictions.Prediction.EPredictionType")
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType)
        pub enum EAnswerType {
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType.SingleInt)
            SingleInt = 0,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType.SingleFloat)
            SingleFloat = 1,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType.MultipleInt)
            MultipleInt = 2,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType.MultipleFloat)
            MultipleFloat = 3,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType.AnswerTeam)
            AnswerTeam = 4,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType.SingleTime)
            SingleTime = 5,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType.MultipleTime)
            MultipleTime = 6,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTASeasonPredictions.Prediction.EAnswerType.NoAnswer)
            NoAnswer = 7,
        }

        impl ::protobuf::Enum for EAnswerType {
            const NAME: &'static str = "EAnswerType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EAnswerType> {
                match value {
                    0 => ::std::option::Option::Some(EAnswerType::SingleInt),
                    1 => ::std::option::Option::Some(EAnswerType::SingleFloat),
                    2 => ::std::option::Option::Some(EAnswerType::MultipleInt),
                    3 => ::std::option::Option::Some(EAnswerType::MultipleFloat),
                    4 => ::std::option::Option::Some(EAnswerType::AnswerTeam),
                    5 => ::std::option::Option::Some(EAnswerType::SingleTime),
                    6 => ::std::option::Option::Some(EAnswerType::MultipleTime),
                    7 => ::std::option::Option::Some(EAnswerType::NoAnswer),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EAnswerType> {
                match str {
                    "SingleInt" => ::std::option::Option::Some(EAnswerType::SingleInt),
                    "SingleFloat" => ::std::option::Option::Some(EAnswerType::SingleFloat),
                    "MultipleInt" => ::std::option::Option::Some(EAnswerType::MultipleInt),
                    "MultipleFloat" => ::std::option::Option::Some(EAnswerType::MultipleFloat),
                    "AnswerTeam" => ::std::option::Option::Some(EAnswerType::AnswerTeam),
                    "SingleTime" => ::std::option::Option::Some(EAnswerType::SingleTime),
                    "MultipleTime" => ::std::option::Option::Some(EAnswerType::MultipleTime),
                    "NoAnswer" => ::std::option::Option::Some(EAnswerType::NoAnswer),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EAnswerType] = &[
                EAnswerType::SingleInt,
                EAnswerType::SingleFloat,
                EAnswerType::MultipleInt,
                EAnswerType::MultipleFloat,
                EAnswerType::AnswerTeam,
                EAnswerType::SingleTime,
                EAnswerType::MultipleTime,
                EAnswerType::NoAnswer,
            ];
        }

        impl ::protobuf::EnumFull for EAnswerType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CMsgDOTASeasonPredictions.Prediction.EAnswerType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for EAnswerType {
            fn default() -> Self {
                EAnswerType::SingleInt
            }
        }

        impl EAnswerType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EAnswerType>("CMsgDOTASeasonPredictions.Prediction.EAnswerType")
            }
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgAvailablePredictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAvailablePredictions {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAvailablePredictions.match_predictions)
    pub match_predictions: ::std::vec::Vec<cmsg_available_predictions::MatchPrediction>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAvailablePredictions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAvailablePredictions {
    fn default() -> &'a CMsgAvailablePredictions {
        <CMsgAvailablePredictions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAvailablePredictions {
    pub fn new() -> CMsgAvailablePredictions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "match_predictions",
            |m: &CMsgAvailablePredictions| { &m.match_predictions },
            |m: &mut CMsgAvailablePredictions| { &mut m.match_predictions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAvailablePredictions>(
            "CMsgAvailablePredictions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAvailablePredictions {
    const NAME: &'static str = "CMsgAvailablePredictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.match_predictions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.match_predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.match_predictions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAvailablePredictions {
        CMsgAvailablePredictions::new()
    }

    fn clear(&mut self) {
        self.match_predictions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAvailablePredictions {
        static instance: CMsgAvailablePredictions = CMsgAvailablePredictions {
            match_predictions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAvailablePredictions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAvailablePredictions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAvailablePredictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAvailablePredictions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgAvailablePredictions`
pub mod cmsg_available_predictions {
    // @@protoc_insertion_point(message:dota.CMsgAvailablePredictions.MatchPrediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchPrediction {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgAvailablePredictions.MatchPrediction.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgAvailablePredictions.MatchPrediction.predictions)
        pub predictions: ::std::vec::Vec<super::CMsgInGamePrediction>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgAvailablePredictions.MatchPrediction.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchPrediction {
        fn default() -> &'a MatchPrediction {
            <MatchPrediction as ::protobuf::Message>::default_instance()
        }
    }

    impl MatchPrediction {
        pub fn new() -> MatchPrediction {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &MatchPrediction| { &m.match_id },
                |m: &mut MatchPrediction| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "predictions",
                |m: &MatchPrediction| { &m.predictions },
                |m: &mut MatchPrediction| { &mut m.predictions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchPrediction>(
                "CMsgAvailablePredictions.MatchPrediction",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MatchPrediction {
        const NAME: &'static str = "MatchPrediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.predictions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            for value in &self.predictions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            for v in &self.predictions {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchPrediction {
            MatchPrediction::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.predictions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchPrediction {
            static instance: MatchPrediction = MatchPrediction {
                match_id: ::std::option::Option::None,
                predictions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MatchPrediction {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgAvailablePredictions.MatchPrediction").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MatchPrediction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MatchPrediction {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgLeagueWatchedGames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeagueWatchedGames {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLeagueWatchedGames.leagues)
    pub leagues: ::std::vec::Vec<cmsg_league_watched_games::League>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLeagueWatchedGames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeagueWatchedGames {
    fn default() -> &'a CMsgLeagueWatchedGames {
        <CMsgLeagueWatchedGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLeagueWatchedGames {
    pub fn new() -> CMsgLeagueWatchedGames {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "leagues",
            |m: &CMsgLeagueWatchedGames| { &m.leagues },
            |m: &mut CMsgLeagueWatchedGames| { &mut m.leagues },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLeagueWatchedGames>(
            "CMsgLeagueWatchedGames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLeagueWatchedGames {
    const NAME: &'static str = "CMsgLeagueWatchedGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.leagues.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.leagues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.leagues {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeagueWatchedGames {
        CMsgLeagueWatchedGames::new()
    }

    fn clear(&mut self) {
        self.leagues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeagueWatchedGames {
        static instance: CMsgLeagueWatchedGames = CMsgLeagueWatchedGames {
            leagues: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLeagueWatchedGames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLeagueWatchedGames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLeagueWatchedGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeagueWatchedGames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgLeagueWatchedGames`
pub mod cmsg_league_watched_games {
    // @@protoc_insertion_point(message:dota.CMsgLeagueWatchedGames.Series)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Series {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgLeagueWatchedGames.Series.node_id)
        pub node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLeagueWatchedGames.Series.game)
        pub game: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgLeagueWatchedGames.Series.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Series {
        fn default() -> &'a Series {
            <Series as ::protobuf::Message>::default_instance()
        }
    }

    impl Series {
        pub fn new() -> Series {
            ::std::default::Default::default()
        }

        // optional uint32 node_id = 1;

        pub fn node_id(&self) -> u32 {
            self.node_id.unwrap_or(0)
        }

        pub fn clear_node_id(&mut self) {
            self.node_id = ::std::option::Option::None;
        }

        pub fn has_node_id(&self) -> bool {
            self.node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_id(&mut self, v: u32) {
            self.node_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "node_id",
                |m: &Series| { &m.node_id },
                |m: &mut Series| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "game",
                |m: &Series| { &m.game },
                |m: &mut Series| { &mut m.game },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Series>(
                "CMsgLeagueWatchedGames.Series",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Series {
        const NAME: &'static str = "Series";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.game)?;
                    },
                    16 => {
                        self.game.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.node_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.game {
                my_size += ::protobuf::rt::uint32_size(2, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.node_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.game {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Series {
            Series::new()
        }

        fn clear(&mut self) {
            self.node_id = ::std::option::Option::None;
            self.game.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Series {
            static instance: Series = Series {
                node_id: ::std::option::Option::None,
                game: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Series {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLeagueWatchedGames.Series").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Series {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Series {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgLeagueWatchedGames.League)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct League {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgLeagueWatchedGames.League.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgLeagueWatchedGames.League.series)
        pub series: ::std::vec::Vec<Series>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgLeagueWatchedGames.League.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a League {
        fn default() -> &'a League {
            <League as ::protobuf::Message>::default_instance()
        }
    }

    impl League {
        pub fn new() -> League {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &League| { &m.league_id },
                |m: &mut League| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "series",
                |m: &League| { &m.series },
                |m: &mut League| { &mut m.series },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<League>(
                "CMsgLeagueWatchedGames.League",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for League {
        const NAME: &'static str = "League";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.series.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.series {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.series {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> League {
            League::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.series.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static League {
            static instance: League = League {
                league_id: ::std::option::Option::None,
                series: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for League {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLeagueWatchedGames.League").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for League {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for League {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTAMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAMatch {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.starttime)
    pub starttime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.players)
    pub players: ::std::vec::Vec<cmsg_dotamatch::Player>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.tower_status)
    pub tower_status: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.barracks_status)
    pub barracks_status: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.cluster)
    pub cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.first_blood_time)
    pub first_blood_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.replay_salt)
    pub replay_salt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.server_ip)
    pub server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.human_players)
    pub human_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.average_skill)
    pub average_skill: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.game_balance)
    pub game_balance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.radiant_team_id)
    pub radiant_team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.dire_team_id)
    pub dire_team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.radiant_team_name)
    pub radiant_team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.dire_team_name)
    pub dire_team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.radiant_team_logo)
    pub radiant_team_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.dire_team_logo)
    pub dire_team_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.radiant_team_logo_url)
    pub radiant_team_logo_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.dire_team_logo_url)
    pub dire_team_logo_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.radiant_team_complete)
    pub radiant_team_complete: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.dire_team_complete)
    pub dire_team_complete: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.positive_votes)
    pub positive_votes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.negative_votes)
    pub negative_votes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.game_mode)
    pub game_mode: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.picks_bans)
    pub picks_bans: ::std::vec::Vec<CMatchHeroSelectEvent>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.match_seq_num)
    pub match_seq_num: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.replay_state)
    pub replay_state: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_dotamatch::ReplayState>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.radiant_guild_id)
    pub radiant_guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.dire_guild_id)
    pub dire_guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.radiant_team_tag)
    pub radiant_team_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.dire_team_tag)
    pub dire_team_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.series_id)
    pub series_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.broadcaster_channels)
    pub broadcaster_channels: ::std::vec::Vec<cmsg_dotamatch::BroadcasterChannel>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.engine)
    pub engine: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.custom_game_data)
    pub custom_game_data: ::protobuf::MessageField<cmsg_dotamatch::CustomGameData>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.match_flags)
    pub match_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.private_metadata_key)
    pub private_metadata_key: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.radiant_team_score)
    pub radiant_team_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.dire_team_score)
    pub dire_team_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.match_outcome)
    pub match_outcome: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchOutcome>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.tournament_round)
    pub tournament_round: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.pre_game_duration)
    pub pre_game_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.coaches)
    pub coaches: ::std::vec::Vec<cmsg_dotamatch::Coach>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAMatch {
    fn default() -> &'a CMsgDOTAMatch {
        <CMsgDOTAMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAMatch {
    pub fn new() -> CMsgDOTAMatch {
        ::std::default::Default::default()
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional fixed32 starttime = 4;

    pub fn starttime(&self) -> u32 {
        self.starttime.unwrap_or(0)
    }

    pub fn clear_starttime(&mut self) {
        self.starttime = ::std::option::Option::None;
    }

    pub fn has_starttime(&self) -> bool {
        self.starttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_starttime(&mut self, v: u32) {
        self.starttime = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 6;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster = 10;

    pub fn cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood_time = 12;

    pub fn first_blood_time(&self) -> u32 {
        self.first_blood_time.unwrap_or(0)
    }

    pub fn clear_first_blood_time(&mut self) {
        self.first_blood_time = ::std::option::Option::None;
    }

    pub fn has_first_blood_time(&self) -> bool {
        self.first_blood_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_time(&mut self, v: u32) {
        self.first_blood_time = ::std::option::Option::Some(v);
    }

    // optional fixed32 replay_salt = 13;

    pub fn replay_salt(&self) -> u32 {
        self.replay_salt.unwrap_or(0)
    }

    pub fn clear_replay_salt(&mut self) {
        self.replay_salt = ::std::option::Option::None;
    }

    pub fn has_replay_salt(&self) -> bool {
        self.replay_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_salt(&mut self, v: u32) {
        self.replay_salt = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_ip = 14;

    pub fn server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 15;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 16;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional uint32 human_players = 17;

    pub fn human_players(&self) -> u32 {
        self.human_players.unwrap_or(0)
    }

    pub fn clear_human_players(&mut self) {
        self.human_players = ::std::option::Option::None;
    }

    pub fn has_human_players(&self) -> bool {
        self.human_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_human_players(&mut self, v: u32) {
        self.human_players = ::std::option::Option::Some(v);
    }

    // optional uint32 average_skill = 18;

    pub fn average_skill(&self) -> u32 {
        self.average_skill.unwrap_or(0)
    }

    pub fn clear_average_skill(&mut self) {
        self.average_skill = ::std::option::Option::None;
    }

    pub fn has_average_skill(&self) -> bool {
        self.average_skill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_skill(&mut self, v: u32) {
        self.average_skill = ::std::option::Option::Some(v);
    }

    // optional float game_balance = 19;

    pub fn game_balance(&self) -> f32 {
        self.game_balance.unwrap_or(0.)
    }

    pub fn clear_game_balance(&mut self) {
        self.game_balance = ::std::option::Option::None;
    }

    pub fn has_game_balance(&self) -> bool {
        self.game_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_balance(&mut self, v: f32) {
        self.game_balance = ::std::option::Option::Some(v);
    }

    // optional uint32 radiant_team_id = 20;

    pub fn radiant_team_id(&self) -> u32 {
        self.radiant_team_id.unwrap_or(0)
    }

    pub fn clear_radiant_team_id(&mut self) {
        self.radiant_team_id = ::std::option::Option::None;
    }

    pub fn has_radiant_team_id(&self) -> bool {
        self.radiant_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_id(&mut self, v: u32) {
        self.radiant_team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_team_id = 21;

    pub fn dire_team_id(&self) -> u32 {
        self.dire_team_id.unwrap_or(0)
    }

    pub fn clear_dire_team_id(&mut self) {
        self.dire_team_id = ::std::option::Option::None;
    }

    pub fn has_dire_team_id(&self) -> bool {
        self.dire_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_id(&mut self, v: u32) {
        self.dire_team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 leagueid = 22;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    // optional string radiant_team_name = 23;

    pub fn radiant_team_name(&self) -> &str {
        match self.radiant_team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radiant_team_name(&mut self) {
        self.radiant_team_name = ::std::option::Option::None;
    }

    pub fn has_radiant_team_name(&self) -> bool {
        self.radiant_team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_name(&mut self, v: ::std::string::String) {
        self.radiant_team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radiant_team_name(&mut self) -> &mut ::std::string::String {
        if self.radiant_team_name.is_none() {
            self.radiant_team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.radiant_team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_radiant_team_name(&mut self) -> ::std::string::String {
        self.radiant_team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dire_team_name = 24;

    pub fn dire_team_name(&self) -> &str {
        match self.dire_team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dire_team_name(&mut self) {
        self.dire_team_name = ::std::option::Option::None;
    }

    pub fn has_dire_team_name(&self) -> bool {
        self.dire_team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_name(&mut self, v: ::std::string::String) {
        self.dire_team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dire_team_name(&mut self) -> &mut ::std::string::String {
        if self.dire_team_name.is_none() {
            self.dire_team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dire_team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_dire_team_name(&mut self) -> ::std::string::String {
        self.dire_team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 radiant_team_logo = 25;

    pub fn radiant_team_logo(&self) -> u64 {
        self.radiant_team_logo.unwrap_or(0)
    }

    pub fn clear_radiant_team_logo(&mut self) {
        self.radiant_team_logo = ::std::option::Option::None;
    }

    pub fn has_radiant_team_logo(&self) -> bool {
        self.radiant_team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_logo(&mut self, v: u64) {
        self.radiant_team_logo = ::std::option::Option::Some(v);
    }

    // optional uint64 dire_team_logo = 26;

    pub fn dire_team_logo(&self) -> u64 {
        self.dire_team_logo.unwrap_or(0)
    }

    pub fn clear_dire_team_logo(&mut self) {
        self.dire_team_logo = ::std::option::Option::None;
    }

    pub fn has_dire_team_logo(&self) -> bool {
        self.dire_team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_logo(&mut self, v: u64) {
        self.dire_team_logo = ::std::option::Option::Some(v);
    }

    // optional string radiant_team_logo_url = 54;

    pub fn radiant_team_logo_url(&self) -> &str {
        match self.radiant_team_logo_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radiant_team_logo_url(&mut self) {
        self.radiant_team_logo_url = ::std::option::Option::None;
    }

    pub fn has_radiant_team_logo_url(&self) -> bool {
        self.radiant_team_logo_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_logo_url(&mut self, v: ::std::string::String) {
        self.radiant_team_logo_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radiant_team_logo_url(&mut self) -> &mut ::std::string::String {
        if self.radiant_team_logo_url.is_none() {
            self.radiant_team_logo_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.radiant_team_logo_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_radiant_team_logo_url(&mut self) -> ::std::string::String {
        self.radiant_team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dire_team_logo_url = 55;

    pub fn dire_team_logo_url(&self) -> &str {
        match self.dire_team_logo_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dire_team_logo_url(&mut self) {
        self.dire_team_logo_url = ::std::option::Option::None;
    }

    pub fn has_dire_team_logo_url(&self) -> bool {
        self.dire_team_logo_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_logo_url(&mut self, v: ::std::string::String) {
        self.dire_team_logo_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dire_team_logo_url(&mut self) -> &mut ::std::string::String {
        if self.dire_team_logo_url.is_none() {
            self.dire_team_logo_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dire_team_logo_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_dire_team_logo_url(&mut self) -> ::std::string::String {
        self.dire_team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 radiant_team_complete = 27;

    pub fn radiant_team_complete(&self) -> u32 {
        self.radiant_team_complete.unwrap_or(0)
    }

    pub fn clear_radiant_team_complete(&mut self) {
        self.radiant_team_complete = ::std::option::Option::None;
    }

    pub fn has_radiant_team_complete(&self) -> bool {
        self.radiant_team_complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_complete(&mut self, v: u32) {
        self.radiant_team_complete = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_team_complete = 28;

    pub fn dire_team_complete(&self) -> u32 {
        self.dire_team_complete.unwrap_or(0)
    }

    pub fn clear_dire_team_complete(&mut self) {
        self.dire_team_complete = ::std::option::Option::None;
    }

    pub fn has_dire_team_complete(&self) -> bool {
        self.dire_team_complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_complete(&mut self, v: u32) {
        self.dire_team_complete = ::std::option::Option::Some(v);
    }

    // optional uint32 positive_votes = 29;

    pub fn positive_votes(&self) -> u32 {
        self.positive_votes.unwrap_or(0)
    }

    pub fn clear_positive_votes(&mut self) {
        self.positive_votes = ::std::option::Option::None;
    }

    pub fn has_positive_votes(&self) -> bool {
        self.positive_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positive_votes(&mut self, v: u32) {
        self.positive_votes = ::std::option::Option::Some(v);
    }

    // optional uint32 negative_votes = 30;

    pub fn negative_votes(&self) -> u32 {
        self.negative_votes.unwrap_or(0)
    }

    pub fn clear_negative_votes(&mut self) {
        self.negative_votes = ::std::option::Option::None;
    }

    pub fn has_negative_votes(&self) -> bool {
        self.negative_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative_votes(&mut self, v: u32) {
        self.negative_votes = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GameMode game_mode = 31;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_seq_num = 33;

    pub fn match_seq_num(&self) -> u64 {
        self.match_seq_num.unwrap_or(0)
    }

    pub fn clear_match_seq_num(&mut self) {
        self.match_seq_num = ::std::option::Option::None;
    }

    pub fn has_match_seq_num(&self) -> bool {
        self.match_seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_seq_num(&mut self, v: u64) {
        self.match_seq_num = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgDOTAMatch.ReplayState replay_state = 34;

    pub fn replay_state(&self) -> cmsg_dotamatch::ReplayState {
        match self.replay_state {
            Some(e) => e.enum_value_or(cmsg_dotamatch::ReplayState::REPLAY_AVAILABLE),
            None => cmsg_dotamatch::ReplayState::REPLAY_AVAILABLE,
        }
    }

    pub fn clear_replay_state(&mut self) {
        self.replay_state = ::std::option::Option::None;
    }

    pub fn has_replay_state(&self) -> bool {
        self.replay_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_state(&mut self, v: cmsg_dotamatch::ReplayState) {
        self.replay_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 radiant_guild_id = 35;

    pub fn radiant_guild_id(&self) -> u32 {
        self.radiant_guild_id.unwrap_or(0)
    }

    pub fn clear_radiant_guild_id(&mut self) {
        self.radiant_guild_id = ::std::option::Option::None;
    }

    pub fn has_radiant_guild_id(&self) -> bool {
        self.radiant_guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_guild_id(&mut self, v: u32) {
        self.radiant_guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_guild_id = 36;

    pub fn dire_guild_id(&self) -> u32 {
        self.dire_guild_id.unwrap_or(0)
    }

    pub fn clear_dire_guild_id(&mut self) {
        self.dire_guild_id = ::std::option::Option::None;
    }

    pub fn has_dire_guild_id(&self) -> bool {
        self.dire_guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_guild_id(&mut self, v: u32) {
        self.dire_guild_id = ::std::option::Option::Some(v);
    }

    // optional string radiant_team_tag = 37;

    pub fn radiant_team_tag(&self) -> &str {
        match self.radiant_team_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radiant_team_tag(&mut self) {
        self.radiant_team_tag = ::std::option::Option::None;
    }

    pub fn has_radiant_team_tag(&self) -> bool {
        self.radiant_team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_tag(&mut self, v: ::std::string::String) {
        self.radiant_team_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radiant_team_tag(&mut self) -> &mut ::std::string::String {
        if self.radiant_team_tag.is_none() {
            self.radiant_team_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.radiant_team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_radiant_team_tag(&mut self) -> ::std::string::String {
        self.radiant_team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dire_team_tag = 38;

    pub fn dire_team_tag(&self) -> &str {
        match self.dire_team_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dire_team_tag(&mut self) {
        self.dire_team_tag = ::std::option::Option::None;
    }

    pub fn has_dire_team_tag(&self) -> bool {
        self.dire_team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_tag(&mut self, v: ::std::string::String) {
        self.dire_team_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dire_team_tag(&mut self) -> &mut ::std::string::String {
        if self.dire_team_tag.is_none() {
            self.dire_team_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dire_team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_dire_team_tag(&mut self) -> ::std::string::String {
        self.dire_team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 series_id = 39;

    pub fn series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 40;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 engine = 44;

    pub fn engine(&self) -> u32 {
        self.engine.unwrap_or(0)
    }

    pub fn clear_engine(&mut self) {
        self.engine = ::std::option::Option::None;
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: u32) {
        self.engine = ::std::option::Option::Some(v);
    }

    // optional uint32 match_flags = 46;

    pub fn match_flags(&self) -> u32 {
        self.match_flags.unwrap_or(0)
    }

    pub fn clear_match_flags(&mut self) {
        self.match_flags = ::std::option::Option::None;
    }

    pub fn has_match_flags(&self) -> bool {
        self.match_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_flags(&mut self, v: u32) {
        self.match_flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 private_metadata_key = 47;

    pub fn private_metadata_key(&self) -> u32 {
        self.private_metadata_key.unwrap_or(0)
    }

    pub fn clear_private_metadata_key(&mut self) {
        self.private_metadata_key = ::std::option::Option::None;
    }

    pub fn has_private_metadata_key(&self) -> bool {
        self.private_metadata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_metadata_key(&mut self, v: u32) {
        self.private_metadata_key = ::std::option::Option::Some(v);
    }

    // optional uint32 radiant_team_score = 48;

    pub fn radiant_team_score(&self) -> u32 {
        self.radiant_team_score.unwrap_or(0)
    }

    pub fn clear_radiant_team_score(&mut self) {
        self.radiant_team_score = ::std::option::Option::None;
    }

    pub fn has_radiant_team_score(&self) -> bool {
        self.radiant_team_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_score(&mut self, v: u32) {
        self.radiant_team_score = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_team_score = 49;

    pub fn dire_team_score(&self) -> u32 {
        self.dire_team_score.unwrap_or(0)
    }

    pub fn clear_dire_team_score(&mut self) {
        self.dire_team_score = ::std::option::Option::None;
    }

    pub fn has_dire_team_score(&self) -> bool {
        self.dire_team_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_score(&mut self, v: u32) {
        self.dire_team_score = ::std::option::Option::Some(v);
    }

    // optional .dota.EMatchOutcome match_outcome = 50;

    pub fn match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        match self.match_outcome {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown),
            None => super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown,
        }
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 tournament_id = 51;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_round = 52;

    pub fn tournament_round(&self) -> u32 {
        self.tournament_round.unwrap_or(0)
    }

    pub fn clear_tournament_round(&mut self) {
        self.tournament_round = ::std::option::Option::None;
    }

    pub fn has_tournament_round(&self) -> bool {
        self.tournament_round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_round(&mut self, v: u32) {
        self.tournament_round = ::std::option::Option::Some(v);
    }

    // optional uint32 pre_game_duration = 53;

    pub fn pre_game_duration(&self) -> u32 {
        self.pre_game_duration.unwrap_or(0)
    }

    pub fn clear_pre_game_duration(&mut self) {
        self.pre_game_duration = ::std::option::Option::None;
    }

    pub fn has_pre_game_duration(&self) -> bool {
        self.pre_game_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_game_duration(&mut self, v: u32) {
        self.pre_game_duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(50);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgDOTAMatch| { &m.duration },
            |m: &mut CMsgDOTAMatch| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "starttime",
            |m: &CMsgDOTAMatch| { &m.starttime },
            |m: &mut CMsgDOTAMatch| { &mut m.starttime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgDOTAMatch| { &m.players },
            |m: &mut CMsgDOTAMatch| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgDOTAMatch| { &m.match_id },
            |m: &mut CMsgDOTAMatch| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tower_status",
            |m: &CMsgDOTAMatch| { &m.tower_status },
            |m: &mut CMsgDOTAMatch| { &mut m.tower_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "barracks_status",
            |m: &CMsgDOTAMatch| { &m.barracks_status },
            |m: &mut CMsgDOTAMatch| { &mut m.barracks_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cluster",
            |m: &CMsgDOTAMatch| { &m.cluster },
            |m: &mut CMsgDOTAMatch| { &mut m.cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_blood_time",
            |m: &CMsgDOTAMatch| { &m.first_blood_time },
            |m: &mut CMsgDOTAMatch| { &mut m.first_blood_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_salt",
            |m: &CMsgDOTAMatch| { &m.replay_salt },
            |m: &mut CMsgDOTAMatch| { &mut m.replay_salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_ip",
            |m: &CMsgDOTAMatch| { &m.server_ip },
            |m: &mut CMsgDOTAMatch| { &mut m.server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgDOTAMatch| { &m.server_port },
            |m: &mut CMsgDOTAMatch| { &mut m.server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgDOTAMatch| { &m.lobby_type },
            |m: &mut CMsgDOTAMatch| { &mut m.lobby_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "human_players",
            |m: &CMsgDOTAMatch| { &m.human_players },
            |m: &mut CMsgDOTAMatch| { &mut m.human_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_skill",
            |m: &CMsgDOTAMatch| { &m.average_skill },
            |m: &mut CMsgDOTAMatch| { &mut m.average_skill },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_balance",
            |m: &CMsgDOTAMatch| { &m.game_balance },
            |m: &mut CMsgDOTAMatch| { &mut m.game_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_team_id",
            |m: &CMsgDOTAMatch| { &m.radiant_team_id },
            |m: &mut CMsgDOTAMatch| { &mut m.radiant_team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_team_id",
            |m: &CMsgDOTAMatch| { &m.dire_team_id },
            |m: &mut CMsgDOTAMatch| { &mut m.dire_team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leagueid",
            |m: &CMsgDOTAMatch| { &m.leagueid },
            |m: &mut CMsgDOTAMatch| { &mut m.leagueid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_team_name",
            |m: &CMsgDOTAMatch| { &m.radiant_team_name },
            |m: &mut CMsgDOTAMatch| { &mut m.radiant_team_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_team_name",
            |m: &CMsgDOTAMatch| { &m.dire_team_name },
            |m: &mut CMsgDOTAMatch| { &mut m.dire_team_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_team_logo",
            |m: &CMsgDOTAMatch| { &m.radiant_team_logo },
            |m: &mut CMsgDOTAMatch| { &mut m.radiant_team_logo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_team_logo",
            |m: &CMsgDOTAMatch| { &m.dire_team_logo },
            |m: &mut CMsgDOTAMatch| { &mut m.dire_team_logo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_team_logo_url",
            |m: &CMsgDOTAMatch| { &m.radiant_team_logo_url },
            |m: &mut CMsgDOTAMatch| { &mut m.radiant_team_logo_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_team_logo_url",
            |m: &CMsgDOTAMatch| { &m.dire_team_logo_url },
            |m: &mut CMsgDOTAMatch| { &mut m.dire_team_logo_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_team_complete",
            |m: &CMsgDOTAMatch| { &m.radiant_team_complete },
            |m: &mut CMsgDOTAMatch| { &mut m.radiant_team_complete },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_team_complete",
            |m: &CMsgDOTAMatch| { &m.dire_team_complete },
            |m: &mut CMsgDOTAMatch| { &mut m.dire_team_complete },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positive_votes",
            |m: &CMsgDOTAMatch| { &m.positive_votes },
            |m: &mut CMsgDOTAMatch| { &mut m.positive_votes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "negative_votes",
            |m: &CMsgDOTAMatch| { &m.negative_votes },
            |m: &mut CMsgDOTAMatch| { &mut m.negative_votes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgDOTAMatch| { &m.game_mode },
            |m: &mut CMsgDOTAMatch| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "picks_bans",
            |m: &CMsgDOTAMatch| { &m.picks_bans },
            |m: &mut CMsgDOTAMatch| { &mut m.picks_bans },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_seq_num",
            |m: &CMsgDOTAMatch| { &m.match_seq_num },
            |m: &mut CMsgDOTAMatch| { &mut m.match_seq_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_state",
            |m: &CMsgDOTAMatch| { &m.replay_state },
            |m: &mut CMsgDOTAMatch| { &mut m.replay_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_guild_id",
            |m: &CMsgDOTAMatch| { &m.radiant_guild_id },
            |m: &mut CMsgDOTAMatch| { &mut m.radiant_guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_guild_id",
            |m: &CMsgDOTAMatch| { &m.dire_guild_id },
            |m: &mut CMsgDOTAMatch| { &mut m.dire_guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_team_tag",
            |m: &CMsgDOTAMatch| { &m.radiant_team_tag },
            |m: &mut CMsgDOTAMatch| { &mut m.radiant_team_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_team_tag",
            |m: &CMsgDOTAMatch| { &m.dire_team_tag },
            |m: &mut CMsgDOTAMatch| { &mut m.dire_team_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_id",
            |m: &CMsgDOTAMatch| { &m.series_id },
            |m: &mut CMsgDOTAMatch| { &mut m.series_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_type",
            |m: &CMsgDOTAMatch| { &m.series_type },
            |m: &mut CMsgDOTAMatch| { &mut m.series_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcaster_channels",
            |m: &CMsgDOTAMatch| { &m.broadcaster_channels },
            |m: &mut CMsgDOTAMatch| { &mut m.broadcaster_channels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engine",
            |m: &CMsgDOTAMatch| { &m.engine },
            |m: &mut CMsgDOTAMatch| { &mut m.engine },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotamatch::CustomGameData>(
            "custom_game_data",
            |m: &CMsgDOTAMatch| { &m.custom_game_data },
            |m: &mut CMsgDOTAMatch| { &mut m.custom_game_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_flags",
            |m: &CMsgDOTAMatch| { &m.match_flags },
            |m: &mut CMsgDOTAMatch| { &mut m.match_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "private_metadata_key",
            |m: &CMsgDOTAMatch| { &m.private_metadata_key },
            |m: &mut CMsgDOTAMatch| { &mut m.private_metadata_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_team_score",
            |m: &CMsgDOTAMatch| { &m.radiant_team_score },
            |m: &mut CMsgDOTAMatch| { &mut m.radiant_team_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_team_score",
            |m: &CMsgDOTAMatch| { &m.dire_team_score },
            |m: &mut CMsgDOTAMatch| { &mut m.dire_team_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_outcome",
            |m: &CMsgDOTAMatch| { &m.match_outcome },
            |m: &mut CMsgDOTAMatch| { &mut m.match_outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_id",
            |m: &CMsgDOTAMatch| { &m.tournament_id },
            |m: &mut CMsgDOTAMatch| { &mut m.tournament_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_round",
            |m: &CMsgDOTAMatch| { &m.tournament_round },
            |m: &mut CMsgDOTAMatch| { &mut m.tournament_round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pre_game_duration",
            |m: &CMsgDOTAMatch| { &m.pre_game_duration },
            |m: &mut CMsgDOTAMatch| { &mut m.pre_game_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "coaches",
            |m: &CMsgDOTAMatch| { &m.coaches },
            |m: &mut CMsgDOTAMatch| { &mut m.coaches },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAMatch>(
            "CMsgDOTAMatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAMatch {
    const NAME: &'static str = "CMsgDOTAMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.starttime = ::std::option::Option::Some(is.read_fixed32()?);
                },
                42 => {
                    self.players.push(is.read_message()?);
                },
                48 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.tower_status)?;
                },
                64 => {
                    self.tower_status.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.barracks_status)?;
                },
                72 => {
                    self.barracks_status.push(is.read_uint32()?);
                },
                80 => {
                    self.cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.first_blood_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.replay_salt = ::std::option::Option::Some(is.read_fixed32()?);
                },
                117 => {
                    self.server_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                120 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.human_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.average_skill = ::std::option::Option::Some(is.read_uint32()?);
                },
                157 => {
                    self.game_balance = ::std::option::Option::Some(is.read_float()?);
                },
                160 => {
                    self.radiant_team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.dire_team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                186 => {
                    self.radiant_team_name = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    self.dire_team_name = ::std::option::Option::Some(is.read_string()?);
                },
                200 => {
                    self.radiant_team_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                208 => {
                    self.dire_team_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                434 => {
                    self.radiant_team_logo_url = ::std::option::Option::Some(is.read_string()?);
                },
                442 => {
                    self.dire_team_logo_url = ::std::option::Option::Some(is.read_string()?);
                },
                216 => {
                    self.radiant_team_complete = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.dire_team_complete = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.positive_votes = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.negative_votes = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                258 => {
                    self.picks_bans.push(is.read_message()?);
                },
                264 => {
                    self.match_seq_num = ::std::option::Option::Some(is.read_uint64()?);
                },
                272 => {
                    self.replay_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                280 => {
                    self.radiant_guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.dire_guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                298 => {
                    self.radiant_team_tag = ::std::option::Option::Some(is.read_string()?);
                },
                306 => {
                    self.dire_team_tag = ::std::option::Option::Some(is.read_string()?);
                },
                312 => {
                    self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                320 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                346 => {
                    self.broadcaster_channels.push(is.read_message()?);
                },
                352 => {
                    self.engine = ::std::option::Option::Some(is.read_uint32()?);
                },
                362 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_data)?;
                },
                368 => {
                    self.match_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                381 => {
                    self.private_metadata_key = ::std::option::Option::Some(is.read_fixed32()?);
                },
                384 => {
                    self.radiant_team_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                392 => {
                    self.dire_team_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                400 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                408 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                416 => {
                    self.tournament_round = ::std::option::Option::Some(is.read_uint32()?);
                },
                424 => {
                    self.pre_game_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                458 => {
                    self.coaches.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.starttime {
            my_size += 1 + 4;
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        for value in &self.tower_status {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.barracks_status {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        if let Some(v) = self.cluster {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.first_blood_time {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.replay_salt {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.human_players {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.average_skill {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.game_balance {
            my_size += 2 + 4;
        }
        if let Some(v) = self.radiant_team_id {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.dire_team_id {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.radiant_team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.dire_team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        if let Some(v) = self.radiant_team_logo {
            my_size += ::protobuf::rt::uint64_size(25, v);
        }
        if let Some(v) = self.dire_team_logo {
            my_size += ::protobuf::rt::uint64_size(26, v);
        }
        if let Some(v) = self.radiant_team_logo_url.as_ref() {
            my_size += ::protobuf::rt::string_size(54, &v);
        }
        if let Some(v) = self.dire_team_logo_url.as_ref() {
            my_size += ::protobuf::rt::string_size(55, &v);
        }
        if let Some(v) = self.radiant_team_complete {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.dire_team_complete {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.positive_votes {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.negative_votes {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::int32_size(31, v.value());
        }
        for value in &self.picks_bans {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_seq_num {
            my_size += ::protobuf::rt::uint64_size(33, v);
        }
        if let Some(v) = self.replay_state {
            my_size += ::protobuf::rt::int32_size(34, v.value());
        }
        if let Some(v) = self.radiant_guild_id {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.dire_guild_id {
            my_size += ::protobuf::rt::uint32_size(36, v);
        }
        if let Some(v) = self.radiant_team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(37, &v);
        }
        if let Some(v) = self.dire_team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(38, &v);
        }
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::uint32_size(40, v);
        }
        for value in &self.broadcaster_channels {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.engine {
            my_size += ::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.custom_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_flags {
            my_size += ::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.private_metadata_key {
            my_size += 2 + 4;
        }
        if let Some(v) = self.radiant_team_score {
            my_size += ::protobuf::rt::uint32_size(48, v);
        }
        if let Some(v) = self.dire_team_score {
            my_size += ::protobuf::rt::uint32_size(49, v);
        }
        if let Some(v) = self.match_outcome {
            my_size += ::protobuf::rt::int32_size(50, v.value());
        }
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::uint32_size(51, v);
        }
        if let Some(v) = self.tournament_round {
            my_size += ::protobuf::rt::uint32_size(52, v);
        }
        if let Some(v) = self.pre_game_duration {
            my_size += ::protobuf::rt::uint32_size(53, v);
        }
        for value in &self.coaches {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.starttime {
            os.write_fixed32(4, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(6, v)?;
        }
        for v in &self.tower_status {
            os.write_uint32(8, *v)?;
        };
        for v in &self.barracks_status {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.cluster {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.first_blood_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.replay_salt {
            os.write_fixed32(13, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_fixed32(14, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.human_players {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.average_skill {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.game_balance {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.radiant_team_id {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.dire_team_id {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.radiant_team_name.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.dire_team_name.as_ref() {
            os.write_string(24, v)?;
        }
        if let Some(v) = self.radiant_team_logo {
            os.write_uint64(25, v)?;
        }
        if let Some(v) = self.dire_team_logo {
            os.write_uint64(26, v)?;
        }
        if let Some(v) = self.radiant_team_logo_url.as_ref() {
            os.write_string(54, v)?;
        }
        if let Some(v) = self.dire_team_logo_url.as_ref() {
            os.write_string(55, v)?;
        }
        if let Some(v) = self.radiant_team_complete {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.dire_team_complete {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.positive_votes {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.negative_votes {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(31, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.picks_bans {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        };
        if let Some(v) = self.match_seq_num {
            os.write_uint64(33, v)?;
        }
        if let Some(v) = self.replay_state {
            os.write_enum(34, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radiant_guild_id {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.dire_guild_id {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.radiant_team_tag.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.dire_team_tag.as_ref() {
            os.write_string(38, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(40, v)?;
        }
        for v in &self.broadcaster_channels {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        };
        if let Some(v) = self.engine {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.custom_game_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        }
        if let Some(v) = self.match_flags {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.private_metadata_key {
            os.write_fixed32(47, v)?;
        }
        if let Some(v) = self.radiant_team_score {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.dire_team_score {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(50, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.tournament_round {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.pre_game_duration {
            os.write_uint32(53, v)?;
        }
        for v in &self.coaches {
            ::protobuf::rt::write_message_field_with_cached_size(57, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAMatch {
        CMsgDOTAMatch::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.starttime = ::std::option::Option::None;
        self.players.clear();
        self.match_id = ::std::option::Option::None;
        self.tower_status.clear();
        self.barracks_status.clear();
        self.cluster = ::std::option::Option::None;
        self.first_blood_time = ::std::option::Option::None;
        self.replay_salt = ::std::option::Option::None;
        self.server_ip = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.human_players = ::std::option::Option::None;
        self.average_skill = ::std::option::Option::None;
        self.game_balance = ::std::option::Option::None;
        self.radiant_team_id = ::std::option::Option::None;
        self.dire_team_id = ::std::option::Option::None;
        self.leagueid = ::std::option::Option::None;
        self.radiant_team_name = ::std::option::Option::None;
        self.dire_team_name = ::std::option::Option::None;
        self.radiant_team_logo = ::std::option::Option::None;
        self.dire_team_logo = ::std::option::Option::None;
        self.radiant_team_logo_url = ::std::option::Option::None;
        self.dire_team_logo_url = ::std::option::Option::None;
        self.radiant_team_complete = ::std::option::Option::None;
        self.dire_team_complete = ::std::option::Option::None;
        self.positive_votes = ::std::option::Option::None;
        self.negative_votes = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.picks_bans.clear();
        self.match_seq_num = ::std::option::Option::None;
        self.replay_state = ::std::option::Option::None;
        self.radiant_guild_id = ::std::option::Option::None;
        self.dire_guild_id = ::std::option::Option::None;
        self.radiant_team_tag = ::std::option::Option::None;
        self.dire_team_tag = ::std::option::Option::None;
        self.series_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.broadcaster_channels.clear();
        self.engine = ::std::option::Option::None;
        self.custom_game_data.clear();
        self.match_flags = ::std::option::Option::None;
        self.private_metadata_key = ::std::option::Option::None;
        self.radiant_team_score = ::std::option::Option::None;
        self.dire_team_score = ::std::option::Option::None;
        self.match_outcome = ::std::option::Option::None;
        self.tournament_id = ::std::option::Option::None;
        self.tournament_round = ::std::option::Option::None;
        self.pre_game_duration = ::std::option::Option::None;
        self.coaches.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAMatch {
        static instance: CMsgDOTAMatch = CMsgDOTAMatch {
            duration: ::std::option::Option::None,
            starttime: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            match_id: ::std::option::Option::None,
            tower_status: ::std::vec::Vec::new(),
            barracks_status: ::std::vec::Vec::new(),
            cluster: ::std::option::Option::None,
            first_blood_time: ::std::option::Option::None,
            replay_salt: ::std::option::Option::None,
            server_ip: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            human_players: ::std::option::Option::None,
            average_skill: ::std::option::Option::None,
            game_balance: ::std::option::Option::None,
            radiant_team_id: ::std::option::Option::None,
            dire_team_id: ::std::option::Option::None,
            leagueid: ::std::option::Option::None,
            radiant_team_name: ::std::option::Option::None,
            dire_team_name: ::std::option::Option::None,
            radiant_team_logo: ::std::option::Option::None,
            dire_team_logo: ::std::option::Option::None,
            radiant_team_logo_url: ::std::option::Option::None,
            dire_team_logo_url: ::std::option::Option::None,
            radiant_team_complete: ::std::option::Option::None,
            dire_team_complete: ::std::option::Option::None,
            positive_votes: ::std::option::Option::None,
            negative_votes: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            picks_bans: ::std::vec::Vec::new(),
            match_seq_num: ::std::option::Option::None,
            replay_state: ::std::option::Option::None,
            radiant_guild_id: ::std::option::Option::None,
            dire_guild_id: ::std::option::Option::None,
            radiant_team_tag: ::std::option::Option::None,
            dire_team_tag: ::std::option::Option::None,
            series_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            broadcaster_channels: ::std::vec::Vec::new(),
            engine: ::std::option::Option::None,
            custom_game_data: ::protobuf::MessageField::none(),
            match_flags: ::std::option::Option::None,
            private_metadata_key: ::std::option::Option::None,
            radiant_team_score: ::std::option::Option::None,
            dire_team_score: ::std::option::Option::None,
            match_outcome: ::std::option::Option::None,
            tournament_id: ::std::option::Option::None,
            tournament_round: ::std::option::Option::None,
            pre_game_duration: ::std::option::Option::None,
            coaches: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAMatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAMatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTAMatch`
pub mod cmsg_dotamatch {
    // @@protoc_insertion_point(message:dota.CMsgDOTAMatch.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_0)
        pub item_0: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_1)
        pub item_1: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_2)
        pub item_2: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_3)
        pub item_3: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_4)
        pub item_4: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_5)
        pub item_5: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_6)
        pub item_6: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_7)
        pub item_7: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_8)
        pub item_8: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.item_9)
        pub item_9: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.expected_team_contribution)
        pub expected_team_contribution: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.scaled_metric)
        pub scaled_metric: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.previous_rank)
        pub previous_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.rank_change)
        pub rank_change: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.mmr_type)
        pub mmr_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.assists)
        pub assists: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.leaver_status)
        pub leaver_status: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.gold)
        pub gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.last_hits)
        pub last_hits: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.denies)
        pub denies: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.gold_per_min)
        pub gold_per_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.xp_per_min)
        pub xp_per_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.gold_spent)
        pub gold_spent: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.hero_damage)
        pub hero_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.tower_damage)
        pub tower_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.hero_healing)
        pub hero_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.time_last_seen)
        pub time_last_seen: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.support_ability_value)
        pub support_ability_value: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.feeding_detected)
        pub feeding_detected: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.search_rank)
        pub search_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.search_rank_uncertainty)
        pub search_rank_uncertainty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.rank_uncertainty_change)
        pub rank_uncertainty_change: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.hero_play_count)
        pub hero_play_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.party_id)
        pub party_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.scaled_hero_damage)
        pub scaled_hero_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.scaled_tower_damage)
        pub scaled_tower_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.scaled_hero_healing)
        pub scaled_hero_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.scaled_kills)
        pub scaled_kills: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.scaled_deaths)
        pub scaled_deaths: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.scaled_assists)
        pub scaled_assists: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.claimed_farm_gold)
        pub claimed_farm_gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.support_gold)
        pub support_gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.claimed_denies)
        pub claimed_denies: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.claimed_misses)
        pub claimed_misses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.misses)
        pub misses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.ability_upgrades)
        pub ability_upgrades: ::std::vec::Vec<super::CMatchPlayerAbilityUpgrade>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.additional_units_inventory)
        pub additional_units_inventory: ::std::vec::Vec<super::CMatchAdditionalUnitInventory>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.permanent_buffs)
        pub permanent_buffs: ::std::vec::Vec<super::CMatchPlayerPermanentBuff>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.pro_name)
        pub pro_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.real_name)
        pub real_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.custom_game_data)
        pub custom_game_data: ::protobuf::MessageField<player::CustomGameData>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.active_plus_subscription)
        pub active_plus_subscription: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.bot_difficulty)
        pub bot_difficulty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.hero_pick_order)
        pub hero_pick_order: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.hero_was_randomed)
        pub hero_was_randomed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.hero_was_dota_plus_suggestion)
        pub hero_was_dota_plus_suggestion: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.hero_damage_received)
        pub hero_damage_received: ::std::vec::Vec<player::HeroDamageReceived>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.hero_damage_dealt)
        pub hero_damage_dealt: ::std::vec::Vec<player::HeroDamageReceived>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.seconds_dead)
        pub seconds_dead: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.gold_lost_to_death)
        pub gold_lost_to_death: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.lane_selection_flags)
        pub lane_selection_flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.bounty_runes)
        pub bounty_runes: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.outposts_captured)
        pub outposts_captured: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.team_number)
        pub team_number: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::DOTA_GC_TEAM>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.team_slot)
        pub team_slot: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatch.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 player_slot = 2;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 3;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional int32 item_0 = 4;

        pub fn item_0(&self) -> i32 {
            self.item_0.unwrap_or(0)
        }

        pub fn clear_item_0(&mut self) {
            self.item_0 = ::std::option::Option::None;
        }

        pub fn has_item_0(&self) -> bool {
            self.item_0.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_0(&mut self, v: i32) {
            self.item_0 = ::std::option::Option::Some(v);
        }

        // optional int32 item_1 = 5;

        pub fn item_1(&self) -> i32 {
            self.item_1.unwrap_or(0)
        }

        pub fn clear_item_1(&mut self) {
            self.item_1 = ::std::option::Option::None;
        }

        pub fn has_item_1(&self) -> bool {
            self.item_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_1(&mut self, v: i32) {
            self.item_1 = ::std::option::Option::Some(v);
        }

        // optional int32 item_2 = 6;

        pub fn item_2(&self) -> i32 {
            self.item_2.unwrap_or(0)
        }

        pub fn clear_item_2(&mut self) {
            self.item_2 = ::std::option::Option::None;
        }

        pub fn has_item_2(&self) -> bool {
            self.item_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_2(&mut self, v: i32) {
            self.item_2 = ::std::option::Option::Some(v);
        }

        // optional int32 item_3 = 7;

        pub fn item_3(&self) -> i32 {
            self.item_3.unwrap_or(0)
        }

        pub fn clear_item_3(&mut self) {
            self.item_3 = ::std::option::Option::None;
        }

        pub fn has_item_3(&self) -> bool {
            self.item_3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_3(&mut self, v: i32) {
            self.item_3 = ::std::option::Option::Some(v);
        }

        // optional int32 item_4 = 8;

        pub fn item_4(&self) -> i32 {
            self.item_4.unwrap_or(0)
        }

        pub fn clear_item_4(&mut self) {
            self.item_4 = ::std::option::Option::None;
        }

        pub fn has_item_4(&self) -> bool {
            self.item_4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_4(&mut self, v: i32) {
            self.item_4 = ::std::option::Option::Some(v);
        }

        // optional int32 item_5 = 9;

        pub fn item_5(&self) -> i32 {
            self.item_5.unwrap_or(0)
        }

        pub fn clear_item_5(&mut self) {
            self.item_5 = ::std::option::Option::None;
        }

        pub fn has_item_5(&self) -> bool {
            self.item_5.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_5(&mut self, v: i32) {
            self.item_5 = ::std::option::Option::Some(v);
        }

        // optional int32 item_6 = 59;

        pub fn item_6(&self) -> i32 {
            self.item_6.unwrap_or(0)
        }

        pub fn clear_item_6(&mut self) {
            self.item_6 = ::std::option::Option::None;
        }

        pub fn has_item_6(&self) -> bool {
            self.item_6.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_6(&mut self, v: i32) {
            self.item_6 = ::std::option::Option::Some(v);
        }

        // optional int32 item_7 = 60;

        pub fn item_7(&self) -> i32 {
            self.item_7.unwrap_or(0)
        }

        pub fn clear_item_7(&mut self) {
            self.item_7 = ::std::option::Option::None;
        }

        pub fn has_item_7(&self) -> bool {
            self.item_7.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_7(&mut self, v: i32) {
            self.item_7 = ::std::option::Option::Some(v);
        }

        // optional int32 item_8 = 61;

        pub fn item_8(&self) -> i32 {
            self.item_8.unwrap_or(0)
        }

        pub fn clear_item_8(&mut self) {
            self.item_8 = ::std::option::Option::None;
        }

        pub fn has_item_8(&self) -> bool {
            self.item_8.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_8(&mut self, v: i32) {
            self.item_8 = ::std::option::Option::Some(v);
        }

        // optional int32 item_9 = 76;

        pub fn item_9(&self) -> i32 {
            self.item_9.unwrap_or(0)
        }

        pub fn clear_item_9(&mut self) {
            self.item_9 = ::std::option::Option::None;
        }

        pub fn has_item_9(&self) -> bool {
            self.item_9.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_9(&mut self, v: i32) {
            self.item_9 = ::std::option::Option::Some(v);
        }

        // optional float expected_team_contribution = 10;

        pub fn expected_team_contribution(&self) -> f32 {
            self.expected_team_contribution.unwrap_or(0.)
        }

        pub fn clear_expected_team_contribution(&mut self) {
            self.expected_team_contribution = ::std::option::Option::None;
        }

        pub fn has_expected_team_contribution(&self) -> bool {
            self.expected_team_contribution.is_some()
        }

        // Param is passed by value, moved
        pub fn set_expected_team_contribution(&mut self, v: f32) {
            self.expected_team_contribution = ::std::option::Option::Some(v);
        }

        // optional float scaled_metric = 11;

        pub fn scaled_metric(&self) -> f32 {
            self.scaled_metric.unwrap_or(0.)
        }

        pub fn clear_scaled_metric(&mut self) {
            self.scaled_metric = ::std::option::Option::None;
        }

        pub fn has_scaled_metric(&self) -> bool {
            self.scaled_metric.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_metric(&mut self, v: f32) {
            self.scaled_metric = ::std::option::Option::Some(v);
        }

        // optional uint32 previous_rank = 12;

        pub fn previous_rank(&self) -> u32 {
            self.previous_rank.unwrap_or(0)
        }

        pub fn clear_previous_rank(&mut self) {
            self.previous_rank = ::std::option::Option::None;
        }

        pub fn has_previous_rank(&self) -> bool {
            self.previous_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_previous_rank(&mut self, v: u32) {
            self.previous_rank = ::std::option::Option::Some(v);
        }

        // optional sint32 rank_change = 13;

        pub fn rank_change(&self) -> i32 {
            self.rank_change.unwrap_or(0)
        }

        pub fn clear_rank_change(&mut self) {
            self.rank_change = ::std::option::Option::None;
        }

        pub fn has_rank_change(&self) -> bool {
            self.rank_change.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_change(&mut self, v: i32) {
            self.rank_change = ::std::option::Option::Some(v);
        }

        // optional uint32 mmr_type = 74;

        pub fn mmr_type(&self) -> u32 {
            self.mmr_type.unwrap_or(0)
        }

        pub fn clear_mmr_type(&mut self) {
            self.mmr_type = ::std::option::Option::None;
        }

        pub fn has_mmr_type(&self) -> bool {
            self.mmr_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mmr_type(&mut self, v: u32) {
            self.mmr_type = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 14;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 15;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 assists = 16;

        pub fn assists(&self) -> u32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: u32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional uint32 leaver_status = 17;

        pub fn leaver_status(&self) -> u32 {
            self.leaver_status.unwrap_or(0)
        }

        pub fn clear_leaver_status(&mut self) {
            self.leaver_status = ::std::option::Option::None;
        }

        pub fn has_leaver_status(&self) -> bool {
            self.leaver_status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leaver_status(&mut self, v: u32) {
            self.leaver_status = ::std::option::Option::Some(v);
        }

        // optional uint32 gold = 18;

        pub fn gold(&self) -> u32 {
            self.gold.unwrap_or(0)
        }

        pub fn clear_gold(&mut self) {
            self.gold = ::std::option::Option::None;
        }

        pub fn has_gold(&self) -> bool {
            self.gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold(&mut self, v: u32) {
            self.gold = ::std::option::Option::Some(v);
        }

        // optional uint32 last_hits = 19;

        pub fn last_hits(&self) -> u32 {
            self.last_hits.unwrap_or(0)
        }

        pub fn clear_last_hits(&mut self) {
            self.last_hits = ::std::option::Option::None;
        }

        pub fn has_last_hits(&self) -> bool {
            self.last_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hits(&mut self, v: u32) {
            self.last_hits = ::std::option::Option::Some(v);
        }

        // optional uint32 denies = 20;

        pub fn denies(&self) -> u32 {
            self.denies.unwrap_or(0)
        }

        pub fn clear_denies(&mut self) {
            self.denies = ::std::option::Option::None;
        }

        pub fn has_denies(&self) -> bool {
            self.denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies(&mut self, v: u32) {
            self.denies = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_per_min = 21;

        pub fn gold_per_min(&self) -> u32 {
            self.gold_per_min.unwrap_or(0)
        }

        pub fn clear_gold_per_min(&mut self) {
            self.gold_per_min = ::std::option::Option::None;
        }

        pub fn has_gold_per_min(&self) -> bool {
            self.gold_per_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_per_min(&mut self, v: u32) {
            self.gold_per_min = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_per_min = 22;

        pub fn xp_per_min(&self) -> u32 {
            self.xp_per_min.unwrap_or(0)
        }

        pub fn clear_xp_per_min(&mut self) {
            self.xp_per_min = ::std::option::Option::None;
        }

        pub fn has_xp_per_min(&self) -> bool {
            self.xp_per_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_per_min(&mut self, v: u32) {
            self.xp_per_min = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_spent = 23;

        pub fn gold_spent(&self) -> u32 {
            self.gold_spent.unwrap_or(0)
        }

        pub fn clear_gold_spent(&mut self) {
            self.gold_spent = ::std::option::Option::None;
        }

        pub fn has_gold_spent(&self) -> bool {
            self.gold_spent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent(&mut self, v: u32) {
            self.gold_spent = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_damage = 24;

        pub fn hero_damage(&self) -> u32 {
            self.hero_damage.unwrap_or(0)
        }

        pub fn clear_hero_damage(&mut self) {
            self.hero_damage = ::std::option::Option::None;
        }

        pub fn has_hero_damage(&self) -> bool {
            self.hero_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_damage(&mut self, v: u32) {
            self.hero_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 tower_damage = 25;

        pub fn tower_damage(&self) -> u32 {
            self.tower_damage.unwrap_or(0)
        }

        pub fn clear_tower_damage(&mut self) {
            self.tower_damage = ::std::option::Option::None;
        }

        pub fn has_tower_damage(&self) -> bool {
            self.tower_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_damage(&mut self, v: u32) {
            self.tower_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_healing = 26;

        pub fn hero_healing(&self) -> u32 {
            self.hero_healing.unwrap_or(0)
        }

        pub fn clear_hero_healing(&mut self) {
            self.hero_healing = ::std::option::Option::None;
        }

        pub fn has_hero_healing(&self) -> bool {
            self.hero_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_healing(&mut self, v: u32) {
            self.hero_healing = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 27;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_seen = 28;

        pub fn time_last_seen(&self) -> u32 {
            self.time_last_seen.unwrap_or(0)
        }

        pub fn clear_time_last_seen(&mut self) {
            self.time_last_seen = ::std::option::Option::None;
        }

        pub fn has_time_last_seen(&self) -> bool {
            self.time_last_seen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_seen(&mut self, v: u32) {
            self.time_last_seen = ::std::option::Option::Some(v);
        }

        // optional string player_name = 29;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 support_ability_value = 30;

        pub fn support_ability_value(&self) -> u32 {
            self.support_ability_value.unwrap_or(0)
        }

        pub fn clear_support_ability_value(&mut self) {
            self.support_ability_value = ::std::option::Option::None;
        }

        pub fn has_support_ability_value(&self) -> bool {
            self.support_ability_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support_ability_value(&mut self, v: u32) {
            self.support_ability_value = ::std::option::Option::Some(v);
        }

        // optional bool feeding_detected = 32;

        pub fn feeding_detected(&self) -> bool {
            self.feeding_detected.unwrap_or(false)
        }

        pub fn clear_feeding_detected(&mut self) {
            self.feeding_detected = ::std::option::Option::None;
        }

        pub fn has_feeding_detected(&self) -> bool {
            self.feeding_detected.is_some()
        }

        // Param is passed by value, moved
        pub fn set_feeding_detected(&mut self, v: bool) {
            self.feeding_detected = ::std::option::Option::Some(v);
        }

        // optional uint32 search_rank = 34;

        pub fn search_rank(&self) -> u32 {
            self.search_rank.unwrap_or(0)
        }

        pub fn clear_search_rank(&mut self) {
            self.search_rank = ::std::option::Option::None;
        }

        pub fn has_search_rank(&self) -> bool {
            self.search_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_search_rank(&mut self, v: u32) {
            self.search_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 search_rank_uncertainty = 35;

        pub fn search_rank_uncertainty(&self) -> u32 {
            self.search_rank_uncertainty.unwrap_or(0)
        }

        pub fn clear_search_rank_uncertainty(&mut self) {
            self.search_rank_uncertainty = ::std::option::Option::None;
        }

        pub fn has_search_rank_uncertainty(&self) -> bool {
            self.search_rank_uncertainty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_search_rank_uncertainty(&mut self, v: u32) {
            self.search_rank_uncertainty = ::std::option::Option::Some(v);
        }

        // optional int32 rank_uncertainty_change = 36;

        pub fn rank_uncertainty_change(&self) -> i32 {
            self.rank_uncertainty_change.unwrap_or(0)
        }

        pub fn clear_rank_uncertainty_change(&mut self) {
            self.rank_uncertainty_change = ::std::option::Option::None;
        }

        pub fn has_rank_uncertainty_change(&self) -> bool {
            self.rank_uncertainty_change.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_uncertainty_change(&mut self, v: i32) {
            self.rank_uncertainty_change = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_play_count = 37;

        pub fn hero_play_count(&self) -> u32 {
            self.hero_play_count.unwrap_or(0)
        }

        pub fn clear_hero_play_count(&mut self) {
            self.hero_play_count = ::std::option::Option::None;
        }

        pub fn has_hero_play_count(&self) -> bool {
            self.hero_play_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_play_count(&mut self, v: u32) {
            self.hero_play_count = ::std::option::Option::Some(v);
        }

        // optional fixed64 party_id = 38;

        pub fn party_id(&self) -> u64 {
            self.party_id.unwrap_or(0)
        }

        pub fn clear_party_id(&mut self) {
            self.party_id = ::std::option::Option::None;
        }

        pub fn has_party_id(&self) -> bool {
            self.party_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_party_id(&mut self, v: u64) {
            self.party_id = ::std::option::Option::Some(v);
        }

        // optional uint32 scaled_hero_damage = 54;

        pub fn scaled_hero_damage(&self) -> u32 {
            self.scaled_hero_damage.unwrap_or(0)
        }

        pub fn clear_scaled_hero_damage(&mut self) {
            self.scaled_hero_damage = ::std::option::Option::None;
        }

        pub fn has_scaled_hero_damage(&self) -> bool {
            self.scaled_hero_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_hero_damage(&mut self, v: u32) {
            self.scaled_hero_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 scaled_tower_damage = 55;

        pub fn scaled_tower_damage(&self) -> u32 {
            self.scaled_tower_damage.unwrap_or(0)
        }

        pub fn clear_scaled_tower_damage(&mut self) {
            self.scaled_tower_damage = ::std::option::Option::None;
        }

        pub fn has_scaled_tower_damage(&self) -> bool {
            self.scaled_tower_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_tower_damage(&mut self, v: u32) {
            self.scaled_tower_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 scaled_hero_healing = 56;

        pub fn scaled_hero_healing(&self) -> u32 {
            self.scaled_hero_healing.unwrap_or(0)
        }

        pub fn clear_scaled_hero_healing(&mut self) {
            self.scaled_hero_healing = ::std::option::Option::None;
        }

        pub fn has_scaled_hero_healing(&self) -> bool {
            self.scaled_hero_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_hero_healing(&mut self, v: u32) {
            self.scaled_hero_healing = ::std::option::Option::Some(v);
        }

        // optional float scaled_kills = 39;

        pub fn scaled_kills(&self) -> f32 {
            self.scaled_kills.unwrap_or(0.)
        }

        pub fn clear_scaled_kills(&mut self) {
            self.scaled_kills = ::std::option::Option::None;
        }

        pub fn has_scaled_kills(&self) -> bool {
            self.scaled_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_kills(&mut self, v: f32) {
            self.scaled_kills = ::std::option::Option::Some(v);
        }

        // optional float scaled_deaths = 40;

        pub fn scaled_deaths(&self) -> f32 {
            self.scaled_deaths.unwrap_or(0.)
        }

        pub fn clear_scaled_deaths(&mut self) {
            self.scaled_deaths = ::std::option::Option::None;
        }

        pub fn has_scaled_deaths(&self) -> bool {
            self.scaled_deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_deaths(&mut self, v: f32) {
            self.scaled_deaths = ::std::option::Option::Some(v);
        }

        // optional float scaled_assists = 41;

        pub fn scaled_assists(&self) -> f32 {
            self.scaled_assists.unwrap_or(0.)
        }

        pub fn clear_scaled_assists(&mut self) {
            self.scaled_assists = ::std::option::Option::None;
        }

        pub fn has_scaled_assists(&self) -> bool {
            self.scaled_assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_assists(&mut self, v: f32) {
            self.scaled_assists = ::std::option::Option::Some(v);
        }

        // optional uint32 claimed_farm_gold = 42;

        pub fn claimed_farm_gold(&self) -> u32 {
            self.claimed_farm_gold.unwrap_or(0)
        }

        pub fn clear_claimed_farm_gold(&mut self) {
            self.claimed_farm_gold = ::std::option::Option::None;
        }

        pub fn has_claimed_farm_gold(&self) -> bool {
            self.claimed_farm_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_farm_gold(&mut self, v: u32) {
            self.claimed_farm_gold = ::std::option::Option::Some(v);
        }

        // optional uint32 support_gold = 43;

        pub fn support_gold(&self) -> u32 {
            self.support_gold.unwrap_or(0)
        }

        pub fn clear_support_gold(&mut self) {
            self.support_gold = ::std::option::Option::None;
        }

        pub fn has_support_gold(&self) -> bool {
            self.support_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support_gold(&mut self, v: u32) {
            self.support_gold = ::std::option::Option::Some(v);
        }

        // optional uint32 claimed_denies = 44;

        pub fn claimed_denies(&self) -> u32 {
            self.claimed_denies.unwrap_or(0)
        }

        pub fn clear_claimed_denies(&mut self) {
            self.claimed_denies = ::std::option::Option::None;
        }

        pub fn has_claimed_denies(&self) -> bool {
            self.claimed_denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_denies(&mut self, v: u32) {
            self.claimed_denies = ::std::option::Option::Some(v);
        }

        // optional uint32 claimed_misses = 45;

        pub fn claimed_misses(&self) -> u32 {
            self.claimed_misses.unwrap_or(0)
        }

        pub fn clear_claimed_misses(&mut self) {
            self.claimed_misses = ::std::option::Option::None;
        }

        pub fn has_claimed_misses(&self) -> bool {
            self.claimed_misses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_misses(&mut self, v: u32) {
            self.claimed_misses = ::std::option::Option::Some(v);
        }

        // optional uint32 misses = 46;

        pub fn misses(&self) -> u32 {
            self.misses.unwrap_or(0)
        }

        pub fn clear_misses(&mut self) {
            self.misses = ::std::option::Option::None;
        }

        pub fn has_misses(&self) -> bool {
            self.misses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_misses(&mut self, v: u32) {
            self.misses = ::std::option::Option::Some(v);
        }

        // optional string pro_name = 72;

        pub fn pro_name(&self) -> &str {
            match self.pro_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_pro_name(&mut self) {
            self.pro_name = ::std::option::Option::None;
        }

        pub fn has_pro_name(&self) -> bool {
            self.pro_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pro_name(&mut self, v: ::std::string::String) {
            self.pro_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_pro_name(&mut self) -> &mut ::std::string::String {
            if self.pro_name.is_none() {
                self.pro_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.pro_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_pro_name(&mut self) -> ::std::string::String {
            self.pro_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string real_name = 73;

        pub fn real_name(&self) -> &str {
            match self.real_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_real_name(&mut self) {
            self.real_name = ::std::option::Option::None;
        }

        pub fn has_real_name(&self) -> bool {
            self.real_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_real_name(&mut self, v: ::std::string::String) {
            self.real_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_real_name(&mut self) -> &mut ::std::string::String {
            if self.real_name.is_none() {
                self.real_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.real_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_real_name(&mut self) -> ::std::string::String {
            self.real_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool active_plus_subscription = 51;

        pub fn active_plus_subscription(&self) -> bool {
            self.active_plus_subscription.unwrap_or(false)
        }

        pub fn clear_active_plus_subscription(&mut self) {
            self.active_plus_subscription = ::std::option::Option::None;
        }

        pub fn has_active_plus_subscription(&self) -> bool {
            self.active_plus_subscription.is_some()
        }

        // Param is passed by value, moved
        pub fn set_active_plus_subscription(&mut self, v: bool) {
            self.active_plus_subscription = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 52;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional uint32 bot_difficulty = 58;

        pub fn bot_difficulty(&self) -> u32 {
            self.bot_difficulty.unwrap_or(0)
        }

        pub fn clear_bot_difficulty(&mut self) {
            self.bot_difficulty = ::std::option::Option::None;
        }

        pub fn has_bot_difficulty(&self) -> bool {
            self.bot_difficulty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bot_difficulty(&mut self, v: u32) {
            self.bot_difficulty = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_pick_order = 63;

        pub fn hero_pick_order(&self) -> u32 {
            self.hero_pick_order.unwrap_or(0)
        }

        pub fn clear_hero_pick_order(&mut self) {
            self.hero_pick_order = ::std::option::Option::None;
        }

        pub fn has_hero_pick_order(&self) -> bool {
            self.hero_pick_order.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_pick_order(&mut self, v: u32) {
            self.hero_pick_order = ::std::option::Option::Some(v);
        }

        // optional bool hero_was_randomed = 64;

        pub fn hero_was_randomed(&self) -> bool {
            self.hero_was_randomed.unwrap_or(false)
        }

        pub fn clear_hero_was_randomed(&mut self) {
            self.hero_was_randomed = ::std::option::Option::None;
        }

        pub fn has_hero_was_randomed(&self) -> bool {
            self.hero_was_randomed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_was_randomed(&mut self, v: bool) {
            self.hero_was_randomed = ::std::option::Option::Some(v);
        }

        // optional bool hero_was_dota_plus_suggestion = 69;

        pub fn hero_was_dota_plus_suggestion(&self) -> bool {
            self.hero_was_dota_plus_suggestion.unwrap_or(false)
        }

        pub fn clear_hero_was_dota_plus_suggestion(&mut self) {
            self.hero_was_dota_plus_suggestion = ::std::option::Option::None;
        }

        pub fn has_hero_was_dota_plus_suggestion(&self) -> bool {
            self.hero_was_dota_plus_suggestion.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_was_dota_plus_suggestion(&mut self, v: bool) {
            self.hero_was_dota_plus_suggestion = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_dead = 70;

        pub fn seconds_dead(&self) -> u32 {
            self.seconds_dead.unwrap_or(0)
        }

        pub fn clear_seconds_dead(&mut self) {
            self.seconds_dead = ::std::option::Option::None;
        }

        pub fn has_seconds_dead(&self) -> bool {
            self.seconds_dead.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_dead(&mut self, v: u32) {
            self.seconds_dead = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_lost_to_death = 71;

        pub fn gold_lost_to_death(&self) -> u32 {
            self.gold_lost_to_death.unwrap_or(0)
        }

        pub fn clear_gold_lost_to_death(&mut self) {
            self.gold_lost_to_death = ::std::option::Option::None;
        }

        pub fn has_gold_lost_to_death(&self) -> bool {
            self.gold_lost_to_death.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_lost_to_death(&mut self, v: u32) {
            self.gold_lost_to_death = ::std::option::Option::Some(v);
        }

        // optional uint32 lane_selection_flags = 75;

        pub fn lane_selection_flags(&self) -> u32 {
            self.lane_selection_flags.unwrap_or(0)
        }

        pub fn clear_lane_selection_flags(&mut self) {
            self.lane_selection_flags = ::std::option::Option::None;
        }

        pub fn has_lane_selection_flags(&self) -> bool {
            self.lane_selection_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane_selection_flags(&mut self, v: u32) {
            self.lane_selection_flags = ::std::option::Option::Some(v);
        }

        // optional uint32 bounty_runes = 77;

        pub fn bounty_runes(&self) -> u32 {
            self.bounty_runes.unwrap_or(0)
        }

        pub fn clear_bounty_runes(&mut self) {
            self.bounty_runes = ::std::option::Option::None;
        }

        pub fn has_bounty_runes(&self) -> bool {
            self.bounty_runes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bounty_runes(&mut self, v: u32) {
            self.bounty_runes = ::std::option::Option::Some(v);
        }

        // optional uint32 outposts_captured = 78;

        pub fn outposts_captured(&self) -> u32 {
            self.outposts_captured.unwrap_or(0)
        }

        pub fn clear_outposts_captured(&mut self) {
            self.outposts_captured = ::std::option::Option::None;
        }

        pub fn has_outposts_captured(&self) -> bool {
            self.outposts_captured.is_some()
        }

        // Param is passed by value, moved
        pub fn set_outposts_captured(&mut self, v: u32) {
            self.outposts_captured = ::std::option::Option::Some(v);
        }

        // optional .dota.DOTA_GC_TEAM team_number = 80;

        pub fn team_number(&self) -> super::super::dota_shared_enums::DOTA_GC_TEAM {
            match self.team_number {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                None => super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
            }
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: super::super::dota_shared_enums::DOTA_GC_TEAM) {
            self.team_number = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 team_slot = 81;

        pub fn team_slot(&self) -> u32 {
            self.team_slot.unwrap_or(0)
        }

        pub fn clear_team_slot(&mut self) {
            self.team_slot = ::std::option::Option::None;
        }

        pub fn has_team_slot(&self) -> bool {
            self.team_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_slot(&mut self, v: u32) {
            self.team_slot = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(73);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_slot",
                |m: &Player| { &m.player_slot },
                |m: &mut Player| { &mut m.player_slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &Player| { &m.hero_id },
                |m: &mut Player| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_0",
                |m: &Player| { &m.item_0 },
                |m: &mut Player| { &mut m.item_0 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_1",
                |m: &Player| { &m.item_1 },
                |m: &mut Player| { &mut m.item_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_2",
                |m: &Player| { &m.item_2 },
                |m: &mut Player| { &mut m.item_2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_3",
                |m: &Player| { &m.item_3 },
                |m: &mut Player| { &mut m.item_3 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_4",
                |m: &Player| { &m.item_4 },
                |m: &mut Player| { &mut m.item_4 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_5",
                |m: &Player| { &m.item_5 },
                |m: &mut Player| { &mut m.item_5 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_6",
                |m: &Player| { &m.item_6 },
                |m: &mut Player| { &mut m.item_6 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_7",
                |m: &Player| { &m.item_7 },
                |m: &mut Player| { &mut m.item_7 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_8",
                |m: &Player| { &m.item_8 },
                |m: &mut Player| { &mut m.item_8 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_9",
                |m: &Player| { &m.item_9 },
                |m: &mut Player| { &mut m.item_9 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "expected_team_contribution",
                |m: &Player| { &m.expected_team_contribution },
                |m: &mut Player| { &mut m.expected_team_contribution },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scaled_metric",
                |m: &Player| { &m.scaled_metric },
                |m: &mut Player| { &mut m.scaled_metric },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "previous_rank",
                |m: &Player| { &m.previous_rank },
                |m: &mut Player| { &mut m.previous_rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_change",
                |m: &Player| { &m.rank_change },
                |m: &mut Player| { &mut m.rank_change },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mmr_type",
                |m: &Player| { &m.mmr_type },
                |m: &mut Player| { &mut m.mmr_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills",
                |m: &Player| { &m.kills },
                |m: &mut Player| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deaths",
                |m: &Player| { &m.deaths },
                |m: &mut Player| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "assists",
                |m: &Player| { &m.assists },
                |m: &mut Player| { &mut m.assists },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "leaver_status",
                |m: &Player| { &m.leaver_status },
                |m: &mut Player| { &mut m.leaver_status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold",
                |m: &Player| { &m.gold },
                |m: &mut Player| { &mut m.gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_hits",
                |m: &Player| { &m.last_hits },
                |m: &mut Player| { &mut m.last_hits },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "denies",
                |m: &Player| { &m.denies },
                |m: &mut Player| { &mut m.denies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_per_min",
                |m: &Player| { &m.gold_per_min },
                |m: &mut Player| { &mut m.gold_per_min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xp_per_min",
                |m: &Player| { &m.xp_per_min },
                |m: &mut Player| { &mut m.xp_per_min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_spent",
                |m: &Player| { &m.gold_spent },
                |m: &mut Player| { &mut m.gold_spent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_damage",
                |m: &Player| { &m.hero_damage },
                |m: &mut Player| { &mut m.hero_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tower_damage",
                |m: &Player| { &m.tower_damage },
                |m: &mut Player| { &mut m.tower_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_healing",
                |m: &Player| { &m.hero_healing },
                |m: &mut Player| { &mut m.hero_healing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &Player| { &m.level },
                |m: &mut Player| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_last_seen",
                |m: &Player| { &m.time_last_seen },
                |m: &mut Player| { &mut m.time_last_seen },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_name",
                |m: &Player| { &m.player_name },
                |m: &mut Player| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "support_ability_value",
                |m: &Player| { &m.support_ability_value },
                |m: &mut Player| { &mut m.support_ability_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "feeding_detected",
                |m: &Player| { &m.feeding_detected },
                |m: &mut Player| { &mut m.feeding_detected },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "search_rank",
                |m: &Player| { &m.search_rank },
                |m: &mut Player| { &mut m.search_rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "search_rank_uncertainty",
                |m: &Player| { &m.search_rank_uncertainty },
                |m: &mut Player| { &mut m.search_rank_uncertainty },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_uncertainty_change",
                |m: &Player| { &m.rank_uncertainty_change },
                |m: &mut Player| { &mut m.rank_uncertainty_change },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_play_count",
                |m: &Player| { &m.hero_play_count },
                |m: &mut Player| { &mut m.hero_play_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "party_id",
                |m: &Player| { &m.party_id },
                |m: &mut Player| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scaled_hero_damage",
                |m: &Player| { &m.scaled_hero_damage },
                |m: &mut Player| { &mut m.scaled_hero_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scaled_tower_damage",
                |m: &Player| { &m.scaled_tower_damage },
                |m: &mut Player| { &mut m.scaled_tower_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scaled_hero_healing",
                |m: &Player| { &m.scaled_hero_healing },
                |m: &mut Player| { &mut m.scaled_hero_healing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scaled_kills",
                |m: &Player| { &m.scaled_kills },
                |m: &mut Player| { &mut m.scaled_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scaled_deaths",
                |m: &Player| { &m.scaled_deaths },
                |m: &mut Player| { &mut m.scaled_deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scaled_assists",
                |m: &Player| { &m.scaled_assists },
                |m: &mut Player| { &mut m.scaled_assists },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "claimed_farm_gold",
                |m: &Player| { &m.claimed_farm_gold },
                |m: &mut Player| { &mut m.claimed_farm_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "support_gold",
                |m: &Player| { &m.support_gold },
                |m: &mut Player| { &mut m.support_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "claimed_denies",
                |m: &Player| { &m.claimed_denies },
                |m: &mut Player| { &mut m.claimed_denies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "claimed_misses",
                |m: &Player| { &m.claimed_misses },
                |m: &mut Player| { &mut m.claimed_misses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "misses",
                |m: &Player| { &m.misses },
                |m: &mut Player| { &mut m.misses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "ability_upgrades",
                |m: &Player| { &m.ability_upgrades },
                |m: &mut Player| { &mut m.ability_upgrades },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "additional_units_inventory",
                |m: &Player| { &m.additional_units_inventory },
                |m: &mut Player| { &mut m.additional_units_inventory },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "permanent_buffs",
                |m: &Player| { &m.permanent_buffs },
                |m: &mut Player| { &mut m.permanent_buffs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pro_name",
                |m: &Player| { &m.pro_name },
                |m: &mut Player| { &mut m.pro_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "real_name",
                |m: &Player| { &m.real_name },
                |m: &mut Player| { &mut m.real_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, player::CustomGameData>(
                "custom_game_data",
                |m: &Player| { &m.custom_game_data },
                |m: &mut Player| { &mut m.custom_game_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "active_plus_subscription",
                |m: &Player| { &m.active_plus_subscription },
                |m: &mut Player| { &mut m.active_plus_subscription },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "net_worth",
                |m: &Player| { &m.net_worth },
                |m: &mut Player| { &mut m.net_worth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bot_difficulty",
                |m: &Player| { &m.bot_difficulty },
                |m: &mut Player| { &mut m.bot_difficulty },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_pick_order",
                |m: &Player| { &m.hero_pick_order },
                |m: &mut Player| { &mut m.hero_pick_order },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_was_randomed",
                |m: &Player| { &m.hero_was_randomed },
                |m: &mut Player| { &mut m.hero_was_randomed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_was_dota_plus_suggestion",
                |m: &Player| { &m.hero_was_dota_plus_suggestion },
                |m: &mut Player| { &mut m.hero_was_dota_plus_suggestion },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hero_damage_received",
                |m: &Player| { &m.hero_damage_received },
                |m: &mut Player| { &mut m.hero_damage_received },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hero_damage_dealt",
                |m: &Player| { &m.hero_damage_dealt },
                |m: &mut Player| { &mut m.hero_damage_dealt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "seconds_dead",
                |m: &Player| { &m.seconds_dead },
                |m: &mut Player| { &mut m.seconds_dead },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_lost_to_death",
                |m: &Player| { &m.gold_lost_to_death },
                |m: &mut Player| { &mut m.gold_lost_to_death },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lane_selection_flags",
                |m: &Player| { &m.lane_selection_flags },
                |m: &mut Player| { &mut m.lane_selection_flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bounty_runes",
                |m: &Player| { &m.bounty_runes },
                |m: &mut Player| { &mut m.bounty_runes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "outposts_captured",
                |m: &Player| { &m.outposts_captured },
                |m: &mut Player| { &mut m.outposts_captured },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_number",
                |m: &Player| { &m.team_number },
                |m: &mut Player| { &mut m.team_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_slot",
                |m: &Player| { &m.team_slot },
                |m: &mut Player| { &mut m.team_slot },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgDOTAMatch.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.item_0 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.item_1 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.item_2 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.item_3 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.item_4 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.item_5 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    472 => {
                        self.item_6 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    480 => {
                        self.item_7 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    488 => {
                        self.item_8 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    608 => {
                        self.item_9 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    85 => {
                        self.expected_team_contribution = ::std::option::Option::Some(is.read_float()?);
                    },
                    93 => {
                        self.scaled_metric = ::std::option::Option::Some(is.read_float()?);
                    },
                    96 => {
                        self.previous_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.rank_change = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    592 => {
                        self.mmr_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.leaver_status = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.denies = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.gold_per_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    176 => {
                        self.xp_per_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    184 => {
                        self.gold_spent = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    192 => {
                        self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    200 => {
                        self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    208 => {
                        self.hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    216 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    224 => {
                        self.time_last_seen = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    234 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    240 => {
                        self.support_ability_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    256 => {
                        self.feeding_detected = ::std::option::Option::Some(is.read_bool()?);
                    },
                    272 => {
                        self.search_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    280 => {
                        self.search_rank_uncertainty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    288 => {
                        self.rank_uncertainty_change = ::std::option::Option::Some(is.read_int32()?);
                    },
                    296 => {
                        self.hero_play_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    305 => {
                        self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    432 => {
                        self.scaled_hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    440 => {
                        self.scaled_tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    448 => {
                        self.scaled_hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    317 => {
                        self.scaled_kills = ::std::option::Option::Some(is.read_float()?);
                    },
                    325 => {
                        self.scaled_deaths = ::std::option::Option::Some(is.read_float()?);
                    },
                    333 => {
                        self.scaled_assists = ::std::option::Option::Some(is.read_float()?);
                    },
                    336 => {
                        self.claimed_farm_gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    344 => {
                        self.support_gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    352 => {
                        self.claimed_denies = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    360 => {
                        self.claimed_misses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    368 => {
                        self.misses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    378 => {
                        self.ability_upgrades.push(is.read_message()?);
                    },
                    386 => {
                        self.additional_units_inventory.push(is.read_message()?);
                    },
                    458 => {
                        self.permanent_buffs.push(is.read_message()?);
                    },
                    578 => {
                        self.pro_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    586 => {
                        self.real_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    402 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_data)?;
                    },
                    408 => {
                        self.active_plus_subscription = ::std::option::Option::Some(is.read_bool()?);
                    },
                    416 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    464 => {
                        self.bot_difficulty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    504 => {
                        self.hero_pick_order = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    512 => {
                        self.hero_was_randomed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    552 => {
                        self.hero_was_dota_plus_suggestion = ::std::option::Option::Some(is.read_bool()?);
                    },
                    538 => {
                        self.hero_damage_received.push(is.read_message()?);
                    },
                    634 => {
                        self.hero_damage_dealt.push(is.read_message()?);
                    },
                    560 => {
                        self.seconds_dead = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    568 => {
                        self.gold_lost_to_death = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    600 => {
                        self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    616 => {
                        self.bounty_runes = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    624 => {
                        self.outposts_captured = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    640 => {
                        self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    648 => {
                        self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.player_slot {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.item_0 {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.item_1 {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.item_2 {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.item_3 {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.item_4 {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.item_5 {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.item_6 {
                my_size += ::protobuf::rt::int32_size(59, v);
            }
            if let Some(v) = self.item_7 {
                my_size += ::protobuf::rt::int32_size(60, v);
            }
            if let Some(v) = self.item_8 {
                my_size += ::protobuf::rt::int32_size(61, v);
            }
            if let Some(v) = self.item_9 {
                my_size += ::protobuf::rt::int32_size(76, v);
            }
            if let Some(v) = self.expected_team_contribution {
                my_size += 1 + 4;
            }
            if let Some(v) = self.scaled_metric {
                my_size += 1 + 4;
            }
            if let Some(v) = self.previous_rank {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.rank_change {
                my_size += ::protobuf::rt::sint32_size(13, v);
            }
            if let Some(v) = self.mmr_type {
                my_size += ::protobuf::rt::uint32_size(74, v);
            }
            if let Some(v) = self.kills {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.assists {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.leaver_status {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.gold {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.last_hits {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.denies {
                my_size += ::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.gold_per_min {
                my_size += ::protobuf::rt::uint32_size(21, v);
            }
            if let Some(v) = self.xp_per_min {
                my_size += ::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.gold_spent {
                my_size += ::protobuf::rt::uint32_size(23, v);
            }
            if let Some(v) = self.hero_damage {
                my_size += ::protobuf::rt::uint32_size(24, v);
            }
            if let Some(v) = self.tower_damage {
                my_size += ::protobuf::rt::uint32_size(25, v);
            }
            if let Some(v) = self.hero_healing {
                my_size += ::protobuf::rt::uint32_size(26, v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(27, v);
            }
            if let Some(v) = self.time_last_seen {
                my_size += ::protobuf::rt::uint32_size(28, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::protobuf::rt::string_size(29, &v);
            }
            if let Some(v) = self.support_ability_value {
                my_size += ::protobuf::rt::uint32_size(30, v);
            }
            if let Some(v) = self.feeding_detected {
                my_size += 2 + 1;
            }
            if let Some(v) = self.search_rank {
                my_size += ::protobuf::rt::uint32_size(34, v);
            }
            if let Some(v) = self.search_rank_uncertainty {
                my_size += ::protobuf::rt::uint32_size(35, v);
            }
            if let Some(v) = self.rank_uncertainty_change {
                my_size += ::protobuf::rt::int32_size(36, v);
            }
            if let Some(v) = self.hero_play_count {
                my_size += ::protobuf::rt::uint32_size(37, v);
            }
            if let Some(v) = self.party_id {
                my_size += 2 + 8;
            }
            if let Some(v) = self.scaled_hero_damage {
                my_size += ::protobuf::rt::uint32_size(54, v);
            }
            if let Some(v) = self.scaled_tower_damage {
                my_size += ::protobuf::rt::uint32_size(55, v);
            }
            if let Some(v) = self.scaled_hero_healing {
                my_size += ::protobuf::rt::uint32_size(56, v);
            }
            if let Some(v) = self.scaled_kills {
                my_size += 2 + 4;
            }
            if let Some(v) = self.scaled_deaths {
                my_size += 2 + 4;
            }
            if let Some(v) = self.scaled_assists {
                my_size += 2 + 4;
            }
            if let Some(v) = self.claimed_farm_gold {
                my_size += ::protobuf::rt::uint32_size(42, v);
            }
            if let Some(v) = self.support_gold {
                my_size += ::protobuf::rt::uint32_size(43, v);
            }
            if let Some(v) = self.claimed_denies {
                my_size += ::protobuf::rt::uint32_size(44, v);
            }
            if let Some(v) = self.claimed_misses {
                my_size += ::protobuf::rt::uint32_size(45, v);
            }
            if let Some(v) = self.misses {
                my_size += ::protobuf::rt::uint32_size(46, v);
            }
            for value in &self.ability_upgrades {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.additional_units_inventory {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.permanent_buffs {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.pro_name.as_ref() {
                my_size += ::protobuf::rt::string_size(72, &v);
            }
            if let Some(v) = self.real_name.as_ref() {
                my_size += ::protobuf::rt::string_size(73, &v);
            }
            if let Some(v) = self.custom_game_data.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.active_plus_subscription {
                my_size += 2 + 1;
            }
            if let Some(v) = self.net_worth {
                my_size += ::protobuf::rt::uint32_size(52, v);
            }
            if let Some(v) = self.bot_difficulty {
                my_size += ::protobuf::rt::uint32_size(58, v);
            }
            if let Some(v) = self.hero_pick_order {
                my_size += ::protobuf::rt::uint32_size(63, v);
            }
            if let Some(v) = self.hero_was_randomed {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hero_was_dota_plus_suggestion {
                my_size += 2 + 1;
            }
            for value in &self.hero_damage_received {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.hero_damage_dealt {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.seconds_dead {
                my_size += ::protobuf::rt::uint32_size(70, v);
            }
            if let Some(v) = self.gold_lost_to_death {
                my_size += ::protobuf::rt::uint32_size(71, v);
            }
            if let Some(v) = self.lane_selection_flags {
                my_size += ::protobuf::rt::uint32_size(75, v);
            }
            if let Some(v) = self.bounty_runes {
                my_size += ::protobuf::rt::uint32_size(77, v);
            }
            if let Some(v) = self.outposts_captured {
                my_size += ::protobuf::rt::uint32_size(78, v);
            }
            if let Some(v) = self.team_number {
                my_size += ::protobuf::rt::int32_size(80, v.value());
            }
            if let Some(v) = self.team_slot {
                my_size += ::protobuf::rt::uint32_size(81, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.player_slot {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.item_0 {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.item_1 {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.item_2 {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.item_3 {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.item_4 {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.item_5 {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.item_6 {
                os.write_int32(59, v)?;
            }
            if let Some(v) = self.item_7 {
                os.write_int32(60, v)?;
            }
            if let Some(v) = self.item_8 {
                os.write_int32(61, v)?;
            }
            if let Some(v) = self.item_9 {
                os.write_int32(76, v)?;
            }
            if let Some(v) = self.expected_team_contribution {
                os.write_float(10, v)?;
            }
            if let Some(v) = self.scaled_metric {
                os.write_float(11, v)?;
            }
            if let Some(v) = self.previous_rank {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.rank_change {
                os.write_sint32(13, v)?;
            }
            if let Some(v) = self.mmr_type {
                os.write_uint32(74, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.assists {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.leaver_status {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.gold {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.last_hits {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.denies {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.gold_per_min {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.xp_per_min {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.gold_spent {
                os.write_uint32(23, v)?;
            }
            if let Some(v) = self.hero_damage {
                os.write_uint32(24, v)?;
            }
            if let Some(v) = self.tower_damage {
                os.write_uint32(25, v)?;
            }
            if let Some(v) = self.hero_healing {
                os.write_uint32(26, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.time_last_seen {
                os.write_uint32(28, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(29, v)?;
            }
            if let Some(v) = self.support_ability_value {
                os.write_uint32(30, v)?;
            }
            if let Some(v) = self.feeding_detected {
                os.write_bool(32, v)?;
            }
            if let Some(v) = self.search_rank {
                os.write_uint32(34, v)?;
            }
            if let Some(v) = self.search_rank_uncertainty {
                os.write_uint32(35, v)?;
            }
            if let Some(v) = self.rank_uncertainty_change {
                os.write_int32(36, v)?;
            }
            if let Some(v) = self.hero_play_count {
                os.write_uint32(37, v)?;
            }
            if let Some(v) = self.party_id {
                os.write_fixed64(38, v)?;
            }
            if let Some(v) = self.scaled_hero_damage {
                os.write_uint32(54, v)?;
            }
            if let Some(v) = self.scaled_tower_damage {
                os.write_uint32(55, v)?;
            }
            if let Some(v) = self.scaled_hero_healing {
                os.write_uint32(56, v)?;
            }
            if let Some(v) = self.scaled_kills {
                os.write_float(39, v)?;
            }
            if let Some(v) = self.scaled_deaths {
                os.write_float(40, v)?;
            }
            if let Some(v) = self.scaled_assists {
                os.write_float(41, v)?;
            }
            if let Some(v) = self.claimed_farm_gold {
                os.write_uint32(42, v)?;
            }
            if let Some(v) = self.support_gold {
                os.write_uint32(43, v)?;
            }
            if let Some(v) = self.claimed_denies {
                os.write_uint32(44, v)?;
            }
            if let Some(v) = self.claimed_misses {
                os.write_uint32(45, v)?;
            }
            if let Some(v) = self.misses {
                os.write_uint32(46, v)?;
            }
            for v in &self.ability_upgrades {
                ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
            };
            for v in &self.additional_units_inventory {
                ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
            };
            for v in &self.permanent_buffs {
                ::protobuf::rt::write_message_field_with_cached_size(57, v, os)?;
            };
            if let Some(v) = self.pro_name.as_ref() {
                os.write_string(72, v)?;
            }
            if let Some(v) = self.real_name.as_ref() {
                os.write_string(73, v)?;
            }
            if let Some(v) = self.custom_game_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
            }
            if let Some(v) = self.active_plus_subscription {
                os.write_bool(51, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(52, v)?;
            }
            if let Some(v) = self.bot_difficulty {
                os.write_uint32(58, v)?;
            }
            if let Some(v) = self.hero_pick_order {
                os.write_uint32(63, v)?;
            }
            if let Some(v) = self.hero_was_randomed {
                os.write_bool(64, v)?;
            }
            if let Some(v) = self.hero_was_dota_plus_suggestion {
                os.write_bool(69, v)?;
            }
            for v in &self.hero_damage_received {
                ::protobuf::rt::write_message_field_with_cached_size(67, v, os)?;
            };
            for v in &self.hero_damage_dealt {
                ::protobuf::rt::write_message_field_with_cached_size(79, v, os)?;
            };
            if let Some(v) = self.seconds_dead {
                os.write_uint32(70, v)?;
            }
            if let Some(v) = self.gold_lost_to_death {
                os.write_uint32(71, v)?;
            }
            if let Some(v) = self.lane_selection_flags {
                os.write_uint32(75, v)?;
            }
            if let Some(v) = self.bounty_runes {
                os.write_uint32(77, v)?;
            }
            if let Some(v) = self.outposts_captured {
                os.write_uint32(78, v)?;
            }
            if let Some(v) = self.team_number {
                os.write_enum(80, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.team_slot {
                os.write_uint32(81, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.player_slot = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.item_0 = ::std::option::Option::None;
            self.item_1 = ::std::option::Option::None;
            self.item_2 = ::std::option::Option::None;
            self.item_3 = ::std::option::Option::None;
            self.item_4 = ::std::option::Option::None;
            self.item_5 = ::std::option::Option::None;
            self.item_6 = ::std::option::Option::None;
            self.item_7 = ::std::option::Option::None;
            self.item_8 = ::std::option::Option::None;
            self.item_9 = ::std::option::Option::None;
            self.expected_team_contribution = ::std::option::Option::None;
            self.scaled_metric = ::std::option::Option::None;
            self.previous_rank = ::std::option::Option::None;
            self.rank_change = ::std::option::Option::None;
            self.mmr_type = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.leaver_status = ::std::option::Option::None;
            self.gold = ::std::option::Option::None;
            self.last_hits = ::std::option::Option::None;
            self.denies = ::std::option::Option::None;
            self.gold_per_min = ::std::option::Option::None;
            self.xp_per_min = ::std::option::Option::None;
            self.gold_spent = ::std::option::Option::None;
            self.hero_damage = ::std::option::Option::None;
            self.tower_damage = ::std::option::Option::None;
            self.hero_healing = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.time_last_seen = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.support_ability_value = ::std::option::Option::None;
            self.feeding_detected = ::std::option::Option::None;
            self.search_rank = ::std::option::Option::None;
            self.search_rank_uncertainty = ::std::option::Option::None;
            self.rank_uncertainty_change = ::std::option::Option::None;
            self.hero_play_count = ::std::option::Option::None;
            self.party_id = ::std::option::Option::None;
            self.scaled_hero_damage = ::std::option::Option::None;
            self.scaled_tower_damage = ::std::option::Option::None;
            self.scaled_hero_healing = ::std::option::Option::None;
            self.scaled_kills = ::std::option::Option::None;
            self.scaled_deaths = ::std::option::Option::None;
            self.scaled_assists = ::std::option::Option::None;
            self.claimed_farm_gold = ::std::option::Option::None;
            self.support_gold = ::std::option::Option::None;
            self.claimed_denies = ::std::option::Option::None;
            self.claimed_misses = ::std::option::Option::None;
            self.misses = ::std::option::Option::None;
            self.ability_upgrades.clear();
            self.additional_units_inventory.clear();
            self.permanent_buffs.clear();
            self.pro_name = ::std::option::Option::None;
            self.real_name = ::std::option::Option::None;
            self.custom_game_data.clear();
            self.active_plus_subscription = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.bot_difficulty = ::std::option::Option::None;
            self.hero_pick_order = ::std::option::Option::None;
            self.hero_was_randomed = ::std::option::Option::None;
            self.hero_was_dota_plus_suggestion = ::std::option::Option::None;
            self.hero_damage_received.clear();
            self.hero_damage_dealt.clear();
            self.seconds_dead = ::std::option::Option::None;
            self.gold_lost_to_death = ::std::option::Option::None;
            self.lane_selection_flags = ::std::option::Option::None;
            self.bounty_runes = ::std::option::Option::None;
            self.outposts_captured = ::std::option::Option::None;
            self.team_number = ::std::option::Option::None;
            self.team_slot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                player_slot: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                item_0: ::std::option::Option::None,
                item_1: ::std::option::Option::None,
                item_2: ::std::option::Option::None,
                item_3: ::std::option::Option::None,
                item_4: ::std::option::Option::None,
                item_5: ::std::option::Option::None,
                item_6: ::std::option::Option::None,
                item_7: ::std::option::Option::None,
                item_8: ::std::option::Option::None,
                item_9: ::std::option::Option::None,
                expected_team_contribution: ::std::option::Option::None,
                scaled_metric: ::std::option::Option::None,
                previous_rank: ::std::option::Option::None,
                rank_change: ::std::option::Option::None,
                mmr_type: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                leaver_status: ::std::option::Option::None,
                gold: ::std::option::Option::None,
                last_hits: ::std::option::Option::None,
                denies: ::std::option::Option::None,
                gold_per_min: ::std::option::Option::None,
                xp_per_min: ::std::option::Option::None,
                gold_spent: ::std::option::Option::None,
                hero_damage: ::std::option::Option::None,
                tower_damage: ::std::option::Option::None,
                hero_healing: ::std::option::Option::None,
                level: ::std::option::Option::None,
                time_last_seen: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                support_ability_value: ::std::option::Option::None,
                feeding_detected: ::std::option::Option::None,
                search_rank: ::std::option::Option::None,
                search_rank_uncertainty: ::std::option::Option::None,
                rank_uncertainty_change: ::std::option::Option::None,
                hero_play_count: ::std::option::Option::None,
                party_id: ::std::option::Option::None,
                scaled_hero_damage: ::std::option::Option::None,
                scaled_tower_damage: ::std::option::Option::None,
                scaled_hero_healing: ::std::option::Option::None,
                scaled_kills: ::std::option::Option::None,
                scaled_deaths: ::std::option::Option::None,
                scaled_assists: ::std::option::Option::None,
                claimed_farm_gold: ::std::option::Option::None,
                support_gold: ::std::option::Option::None,
                claimed_denies: ::std::option::Option::None,
                claimed_misses: ::std::option::Option::None,
                misses: ::std::option::Option::None,
                ability_upgrades: ::std::vec::Vec::new(),
                additional_units_inventory: ::std::vec::Vec::new(),
                permanent_buffs: ::std::vec::Vec::new(),
                pro_name: ::std::option::Option::None,
                real_name: ::std::option::Option::None,
                custom_game_data: ::protobuf::MessageField::none(),
                active_plus_subscription: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                bot_difficulty: ::std::option::Option::None,
                hero_pick_order: ::std::option::Option::None,
                hero_was_randomed: ::std::option::Option::None,
                hero_was_dota_plus_suggestion: ::std::option::Option::None,
                hero_damage_received: ::std::vec::Vec::new(),
                hero_damage_dealt: ::std::vec::Vec::new(),
                seconds_dead: ::std::option::Option::None,
                gold_lost_to_death: ::std::option::Option::None,
                lane_selection_flags: ::std::option::Option::None,
                bounty_runes: ::std::option::Option::None,
                outposts_captured: ::std::option::Option::None,
                team_number: ::std::option::Option::None,
                team_slot: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAMatch.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Player`
    pub mod player {
        // @@protoc_insertion_point(message:dota.CMsgDOTAMatch.Player.CustomGameData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CustomGameData {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.CustomGameData.dota_team)
            pub dota_team: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.CustomGameData.winner)
            pub winner: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatch.Player.CustomGameData.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CustomGameData {
            fn default() -> &'a CustomGameData {
                <CustomGameData as ::protobuf::Message>::default_instance()
            }
        }

        impl CustomGameData {
            pub fn new() -> CustomGameData {
                ::std::default::Default::default()
            }

            // optional uint32 dota_team = 1;

            pub fn dota_team(&self) -> u32 {
                self.dota_team.unwrap_or(0)
            }

            pub fn clear_dota_team(&mut self) {
                self.dota_team = ::std::option::Option::None;
            }

            pub fn has_dota_team(&self) -> bool {
                self.dota_team.is_some()
            }

            // Param is passed by value, moved
            pub fn set_dota_team(&mut self, v: u32) {
                self.dota_team = ::std::option::Option::Some(v);
            }

            // optional bool winner = 2;

            pub fn winner(&self) -> bool {
                self.winner.unwrap_or(false)
            }

            pub fn clear_winner(&mut self) {
                self.winner = ::std::option::Option::None;
            }

            pub fn has_winner(&self) -> bool {
                self.winner.is_some()
            }

            // Param is passed by value, moved
            pub fn set_winner(&mut self, v: bool) {
                self.winner = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "dota_team",
                    |m: &CustomGameData| { &m.dota_team },
                    |m: &mut CustomGameData| { &mut m.dota_team },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "winner",
                    |m: &CustomGameData| { &m.winner },
                    |m: &mut CustomGameData| { &mut m.winner },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomGameData>(
                    "CMsgDOTAMatch.Player.CustomGameData",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CustomGameData {
            const NAME: &'static str = "CustomGameData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.dota_team = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.winner = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.dota_team {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.winner {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.dota_team {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.winner {
                    os.write_bool(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CustomGameData {
                CustomGameData::new()
            }

            fn clear(&mut self) {
                self.dota_team = ::std::option::Option::None;
                self.winner = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CustomGameData {
                static instance: CustomGameData = CustomGameData {
                    dota_team: ::std::option::Option::None,
                    winner: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for CustomGameData {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTAMatch.Player.CustomGameData").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CustomGameData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CustomGameData {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CMsgDOTAMatch.Player.HeroDamageReceived)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct HeroDamageReceived {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.HeroDamageReceived.pre_reduction)
            pub pre_reduction: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.HeroDamageReceived.post_reduction)
            pub post_reduction: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Player.HeroDamageReceived.damage_type)
            pub damage_type: ::std::option::Option<::protobuf::EnumOrUnknown<HeroDamageType>>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatch.Player.HeroDamageReceived.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a HeroDamageReceived {
            fn default() -> &'a HeroDamageReceived {
                <HeroDamageReceived as ::protobuf::Message>::default_instance()
            }
        }

        impl HeroDamageReceived {
            pub fn new() -> HeroDamageReceived {
                ::std::default::Default::default()
            }

            // optional uint32 pre_reduction = 1;

            pub fn pre_reduction(&self) -> u32 {
                self.pre_reduction.unwrap_or(0)
            }

            pub fn clear_pre_reduction(&mut self) {
                self.pre_reduction = ::std::option::Option::None;
            }

            pub fn has_pre_reduction(&self) -> bool {
                self.pre_reduction.is_some()
            }

            // Param is passed by value, moved
            pub fn set_pre_reduction(&mut self, v: u32) {
                self.pre_reduction = ::std::option::Option::Some(v);
            }

            // optional uint32 post_reduction = 2;

            pub fn post_reduction(&self) -> u32 {
                self.post_reduction.unwrap_or(0)
            }

            pub fn clear_post_reduction(&mut self) {
                self.post_reduction = ::std::option::Option::None;
            }

            pub fn has_post_reduction(&self) -> bool {
                self.post_reduction.is_some()
            }

            // Param is passed by value, moved
            pub fn set_post_reduction(&mut self, v: u32) {
                self.post_reduction = ::std::option::Option::Some(v);
            }

            // optional .dota.CMsgDOTAMatch.Player.HeroDamageType damage_type = 3;

            pub fn damage_type(&self) -> HeroDamageType {
                match self.damage_type {
                    Some(e) => e.enum_value_or(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                    None => HeroDamageType::HERO_DAMAGE_PHYSICAL,
                }
            }

            pub fn clear_damage_type(&mut self) {
                self.damage_type = ::std::option::Option::None;
            }

            pub fn has_damage_type(&self) -> bool {
                self.damage_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_damage_type(&mut self, v: HeroDamageType) {
                self.damage_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "pre_reduction",
                    |m: &HeroDamageReceived| { &m.pre_reduction },
                    |m: &mut HeroDamageReceived| { &mut m.pre_reduction },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "post_reduction",
                    |m: &HeroDamageReceived| { &m.post_reduction },
                    |m: &mut HeroDamageReceived| { &mut m.post_reduction },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "damage_type",
                    |m: &HeroDamageReceived| { &m.damage_type },
                    |m: &mut HeroDamageReceived| { &mut m.damage_type },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroDamageReceived>(
                    "CMsgDOTAMatch.Player.HeroDamageReceived",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for HeroDamageReceived {
            const NAME: &'static str = "HeroDamageReceived";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.pre_reduction = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.post_reduction = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.damage_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.pre_reduction {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.post_reduction {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.damage_type {
                    my_size += ::protobuf::rt::int32_size(3, v.value());
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.pre_reduction {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.post_reduction {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.damage_type {
                    os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> HeroDamageReceived {
                HeroDamageReceived::new()
            }

            fn clear(&mut self) {
                self.pre_reduction = ::std::option::Option::None;
                self.post_reduction = ::std::option::Option::None;
                self.damage_type = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static HeroDamageReceived {
                static instance: HeroDamageReceived = HeroDamageReceived {
                    pre_reduction: ::std::option::Option::None,
                    post_reduction: ::std::option::Option::None,
                    damage_type: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for HeroDamageReceived {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTAMatch.Player.HeroDamageReceived").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for HeroDamageReceived {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for HeroDamageReceived {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:dota.CMsgDOTAMatch.Player.HeroDamageType)
        pub enum HeroDamageType {
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTAMatch.Player.HeroDamageType.HERO_DAMAGE_PHYSICAL)
            HERO_DAMAGE_PHYSICAL = 0,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTAMatch.Player.HeroDamageType.HERO_DAMAGE_MAGICAL)
            HERO_DAMAGE_MAGICAL = 1,
            // @@protoc_insertion_point(enum_value:dota.CMsgDOTAMatch.Player.HeroDamageType.HERO_DAMAGE_PURE)
            HERO_DAMAGE_PURE = 2,
        }

        impl ::protobuf::Enum for HeroDamageType {
            const NAME: &'static str = "HeroDamageType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<HeroDamageType> {
                match value {
                    0 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                    1 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_MAGICAL),
                    2 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PURE),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<HeroDamageType> {
                match str {
                    "HERO_DAMAGE_PHYSICAL" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                    "HERO_DAMAGE_MAGICAL" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_MAGICAL),
                    "HERO_DAMAGE_PURE" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PURE),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [HeroDamageType] = &[
                HeroDamageType::HERO_DAMAGE_PHYSICAL,
                HeroDamageType::HERO_DAMAGE_MAGICAL,
                HeroDamageType::HERO_DAMAGE_PURE,
            ];
        }

        impl ::protobuf::EnumFull for HeroDamageType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CMsgDOTAMatch.Player.HeroDamageType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for HeroDamageType {
            fn default() -> Self {
                HeroDamageType::HERO_DAMAGE_PHYSICAL
            }
        }

        impl HeroDamageType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HeroDamageType>("CMsgDOTAMatch.Player.HeroDamageType")
            }
        }
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTAMatch.BroadcasterInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BroadcasterInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.BroadcasterInfo.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.BroadcasterInfo.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatch.BroadcasterInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BroadcasterInfo {
        fn default() -> &'a BroadcasterInfo {
            <BroadcasterInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl BroadcasterInfo {
        pub fn new() -> BroadcasterInfo {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &BroadcasterInfo| { &m.account_id },
                |m: &mut BroadcasterInfo| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &BroadcasterInfo| { &m.name },
                |m: &mut BroadcasterInfo| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BroadcasterInfo>(
                "CMsgDOTAMatch.BroadcasterInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BroadcasterInfo {
        const NAME: &'static str = "BroadcasterInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BroadcasterInfo {
            BroadcasterInfo::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BroadcasterInfo {
            static instance: BroadcasterInfo = BroadcasterInfo {
                account_id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BroadcasterInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAMatch.BroadcasterInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BroadcasterInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BroadcasterInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTAMatch.BroadcasterChannel)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BroadcasterChannel {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.BroadcasterChannel.country_code)
        pub country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.BroadcasterChannel.description)
        pub description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.BroadcasterChannel.broadcaster_infos)
        pub broadcaster_infos: ::std::vec::Vec<BroadcasterInfo>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.BroadcasterChannel.language_code)
        pub language_code: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatch.BroadcasterChannel.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BroadcasterChannel {
        fn default() -> &'a BroadcasterChannel {
            <BroadcasterChannel as ::protobuf::Message>::default_instance()
        }
    }

    impl BroadcasterChannel {
        pub fn new() -> BroadcasterChannel {
            ::std::default::Default::default()
        }

        // optional string country_code = 1;

        pub fn country_code(&self) -> &str {
            match self.country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country_code(&mut self) {
            self.country_code = ::std::option::Option::None;
        }

        pub fn has_country_code(&self) -> bool {
            self.country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country_code(&mut self, v: ::std::string::String) {
            self.country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
            if self.country_code.is_none() {
                self.country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_country_code(&mut self) -> ::std::string::String {
            self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string description = 2;

        pub fn description(&self) -> &str {
            match self.description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_description(&mut self) {
            self.description = ::std::option::Option::None;
        }

        pub fn has_description(&self) -> bool {
            self.description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            if self.description.is_none() {
                self.description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.description.as_mut().unwrap()
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            self.description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string language_code = 4;

        pub fn language_code(&self) -> &str {
            match self.language_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language_code(&mut self) {
            self.language_code = ::std::option::Option::None;
        }

        pub fn has_language_code(&self) -> bool {
            self.language_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language_code(&mut self, v: ::std::string::String) {
            self.language_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language_code(&mut self) -> &mut ::std::string::String {
            if self.language_code.is_none() {
                self.language_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_language_code(&mut self) -> ::std::string::String {
            self.language_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "country_code",
                |m: &BroadcasterChannel| { &m.country_code },
                |m: &mut BroadcasterChannel| { &mut m.country_code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "description",
                |m: &BroadcasterChannel| { &m.description },
                |m: &mut BroadcasterChannel| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "broadcaster_infos",
                |m: &BroadcasterChannel| { &m.broadcaster_infos },
                |m: &mut BroadcasterChannel| { &mut m.broadcaster_infos },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language_code",
                |m: &BroadcasterChannel| { &m.language_code },
                |m: &mut BroadcasterChannel| { &mut m.language_code },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BroadcasterChannel>(
                "CMsgDOTAMatch.BroadcasterChannel",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BroadcasterChannel {
        const NAME: &'static str = "BroadcasterChannel";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.description = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.broadcaster_infos.push(is.read_message()?);
                    },
                    34 => {
                        self.language_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.country_code.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.description.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            for value in &self.broadcaster_infos {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.language_code.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.country_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.description.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.broadcaster_infos {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.language_code.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BroadcasterChannel {
            BroadcasterChannel::new()
        }

        fn clear(&mut self) {
            self.country_code = ::std::option::Option::None;
            self.description = ::std::option::Option::None;
            self.broadcaster_infos.clear();
            self.language_code = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BroadcasterChannel {
            static instance: BroadcasterChannel = BroadcasterChannel {
                country_code: ::std::option::Option::None,
                description: ::std::option::Option::None,
                broadcaster_infos: ::std::vec::Vec::new(),
                language_code: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BroadcasterChannel {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAMatch.BroadcasterChannel").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BroadcasterChannel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BroadcasterChannel {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTAMatch.Coach)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Coach {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Coach.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Coach.coach_name)
        pub coach_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Coach.coach_rating)
        pub coach_rating: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Coach.coach_team)
        pub coach_team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Coach.coach_party_id)
        pub coach_party_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.Coach.is_private_coach)
        pub is_private_coach: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatch.Coach.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Coach {
        fn default() -> &'a Coach {
            <Coach as ::protobuf::Message>::default_instance()
        }
    }

    impl Coach {
        pub fn new() -> Coach {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional string coach_name = 2;

        pub fn coach_name(&self) -> &str {
            match self.coach_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_coach_name(&mut self) {
            self.coach_name = ::std::option::Option::None;
        }

        pub fn has_coach_name(&self) -> bool {
            self.coach_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coach_name(&mut self, v: ::std::string::String) {
            self.coach_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_coach_name(&mut self) -> &mut ::std::string::String {
            if self.coach_name.is_none() {
                self.coach_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.coach_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_coach_name(&mut self) -> ::std::string::String {
            self.coach_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 coach_rating = 3;

        pub fn coach_rating(&self) -> u32 {
            self.coach_rating.unwrap_or(0)
        }

        pub fn clear_coach_rating(&mut self) {
            self.coach_rating = ::std::option::Option::None;
        }

        pub fn has_coach_rating(&self) -> bool {
            self.coach_rating.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coach_rating(&mut self, v: u32) {
            self.coach_rating = ::std::option::Option::Some(v);
        }

        // optional uint32 coach_team = 4;

        pub fn coach_team(&self) -> u32 {
            self.coach_team.unwrap_or(0)
        }

        pub fn clear_coach_team(&mut self) {
            self.coach_team = ::std::option::Option::None;
        }

        pub fn has_coach_team(&self) -> bool {
            self.coach_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coach_team(&mut self, v: u32) {
            self.coach_team = ::std::option::Option::Some(v);
        }

        // optional uint64 coach_party_id = 5;

        pub fn coach_party_id(&self) -> u64 {
            self.coach_party_id.unwrap_or(0)
        }

        pub fn clear_coach_party_id(&mut self) {
            self.coach_party_id = ::std::option::Option::None;
        }

        pub fn has_coach_party_id(&self) -> bool {
            self.coach_party_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coach_party_id(&mut self, v: u64) {
            self.coach_party_id = ::std::option::Option::Some(v);
        }

        // optional bool is_private_coach = 6;

        pub fn is_private_coach(&self) -> bool {
            self.is_private_coach.unwrap_or(false)
        }

        pub fn clear_is_private_coach(&mut self) {
            self.is_private_coach = ::std::option::Option::None;
        }

        pub fn has_is_private_coach(&self) -> bool {
            self.is_private_coach.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_private_coach(&mut self, v: bool) {
            self.is_private_coach = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Coach| { &m.account_id },
                |m: &mut Coach| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "coach_name",
                |m: &Coach| { &m.coach_name },
                |m: &mut Coach| { &mut m.coach_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "coach_rating",
                |m: &Coach| { &m.coach_rating },
                |m: &mut Coach| { &mut m.coach_rating },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "coach_team",
                |m: &Coach| { &m.coach_team },
                |m: &mut Coach| { &mut m.coach_team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "coach_party_id",
                |m: &Coach| { &m.coach_party_id },
                |m: &mut Coach| { &mut m.coach_party_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_private_coach",
                |m: &Coach| { &m.is_private_coach },
                |m: &mut Coach| { &mut m.is_private_coach },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Coach>(
                "CMsgDOTAMatch.Coach",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Coach {
        const NAME: &'static str = "Coach";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.coach_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.coach_rating = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.coach_team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.coach_party_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    48 => {
                        self.is_private_coach = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.coach_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.coach_rating {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.coach_team {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.coach_party_id {
                my_size += ::protobuf::rt::uint64_size(5, v);
            }
            if let Some(v) = self.is_private_coach {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.coach_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.coach_rating {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.coach_team {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.coach_party_id {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.is_private_coach {
                os.write_bool(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Coach {
            Coach::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.coach_name = ::std::option::Option::None;
            self.coach_rating = ::std::option::Option::None;
            self.coach_team = ::std::option::Option::None;
            self.coach_party_id = ::std::option::Option::None;
            self.is_private_coach = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Coach {
            static instance: Coach = Coach {
                account_id: ::std::option::Option::None,
                coach_name: ::std::option::Option::None,
                coach_rating: ::std::option::Option::None,
                coach_team: ::std::option::Option::None,
                coach_party_id: ::std::option::Option::None,
                is_private_coach: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Coach {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAMatch.Coach").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Coach {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Coach {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTAMatch.CustomGameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CustomGameData {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.CustomGameData.custom_game_id)
        pub custom_game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatch.CustomGameData.map_name)
        pub map_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatch.CustomGameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CustomGameData {
        fn default() -> &'a CustomGameData {
            <CustomGameData as ::protobuf::Message>::default_instance()
        }
    }

    impl CustomGameData {
        pub fn new() -> CustomGameData {
            ::std::default::Default::default()
        }

        // optional uint64 custom_game_id = 1;

        pub fn custom_game_id(&self) -> u64 {
            self.custom_game_id.unwrap_or(0)
        }

        pub fn clear_custom_game_id(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
        }

        pub fn has_custom_game_id(&self) -> bool {
            self.custom_game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_custom_game_id(&mut self, v: u64) {
            self.custom_game_id = ::std::option::Option::Some(v);
        }

        // optional string map_name = 2;

        pub fn map_name(&self) -> &str {
            match self.map_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_map_name(&mut self) {
            self.map_name = ::std::option::Option::None;
        }

        pub fn has_map_name(&self) -> bool {
            self.map_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_name(&mut self, v: ::std::string::String) {
            self.map_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
            if self.map_name.is_none() {
                self.map_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.map_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_map_name(&mut self) -> ::std::string::String {
            self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "custom_game_id",
                |m: &CustomGameData| { &m.custom_game_id },
                |m: &mut CustomGameData| { &mut m.custom_game_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "map_name",
                |m: &CustomGameData| { &m.map_name },
                |m: &mut CustomGameData| { &mut m.map_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomGameData>(
                "CMsgDOTAMatch.CustomGameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CustomGameData {
        const NAME: &'static str = "CustomGameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.map_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.custom_game_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.map_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.custom_game_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.map_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CustomGameData {
            CustomGameData::new()
        }

        fn clear(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
            self.map_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CustomGameData {
            static instance: CustomGameData = CustomGameData {
                custom_game_id: ::std::option::Option::None,
                map_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CustomGameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAMatch.CustomGameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CustomGameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CustomGameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgDOTAMatch.ReplayState)
    pub enum ReplayState {
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTAMatch.ReplayState.REPLAY_AVAILABLE)
        REPLAY_AVAILABLE = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTAMatch.ReplayState.REPLAY_NOT_RECORDED)
        REPLAY_NOT_RECORDED = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgDOTAMatch.ReplayState.REPLAY_EXPIRED)
        REPLAY_EXPIRED = 2,
    }

    impl ::protobuf::Enum for ReplayState {
        const NAME: &'static str = "ReplayState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ReplayState> {
            match value {
                0 => ::std::option::Option::Some(ReplayState::REPLAY_AVAILABLE),
                1 => ::std::option::Option::Some(ReplayState::REPLAY_NOT_RECORDED),
                2 => ::std::option::Option::Some(ReplayState::REPLAY_EXPIRED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ReplayState> {
            match str {
                "REPLAY_AVAILABLE" => ::std::option::Option::Some(ReplayState::REPLAY_AVAILABLE),
                "REPLAY_NOT_RECORDED" => ::std::option::Option::Some(ReplayState::REPLAY_NOT_RECORDED),
                "REPLAY_EXPIRED" => ::std::option::Option::Some(ReplayState::REPLAY_EXPIRED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ReplayState] = &[
            ReplayState::REPLAY_AVAILABLE,
            ReplayState::REPLAY_NOT_RECORDED,
            ReplayState::REPLAY_EXPIRED,
        ];
    }

    impl ::protobuf::EnumFull for ReplayState {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgDOTAMatch.ReplayState").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ReplayState {
        fn default() -> Self {
            ReplayState::REPLAY_AVAILABLE
        }
    }

    impl ReplayState {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReplayState>("CMsgDOTAMatch.ReplayState")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgPlayerCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerCard {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPlayerCard.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerCard.stat_modifier)
    pub stat_modifier: ::std::vec::Vec<cmsg_player_card::StatModifier>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPlayerCard.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerCard {
    fn default() -> &'a CMsgPlayerCard {
        <CMsgPlayerCard as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerCard {
    pub fn new() -> CMsgPlayerCard {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgPlayerCard| { &m.account_id },
            |m: &mut CMsgPlayerCard| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_modifier",
            |m: &CMsgPlayerCard| { &m.stat_modifier },
            |m: &mut CMsgPlayerCard| { &mut m.stat_modifier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerCard>(
            "CMsgPlayerCard",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerCard {
    const NAME: &'static str = "CMsgPlayerCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.stat_modifier.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.stat_modifier {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stat_modifier {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerCard {
        CMsgPlayerCard::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.stat_modifier.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerCard {
        static instance: CMsgPlayerCard = CMsgPlayerCard {
            account_id: ::std::option::Option::None,
            stat_modifier: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerCard {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerCard").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerCard {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPlayerCard`
pub mod cmsg_player_card {
    // @@protoc_insertion_point(message:dota.CMsgPlayerCard.StatModifier)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatModifier {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgPlayerCard.StatModifier.stat)
        pub stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPlayerCard.StatModifier.value)
        pub value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgPlayerCard.StatModifier.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatModifier {
        fn default() -> &'a StatModifier {
            <StatModifier as ::protobuf::Message>::default_instance()
        }
    }

    impl StatModifier {
        pub fn new() -> StatModifier {
            ::std::default::Default::default()
        }

        // optional uint32 stat = 1;

        pub fn stat(&self) -> u32 {
            self.stat.unwrap_or(0)
        }

        pub fn clear_stat(&mut self) {
            self.stat = ::std::option::Option::None;
        }

        pub fn has_stat(&self) -> bool {
            self.stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat(&mut self, v: u32) {
            self.stat = ::std::option::Option::Some(v);
        }

        // optional uint32 value = 2;

        pub fn value(&self) -> u32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u32) {
            self.value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat",
                |m: &StatModifier| { &m.stat },
                |m: &mut StatModifier| { &mut m.stat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &StatModifier| { &m.value },
                |m: &mut StatModifier| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatModifier>(
                "CMsgPlayerCard.StatModifier",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StatModifier {
        const NAME: &'static str = "StatModifier";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stat {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatModifier {
            StatModifier::new()
        }

        fn clear(&mut self) {
            self.stat = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatModifier {
            static instance: StatModifier = StatModifier {
                stat: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StatModifier {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPlayerCard.StatModifier").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StatModifier {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StatModifier {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTAFantasyPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.player_account_id)
    pub player_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.match_completed)
    pub match_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.delay)
    pub delay: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.series_id)
    pub series_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.cs)
    pub cs: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.gpm)
    pub gpm: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.tower_kills)
    pub tower_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.roshan_kills)
    pub roshan_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.teamfight_participation)
    pub teamfight_participation: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.wards_placed)
    pub wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.camps_stacked)
    pub camps_stacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.runes_grabbed)
    pub runes_grabbed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.first_blood)
    pub first_blood: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerStats.stuns)
    pub stuns: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyPlayerStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyPlayerStats {
    fn default() -> &'a CMsgDOTAFantasyPlayerStats {
        <CMsgDOTAFantasyPlayerStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyPlayerStats {
    pub fn new() -> CMsgDOTAFantasyPlayerStats {
        ::std::default::Default::default()
    }

    // optional uint32 player_account_id = 1;

    pub fn player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool match_completed = 3;

    pub fn match_completed(&self) -> bool {
        self.match_completed.unwrap_or(false)
    }

    pub fn clear_match_completed(&mut self) {
        self.match_completed = ::std::option::Option::None;
    }

    pub fn has_match_completed(&self) -> bool {
        self.match_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_completed(&mut self, v: bool) {
        self.match_completed = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 4;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 5;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 delay = 6;

    pub fn delay(&self) -> u32 {
        self.delay.unwrap_or(0)
    }

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: u32) {
        self.delay = ::std::option::Option::Some(v);
    }

    // optional uint32 series_id = 7;

    pub fn series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 8;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 10;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 11;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 cs = 12;

    pub fn cs(&self) -> u32 {
        self.cs.unwrap_or(0)
    }

    pub fn clear_cs(&mut self) {
        self.cs = ::std::option::Option::None;
    }

    pub fn has_cs(&self) -> bool {
        self.cs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cs(&mut self, v: u32) {
        self.cs = ::std::option::Option::Some(v);
    }

    // optional float gpm = 13;

    pub fn gpm(&self) -> f32 {
        self.gpm.unwrap_or(0.)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: f32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional uint32 tower_kills = 14;

    pub fn tower_kills(&self) -> u32 {
        self.tower_kills.unwrap_or(0)
    }

    pub fn clear_tower_kills(&mut self) {
        self.tower_kills = ::std::option::Option::None;
    }

    pub fn has_tower_kills(&self) -> bool {
        self.tower_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_kills(&mut self, v: u32) {
        self.tower_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 roshan_kills = 15;

    pub fn roshan_kills(&self) -> u32 {
        self.roshan_kills.unwrap_or(0)
    }

    pub fn clear_roshan_kills(&mut self) {
        self.roshan_kills = ::std::option::Option::None;
    }

    pub fn has_roshan_kills(&self) -> bool {
        self.roshan_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_kills(&mut self, v: u32) {
        self.roshan_kills = ::std::option::Option::Some(v);
    }

    // optional float teamfight_participation = 16;

    pub fn teamfight_participation(&self) -> f32 {
        self.teamfight_participation.unwrap_or(0.)
    }

    pub fn clear_teamfight_participation(&mut self) {
        self.teamfight_participation = ::std::option::Option::None;
    }

    pub fn has_teamfight_participation(&self) -> bool {
        self.teamfight_participation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamfight_participation(&mut self, v: f32) {
        self.teamfight_participation = ::std::option::Option::Some(v);
    }

    // optional uint32 wards_placed = 17;

    pub fn wards_placed(&self) -> u32 {
        self.wards_placed.unwrap_or(0)
    }

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: u32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 camps_stacked = 18;

    pub fn camps_stacked(&self) -> u32 {
        self.camps_stacked.unwrap_or(0)
    }

    pub fn clear_camps_stacked(&mut self) {
        self.camps_stacked = ::std::option::Option::None;
    }

    pub fn has_camps_stacked(&self) -> bool {
        self.camps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camps_stacked(&mut self, v: u32) {
        self.camps_stacked = ::std::option::Option::Some(v);
    }

    // optional uint32 runes_grabbed = 19;

    pub fn runes_grabbed(&self) -> u32 {
        self.runes_grabbed.unwrap_or(0)
    }

    pub fn clear_runes_grabbed(&mut self) {
        self.runes_grabbed = ::std::option::Option::None;
    }

    pub fn has_runes_grabbed(&self) -> bool {
        self.runes_grabbed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runes_grabbed(&mut self, v: u32) {
        self.runes_grabbed = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood = 20;

    pub fn first_blood(&self) -> u32 {
        self.first_blood.unwrap_or(0)
    }

    pub fn clear_first_blood(&mut self) {
        self.first_blood = ::std::option::Option::None;
    }

    pub fn has_first_blood(&self) -> bool {
        self.first_blood.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood(&mut self, v: u32) {
        self.first_blood = ::std::option::Option::Some(v);
    }

    // optional float stuns = 21;

    pub fn stuns(&self) -> f32 {
        self.stuns.unwrap_or(0.)
    }

    pub fn clear_stuns(&mut self) {
        self.stuns = ::std::option::Option::None;
    }

    pub fn has_stuns(&self) -> bool {
        self.stuns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stuns(&mut self, v: f32) {
        self.stuns = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_account_id",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.player_account_id },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.player_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.match_id },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_completed",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.match_completed },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.match_completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.team_id },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.league_id },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.delay },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_id",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.series_id },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.series_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_type",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.series_type },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.series_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.kills },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaths",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.deaths },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cs",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.cs },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.cs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpm",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.gpm },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.gpm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tower_kills",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.tower_kills },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.tower_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roshan_kills",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.roshan_kills },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.roshan_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "teamfight_participation",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.teamfight_participation },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.teamfight_participation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wards_placed",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.wards_placed },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.wards_placed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "camps_stacked",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.camps_stacked },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.camps_stacked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runes_grabbed",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.runes_grabbed },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.runes_grabbed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_blood",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.first_blood },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.first_blood },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stuns",
            |m: &CMsgDOTAFantasyPlayerStats| { &m.stuns },
            |m: &mut CMsgDOTAFantasyPlayerStats| { &mut m.stuns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAFantasyPlayerStats>(
            "CMsgDOTAFantasyPlayerStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerStats {
    const NAME: &'static str = "CMsgDOTAFantasyPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.match_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.delay = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.cs = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.gpm = ::std::option::Option::Some(is.read_float()?);
                },
                112 => {
                    self.tower_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                133 => {
                    self.teamfight_participation = ::std::option::Option::Some(is.read_float()?);
                },
                136 => {
                    self.wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.runes_grabbed = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.first_blood = ::std::option::Option::Some(is.read_uint32()?);
                },
                173 => {
                    self.stuns = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.match_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.delay {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.cs {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.gpm {
            my_size += 1 + 4;
        }
        if let Some(v) = self.tower_kills {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.roshan_kills {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.teamfight_participation {
            my_size += 2 + 4;
        }
        if let Some(v) = self.wards_placed {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.camps_stacked {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.runes_grabbed {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.first_blood {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.stuns {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.match_completed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.delay {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.cs {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.tower_kills {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.roshan_kills {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.teamfight_participation {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.camps_stacked {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.runes_grabbed {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.first_blood {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.stuns {
            os.write_float(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyPlayerStats {
        CMsgDOTAFantasyPlayerStats::new()
    }

    fn clear(&mut self) {
        self.player_account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.match_completed = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.delay = ::std::option::Option::None;
        self.series_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.cs = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.tower_kills = ::std::option::Option::None;
        self.roshan_kills = ::std::option::Option::None;
        self.teamfight_participation = ::std::option::Option::None;
        self.wards_placed = ::std::option::Option::None;
        self.camps_stacked = ::std::option::Option::None;
        self.runes_grabbed = ::std::option::Option::None;
        self.first_blood = ::std::option::Option::None;
        self.stuns = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyPlayerStats {
        static instance: CMsgDOTAFantasyPlayerStats = CMsgDOTAFantasyPlayerStats {
            player_account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            match_completed: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            delay: ::std::option::Option::None,
            series_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            cs: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            tower_kills: ::std::option::Option::None,
            roshan_kills: ::std::option::Option::None,
            teamfight_participation: ::std::option::Option::None,
            wards_placed: ::std::option::Option::None,
            camps_stacked: ::std::option::Option::None,
            runes_grabbed: ::std::option::Option::None,
            first_blood: ::std::option::Option::None,
            stuns: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAFantasyPlayerStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyPlayerStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAFantasyPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTAFantasyPlayerMatchStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyPlayerMatchStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAFantasyPlayerMatchStats.matches)
    pub matches: ::std::vec::Vec<CMsgDOTAFantasyPlayerStats>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAFantasyPlayerMatchStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyPlayerMatchStats {
    fn default() -> &'a CMsgDOTAFantasyPlayerMatchStats {
        <CMsgDOTAFantasyPlayerMatchStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyPlayerMatchStats {
    pub fn new() -> CMsgDOTAFantasyPlayerMatchStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &CMsgDOTAFantasyPlayerMatchStats| { &m.matches },
            |m: &mut CMsgDOTAFantasyPlayerMatchStats| { &mut m.matches },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAFantasyPlayerMatchStats>(
            "CMsgDOTAFantasyPlayerMatchStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerMatchStats {
    const NAME: &'static str = "CMsgDOTAFantasyPlayerMatchStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matches.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyPlayerMatchStats {
        CMsgDOTAFantasyPlayerMatchStats::new()
    }

    fn clear(&mut self) {
        self.matches.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyPlayerMatchStats {
        static instance: CMsgDOTAFantasyPlayerMatchStats = CMsgDOTAFantasyPlayerMatchStats {
            matches: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAFantasyPlayerMatchStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAFantasyPlayerMatchStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAFantasyPlayerMatchStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerMatchStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTABotDebugInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTABotDebugInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.bots)
    pub bots: ::std::vec::Vec<cmsg_dotabot_debug_info::Bot>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_push_lane_top)
    pub desire_push_lane_top: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_push_lane_mid)
    pub desire_push_lane_mid: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_push_lane_bot)
    pub desire_push_lane_bot: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_defend_lane_top)
    pub desire_defend_lane_top: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_defend_lane_mid)
    pub desire_defend_lane_mid: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_defend_lane_bot)
    pub desire_defend_lane_bot: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_farm_lane_top)
    pub desire_farm_lane_top: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_farm_lane_mid)
    pub desire_farm_lane_mid: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_farm_lane_bot)
    pub desire_farm_lane_bot: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.desire_farm_roshan)
    pub desire_farm_roshan: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.execution_time)
    pub execution_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.rune_status)
    pub rune_status: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTABotDebugInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTABotDebugInfo {
    fn default() -> &'a CMsgDOTABotDebugInfo {
        <CMsgDOTABotDebugInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTABotDebugInfo {
    pub fn new() -> CMsgDOTABotDebugInfo {
        ::std::default::Default::default()
    }

    // optional float desire_push_lane_top = 2;

    pub fn desire_push_lane_top(&self) -> f32 {
        self.desire_push_lane_top.unwrap_or(0.)
    }

    pub fn clear_desire_push_lane_top(&mut self) {
        self.desire_push_lane_top = ::std::option::Option::None;
    }

    pub fn has_desire_push_lane_top(&self) -> bool {
        self.desire_push_lane_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_push_lane_top(&mut self, v: f32) {
        self.desire_push_lane_top = ::std::option::Option::Some(v);
    }

    // optional float desire_push_lane_mid = 3;

    pub fn desire_push_lane_mid(&self) -> f32 {
        self.desire_push_lane_mid.unwrap_or(0.)
    }

    pub fn clear_desire_push_lane_mid(&mut self) {
        self.desire_push_lane_mid = ::std::option::Option::None;
    }

    pub fn has_desire_push_lane_mid(&self) -> bool {
        self.desire_push_lane_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_push_lane_mid(&mut self, v: f32) {
        self.desire_push_lane_mid = ::std::option::Option::Some(v);
    }

    // optional float desire_push_lane_bot = 4;

    pub fn desire_push_lane_bot(&self) -> f32 {
        self.desire_push_lane_bot.unwrap_or(0.)
    }

    pub fn clear_desire_push_lane_bot(&mut self) {
        self.desire_push_lane_bot = ::std::option::Option::None;
    }

    pub fn has_desire_push_lane_bot(&self) -> bool {
        self.desire_push_lane_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_push_lane_bot(&mut self, v: f32) {
        self.desire_push_lane_bot = ::std::option::Option::Some(v);
    }

    // optional float desire_defend_lane_top = 5;

    pub fn desire_defend_lane_top(&self) -> f32 {
        self.desire_defend_lane_top.unwrap_or(0.)
    }

    pub fn clear_desire_defend_lane_top(&mut self) {
        self.desire_defend_lane_top = ::std::option::Option::None;
    }

    pub fn has_desire_defend_lane_top(&self) -> bool {
        self.desire_defend_lane_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_defend_lane_top(&mut self, v: f32) {
        self.desire_defend_lane_top = ::std::option::Option::Some(v);
    }

    // optional float desire_defend_lane_mid = 6;

    pub fn desire_defend_lane_mid(&self) -> f32 {
        self.desire_defend_lane_mid.unwrap_or(0.)
    }

    pub fn clear_desire_defend_lane_mid(&mut self) {
        self.desire_defend_lane_mid = ::std::option::Option::None;
    }

    pub fn has_desire_defend_lane_mid(&self) -> bool {
        self.desire_defend_lane_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_defend_lane_mid(&mut self, v: f32) {
        self.desire_defend_lane_mid = ::std::option::Option::Some(v);
    }

    // optional float desire_defend_lane_bot = 7;

    pub fn desire_defend_lane_bot(&self) -> f32 {
        self.desire_defend_lane_bot.unwrap_or(0.)
    }

    pub fn clear_desire_defend_lane_bot(&mut self) {
        self.desire_defend_lane_bot = ::std::option::Option::None;
    }

    pub fn has_desire_defend_lane_bot(&self) -> bool {
        self.desire_defend_lane_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_defend_lane_bot(&mut self, v: f32) {
        self.desire_defend_lane_bot = ::std::option::Option::Some(v);
    }

    // optional float desire_farm_lane_top = 8;

    pub fn desire_farm_lane_top(&self) -> f32 {
        self.desire_farm_lane_top.unwrap_or(0.)
    }

    pub fn clear_desire_farm_lane_top(&mut self) {
        self.desire_farm_lane_top = ::std::option::Option::None;
    }

    pub fn has_desire_farm_lane_top(&self) -> bool {
        self.desire_farm_lane_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_lane_top(&mut self, v: f32) {
        self.desire_farm_lane_top = ::std::option::Option::Some(v);
    }

    // optional float desire_farm_lane_mid = 9;

    pub fn desire_farm_lane_mid(&self) -> f32 {
        self.desire_farm_lane_mid.unwrap_or(0.)
    }

    pub fn clear_desire_farm_lane_mid(&mut self) {
        self.desire_farm_lane_mid = ::std::option::Option::None;
    }

    pub fn has_desire_farm_lane_mid(&self) -> bool {
        self.desire_farm_lane_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_lane_mid(&mut self, v: f32) {
        self.desire_farm_lane_mid = ::std::option::Option::Some(v);
    }

    // optional float desire_farm_lane_bot = 10;

    pub fn desire_farm_lane_bot(&self) -> f32 {
        self.desire_farm_lane_bot.unwrap_or(0.)
    }

    pub fn clear_desire_farm_lane_bot(&mut self) {
        self.desire_farm_lane_bot = ::std::option::Option::None;
    }

    pub fn has_desire_farm_lane_bot(&self) -> bool {
        self.desire_farm_lane_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_lane_bot(&mut self, v: f32) {
        self.desire_farm_lane_bot = ::std::option::Option::Some(v);
    }

    // optional float desire_farm_roshan = 11;

    pub fn desire_farm_roshan(&self) -> f32 {
        self.desire_farm_roshan.unwrap_or(0.)
    }

    pub fn clear_desire_farm_roshan(&mut self) {
        self.desire_farm_roshan = ::std::option::Option::None;
    }

    pub fn has_desire_farm_roshan(&self) -> bool {
        self.desire_farm_roshan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_roshan(&mut self, v: f32) {
        self.desire_farm_roshan = ::std::option::Option::Some(v);
    }

    // optional float execution_time = 12;

    pub fn execution_time(&self) -> f32 {
        self.execution_time.unwrap_or(0.)
    }

    pub fn clear_execution_time(&mut self) {
        self.execution_time = ::std::option::Option::None;
    }

    pub fn has_execution_time(&self) -> bool {
        self.execution_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution_time(&mut self, v: f32) {
        self.execution_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bots",
            |m: &CMsgDOTABotDebugInfo| { &m.bots },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.bots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_push_lane_top",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_push_lane_top },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_push_lane_top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_push_lane_mid",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_push_lane_mid },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_push_lane_mid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_push_lane_bot",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_push_lane_bot },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_push_lane_bot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_defend_lane_top",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_defend_lane_top },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_defend_lane_top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_defend_lane_mid",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_defend_lane_mid },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_defend_lane_mid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_defend_lane_bot",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_defend_lane_bot },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_defend_lane_bot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_farm_lane_top",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_farm_lane_top },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_farm_lane_top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_farm_lane_mid",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_farm_lane_mid },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_farm_lane_mid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_farm_lane_bot",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_farm_lane_bot },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_farm_lane_bot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desire_farm_roshan",
            |m: &CMsgDOTABotDebugInfo| { &m.desire_farm_roshan },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.desire_farm_roshan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "execution_time",
            |m: &CMsgDOTABotDebugInfo| { &m.execution_time },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.execution_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rune_status",
            |m: &CMsgDOTABotDebugInfo| { &m.rune_status },
            |m: &mut CMsgDOTABotDebugInfo| { &mut m.rune_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTABotDebugInfo>(
            "CMsgDOTABotDebugInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTABotDebugInfo {
    const NAME: &'static str = "CMsgDOTABotDebugInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bots.push(is.read_message()?);
                },
                21 => {
                    self.desire_push_lane_top = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.desire_push_lane_mid = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.desire_push_lane_bot = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.desire_defend_lane_top = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.desire_defend_lane_mid = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.desire_defend_lane_bot = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.desire_farm_lane_top = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.desire_farm_lane_mid = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.desire_farm_lane_bot = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.desire_farm_roshan = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.execution_time = ::std::option::Option::Some(is.read_float()?);
                },
                106 => {
                    is.read_repeated_packed_uint32_into(&mut self.rune_status)?;
                },
                104 => {
                    self.rune_status.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.desire_push_lane_top {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_push_lane_mid {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_push_lane_bot {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_defend_lane_top {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_defend_lane_mid {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_defend_lane_bot {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_farm_lane_top {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_farm_lane_mid {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_farm_lane_bot {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_farm_roshan {
            my_size += 1 + 4;
        }
        if let Some(v) = self.execution_time {
            my_size += 1 + 4;
        }
        for value in &self.rune_status {
            my_size += ::protobuf::rt::uint32_size(13, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.bots {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.desire_push_lane_top {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.desire_push_lane_mid {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.desire_push_lane_bot {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.desire_defend_lane_top {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.desire_defend_lane_mid {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.desire_defend_lane_bot {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.desire_farm_lane_top {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.desire_farm_lane_mid {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.desire_farm_lane_bot {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.desire_farm_roshan {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.execution_time {
            os.write_float(12, v)?;
        }
        for v in &self.rune_status {
            os.write_uint32(13, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTABotDebugInfo {
        CMsgDOTABotDebugInfo::new()
    }

    fn clear(&mut self) {
        self.bots.clear();
        self.desire_push_lane_top = ::std::option::Option::None;
        self.desire_push_lane_mid = ::std::option::Option::None;
        self.desire_push_lane_bot = ::std::option::Option::None;
        self.desire_defend_lane_top = ::std::option::Option::None;
        self.desire_defend_lane_mid = ::std::option::Option::None;
        self.desire_defend_lane_bot = ::std::option::Option::None;
        self.desire_farm_lane_top = ::std::option::Option::None;
        self.desire_farm_lane_mid = ::std::option::Option::None;
        self.desire_farm_lane_bot = ::std::option::Option::None;
        self.desire_farm_roshan = ::std::option::Option::None;
        self.execution_time = ::std::option::Option::None;
        self.rune_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTABotDebugInfo {
        static instance: CMsgDOTABotDebugInfo = CMsgDOTABotDebugInfo {
            bots: ::std::vec::Vec::new(),
            desire_push_lane_top: ::std::option::Option::None,
            desire_push_lane_mid: ::std::option::Option::None,
            desire_push_lane_bot: ::std::option::Option::None,
            desire_defend_lane_top: ::std::option::Option::None,
            desire_defend_lane_mid: ::std::option::Option::None,
            desire_defend_lane_bot: ::std::option::Option::None,
            desire_farm_lane_top: ::std::option::Option::None,
            desire_farm_lane_mid: ::std::option::Option::None,
            desire_farm_lane_bot: ::std::option::Option::None,
            desire_farm_roshan: ::std::option::Option::None,
            execution_time: ::std::option::Option::None,
            rune_status: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTABotDebugInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTABotDebugInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTABotDebugInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTABotDebugInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTABotDebugInfo`
pub mod cmsg_dotabot_debug_info {
    // @@protoc_insertion_point(message:dota.CMsgDOTABotDebugInfo.Bot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bot {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.player_owner_id)
        pub player_owner_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.difficulty)
        pub difficulty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.power_current)
        pub power_current: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.power_max)
        pub power_max: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.move_target_x)
        pub move_target_x: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.move_target_y)
        pub move_target_y: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.move_target_z)
        pub move_target_z: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.active_mode_id)
        pub active_mode_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.execution_time)
        pub execution_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.modes)
        pub modes: ::std::vec::Vec<bot::Mode>,
        // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.action)
        pub action: ::protobuf::MessageField<bot::Action>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTABotDebugInfo.Bot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bot {
        fn default() -> &'a Bot {
            <Bot as ::protobuf::Message>::default_instance()
        }
    }

    impl Bot {
        pub fn new() -> Bot {
            ::std::default::Default::default()
        }

        // optional int32 player_owner_id = 1;

        pub fn player_owner_id(&self) -> i32 {
            self.player_owner_id.unwrap_or(0)
        }

        pub fn clear_player_owner_id(&mut self) {
            self.player_owner_id = ::std::option::Option::None;
        }

        pub fn has_player_owner_id(&self) -> bool {
            self.player_owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_owner_id(&mut self, v: i32) {
            self.player_owner_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 2;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 difficulty = 3;

        pub fn difficulty(&self) -> u32 {
            self.difficulty.unwrap_or(0)
        }

        pub fn clear_difficulty(&mut self) {
            self.difficulty = ::std::option::Option::None;
        }

        pub fn has_difficulty(&self) -> bool {
            self.difficulty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_difficulty(&mut self, v: u32) {
            self.difficulty = ::std::option::Option::Some(v);
        }

        // optional uint32 power_current = 4;

        pub fn power_current(&self) -> u32 {
            self.power_current.unwrap_or(0)
        }

        pub fn clear_power_current(&mut self) {
            self.power_current = ::std::option::Option::None;
        }

        pub fn has_power_current(&self) -> bool {
            self.power_current.is_some()
        }

        // Param is passed by value, moved
        pub fn set_power_current(&mut self, v: u32) {
            self.power_current = ::std::option::Option::Some(v);
        }

        // optional uint32 power_max = 5;

        pub fn power_max(&self) -> u32 {
            self.power_max.unwrap_or(0)
        }

        pub fn clear_power_max(&mut self) {
            self.power_max = ::std::option::Option::None;
        }

        pub fn has_power_max(&self) -> bool {
            self.power_max.is_some()
        }

        // Param is passed by value, moved
        pub fn set_power_max(&mut self, v: u32) {
            self.power_max = ::std::option::Option::Some(v);
        }

        // optional uint32 move_target_x = 6;

        pub fn move_target_x(&self) -> u32 {
            self.move_target_x.unwrap_or(0)
        }

        pub fn clear_move_target_x(&mut self) {
            self.move_target_x = ::std::option::Option::None;
        }

        pub fn has_move_target_x(&self) -> bool {
            self.move_target_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_move_target_x(&mut self, v: u32) {
            self.move_target_x = ::std::option::Option::Some(v);
        }

        // optional uint32 move_target_y = 7;

        pub fn move_target_y(&self) -> u32 {
            self.move_target_y.unwrap_or(0)
        }

        pub fn clear_move_target_y(&mut self) {
            self.move_target_y = ::std::option::Option::None;
        }

        pub fn has_move_target_y(&self) -> bool {
            self.move_target_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_move_target_y(&mut self, v: u32) {
            self.move_target_y = ::std::option::Option::Some(v);
        }

        // optional uint32 move_target_z = 8;

        pub fn move_target_z(&self) -> u32 {
            self.move_target_z.unwrap_or(0)
        }

        pub fn clear_move_target_z(&mut self) {
            self.move_target_z = ::std::option::Option::None;
        }

        pub fn has_move_target_z(&self) -> bool {
            self.move_target_z.is_some()
        }

        // Param is passed by value, moved
        pub fn set_move_target_z(&mut self, v: u32) {
            self.move_target_z = ::std::option::Option::Some(v);
        }

        // optional uint32 active_mode_id = 9;

        pub fn active_mode_id(&self) -> u32 {
            self.active_mode_id.unwrap_or(0)
        }

        pub fn clear_active_mode_id(&mut self) {
            self.active_mode_id = ::std::option::Option::None;
        }

        pub fn has_active_mode_id(&self) -> bool {
            self.active_mode_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_active_mode_id(&mut self, v: u32) {
            self.active_mode_id = ::std::option::Option::Some(v);
        }

        // optional float execution_time = 10;

        pub fn execution_time(&self) -> f32 {
            self.execution_time.unwrap_or(0.)
        }

        pub fn clear_execution_time(&mut self) {
            self.execution_time = ::std::option::Option::None;
        }

        pub fn has_execution_time(&self) -> bool {
            self.execution_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_execution_time(&mut self, v: f32) {
            self.execution_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(12);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_owner_id",
                |m: &Bot| { &m.player_owner_id },
                |m: &mut Bot| { &mut m.player_owner_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &Bot| { &m.hero_id },
                |m: &mut Bot| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "difficulty",
                |m: &Bot| { &m.difficulty },
                |m: &mut Bot| { &mut m.difficulty },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "power_current",
                |m: &Bot| { &m.power_current },
                |m: &mut Bot| { &mut m.power_current },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "power_max",
                |m: &Bot| { &m.power_max },
                |m: &mut Bot| { &mut m.power_max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "move_target_x",
                |m: &Bot| { &m.move_target_x },
                |m: &mut Bot| { &mut m.move_target_x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "move_target_y",
                |m: &Bot| { &m.move_target_y },
                |m: &mut Bot| { &mut m.move_target_y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "move_target_z",
                |m: &Bot| { &m.move_target_z },
                |m: &mut Bot| { &mut m.move_target_z },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "active_mode_id",
                |m: &Bot| { &m.active_mode_id },
                |m: &mut Bot| { &mut m.active_mode_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "execution_time",
                |m: &Bot| { &m.execution_time },
                |m: &mut Bot| { &mut m.execution_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "modes",
                |m: &Bot| { &m.modes },
                |m: &mut Bot| { &mut m.modes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, bot::Action>(
                "action",
                |m: &Bot| { &m.action },
                |m: &mut Bot| { &mut m.action },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Bot>(
                "CMsgDOTABotDebugInfo.Bot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Bot {
        const NAME: &'static str = "Bot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_owner_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.difficulty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.power_current = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.power_max = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.move_target_x = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.move_target_y = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.move_target_z = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.active_mode_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    85 => {
                        self.execution_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    90 => {
                        self.modes.push(is.read_message()?);
                    },
                    98 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.action)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_owner_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.difficulty {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.power_current {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.power_max {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.move_target_x {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.move_target_y {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.move_target_z {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.active_mode_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.execution_time {
                my_size += 1 + 4;
            }
            for value in &self.modes {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.action.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_owner_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.difficulty {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.power_current {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.power_max {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.move_target_x {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.move_target_y {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.move_target_z {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.active_mode_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.execution_time {
                os.write_float(10, v)?;
            }
            for v in &self.modes {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            };
            if let Some(v) = self.action.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bot {
            Bot::new()
        }

        fn clear(&mut self) {
            self.player_owner_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.difficulty = ::std::option::Option::None;
            self.power_current = ::std::option::Option::None;
            self.power_max = ::std::option::Option::None;
            self.move_target_x = ::std::option::Option::None;
            self.move_target_y = ::std::option::Option::None;
            self.move_target_z = ::std::option::Option::None;
            self.active_mode_id = ::std::option::Option::None;
            self.execution_time = ::std::option::Option::None;
            self.modes.clear();
            self.action.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bot {
            static instance: Bot = Bot {
                player_owner_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                difficulty: ::std::option::Option::None,
                power_current: ::std::option::Option::None,
                power_max: ::std::option::Option::None,
                move_target_x: ::std::option::Option::None,
                move_target_y: ::std::option::Option::None,
                move_target_z: ::std::option::Option::None,
                active_mode_id: ::std::option::Option::None,
                execution_time: ::std::option::Option::None,
                modes: ::std::vec::Vec::new(),
                action: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Bot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTABotDebugInfo.Bot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Bot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Bot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Bot`
    pub mod bot {
        // @@protoc_insertion_point(message:dota.CMsgDOTABotDebugInfo.Bot.Mode)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Mode {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.Mode.mode_id)
            pub mode_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.Mode.desire)
            pub desire: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.Mode.target_entity)
            pub target_entity: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.Mode.target_x)
            pub target_x: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.Mode.target_y)
            pub target_y: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.Mode.target_z)
            pub target_z: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTABotDebugInfo.Bot.Mode.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Mode {
            fn default() -> &'a Mode {
                <Mode as ::protobuf::Message>::default_instance()
            }
        }

        impl Mode {
            pub fn new() -> Mode {
                ::std::default::Default::default()
            }

            // optional uint32 mode_id = 1;

            pub fn mode_id(&self) -> u32 {
                self.mode_id.unwrap_or(0)
            }

            pub fn clear_mode_id(&mut self) {
                self.mode_id = ::std::option::Option::None;
            }

            pub fn has_mode_id(&self) -> bool {
                self.mode_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_mode_id(&mut self, v: u32) {
                self.mode_id = ::std::option::Option::Some(v);
            }

            // optional float desire = 2;

            pub fn desire(&self) -> f32 {
                self.desire.unwrap_or(0.)
            }

            pub fn clear_desire(&mut self) {
                self.desire = ::std::option::Option::None;
            }

            pub fn has_desire(&self) -> bool {
                self.desire.is_some()
            }

            // Param is passed by value, moved
            pub fn set_desire(&mut self, v: f32) {
                self.desire = ::std::option::Option::Some(v);
            }

            // optional int32 target_entity = 3;

            pub fn target_entity(&self) -> i32 {
                self.target_entity.unwrap_or(0)
            }

            pub fn clear_target_entity(&mut self) {
                self.target_entity = ::std::option::Option::None;
            }

            pub fn has_target_entity(&self) -> bool {
                self.target_entity.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_entity(&mut self, v: i32) {
                self.target_entity = ::std::option::Option::Some(v);
            }

            // optional uint32 target_x = 4;

            pub fn target_x(&self) -> u32 {
                self.target_x.unwrap_or(0)
            }

            pub fn clear_target_x(&mut self) {
                self.target_x = ::std::option::Option::None;
            }

            pub fn has_target_x(&self) -> bool {
                self.target_x.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_x(&mut self, v: u32) {
                self.target_x = ::std::option::Option::Some(v);
            }

            // optional uint32 target_y = 5;

            pub fn target_y(&self) -> u32 {
                self.target_y.unwrap_or(0)
            }

            pub fn clear_target_y(&mut self) {
                self.target_y = ::std::option::Option::None;
            }

            pub fn has_target_y(&self) -> bool {
                self.target_y.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_y(&mut self, v: u32) {
                self.target_y = ::std::option::Option::Some(v);
            }

            // optional uint32 target_z = 6;

            pub fn target_z(&self) -> u32 {
                self.target_z.unwrap_or(0)
            }

            pub fn clear_target_z(&mut self) {
                self.target_z = ::std::option::Option::None;
            }

            pub fn has_target_z(&self) -> bool {
                self.target_z.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_z(&mut self, v: u32) {
                self.target_z = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "mode_id",
                    |m: &Mode| { &m.mode_id },
                    |m: &mut Mode| { &mut m.mode_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "desire",
                    |m: &Mode| { &m.desire },
                    |m: &mut Mode| { &mut m.desire },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "target_entity",
                    |m: &Mode| { &m.target_entity },
                    |m: &mut Mode| { &mut m.target_entity },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "target_x",
                    |m: &Mode| { &m.target_x },
                    |m: &mut Mode| { &mut m.target_x },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "target_y",
                    |m: &Mode| { &m.target_y },
                    |m: &mut Mode| { &mut m.target_y },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "target_z",
                    |m: &Mode| { &m.target_z },
                    |m: &mut Mode| { &mut m.target_z },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Mode>(
                    "CMsgDOTABotDebugInfo.Bot.Mode",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Mode {
            const NAME: &'static str = "Mode";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.mode_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        21 => {
                            self.desire = ::std::option::Option::Some(is.read_float()?);
                        },
                        24 => {
                            self.target_entity = ::std::option::Option::Some(is.read_int32()?);
                        },
                        32 => {
                            self.target_x = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.target_y = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.target_z = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.mode_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.desire {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.target_entity {
                    my_size += ::protobuf::rt::int32_size(3, v);
                }
                if let Some(v) = self.target_x {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.target_y {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.target_z {
                    my_size += ::protobuf::rt::uint32_size(6, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.mode_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.desire {
                    os.write_float(2, v)?;
                }
                if let Some(v) = self.target_entity {
                    os.write_int32(3, v)?;
                }
                if let Some(v) = self.target_x {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.target_y {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.target_z {
                    os.write_uint32(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Mode {
                Mode::new()
            }

            fn clear(&mut self) {
                self.mode_id = ::std::option::Option::None;
                self.desire = ::std::option::Option::None;
                self.target_entity = ::std::option::Option::None;
                self.target_x = ::std::option::Option::None;
                self.target_y = ::std::option::Option::None;
                self.target_z = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Mode {
                static instance: Mode = Mode {
                    mode_id: ::std::option::Option::None,
                    desire: ::std::option::Option::None,
                    target_entity: ::std::option::Option::None,
                    target_x: ::std::option::Option::None,
                    target_y: ::std::option::Option::None,
                    target_z: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Mode {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTABotDebugInfo.Bot.Mode").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Mode {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Mode {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:dota.CMsgDOTABotDebugInfo.Bot.Action)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Action {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.Action.action_id)
            pub action_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgDOTABotDebugInfo.Bot.Action.action_target)
            pub action_target: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgDOTABotDebugInfo.Bot.Action.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Action {
            fn default() -> &'a Action {
                <Action as ::protobuf::Message>::default_instance()
            }
        }

        impl Action {
            pub fn new() -> Action {
                ::std::default::Default::default()
            }

            // optional uint32 action_id = 1;

            pub fn action_id(&self) -> u32 {
                self.action_id.unwrap_or(0)
            }

            pub fn clear_action_id(&mut self) {
                self.action_id = ::std::option::Option::None;
            }

            pub fn has_action_id(&self) -> bool {
                self.action_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_action_id(&mut self, v: u32) {
                self.action_id = ::std::option::Option::Some(v);
            }

            // optional string action_target = 2;

            pub fn action_target(&self) -> &str {
                match self.action_target.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_action_target(&mut self) {
                self.action_target = ::std::option::Option::None;
            }

            pub fn has_action_target(&self) -> bool {
                self.action_target.is_some()
            }

            // Param is passed by value, moved
            pub fn set_action_target(&mut self, v: ::std::string::String) {
                self.action_target = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_action_target(&mut self) -> &mut ::std::string::String {
                if self.action_target.is_none() {
                    self.action_target = ::std::option::Option::Some(::std::string::String::new());
                }
                self.action_target.as_mut().unwrap()
            }

            // Take field
            pub fn take_action_target(&mut self) -> ::std::string::String {
                self.action_target.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "action_id",
                    |m: &Action| { &m.action_id },
                    |m: &mut Action| { &mut m.action_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "action_target",
                    |m: &Action| { &m.action_target },
                    |m: &mut Action| { &mut m.action_target },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Action>(
                    "CMsgDOTABotDebugInfo.Bot.Action",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Action {
            const NAME: &'static str = "Action";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            self.action_target = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.action_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.action_target.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.action_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.action_target.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Action {
                Action::new()
            }

            fn clear(&mut self) {
                self.action_id = ::std::option::Option::None;
                self.action_target = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Action {
                static instance: Action = Action {
                    action_id: ::std::option::Option::None,
                    action_target: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Action {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgDOTABotDebugInfo.Bot.Action").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Action {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Action {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgSuccessfulHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSuccessfulHero {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSuccessfulHero.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSuccessfulHero.win_percent)
    pub win_percent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgSuccessfulHero.longest_streak)
    pub longest_streak: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSuccessfulHero.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSuccessfulHero {
    fn default() -> &'a CMsgSuccessfulHero {
        <CMsgSuccessfulHero as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSuccessfulHero {
    pub fn new() -> CMsgSuccessfulHero {
        ::std::default::Default::default()
    }

    // optional uint32 hero_id = 1;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional float win_percent = 2;

    pub fn win_percent(&self) -> f32 {
        self.win_percent.unwrap_or(0.)
    }

    pub fn clear_win_percent(&mut self) {
        self.win_percent = ::std::option::Option::None;
    }

    pub fn has_win_percent(&self) -> bool {
        self.win_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_percent(&mut self, v: f32) {
        self.win_percent = ::std::option::Option::Some(v);
    }

    // optional uint32 longest_streak = 3;

    pub fn longest_streak(&self) -> u32 {
        self.longest_streak.unwrap_or(0)
    }

    pub fn clear_longest_streak(&mut self) {
        self.longest_streak = ::std::option::Option::None;
    }

    pub fn has_longest_streak(&self) -> bool {
        self.longest_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_longest_streak(&mut self, v: u32) {
        self.longest_streak = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgSuccessfulHero| { &m.hero_id },
            |m: &mut CMsgSuccessfulHero| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "win_percent",
            |m: &CMsgSuccessfulHero| { &m.win_percent },
            |m: &mut CMsgSuccessfulHero| { &mut m.win_percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "longest_streak",
            |m: &CMsgSuccessfulHero| { &m.longest_streak },
            |m: &mut CMsgSuccessfulHero| { &mut m.longest_streak },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSuccessfulHero>(
            "CMsgSuccessfulHero",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSuccessfulHero {
    const NAME: &'static str = "CMsgSuccessfulHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.win_percent = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.longest_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.win_percent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.longest_streak {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.win_percent {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.longest_streak {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSuccessfulHero {
        CMsgSuccessfulHero::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.win_percent = ::std::option::Option::None;
        self.longest_streak = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSuccessfulHero {
        static instance: CMsgSuccessfulHero = CMsgSuccessfulHero {
            hero_id: ::std::option::Option::None,
            win_percent: ::std::option::Option::None,
            longest_streak: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSuccessfulHero {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSuccessfulHero").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSuccessfulHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSuccessfulHero {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgRecentMatchInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRecentMatchInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.game_mode)
    pub game_mode: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.assists)
    pub assists: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.player_slot)
    pub player_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.match_outcome)
    pub match_outcome: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchOutcome>>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgRecentMatchInfo.team_number)
    pub team_number: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgRecentMatchInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRecentMatchInfo {
    fn default() -> &'a CMsgRecentMatchInfo {
        <CMsgRecentMatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRecentMatchInfo {
    pub fn new() -> CMsgRecentMatchInfo {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GameMode game_mode = 2;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 kills = 3;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 4;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 5;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 6;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 player_slot = 7;

    pub fn player_slot(&self) -> u32 {
        self.player_slot.unwrap_or(0)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: u32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional .dota.EMatchOutcome match_outcome = 8;

    pub fn match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        match self.match_outcome {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown),
            None => super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown,
        }
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 9;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 10;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional uint32 team_number = 11;

    pub fn team_number(&self) -> u32 {
        self.team_number.unwrap_or(0)
    }

    pub fn clear_team_number(&mut self) {
        self.team_number = ::std::option::Option::None;
    }

    pub fn has_team_number(&self) -> bool {
        self.team_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_number(&mut self, v: u32) {
        self.team_number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgRecentMatchInfo| { &m.match_id },
            |m: &mut CMsgRecentMatchInfo| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgRecentMatchInfo| { &m.game_mode },
            |m: &mut CMsgRecentMatchInfo| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills",
            |m: &CMsgRecentMatchInfo| { &m.kills },
            |m: &mut CMsgRecentMatchInfo| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaths",
            |m: &CMsgRecentMatchInfo| { &m.deaths },
            |m: &mut CMsgRecentMatchInfo| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assists",
            |m: &CMsgRecentMatchInfo| { &m.assists },
            |m: &mut CMsgRecentMatchInfo| { &mut m.assists },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgRecentMatchInfo| { &m.duration },
            |m: &mut CMsgRecentMatchInfo| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CMsgRecentMatchInfo| { &m.player_slot },
            |m: &mut CMsgRecentMatchInfo| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_outcome",
            |m: &CMsgRecentMatchInfo| { &m.match_outcome },
            |m: &mut CMsgRecentMatchInfo| { &mut m.match_outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgRecentMatchInfo| { &m.timestamp },
            |m: &mut CMsgRecentMatchInfo| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgRecentMatchInfo| { &m.lobby_type },
            |m: &mut CMsgRecentMatchInfo| { &mut m.lobby_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_number",
            |m: &CMsgRecentMatchInfo| { &m.team_number },
            |m: &mut CMsgRecentMatchInfo| { &mut m.team_number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRecentMatchInfo>(
            "CMsgRecentMatchInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRecentMatchInfo {
    const NAME: &'static str = "CMsgRecentMatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.team_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.match_outcome {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.team_number {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.team_number {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRecentMatchInfo {
        CMsgRecentMatchInfo::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.match_outcome = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.team_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRecentMatchInfo {
        static instance: CMsgRecentMatchInfo = CMsgRecentMatchInfo {
            match_id: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            match_outcome: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            team_number: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRecentMatchInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRecentMatchInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRecentMatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRecentMatchInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgMatchTips)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchTips {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgMatchTips.tips)
    pub tips: ::std::vec::Vec<cmsg_match_tips::SingleTip>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgMatchTips.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchTips {
    fn default() -> &'a CMsgMatchTips {
        <CMsgMatchTips as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchTips {
    pub fn new() -> CMsgMatchTips {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tips",
            |m: &CMsgMatchTips| { &m.tips },
            |m: &mut CMsgMatchTips| { &mut m.tips },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMatchTips>(
            "CMsgMatchTips",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMatchTips {
    const NAME: &'static str = "CMsgMatchTips";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.tips.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tips {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchTips {
        CMsgMatchTips::new()
    }

    fn clear(&mut self) {
        self.tips.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchTips {
        static instance: CMsgMatchTips = CMsgMatchTips {
            tips: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMatchTips {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMatchTips").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMatchTips {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchTips {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgMatchTips`
pub mod cmsg_match_tips {
    // @@protoc_insertion_point(message:dota.CMsgMatchTips.SingleTip)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleTip {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgMatchTips.SingleTip.source_account_id)
        pub source_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgMatchTips.SingleTip.target_account_id)
        pub target_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgMatchTips.SingleTip.tip_amount)
        pub tip_amount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgMatchTips.SingleTip.event_id)
        pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgMatchTips.SingleTip.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleTip {
        fn default() -> &'a SingleTip {
            <SingleTip as ::protobuf::Message>::default_instance()
        }
    }

    impl SingleTip {
        pub fn new() -> SingleTip {
            ::std::default::Default::default()
        }

        // optional uint32 source_account_id = 1;

        pub fn source_account_id(&self) -> u32 {
            self.source_account_id.unwrap_or(0)
        }

        pub fn clear_source_account_id(&mut self) {
            self.source_account_id = ::std::option::Option::None;
        }

        pub fn has_source_account_id(&self) -> bool {
            self.source_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_account_id(&mut self, v: u32) {
            self.source_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 target_account_id = 2;

        pub fn target_account_id(&self) -> u32 {
            self.target_account_id.unwrap_or(0)
        }

        pub fn clear_target_account_id(&mut self) {
            self.target_account_id = ::std::option::Option::None;
        }

        pub fn has_target_account_id(&self) -> bool {
            self.target_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_target_account_id(&mut self, v: u32) {
            self.target_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 tip_amount = 3;

        pub fn tip_amount(&self) -> u32 {
            self.tip_amount.unwrap_or(0)
        }

        pub fn clear_tip_amount(&mut self) {
            self.tip_amount = ::std::option::Option::None;
        }

        pub fn has_tip_amount(&self) -> bool {
            self.tip_amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tip_amount(&mut self, v: u32) {
            self.tip_amount = ::std::option::Option::Some(v);
        }

        // optional .dota.EEvent event_id = 4;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_account_id",
                |m: &SingleTip| { &m.source_account_id },
                |m: &mut SingleTip| { &mut m.source_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "target_account_id",
                |m: &SingleTip| { &m.target_account_id },
                |m: &mut SingleTip| { &mut m.target_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tip_amount",
                |m: &SingleTip| { &m.tip_amount },
                |m: &mut SingleTip| { &mut m.tip_amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_id",
                |m: &SingleTip| { &m.event_id },
                |m: &mut SingleTip| { &mut m.event_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleTip>(
                "CMsgMatchTips.SingleTip",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SingleTip {
        const NAME: &'static str = "SingleTip";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.source_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.tip_amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.source_account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.target_account_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.tip_amount {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.source_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.target_account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.tip_amount {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleTip {
            SingleTip::new()
        }

        fn clear(&mut self) {
            self.source_account_id = ::std::option::Option::None;
            self.target_account_id = ::std::option::Option::None;
            self.tip_amount = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleTip {
            static instance: SingleTip = SingleTip {
                source_account_id: ::std::option::Option::None,
                target_account_id: ::std::option::Option::None,
                tip_amount: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SingleTip {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMatchTips.SingleTip").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SingleTip {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SingleTip {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTAMatchMinimal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAMatchMinimal {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.game_mode)
    pub game_mode: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.players)
    pub players: ::std::vec::Vec<cmsg_dotamatch_minimal::Player>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.tourney)
    pub tourney: ::protobuf::MessageField<cmsg_dotamatch_minimal::Tourney>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.match_outcome)
    pub match_outcome: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchOutcome>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.radiant_score)
    pub radiant_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.dire_score)
    pub dire_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatchMinimal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAMatchMinimal {
    fn default() -> &'a CMsgDOTAMatchMinimal {
        <CMsgDOTAMatchMinimal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAMatchMinimal {
    pub fn new() -> CMsgDOTAMatchMinimal {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 start_time = 2;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_GameMode game_mode = 4;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.EMatchOutcome match_outcome = 8;

    pub fn match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        match self.match_outcome {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown),
            None => super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown,
        }
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 radiant_score = 9;

    pub fn radiant_score(&self) -> u32 {
        self.radiant_score.unwrap_or(0)
    }

    pub fn clear_radiant_score(&mut self) {
        self.radiant_score = ::std::option::Option::None;
    }

    pub fn has_radiant_score(&self) -> bool {
        self.radiant_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_score(&mut self, v: u32) {
        self.radiant_score = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_score = 10;

    pub fn dire_score(&self) -> u32 {
        self.dire_score.unwrap_or(0)
    }

    pub fn clear_dire_score(&mut self) {
        self.dire_score = ::std::option::Option::None;
    }

    pub fn has_dire_score(&self) -> bool {
        self.dire_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_score(&mut self, v: u32) {
        self.dire_score = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 11;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgDOTAMatchMinimal| { &m.match_id },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgDOTAMatchMinimal| { &m.start_time },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgDOTAMatchMinimal| { &m.duration },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgDOTAMatchMinimal| { &m.game_mode },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgDOTAMatchMinimal| { &m.players },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotamatch_minimal::Tourney>(
            "tourney",
            |m: &CMsgDOTAMatchMinimal| { &m.tourney },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.tourney },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_outcome",
            |m: &CMsgDOTAMatchMinimal| { &m.match_outcome },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.match_outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radiant_score",
            |m: &CMsgDOTAMatchMinimal| { &m.radiant_score },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.radiant_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dire_score",
            |m: &CMsgDOTAMatchMinimal| { &m.dire_score },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.dire_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgDOTAMatchMinimal| { &m.lobby_type },
            |m: &mut CMsgDOTAMatchMinimal| { &mut m.lobby_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTAMatchMinimal>(
            "CMsgDOTAMatchMinimal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTAMatchMinimal {
    const NAME: &'static str = "CMsgDOTAMatchMinimal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.start_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.players.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tourney)?;
                },
                64 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.radiant_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.dire_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tourney.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_outcome {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.radiant_score {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.dire_score {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.tourney.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radiant_score {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.dire_score {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAMatchMinimal {
        CMsgDOTAMatchMinimal::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.players.clear();
        self.tourney.clear();
        self.match_outcome = ::std::option::Option::None;
        self.radiant_score = ::std::option::Option::None;
        self.dire_score = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAMatchMinimal {
        static instance: CMsgDOTAMatchMinimal = CMsgDOTAMatchMinimal {
            match_id: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            tourney: ::protobuf::MessageField::none(),
            match_outcome: ::std::option::Option::None,
            radiant_score: ::std::option::Option::None,
            dire_score: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTAMatchMinimal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTAMatchMinimal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTAMatchMinimal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatchMinimal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTAMatchMinimal`
pub mod cmsg_dotamatch_minimal {
    // @@protoc_insertion_point(message:dota.CMsgDOTAMatchMinimal.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.assists)
        pub assists: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.items)
        pub items: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.pro_name)
        pub pro_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Player.team_number)
        pub team_number: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::DOTA_GC_TEAM>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatchMinimal.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 2;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 3;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 4;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 assists = 5;

        pub fn assists(&self) -> u32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: u32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional uint32 player_slot = 7;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional string pro_name = 8;

        pub fn pro_name(&self) -> &str {
            match self.pro_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_pro_name(&mut self) {
            self.pro_name = ::std::option::Option::None;
        }

        pub fn has_pro_name(&self) -> bool {
            self.pro_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pro_name(&mut self, v: ::std::string::String) {
            self.pro_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_pro_name(&mut self) -> &mut ::std::string::String {
            if self.pro_name.is_none() {
                self.pro_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.pro_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_pro_name(&mut self) -> ::std::string::String {
            self.pro_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 level = 9;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional .dota.DOTA_GC_TEAM team_number = 10;

        pub fn team_number(&self) -> super::super::dota_shared_enums::DOTA_GC_TEAM {
            match self.team_number {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                None => super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
            }
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: super::super::dota_shared_enums::DOTA_GC_TEAM) {
            self.team_number = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &Player| { &m.hero_id },
                |m: &mut Player| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "kills",
                |m: &Player| { &m.kills },
                |m: &mut Player| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deaths",
                |m: &Player| { &m.deaths },
                |m: &mut Player| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "assists",
                |m: &Player| { &m.assists },
                |m: &mut Player| { &mut m.assists },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "items",
                |m: &Player| { &m.items },
                |m: &mut Player| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_slot",
                |m: &Player| { &m.player_slot },
                |m: &mut Player| { &mut m.player_slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pro_name",
                |m: &Player| { &m.pro_name },
                |m: &mut Player| { &mut m.pro_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &Player| { &m.level },
                |m: &mut Player| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_number",
                |m: &Player| { &m.team_number },
                |m: &mut Player| { &mut m.team_number },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgDOTAMatchMinimal.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        is.read_repeated_packed_int32_into(&mut self.items)?;
                    },
                    48 => {
                        self.items.push(is.read_int32()?);
                    },
                    56 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.pro_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.kills {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.assists {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            for value in &self.items {
                my_size += ::protobuf::rt::int32_size(6, *value);
            };
            if let Some(v) = self.player_slot {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.pro_name.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.team_number {
                my_size += ::protobuf::rt::int32_size(10, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.assists {
                os.write_uint32(5, v)?;
            }
            for v in &self.items {
                os.write_int32(6, *v)?;
            };
            if let Some(v) = self.player_slot {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.pro_name.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.team_number {
                os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.items.clear();
            self.player_slot = ::std::option::Option::None;
            self.pro_name = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.team_number = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                items: ::std::vec::Vec::new(),
                player_slot: ::std::option::Option::None,
                pro_name: ::std::option::Option::None,
                level: ::std::option::Option::None,
                team_number: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAMatchMinimal.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTAMatchMinimal.Tourney)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tourney {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.series_type)
        pub series_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.series_game)
        pub series_game: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.weekend_tourney_tournament_id)
        pub weekend_tourney_tournament_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.weekend_tourney_season_trophy_id)
        pub weekend_tourney_season_trophy_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.weekend_tourney_division)
        pub weekend_tourney_division: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.weekend_tourney_skill_level)
        pub weekend_tourney_skill_level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.radiant_team_id)
        pub radiant_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.radiant_team_name)
        pub radiant_team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.radiant_team_logo)
        pub radiant_team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.radiant_team_logo_url)
        pub radiant_team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.dire_team_id)
        pub dire_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.dire_team_name)
        pub dire_team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.dire_team_logo)
        pub dire_team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTAMatchMinimal.Tourney.dire_team_logo_url)
        pub dire_team_logo_url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTAMatchMinimal.Tourney.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tourney {
        fn default() -> &'a Tourney {
            <Tourney as ::protobuf::Message>::default_instance()
        }
    }

    impl Tourney {
        pub fn new() -> Tourney {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 series_type = 8;

        pub fn series_type(&self) -> u32 {
            self.series_type.unwrap_or(0)
        }

        pub fn clear_series_type(&mut self) {
            self.series_type = ::std::option::Option::None;
        }

        pub fn has_series_type(&self) -> bool {
            self.series_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_type(&mut self, v: u32) {
            self.series_type = ::std::option::Option::Some(v);
        }

        // optional uint32 series_game = 9;

        pub fn series_game(&self) -> u32 {
            self.series_game.unwrap_or(0)
        }

        pub fn clear_series_game(&mut self) {
            self.series_game = ::std::option::Option::None;
        }

        pub fn has_series_game(&self) -> bool {
            self.series_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_game(&mut self, v: u32) {
            self.series_game = ::std::option::Option::Some(v);
        }

        // optional uint32 weekend_tourney_tournament_id = 10;

        pub fn weekend_tourney_tournament_id(&self) -> u32 {
            self.weekend_tourney_tournament_id.unwrap_or(0)
        }

        pub fn clear_weekend_tourney_tournament_id(&mut self) {
            self.weekend_tourney_tournament_id = ::std::option::Option::None;
        }

        pub fn has_weekend_tourney_tournament_id(&self) -> bool {
            self.weekend_tourney_tournament_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weekend_tourney_tournament_id(&mut self, v: u32) {
            self.weekend_tourney_tournament_id = ::std::option::Option::Some(v);
        }

        // optional uint32 weekend_tourney_season_trophy_id = 11;

        pub fn weekend_tourney_season_trophy_id(&self) -> u32 {
            self.weekend_tourney_season_trophy_id.unwrap_or(0)
        }

        pub fn clear_weekend_tourney_season_trophy_id(&mut self) {
            self.weekend_tourney_season_trophy_id = ::std::option::Option::None;
        }

        pub fn has_weekend_tourney_season_trophy_id(&self) -> bool {
            self.weekend_tourney_season_trophy_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weekend_tourney_season_trophy_id(&mut self, v: u32) {
            self.weekend_tourney_season_trophy_id = ::std::option::Option::Some(v);
        }

        // optional uint32 weekend_tourney_division = 12;

        pub fn weekend_tourney_division(&self) -> u32 {
            self.weekend_tourney_division.unwrap_or(0)
        }

        pub fn clear_weekend_tourney_division(&mut self) {
            self.weekend_tourney_division = ::std::option::Option::None;
        }

        pub fn has_weekend_tourney_division(&self) -> bool {
            self.weekend_tourney_division.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weekend_tourney_division(&mut self, v: u32) {
            self.weekend_tourney_division = ::std::option::Option::Some(v);
        }

        // optional uint32 weekend_tourney_skill_level = 13;

        pub fn weekend_tourney_skill_level(&self) -> u32 {
            self.weekend_tourney_skill_level.unwrap_or(0)
        }

        pub fn clear_weekend_tourney_skill_level(&mut self) {
            self.weekend_tourney_skill_level = ::std::option::Option::None;
        }

        pub fn has_weekend_tourney_skill_level(&self) -> bool {
            self.weekend_tourney_skill_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weekend_tourney_skill_level(&mut self, v: u32) {
            self.weekend_tourney_skill_level = ::std::option::Option::Some(v);
        }

        // optional uint32 radiant_team_id = 2;

        pub fn radiant_team_id(&self) -> u32 {
            self.radiant_team_id.unwrap_or(0)
        }

        pub fn clear_radiant_team_id(&mut self) {
            self.radiant_team_id = ::std::option::Option::None;
        }

        pub fn has_radiant_team_id(&self) -> bool {
            self.radiant_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_id(&mut self, v: u32) {
            self.radiant_team_id = ::std::option::Option::Some(v);
        }

        // optional string radiant_team_name = 3;

        pub fn radiant_team_name(&self) -> &str {
            match self.radiant_team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_radiant_team_name(&mut self) {
            self.radiant_team_name = ::std::option::Option::None;
        }

        pub fn has_radiant_team_name(&self) -> bool {
            self.radiant_team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_name(&mut self, v: ::std::string::String) {
            self.radiant_team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_radiant_team_name(&mut self) -> &mut ::std::string::String {
            if self.radiant_team_name.is_none() {
                self.radiant_team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.radiant_team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_radiant_team_name(&mut self) -> ::std::string::String {
            self.radiant_team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 radiant_team_logo = 4;

        pub fn radiant_team_logo(&self) -> u64 {
            self.radiant_team_logo.unwrap_or(0)
        }

        pub fn clear_radiant_team_logo(&mut self) {
            self.radiant_team_logo = ::std::option::Option::None;
        }

        pub fn has_radiant_team_logo(&self) -> bool {
            self.radiant_team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_logo(&mut self, v: u64) {
            self.radiant_team_logo = ::std::option::Option::Some(v);
        }

        // optional string radiant_team_logo_url = 14;

        pub fn radiant_team_logo_url(&self) -> &str {
            match self.radiant_team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_radiant_team_logo_url(&mut self) {
            self.radiant_team_logo_url = ::std::option::Option::None;
        }

        pub fn has_radiant_team_logo_url(&self) -> bool {
            self.radiant_team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_logo_url(&mut self, v: ::std::string::String) {
            self.radiant_team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_radiant_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.radiant_team_logo_url.is_none() {
                self.radiant_team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.radiant_team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_radiant_team_logo_url(&mut self) -> ::std::string::String {
            self.radiant_team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 dire_team_id = 5;

        pub fn dire_team_id(&self) -> u32 {
            self.dire_team_id.unwrap_or(0)
        }

        pub fn clear_dire_team_id(&mut self) {
            self.dire_team_id = ::std::option::Option::None;
        }

        pub fn has_dire_team_id(&self) -> bool {
            self.dire_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_id(&mut self, v: u32) {
            self.dire_team_id = ::std::option::Option::Some(v);
        }

        // optional string dire_team_name = 6;

        pub fn dire_team_name(&self) -> &str {
            match self.dire_team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dire_team_name(&mut self) {
            self.dire_team_name = ::std::option::Option::None;
        }

        pub fn has_dire_team_name(&self) -> bool {
            self.dire_team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_name(&mut self, v: ::std::string::String) {
            self.dire_team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dire_team_name(&mut self) -> &mut ::std::string::String {
            if self.dire_team_name.is_none() {
                self.dire_team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dire_team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_dire_team_name(&mut self) -> ::std::string::String {
            self.dire_team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 dire_team_logo = 7;

        pub fn dire_team_logo(&self) -> u64 {
            self.dire_team_logo.unwrap_or(0)
        }

        pub fn clear_dire_team_logo(&mut self) {
            self.dire_team_logo = ::std::option::Option::None;
        }

        pub fn has_dire_team_logo(&self) -> bool {
            self.dire_team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_logo(&mut self, v: u64) {
            self.dire_team_logo = ::std::option::Option::Some(v);
        }

        // optional string dire_team_logo_url = 15;

        pub fn dire_team_logo_url(&self) -> &str {
            match self.dire_team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dire_team_logo_url(&mut self) {
            self.dire_team_logo_url = ::std::option::Option::None;
        }

        pub fn has_dire_team_logo_url(&self) -> bool {
            self.dire_team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_logo_url(&mut self, v: ::std::string::String) {
            self.dire_team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dire_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.dire_team_logo_url.is_none() {
                self.dire_team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dire_team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_dire_team_logo_url(&mut self) -> ::std::string::String {
            self.dire_team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(15);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &Tourney| { &m.league_id },
                |m: &mut Tourney| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "series_type",
                |m: &Tourney| { &m.series_type },
                |m: &mut Tourney| { &mut m.series_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "series_game",
                |m: &Tourney| { &m.series_game },
                |m: &mut Tourney| { &mut m.series_game },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "weekend_tourney_tournament_id",
                |m: &Tourney| { &m.weekend_tourney_tournament_id },
                |m: &mut Tourney| { &mut m.weekend_tourney_tournament_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "weekend_tourney_season_trophy_id",
                |m: &Tourney| { &m.weekend_tourney_season_trophy_id },
                |m: &mut Tourney| { &mut m.weekend_tourney_season_trophy_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "weekend_tourney_division",
                |m: &Tourney| { &m.weekend_tourney_division },
                |m: &mut Tourney| { &mut m.weekend_tourney_division },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "weekend_tourney_skill_level",
                |m: &Tourney| { &m.weekend_tourney_skill_level },
                |m: &mut Tourney| { &mut m.weekend_tourney_skill_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radiant_team_id",
                |m: &Tourney| { &m.radiant_team_id },
                |m: &mut Tourney| { &mut m.radiant_team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radiant_team_name",
                |m: &Tourney| { &m.radiant_team_name },
                |m: &mut Tourney| { &mut m.radiant_team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radiant_team_logo",
                |m: &Tourney| { &m.radiant_team_logo },
                |m: &mut Tourney| { &mut m.radiant_team_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radiant_team_logo_url",
                |m: &Tourney| { &m.radiant_team_logo_url },
                |m: &mut Tourney| { &mut m.radiant_team_logo_url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dire_team_id",
                |m: &Tourney| { &m.dire_team_id },
                |m: &mut Tourney| { &mut m.dire_team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dire_team_name",
                |m: &Tourney| { &m.dire_team_name },
                |m: &mut Tourney| { &mut m.dire_team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dire_team_logo",
                |m: &Tourney| { &m.dire_team_logo },
                |m: &mut Tourney| { &mut m.dire_team_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dire_team_logo_url",
                |m: &Tourney| { &m.dire_team_logo_url },
                |m: &mut Tourney| { &mut m.dire_team_logo_url },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tourney>(
                "CMsgDOTAMatchMinimal.Tourney",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Tourney {
        const NAME: &'static str = "Tourney";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.series_game = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.weekend_tourney_tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.weekend_tourney_season_trophy_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.weekend_tourney_division = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.weekend_tourney_skill_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.radiant_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.radiant_team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.radiant_team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    114 => {
                        self.radiant_team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.dire_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.dire_team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    57 => {
                        self.dire_team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    122 => {
                        self.dire_team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.series_type {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.series_game {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.weekend_tourney_tournament_id {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.weekend_tourney_season_trophy_id {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.weekend_tourney_division {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.weekend_tourney_skill_level {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.radiant_team_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.radiant_team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.radiant_team_logo {
                my_size += 1 + 8;
            }
            if let Some(v) = self.radiant_team_logo_url.as_ref() {
                my_size += ::protobuf::rt::string_size(14, &v);
            }
            if let Some(v) = self.dire_team_id {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.dire_team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.dire_team_logo {
                my_size += 1 + 8;
            }
            if let Some(v) = self.dire_team_logo_url.as_ref() {
                my_size += ::protobuf::rt::string_size(15, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.series_type {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.series_game {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.weekend_tourney_tournament_id {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.weekend_tourney_season_trophy_id {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.weekend_tourney_division {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.weekend_tourney_skill_level {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.radiant_team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.radiant_team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.radiant_team_logo {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.radiant_team_logo_url.as_ref() {
                os.write_string(14, v)?;
            }
            if let Some(v) = self.dire_team_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.dire_team_name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.dire_team_logo {
                os.write_fixed64(7, v)?;
            }
            if let Some(v) = self.dire_team_logo_url.as_ref() {
                os.write_string(15, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tourney {
            Tourney::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.series_type = ::std::option::Option::None;
            self.series_game = ::std::option::Option::None;
            self.weekend_tourney_tournament_id = ::std::option::Option::None;
            self.weekend_tourney_season_trophy_id = ::std::option::Option::None;
            self.weekend_tourney_division = ::std::option::Option::None;
            self.weekend_tourney_skill_level = ::std::option::Option::None;
            self.radiant_team_id = ::std::option::Option::None;
            self.radiant_team_name = ::std::option::Option::None;
            self.radiant_team_logo = ::std::option::Option::None;
            self.radiant_team_logo_url = ::std::option::Option::None;
            self.dire_team_id = ::std::option::Option::None;
            self.dire_team_name = ::std::option::Option::None;
            self.dire_team_logo = ::std::option::Option::None;
            self.dire_team_logo_url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tourney {
            static instance: Tourney = Tourney {
                league_id: ::std::option::Option::None,
                series_type: ::std::option::Option::None,
                series_game: ::std::option::Option::None,
                weekend_tourney_tournament_id: ::std::option::Option::None,
                weekend_tourney_season_trophy_id: ::std::option::Option::None,
                weekend_tourney_division: ::std::option::Option::None,
                weekend_tourney_skill_level: ::std::option::Option::None,
                radiant_team_id: ::std::option::Option::None,
                radiant_team_name: ::std::option::Option::None,
                radiant_team_logo: ::std::option::Option::None,
                radiant_team_logo_url: ::std::option::Option::None,
                dire_team_id: ::std::option::Option::None,
                dire_team_name: ::std::option::Option::None,
                dire_team_logo: ::std::option::Option::None,
                dire_team_logo_url: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Tourney {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTAMatchMinimal.Tourney").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tourney {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Tourney {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgConsumableUsage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConsumableUsage {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgConsumableUsage.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgConsumableUsage.quantity_change)
    pub quantity_change: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgConsumableUsage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConsumableUsage {
    fn default() -> &'a CMsgConsumableUsage {
        <CMsgConsumableUsage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumableUsage {
    pub fn new() -> CMsgConsumableUsage {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional int32 quantity_change = 2;

    pub fn quantity_change(&self) -> i32 {
        self.quantity_change.unwrap_or(0)
    }

    pub fn clear_quantity_change(&mut self) {
        self.quantity_change = ::std::option::Option::None;
    }

    pub fn has_quantity_change(&self) -> bool {
        self.quantity_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity_change(&mut self, v: i32) {
        self.quantity_change = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def",
            |m: &CMsgConsumableUsage| { &m.item_def },
            |m: &mut CMsgConsumableUsage| { &mut m.item_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity_change",
            |m: &CMsgConsumableUsage| { &m.quantity_change },
            |m: &mut CMsgConsumableUsage| { &mut m.quantity_change },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConsumableUsage>(
            "CMsgConsumableUsage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConsumableUsage {
    const NAME: &'static str = "CMsgConsumableUsage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity_change = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity_change {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity_change {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConsumableUsage {
        CMsgConsumableUsage::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.quantity_change = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConsumableUsage {
        static instance: CMsgConsumableUsage = CMsgConsumableUsage {
            item_def: ::std::option::Option::None,
            quantity_change: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConsumableUsage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConsumableUsage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConsumableUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConsumableUsage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgMatchConsumableUsage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchConsumableUsage {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgMatchConsumableUsage.player_consumables_used)
    pub player_consumables_used: ::std::vec::Vec<cmsg_match_consumable_usage::PlayerUsage>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgMatchConsumableUsage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchConsumableUsage {
    fn default() -> &'a CMsgMatchConsumableUsage {
        <CMsgMatchConsumableUsage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchConsumableUsage {
    pub fn new() -> CMsgMatchConsumableUsage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_consumables_used",
            |m: &CMsgMatchConsumableUsage| { &m.player_consumables_used },
            |m: &mut CMsgMatchConsumableUsage| { &mut m.player_consumables_used },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMatchConsumableUsage>(
            "CMsgMatchConsumableUsage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMatchConsumableUsage {
    const NAME: &'static str = "CMsgMatchConsumableUsage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_consumables_used.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_consumables_used {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_consumables_used {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchConsumableUsage {
        CMsgMatchConsumableUsage::new()
    }

    fn clear(&mut self) {
        self.player_consumables_used.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchConsumableUsage {
        static instance: CMsgMatchConsumableUsage = CMsgMatchConsumableUsage {
            player_consumables_used: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMatchConsumableUsage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMatchConsumableUsage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMatchConsumableUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchConsumableUsage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgMatchConsumableUsage`
pub mod cmsg_match_consumable_usage {
    // @@protoc_insertion_point(message:dota.CMsgMatchConsumableUsage.PlayerUsage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerUsage {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgMatchConsumableUsage.PlayerUsage.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgMatchConsumableUsage.PlayerUsage.consumables_used)
        pub consumables_used: ::std::vec::Vec<super::CMsgConsumableUsage>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgMatchConsumableUsage.PlayerUsage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerUsage {
        fn default() -> &'a PlayerUsage {
            <PlayerUsage as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerUsage {
        pub fn new() -> PlayerUsage {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PlayerUsage| { &m.account_id },
                |m: &mut PlayerUsage| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "consumables_used",
                |m: &PlayerUsage| { &m.consumables_used },
                |m: &mut PlayerUsage| { &mut m.consumables_used },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerUsage>(
                "CMsgMatchConsumableUsage.PlayerUsage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerUsage {
        const NAME: &'static str = "PlayerUsage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.consumables_used.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.consumables_used {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.consumables_used {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerUsage {
            PlayerUsage::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.consumables_used.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerUsage {
            static instance: PlayerUsage = PlayerUsage {
                account_id: ::std::option::Option::None,
                consumables_used: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerUsage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMatchConsumableUsage.PlayerUsage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerUsage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerUsage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgMatchEventActionGrants)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchEventActionGrants {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgMatchEventActionGrants.player_grants)
    pub player_grants: ::std::vec::Vec<cmsg_match_event_action_grants::PlayerGrants>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgMatchEventActionGrants.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchEventActionGrants {
    fn default() -> &'a CMsgMatchEventActionGrants {
        <CMsgMatchEventActionGrants as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchEventActionGrants {
    pub fn new() -> CMsgMatchEventActionGrants {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_grants",
            |m: &CMsgMatchEventActionGrants| { &m.player_grants },
            |m: &mut CMsgMatchEventActionGrants| { &mut m.player_grants },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMatchEventActionGrants>(
            "CMsgMatchEventActionGrants",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMatchEventActionGrants {
    const NAME: &'static str = "CMsgMatchEventActionGrants";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_grants.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_grants {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_grants {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchEventActionGrants {
        CMsgMatchEventActionGrants::new()
    }

    fn clear(&mut self) {
        self.player_grants.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchEventActionGrants {
        static instance: CMsgMatchEventActionGrants = CMsgMatchEventActionGrants {
            player_grants: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMatchEventActionGrants {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMatchEventActionGrants").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMatchEventActionGrants {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchEventActionGrants {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgMatchEventActionGrants`
pub mod cmsg_match_event_action_grants {
    // @@protoc_insertion_point(message:dota.CMsgMatchEventActionGrants.PlayerGrants)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerGrants {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgMatchEventActionGrants.PlayerGrants.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgMatchEventActionGrants.PlayerGrants.actions_granted)
        pub actions_granted: ::std::vec::Vec<super::super::dota_shared_enums::CMsgPendingEventAward>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgMatchEventActionGrants.PlayerGrants.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerGrants {
        fn default() -> &'a PlayerGrants {
            <PlayerGrants as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerGrants {
        pub fn new() -> PlayerGrants {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PlayerGrants| { &m.account_id },
                |m: &mut PlayerGrants| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "actions_granted",
                |m: &PlayerGrants| { &m.actions_granted },
                |m: &mut PlayerGrants| { &mut m.actions_granted },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerGrants>(
                "CMsgMatchEventActionGrants.PlayerGrants",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerGrants {
        const NAME: &'static str = "PlayerGrants";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.actions_granted.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.actions_granted {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.actions_granted {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerGrants {
            PlayerGrants::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.actions_granted.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerGrants {
            static instance: PlayerGrants = PlayerGrants {
                account_id: ::std::option::Option::None,
                actions_granted: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerGrants {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMatchEventActionGrants.PlayerGrants").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerGrants {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerGrants {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgCustomGameWhitelist)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCustomGameWhitelist {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCustomGameWhitelist.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCustomGameWhitelist.custom_games_whitelist)
    pub custom_games_whitelist: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:dota.CMsgCustomGameWhitelist.disable_whitelist)
    pub disable_whitelist: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCustomGameWhitelist.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCustomGameWhitelist {
    fn default() -> &'a CMsgCustomGameWhitelist {
        <CMsgCustomGameWhitelist as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCustomGameWhitelist {
    pub fn new() -> CMsgCustomGameWhitelist {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bool disable_whitelist = 3;

    pub fn disable_whitelist(&self) -> bool {
        self.disable_whitelist.unwrap_or(false)
    }

    pub fn clear_disable_whitelist(&mut self) {
        self.disable_whitelist = ::std::option::Option::None;
    }

    pub fn has_disable_whitelist(&self) -> bool {
        self.disable_whitelist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_whitelist(&mut self, v: bool) {
        self.disable_whitelist = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgCustomGameWhitelist| { &m.version },
            |m: &mut CMsgCustomGameWhitelist| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "custom_games_whitelist",
            |m: &CMsgCustomGameWhitelist| { &m.custom_games_whitelist },
            |m: &mut CMsgCustomGameWhitelist| { &mut m.custom_games_whitelist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_whitelist",
            |m: &CMsgCustomGameWhitelist| { &m.disable_whitelist },
            |m: &mut CMsgCustomGameWhitelist| { &mut m.disable_whitelist },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCustomGameWhitelist>(
            "CMsgCustomGameWhitelist",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCustomGameWhitelist {
    const NAME: &'static str = "CMsgCustomGameWhitelist";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.custom_games_whitelist)?;
                },
                16 => {
                    self.custom_games_whitelist.push(is.read_uint64()?);
                },
                24 => {
                    self.disable_whitelist = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.custom_games_whitelist {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.disable_whitelist {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.custom_games_whitelist {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.disable_whitelist {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCustomGameWhitelist {
        CMsgCustomGameWhitelist::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.custom_games_whitelist.clear();
        self.disable_whitelist = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCustomGameWhitelist {
        static instance: CMsgCustomGameWhitelist = CMsgCustomGameWhitelist {
            version: ::std::option::Option::None,
            custom_games_whitelist: ::std::vec::Vec::new(),
            disable_whitelist: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCustomGameWhitelist {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCustomGameWhitelist").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCustomGameWhitelist {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCustomGameWhitelist {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCustomGameWhitelistForEdit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCustomGameWhitelistForEdit {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCustomGameWhitelistForEdit.whitelist_entries)
    pub whitelist_entries: ::std::vec::Vec<cmsg_custom_game_whitelist_for_edit::WhitelistEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCustomGameWhitelistForEdit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCustomGameWhitelistForEdit {
    fn default() -> &'a CMsgCustomGameWhitelistForEdit {
        <CMsgCustomGameWhitelistForEdit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCustomGameWhitelistForEdit {
    pub fn new() -> CMsgCustomGameWhitelistForEdit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "whitelist_entries",
            |m: &CMsgCustomGameWhitelistForEdit| { &m.whitelist_entries },
            |m: &mut CMsgCustomGameWhitelistForEdit| { &mut m.whitelist_entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCustomGameWhitelistForEdit>(
            "CMsgCustomGameWhitelistForEdit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCustomGameWhitelistForEdit {
    const NAME: &'static str = "CMsgCustomGameWhitelistForEdit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.whitelist_entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.whitelist_entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.whitelist_entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCustomGameWhitelistForEdit {
        CMsgCustomGameWhitelistForEdit::new()
    }

    fn clear(&mut self) {
        self.whitelist_entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCustomGameWhitelistForEdit {
        static instance: CMsgCustomGameWhitelistForEdit = CMsgCustomGameWhitelistForEdit {
            whitelist_entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCustomGameWhitelistForEdit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCustomGameWhitelistForEdit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCustomGameWhitelistForEdit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCustomGameWhitelistForEdit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCustomGameWhitelistForEdit`
pub mod cmsg_custom_game_whitelist_for_edit {
    // @@protoc_insertion_point(message:dota.CMsgCustomGameWhitelistForEdit.WhitelistEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WhitelistEntry {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgCustomGameWhitelistForEdit.WhitelistEntry.custom_game_id)
        pub custom_game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgCustomGameWhitelistForEdit.WhitelistEntry.whitelist_state)
        pub whitelist_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::ECustomGameWhitelistState>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgCustomGameWhitelistForEdit.WhitelistEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WhitelistEntry {
        fn default() -> &'a WhitelistEntry {
            <WhitelistEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl WhitelistEntry {
        pub fn new() -> WhitelistEntry {
            ::std::default::Default::default()
        }

        // optional uint64 custom_game_id = 1;

        pub fn custom_game_id(&self) -> u64 {
            self.custom_game_id.unwrap_or(0)
        }

        pub fn clear_custom_game_id(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
        }

        pub fn has_custom_game_id(&self) -> bool {
            self.custom_game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_custom_game_id(&mut self, v: u64) {
            self.custom_game_id = ::std::option::Option::Some(v);
        }

        // optional .dota.ECustomGameWhitelistState whitelist_state = 2;

        pub fn whitelist_state(&self) -> super::ECustomGameWhitelistState {
            match self.whitelist_state {
                Some(e) => e.enum_value_or(super::ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN),
                None => super::ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN,
            }
        }

        pub fn clear_whitelist_state(&mut self) {
            self.whitelist_state = ::std::option::Option::None;
        }

        pub fn has_whitelist_state(&self) -> bool {
            self.whitelist_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_whitelist_state(&mut self, v: super::ECustomGameWhitelistState) {
            self.whitelist_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "custom_game_id",
                |m: &WhitelistEntry| { &m.custom_game_id },
                |m: &mut WhitelistEntry| { &mut m.custom_game_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "whitelist_state",
                |m: &WhitelistEntry| { &m.whitelist_state },
                |m: &mut WhitelistEntry| { &mut m.whitelist_state },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WhitelistEntry>(
                "CMsgCustomGameWhitelistForEdit.WhitelistEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WhitelistEntry {
        const NAME: &'static str = "WhitelistEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.whitelist_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.custom_game_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.whitelist_state {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.custom_game_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.whitelist_state {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WhitelistEntry {
            WhitelistEntry::new()
        }

        fn clear(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
            self.whitelist_state = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WhitelistEntry {
            static instance: WhitelistEntry = WhitelistEntry {
                custom_game_id: ::std::option::Option::None,
                whitelist_state: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WhitelistEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCustomGameWhitelistForEdit.WhitelistEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WhitelistEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WhitelistEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgPlayerRecentMatchInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerRecentMatchInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchInfo.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchInfo.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchInfo.win)
    pub win: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchInfo.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchInfo.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchInfo.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchInfo.assists)
    pub assists: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPlayerRecentMatchInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerRecentMatchInfo {
    fn default() -> &'a CMsgPlayerRecentMatchInfo {
        <CMsgPlayerRecentMatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerRecentMatchInfo {
    pub fn new() -> CMsgPlayerRecentMatchInfo {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool win = 4;

    pub fn win(&self) -> bool {
        self.win.unwrap_or(false)
    }

    pub fn clear_win(&mut self) {
        self.win = ::std::option::Option::None;
    }

    pub fn has_win(&self) -> bool {
        self.win.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win(&mut self, v: bool) {
        self.win = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 5;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 6;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 7;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 8;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgPlayerRecentMatchInfo| { &m.match_id },
            |m: &mut CMsgPlayerRecentMatchInfo| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgPlayerRecentMatchInfo| { &m.timestamp },
            |m: &mut CMsgPlayerRecentMatchInfo| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgPlayerRecentMatchInfo| { &m.duration },
            |m: &mut CMsgPlayerRecentMatchInfo| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "win",
            |m: &CMsgPlayerRecentMatchInfo| { &m.win },
            |m: &mut CMsgPlayerRecentMatchInfo| { &mut m.win },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgPlayerRecentMatchInfo| { &m.hero_id },
            |m: &mut CMsgPlayerRecentMatchInfo| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills",
            |m: &CMsgPlayerRecentMatchInfo| { &m.kills },
            |m: &mut CMsgPlayerRecentMatchInfo| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaths",
            |m: &CMsgPlayerRecentMatchInfo| { &m.deaths },
            |m: &mut CMsgPlayerRecentMatchInfo| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assists",
            |m: &CMsgPlayerRecentMatchInfo| { &m.assists },
            |m: &mut CMsgPlayerRecentMatchInfo| { &mut m.assists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerRecentMatchInfo>(
            "CMsgPlayerRecentMatchInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerRecentMatchInfo {
    const NAME: &'static str = "CMsgPlayerRecentMatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.win = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.win {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.win {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerRecentMatchInfo {
        CMsgPlayerRecentMatchInfo::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.win = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerRecentMatchInfo {
        static instance: CMsgPlayerRecentMatchInfo = CMsgPlayerRecentMatchInfo {
            match_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            win: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerRecentMatchInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerRecentMatchInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerRecentMatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerRecentMatchInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPlayerMatchRecord)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerMatchRecord {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPlayerMatchRecord.wins)
    pub wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerMatchRecord.losses)
    pub losses: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPlayerMatchRecord.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerMatchRecord {
    fn default() -> &'a CMsgPlayerMatchRecord {
        <CMsgPlayerMatchRecord as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerMatchRecord {
    pub fn new() -> CMsgPlayerMatchRecord {
        ::std::default::Default::default()
    }

    // optional uint32 wins = 1;

    pub fn wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    // optional uint32 losses = 2;

    pub fn losses(&self) -> u32 {
        self.losses.unwrap_or(0)
    }

    pub fn clear_losses(&mut self) {
        self.losses = ::std::option::Option::None;
    }

    pub fn has_losses(&self) -> bool {
        self.losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losses(&mut self, v: u32) {
        self.losses = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wins",
            |m: &CMsgPlayerMatchRecord| { &m.wins },
            |m: &mut CMsgPlayerMatchRecord| { &mut m.wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "losses",
            |m: &CMsgPlayerMatchRecord| { &m.losses },
            |m: &mut CMsgPlayerMatchRecord| { &mut m.losses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerMatchRecord>(
            "CMsgPlayerMatchRecord",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerMatchRecord {
    const NAME: &'static str = "CMsgPlayerMatchRecord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.losses = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.losses {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.wins {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.losses {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerMatchRecord {
        CMsgPlayerMatchRecord::new()
    }

    fn clear(&mut self) {
        self.wins = ::std::option::Option::None;
        self.losses = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerMatchRecord {
        static instance: CMsgPlayerMatchRecord = CMsgPlayerMatchRecord {
            wins: ::std::option::Option::None,
            losses: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerMatchRecord {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerMatchRecord").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerMatchRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerMatchRecord {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPlayerRecentMatchOutcomes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerRecentMatchOutcomes {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchOutcomes.outcomes)
    pub outcomes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentMatchOutcomes.match_count)
    pub match_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPlayerRecentMatchOutcomes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerRecentMatchOutcomes {
    fn default() -> &'a CMsgPlayerRecentMatchOutcomes {
        <CMsgPlayerRecentMatchOutcomes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerRecentMatchOutcomes {
    pub fn new() -> CMsgPlayerRecentMatchOutcomes {
        ::std::default::Default::default()
    }

    // optional uint32 outcomes = 1;

    pub fn outcomes(&self) -> u32 {
        self.outcomes.unwrap_or(0)
    }

    pub fn clear_outcomes(&mut self) {
        self.outcomes = ::std::option::Option::None;
    }

    pub fn has_outcomes(&self) -> bool {
        self.outcomes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outcomes(&mut self, v: u32) {
        self.outcomes = ::std::option::Option::Some(v);
    }

    // optional uint32 match_count = 2;

    pub fn match_count(&self) -> u32 {
        self.match_count.unwrap_or(0)
    }

    pub fn clear_match_count(&mut self) {
        self.match_count = ::std::option::Option::None;
    }

    pub fn has_match_count(&self) -> bool {
        self.match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_count(&mut self, v: u32) {
        self.match_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "outcomes",
            |m: &CMsgPlayerRecentMatchOutcomes| { &m.outcomes },
            |m: &mut CMsgPlayerRecentMatchOutcomes| { &mut m.outcomes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_count",
            |m: &CMsgPlayerRecentMatchOutcomes| { &m.match_count },
            |m: &mut CMsgPlayerRecentMatchOutcomes| { &mut m.match_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerRecentMatchOutcomes>(
            "CMsgPlayerRecentMatchOutcomes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerRecentMatchOutcomes {
    const NAME: &'static str = "CMsgPlayerRecentMatchOutcomes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.outcomes = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.outcomes {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.outcomes {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerRecentMatchOutcomes {
        CMsgPlayerRecentMatchOutcomes::new()
    }

    fn clear(&mut self) {
        self.outcomes = ::std::option::Option::None;
        self.match_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerRecentMatchOutcomes {
        static instance: CMsgPlayerRecentMatchOutcomes = CMsgPlayerRecentMatchOutcomes {
            outcomes: ::std::option::Option::None,
            match_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerRecentMatchOutcomes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerRecentMatchOutcomes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerRecentMatchOutcomes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerRecentMatchOutcomes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPlayerRecentCommends)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerRecentCommends {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentCommends.commends)
    pub commends: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentCommends.match_count)
    pub match_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPlayerRecentCommends.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerRecentCommends {
    fn default() -> &'a CMsgPlayerRecentCommends {
        <CMsgPlayerRecentCommends as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerRecentCommends {
    pub fn new() -> CMsgPlayerRecentCommends {
        ::std::default::Default::default()
    }

    // optional uint32 commends = 1;

    pub fn commends(&self) -> u32 {
        self.commends.unwrap_or(0)
    }

    pub fn clear_commends(&mut self) {
        self.commends = ::std::option::Option::None;
    }

    pub fn has_commends(&self) -> bool {
        self.commends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commends(&mut self, v: u32) {
        self.commends = ::std::option::Option::Some(v);
    }

    // optional uint32 match_count = 2;

    pub fn match_count(&self) -> u32 {
        self.match_count.unwrap_or(0)
    }

    pub fn clear_match_count(&mut self) {
        self.match_count = ::std::option::Option::None;
    }

    pub fn has_match_count(&self) -> bool {
        self.match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_count(&mut self, v: u32) {
        self.match_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commends",
            |m: &CMsgPlayerRecentCommends| { &m.commends },
            |m: &mut CMsgPlayerRecentCommends| { &mut m.commends },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_count",
            |m: &CMsgPlayerRecentCommends| { &m.match_count },
            |m: &mut CMsgPlayerRecentCommends| { &mut m.match_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerRecentCommends>(
            "CMsgPlayerRecentCommends",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerRecentCommends {
    const NAME: &'static str = "CMsgPlayerRecentCommends";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.commends = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commends {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.commends {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerRecentCommends {
        CMsgPlayerRecentCommends::new()
    }

    fn clear(&mut self) {
        self.commends = ::std::option::Option::None;
        self.match_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerRecentCommends {
        static instance: CMsgPlayerRecentCommends = CMsgPlayerRecentCommends {
            commends: ::std::option::Option::None,
            match_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerRecentCommends {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerRecentCommends").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerRecentCommends {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerRecentCommends {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPlayerRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentAccomplishments.recent_outcomes)
    pub recent_outcomes: ::protobuf::MessageField<CMsgPlayerRecentMatchOutcomes>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentAccomplishments.total_record)
    pub total_record: ::protobuf::MessageField<CMsgPlayerMatchRecord>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentAccomplishments.prediction_streak)
    pub prediction_streak: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentAccomplishments.plus_prediction_streak)
    pub plus_prediction_streak: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentAccomplishments.recent_commends)
    pub recent_commends: ::protobuf::MessageField<CMsgPlayerRecentCommends>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentAccomplishments.first_match_timestamp)
    pub first_match_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentAccomplishments.last_match)
    pub last_match: ::protobuf::MessageField<CMsgPlayerRecentMatchInfo>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerRecentAccomplishments.recent_mvps)
    pub recent_mvps: ::protobuf::MessageField<CMsgPlayerRecentMatchOutcomes>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPlayerRecentAccomplishments.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerRecentAccomplishments {
    fn default() -> &'a CMsgPlayerRecentAccomplishments {
        <CMsgPlayerRecentAccomplishments as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerRecentAccomplishments {
    pub fn new() -> CMsgPlayerRecentAccomplishments {
        ::std::default::Default::default()
    }

    // optional uint32 prediction_streak = 3;

    pub fn prediction_streak(&self) -> u32 {
        self.prediction_streak.unwrap_or(0)
    }

    pub fn clear_prediction_streak(&mut self) {
        self.prediction_streak = ::std::option::Option::None;
    }

    pub fn has_prediction_streak(&self) -> bool {
        self.prediction_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_streak(&mut self, v: u32) {
        self.prediction_streak = ::std::option::Option::Some(v);
    }

    // optional uint32 plus_prediction_streak = 4;

    pub fn plus_prediction_streak(&self) -> u32 {
        self.plus_prediction_streak.unwrap_or(0)
    }

    pub fn clear_plus_prediction_streak(&mut self) {
        self.plus_prediction_streak = ::std::option::Option::None;
    }

    pub fn has_plus_prediction_streak(&self) -> bool {
        self.plus_prediction_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plus_prediction_streak(&mut self, v: u32) {
        self.plus_prediction_streak = ::std::option::Option::Some(v);
    }

    // optional uint32 first_match_timestamp = 6;

    pub fn first_match_timestamp(&self) -> u32 {
        self.first_match_timestamp.unwrap_or(0)
    }

    pub fn clear_first_match_timestamp(&mut self) {
        self.first_match_timestamp = ::std::option::Option::None;
    }

    pub fn has_first_match_timestamp(&self) -> bool {
        self.first_match_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_match_timestamp(&mut self, v: u32) {
        self.first_match_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerRecentMatchOutcomes>(
            "recent_outcomes",
            |m: &CMsgPlayerRecentAccomplishments| { &m.recent_outcomes },
            |m: &mut CMsgPlayerRecentAccomplishments| { &mut m.recent_outcomes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerMatchRecord>(
            "total_record",
            |m: &CMsgPlayerRecentAccomplishments| { &m.total_record },
            |m: &mut CMsgPlayerRecentAccomplishments| { &mut m.total_record },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prediction_streak",
            |m: &CMsgPlayerRecentAccomplishments| { &m.prediction_streak },
            |m: &mut CMsgPlayerRecentAccomplishments| { &mut m.prediction_streak },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plus_prediction_streak",
            |m: &CMsgPlayerRecentAccomplishments| { &m.plus_prediction_streak },
            |m: &mut CMsgPlayerRecentAccomplishments| { &mut m.plus_prediction_streak },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerRecentCommends>(
            "recent_commends",
            |m: &CMsgPlayerRecentAccomplishments| { &m.recent_commends },
            |m: &mut CMsgPlayerRecentAccomplishments| { &mut m.recent_commends },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_match_timestamp",
            |m: &CMsgPlayerRecentAccomplishments| { &m.first_match_timestamp },
            |m: &mut CMsgPlayerRecentAccomplishments| { &mut m.first_match_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerRecentMatchInfo>(
            "last_match",
            |m: &CMsgPlayerRecentAccomplishments| { &m.last_match },
            |m: &mut CMsgPlayerRecentAccomplishments| { &mut m.last_match },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerRecentMatchOutcomes>(
            "recent_mvps",
            |m: &CMsgPlayerRecentAccomplishments| { &m.recent_mvps },
            |m: &mut CMsgPlayerRecentAccomplishments| { &mut m.recent_mvps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerRecentAccomplishments>(
            "CMsgPlayerRecentAccomplishments",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerRecentAccomplishments {
    const NAME: &'static str = "CMsgPlayerRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_outcomes)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_record)?;
                },
                24 => {
                    self.prediction_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.plus_prediction_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_commends)?;
                },
                48 => {
                    self.first_match_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_match)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_mvps)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recent_outcomes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.prediction_streak {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.plus_prediction_streak {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.recent_commends.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.first_match_timestamp {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.last_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.recent_mvps.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.recent_outcomes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.total_record.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.prediction_streak {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.plus_prediction_streak {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.recent_commends.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.first_match_timestamp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.last_match.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.recent_mvps.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerRecentAccomplishments {
        CMsgPlayerRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.recent_outcomes.clear();
        self.total_record.clear();
        self.prediction_streak = ::std::option::Option::None;
        self.plus_prediction_streak = ::std::option::Option::None;
        self.recent_commends.clear();
        self.first_match_timestamp = ::std::option::Option::None;
        self.last_match.clear();
        self.recent_mvps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerRecentAccomplishments {
        static instance: CMsgPlayerRecentAccomplishments = CMsgPlayerRecentAccomplishments {
            recent_outcomes: ::protobuf::MessageField::none(),
            total_record: ::protobuf::MessageField::none(),
            prediction_streak: ::std::option::Option::None,
            plus_prediction_streak: ::std::option::Option::None,
            recent_commends: ::protobuf::MessageField::none(),
            first_match_timestamp: ::std::option::Option::None,
            last_match: ::protobuf::MessageField::none(),
            recent_mvps: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerRecentAccomplishments {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerRecentAccomplishments").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerRecentAccomplishments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerRecentAccomplishments {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPlayerHeroRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerHeroRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPlayerHeroRecentAccomplishments.recent_outcomes)
    pub recent_outcomes: ::protobuf::MessageField<CMsgPlayerRecentMatchOutcomes>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerHeroRecentAccomplishments.total_record)
    pub total_record: ::protobuf::MessageField<CMsgPlayerMatchRecord>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerHeroRecentAccomplishments.last_match)
    pub last_match: ::protobuf::MessageField<CMsgPlayerRecentMatchInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPlayerHeroRecentAccomplishments.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerHeroRecentAccomplishments {
    fn default() -> &'a CMsgPlayerHeroRecentAccomplishments {
        <CMsgPlayerHeroRecentAccomplishments as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerHeroRecentAccomplishments {
    pub fn new() -> CMsgPlayerHeroRecentAccomplishments {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerRecentMatchOutcomes>(
            "recent_outcomes",
            |m: &CMsgPlayerHeroRecentAccomplishments| { &m.recent_outcomes },
            |m: &mut CMsgPlayerHeroRecentAccomplishments| { &mut m.recent_outcomes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerMatchRecord>(
            "total_record",
            |m: &CMsgPlayerHeroRecentAccomplishments| { &m.total_record },
            |m: &mut CMsgPlayerHeroRecentAccomplishments| { &mut m.total_record },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerRecentMatchInfo>(
            "last_match",
            |m: &CMsgPlayerHeroRecentAccomplishments| { &m.last_match },
            |m: &mut CMsgPlayerHeroRecentAccomplishments| { &mut m.last_match },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerHeroRecentAccomplishments>(
            "CMsgPlayerHeroRecentAccomplishments",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerHeroRecentAccomplishments {
    const NAME: &'static str = "CMsgPlayerHeroRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_outcomes)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_record)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_match)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recent_outcomes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.recent_outcomes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.total_record.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.last_match.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerHeroRecentAccomplishments {
        CMsgPlayerHeroRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.recent_outcomes.clear();
        self.total_record.clear();
        self.last_match.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerHeroRecentAccomplishments {
        static instance: CMsgPlayerHeroRecentAccomplishments = CMsgPlayerHeroRecentAccomplishments {
            recent_outcomes: ::protobuf::MessageField::none(),
            total_record: ::protobuf::MessageField::none(),
            last_match: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerHeroRecentAccomplishments {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerHeroRecentAccomplishments").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerHeroRecentAccomplishments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerHeroRecentAccomplishments {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgRecentAccomplishments.player_accomplishments)
    pub player_accomplishments: ::protobuf::MessageField<CMsgPlayerRecentAccomplishments>,
    // @@protoc_insertion_point(field:dota.CMsgRecentAccomplishments.hero_accomplishments)
    pub hero_accomplishments: ::protobuf::MessageField<CMsgPlayerHeroRecentAccomplishments>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgRecentAccomplishments.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRecentAccomplishments {
    fn default() -> &'a CMsgRecentAccomplishments {
        <CMsgRecentAccomplishments as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRecentAccomplishments {
    pub fn new() -> CMsgRecentAccomplishments {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerRecentAccomplishments>(
            "player_accomplishments",
            |m: &CMsgRecentAccomplishments| { &m.player_accomplishments },
            |m: &mut CMsgRecentAccomplishments| { &mut m.player_accomplishments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPlayerHeroRecentAccomplishments>(
            "hero_accomplishments",
            |m: &CMsgRecentAccomplishments| { &m.hero_accomplishments },
            |m: &mut CMsgRecentAccomplishments| { &mut m.hero_accomplishments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRecentAccomplishments>(
            "CMsgRecentAccomplishments",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRecentAccomplishments {
    const NAME: &'static str = "CMsgRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_accomplishments)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_accomplishments)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_accomplishments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hero_accomplishments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_accomplishments.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.hero_accomplishments.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRecentAccomplishments {
        CMsgRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.player_accomplishments.clear();
        self.hero_accomplishments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRecentAccomplishments {
        static instance: CMsgRecentAccomplishments = CMsgRecentAccomplishments {
            player_accomplishments: ::protobuf::MessageField::none(),
            hero_accomplishments: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRecentAccomplishments {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRecentAccomplishments").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRecentAccomplishments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRecentAccomplishments {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCRequestPlayerRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestPlayerRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestPlayerRecentAccomplishments.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestPlayerRecentAccomplishments.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCRequestPlayerRecentAccomplishments.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestPlayerRecentAccomplishments {
    fn default() -> &'a CMsgServerToGCRequestPlayerRecentAccomplishments {
        <CMsgServerToGCRequestPlayerRecentAccomplishments as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestPlayerRecentAccomplishments {
    pub fn new() -> CMsgServerToGCRequestPlayerRecentAccomplishments {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 2;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgServerToGCRequestPlayerRecentAccomplishments| { &m.account_id },
            |m: &mut CMsgServerToGCRequestPlayerRecentAccomplishments| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgServerToGCRequestPlayerRecentAccomplishments| { &m.hero_id },
            |m: &mut CMsgServerToGCRequestPlayerRecentAccomplishments| { &mut m.hero_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCRequestPlayerRecentAccomplishments>(
            "CMsgServerToGCRequestPlayerRecentAccomplishments",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCRequestPlayerRecentAccomplishments {
    const NAME: &'static str = "CMsgServerToGCRequestPlayerRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestPlayerRecentAccomplishments {
        CMsgServerToGCRequestPlayerRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestPlayerRecentAccomplishments {
        static instance: CMsgServerToGCRequestPlayerRecentAccomplishments = CMsgServerToGCRequestPlayerRecentAccomplishments {
            account_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCRequestPlayerRecentAccomplishments {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCRequestPlayerRecentAccomplishments").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCRequestPlayerRecentAccomplishments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRequestPlayerRecentAccomplishments {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.player_accomplishments)
    pub player_accomplishments: ::protobuf::MessageField<CMsgRecentAccomplishments>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    fn default() -> &'a CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
        <CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    pub fn new() -> CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse::k_eInternalError),
            None => cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse| { &m.result },
            |m: &mut CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgRecentAccomplishments>(
            "player_accomplishments",
            |m: &CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse| { &m.player_accomplishments },
            |m: &mut CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse| { &mut m.player_accomplishments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse>(
            "CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    const NAME: &'static str = "CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_accomplishments)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.player_accomplishments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.player_accomplishments.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
        CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.player_accomplishments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
        static instance: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse = CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
            result: ::std::option::Option::None,
            player_accomplishments: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse`
pub mod cmsg_server_to_gcrequest_player_recent_accomplishments_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgArcanaVoteMatchVotes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgArcanaVoteMatchVotes {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgArcanaVoteMatchVotes.match_id)
    pub match_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgArcanaVoteMatchVotes.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgArcanaVoteMatchVotes.vote_count)
    pub vote_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgArcanaVoteMatchVotes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgArcanaVoteMatchVotes {
    fn default() -> &'a CMsgArcanaVoteMatchVotes {
        <CMsgArcanaVoteMatchVotes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgArcanaVoteMatchVotes {
    pub fn new() -> CMsgArcanaVoteMatchVotes {
        ::std::default::Default::default()
    }

    // optional uint32 match_id = 1;

    pub fn match_id(&self) -> u32 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u32) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 2;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 vote_count = 3;

    pub fn vote_count(&self) -> u32 {
        self.vote_count.unwrap_or(0)
    }

    pub fn clear_vote_count(&mut self) {
        self.vote_count = ::std::option::Option::None;
    }

    pub fn has_vote_count(&self) -> bool {
        self.vote_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_count(&mut self, v: u32) {
        self.vote_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgArcanaVoteMatchVotes| { &m.match_id },
            |m: &mut CMsgArcanaVoteMatchVotes| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgArcanaVoteMatchVotes| { &m.hero_id },
            |m: &mut CMsgArcanaVoteMatchVotes| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_count",
            |m: &CMsgArcanaVoteMatchVotes| { &m.vote_count },
            |m: &mut CMsgArcanaVoteMatchVotes| { &mut m.vote_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgArcanaVoteMatchVotes>(
            "CMsgArcanaVoteMatchVotes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgArcanaVoteMatchVotes {
    const NAME: &'static str = "CMsgArcanaVoteMatchVotes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.vote_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.vote_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.vote_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgArcanaVoteMatchVotes {
        CMsgArcanaVoteMatchVotes::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.vote_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgArcanaVoteMatchVotes {
        static instance: CMsgArcanaVoteMatchVotes = CMsgArcanaVoteMatchVotes {
            match_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            vote_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgArcanaVoteMatchVotes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgArcanaVoteMatchVotes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgArcanaVoteMatchVotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgArcanaVoteMatchVotes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCtoGCAssociatedExploiterAccountInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCtoGCAssociatedExploiterAccountInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfo.num_matches_to_search)
    pub num_matches_to_search: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfo.min_shared_match_count)
    pub min_shared_match_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfo.num_additional_players)
    pub num_additional_players: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCtoGCAssociatedExploiterAccountInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCtoGCAssociatedExploiterAccountInfo {
    fn default() -> &'a CMsgGCtoGCAssociatedExploiterAccountInfo {
        <CMsgGCtoGCAssociatedExploiterAccountInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCtoGCAssociatedExploiterAccountInfo {
    pub fn new() -> CMsgGCtoGCAssociatedExploiterAccountInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 num_matches_to_search = 2;

    pub fn num_matches_to_search(&self) -> u32 {
        self.num_matches_to_search.unwrap_or(0)
    }

    pub fn clear_num_matches_to_search(&mut self) {
        self.num_matches_to_search = ::std::option::Option::None;
    }

    pub fn has_num_matches_to_search(&self) -> bool {
        self.num_matches_to_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_matches_to_search(&mut self, v: u32) {
        self.num_matches_to_search = ::std::option::Option::Some(v);
    }

    // optional uint32 min_shared_match_count = 3;

    pub fn min_shared_match_count(&self) -> u32 {
        self.min_shared_match_count.unwrap_or(0)
    }

    pub fn clear_min_shared_match_count(&mut self) {
        self.min_shared_match_count = ::std::option::Option::None;
    }

    pub fn has_min_shared_match_count(&self) -> bool {
        self.min_shared_match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_shared_match_count(&mut self, v: u32) {
        self.min_shared_match_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_additional_players = 4;

    pub fn num_additional_players(&self) -> u32 {
        self.num_additional_players.unwrap_or(0)
    }

    pub fn clear_num_additional_players(&mut self) {
        self.num_additional_players = ::std::option::Option::None;
    }

    pub fn has_num_additional_players(&self) -> bool {
        self.num_additional_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_additional_players(&mut self, v: u32) {
        self.num_additional_players = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCtoGCAssociatedExploiterAccountInfo| { &m.account_id },
            |m: &mut CMsgGCtoGCAssociatedExploiterAccountInfo| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_matches_to_search",
            |m: &CMsgGCtoGCAssociatedExploiterAccountInfo| { &m.num_matches_to_search },
            |m: &mut CMsgGCtoGCAssociatedExploiterAccountInfo| { &mut m.num_matches_to_search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_shared_match_count",
            |m: &CMsgGCtoGCAssociatedExploiterAccountInfo| { &m.min_shared_match_count },
            |m: &mut CMsgGCtoGCAssociatedExploiterAccountInfo| { &mut m.min_shared_match_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_additional_players",
            |m: &CMsgGCtoGCAssociatedExploiterAccountInfo| { &m.num_additional_players },
            |m: &mut CMsgGCtoGCAssociatedExploiterAccountInfo| { &mut m.num_additional_players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCtoGCAssociatedExploiterAccountInfo>(
            "CMsgGCtoGCAssociatedExploiterAccountInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCtoGCAssociatedExploiterAccountInfo {
    const NAME: &'static str = "CMsgGCtoGCAssociatedExploiterAccountInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_matches_to_search = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.min_shared_match_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.num_additional_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_matches_to_search {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.min_shared_match_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.num_additional_players {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_matches_to_search {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.min_shared_match_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.num_additional_players {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCtoGCAssociatedExploiterAccountInfo {
        CMsgGCtoGCAssociatedExploiterAccountInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.num_matches_to_search = ::std::option::Option::None;
        self.min_shared_match_count = ::std::option::Option::None;
        self.num_additional_players = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCtoGCAssociatedExploiterAccountInfo {
        static instance: CMsgGCtoGCAssociatedExploiterAccountInfo = CMsgGCtoGCAssociatedExploiterAccountInfo {
            account_id: ::std::option::Option::None,
            num_matches_to_search: ::std::option::Option::None,
            min_shared_match_count: ::std::option::Option::None,
            num_additional_players: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCtoGCAssociatedExploiterAccountInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCtoGCAssociatedExploiterAccountInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCtoGCAssociatedExploiterAccountInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCtoGCAssociatedExploiterAccountInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.accounts)
    pub accounts: ::std::vec::Vec<cmsg_gcto_gcassociated_exploiter_account_info_response::Account>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    fn default() -> &'a CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
        <CMsgGCtoGCAssociatedExploiterAccountInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    pub fn new() -> CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accounts",
            |m: &CMsgGCtoGCAssociatedExploiterAccountInfoResponse| { &m.accounts },
            |m: &mut CMsgGCtoGCAssociatedExploiterAccountInfoResponse| { &mut m.accounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCtoGCAssociatedExploiterAccountInfoResponse>(
            "CMsgGCtoGCAssociatedExploiterAccountInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    const NAME: &'static str = "CMsgGCtoGCAssociatedExploiterAccountInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accounts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.accounts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
        CMsgGCtoGCAssociatedExploiterAccountInfoResponse::new()
    }

    fn clear(&mut self) {
        self.accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
        static instance: CMsgGCtoGCAssociatedExploiterAccountInfoResponse = CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
            accounts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCtoGCAssociatedExploiterAccountInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCtoGCAssociatedExploiterAccountInfoResponse`
pub mod cmsg_gcto_gcassociated_exploiter_account_info_response {
    // @@protoc_insertion_point(message:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Account {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.num_common_matches)
        pub num_common_matches: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.earliest_common_match)
        pub earliest_common_match: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.latest_common_match)
        pub latest_common_match: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.generation)
        pub generation: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.persona)
        pub persona: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.already_banned)
        pub already_banned: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Account {
        fn default() -> &'a Account {
            <Account as ::protobuf::Message>::default_instance()
        }
    }

    impl Account {
        pub fn new() -> Account {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 num_common_matches = 2;

        pub fn num_common_matches(&self) -> u32 {
            self.num_common_matches.unwrap_or(0)
        }

        pub fn clear_num_common_matches(&mut self) {
            self.num_common_matches = ::std::option::Option::None;
        }

        pub fn has_num_common_matches(&self) -> bool {
            self.num_common_matches.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_common_matches(&mut self, v: u32) {
            self.num_common_matches = ::std::option::Option::Some(v);
        }

        // optional uint32 earliest_common_match = 3;

        pub fn earliest_common_match(&self) -> u32 {
            self.earliest_common_match.unwrap_or(0)
        }

        pub fn clear_earliest_common_match(&mut self) {
            self.earliest_common_match = ::std::option::Option::None;
        }

        pub fn has_earliest_common_match(&self) -> bool {
            self.earliest_common_match.is_some()
        }

        // Param is passed by value, moved
        pub fn set_earliest_common_match(&mut self, v: u32) {
            self.earliest_common_match = ::std::option::Option::Some(v);
        }

        // optional uint32 latest_common_match = 4;

        pub fn latest_common_match(&self) -> u32 {
            self.latest_common_match.unwrap_or(0)
        }

        pub fn clear_latest_common_match(&mut self) {
            self.latest_common_match = ::std::option::Option::None;
        }

        pub fn has_latest_common_match(&self) -> bool {
            self.latest_common_match.is_some()
        }

        // Param is passed by value, moved
        pub fn set_latest_common_match(&mut self, v: u32) {
            self.latest_common_match = ::std::option::Option::Some(v);
        }

        // optional uint32 generation = 5;

        pub fn generation(&self) -> u32 {
            self.generation.unwrap_or(0)
        }

        pub fn clear_generation(&mut self) {
            self.generation = ::std::option::Option::None;
        }

        pub fn has_generation(&self) -> bool {
            self.generation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_generation(&mut self, v: u32) {
            self.generation = ::std::option::Option::Some(v);
        }

        // optional string persona = 6;

        pub fn persona(&self) -> &str {
            match self.persona.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona(&mut self) {
            self.persona = ::std::option::Option::None;
        }

        pub fn has_persona(&self) -> bool {
            self.persona.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona(&mut self, v: ::std::string::String) {
            self.persona = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona(&mut self) -> &mut ::std::string::String {
            if self.persona.is_none() {
                self.persona = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona(&mut self) -> ::std::string::String {
            self.persona.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool already_banned = 7;

        pub fn already_banned(&self) -> bool {
            self.already_banned.unwrap_or(false)
        }

        pub fn clear_already_banned(&mut self) {
            self.already_banned = ::std::option::Option::None;
        }

        pub fn has_already_banned(&self) -> bool {
            self.already_banned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_already_banned(&mut self, v: bool) {
            self.already_banned = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Account| { &m.account_id },
                |m: &mut Account| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_common_matches",
                |m: &Account| { &m.num_common_matches },
                |m: &mut Account| { &mut m.num_common_matches },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "earliest_common_match",
                |m: &Account| { &m.earliest_common_match },
                |m: &mut Account| { &mut m.earliest_common_match },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "latest_common_match",
                |m: &Account| { &m.latest_common_match },
                |m: &mut Account| { &mut m.latest_common_match },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "generation",
                |m: &Account| { &m.generation },
                |m: &mut Account| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona",
                |m: &Account| { &m.persona },
                |m: &mut Account| { &mut m.persona },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "already_banned",
                |m: &Account| { &m.already_banned },
                |m: &mut Account| { &mut m.already_banned },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Account>(
                "CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Account {
        const NAME: &'static str = "Account";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.num_common_matches = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.earliest_common_match = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.latest_common_match = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.generation = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.persona = ::std::option::Option::Some(is.read_string()?);
                    },
                    56 => {
                        self.already_banned = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.num_common_matches {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.earliest_common_match {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.latest_common_match {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.generation {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.persona.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.already_banned {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.num_common_matches {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.earliest_common_match {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.latest_common_match {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.generation {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.already_banned {
                os.write_bool(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Account {
            Account::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.num_common_matches = ::std::option::Option::None;
            self.earliest_common_match = ::std::option::Option::None;
            self.latest_common_match = ::std::option::Option::None;
            self.generation = ::std::option::Option::None;
            self.persona = ::std::option::Option::None;
            self.already_banned = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Account {
            static instance: Account = Account {
                account_id: ::std::option::Option::None,
                num_common_matches: ::std::option::Option::None,
                earliest_common_match: ::std::option::Option::None,
                latest_common_match: ::std::option::Option::None,
                generation: ::std::option::Option::None,
                persona: ::std::option::Option::None,
                already_banned: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Account {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Account {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Account {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgPullTabsData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPullTabsData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPullTabsData.slots)
    pub slots: ::std::vec::Vec<cmsg_pull_tabs_data::Slot>,
    // @@protoc_insertion_point(field:dota.CMsgPullTabsData.jackpots)
    pub jackpots: ::std::vec::Vec<cmsg_pull_tabs_data::Jackpot>,
    // @@protoc_insertion_point(field:dota.CMsgPullTabsData.last_board)
    pub last_board: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPullTabsData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPullTabsData {
    fn default() -> &'a CMsgPullTabsData {
        <CMsgPullTabsData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPullTabsData {
    pub fn new() -> CMsgPullTabsData {
        ::std::default::Default::default()
    }

    // optional uint32 last_board = 3;

    pub fn last_board(&self) -> u32 {
        self.last_board.unwrap_or(0)
    }

    pub fn clear_last_board(&mut self) {
        self.last_board = ::std::option::Option::None;
    }

    pub fn has_last_board(&self) -> bool {
        self.last_board.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_board(&mut self, v: u32) {
        self.last_board = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "slots",
            |m: &CMsgPullTabsData| { &m.slots },
            |m: &mut CMsgPullTabsData| { &mut m.slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "jackpots",
            |m: &CMsgPullTabsData| { &m.jackpots },
            |m: &mut CMsgPullTabsData| { &mut m.jackpots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_board",
            |m: &CMsgPullTabsData| { &m.last_board },
            |m: &mut CMsgPullTabsData| { &mut m.last_board },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPullTabsData>(
            "CMsgPullTabsData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPullTabsData {
    const NAME: &'static str = "CMsgPullTabsData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.slots.push(is.read_message()?);
                },
                18 => {
                    self.jackpots.push(is.read_message()?);
                },
                24 => {
                    self.last_board = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.jackpots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.last_board {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.slots {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.jackpots {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.last_board {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPullTabsData {
        CMsgPullTabsData::new()
    }

    fn clear(&mut self) {
        self.slots.clear();
        self.jackpots.clear();
        self.last_board = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPullTabsData {
        static instance: CMsgPullTabsData = CMsgPullTabsData {
            slots: ::std::vec::Vec::new(),
            jackpots: ::std::vec::Vec::new(),
            last_board: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPullTabsData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPullTabsData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPullTabsData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPullTabsData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPullTabsData`
pub mod cmsg_pull_tabs_data {
    // @@protoc_insertion_point(message:dota.CMsgPullTabsData.Slot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Slot {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgPullTabsData.Slot.event_id)
        pub event_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPullTabsData.Slot.board_id)
        pub board_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPullTabsData.Slot.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPullTabsData.Slot.action_id)
        pub action_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPullTabsData.Slot.redeemed)
        pub redeemed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgPullTabsData.Slot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Slot {
        fn default() -> &'a Slot {
            <Slot as ::protobuf::Message>::default_instance()
        }
    }

    impl Slot {
        pub fn new() -> Slot {
            ::std::default::Default::default()
        }

        // optional uint32 event_id = 1;

        pub fn event_id(&self) -> u32 {
            self.event_id.unwrap_or(0)
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: u32) {
            self.event_id = ::std::option::Option::Some(v);
        }

        // optional uint32 board_id = 2;

        pub fn board_id(&self) -> u32 {
            self.board_id.unwrap_or(0)
        }

        pub fn clear_board_id(&mut self) {
            self.board_id = ::std::option::Option::None;
        }

        pub fn has_board_id(&self) -> bool {
            self.board_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_board_id(&mut self, v: u32) {
            self.board_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 3;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 action_id = 4;

        pub fn action_id(&self) -> u32 {
            self.action_id.unwrap_or(0)
        }

        pub fn clear_action_id(&mut self) {
            self.action_id = ::std::option::Option::None;
        }

        pub fn has_action_id(&self) -> bool {
            self.action_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action_id(&mut self, v: u32) {
            self.action_id = ::std::option::Option::Some(v);
        }

        // optional bool redeemed = 5;

        pub fn redeemed(&self) -> bool {
            self.redeemed.unwrap_or(false)
        }

        pub fn clear_redeemed(&mut self) {
            self.redeemed = ::std::option::Option::None;
        }

        pub fn has_redeemed(&self) -> bool {
            self.redeemed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_redeemed(&mut self, v: bool) {
            self.redeemed = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_id",
                |m: &Slot| { &m.event_id },
                |m: &mut Slot| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "board_id",
                |m: &Slot| { &m.board_id },
                |m: &mut Slot| { &mut m.board_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &Slot| { &m.hero_id },
                |m: &mut Slot| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "action_id",
                |m: &Slot| { &m.action_id },
                |m: &mut Slot| { &mut m.action_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "redeemed",
                |m: &Slot| { &m.redeemed },
                |m: &mut Slot| { &mut m.redeemed },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Slot>(
                "CMsgPullTabsData.Slot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Slot {
        const NAME: &'static str = "Slot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.board_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.redeemed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.board_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.action_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.redeemed {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.event_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.board_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.action_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.redeemed {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Slot {
            Slot::new()
        }

        fn clear(&mut self) {
            self.event_id = ::std::option::Option::None;
            self.board_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.action_id = ::std::option::Option::None;
            self.redeemed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Slot {
            static instance: Slot = Slot {
                event_id: ::std::option::Option::None,
                board_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                action_id: ::std::option::Option::None,
                redeemed: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Slot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPullTabsData.Slot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Slot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Slot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgPullTabsData.Jackpot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Jackpot {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgPullTabsData.Jackpot.board_id)
        pub board_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPullTabsData.Jackpot.action_id)
        pub action_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgPullTabsData.Jackpot.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgPullTabsData.Jackpot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Jackpot {
        fn default() -> &'a Jackpot {
            <Jackpot as ::protobuf::Message>::default_instance()
        }
    }

    impl Jackpot {
        pub fn new() -> Jackpot {
            ::std::default::Default::default()
        }

        // optional uint32 board_id = 1;

        pub fn board_id(&self) -> u32 {
            self.board_id.unwrap_or(0)
        }

        pub fn clear_board_id(&mut self) {
            self.board_id = ::std::option::Option::None;
        }

        pub fn has_board_id(&self) -> bool {
            self.board_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_board_id(&mut self, v: u32) {
            self.board_id = ::std::option::Option::Some(v);
        }

        // optional uint32 action_id = 2;

        pub fn action_id(&self) -> u32 {
            self.action_id.unwrap_or(0)
        }

        pub fn clear_action_id(&mut self) {
            self.action_id = ::std::option::Option::None;
        }

        pub fn has_action_id(&self) -> bool {
            self.action_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action_id(&mut self, v: u32) {
            self.action_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 3;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "board_id",
                |m: &Jackpot| { &m.board_id },
                |m: &mut Jackpot| { &mut m.board_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "action_id",
                |m: &Jackpot| { &m.action_id },
                |m: &mut Jackpot| { &mut m.action_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &Jackpot| { &m.hero_id },
                |m: &mut Jackpot| { &mut m.hero_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Jackpot>(
                "CMsgPullTabsData.Jackpot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Jackpot {
        const NAME: &'static str = "Jackpot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.board_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.board_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.action_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.board_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.action_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Jackpot {
            Jackpot::new()
        }

        fn clear(&mut self) {
            self.board_id = ::std::option::Option::None;
            self.action_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Jackpot {
            static instance: Jackpot = Jackpot {
                board_id: ::std::option::Option::None,
                action_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Jackpot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPullTabsData.Jackpot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Jackpot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Jackpot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgUnderDraftData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUnderDraftData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.bench_slots)
    pub bench_slots: ::std::vec::Vec<cmsg_under_draft_data::BenchSlot>,
    // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.shop_slots)
    pub shop_slots: ::std::vec::Vec<cmsg_under_draft_data::ShopSlot>,
    // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.gold)
    pub gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.total_gold)
    pub total_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.not_restorable)
    pub not_restorable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgUnderDraftData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUnderDraftData {
    fn default() -> &'a CMsgUnderDraftData {
        <CMsgUnderDraftData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUnderDraftData {
    pub fn new() -> CMsgUnderDraftData {
        ::std::default::Default::default()
    }

    // optional uint32 gold = 3;

    pub fn gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    // optional uint32 total_gold = 4;

    pub fn total_gold(&self) -> u32 {
        self.total_gold.unwrap_or(0)
    }

    pub fn clear_total_gold(&mut self) {
        self.total_gold = ::std::option::Option::None;
    }

    pub fn has_total_gold(&self) -> bool {
        self.total_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_gold(&mut self, v: u32) {
        self.total_gold = ::std::option::Option::Some(v);
    }

    // optional bool not_restorable = 5;

    pub fn not_restorable(&self) -> bool {
        self.not_restorable.unwrap_or(false)
    }

    pub fn clear_not_restorable(&mut self) {
        self.not_restorable = ::std::option::Option::None;
    }

    pub fn has_not_restorable(&self) -> bool {
        self.not_restorable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_restorable(&mut self, v: bool) {
        self.not_restorable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bench_slots",
            |m: &CMsgUnderDraftData| { &m.bench_slots },
            |m: &mut CMsgUnderDraftData| { &mut m.bench_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shop_slots",
            |m: &CMsgUnderDraftData| { &m.shop_slots },
            |m: &mut CMsgUnderDraftData| { &mut m.shop_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gold",
            |m: &CMsgUnderDraftData| { &m.gold },
            |m: &mut CMsgUnderDraftData| { &mut m.gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_gold",
            |m: &CMsgUnderDraftData| { &m.total_gold },
            |m: &mut CMsgUnderDraftData| { &mut m.total_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_restorable",
            |m: &CMsgUnderDraftData| { &m.not_restorable },
            |m: &mut CMsgUnderDraftData| { &mut m.not_restorable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUnderDraftData>(
            "CMsgUnderDraftData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUnderDraftData {
    const NAME: &'static str = "CMsgUnderDraftData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bench_slots.push(is.read_message()?);
                },
                18 => {
                    self.shop_slots.push(is.read_message()?);
                },
                24 => {
                    self.gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.total_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.not_restorable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bench_slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.shop_slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gold {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.total_gold {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.not_restorable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.bench_slots {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.shop_slots {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.gold {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_gold {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.not_restorable {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUnderDraftData {
        CMsgUnderDraftData::new()
    }

    fn clear(&mut self) {
        self.bench_slots.clear();
        self.shop_slots.clear();
        self.gold = ::std::option::Option::None;
        self.total_gold = ::std::option::Option::None;
        self.not_restorable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUnderDraftData {
        static instance: CMsgUnderDraftData = CMsgUnderDraftData {
            bench_slots: ::std::vec::Vec::new(),
            shop_slots: ::std::vec::Vec::new(),
            gold: ::std::option::Option::None,
            total_gold: ::std::option::Option::None,
            not_restorable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUnderDraftData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUnderDraftData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUnderDraftData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUnderDraftData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgUnderDraftData`
pub mod cmsg_under_draft_data {
    // @@protoc_insertion_point(message:dota.CMsgUnderDraftData.BenchSlot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BenchSlot {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.BenchSlot.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.BenchSlot.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.BenchSlot.stars)
        pub stars: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgUnderDraftData.BenchSlot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BenchSlot {
        fn default() -> &'a BenchSlot {
            <BenchSlot as ::protobuf::Message>::default_instance()
        }
    }

    impl BenchSlot {
        pub fn new() -> BenchSlot {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 2;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stars = 3;

        pub fn stars(&self) -> u32 {
            self.stars.unwrap_or(0)
        }

        pub fn clear_stars(&mut self) {
            self.stars = ::std::option::Option::None;
        }

        pub fn has_stars(&self) -> bool {
            self.stars.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stars(&mut self, v: u32) {
            self.stars = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot_id",
                |m: &BenchSlot| { &m.slot_id },
                |m: &mut BenchSlot| { &mut m.slot_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &BenchSlot| { &m.hero_id },
                |m: &mut BenchSlot| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stars",
                |m: &BenchSlot| { &m.stars },
                |m: &mut BenchSlot| { &mut m.stars },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BenchSlot>(
                "CMsgUnderDraftData.BenchSlot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BenchSlot {
        const NAME: &'static str = "BenchSlot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.stars = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.stars {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.stars {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BenchSlot {
            BenchSlot::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.stars = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BenchSlot {
            static instance: BenchSlot = BenchSlot {
                slot_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                stars: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BenchSlot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgUnderDraftData.BenchSlot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BenchSlot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BenchSlot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgUnderDraftData.ShopSlot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ShopSlot {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.ShopSlot.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.ShopSlot.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgUnderDraftData.ShopSlot.is_special_reward)
        pub is_special_reward: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgUnderDraftData.ShopSlot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ShopSlot {
        fn default() -> &'a ShopSlot {
            <ShopSlot as ::protobuf::Message>::default_instance()
        }
    }

    impl ShopSlot {
        pub fn new() -> ShopSlot {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 2;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional bool is_special_reward = 3;

        pub fn is_special_reward(&self) -> bool {
            self.is_special_reward.unwrap_or(false)
        }

        pub fn clear_is_special_reward(&mut self) {
            self.is_special_reward = ::std::option::Option::None;
        }

        pub fn has_is_special_reward(&self) -> bool {
            self.is_special_reward.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_special_reward(&mut self, v: bool) {
            self.is_special_reward = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot_id",
                |m: &ShopSlot| { &m.slot_id },
                |m: &mut ShopSlot| { &mut m.slot_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &ShopSlot| { &m.hero_id },
                |m: &mut ShopSlot| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_special_reward",
                |m: &ShopSlot| { &m.is_special_reward },
                |m: &mut ShopSlot| { &mut m.is_special_reward },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShopSlot>(
                "CMsgUnderDraftData.ShopSlot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ShopSlot {
        const NAME: &'static str = "ShopSlot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.is_special_reward = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.is_special_reward {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.is_special_reward {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ShopSlot {
            ShopSlot::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.is_special_reward = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ShopSlot {
            static instance: ShopSlot = ShopSlot {
                slot_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                is_special_reward: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ShopSlot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgUnderDraftData.ShopSlot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ShopSlot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ShopSlot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgPlayerTitleData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerTitleData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPlayerTitleData.title)
    pub title: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerTitleData.event_id)
    pub event_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPlayerTitleData.active)
    pub active: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPlayerTitleData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerTitleData {
    fn default() -> &'a CMsgPlayerTitleData {
        <CMsgPlayerTitleData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerTitleData {
    pub fn new() -> CMsgPlayerTitleData {
        ::std::default::Default::default()
    }

    // optional uint32 active = 3;

    pub fn active(&self) -> u32 {
        self.active.unwrap_or(0)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: u32) {
        self.active = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "title",
            |m: &CMsgPlayerTitleData| { &m.title },
            |m: &mut CMsgPlayerTitleData| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_id",
            |m: &CMsgPlayerTitleData| { &m.event_id },
            |m: &mut CMsgPlayerTitleData| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active",
            |m: &CMsgPlayerTitleData| { &m.active },
            |m: &mut CMsgPlayerTitleData| { &mut m.active },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerTitleData>(
            "CMsgPlayerTitleData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerTitleData {
    const NAME: &'static str = "CMsgPlayerTitleData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.title)?;
                },
                8 => {
                    self.title.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.event_id)?;
                },
                16 => {
                    self.event_id.push(is.read_uint32()?);
                },
                24 => {
                    self.active = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.title {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.event_id {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.active {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.title {
            os.write_uint32(1, *v)?;
        };
        for v in &self.event_id {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.active {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerTitleData {
        CMsgPlayerTitleData::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.event_id.clear();
        self.active = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerTitleData {
        static instance: CMsgPlayerTitleData = CMsgPlayerTitleData {
            title: ::std::vec::Vec::new(),
            event_id: ::std::vec::Vec::new(),
            active: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerTitleData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerTitleData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerTitleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerTitleData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTATriviaQuestion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTATriviaQuestion {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTATriviaQuestion.question_id)
    pub question_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTATriviaQuestion.category)
    pub category: ::std::option::Option<::protobuf::EnumOrUnknown<EDOTATriviaQuestionCategory>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTATriviaQuestion.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTATriviaQuestion.question_value)
    pub question_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTATriviaQuestion.answer_values)
    pub answer_values: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTATriviaQuestion.correct_answer_index)
    pub correct_answer_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTATriviaQuestion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTATriviaQuestion {
    fn default() -> &'a CMsgDOTATriviaQuestion {
        <CMsgDOTATriviaQuestion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTATriviaQuestion {
    pub fn new() -> CMsgDOTATriviaQuestion {
        ::std::default::Default::default()
    }

    // optional uint32 question_id = 1;

    pub fn question_id(&self) -> u32 {
        self.question_id.unwrap_or(0)
    }

    pub fn clear_question_id(&mut self) {
        self.question_id = ::std::option::Option::None;
    }

    pub fn has_question_id(&self) -> bool {
        self.question_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_id(&mut self, v: u32) {
        self.question_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EDOTATriviaQuestionCategory category = 2;

    pub fn category(&self) -> EDOTATriviaQuestionCategory {
        match self.category {
            Some(e) => e.enum_value_or(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon),
            None => EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon,
        }
    }

    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: EDOTATriviaQuestionCategory) {
        self.category = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string question_value = 4;

    pub fn question_value(&self) -> &str {
        match self.question_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_question_value(&mut self) {
        self.question_value = ::std::option::Option::None;
    }

    pub fn has_question_value(&self) -> bool {
        self.question_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_value(&mut self, v: ::std::string::String) {
        self.question_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_question_value(&mut self) -> &mut ::std::string::String {
        if self.question_value.is_none() {
            self.question_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.question_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_question_value(&mut self) -> ::std::string::String {
        self.question_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 correct_answer_index = 6;

    pub fn correct_answer_index(&self) -> u32 {
        self.correct_answer_index.unwrap_or(0)
    }

    pub fn clear_correct_answer_index(&mut self) {
        self.correct_answer_index = ::std::option::Option::None;
    }

    pub fn has_correct_answer_index(&self) -> bool {
        self.correct_answer_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct_answer_index(&mut self, v: u32) {
        self.correct_answer_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "question_id",
            |m: &CMsgDOTATriviaQuestion| { &m.question_id },
            |m: &mut CMsgDOTATriviaQuestion| { &mut m.question_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "category",
            |m: &CMsgDOTATriviaQuestion| { &m.category },
            |m: &mut CMsgDOTATriviaQuestion| { &mut m.category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgDOTATriviaQuestion| { &m.timestamp },
            |m: &mut CMsgDOTATriviaQuestion| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "question_value",
            |m: &CMsgDOTATriviaQuestion| { &m.question_value },
            |m: &mut CMsgDOTATriviaQuestion| { &mut m.question_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "answer_values",
            |m: &CMsgDOTATriviaQuestion| { &m.answer_values },
            |m: &mut CMsgDOTATriviaQuestion| { &mut m.answer_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "correct_answer_index",
            |m: &CMsgDOTATriviaQuestion| { &m.correct_answer_index },
            |m: &mut CMsgDOTATriviaQuestion| { &mut m.correct_answer_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTATriviaQuestion>(
            "CMsgDOTATriviaQuestion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTATriviaQuestion {
    const NAME: &'static str = "CMsgDOTATriviaQuestion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.question_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.category = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.question_value = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.answer_values.push(is.read_string()?);
                },
                48 => {
                    self.correct_answer_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.question_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.category {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.question_value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.answer_values {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.correct_answer_index {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.question_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.category {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.question_value.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.answer_values {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.correct_answer_index {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTATriviaQuestion {
        CMsgDOTATriviaQuestion::new()
    }

    fn clear(&mut self) {
        self.question_id = ::std::option::Option::None;
        self.category = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.question_value = ::std::option::Option::None;
        self.answer_values.clear();
        self.correct_answer_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTATriviaQuestion {
        static instance: CMsgDOTATriviaQuestion = CMsgDOTATriviaQuestion {
            question_id: ::std::option::Option::None,
            category: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            question_value: ::std::option::Option::None,
            answer_values: ::std::vec::Vec::new(),
            correct_answer_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTATriviaQuestion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTATriviaQuestion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTATriviaQuestion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTATriviaQuestion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTATriviaQuestionAnswersSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTATriviaQuestionAnswersSummary {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTATriviaQuestionAnswersSummary.summary_available)
    pub summary_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTATriviaQuestionAnswersSummary.picked_count)
    pub picked_count: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTATriviaQuestionAnswersSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTATriviaQuestionAnswersSummary {
    fn default() -> &'a CMsgDOTATriviaQuestionAnswersSummary {
        <CMsgDOTATriviaQuestionAnswersSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTATriviaQuestionAnswersSummary {
    pub fn new() -> CMsgDOTATriviaQuestionAnswersSummary {
        ::std::default::Default::default()
    }

    // optional bool summary_available = 1;

    pub fn summary_available(&self) -> bool {
        self.summary_available.unwrap_or(false)
    }

    pub fn clear_summary_available(&mut self) {
        self.summary_available = ::std::option::Option::None;
    }

    pub fn has_summary_available(&self) -> bool {
        self.summary_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary_available(&mut self, v: bool) {
        self.summary_available = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "summary_available",
            |m: &CMsgDOTATriviaQuestionAnswersSummary| { &m.summary_available },
            |m: &mut CMsgDOTATriviaQuestionAnswersSummary| { &mut m.summary_available },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "picked_count",
            |m: &CMsgDOTATriviaQuestionAnswersSummary| { &m.picked_count },
            |m: &mut CMsgDOTATriviaQuestionAnswersSummary| { &mut m.picked_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTATriviaQuestionAnswersSummary>(
            "CMsgDOTATriviaQuestionAnswersSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTATriviaQuestionAnswersSummary {
    const NAME: &'static str = "CMsgDOTATriviaQuestionAnswersSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.summary_available = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.picked_count)?;
                },
                16 => {
                    self.picked_count.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.summary_available {
            my_size += 1 + 1;
        }
        for value in &self.picked_count {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.summary_available {
            os.write_bool(1, v)?;
        }
        for v in &self.picked_count {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTATriviaQuestionAnswersSummary {
        CMsgDOTATriviaQuestionAnswersSummary::new()
    }

    fn clear(&mut self) {
        self.summary_available = ::std::option::Option::None;
        self.picked_count.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTATriviaQuestionAnswersSummary {
        static instance: CMsgDOTATriviaQuestionAnswersSummary = CMsgDOTATriviaQuestionAnswersSummary {
            summary_available: ::std::option::Option::None,
            picked_count: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTATriviaQuestionAnswersSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTATriviaQuestionAnswersSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTATriviaQuestionAnswersSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTATriviaQuestionAnswersSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameDataSpecialValueBonus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataSpecialValueBonus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameDataSpecialValueBonus.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataSpecialValueBonus.value)
    pub value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataSpecialValueBonus.operation)
    pub operation: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameDataSpecialValueBonus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataSpecialValueBonus {
    fn default() -> &'a CMsgGameDataSpecialValueBonus {
        <CMsgGameDataSpecialValueBonus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataSpecialValueBonus {
    pub fn new() -> CMsgGameDataSpecialValueBonus {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float value = 2;

    pub fn value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint32 operation = 3;

    pub fn operation(&self) -> u32 {
        self.operation.unwrap_or(0)
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: u32) {
        self.operation = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgGameDataSpecialValueBonus| { &m.name },
            |m: &mut CMsgGameDataSpecialValueBonus| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgGameDataSpecialValueBonus| { &m.value },
            |m: &mut CMsgGameDataSpecialValueBonus| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &CMsgGameDataSpecialValueBonus| { &m.operation },
            |m: &mut CMsgGameDataSpecialValueBonus| { &mut m.operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameDataSpecialValueBonus>(
            "CMsgGameDataSpecialValueBonus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameDataSpecialValueBonus {
    const NAME: &'static str = "CMsgGameDataSpecialValueBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.value = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.operation = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.operation {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataSpecialValueBonus {
        CMsgGameDataSpecialValueBonus::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataSpecialValueBonus {
        static instance: CMsgGameDataSpecialValueBonus = CMsgGameDataSpecialValueBonus {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            operation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameDataSpecialValueBonus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameDataSpecialValueBonus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameDataSpecialValueBonus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameDataSpecialValueBonus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameDataSpecialValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataSpecialValues {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameDataSpecialValues.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataSpecialValues.values_float)
    pub values_float: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataSpecialValues.is_percentage)
    pub is_percentage: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataSpecialValues.heading_loc)
    pub heading_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataSpecialValues.bonuses)
    pub bonuses: ::std::vec::Vec<CMsgGameDataSpecialValueBonus>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameDataSpecialValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataSpecialValues {
    fn default() -> &'a CMsgGameDataSpecialValues {
        <CMsgGameDataSpecialValues as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataSpecialValues {
    pub fn new() -> CMsgGameDataSpecialValues {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_percentage = 4;

    pub fn is_percentage(&self) -> bool {
        self.is_percentage.unwrap_or(false)
    }

    pub fn clear_is_percentage(&mut self) {
        self.is_percentage = ::std::option::Option::None;
    }

    pub fn has_is_percentage(&self) -> bool {
        self.is_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_percentage(&mut self, v: bool) {
        self.is_percentage = ::std::option::Option::Some(v);
    }

    // optional string heading_loc = 5;

    pub fn heading_loc(&self) -> &str {
        match self.heading_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_heading_loc(&mut self) {
        self.heading_loc = ::std::option::Option::None;
    }

    pub fn has_heading_loc(&self) -> bool {
        self.heading_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heading_loc(&mut self, v: ::std::string::String) {
        self.heading_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_heading_loc(&mut self) -> &mut ::std::string::String {
        if self.heading_loc.is_none() {
            self.heading_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.heading_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_heading_loc(&mut self) -> ::std::string::String {
        self.heading_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgGameDataSpecialValues| { &m.name },
            |m: &mut CMsgGameDataSpecialValues| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values_float",
            |m: &CMsgGameDataSpecialValues| { &m.values_float },
            |m: &mut CMsgGameDataSpecialValues| { &mut m.values_float },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_percentage",
            |m: &CMsgGameDataSpecialValues| { &m.is_percentage },
            |m: &mut CMsgGameDataSpecialValues| { &mut m.is_percentage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "heading_loc",
            |m: &CMsgGameDataSpecialValues| { &m.heading_loc },
            |m: &mut CMsgGameDataSpecialValues| { &mut m.heading_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bonuses",
            |m: &CMsgGameDataSpecialValues| { &m.bonuses },
            |m: &mut CMsgGameDataSpecialValues| { &mut m.bonuses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameDataSpecialValues>(
            "CMsgGameDataSpecialValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameDataSpecialValues {
    const NAME: &'static str = "CMsgGameDataSpecialValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.values_float)?;
                },
                21 => {
                    self.values_float.push(is.read_float()?);
                },
                32 => {
                    self.is_percentage = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.heading_loc = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.bonuses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += 5 * self.values_float.len() as u64;
        if let Some(v) = self.is_percentage {
            my_size += 1 + 1;
        }
        if let Some(v) = self.heading_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.bonuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.values_float {
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.is_percentage {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.heading_loc.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.bonuses {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataSpecialValues {
        CMsgGameDataSpecialValues::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.values_float.clear();
        self.is_percentage = ::std::option::Option::None;
        self.heading_loc = ::std::option::Option::None;
        self.bonuses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataSpecialValues {
        static instance: CMsgGameDataSpecialValues = CMsgGameDataSpecialValues {
            name: ::std::option::Option::None,
            values_float: ::std::vec::Vec::new(),
            is_percentage: ::std::option::Option::None,
            heading_loc: ::std::option::Option::None,
            bonuses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameDataSpecialValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameDataSpecialValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameDataSpecialValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameDataSpecialValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameDataAbilityOrItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataAbilityOrItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.name_loc)
    pub name_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.desc_loc)
    pub desc_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.lore_loc)
    pub lore_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.notes_loc)
    pub notes_loc: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.shard_loc)
    pub shard_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.scepter_loc)
    pub scepter_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.behavior)
    pub behavior: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.target_team)
    pub target_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.target_type)
    pub target_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.damage)
    pub damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.immunity)
    pub immunity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.dispellable)
    pub dispellable: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.max_level)
    pub max_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.cast_ranges)
    pub cast_ranges: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.cast_points)
    pub cast_points: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.channel_times)
    pub channel_times: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.cooldowns)
    pub cooldowns: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.durations)
    pub durations: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.damages)
    pub damages: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.mana_costs)
    pub mana_costs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.gold_costs)
    pub gold_costs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.health_costs)
    pub health_costs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.special_values)
    pub special_values: ::std::vec::Vec<CMsgGameDataSpecialValues>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.is_item)
    pub is_item: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.ability_has_scepter)
    pub ability_has_scepter: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.ability_has_shard)
    pub ability_has_shard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.ability_is_granted_by_scepter)
    pub ability_is_granted_by_scepter: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.ability_is_granted_by_shard)
    pub ability_is_granted_by_shard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.item_cost)
    pub item_cost: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.item_initial_charges)
    pub item_initial_charges: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.item_neutral_tier)
    pub item_neutral_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.item_stock_max)
    pub item_stock_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.item_stock_time)
    pub item_stock_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilityOrItem.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameDataAbilityOrItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataAbilityOrItem {
    fn default() -> &'a CMsgGameDataAbilityOrItem {
        <CMsgGameDataAbilityOrItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataAbilityOrItem {
    pub fn new() -> CMsgGameDataAbilityOrItem {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name_loc = 5;

    pub fn name_loc(&self) -> &str {
        match self.name_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_loc(&mut self) {
        self.name_loc = ::std::option::Option::None;
    }

    pub fn has_name_loc(&self) -> bool {
        self.name_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loc(&mut self, v: ::std::string::String) {
        self.name_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loc(&mut self) -> &mut ::std::string::String {
        if self.name_loc.is_none() {
            self.name_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loc(&mut self) -> ::std::string::String {
        self.name_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_loc = 6;

    pub fn desc_loc(&self) -> &str {
        match self.desc_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc_loc(&mut self) {
        self.desc_loc = ::std::option::Option::None;
    }

    pub fn has_desc_loc(&self) -> bool {
        self.desc_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_loc(&mut self, v: ::std::string::String) {
        self.desc_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_loc(&mut self) -> &mut ::std::string::String {
        if self.desc_loc.is_none() {
            self.desc_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_loc(&mut self) -> ::std::string::String {
        self.desc_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string lore_loc = 7;

    pub fn lore_loc(&self) -> &str {
        match self.lore_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lore_loc(&mut self) {
        self.lore_loc = ::std::option::Option::None;
    }

    pub fn has_lore_loc(&self) -> bool {
        self.lore_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lore_loc(&mut self, v: ::std::string::String) {
        self.lore_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lore_loc(&mut self) -> &mut ::std::string::String {
        if self.lore_loc.is_none() {
            self.lore_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lore_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_lore_loc(&mut self) -> ::std::string::String {
        self.lore_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shard_loc = 9;

    pub fn shard_loc(&self) -> &str {
        match self.shard_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shard_loc(&mut self) {
        self.shard_loc = ::std::option::Option::None;
    }

    pub fn has_shard_loc(&self) -> bool {
        self.shard_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shard_loc(&mut self, v: ::std::string::String) {
        self.shard_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_loc(&mut self) -> &mut ::std::string::String {
        if self.shard_loc.is_none() {
            self.shard_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shard_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_shard_loc(&mut self) -> ::std::string::String {
        self.shard_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string scepter_loc = 10;

    pub fn scepter_loc(&self) -> &str {
        match self.scepter_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scepter_loc(&mut self) {
        self.scepter_loc = ::std::option::Option::None;
    }

    pub fn has_scepter_loc(&self) -> bool {
        self.scepter_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scepter_loc(&mut self, v: ::std::string::String) {
        self.scepter_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scepter_loc(&mut self) -> &mut ::std::string::String {
        if self.scepter_loc.is_none() {
            self.scepter_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scepter_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_scepter_loc(&mut self) -> ::std::string::String {
        self.scepter_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 type = 20;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint64 behavior = 21;

    pub fn behavior(&self) -> u64 {
        self.behavior.unwrap_or(0)
    }

    pub fn clear_behavior(&mut self) {
        self.behavior = ::std::option::Option::None;
    }

    pub fn has_behavior(&self) -> bool {
        self.behavior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_behavior(&mut self, v: u64) {
        self.behavior = ::std::option::Option::Some(v);
    }

    // optional uint32 target_team = 22;

    pub fn target_team(&self) -> u32 {
        self.target_team.unwrap_or(0)
    }

    pub fn clear_target_team(&mut self) {
        self.target_team = ::std::option::Option::None;
    }

    pub fn has_target_team(&self) -> bool {
        self.target_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_team(&mut self, v: u32) {
        self.target_team = ::std::option::Option::Some(v);
    }

    // optional uint32 target_type = 23;

    pub fn target_type(&self) -> u32 {
        self.target_type.unwrap_or(0)
    }

    pub fn clear_target_type(&mut self) {
        self.target_type = ::std::option::Option::None;
    }

    pub fn has_target_type(&self) -> bool {
        self.target_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_type(&mut self, v: u32) {
        self.target_type = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 24;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 damage = 25;

    pub fn damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional uint32 immunity = 26;

    pub fn immunity(&self) -> u32 {
        self.immunity.unwrap_or(0)
    }

    pub fn clear_immunity(&mut self) {
        self.immunity = ::std::option::Option::None;
    }

    pub fn has_immunity(&self) -> bool {
        self.immunity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_immunity(&mut self, v: u32) {
        self.immunity = ::std::option::Option::Some(v);
    }

    // optional uint32 dispellable = 27;

    pub fn dispellable(&self) -> u32 {
        self.dispellable.unwrap_or(0)
    }

    pub fn clear_dispellable(&mut self) {
        self.dispellable = ::std::option::Option::None;
    }

    pub fn has_dispellable(&self) -> bool {
        self.dispellable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dispellable(&mut self, v: u32) {
        self.dispellable = ::std::option::Option::Some(v);
    }

    // optional uint32 max_level = 28;

    pub fn max_level(&self) -> u32 {
        self.max_level.unwrap_or(0)
    }

    pub fn clear_max_level(&mut self) {
        self.max_level = ::std::option::Option::None;
    }

    pub fn has_max_level(&self) -> bool {
        self.max_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_level(&mut self, v: u32) {
        self.max_level = ::std::option::Option::Some(v);
    }

    // optional bool is_item = 50;

    pub fn is_item(&self) -> bool {
        self.is_item.unwrap_or(false)
    }

    pub fn clear_is_item(&mut self) {
        self.is_item = ::std::option::Option::None;
    }

    pub fn has_is_item(&self) -> bool {
        self.is_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_item(&mut self, v: bool) {
        self.is_item = ::std::option::Option::Some(v);
    }

    // optional bool ability_has_scepter = 60;

    pub fn ability_has_scepter(&self) -> bool {
        self.ability_has_scepter.unwrap_or(false)
    }

    pub fn clear_ability_has_scepter(&mut self) {
        self.ability_has_scepter = ::std::option::Option::None;
    }

    pub fn has_ability_has_scepter(&self) -> bool {
        self.ability_has_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_has_scepter(&mut self, v: bool) {
        self.ability_has_scepter = ::std::option::Option::Some(v);
    }

    // optional bool ability_has_shard = 61;

    pub fn ability_has_shard(&self) -> bool {
        self.ability_has_shard.unwrap_or(false)
    }

    pub fn clear_ability_has_shard(&mut self) {
        self.ability_has_shard = ::std::option::Option::None;
    }

    pub fn has_ability_has_shard(&self) -> bool {
        self.ability_has_shard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_has_shard(&mut self, v: bool) {
        self.ability_has_shard = ::std::option::Option::Some(v);
    }

    // optional bool ability_is_granted_by_scepter = 62;

    pub fn ability_is_granted_by_scepter(&self) -> bool {
        self.ability_is_granted_by_scepter.unwrap_or(false)
    }

    pub fn clear_ability_is_granted_by_scepter(&mut self) {
        self.ability_is_granted_by_scepter = ::std::option::Option::None;
    }

    pub fn has_ability_is_granted_by_scepter(&self) -> bool {
        self.ability_is_granted_by_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_is_granted_by_scepter(&mut self, v: bool) {
        self.ability_is_granted_by_scepter = ::std::option::Option::Some(v);
    }

    // optional bool ability_is_granted_by_shard = 63;

    pub fn ability_is_granted_by_shard(&self) -> bool {
        self.ability_is_granted_by_shard.unwrap_or(false)
    }

    pub fn clear_ability_is_granted_by_shard(&mut self) {
        self.ability_is_granted_by_shard = ::std::option::Option::None;
    }

    pub fn has_ability_is_granted_by_shard(&self) -> bool {
        self.ability_is_granted_by_shard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_is_granted_by_shard(&mut self, v: bool) {
        self.ability_is_granted_by_shard = ::std::option::Option::Some(v);
    }

    // optional uint32 item_cost = 70;

    pub fn item_cost(&self) -> u32 {
        self.item_cost.unwrap_or(0)
    }

    pub fn clear_item_cost(&mut self) {
        self.item_cost = ::std::option::Option::None;
    }

    pub fn has_item_cost(&self) -> bool {
        self.item_cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_cost(&mut self, v: u32) {
        self.item_cost = ::std::option::Option::Some(v);
    }

    // optional uint32 item_initial_charges = 71;

    pub fn item_initial_charges(&self) -> u32 {
        self.item_initial_charges.unwrap_or(0)
    }

    pub fn clear_item_initial_charges(&mut self) {
        self.item_initial_charges = ::std::option::Option::None;
    }

    pub fn has_item_initial_charges(&self) -> bool {
        self.item_initial_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_initial_charges(&mut self, v: u32) {
        self.item_initial_charges = ::std::option::Option::Some(v);
    }

    // optional uint32 item_neutral_tier = 72;

    pub fn item_neutral_tier(&self) -> u32 {
        self.item_neutral_tier.unwrap_or(0)
    }

    pub fn clear_item_neutral_tier(&mut self) {
        self.item_neutral_tier = ::std::option::Option::None;
    }

    pub fn has_item_neutral_tier(&self) -> bool {
        self.item_neutral_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_neutral_tier(&mut self, v: u32) {
        self.item_neutral_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 item_stock_max = 73;

    pub fn item_stock_max(&self) -> u32 {
        self.item_stock_max.unwrap_or(0)
    }

    pub fn clear_item_stock_max(&mut self) {
        self.item_stock_max = ::std::option::Option::None;
    }

    pub fn has_item_stock_max(&self) -> bool {
        self.item_stock_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_stock_max(&mut self, v: u32) {
        self.item_stock_max = ::std::option::Option::Some(v);
    }

    // optional float item_stock_time = 74;

    pub fn item_stock_time(&self) -> f32 {
        self.item_stock_time.unwrap_or(0.)
    }

    pub fn clear_item_stock_time(&mut self) {
        self.item_stock_time = ::std::option::Option::None;
    }

    pub fn has_item_stock_time(&self) -> bool {
        self.item_stock_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_stock_time(&mut self, v: f32) {
        self.item_stock_time = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 85;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(38);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgGameDataAbilityOrItem| { &m.id },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgGameDataAbilityOrItem| { &m.name },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_loc",
            |m: &CMsgGameDataAbilityOrItem| { &m.name_loc },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.name_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desc_loc",
            |m: &CMsgGameDataAbilityOrItem| { &m.desc_loc },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.desc_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lore_loc",
            |m: &CMsgGameDataAbilityOrItem| { &m.lore_loc },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.lore_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notes_loc",
            |m: &CMsgGameDataAbilityOrItem| { &m.notes_loc },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.notes_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shard_loc",
            |m: &CMsgGameDataAbilityOrItem| { &m.shard_loc },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.shard_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scepter_loc",
            |m: &CMsgGameDataAbilityOrItem| { &m.scepter_loc },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.scepter_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgGameDataAbilityOrItem| { &m.type_ },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "behavior",
            |m: &CMsgGameDataAbilityOrItem| { &m.behavior },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.behavior },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_team",
            |m: &CMsgGameDataAbilityOrItem| { &m.target_team },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.target_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_type",
            |m: &CMsgGameDataAbilityOrItem| { &m.target_type },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.target_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgGameDataAbilityOrItem| { &m.flags },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage",
            |m: &CMsgGameDataAbilityOrItem| { &m.damage },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "immunity",
            |m: &CMsgGameDataAbilityOrItem| { &m.immunity },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.immunity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dispellable",
            |m: &CMsgGameDataAbilityOrItem| { &m.dispellable },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.dispellable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_level",
            |m: &CMsgGameDataAbilityOrItem| { &m.max_level },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.max_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cast_ranges",
            |m: &CMsgGameDataAbilityOrItem| { &m.cast_ranges },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.cast_ranges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cast_points",
            |m: &CMsgGameDataAbilityOrItem| { &m.cast_points },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.cast_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channel_times",
            |m: &CMsgGameDataAbilityOrItem| { &m.channel_times },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.channel_times },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cooldowns",
            |m: &CMsgGameDataAbilityOrItem| { &m.cooldowns },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.cooldowns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "durations",
            |m: &CMsgGameDataAbilityOrItem| { &m.durations },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.durations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "damages",
            |m: &CMsgGameDataAbilityOrItem| { &m.damages },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.damages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mana_costs",
            |m: &CMsgGameDataAbilityOrItem| { &m.mana_costs },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.mana_costs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gold_costs",
            |m: &CMsgGameDataAbilityOrItem| { &m.gold_costs },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.gold_costs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "health_costs",
            |m: &CMsgGameDataAbilityOrItem| { &m.health_costs },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.health_costs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "special_values",
            |m: &CMsgGameDataAbilityOrItem| { &m.special_values },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.special_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_item",
            |m: &CMsgGameDataAbilityOrItem| { &m.is_item },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.is_item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_has_scepter",
            |m: &CMsgGameDataAbilityOrItem| { &m.ability_has_scepter },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.ability_has_scepter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_has_shard",
            |m: &CMsgGameDataAbilityOrItem| { &m.ability_has_shard },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.ability_has_shard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_is_granted_by_scepter",
            |m: &CMsgGameDataAbilityOrItem| { &m.ability_is_granted_by_scepter },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.ability_is_granted_by_scepter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_is_granted_by_shard",
            |m: &CMsgGameDataAbilityOrItem| { &m.ability_is_granted_by_shard },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.ability_is_granted_by_shard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_cost",
            |m: &CMsgGameDataAbilityOrItem| { &m.item_cost },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.item_cost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_initial_charges",
            |m: &CMsgGameDataAbilityOrItem| { &m.item_initial_charges },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.item_initial_charges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_neutral_tier",
            |m: &CMsgGameDataAbilityOrItem| { &m.item_neutral_tier },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.item_neutral_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_stock_max",
            |m: &CMsgGameDataAbilityOrItem| { &m.item_stock_max },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.item_stock_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_stock_time",
            |m: &CMsgGameDataAbilityOrItem| { &m.item_stock_time },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.item_stock_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality",
            |m: &CMsgGameDataAbilityOrItem| { &m.item_quality },
            |m: &mut CMsgGameDataAbilityOrItem| { &mut m.item_quality },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameDataAbilityOrItem>(
            "CMsgGameDataAbilityOrItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameDataAbilityOrItem {
    const NAME: &'static str = "CMsgGameDataAbilityOrItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.name_loc = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.desc_loc = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.lore_loc = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.notes_loc.push(is.read_string()?);
                },
                74 => {
                    self.shard_loc = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.scepter_loc = ::std::option::Option::Some(is.read_string()?);
                },
                160 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.behavior = ::std::option::Option::Some(is.read_uint64()?);
                },
                176 => {
                    self.target_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.target_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.immunity = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.dispellable = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.max_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    is.read_repeated_packed_uint32_into(&mut self.cast_ranges)?;
                },
                240 => {
                    self.cast_ranges.push(is.read_uint32()?);
                },
                250 => {
                    is.read_repeated_packed_float_into(&mut self.cast_points)?;
                },
                253 => {
                    self.cast_points.push(is.read_float()?);
                },
                258 => {
                    is.read_repeated_packed_float_into(&mut self.channel_times)?;
                },
                261 => {
                    self.channel_times.push(is.read_float()?);
                },
                266 => {
                    is.read_repeated_packed_float_into(&mut self.cooldowns)?;
                },
                269 => {
                    self.cooldowns.push(is.read_float()?);
                },
                274 => {
                    is.read_repeated_packed_float_into(&mut self.durations)?;
                },
                277 => {
                    self.durations.push(is.read_float()?);
                },
                282 => {
                    is.read_repeated_packed_uint32_into(&mut self.damages)?;
                },
                280 => {
                    self.damages.push(is.read_uint32()?);
                },
                290 => {
                    is.read_repeated_packed_uint32_into(&mut self.mana_costs)?;
                },
                288 => {
                    self.mana_costs.push(is.read_uint32()?);
                },
                298 => {
                    is.read_repeated_packed_uint32_into(&mut self.gold_costs)?;
                },
                296 => {
                    self.gold_costs.push(is.read_uint32()?);
                },
                306 => {
                    is.read_repeated_packed_uint32_into(&mut self.health_costs)?;
                },
                304 => {
                    self.health_costs.push(is.read_uint32()?);
                },
                322 => {
                    self.special_values.push(is.read_message()?);
                },
                400 => {
                    self.is_item = ::std::option::Option::Some(is.read_bool()?);
                },
                480 => {
                    self.ability_has_scepter = ::std::option::Option::Some(is.read_bool()?);
                },
                488 => {
                    self.ability_has_shard = ::std::option::Option::Some(is.read_bool()?);
                },
                496 => {
                    self.ability_is_granted_by_scepter = ::std::option::Option::Some(is.read_bool()?);
                },
                504 => {
                    self.ability_is_granted_by_shard = ::std::option::Option::Some(is.read_bool()?);
                },
                560 => {
                    self.item_cost = ::std::option::Option::Some(is.read_uint32()?);
                },
                568 => {
                    self.item_initial_charges = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.item_neutral_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                584 => {
                    self.item_stock_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                597 => {
                    self.item_stock_time = ::std::option::Option::Some(is.read_float()?);
                },
                680 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.desc_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.lore_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.notes_loc {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.shard_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.scepter_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.behavior {
            my_size += ::protobuf::rt::uint64_size(21, v);
        }
        if let Some(v) = self.target_team {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.target_type {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.damage {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.immunity {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.dispellable {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.max_level {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        for value in &self.cast_ranges {
            my_size += ::protobuf::rt::uint32_size(30, *value);
        };
        my_size += 6 * self.cast_points.len() as u64;
        my_size += 6 * self.channel_times.len() as u64;
        my_size += 6 * self.cooldowns.len() as u64;
        my_size += 6 * self.durations.len() as u64;
        for value in &self.damages {
            my_size += ::protobuf::rt::uint32_size(35, *value);
        };
        for value in &self.mana_costs {
            my_size += ::protobuf::rt::uint32_size(36, *value);
        };
        for value in &self.gold_costs {
            my_size += ::protobuf::rt::uint32_size(37, *value);
        };
        for value in &self.health_costs {
            my_size += ::protobuf::rt::uint32_size(38, *value);
        };
        for value in &self.special_values {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_item {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_has_scepter {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_has_shard {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_is_granted_by_scepter {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_is_granted_by_shard {
            my_size += 2 + 1;
        }
        if let Some(v) = self.item_cost {
            my_size += ::protobuf::rt::uint32_size(70, v);
        }
        if let Some(v) = self.item_initial_charges {
            my_size += ::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.item_neutral_tier {
            my_size += ::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.item_stock_max {
            my_size += ::protobuf::rt::uint32_size(73, v);
        }
        if let Some(v) = self.item_stock_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::uint32_size(85, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name_loc.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.desc_loc.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.lore_loc.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.notes_loc {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.shard_loc.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.scepter_loc.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.behavior {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.target_team {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.target_type {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.immunity {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.dispellable {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.max_level {
            os.write_uint32(28, v)?;
        }
        for v in &self.cast_ranges {
            os.write_uint32(30, *v)?;
        };
        for v in &self.cast_points {
            os.write_float(31, *v)?;
        };
        for v in &self.channel_times {
            os.write_float(32, *v)?;
        };
        for v in &self.cooldowns {
            os.write_float(33, *v)?;
        };
        for v in &self.durations {
            os.write_float(34, *v)?;
        };
        for v in &self.damages {
            os.write_uint32(35, *v)?;
        };
        for v in &self.mana_costs {
            os.write_uint32(36, *v)?;
        };
        for v in &self.gold_costs {
            os.write_uint32(37, *v)?;
        };
        for v in &self.health_costs {
            os.write_uint32(38, *v)?;
        };
        for v in &self.special_values {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        };
        if let Some(v) = self.is_item {
            os.write_bool(50, v)?;
        }
        if let Some(v) = self.ability_has_scepter {
            os.write_bool(60, v)?;
        }
        if let Some(v) = self.ability_has_shard {
            os.write_bool(61, v)?;
        }
        if let Some(v) = self.ability_is_granted_by_scepter {
            os.write_bool(62, v)?;
        }
        if let Some(v) = self.ability_is_granted_by_shard {
            os.write_bool(63, v)?;
        }
        if let Some(v) = self.item_cost {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.item_initial_charges {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.item_neutral_tier {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.item_stock_max {
            os.write_uint32(73, v)?;
        }
        if let Some(v) = self.item_stock_time {
            os.write_float(74, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(85, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataAbilityOrItem {
        CMsgGameDataAbilityOrItem::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.name_loc = ::std::option::Option::None;
        self.desc_loc = ::std::option::Option::None;
        self.lore_loc = ::std::option::Option::None;
        self.notes_loc.clear();
        self.shard_loc = ::std::option::Option::None;
        self.scepter_loc = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.behavior = ::std::option::Option::None;
        self.target_team = ::std::option::Option::None;
        self.target_type = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.immunity = ::std::option::Option::None;
        self.dispellable = ::std::option::Option::None;
        self.max_level = ::std::option::Option::None;
        self.cast_ranges.clear();
        self.cast_points.clear();
        self.channel_times.clear();
        self.cooldowns.clear();
        self.durations.clear();
        self.damages.clear();
        self.mana_costs.clear();
        self.gold_costs.clear();
        self.health_costs.clear();
        self.special_values.clear();
        self.is_item = ::std::option::Option::None;
        self.ability_has_scepter = ::std::option::Option::None;
        self.ability_has_shard = ::std::option::Option::None;
        self.ability_is_granted_by_scepter = ::std::option::Option::None;
        self.ability_is_granted_by_shard = ::std::option::Option::None;
        self.item_cost = ::std::option::Option::None;
        self.item_initial_charges = ::std::option::Option::None;
        self.item_neutral_tier = ::std::option::Option::None;
        self.item_stock_max = ::std::option::Option::None;
        self.item_stock_time = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataAbilityOrItem {
        static instance: CMsgGameDataAbilityOrItem = CMsgGameDataAbilityOrItem {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            name_loc: ::std::option::Option::None,
            desc_loc: ::std::option::Option::None,
            lore_loc: ::std::option::Option::None,
            notes_loc: ::std::vec::Vec::new(),
            shard_loc: ::std::option::Option::None,
            scepter_loc: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            behavior: ::std::option::Option::None,
            target_team: ::std::option::Option::None,
            target_type: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            damage: ::std::option::Option::None,
            immunity: ::std::option::Option::None,
            dispellable: ::std::option::Option::None,
            max_level: ::std::option::Option::None,
            cast_ranges: ::std::vec::Vec::new(),
            cast_points: ::std::vec::Vec::new(),
            channel_times: ::std::vec::Vec::new(),
            cooldowns: ::std::vec::Vec::new(),
            durations: ::std::vec::Vec::new(),
            damages: ::std::vec::Vec::new(),
            mana_costs: ::std::vec::Vec::new(),
            gold_costs: ::std::vec::Vec::new(),
            health_costs: ::std::vec::Vec::new(),
            special_values: ::std::vec::Vec::new(),
            is_item: ::std::option::Option::None,
            ability_has_scepter: ::std::option::Option::None,
            ability_has_shard: ::std::option::Option::None,
            ability_is_granted_by_scepter: ::std::option::Option::None,
            ability_is_granted_by_shard: ::std::option::Option::None,
            item_cost: ::std::option::Option::None,
            item_initial_charges: ::std::option::Option::None,
            item_neutral_tier: ::std::option::Option::None,
            item_stock_max: ::std::option::Option::None,
            item_stock_time: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameDataAbilityOrItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameDataAbilityOrItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameDataAbilityOrItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameDataAbilityOrItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameDataHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataHero {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.order_id)
    pub order_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.name_loc)
    pub name_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.bio_loc)
    pub bio_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.hype_loc)
    pub hype_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.npe_desc_loc)
    pub npe_desc_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.str_base)
    pub str_base: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.str_gain)
    pub str_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.agi_base)
    pub agi_base: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.agi_gain)
    pub agi_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.int_base)
    pub int_base: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.int_gain)
    pub int_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.primary_attr)
    pub primary_attr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.complexity)
    pub complexity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.attack_capability)
    pub attack_capability: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.role_levels)
    pub role_levels: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.damage_min)
    pub damage_min: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.damage_max)
    pub damage_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.attack_rate)
    pub attack_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.attack_range)
    pub attack_range: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.projectile_speed)
    pub projectile_speed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.armor)
    pub armor: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.magic_resistance)
    pub magic_resistance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.movement_speed)
    pub movement_speed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.turn_rate)
    pub turn_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.sight_range_day)
    pub sight_range_day: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.sight_range_night)
    pub sight_range_night: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.max_health)
    pub max_health: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.health_regen)
    pub health_regen: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.max_mana)
    pub max_mana: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.mana_regen)
    pub mana_regen: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.abilities)
    pub abilities: ::std::vec::Vec<CMsgGameDataAbilityOrItem>,
    // @@protoc_insertion_point(field:dota.CMsgGameDataHero.talents)
    pub talents: ::std::vec::Vec<CMsgGameDataAbilityOrItem>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameDataHero.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataHero {
    fn default() -> &'a CMsgGameDataHero {
        <CMsgGameDataHero as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataHero {
    pub fn new() -> CMsgGameDataHero {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 order_id = 3;

    pub fn order_id(&self) -> u32 {
        self.order_id.unwrap_or(0)
    }

    pub fn clear_order_id(&mut self) {
        self.order_id = ::std::option::Option::None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: u32) {
        self.order_id = ::std::option::Option::Some(v);
    }

    // optional string name_loc = 5;

    pub fn name_loc(&self) -> &str {
        match self.name_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_loc(&mut self) {
        self.name_loc = ::std::option::Option::None;
    }

    pub fn has_name_loc(&self) -> bool {
        self.name_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loc(&mut self, v: ::std::string::String) {
        self.name_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loc(&mut self) -> &mut ::std::string::String {
        if self.name_loc.is_none() {
            self.name_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loc(&mut self) -> ::std::string::String {
        self.name_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bio_loc = 6;

    pub fn bio_loc(&self) -> &str {
        match self.bio_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bio_loc(&mut self) {
        self.bio_loc = ::std::option::Option::None;
    }

    pub fn has_bio_loc(&self) -> bool {
        self.bio_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bio_loc(&mut self, v: ::std::string::String) {
        self.bio_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bio_loc(&mut self) -> &mut ::std::string::String {
        if self.bio_loc.is_none() {
            self.bio_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bio_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_bio_loc(&mut self) -> ::std::string::String {
        self.bio_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hype_loc = 7;

    pub fn hype_loc(&self) -> &str {
        match self.hype_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hype_loc(&mut self) {
        self.hype_loc = ::std::option::Option::None;
    }

    pub fn has_hype_loc(&self) -> bool {
        self.hype_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hype_loc(&mut self, v: ::std::string::String) {
        self.hype_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hype_loc(&mut self) -> &mut ::std::string::String {
        if self.hype_loc.is_none() {
            self.hype_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hype_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_hype_loc(&mut self) -> ::std::string::String {
        self.hype_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string npe_desc_loc = 8;

    pub fn npe_desc_loc(&self) -> &str {
        match self.npe_desc_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_npe_desc_loc(&mut self) {
        self.npe_desc_loc = ::std::option::Option::None;
    }

    pub fn has_npe_desc_loc(&self) -> bool {
        self.npe_desc_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_npe_desc_loc(&mut self, v: ::std::string::String) {
        self.npe_desc_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npe_desc_loc(&mut self) -> &mut ::std::string::String {
        if self.npe_desc_loc.is_none() {
            self.npe_desc_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.npe_desc_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_npe_desc_loc(&mut self) -> ::std::string::String {
        self.npe_desc_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 str_base = 10;

    pub fn str_base(&self) -> u32 {
        self.str_base.unwrap_or(0)
    }

    pub fn clear_str_base(&mut self) {
        self.str_base = ::std::option::Option::None;
    }

    pub fn has_str_base(&self) -> bool {
        self.str_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_str_base(&mut self, v: u32) {
        self.str_base = ::std::option::Option::Some(v);
    }

    // optional float str_gain = 11;

    pub fn str_gain(&self) -> f32 {
        self.str_gain.unwrap_or(0.)
    }

    pub fn clear_str_gain(&mut self) {
        self.str_gain = ::std::option::Option::None;
    }

    pub fn has_str_gain(&self) -> bool {
        self.str_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_str_gain(&mut self, v: f32) {
        self.str_gain = ::std::option::Option::Some(v);
    }

    // optional uint32 agi_base = 12;

    pub fn agi_base(&self) -> u32 {
        self.agi_base.unwrap_or(0)
    }

    pub fn clear_agi_base(&mut self) {
        self.agi_base = ::std::option::Option::None;
    }

    pub fn has_agi_base(&self) -> bool {
        self.agi_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agi_base(&mut self, v: u32) {
        self.agi_base = ::std::option::Option::Some(v);
    }

    // optional float agi_gain = 13;

    pub fn agi_gain(&self) -> f32 {
        self.agi_gain.unwrap_or(0.)
    }

    pub fn clear_agi_gain(&mut self) {
        self.agi_gain = ::std::option::Option::None;
    }

    pub fn has_agi_gain(&self) -> bool {
        self.agi_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agi_gain(&mut self, v: f32) {
        self.agi_gain = ::std::option::Option::Some(v);
    }

    // optional uint32 int_base = 14;

    pub fn int_base(&self) -> u32 {
        self.int_base.unwrap_or(0)
    }

    pub fn clear_int_base(&mut self) {
        self.int_base = ::std::option::Option::None;
    }

    pub fn has_int_base(&self) -> bool {
        self.int_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_base(&mut self, v: u32) {
        self.int_base = ::std::option::Option::Some(v);
    }

    // optional float int_gain = 15;

    pub fn int_gain(&self) -> f32 {
        self.int_gain.unwrap_or(0.)
    }

    pub fn clear_int_gain(&mut self) {
        self.int_gain = ::std::option::Option::None;
    }

    pub fn has_int_gain(&self) -> bool {
        self.int_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_gain(&mut self, v: f32) {
        self.int_gain = ::std::option::Option::Some(v);
    }

    // optional uint32 primary_attr = 20;

    pub fn primary_attr(&self) -> u32 {
        self.primary_attr.unwrap_or(0)
    }

    pub fn clear_primary_attr(&mut self) {
        self.primary_attr = ::std::option::Option::None;
    }

    pub fn has_primary_attr(&self) -> bool {
        self.primary_attr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_attr(&mut self, v: u32) {
        self.primary_attr = ::std::option::Option::Some(v);
    }

    // optional uint32 complexity = 21;

    pub fn complexity(&self) -> u32 {
        self.complexity.unwrap_or(0)
    }

    pub fn clear_complexity(&mut self) {
        self.complexity = ::std::option::Option::None;
    }

    pub fn has_complexity(&self) -> bool {
        self.complexity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_complexity(&mut self, v: u32) {
        self.complexity = ::std::option::Option::Some(v);
    }

    // optional uint32 attack_capability = 22;

    pub fn attack_capability(&self) -> u32 {
        self.attack_capability.unwrap_or(0)
    }

    pub fn clear_attack_capability(&mut self) {
        self.attack_capability = ::std::option::Option::None;
    }

    pub fn has_attack_capability(&self) -> bool {
        self.attack_capability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_capability(&mut self, v: u32) {
        self.attack_capability = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_min = 24;

    pub fn damage_min(&self) -> u32 {
        self.damage_min.unwrap_or(0)
    }

    pub fn clear_damage_min(&mut self) {
        self.damage_min = ::std::option::Option::None;
    }

    pub fn has_damage_min(&self) -> bool {
        self.damage_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_min(&mut self, v: u32) {
        self.damage_min = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_max = 25;

    pub fn damage_max(&self) -> u32 {
        self.damage_max.unwrap_or(0)
    }

    pub fn clear_damage_max(&mut self) {
        self.damage_max = ::std::option::Option::None;
    }

    pub fn has_damage_max(&self) -> bool {
        self.damage_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_max(&mut self, v: u32) {
        self.damage_max = ::std::option::Option::Some(v);
    }

    // optional float attack_rate = 26;

    pub fn attack_rate(&self) -> f32 {
        self.attack_rate.unwrap_or(0.)
    }

    pub fn clear_attack_rate(&mut self) {
        self.attack_rate = ::std::option::Option::None;
    }

    pub fn has_attack_rate(&self) -> bool {
        self.attack_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_rate(&mut self, v: f32) {
        self.attack_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 attack_range = 27;

    pub fn attack_range(&self) -> u32 {
        self.attack_range.unwrap_or(0)
    }

    pub fn clear_attack_range(&mut self) {
        self.attack_range = ::std::option::Option::None;
    }

    pub fn has_attack_range(&self) -> bool {
        self.attack_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_range(&mut self, v: u32) {
        self.attack_range = ::std::option::Option::Some(v);
    }

    // optional uint32 projectile_speed = 28;

    pub fn projectile_speed(&self) -> u32 {
        self.projectile_speed.unwrap_or(0)
    }

    pub fn clear_projectile_speed(&mut self) {
        self.projectile_speed = ::std::option::Option::None;
    }

    pub fn has_projectile_speed(&self) -> bool {
        self.projectile_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projectile_speed(&mut self, v: u32) {
        self.projectile_speed = ::std::option::Option::Some(v);
    }

    // optional float armor = 29;

    pub fn armor(&self) -> f32 {
        self.armor.unwrap_or(0.)
    }

    pub fn clear_armor(&mut self) {
        self.armor = ::std::option::Option::None;
    }

    pub fn has_armor(&self) -> bool {
        self.armor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor(&mut self, v: f32) {
        self.armor = ::std::option::Option::Some(v);
    }

    // optional uint32 magic_resistance = 30;

    pub fn magic_resistance(&self) -> u32 {
        self.magic_resistance.unwrap_or(0)
    }

    pub fn clear_magic_resistance(&mut self) {
        self.magic_resistance = ::std::option::Option::None;
    }

    pub fn has_magic_resistance(&self) -> bool {
        self.magic_resistance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic_resistance(&mut self, v: u32) {
        self.magic_resistance = ::std::option::Option::Some(v);
    }

    // optional uint32 movement_speed = 31;

    pub fn movement_speed(&self) -> u32 {
        self.movement_speed.unwrap_or(0)
    }

    pub fn clear_movement_speed(&mut self) {
        self.movement_speed = ::std::option::Option::None;
    }

    pub fn has_movement_speed(&self) -> bool {
        self.movement_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movement_speed(&mut self, v: u32) {
        self.movement_speed = ::std::option::Option::Some(v);
    }

    // optional float turn_rate = 32;

    pub fn turn_rate(&self) -> f32 {
        self.turn_rate.unwrap_or(0.)
    }

    pub fn clear_turn_rate(&mut self) {
        self.turn_rate = ::std::option::Option::None;
    }

    pub fn has_turn_rate(&self) -> bool {
        self.turn_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_rate(&mut self, v: f32) {
        self.turn_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 sight_range_day = 33;

    pub fn sight_range_day(&self) -> u32 {
        self.sight_range_day.unwrap_or(0)
    }

    pub fn clear_sight_range_day(&mut self) {
        self.sight_range_day = ::std::option::Option::None;
    }

    pub fn has_sight_range_day(&self) -> bool {
        self.sight_range_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sight_range_day(&mut self, v: u32) {
        self.sight_range_day = ::std::option::Option::Some(v);
    }

    // optional uint32 sight_range_night = 34;

    pub fn sight_range_night(&self) -> u32 {
        self.sight_range_night.unwrap_or(0)
    }

    pub fn clear_sight_range_night(&mut self) {
        self.sight_range_night = ::std::option::Option::None;
    }

    pub fn has_sight_range_night(&self) -> bool {
        self.sight_range_night.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sight_range_night(&mut self, v: u32) {
        self.sight_range_night = ::std::option::Option::Some(v);
    }

    // optional uint32 max_health = 35;

    pub fn max_health(&self) -> u32 {
        self.max_health.unwrap_or(0)
    }

    pub fn clear_max_health(&mut self) {
        self.max_health = ::std::option::Option::None;
    }

    pub fn has_max_health(&self) -> bool {
        self.max_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_health(&mut self, v: u32) {
        self.max_health = ::std::option::Option::Some(v);
    }

    // optional float health_regen = 36;

    pub fn health_regen(&self) -> f32 {
        self.health_regen.unwrap_or(0.)
    }

    pub fn clear_health_regen(&mut self) {
        self.health_regen = ::std::option::Option::None;
    }

    pub fn has_health_regen(&self) -> bool {
        self.health_regen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_regen(&mut self, v: f32) {
        self.health_regen = ::std::option::Option::Some(v);
    }

    // optional uint32 max_mana = 37;

    pub fn max_mana(&self) -> u32 {
        self.max_mana.unwrap_or(0)
    }

    pub fn clear_max_mana(&mut self) {
        self.max_mana = ::std::option::Option::None;
    }

    pub fn has_max_mana(&self) -> bool {
        self.max_mana.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_mana(&mut self, v: u32) {
        self.max_mana = ::std::option::Option::Some(v);
    }

    // optional float mana_regen = 38;

    pub fn mana_regen(&self) -> f32 {
        self.mana_regen.unwrap_or(0.)
    }

    pub fn clear_mana_regen(&mut self) {
        self.mana_regen = ::std::option::Option::None;
    }

    pub fn has_mana_regen(&self) -> bool {
        self.mana_regen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mana_regen(&mut self, v: f32) {
        self.mana_regen = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(34);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgGameDataHero| { &m.id },
            |m: &mut CMsgGameDataHero| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgGameDataHero| { &m.name },
            |m: &mut CMsgGameDataHero| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "order_id",
            |m: &CMsgGameDataHero| { &m.order_id },
            |m: &mut CMsgGameDataHero| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_loc",
            |m: &CMsgGameDataHero| { &m.name_loc },
            |m: &mut CMsgGameDataHero| { &mut m.name_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bio_loc",
            |m: &CMsgGameDataHero| { &m.bio_loc },
            |m: &mut CMsgGameDataHero| { &mut m.bio_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hype_loc",
            |m: &CMsgGameDataHero| { &m.hype_loc },
            |m: &mut CMsgGameDataHero| { &mut m.hype_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "npe_desc_loc",
            |m: &CMsgGameDataHero| { &m.npe_desc_loc },
            |m: &mut CMsgGameDataHero| { &mut m.npe_desc_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "str_base",
            |m: &CMsgGameDataHero| { &m.str_base },
            |m: &mut CMsgGameDataHero| { &mut m.str_base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "str_gain",
            |m: &CMsgGameDataHero| { &m.str_gain },
            |m: &mut CMsgGameDataHero| { &mut m.str_gain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "agi_base",
            |m: &CMsgGameDataHero| { &m.agi_base },
            |m: &mut CMsgGameDataHero| { &mut m.agi_base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "agi_gain",
            |m: &CMsgGameDataHero| { &m.agi_gain },
            |m: &mut CMsgGameDataHero| { &mut m.agi_gain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_base",
            |m: &CMsgGameDataHero| { &m.int_base },
            |m: &mut CMsgGameDataHero| { &mut m.int_base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_gain",
            |m: &CMsgGameDataHero| { &m.int_gain },
            |m: &mut CMsgGameDataHero| { &mut m.int_gain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_attr",
            |m: &CMsgGameDataHero| { &m.primary_attr },
            |m: &mut CMsgGameDataHero| { &mut m.primary_attr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "complexity",
            |m: &CMsgGameDataHero| { &m.complexity },
            |m: &mut CMsgGameDataHero| { &mut m.complexity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attack_capability",
            |m: &CMsgGameDataHero| { &m.attack_capability },
            |m: &mut CMsgGameDataHero| { &mut m.attack_capability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_levels",
            |m: &CMsgGameDataHero| { &m.role_levels },
            |m: &mut CMsgGameDataHero| { &mut m.role_levels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_min",
            |m: &CMsgGameDataHero| { &m.damage_min },
            |m: &mut CMsgGameDataHero| { &mut m.damage_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_max",
            |m: &CMsgGameDataHero| { &m.damage_max },
            |m: &mut CMsgGameDataHero| { &mut m.damage_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attack_rate",
            |m: &CMsgGameDataHero| { &m.attack_rate },
            |m: &mut CMsgGameDataHero| { &mut m.attack_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attack_range",
            |m: &CMsgGameDataHero| { &m.attack_range },
            |m: &mut CMsgGameDataHero| { &mut m.attack_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "projectile_speed",
            |m: &CMsgGameDataHero| { &m.projectile_speed },
            |m: &mut CMsgGameDataHero| { &mut m.projectile_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "armor",
            |m: &CMsgGameDataHero| { &m.armor },
            |m: &mut CMsgGameDataHero| { &mut m.armor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "magic_resistance",
            |m: &CMsgGameDataHero| { &m.magic_resistance },
            |m: &mut CMsgGameDataHero| { &mut m.magic_resistance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "movement_speed",
            |m: &CMsgGameDataHero| { &m.movement_speed },
            |m: &mut CMsgGameDataHero| { &mut m.movement_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "turn_rate",
            |m: &CMsgGameDataHero| { &m.turn_rate },
            |m: &mut CMsgGameDataHero| { &mut m.turn_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sight_range_day",
            |m: &CMsgGameDataHero| { &m.sight_range_day },
            |m: &mut CMsgGameDataHero| { &mut m.sight_range_day },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sight_range_night",
            |m: &CMsgGameDataHero| { &m.sight_range_night },
            |m: &mut CMsgGameDataHero| { &mut m.sight_range_night },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_health",
            |m: &CMsgGameDataHero| { &m.max_health },
            |m: &mut CMsgGameDataHero| { &mut m.max_health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health_regen",
            |m: &CMsgGameDataHero| { &m.health_regen },
            |m: &mut CMsgGameDataHero| { &mut m.health_regen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_mana",
            |m: &CMsgGameDataHero| { &m.max_mana },
            |m: &mut CMsgGameDataHero| { &mut m.max_mana },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mana_regen",
            |m: &CMsgGameDataHero| { &m.mana_regen },
            |m: &mut CMsgGameDataHero| { &mut m.mana_regen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abilities",
            |m: &CMsgGameDataHero| { &m.abilities },
            |m: &mut CMsgGameDataHero| { &mut m.abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "talents",
            |m: &CMsgGameDataHero| { &m.talents },
            |m: &mut CMsgGameDataHero| { &mut m.talents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameDataHero>(
            "CMsgGameDataHero",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameDataHero {
    const NAME: &'static str = "CMsgGameDataHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.order_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.name_loc = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.bio_loc = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.hype_loc = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.npe_desc_loc = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.str_base = ::std::option::Option::Some(is.read_uint32()?);
                },
                93 => {
                    self.str_gain = ::std::option::Option::Some(is.read_float()?);
                },
                96 => {
                    self.agi_base = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.agi_gain = ::std::option::Option::Some(is.read_float()?);
                },
                112 => {
                    self.int_base = ::std::option::Option::Some(is.read_uint32()?);
                },
                125 => {
                    self.int_gain = ::std::option::Option::Some(is.read_float()?);
                },
                160 => {
                    self.primary_attr = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.complexity = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.attack_capability = ::std::option::Option::Some(is.read_uint32()?);
                },
                186 => {
                    is.read_repeated_packed_uint32_into(&mut self.role_levels)?;
                },
                184 => {
                    self.role_levels.push(is.read_uint32()?);
                },
                192 => {
                    self.damage_min = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.damage_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                213 => {
                    self.attack_rate = ::std::option::Option::Some(is.read_float()?);
                },
                216 => {
                    self.attack_range = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.projectile_speed = ::std::option::Option::Some(is.read_uint32()?);
                },
                237 => {
                    self.armor = ::std::option::Option::Some(is.read_float()?);
                },
                240 => {
                    self.magic_resistance = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.movement_speed = ::std::option::Option::Some(is.read_uint32()?);
                },
                261 => {
                    self.turn_rate = ::std::option::Option::Some(is.read_float()?);
                },
                264 => {
                    self.sight_range_day = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.sight_range_night = ::std::option::Option::Some(is.read_uint32()?);
                },
                280 => {
                    self.max_health = ::std::option::Option::Some(is.read_uint32()?);
                },
                293 => {
                    self.health_regen = ::std::option::Option::Some(is.read_float()?);
                },
                296 => {
                    self.max_mana = ::std::option::Option::Some(is.read_uint32()?);
                },
                309 => {
                    self.mana_regen = ::std::option::Option::Some(is.read_float()?);
                },
                322 => {
                    self.abilities.push(is.read_message()?);
                },
                330 => {
                    self.talents.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.order_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.name_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bio_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.hype_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.npe_desc_loc.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.str_base {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.str_gain {
            my_size += 1 + 4;
        }
        if let Some(v) = self.agi_base {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.agi_gain {
            my_size += 1 + 4;
        }
        if let Some(v) = self.int_base {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.int_gain {
            my_size += 1 + 4;
        }
        if let Some(v) = self.primary_attr {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.complexity {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.attack_capability {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        for value in &self.role_levels {
            my_size += ::protobuf::rt::uint32_size(23, *value);
        };
        if let Some(v) = self.damage_min {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.damage_max {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.attack_rate {
            my_size += 2 + 4;
        }
        if let Some(v) = self.attack_range {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.projectile_speed {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.armor {
            my_size += 2 + 4;
        }
        if let Some(v) = self.magic_resistance {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.movement_speed {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.turn_rate {
            my_size += 2 + 4;
        }
        if let Some(v) = self.sight_range_day {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.sight_range_night {
            my_size += ::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.max_health {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.health_regen {
            my_size += 2 + 4;
        }
        if let Some(v) = self.max_mana {
            my_size += ::protobuf::rt::uint32_size(37, v);
        }
        if let Some(v) = self.mana_regen {
            my_size += 2 + 4;
        }
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.talents {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.order_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.name_loc.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bio_loc.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.hype_loc.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.npe_desc_loc.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.str_base {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.str_gain {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.agi_base {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.agi_gain {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.int_base {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.int_gain {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.primary_attr {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.complexity {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.attack_capability {
            os.write_uint32(22, v)?;
        }
        for v in &self.role_levels {
            os.write_uint32(23, *v)?;
        };
        if let Some(v) = self.damage_min {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.damage_max {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.attack_rate {
            os.write_float(26, v)?;
        }
        if let Some(v) = self.attack_range {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.projectile_speed {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.armor {
            os.write_float(29, v)?;
        }
        if let Some(v) = self.magic_resistance {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.movement_speed {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.turn_rate {
            os.write_float(32, v)?;
        }
        if let Some(v) = self.sight_range_day {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.sight_range_night {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.max_health {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.health_regen {
            os.write_float(36, v)?;
        }
        if let Some(v) = self.max_mana {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.mana_regen {
            os.write_float(38, v)?;
        }
        for v in &self.abilities {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        };
        for v in &self.talents {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataHero {
        CMsgGameDataHero::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.order_id = ::std::option::Option::None;
        self.name_loc = ::std::option::Option::None;
        self.bio_loc = ::std::option::Option::None;
        self.hype_loc = ::std::option::Option::None;
        self.npe_desc_loc = ::std::option::Option::None;
        self.str_base = ::std::option::Option::None;
        self.str_gain = ::std::option::Option::None;
        self.agi_base = ::std::option::Option::None;
        self.agi_gain = ::std::option::Option::None;
        self.int_base = ::std::option::Option::None;
        self.int_gain = ::std::option::Option::None;
        self.primary_attr = ::std::option::Option::None;
        self.complexity = ::std::option::Option::None;
        self.attack_capability = ::std::option::Option::None;
        self.role_levels.clear();
        self.damage_min = ::std::option::Option::None;
        self.damage_max = ::std::option::Option::None;
        self.attack_rate = ::std::option::Option::None;
        self.attack_range = ::std::option::Option::None;
        self.projectile_speed = ::std::option::Option::None;
        self.armor = ::std::option::Option::None;
        self.magic_resistance = ::std::option::Option::None;
        self.movement_speed = ::std::option::Option::None;
        self.turn_rate = ::std::option::Option::None;
        self.sight_range_day = ::std::option::Option::None;
        self.sight_range_night = ::std::option::Option::None;
        self.max_health = ::std::option::Option::None;
        self.health_regen = ::std::option::Option::None;
        self.max_mana = ::std::option::Option::None;
        self.mana_regen = ::std::option::Option::None;
        self.abilities.clear();
        self.talents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataHero {
        static instance: CMsgGameDataHero = CMsgGameDataHero {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            order_id: ::std::option::Option::None,
            name_loc: ::std::option::Option::None,
            bio_loc: ::std::option::Option::None,
            hype_loc: ::std::option::Option::None,
            npe_desc_loc: ::std::option::Option::None,
            str_base: ::std::option::Option::None,
            str_gain: ::std::option::Option::None,
            agi_base: ::std::option::Option::None,
            agi_gain: ::std::option::Option::None,
            int_base: ::std::option::Option::None,
            int_gain: ::std::option::Option::None,
            primary_attr: ::std::option::Option::None,
            complexity: ::std::option::Option::None,
            attack_capability: ::std::option::Option::None,
            role_levels: ::std::vec::Vec::new(),
            damage_min: ::std::option::Option::None,
            damage_max: ::std::option::Option::None,
            attack_rate: ::std::option::Option::None,
            attack_range: ::std::option::Option::None,
            projectile_speed: ::std::option::Option::None,
            armor: ::std::option::Option::None,
            magic_resistance: ::std::option::Option::None,
            movement_speed: ::std::option::Option::None,
            turn_rate: ::std::option::Option::None,
            sight_range_day: ::std::option::Option::None,
            sight_range_night: ::std::option::Option::None,
            max_health: ::std::option::Option::None,
            health_regen: ::std::option::Option::None,
            max_mana: ::std::option::Option::None,
            mana_regen: ::std::option::Option::None,
            abilities: ::std::vec::Vec::new(),
            talents: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameDataHero {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameDataHero").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameDataHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameDataHero {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameDataAbilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataAbilities {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameDataAbilities.abilities)
    pub abilities: ::std::vec::Vec<CMsgGameDataAbilityOrItem>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameDataAbilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataAbilities {
    fn default() -> &'a CMsgGameDataAbilities {
        <CMsgGameDataAbilities as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataAbilities {
    pub fn new() -> CMsgGameDataAbilities {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abilities",
            |m: &CMsgGameDataAbilities| { &m.abilities },
            |m: &mut CMsgGameDataAbilities| { &mut m.abilities },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameDataAbilities>(
            "CMsgGameDataAbilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameDataAbilities {
    const NAME: &'static str = "CMsgGameDataAbilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.abilities.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.abilities {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataAbilities {
        CMsgGameDataAbilities::new()
    }

    fn clear(&mut self) {
        self.abilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataAbilities {
        static instance: CMsgGameDataAbilities = CMsgGameDataAbilities {
            abilities: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameDataAbilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameDataAbilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameDataAbilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameDataAbilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameDataItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataItems {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameDataItems.items)
    pub items: ::std::vec::Vec<CMsgGameDataAbilityOrItem>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameDataItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataItems {
    fn default() -> &'a CMsgGameDataItems {
        <CMsgGameDataItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataItems {
    pub fn new() -> CMsgGameDataItems {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgGameDataItems| { &m.items },
            |m: &mut CMsgGameDataItems| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameDataItems>(
            "CMsgGameDataItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameDataItems {
    const NAME: &'static str = "CMsgGameDataItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataItems {
        CMsgGameDataItems::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataItems {
        static instance: CMsgGameDataItems = CMsgGameDataItems {
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameDataItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameDataItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameDataItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameDataItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameDataHeroes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataHeroes {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameDataHeroes.heroes)
    pub heroes: ::std::vec::Vec<CMsgGameDataHero>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameDataHeroes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataHeroes {
    fn default() -> &'a CMsgGameDataHeroes {
        <CMsgGameDataHeroes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataHeroes {
    pub fn new() -> CMsgGameDataHeroes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "heroes",
            |m: &CMsgGameDataHeroes| { &m.heroes },
            |m: &mut CMsgGameDataHeroes| { &mut m.heroes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameDataHeroes>(
            "CMsgGameDataHeroes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameDataHeroes {
    const NAME: &'static str = "CMsgGameDataHeroes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.heroes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.heroes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataHeroes {
        CMsgGameDataHeroes::new()
    }

    fn clear(&mut self) {
        self.heroes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataHeroes {
        static instance: CMsgGameDataHeroes = CMsgGameDataHeroes {
            heroes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameDataHeroes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameDataHeroes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameDataHeroes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameDataHeroes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGameDataHeroList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataHeroList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameDataHeroList.heroes)
    pub heroes: ::std::vec::Vec<cmsg_game_data_hero_list::HeroInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameDataHeroList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataHeroList {
    fn default() -> &'a CMsgGameDataHeroList {
        <CMsgGameDataHeroList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataHeroList {
    pub fn new() -> CMsgGameDataHeroList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "heroes",
            |m: &CMsgGameDataHeroList| { &m.heroes },
            |m: &mut CMsgGameDataHeroList| { &mut m.heroes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameDataHeroList>(
            "CMsgGameDataHeroList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameDataHeroList {
    const NAME: &'static str = "CMsgGameDataHeroList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.heroes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.heroes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataHeroList {
        CMsgGameDataHeroList::new()
    }

    fn clear(&mut self) {
        self.heroes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataHeroList {
        static instance: CMsgGameDataHeroList = CMsgGameDataHeroList {
            heroes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameDataHeroList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameDataHeroList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameDataHeroList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameDataHeroList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameDataHeroList`
pub mod cmsg_game_data_hero_list {
    // @@protoc_insertion_point(message:dota.CMsgGameDataHeroList.HeroInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGameDataHeroList.HeroInfo.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameDataHeroList.HeroInfo.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGameDataHeroList.HeroInfo.name_loc)
        pub name_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGameDataHeroList.HeroInfo.name_english_loc)
        pub name_english_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGameDataHeroList.HeroInfo.primary_attr)
        pub primary_attr: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGameDataHeroList.HeroInfo.complexity)
        pub complexity: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGameDataHeroList.HeroInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroInfo {
        fn default() -> &'a HeroInfo {
            <HeroInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl HeroInfo {
        pub fn new() -> HeroInfo {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name_loc = 3;

        pub fn name_loc(&self) -> &str {
            match self.name_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_loc(&mut self) {
            self.name_loc = ::std::option::Option::None;
        }

        pub fn has_name_loc(&self) -> bool {
            self.name_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_loc(&mut self, v: ::std::string::String) {
            self.name_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_loc(&mut self) -> &mut ::std::string::String {
            if self.name_loc.is_none() {
                self.name_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_loc(&mut self) -> ::std::string::String {
            self.name_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name_english_loc = 4;

        pub fn name_english_loc(&self) -> &str {
            match self.name_english_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_english_loc(&mut self) {
            self.name_english_loc = ::std::option::Option::None;
        }

        pub fn has_name_english_loc(&self) -> bool {
            self.name_english_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_english_loc(&mut self, v: ::std::string::String) {
            self.name_english_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_english_loc(&mut self) -> &mut ::std::string::String {
            if self.name_english_loc.is_none() {
                self.name_english_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_english_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_english_loc(&mut self) -> ::std::string::String {
            self.name_english_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 primary_attr = 5;

        pub fn primary_attr(&self) -> u32 {
            self.primary_attr.unwrap_or(0)
        }

        pub fn clear_primary_attr(&mut self) {
            self.primary_attr = ::std::option::Option::None;
        }

        pub fn has_primary_attr(&self) -> bool {
            self.primary_attr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_attr(&mut self, v: u32) {
            self.primary_attr = ::std::option::Option::Some(v);
        }

        // optional uint32 complexity = 6;

        pub fn complexity(&self) -> u32 {
            self.complexity.unwrap_or(0)
        }

        pub fn clear_complexity(&mut self) {
            self.complexity = ::std::option::Option::None;
        }

        pub fn has_complexity(&self) -> bool {
            self.complexity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_complexity(&mut self, v: u32) {
            self.complexity = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &HeroInfo| { &m.id },
                |m: &mut HeroInfo| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &HeroInfo| { &m.name },
                |m: &mut HeroInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_loc",
                |m: &HeroInfo| { &m.name_loc },
                |m: &mut HeroInfo| { &mut m.name_loc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_english_loc",
                |m: &HeroInfo| { &m.name_english_loc },
                |m: &mut HeroInfo| { &mut m.name_english_loc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "primary_attr",
                |m: &HeroInfo| { &m.primary_attr },
                |m: &mut HeroInfo| { &mut m.primary_attr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "complexity",
                |m: &HeroInfo| { &m.complexity },
                |m: &mut HeroInfo| { &mut m.complexity },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeroInfo>(
                "CMsgGameDataHeroList.HeroInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HeroInfo {
        const NAME: &'static str = "HeroInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.name_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.name_english_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.primary_attr = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.complexity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.name_loc.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.name_english_loc.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.primary_attr {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.complexity {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.name_loc.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.name_english_loc.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.primary_attr {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.complexity {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroInfo {
            HeroInfo::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.name_loc = ::std::option::Option::None;
            self.name_english_loc = ::std::option::Option::None;
            self.primary_attr = ::std::option::Option::None;
            self.complexity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroInfo {
            static instance: HeroInfo = HeroInfo {
                id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                name_loc: ::std::option::Option::None,
                name_english_loc: ::std::option::Option::None,
                primary_attr: ::std::option::Option::None,
                complexity: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HeroInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameDataHeroList.HeroInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HeroInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HeroInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGameDataItemAbilityList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataItemAbilityList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGameDataItemAbilityList.itemabilities)
    pub itemabilities: ::std::vec::Vec<cmsg_game_data_item_ability_list::ItemAbilityInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGameDataItemAbilityList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataItemAbilityList {
    fn default() -> &'a CMsgGameDataItemAbilityList {
        <CMsgGameDataItemAbilityList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataItemAbilityList {
    pub fn new() -> CMsgGameDataItemAbilityList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "itemabilities",
            |m: &CMsgGameDataItemAbilityList| { &m.itemabilities },
            |m: &mut CMsgGameDataItemAbilityList| { &mut m.itemabilities },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameDataItemAbilityList>(
            "CMsgGameDataItemAbilityList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameDataItemAbilityList {
    const NAME: &'static str = "CMsgGameDataItemAbilityList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.itemabilities.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.itemabilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.itemabilities {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataItemAbilityList {
        CMsgGameDataItemAbilityList::new()
    }

    fn clear(&mut self) {
        self.itemabilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataItemAbilityList {
        static instance: CMsgGameDataItemAbilityList = CMsgGameDataItemAbilityList {
            itemabilities: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameDataItemAbilityList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameDataItemAbilityList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameDataItemAbilityList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameDataItemAbilityList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameDataItemAbilityList`
pub mod cmsg_game_data_item_ability_list {
    // @@protoc_insertion_point(message:dota.CMsgGameDataItemAbilityList.ItemAbilityInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemAbilityInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGameDataItemAbilityList.ItemAbilityInfo.id)
        pub id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgGameDataItemAbilityList.ItemAbilityInfo.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGameDataItemAbilityList.ItemAbilityInfo.name_loc)
        pub name_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGameDataItemAbilityList.ItemAbilityInfo.name_english_loc)
        pub name_english_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgGameDataItemAbilityList.ItemAbilityInfo.neutral_item_tier)
        pub neutral_item_tier: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGameDataItemAbilityList.ItemAbilityInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemAbilityInfo {
        fn default() -> &'a ItemAbilityInfo {
            <ItemAbilityInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemAbilityInfo {
        pub fn new() -> ItemAbilityInfo {
            ::std::default::Default::default()
        }

        // optional int32 id = 1;

        pub fn id(&self) -> i32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: i32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name_loc = 3;

        pub fn name_loc(&self) -> &str {
            match self.name_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_loc(&mut self) {
            self.name_loc = ::std::option::Option::None;
        }

        pub fn has_name_loc(&self) -> bool {
            self.name_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_loc(&mut self, v: ::std::string::String) {
            self.name_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_loc(&mut self) -> &mut ::std::string::String {
            if self.name_loc.is_none() {
                self.name_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_loc(&mut self) -> ::std::string::String {
            self.name_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name_english_loc = 4;

        pub fn name_english_loc(&self) -> &str {
            match self.name_english_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_english_loc(&mut self) {
            self.name_english_loc = ::std::option::Option::None;
        }

        pub fn has_name_english_loc(&self) -> bool {
            self.name_english_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_english_loc(&mut self, v: ::std::string::String) {
            self.name_english_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_english_loc(&mut self) -> &mut ::std::string::String {
            if self.name_english_loc.is_none() {
                self.name_english_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_english_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_english_loc(&mut self) -> ::std::string::String {
            self.name_english_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 neutral_item_tier = 5;

        pub fn neutral_item_tier(&self) -> i32 {
            self.neutral_item_tier.unwrap_or(0)
        }

        pub fn clear_neutral_item_tier(&mut self) {
            self.neutral_item_tier = ::std::option::Option::None;
        }

        pub fn has_neutral_item_tier(&self) -> bool {
            self.neutral_item_tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_neutral_item_tier(&mut self, v: i32) {
            self.neutral_item_tier = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &ItemAbilityInfo| { &m.id },
                |m: &mut ItemAbilityInfo| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &ItemAbilityInfo| { &m.name },
                |m: &mut ItemAbilityInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_loc",
                |m: &ItemAbilityInfo| { &m.name_loc },
                |m: &mut ItemAbilityInfo| { &mut m.name_loc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_english_loc",
                |m: &ItemAbilityInfo| { &m.name_english_loc },
                |m: &mut ItemAbilityInfo| { &mut m.name_english_loc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "neutral_item_tier",
                |m: &ItemAbilityInfo| { &m.neutral_item_tier },
                |m: &mut ItemAbilityInfo| { &mut m.neutral_item_tier },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemAbilityInfo>(
                "CMsgGameDataItemAbilityList.ItemAbilityInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemAbilityInfo {
        const NAME: &'static str = "ItemAbilityInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.name_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.name_english_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.neutral_item_tier = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.name_loc.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.name_english_loc.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.neutral_item_tier {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.name_loc.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.name_english_loc.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.neutral_item_tier {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemAbilityInfo {
            ItemAbilityInfo::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.name_loc = ::std::option::Option::None;
            self.name_english_loc = ::std::option::Option::None;
            self.neutral_item_tier = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemAbilityInfo {
            static instance: ItemAbilityInfo = ItemAbilityInfo {
                id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                name_loc: ::std::option::Option::None,
                name_english_loc: ::std::option::Option::None,
                neutral_item_tier: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemAbilityInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameDataItemAbilityList.ItemAbilityInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemAbilityInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemAbilityInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgLobbyAbilityDraftData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyAbilityDraftData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgLobbyAbilityDraftData.shuffle_draft_order)
    pub shuffle_draft_order: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgLobbyAbilityDraftData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyAbilityDraftData {
    fn default() -> &'a CMsgLobbyAbilityDraftData {
        <CMsgLobbyAbilityDraftData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyAbilityDraftData {
    pub fn new() -> CMsgLobbyAbilityDraftData {
        ::std::default::Default::default()
    }

    // optional bool shuffle_draft_order = 1;

    pub fn shuffle_draft_order(&self) -> bool {
        self.shuffle_draft_order.unwrap_or(false)
    }

    pub fn clear_shuffle_draft_order(&mut self) {
        self.shuffle_draft_order = ::std::option::Option::None;
    }

    pub fn has_shuffle_draft_order(&self) -> bool {
        self.shuffle_draft_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shuffle_draft_order(&mut self, v: bool) {
        self.shuffle_draft_order = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shuffle_draft_order",
            |m: &CMsgLobbyAbilityDraftData| { &m.shuffle_draft_order },
            |m: &mut CMsgLobbyAbilityDraftData| { &mut m.shuffle_draft_order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLobbyAbilityDraftData>(
            "CMsgLobbyAbilityDraftData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLobbyAbilityDraftData {
    const NAME: &'static str = "CMsgLobbyAbilityDraftData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shuffle_draft_order = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shuffle_draft_order {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shuffle_draft_order {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyAbilityDraftData {
        CMsgLobbyAbilityDraftData::new()
    }

    fn clear(&mut self) {
        self.shuffle_draft_order = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyAbilityDraftData {
        static instance: CMsgLobbyAbilityDraftData = CMsgLobbyAbilityDraftData {
            shuffle_draft_order: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLobbyAbilityDraftData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLobbyAbilityDraftData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLobbyAbilityDraftData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyAbilityDraftData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSOEconItemDropRateBonus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemDropRateBonus {
    // message fields
    // @@protoc_insertion_point(field:dota.CSOEconItemDropRateBonus.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemDropRateBonus.expiration_date)
    pub expiration_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemDropRateBonus.bonus)
    pub bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemDropRateBonus.bonus_count)
    pub bonus_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemDropRateBonus.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSOEconItemDropRateBonus.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemDropRateBonus.seconds_left)
    pub seconds_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemDropRateBonus.booster_type)
    pub booster_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSOEconItemDropRateBonus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemDropRateBonus {
    fn default() -> &'a CSOEconItemDropRateBonus {
        <CSOEconItemDropRateBonus as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemDropRateBonus {
    pub fn new() -> CSOEconItemDropRateBonus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_date = 2;

    pub fn expiration_date(&self) -> u32 {
        self.expiration_date.unwrap_or(0)
    }

    pub fn clear_expiration_date(&mut self) {
        self.expiration_date = ::std::option::Option::None;
    }

    pub fn has_expiration_date(&self) -> bool {
        self.expiration_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_date(&mut self, v: u32) {
        self.expiration_date = ::std::option::Option::Some(v);
    }

    // optional float bonus = 3;

    pub fn bonus(&self) -> f32 {
        self.bonus.unwrap_or(0.)
    }

    pub fn clear_bonus(&mut self) {
        self.bonus = ::std::option::Option::None;
    }

    pub fn has_bonus(&self) -> bool {
        self.bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus(&mut self, v: f32) {
        self.bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_count = 4;

    pub fn bonus_count(&self) -> u32 {
        self.bonus_count.unwrap_or(0)
    }

    pub fn clear_bonus_count(&mut self) {
        self.bonus_count = ::std::option::Option::None;
    }

    pub fn has_bonus_count(&self) -> bool {
        self.bonus_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_count(&mut self, v: u32) {
        self.bonus_count = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 5;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 6;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_left = 7;

    pub fn seconds_left(&self) -> u32 {
        self.seconds_left.unwrap_or(0)
    }

    pub fn clear_seconds_left(&mut self) {
        self.seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        self.seconds_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: u32) {
        self.seconds_left = ::std::option::Option::Some(v);
    }

    // optional uint32 booster_type = 8;

    pub fn booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconItemDropRateBonus| { &m.account_id },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_date",
            |m: &CSOEconItemDropRateBonus| { &m.expiration_date },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.expiration_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus",
            |m: &CSOEconItemDropRateBonus| { &m.bonus },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.bonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_count",
            |m: &CSOEconItemDropRateBonus| { &m.bonus_count },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.bonus_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CSOEconItemDropRateBonus| { &m.item_id },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOEconItemDropRateBonus| { &m.def_index },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_left",
            |m: &CSOEconItemDropRateBonus| { &m.seconds_left },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.seconds_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "booster_type",
            |m: &CSOEconItemDropRateBonus| { &m.booster_type },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.booster_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemDropRateBonus>(
            "CSOEconItemDropRateBonus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemDropRateBonus {
    const NAME: &'static str = "CSOEconItemDropRateBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.expiration_date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.bonus = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.bonus_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.seconds_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.booster_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.expiration_date {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bonus_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.seconds_left {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.booster_type {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_date {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.bonus {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.bonus_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.seconds_left {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemDropRateBonus {
        CSOEconItemDropRateBonus::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.expiration_date = ::std::option::Option::None;
        self.bonus = ::std::option::Option::None;
        self.bonus_count = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.seconds_left = ::std::option::Option::None;
        self.booster_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemDropRateBonus {
        static instance: CSOEconItemDropRateBonus = CSOEconItemDropRateBonus {
            account_id: ::std::option::Option::None,
            expiration_date: ::std::option::Option::None,
            bonus: ::std::option::Option::None,
            bonus_count: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            seconds_left: ::std::option::Option::None,
            booster_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemDropRateBonus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemDropRateBonus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemDropRateBonus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemDropRateBonus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CSOEconItemTournamentPassport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemTournamentPassport {
    // message fields
    // @@protoc_insertion_point(field:dota.CSOEconItemTournamentPassport.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemTournamentPassport.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemTournamentPassport.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CSOEconItemTournamentPassport.original_purchaser_id)
    pub original_purchaser_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemTournamentPassport.passports_bought)
    pub passports_bought: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemTournamentPassport.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemTournamentPassport.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CSOEconItemTournamentPassport.reward_flags)
    pub reward_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CSOEconItemTournamentPassport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemTournamentPassport {
    fn default() -> &'a CSOEconItemTournamentPassport {
        <CSOEconItemTournamentPassport as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemTournamentPassport {
    pub fn new() -> CSOEconItemTournamentPassport {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 2;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 original_purchaser_id = 4;

    pub fn original_purchaser_id(&self) -> u32 {
        self.original_purchaser_id.unwrap_or(0)
    }

    pub fn clear_original_purchaser_id(&mut self) {
        self.original_purchaser_id = ::std::option::Option::None;
    }

    pub fn has_original_purchaser_id(&self) -> bool {
        self.original_purchaser_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_purchaser_id(&mut self, v: u32) {
        self.original_purchaser_id = ::std::option::Option::Some(v);
    }

    // optional uint32 passports_bought = 5;

    pub fn passports_bought(&self) -> u32 {
        self.passports_bought.unwrap_or(0)
    }

    pub fn clear_passports_bought(&mut self) {
        self.passports_bought = ::std::option::Option::None;
    }

    pub fn has_passports_bought(&self) -> bool {
        self.passports_bought.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passports_bought(&mut self, v: u32) {
        self.passports_bought = ::std::option::Option::Some(v);
    }

    // optional uint32 version = 6;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 7;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_flags = 8;

    pub fn reward_flags(&self) -> u32 {
        self.reward_flags.unwrap_or(0)
    }

    pub fn clear_reward_flags(&mut self) {
        self.reward_flags = ::std::option::Option::None;
    }

    pub fn has_reward_flags(&self) -> bool {
        self.reward_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_flags(&mut self, v: u32) {
        self.reward_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconItemTournamentPassport| { &m.account_id },
            |m: &mut CSOEconItemTournamentPassport| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CSOEconItemTournamentPassport| { &m.league_id },
            |m: &mut CSOEconItemTournamentPassport| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CSOEconItemTournamentPassport| { &m.item_id },
            |m: &mut CSOEconItemTournamentPassport| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_purchaser_id",
            |m: &CSOEconItemTournamentPassport| { &m.original_purchaser_id },
            |m: &mut CSOEconItemTournamentPassport| { &mut m.original_purchaser_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passports_bought",
            |m: &CSOEconItemTournamentPassport| { &m.passports_bought },
            |m: &mut CSOEconItemTournamentPassport| { &mut m.passports_bought },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CSOEconItemTournamentPassport| { &m.version },
            |m: &mut CSOEconItemTournamentPassport| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOEconItemTournamentPassport| { &m.def_index },
            |m: &mut CSOEconItemTournamentPassport| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_flags",
            |m: &CSOEconItemTournamentPassport| { &m.reward_flags },
            |m: &mut CSOEconItemTournamentPassport| { &mut m.reward_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemTournamentPassport>(
            "CSOEconItemTournamentPassport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemTournamentPassport {
    const NAME: &'static str = "CSOEconItemTournamentPassport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.original_purchaser_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.passports_bought = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.reward_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.original_purchaser_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.passports_bought {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.reward_flags {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.original_purchaser_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.passports_bought {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.reward_flags {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemTournamentPassport {
        CSOEconItemTournamentPassport::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.original_purchaser_id = ::std::option::Option::None;
        self.passports_bought = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.reward_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemTournamentPassport {
        static instance: CSOEconItemTournamentPassport = CSOEconItemTournamentPassport {
            account_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            original_purchaser_id: ::std::option::Option::None,
            passports_bought: ::std::option::Option::None,
            version: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            reward_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemTournamentPassport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemTournamentPassport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemTournamentPassport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemTournamentPassport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgStickerbookSticker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerbookSticker {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.sticker_num)
    pub sticker_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.position_x)
    pub position_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.position_y)
    pub position_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.position_z)
    pub position_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.rotation)
    pub rotation: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.source_item_id)
    pub source_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookSticker.depth_bias)
    pub depth_bias: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgStickerbookSticker.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerbookSticker {
    fn default() -> &'a CMsgStickerbookSticker {
        <CMsgStickerbookSticker as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerbookSticker {
    pub fn new() -> CMsgStickerbookSticker {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sticker_num = 2;

    pub fn sticker_num(&self) -> u32 {
        self.sticker_num.unwrap_or(0)
    }

    pub fn clear_sticker_num(&mut self) {
        self.sticker_num = ::std::option::Option::None;
    }

    pub fn has_sticker_num(&self) -> bool {
        self.sticker_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_num(&mut self, v: u32) {
        self.sticker_num = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 3;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional float position_x = 4;

    pub fn position_x(&self) -> f32 {
        self.position_x.unwrap_or(0.)
    }

    pub fn clear_position_x(&mut self) {
        self.position_x = ::std::option::Option::None;
    }

    pub fn has_position_x(&self) -> bool {
        self.position_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_x(&mut self, v: f32) {
        self.position_x = ::std::option::Option::Some(v);
    }

    // optional float position_y = 5;

    pub fn position_y(&self) -> f32 {
        self.position_y.unwrap_or(0.)
    }

    pub fn clear_position_y(&mut self) {
        self.position_y = ::std::option::Option::None;
    }

    pub fn has_position_y(&self) -> bool {
        self.position_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_y(&mut self, v: f32) {
        self.position_y = ::std::option::Option::Some(v);
    }

    // optional float position_z = 8;

    pub fn position_z(&self) -> f32 {
        self.position_z.unwrap_or(0.)
    }

    pub fn clear_position_z(&mut self) {
        self.position_z = ::std::option::Option::None;
    }

    pub fn has_position_z(&self) -> bool {
        self.position_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_z(&mut self, v: f32) {
        self.position_z = ::std::option::Option::Some(v);
    }

    // optional float rotation = 6;

    pub fn rotation(&self) -> f32 {
        self.rotation.unwrap_or(0.)
    }

    pub fn clear_rotation(&mut self) {
        self.rotation = ::std::option::Option::None;
    }

    pub fn has_rotation(&self) -> bool {
        self.rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation(&mut self, v: f32) {
        self.rotation = ::std::option::Option::Some(v);
    }

    // optional float scale = 7;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional uint64 source_item_id = 9;

    pub fn source_item_id(&self) -> u64 {
        self.source_item_id.unwrap_or(0)
    }

    pub fn clear_source_item_id(&mut self) {
        self.source_item_id = ::std::option::Option::None;
    }

    pub fn has_source_item_id(&self) -> bool {
        self.source_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_item_id(&mut self, v: u64) {
        self.source_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 depth_bias = 10;

    pub fn depth_bias(&self) -> u32 {
        self.depth_bias.unwrap_or(0)
    }

    pub fn clear_depth_bias(&mut self) {
        self.depth_bias = ::std::option::Option::None;
    }

    pub fn has_depth_bias(&self) -> bool {
        self.depth_bias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depth_bias(&mut self, v: u32) {
        self.depth_bias = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_id",
            |m: &CMsgStickerbookSticker| { &m.item_def_id },
            |m: &mut CMsgStickerbookSticker| { &mut m.item_def_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sticker_num",
            |m: &CMsgStickerbookSticker| { &m.sticker_num },
            |m: &mut CMsgStickerbookSticker| { &mut m.sticker_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CMsgStickerbookSticker| { &m.quality },
            |m: &mut CMsgStickerbookSticker| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position_x",
            |m: &CMsgStickerbookSticker| { &m.position_x },
            |m: &mut CMsgStickerbookSticker| { &mut m.position_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position_y",
            |m: &CMsgStickerbookSticker| { &m.position_y },
            |m: &mut CMsgStickerbookSticker| { &mut m.position_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position_z",
            |m: &CMsgStickerbookSticker| { &m.position_z },
            |m: &mut CMsgStickerbookSticker| { &mut m.position_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rotation",
            |m: &CMsgStickerbookSticker| { &m.rotation },
            |m: &mut CMsgStickerbookSticker| { &mut m.rotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgStickerbookSticker| { &m.scale },
            |m: &mut CMsgStickerbookSticker| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_item_id",
            |m: &CMsgStickerbookSticker| { &m.source_item_id },
            |m: &mut CMsgStickerbookSticker| { &mut m.source_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depth_bias",
            |m: &CMsgStickerbookSticker| { &m.depth_bias },
            |m: &mut CMsgStickerbookSticker| { &mut m.depth_bias },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStickerbookSticker>(
            "CMsgStickerbookSticker",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStickerbookSticker {
    const NAME: &'static str = "CMsgStickerbookSticker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.sticker_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.position_x = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.position_y = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.position_z = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.rotation = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.source_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.depth_bias = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sticker_num {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.position_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.position_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.position_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rotation {
            my_size += 1 + 4;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.source_item_id {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.depth_bias {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sticker_num {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.position_x {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.position_y {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.position_z {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.rotation {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.source_item_id {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.depth_bias {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerbookSticker {
        CMsgStickerbookSticker::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.sticker_num = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.position_x = ::std::option::Option::None;
        self.position_y = ::std::option::Option::None;
        self.position_z = ::std::option::Option::None;
        self.rotation = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.source_item_id = ::std::option::Option::None;
        self.depth_bias = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerbookSticker {
        static instance: CMsgStickerbookSticker = CMsgStickerbookSticker {
            item_def_id: ::std::option::Option::None,
            sticker_num: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            position_x: ::std::option::Option::None,
            position_y: ::std::option::Option::None,
            position_z: ::std::option::Option::None,
            rotation: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            source_item_id: ::std::option::Option::None,
            depth_bias: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStickerbookSticker {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStickerbookSticker").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStickerbookSticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStickerbookSticker {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgStickerbookPage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerbookPage {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgStickerbookPage.page_num)
    pub page_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookPage.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookPage.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookPage.stickers)
    pub stickers: ::std::vec::Vec<CMsgStickerbookSticker>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbookPage.page_type)
    pub page_type: ::std::option::Option<::protobuf::EnumOrUnknown<EStickerbookPageType>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgStickerbookPage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerbookPage {
    fn default() -> &'a CMsgStickerbookPage {
        <CMsgStickerbookPage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerbookPage {
    pub fn new() -> CMsgStickerbookPage {
        ::std::default::Default::default()
    }

    // optional uint32 page_num = 1;

    pub fn page_num(&self) -> u32 {
        self.page_num.unwrap_or(0)
    }

    pub fn clear_page_num(&mut self) {
        self.page_num = ::std::option::Option::None;
    }

    pub fn has_page_num(&self) -> bool {
        self.page_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_num(&mut self, v: u32) {
        self.page_num = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 team_id = 3;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EStickerbookPageType page_type = 5;

    pub fn page_type(&self) -> EStickerbookPageType {
        match self.page_type {
            Some(e) => e.enum_value_or(EStickerbookPageType::STICKER_PAGE_GENERIC),
            None => EStickerbookPageType::STICKER_PAGE_GENERIC,
        }
    }

    pub fn clear_page_type(&mut self) {
        self.page_type = ::std::option::Option::None;
    }

    pub fn has_page_type(&self) -> bool {
        self.page_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_type(&mut self, v: EStickerbookPageType) {
        self.page_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_num",
            |m: &CMsgStickerbookPage| { &m.page_num },
            |m: &mut CMsgStickerbookPage| { &mut m.page_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgStickerbookPage| { &m.event_id },
            |m: &mut CMsgStickerbookPage| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CMsgStickerbookPage| { &m.team_id },
            |m: &mut CMsgStickerbookPage| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stickers",
            |m: &CMsgStickerbookPage| { &m.stickers },
            |m: &mut CMsgStickerbookPage| { &mut m.stickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_type",
            |m: &CMsgStickerbookPage| { &m.page_type },
            |m: &mut CMsgStickerbookPage| { &mut m.page_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStickerbookPage>(
            "CMsgStickerbookPage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStickerbookPage {
    const NAME: &'static str = "CMsgStickerbookPage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.page_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.stickers.push(is.read_message()?);
                },
                40 => {
                    self.page_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.page_num {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.stickers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.page_type {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.page_num {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.stickers {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.page_type {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerbookPage {
        CMsgStickerbookPage::new()
    }

    fn clear(&mut self) {
        self.page_num = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.stickers.clear();
        self.page_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerbookPage {
        static instance: CMsgStickerbookPage = CMsgStickerbookPage {
            page_num: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            stickers: ::std::vec::Vec::new(),
            page_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStickerbookPage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStickerbookPage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStickerbookPage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStickerbookPage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgStickerbookTeamPageOrderSequence)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerbookTeamPageOrderSequence {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgStickerbookTeamPageOrderSequence.page_numbers)
    pub page_numbers: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgStickerbookTeamPageOrderSequence.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerbookTeamPageOrderSequence {
    fn default() -> &'a CMsgStickerbookTeamPageOrderSequence {
        <CMsgStickerbookTeamPageOrderSequence as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerbookTeamPageOrderSequence {
    pub fn new() -> CMsgStickerbookTeamPageOrderSequence {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "page_numbers",
            |m: &CMsgStickerbookTeamPageOrderSequence| { &m.page_numbers },
            |m: &mut CMsgStickerbookTeamPageOrderSequence| { &mut m.page_numbers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStickerbookTeamPageOrderSequence>(
            "CMsgStickerbookTeamPageOrderSequence",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStickerbookTeamPageOrderSequence {
    const NAME: &'static str = "CMsgStickerbookTeamPageOrderSequence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.page_numbers)?;
                },
                8 => {
                    self.page_numbers.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.page_numbers {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.page_numbers {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerbookTeamPageOrderSequence {
        CMsgStickerbookTeamPageOrderSequence::new()
    }

    fn clear(&mut self) {
        self.page_numbers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerbookTeamPageOrderSequence {
        static instance: CMsgStickerbookTeamPageOrderSequence = CMsgStickerbookTeamPageOrderSequence {
            page_numbers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStickerbookTeamPageOrderSequence {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStickerbookTeamPageOrderSequence").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStickerbookTeamPageOrderSequence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStickerbookTeamPageOrderSequence {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgStickerbook)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerbook {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgStickerbook.pages)
    pub pages: ::std::vec::Vec<CMsgStickerbookPage>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbook.team_page_order_sequence)
    pub team_page_order_sequence: ::protobuf::MessageField<CMsgStickerbookTeamPageOrderSequence>,
    // @@protoc_insertion_point(field:dota.CMsgStickerbook.favorite_page_num)
    pub favorite_page_num: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgStickerbook.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerbook {
    fn default() -> &'a CMsgStickerbook {
        <CMsgStickerbook as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerbook {
    pub fn new() -> CMsgStickerbook {
        ::std::default::Default::default()
    }

    // optional uint32 favorite_page_num = 3;

    pub fn favorite_page_num(&self) -> u32 {
        self.favorite_page_num.unwrap_or(0)
    }

    pub fn clear_favorite_page_num(&mut self) {
        self.favorite_page_num = ::std::option::Option::None;
    }

    pub fn has_favorite_page_num(&self) -> bool {
        self.favorite_page_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_page_num(&mut self, v: u32) {
        self.favorite_page_num = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pages",
            |m: &CMsgStickerbook| { &m.pages },
            |m: &mut CMsgStickerbook| { &mut m.pages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgStickerbookTeamPageOrderSequence>(
            "team_page_order_sequence",
            |m: &CMsgStickerbook| { &m.team_page_order_sequence },
            |m: &mut CMsgStickerbook| { &mut m.team_page_order_sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "favorite_page_num",
            |m: &CMsgStickerbook| { &m.favorite_page_num },
            |m: &mut CMsgStickerbook| { &mut m.favorite_page_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStickerbook>(
            "CMsgStickerbook",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStickerbook {
    const NAME: &'static str = "CMsgStickerbook";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pages.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.team_page_order_sequence)?;
                },
                24 => {
                    self.favorite_page_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.team_page_order_sequence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.favorite_page_num {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.team_page_order_sequence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.favorite_page_num {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerbook {
        CMsgStickerbook::new()
    }

    fn clear(&mut self) {
        self.pages.clear();
        self.team_page_order_sequence.clear();
        self.favorite_page_num = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerbook {
        static instance: CMsgStickerbook = CMsgStickerbook {
            pages: ::std::vec::Vec::new(),
            team_page_order_sequence: ::protobuf::MessageField::none(),
            favorite_page_num: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStickerbook {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStickerbook").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStickerbook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStickerbook {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgStickerHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerHero {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgStickerHero.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerHero.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerHero.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgStickerHero.source_item_id)
    pub source_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgStickerHero.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerHero {
    fn default() -> &'a CMsgStickerHero {
        <CMsgStickerHero as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerHero {
    pub fn new() -> CMsgStickerHero {
        ::std::default::Default::default()
    }

    // optional uint32 hero_id = 1;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def_id = 2;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 3;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint64 source_item_id = 4;

    pub fn source_item_id(&self) -> u64 {
        self.source_item_id.unwrap_or(0)
    }

    pub fn clear_source_item_id(&mut self) {
        self.source_item_id = ::std::option::Option::None;
    }

    pub fn has_source_item_id(&self) -> bool {
        self.source_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_item_id(&mut self, v: u64) {
        self.source_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgStickerHero| { &m.hero_id },
            |m: &mut CMsgStickerHero| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_id",
            |m: &CMsgStickerHero| { &m.item_def_id },
            |m: &mut CMsgStickerHero| { &mut m.item_def_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CMsgStickerHero| { &m.quality },
            |m: &mut CMsgStickerHero| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_item_id",
            |m: &CMsgStickerHero| { &m.source_item_id },
            |m: &mut CMsgStickerHero| { &mut m.source_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStickerHero>(
            "CMsgStickerHero",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStickerHero {
    const NAME: &'static str = "CMsgStickerHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.source_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.source_item_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_def_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.source_item_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerHero {
        CMsgStickerHero::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.item_def_id = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.source_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerHero {
        static instance: CMsgStickerHero = CMsgStickerHero {
            hero_id: ::std::option::Option::None,
            item_def_id: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            source_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStickerHero {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStickerHero").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStickerHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStickerHero {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgStickerHeroes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerHeroes {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgStickerHeroes.heroes)
    pub heroes: ::std::vec::Vec<CMsgStickerHero>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgStickerHeroes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerHeroes {
    fn default() -> &'a CMsgStickerHeroes {
        <CMsgStickerHeroes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerHeroes {
    pub fn new() -> CMsgStickerHeroes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "heroes",
            |m: &CMsgStickerHeroes| { &m.heroes },
            |m: &mut CMsgStickerHeroes| { &mut m.heroes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStickerHeroes>(
            "CMsgStickerHeroes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStickerHeroes {
    const NAME: &'static str = "CMsgStickerHeroes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.heroes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.heroes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerHeroes {
        CMsgStickerHeroes::new()
    }

    fn clear(&mut self) {
        self.heroes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerHeroes {
        static instance: CMsgStickerHeroes = CMsgStickerHeroes {
            heroes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStickerHeroes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStickerHeroes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStickerHeroes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStickerHeroes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgHeroRoleStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroRoleStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleStats.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleStats.match_count)
    pub match_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleStats.win_count)
    pub win_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgHeroRoleStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroRoleStats {
    fn default() -> &'a CMsgHeroRoleStats {
        <CMsgHeroRoleStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroRoleStats {
    pub fn new() -> CMsgHeroRoleStats {
        ::std::default::Default::default()
    }

    // optional uint32 lane_selection_flags = 1;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 match_count = 2;

    pub fn match_count(&self) -> u32 {
        self.match_count.unwrap_or(0)
    }

    pub fn clear_match_count(&mut self) {
        self.match_count = ::std::option::Option::None;
    }

    pub fn has_match_count(&self) -> bool {
        self.match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_count(&mut self, v: u32) {
        self.match_count = ::std::option::Option::Some(v);
    }

    // optional uint32 win_count = 3;

    pub fn win_count(&self) -> u32 {
        self.win_count.unwrap_or(0)
    }

    pub fn clear_win_count(&mut self) {
        self.win_count = ::std::option::Option::None;
    }

    pub fn has_win_count(&self) -> bool {
        self.win_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_count(&mut self, v: u32) {
        self.win_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane_selection_flags",
            |m: &CMsgHeroRoleStats| { &m.lane_selection_flags },
            |m: &mut CMsgHeroRoleStats| { &mut m.lane_selection_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_count",
            |m: &CMsgHeroRoleStats| { &m.match_count },
            |m: &mut CMsgHeroRoleStats| { &mut m.match_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "win_count",
            |m: &CMsgHeroRoleStats| { &m.win_count },
            |m: &mut CMsgHeroRoleStats| { &mut m.win_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHeroRoleStats>(
            "CMsgHeroRoleStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHeroRoleStats {
    const NAME: &'static str = "CMsgHeroRoleStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.win_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lane_selection_flags {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.win_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.win_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroRoleStats {
        CMsgHeroRoleStats::new()
    }

    fn clear(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
        self.match_count = ::std::option::Option::None;
        self.win_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroRoleStats {
        static instance: CMsgHeroRoleStats = CMsgHeroRoleStats {
            lane_selection_flags: ::std::option::Option::None,
            match_count: ::std::option::Option::None,
            win_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHeroRoleStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHeroRoleStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHeroRoleStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHeroRoleStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgHeroRoleHeroStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroRoleHeroStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleHeroStats.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleHeroStats.role_stats)
    pub role_stats: ::std::vec::Vec<CMsgHeroRoleStats>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgHeroRoleHeroStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroRoleHeroStats {
    fn default() -> &'a CMsgHeroRoleHeroStats {
        <CMsgHeroRoleHeroStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroRoleHeroStats {
    pub fn new() -> CMsgHeroRoleHeroStats {
        ::std::default::Default::default()
    }

    // optional uint32 hero_id = 1;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgHeroRoleHeroStats| { &m.hero_id },
            |m: &mut CMsgHeroRoleHeroStats| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_stats",
            |m: &CMsgHeroRoleHeroStats| { &m.role_stats },
            |m: &mut CMsgHeroRoleHeroStats| { &mut m.role_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHeroRoleHeroStats>(
            "CMsgHeroRoleHeroStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHeroRoleHeroStats {
    const NAME: &'static str = "CMsgHeroRoleHeroStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.role_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.role_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.role_stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroRoleHeroStats {
        CMsgHeroRoleHeroStats::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.role_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroRoleHeroStats {
        static instance: CMsgHeroRoleHeroStats = CMsgHeroRoleHeroStats {
            hero_id: ::std::option::Option::None,
            role_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHeroRoleHeroStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHeroRoleHeroStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHeroRoleHeroStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHeroRoleHeroStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgHeroRoleRankStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroRoleRankStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleRankStats.rank_tier)
    pub rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleRankStats.hero_stats)
    pub hero_stats: ::std::vec::Vec<CMsgHeroRoleHeroStats>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgHeroRoleRankStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroRoleRankStats {
    fn default() -> &'a CMsgHeroRoleRankStats {
        <CMsgHeroRoleRankStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroRoleRankStats {
    pub fn new() -> CMsgHeroRoleRankStats {
        ::std::default::Default::default()
    }

    // optional uint32 rank_tier = 1;

    pub fn rank_tier(&self) -> u32 {
        self.rank_tier.unwrap_or(0)
    }

    pub fn clear_rank_tier(&mut self) {
        self.rank_tier = ::std::option::Option::None;
    }

    pub fn has_rank_tier(&self) -> bool {
        self.rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_tier(&mut self, v: u32) {
        self.rank_tier = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_tier",
            |m: &CMsgHeroRoleRankStats| { &m.rank_tier },
            |m: &mut CMsgHeroRoleRankStats| { &mut m.rank_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hero_stats",
            |m: &CMsgHeroRoleRankStats| { &m.hero_stats },
            |m: &mut CMsgHeroRoleRankStats| { &mut m.hero_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHeroRoleRankStats>(
            "CMsgHeroRoleRankStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHeroRoleRankStats {
    const NAME: &'static str = "CMsgHeroRoleRankStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.hero_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rank_tier {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.hero_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rank_tier {
            os.write_uint32(1, v)?;
        }
        for v in &self.hero_stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroRoleRankStats {
        CMsgHeroRoleRankStats::new()
    }

    fn clear(&mut self) {
        self.rank_tier = ::std::option::Option::None;
        self.hero_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroRoleRankStats {
        static instance: CMsgHeroRoleRankStats = CMsgHeroRoleRankStats {
            rank_tier: ::std::option::Option::None,
            hero_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHeroRoleRankStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHeroRoleRankStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHeroRoleRankStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHeroRoleRankStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgHeroRoleAllRanksStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroRoleAllRanksStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleAllRanksStats.start_timestamp)
    pub start_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleAllRanksStats.end_timestamp)
    pub end_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgHeroRoleAllRanksStats.rank_stats)
    pub rank_stats: ::std::vec::Vec<CMsgHeroRoleRankStats>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgHeroRoleAllRanksStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroRoleAllRanksStats {
    fn default() -> &'a CMsgHeroRoleAllRanksStats {
        <CMsgHeroRoleAllRanksStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroRoleAllRanksStats {
    pub fn new() -> CMsgHeroRoleAllRanksStats {
        ::std::default::Default::default()
    }

    // optional uint32 start_timestamp = 1;

    pub fn start_timestamp(&self) -> u32 {
        self.start_timestamp.unwrap_or(0)
    }

    pub fn clear_start_timestamp(&mut self) {
        self.start_timestamp = ::std::option::Option::None;
    }

    pub fn has_start_timestamp(&self) -> bool {
        self.start_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp(&mut self, v: u32) {
        self.start_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 end_timestamp = 2;

    pub fn end_timestamp(&self) -> u32 {
        self.end_timestamp.unwrap_or(0)
    }

    pub fn clear_end_timestamp(&mut self) {
        self.end_timestamp = ::std::option::Option::None;
    }

    pub fn has_end_timestamp(&self) -> bool {
        self.end_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_timestamp(&mut self, v: u32) {
        self.end_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_timestamp",
            |m: &CMsgHeroRoleAllRanksStats| { &m.start_timestamp },
            |m: &mut CMsgHeroRoleAllRanksStats| { &mut m.start_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_timestamp",
            |m: &CMsgHeroRoleAllRanksStats| { &m.end_timestamp },
            |m: &mut CMsgHeroRoleAllRanksStats| { &mut m.end_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rank_stats",
            |m: &CMsgHeroRoleAllRanksStats| { &m.rank_stats },
            |m: &mut CMsgHeroRoleAllRanksStats| { &mut m.rank_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHeroRoleAllRanksStats>(
            "CMsgHeroRoleAllRanksStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHeroRoleAllRanksStats {
    const NAME: &'static str = "CMsgHeroRoleAllRanksStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.end_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.rank_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_timestamp {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.end_timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.rank_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.end_timestamp {
            os.write_uint32(2, v)?;
        }
        for v in &self.rank_stats {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroRoleAllRanksStats {
        CMsgHeroRoleAllRanksStats::new()
    }

    fn clear(&mut self) {
        self.start_timestamp = ::std::option::Option::None;
        self.end_timestamp = ::std::option::Option::None;
        self.rank_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroRoleAllRanksStats {
        static instance: CMsgHeroRoleAllRanksStats = CMsgHeroRoleAllRanksStats {
            start_timestamp: ::std::option::Option::None,
            end_timestamp: ::std::option::Option::None,
            rank_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHeroRoleAllRanksStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHeroRoleAllRanksStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHeroRoleAllRanksStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHeroRoleAllRanksStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgMapStatsSnapshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMapStatsSnapshot {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.famangos_gained)
    pub famangos_gained: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.wisdom_runes_gained)
    pub wisdom_runes_gained: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.roshan_kills_day)
    pub roshan_kills_day: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.roshan_kills_night)
    pub roshan_kills_night: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.portals_used)
    pub portals_used: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.lanterns_lit)
    pub lanterns_lit: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.miniboss_kills)
    pub miniboss_kills: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.outposts_captured)
    pub outposts_captured: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgMapStatsSnapshot.shield_runes_gained)
    pub shield_runes_gained: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgMapStatsSnapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMapStatsSnapshot {
    fn default() -> &'a CMsgMapStatsSnapshot {
        <CMsgMapStatsSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMapStatsSnapshot {
    pub fn new() -> CMsgMapStatsSnapshot {
        ::std::default::Default::default()
    }

    // optional uint32 timestamp = 1;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 famangos_gained = 2;

    pub fn famangos_gained(&self) -> u64 {
        self.famangos_gained.unwrap_or(0)
    }

    pub fn clear_famangos_gained(&mut self) {
        self.famangos_gained = ::std::option::Option::None;
    }

    pub fn has_famangos_gained(&self) -> bool {
        self.famangos_gained.is_some()
    }

    // Param is passed by value, moved
    pub fn set_famangos_gained(&mut self, v: u64) {
        self.famangos_gained = ::std::option::Option::Some(v);
    }

    // optional uint64 wisdom_runes_gained = 3;

    pub fn wisdom_runes_gained(&self) -> u64 {
        self.wisdom_runes_gained.unwrap_or(0)
    }

    pub fn clear_wisdom_runes_gained(&mut self) {
        self.wisdom_runes_gained = ::std::option::Option::None;
    }

    pub fn has_wisdom_runes_gained(&self) -> bool {
        self.wisdom_runes_gained.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wisdom_runes_gained(&mut self, v: u64) {
        self.wisdom_runes_gained = ::std::option::Option::Some(v);
    }

    // optional uint64 roshan_kills_day = 4;

    pub fn roshan_kills_day(&self) -> u64 {
        self.roshan_kills_day.unwrap_or(0)
    }

    pub fn clear_roshan_kills_day(&mut self) {
        self.roshan_kills_day = ::std::option::Option::None;
    }

    pub fn has_roshan_kills_day(&self) -> bool {
        self.roshan_kills_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_kills_day(&mut self, v: u64) {
        self.roshan_kills_day = ::std::option::Option::Some(v);
    }

    // optional uint64 roshan_kills_night = 5;

    pub fn roshan_kills_night(&self) -> u64 {
        self.roshan_kills_night.unwrap_or(0)
    }

    pub fn clear_roshan_kills_night(&mut self) {
        self.roshan_kills_night = ::std::option::Option::None;
    }

    pub fn has_roshan_kills_night(&self) -> bool {
        self.roshan_kills_night.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_kills_night(&mut self, v: u64) {
        self.roshan_kills_night = ::std::option::Option::Some(v);
    }

    // optional uint64 portals_used = 6;

    pub fn portals_used(&self) -> u64 {
        self.portals_used.unwrap_or(0)
    }

    pub fn clear_portals_used(&mut self) {
        self.portals_used = ::std::option::Option::None;
    }

    pub fn has_portals_used(&self) -> bool {
        self.portals_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portals_used(&mut self, v: u64) {
        self.portals_used = ::std::option::Option::Some(v);
    }

    // optional uint64 lanterns_lit = 7;

    pub fn lanterns_lit(&self) -> u64 {
        self.lanterns_lit.unwrap_or(0)
    }

    pub fn clear_lanterns_lit(&mut self) {
        self.lanterns_lit = ::std::option::Option::None;
    }

    pub fn has_lanterns_lit(&self) -> bool {
        self.lanterns_lit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lanterns_lit(&mut self, v: u64) {
        self.lanterns_lit = ::std::option::Option::Some(v);
    }

    // optional uint64 miniboss_kills = 8;

    pub fn miniboss_kills(&self) -> u64 {
        self.miniboss_kills.unwrap_or(0)
    }

    pub fn clear_miniboss_kills(&mut self) {
        self.miniboss_kills = ::std::option::Option::None;
    }

    pub fn has_miniboss_kills(&self) -> bool {
        self.miniboss_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_miniboss_kills(&mut self, v: u64) {
        self.miniboss_kills = ::std::option::Option::Some(v);
    }

    // optional uint64 outposts_captured = 9;

    pub fn outposts_captured(&self) -> u64 {
        self.outposts_captured.unwrap_or(0)
    }

    pub fn clear_outposts_captured(&mut self) {
        self.outposts_captured = ::std::option::Option::None;
    }

    pub fn has_outposts_captured(&self) -> bool {
        self.outposts_captured.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outposts_captured(&mut self, v: u64) {
        self.outposts_captured = ::std::option::Option::Some(v);
    }

    // optional uint64 shield_runes_gained = 10;

    pub fn shield_runes_gained(&self) -> u64 {
        self.shield_runes_gained.unwrap_or(0)
    }

    pub fn clear_shield_runes_gained(&mut self) {
        self.shield_runes_gained = ::std::option::Option::None;
    }

    pub fn has_shield_runes_gained(&self) -> bool {
        self.shield_runes_gained.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_runes_gained(&mut self, v: u64) {
        self.shield_runes_gained = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgMapStatsSnapshot| { &m.timestamp },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "famangos_gained",
            |m: &CMsgMapStatsSnapshot| { &m.famangos_gained },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.famangos_gained },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wisdom_runes_gained",
            |m: &CMsgMapStatsSnapshot| { &m.wisdom_runes_gained },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.wisdom_runes_gained },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roshan_kills_day",
            |m: &CMsgMapStatsSnapshot| { &m.roshan_kills_day },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.roshan_kills_day },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roshan_kills_night",
            |m: &CMsgMapStatsSnapshot| { &m.roshan_kills_night },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.roshan_kills_night },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "portals_used",
            |m: &CMsgMapStatsSnapshot| { &m.portals_used },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.portals_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lanterns_lit",
            |m: &CMsgMapStatsSnapshot| { &m.lanterns_lit },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.lanterns_lit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "miniboss_kills",
            |m: &CMsgMapStatsSnapshot| { &m.miniboss_kills },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.miniboss_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "outposts_captured",
            |m: &CMsgMapStatsSnapshot| { &m.outposts_captured },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.outposts_captured },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shield_runes_gained",
            |m: &CMsgMapStatsSnapshot| { &m.shield_runes_gained },
            |m: &mut CMsgMapStatsSnapshot| { &mut m.shield_runes_gained },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMapStatsSnapshot>(
            "CMsgMapStatsSnapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMapStatsSnapshot {
    const NAME: &'static str = "CMsgMapStatsSnapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.famangos_gained = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.wisdom_runes_gained = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.roshan_kills_day = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.roshan_kills_night = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.portals_used = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.lanterns_lit = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.miniboss_kills = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.outposts_captured = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.shield_runes_gained = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.famangos_gained {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.wisdom_runes_gained {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.roshan_kills_day {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.roshan_kills_night {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.portals_used {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.lanterns_lit {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.miniboss_kills {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.outposts_captured {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.shield_runes_gained {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.famangos_gained {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.wisdom_runes_gained {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.roshan_kills_day {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.roshan_kills_night {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.portals_used {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.lanterns_lit {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.miniboss_kills {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.outposts_captured {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.shield_runes_gained {
            os.write_uint64(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMapStatsSnapshot {
        CMsgMapStatsSnapshot::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.famangos_gained = ::std::option::Option::None;
        self.wisdom_runes_gained = ::std::option::Option::None;
        self.roshan_kills_day = ::std::option::Option::None;
        self.roshan_kills_night = ::std::option::Option::None;
        self.portals_used = ::std::option::Option::None;
        self.lanterns_lit = ::std::option::Option::None;
        self.miniboss_kills = ::std::option::Option::None;
        self.outposts_captured = ::std::option::Option::None;
        self.shield_runes_gained = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMapStatsSnapshot {
        static instance: CMsgMapStatsSnapshot = CMsgMapStatsSnapshot {
            timestamp: ::std::option::Option::None,
            famangos_gained: ::std::option::Option::None,
            wisdom_runes_gained: ::std::option::Option::None,
            roshan_kills_day: ::std::option::Option::None,
            roshan_kills_night: ::std::option::Option::None,
            portals_used: ::std::option::Option::None,
            lanterns_lit: ::std::option::Option::None,
            miniboss_kills: ::std::option::Option::None,
            outposts_captured: ::std::option::Option::None,
            shield_runes_gained: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMapStatsSnapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMapStatsSnapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMapStatsSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMapStatsSnapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGlobalMapStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGlobalMapStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGlobalMapStats.current)
    pub current: ::protobuf::MessageField<CMsgMapStatsSnapshot>,
    // @@protoc_insertion_point(field:dota.CMsgGlobalMapStats.window_start)
    pub window_start: ::protobuf::MessageField<CMsgMapStatsSnapshot>,
    // @@protoc_insertion_point(field:dota.CMsgGlobalMapStats.window_end)
    pub window_end: ::protobuf::MessageField<CMsgMapStatsSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGlobalMapStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGlobalMapStats {
    fn default() -> &'a CMsgGlobalMapStats {
        <CMsgGlobalMapStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGlobalMapStats {
    pub fn new() -> CMsgGlobalMapStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgMapStatsSnapshot>(
            "current",
            |m: &CMsgGlobalMapStats| { &m.current },
            |m: &mut CMsgGlobalMapStats| { &mut m.current },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgMapStatsSnapshot>(
            "window_start",
            |m: &CMsgGlobalMapStats| { &m.window_start },
            |m: &mut CMsgGlobalMapStats| { &mut m.window_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgMapStatsSnapshot>(
            "window_end",
            |m: &CMsgGlobalMapStats| { &m.window_end },
            |m: &mut CMsgGlobalMapStats| { &mut m.window_end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGlobalMapStats>(
            "CMsgGlobalMapStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGlobalMapStats {
    const NAME: &'static str = "CMsgGlobalMapStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.current)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.window_start)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.window_end)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.window_start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.window_end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.current.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.window_start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.window_end.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGlobalMapStats {
        CMsgGlobalMapStats::new()
    }

    fn clear(&mut self) {
        self.current.clear();
        self.window_start.clear();
        self.window_end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGlobalMapStats {
        static instance: CMsgGlobalMapStats = CMsgGlobalMapStats {
            current: ::protobuf::MessageField::none(),
            window_start: ::protobuf::MessageField::none(),
            window_end: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGlobalMapStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGlobalMapStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGlobalMapStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGlobalMapStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ESpecialPingValue)
pub enum ESpecialPingValue {
    // @@protoc_insertion_point(enum_value:dota.ESpecialPingValue.k_ESpecialPingValue_NoData)
    k_ESpecialPingValue_NoData = 16382,
    // @@protoc_insertion_point(enum_value:dota.ESpecialPingValue.k_ESpecialPingValue_Failed)
    k_ESpecialPingValue_Failed = 16383,
}

impl ::protobuf::Enum for ESpecialPingValue {
    const NAME: &'static str = "ESpecialPingValue";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESpecialPingValue> {
        match value {
            16382 => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_NoData),
            16383 => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_Failed),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESpecialPingValue> {
        match str {
            "k_ESpecialPingValue_NoData" => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_NoData),
            "k_ESpecialPingValue_Failed" => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_Failed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESpecialPingValue] = &[
        ESpecialPingValue::k_ESpecialPingValue_NoData,
        ESpecialPingValue::k_ESpecialPingValue_Failed,
    ];
}

impl ::protobuf::EnumFull for ESpecialPingValue {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESpecialPingValue").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ESpecialPingValue::k_ESpecialPingValue_NoData => 0,
            ESpecialPingValue::k_ESpecialPingValue_Failed => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ESpecialPingValue {
    fn default() -> Self {
        ESpecialPingValue::k_ESpecialPingValue_NoData
    }
}

impl ESpecialPingValue {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESpecialPingValue>("ESpecialPingValue")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDOTAGCSessionNeed)
pub enum EDOTAGCSessionNeed {
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_Unknown)
    k_EDOTAGCSessionNeed_Unknown = 0,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserNoSessionNeeded)
    k_EDOTAGCSessionNeed_UserNoSessionNeeded = 100,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInOnlineGame)
    k_EDOTAGCSessionNeed_UserInOnlineGame = 101,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInLocalGame)
    k_EDOTAGCSessionNeed_UserInLocalGame = 102,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnected)
    k_EDOTAGCSessionNeed_UserInUIWasConnected = 103,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnected)
    k_EDOTAGCSessionNeed_UserInUINeverConnected = 104,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserTutorials)
    k_EDOTAGCSessionNeed_UserTutorials = 105,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle)
    k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle = 106,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle)
    k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle = 107,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerOnline)
    k_EDOTAGCSessionNeed_GameServerOnline = 200,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocal)
    k_EDOTAGCSessionNeed_GameServerLocal = 201,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerIdle)
    k_EDOTAGCSessionNeed_GameServerIdle = 202,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerRelay)
    k_EDOTAGCSessionNeed_GameServerRelay = 203,
    // @@protoc_insertion_point(enum_value:dota.EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocalUpload)
    k_EDOTAGCSessionNeed_GameServerLocalUpload = 204,
}

impl ::protobuf::Enum for EDOTAGCSessionNeed {
    const NAME: &'static str = "EDOTAGCSessionNeed";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAGCSessionNeed> {
        match value {
            0 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown),
            100 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserNoSessionNeeded),
            101 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInOnlineGame),
            102 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInLocalGame),
            103 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnected),
            104 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnected),
            105 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserTutorials),
            106 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle),
            107 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle),
            200 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerOnline),
            201 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocal),
            202 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerIdle),
            203 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerRelay),
            204 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocalUpload),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTAGCSessionNeed> {
        match str {
            "k_EDOTAGCSessionNeed_Unknown" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown),
            "k_EDOTAGCSessionNeed_UserNoSessionNeeded" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserNoSessionNeeded),
            "k_EDOTAGCSessionNeed_UserInOnlineGame" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInOnlineGame),
            "k_EDOTAGCSessionNeed_UserInLocalGame" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInLocalGame),
            "k_EDOTAGCSessionNeed_UserInUIWasConnected" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnected),
            "k_EDOTAGCSessionNeed_UserInUINeverConnected" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnected),
            "k_EDOTAGCSessionNeed_UserTutorials" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserTutorials),
            "k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle),
            "k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle),
            "k_EDOTAGCSessionNeed_GameServerOnline" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerOnline),
            "k_EDOTAGCSessionNeed_GameServerLocal" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocal),
            "k_EDOTAGCSessionNeed_GameServerIdle" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerIdle),
            "k_EDOTAGCSessionNeed_GameServerRelay" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerRelay),
            "k_EDOTAGCSessionNeed_GameServerLocalUpload" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocalUpload),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTAGCSessionNeed] = &[
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserNoSessionNeeded,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInOnlineGame,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInLocalGame,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnected,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnected,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserTutorials,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerOnline,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocal,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerIdle,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerRelay,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocalUpload,
    ];
}

impl ::protobuf::EnumFull for EDOTAGCSessionNeed {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDOTAGCSessionNeed").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown => 0,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserNoSessionNeeded => 1,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInOnlineGame => 2,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInLocalGame => 3,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnected => 4,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnected => 5,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserTutorials => 6,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle => 7,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle => 8,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerOnline => 9,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocal => 10,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerIdle => 11,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerRelay => 12,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocalUpload => 13,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EDOTAGCSessionNeed {
    fn default() -> Self {
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown
    }
}

impl EDOTAGCSessionNeed {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDOTAGCSessionNeed>("EDOTAGCSessionNeed")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDOTAMatchPlayerTimeCustomStat)
pub enum EDOTAMatchPlayerTimeCustomStat {
    // @@protoc_insertion_point(enum_value:dota.EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers)
    k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers = 1,
    // @@protoc_insertion_point(enum_value:dota.EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute)
    k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute = 2,
    // @@protoc_insertion_point(enum_value:dota.EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP)
    k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP = 3,
}

impl ::protobuf::Enum for EDOTAMatchPlayerTimeCustomStat {
    const NAME: &'static str = "EDOTAMatchPlayerTimeCustomStat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAMatchPlayerTimeCustomStat> {
        match value {
            1 => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers),
            2 => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute),
            3 => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTAMatchPlayerTimeCustomStat> {
        match str {
            "k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers" => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers),
            "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute" => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute),
            "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP" => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTAMatchPlayerTimeCustomStat] = &[
        EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers,
        EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute,
        EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP,
    ];
}

impl ::protobuf::EnumFull for EDOTAMatchPlayerTimeCustomStat {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDOTAMatchPlayerTimeCustomStat").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers => 0,
            EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute => 1,
            EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EDOTAMatchPlayerTimeCustomStat {
    fn default() -> Self {
        EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers
    }
}

impl EDOTAMatchPlayerTimeCustomStat {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDOTAMatchPlayerTimeCustomStat>("EDOTAMatchPlayerTimeCustomStat")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_TournamentEvents)
pub enum DOTA_TournamentEvents {
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_FIRST_BLOOD)
    TE_FIRST_BLOOD = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_GAME_END)
    TE_GAME_END = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_MULTI_KILL)
    TE_MULTI_KILL = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_HERO_DENY)
    TE_HERO_DENY = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_AEGIS_DENY)
    TE_AEGIS_DENY = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_AEGIS_STOLEN)
    TE_AEGIS_STOLEN = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_GODLIKE)
    TE_GODLIKE = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_COURIER_KILL)
    TE_COURIER_KILL = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_ECHOSLAM)
    TE_ECHOSLAM = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_RAPIER)
    TE_RAPIER = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_EARLY_ROSHAN)
    TE_EARLY_ROSHAN = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_TournamentEvents.TE_BLACK_HOLE)
    TE_BLACK_HOLE = 11,
}

impl ::protobuf::Enum for DOTA_TournamentEvents {
    const NAME: &'static str = "DOTA_TournamentEvents";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_TournamentEvents> {
        match value {
            0 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_FIRST_BLOOD),
            1 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GAME_END),
            2 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_MULTI_KILL),
            3 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_HERO_DENY),
            4 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_DENY),
            5 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_STOLEN),
            6 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GODLIKE),
            7 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_COURIER_KILL),
            8 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_ECHOSLAM),
            9 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_RAPIER),
            10 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_EARLY_ROSHAN),
            11 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_BLACK_HOLE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_TournamentEvents> {
        match str {
            "TE_FIRST_BLOOD" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_FIRST_BLOOD),
            "TE_GAME_END" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GAME_END),
            "TE_MULTI_KILL" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_MULTI_KILL),
            "TE_HERO_DENY" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_HERO_DENY),
            "TE_AEGIS_DENY" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_DENY),
            "TE_AEGIS_STOLEN" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_STOLEN),
            "TE_GODLIKE" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GODLIKE),
            "TE_COURIER_KILL" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_COURIER_KILL),
            "TE_ECHOSLAM" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_ECHOSLAM),
            "TE_RAPIER" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_RAPIER),
            "TE_EARLY_ROSHAN" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_EARLY_ROSHAN),
            "TE_BLACK_HOLE" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_BLACK_HOLE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_TournamentEvents] = &[
        DOTA_TournamentEvents::TE_FIRST_BLOOD,
        DOTA_TournamentEvents::TE_GAME_END,
        DOTA_TournamentEvents::TE_MULTI_KILL,
        DOTA_TournamentEvents::TE_HERO_DENY,
        DOTA_TournamentEvents::TE_AEGIS_DENY,
        DOTA_TournamentEvents::TE_AEGIS_STOLEN,
        DOTA_TournamentEvents::TE_GODLIKE,
        DOTA_TournamentEvents::TE_COURIER_KILL,
        DOTA_TournamentEvents::TE_ECHOSLAM,
        DOTA_TournamentEvents::TE_RAPIER,
        DOTA_TournamentEvents::TE_EARLY_ROSHAN,
        DOTA_TournamentEvents::TE_BLACK_HOLE,
    ];
}

impl ::protobuf::EnumFull for DOTA_TournamentEvents {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_TournamentEvents").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_TournamentEvents {
    fn default() -> Self {
        DOTA_TournamentEvents::TE_FIRST_BLOOD
    }
}

impl DOTA_TournamentEvents {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_TournamentEvents>("DOTA_TournamentEvents")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EBroadcastTimelineEvent)
pub enum EBroadcastTimelineEvent {
    // @@protoc_insertion_point(enum_value:dota.EBroadcastTimelineEvent.EBroadcastTimelineEvent_MatchStarted)
    EBroadcastTimelineEvent_MatchStarted = 1,
    // @@protoc_insertion_point(enum_value:dota.EBroadcastTimelineEvent.EBroadcastTimelineEvent_GameStateChanged)
    EBroadcastTimelineEvent_GameStateChanged = 2,
    // @@protoc_insertion_point(enum_value:dota.EBroadcastTimelineEvent.EBroadcastTimelineEvent_TowerDeath)
    EBroadcastTimelineEvent_TowerDeath = 3,
    // @@protoc_insertion_point(enum_value:dota.EBroadcastTimelineEvent.EBroadcastTimelineEvent_BarracksDeath)
    EBroadcastTimelineEvent_BarracksDeath = 4,
    // @@protoc_insertion_point(enum_value:dota.EBroadcastTimelineEvent.EBroadcastTimelineEvent_AncientDeath)
    EBroadcastTimelineEvent_AncientDeath = 5,
    // @@protoc_insertion_point(enum_value:dota.EBroadcastTimelineEvent.EBroadcastTimelineEvent_RoshanDeath)
    EBroadcastTimelineEvent_RoshanDeath = 6,
    // @@protoc_insertion_point(enum_value:dota.EBroadcastTimelineEvent.EBroadcastTimelineEvent_HeroDeath)
    EBroadcastTimelineEvent_HeroDeath = 7,
    // @@protoc_insertion_point(enum_value:dota.EBroadcastTimelineEvent.EBroadcastTimelineEvent_TeamFight)
    EBroadcastTimelineEvent_TeamFight = 8,
    // @@protoc_insertion_point(enum_value:dota.EBroadcastTimelineEvent.EBroadcastTimelineEvent_FirstBlood)
    EBroadcastTimelineEvent_FirstBlood = 9,
}

impl ::protobuf::Enum for EBroadcastTimelineEvent {
    const NAME: &'static str = "EBroadcastTimelineEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastTimelineEvent> {
        match value {
            1 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted),
            2 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_GameStateChanged),
            3 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_TowerDeath),
            4 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_BarracksDeath),
            5 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_AncientDeath),
            6 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_RoshanDeath),
            7 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_HeroDeath),
            8 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_TeamFight),
            9 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_FirstBlood),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastTimelineEvent> {
        match str {
            "EBroadcastTimelineEvent_MatchStarted" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted),
            "EBroadcastTimelineEvent_GameStateChanged" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_GameStateChanged),
            "EBroadcastTimelineEvent_TowerDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_TowerDeath),
            "EBroadcastTimelineEvent_BarracksDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_BarracksDeath),
            "EBroadcastTimelineEvent_AncientDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_AncientDeath),
            "EBroadcastTimelineEvent_RoshanDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_RoshanDeath),
            "EBroadcastTimelineEvent_HeroDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_HeroDeath),
            "EBroadcastTimelineEvent_TeamFight" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_TeamFight),
            "EBroadcastTimelineEvent_FirstBlood" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_FirstBlood),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastTimelineEvent] = &[
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_GameStateChanged,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_TowerDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_BarracksDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_AncientDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_RoshanDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_HeroDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_TeamFight,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_FirstBlood,
    ];
}

impl ::protobuf::EnumFull for EBroadcastTimelineEvent {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBroadcastTimelineEvent").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted => 0,
            EBroadcastTimelineEvent::EBroadcastTimelineEvent_GameStateChanged => 1,
            EBroadcastTimelineEvent::EBroadcastTimelineEvent_TowerDeath => 2,
            EBroadcastTimelineEvent::EBroadcastTimelineEvent_BarracksDeath => 3,
            EBroadcastTimelineEvent::EBroadcastTimelineEvent_AncientDeath => 4,
            EBroadcastTimelineEvent::EBroadcastTimelineEvent_RoshanDeath => 5,
            EBroadcastTimelineEvent::EBroadcastTimelineEvent_HeroDeath => 6,
            EBroadcastTimelineEvent::EBroadcastTimelineEvent_TeamFight => 7,
            EBroadcastTimelineEvent::EBroadcastTimelineEvent_FirstBlood => 8,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EBroadcastTimelineEvent {
    fn default() -> Self {
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted
    }
}

impl EBroadcastTimelineEvent {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EBroadcastTimelineEvent>("EBroadcastTimelineEvent")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ECustomGameWhitelistState)
pub enum ECustomGameWhitelistState {
    // @@protoc_insertion_point(enum_value:dota.ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_UNKNOWN)
    CUSTOM_GAME_WHITELIST_STATE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_APPROVED)
    CUSTOM_GAME_WHITELIST_STATE_APPROVED = 1,
    // @@protoc_insertion_point(enum_value:dota.ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_REJECTED)
    CUSTOM_GAME_WHITELIST_STATE_REJECTED = 2,
}

impl ::protobuf::Enum for ECustomGameWhitelistState {
    const NAME: &'static str = "ECustomGameWhitelistState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECustomGameWhitelistState> {
        match value {
            0 => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN),
            1 => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_APPROVED),
            2 => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_REJECTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECustomGameWhitelistState> {
        match str {
            "CUSTOM_GAME_WHITELIST_STATE_UNKNOWN" => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN),
            "CUSTOM_GAME_WHITELIST_STATE_APPROVED" => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_APPROVED),
            "CUSTOM_GAME_WHITELIST_STATE_REJECTED" => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_REJECTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECustomGameWhitelistState] = &[
        ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN,
        ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_APPROVED,
        ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_REJECTED,
    ];
}

impl ::protobuf::EnumFull for ECustomGameWhitelistState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECustomGameWhitelistState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECustomGameWhitelistState {
    fn default() -> Self {
        ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN
    }
}

impl ECustomGameWhitelistState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECustomGameWhitelistState>("ECustomGameWhitelistState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDOTATriviaQuestionCategory)
pub enum EDOTATriviaQuestionCategory {
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityIcon)
    k_EDOTATriviaQuestionCategory_AbilityIcon = 0,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityCooldown)
    k_EDOTATriviaQuestionCategory_AbilityCooldown = 1,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttributes)
    k_EDOTATriviaQuestionCategory_HeroAttributes = 2,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroMovementSpeed)
    k_EDOTATriviaQuestionCategory_HeroMovementSpeed = 3,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_TalentTree)
    k_EDOTATriviaQuestionCategory_TalentTree = 4,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroStats)
    k_EDOTATriviaQuestionCategory_HeroStats = 5,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPrice)
    k_EDOTATriviaQuestionCategory_ItemPrice = 6,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilitySound)
    k_EDOTATriviaQuestionCategory_AbilitySound = 7,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_InvokerSpells)
    k_EDOTATriviaQuestionCategory_InvokerSpells = 8,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityManaCost)
    k_EDOTATriviaQuestionCategory_AbilityManaCost = 9,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttackSound)
    k_EDOTATriviaQuestionCategory_HeroAttackSound = 10,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityName)
    k_EDOTATriviaQuestionCategory_AbilityName = 11,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemComponents)
    k_EDOTATriviaQuestionCategory_ItemComponents = 12,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemLore)
    k_EDOTATriviaQuestionCategory_ItemLore = 13,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPassives)
    k_EDOTATriviaQuestionCategory_ItemPassives = 14,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END)
    k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END = 15,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START)
    k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START = 99,
    // @@protoc_insertion_point(enum_value:dota.EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild)
    k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild = 100,
}

impl ::protobuf::Enum for EDOTATriviaQuestionCategory {
    const NAME: &'static str = "EDOTATriviaQuestionCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTATriviaQuestionCategory> {
        match value {
            0 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon),
            1 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityCooldown),
            2 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttributes),
            3 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroMovementSpeed),
            4 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_TalentTree),
            5 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroStats),
            6 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPrice),
            7 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilitySound),
            8 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_InvokerSpells),
            9 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityManaCost),
            10 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttackSound),
            11 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityName),
            12 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemComponents),
            13 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemLore),
            14 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPassives),
            15 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END),
            99 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START),
            100 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTATriviaQuestionCategory> {
        match str {
            "k_EDOTATriviaQuestionCategory_AbilityIcon" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon),
            "k_EDOTATriviaQuestionCategory_AbilityCooldown" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityCooldown),
            "k_EDOTATriviaQuestionCategory_HeroAttributes" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttributes),
            "k_EDOTATriviaQuestionCategory_HeroMovementSpeed" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroMovementSpeed),
            "k_EDOTATriviaQuestionCategory_TalentTree" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_TalentTree),
            "k_EDOTATriviaQuestionCategory_HeroStats" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroStats),
            "k_EDOTATriviaQuestionCategory_ItemPrice" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPrice),
            "k_EDOTATriviaQuestionCategory_AbilitySound" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilitySound),
            "k_EDOTATriviaQuestionCategory_InvokerSpells" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_InvokerSpells),
            "k_EDOTATriviaQuestionCategory_AbilityManaCost" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityManaCost),
            "k_EDOTATriviaQuestionCategory_HeroAttackSound" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttackSound),
            "k_EDOTATriviaQuestionCategory_AbilityName" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityName),
            "k_EDOTATriviaQuestionCategory_ItemComponents" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemComponents),
            "k_EDOTATriviaQuestionCategory_ItemLore" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemLore),
            "k_EDOTATriviaQuestionCategory_ItemPassives" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPassives),
            "k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END),
            "k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START),
            "k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTATriviaQuestionCategory] = &[
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityCooldown,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttributes,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroMovementSpeed,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_TalentTree,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroStats,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPrice,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilitySound,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_InvokerSpells,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityManaCost,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttackSound,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityName,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemComponents,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemLore,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPassives,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild,
    ];
}

impl ::protobuf::EnumFull for EDOTATriviaQuestionCategory {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDOTATriviaQuestionCategory").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon => 0,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityCooldown => 1,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttributes => 2,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroMovementSpeed => 3,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_TalentTree => 4,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroStats => 5,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPrice => 6,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilitySound => 7,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_InvokerSpells => 8,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityManaCost => 9,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttackSound => 10,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityName => 11,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemComponents => 12,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemLore => 13,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPassives => 14,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END => 15,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START => 16,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild => 17,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EDOTATriviaQuestionCategory {
    fn default() -> Self {
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon
    }
}

impl EDOTATriviaQuestionCategory {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDOTATriviaQuestionCategory>("EDOTATriviaQuestionCategory")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EOverwatchConviction)
pub enum EOverwatchConviction {
    // @@protoc_insertion_point(enum_value:dota.EOverwatchConviction.k_EOverwatchConviction_None)
    k_EOverwatchConviction_None = 0,
    // @@protoc_insertion_point(enum_value:dota.EOverwatchConviction.k_EOverwatchConviction_NotGuilty)
    k_EOverwatchConviction_NotGuilty = 1,
    // @@protoc_insertion_point(enum_value:dota.EOverwatchConviction.k_EOverwatchConviction_GuiltUnclear)
    k_EOverwatchConviction_GuiltUnclear = 2,
    // @@protoc_insertion_point(enum_value:dota.EOverwatchConviction.k_EOverwatchConviction_Guilty)
    k_EOverwatchConviction_Guilty = 3,
}

impl ::protobuf::Enum for EOverwatchConviction {
    const NAME: &'static str = "EOverwatchConviction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOverwatchConviction> {
        match value {
            0 => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_None),
            1 => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_NotGuilty),
            2 => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_GuiltUnclear),
            3 => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_Guilty),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOverwatchConviction> {
        match str {
            "k_EOverwatchConviction_None" => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_None),
            "k_EOverwatchConviction_NotGuilty" => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_NotGuilty),
            "k_EOverwatchConviction_GuiltUnclear" => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_GuiltUnclear),
            "k_EOverwatchConviction_Guilty" => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_Guilty),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOverwatchConviction] = &[
        EOverwatchConviction::k_EOverwatchConviction_None,
        EOverwatchConviction::k_EOverwatchConviction_NotGuilty,
        EOverwatchConviction::k_EOverwatchConviction_GuiltUnclear,
        EOverwatchConviction::k_EOverwatchConviction_Guilty,
    ];
}

impl ::protobuf::EnumFull for EOverwatchConviction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EOverwatchConviction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EOverwatchConviction {
    fn default() -> Self {
        EOverwatchConviction::k_EOverwatchConviction_None
    }
}

impl EOverwatchConviction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EOverwatchConviction>("EOverwatchConviction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EHeroRelicRarity)
pub enum EHeroRelicRarity {
    // @@protoc_insertion_point(enum_value:dota.EHeroRelicRarity.HERO_RELIC_RARITY_INVALID)
    HERO_RELIC_RARITY_INVALID = -1,
    // @@protoc_insertion_point(enum_value:dota.EHeroRelicRarity.HERO_RELIC_RARITY_COMMON)
    HERO_RELIC_RARITY_COMMON = 0,
    // @@protoc_insertion_point(enum_value:dota.EHeroRelicRarity.HERO_RELIC_RARITY_RARE)
    HERO_RELIC_RARITY_RARE = 1,
}

impl ::protobuf::Enum for EHeroRelicRarity {
    const NAME: &'static str = "EHeroRelicRarity";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHeroRelicRarity> {
        match value {
            -1 => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_INVALID),
            0 => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_COMMON),
            1 => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_RARE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHeroRelicRarity> {
        match str {
            "HERO_RELIC_RARITY_INVALID" => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_INVALID),
            "HERO_RELIC_RARITY_COMMON" => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_COMMON),
            "HERO_RELIC_RARITY_RARE" => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_RARE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHeroRelicRarity] = &[
        EHeroRelicRarity::HERO_RELIC_RARITY_INVALID,
        EHeroRelicRarity::HERO_RELIC_RARITY_COMMON,
        EHeroRelicRarity::HERO_RELIC_RARITY_RARE,
    ];
}

impl ::protobuf::EnumFull for EHeroRelicRarity {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EHeroRelicRarity").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EHeroRelicRarity::HERO_RELIC_RARITY_INVALID => 0,
            EHeroRelicRarity::HERO_RELIC_RARITY_COMMON => 1,
            EHeroRelicRarity::HERO_RELIC_RARITY_RARE => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EHeroRelicRarity {
    fn default() -> Self {
        EHeroRelicRarity::HERO_RELIC_RARITY_INVALID
    }
}

impl EHeroRelicRarity {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EHeroRelicRarity>("EHeroRelicRarity")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EStickerbookAuditAction)
pub enum EStickerbookAuditAction {
    // @@protoc_insertion_point(enum_value:dota.EStickerbookAuditAction.STICKERBOOK_AUDIT_CREATE_PAGE)
    STICKERBOOK_AUDIT_CREATE_PAGE = 0,
    // @@protoc_insertion_point(enum_value:dota.EStickerbookAuditAction.STICKERBOOK_AUDIT_DELETE_PAGE)
    STICKERBOOK_AUDIT_DELETE_PAGE = 1,
    // @@protoc_insertion_point(enum_value:dota.EStickerbookAuditAction.STICKERBOOK_AUDIT_STICK_STICKERS)
    STICKERBOOK_AUDIT_STICK_STICKERS = 2,
    // @@protoc_insertion_point(enum_value:dota.EStickerbookAuditAction.STICKERBOOK_AUDIT_REPLACE_STICKERS)
    STICKERBOOK_AUDIT_REPLACE_STICKERS = 3,
    // @@protoc_insertion_point(enum_value:dota.EStickerbookAuditAction.STICKERBOOK_AUDIT_HERO_STICKER)
    STICKERBOOK_AUDIT_HERO_STICKER = 4,
}

impl ::protobuf::Enum for EStickerbookAuditAction {
    const NAME: &'static str = "EStickerbookAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStickerbookAuditAction> {
        match value {
            0 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_CREATE_PAGE),
            1 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_DELETE_PAGE),
            2 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_STICK_STICKERS),
            3 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_REPLACE_STICKERS),
            4 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_HERO_STICKER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStickerbookAuditAction> {
        match str {
            "STICKERBOOK_AUDIT_CREATE_PAGE" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_CREATE_PAGE),
            "STICKERBOOK_AUDIT_DELETE_PAGE" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_DELETE_PAGE),
            "STICKERBOOK_AUDIT_STICK_STICKERS" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_STICK_STICKERS),
            "STICKERBOOK_AUDIT_REPLACE_STICKERS" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_REPLACE_STICKERS),
            "STICKERBOOK_AUDIT_HERO_STICKER" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_HERO_STICKER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStickerbookAuditAction] = &[
        EStickerbookAuditAction::STICKERBOOK_AUDIT_CREATE_PAGE,
        EStickerbookAuditAction::STICKERBOOK_AUDIT_DELETE_PAGE,
        EStickerbookAuditAction::STICKERBOOK_AUDIT_STICK_STICKERS,
        EStickerbookAuditAction::STICKERBOOK_AUDIT_REPLACE_STICKERS,
        EStickerbookAuditAction::STICKERBOOK_AUDIT_HERO_STICKER,
    ];
}

impl ::protobuf::EnumFull for EStickerbookAuditAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStickerbookAuditAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStickerbookAuditAction {
    fn default() -> Self {
        EStickerbookAuditAction::STICKERBOOK_AUDIT_CREATE_PAGE
    }
}

impl EStickerbookAuditAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStickerbookAuditAction>("EStickerbookAuditAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EStickerbookPageType)
pub enum EStickerbookPageType {
    // @@protoc_insertion_point(enum_value:dota.EStickerbookPageType.STICKER_PAGE_GENERIC)
    STICKER_PAGE_GENERIC = 0,
    // @@protoc_insertion_point(enum_value:dota.EStickerbookPageType.STICKER_PAGE_TEAM)
    STICKER_PAGE_TEAM = 1,
    // @@protoc_insertion_point(enum_value:dota.EStickerbookPageType.STICKER_PAGE_TALENT)
    STICKER_PAGE_TALENT = 2,
}

impl ::protobuf::Enum for EStickerbookPageType {
    const NAME: &'static str = "EStickerbookPageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStickerbookPageType> {
        match value {
            0 => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_GENERIC),
            1 => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_TEAM),
            2 => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_TALENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStickerbookPageType> {
        match str {
            "STICKER_PAGE_GENERIC" => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_GENERIC),
            "STICKER_PAGE_TEAM" => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_TEAM),
            "STICKER_PAGE_TALENT" => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_TALENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStickerbookPageType] = &[
        EStickerbookPageType::STICKER_PAGE_GENERIC,
        EStickerbookPageType::STICKER_PAGE_TEAM,
        EStickerbookPageType::STICKER_PAGE_TALENT,
    ];
}

impl ::protobuf::EnumFull for EStickerbookPageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStickerbookPageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStickerbookPageType {
    fn default() -> Self {
        EStickerbookPageType::STICKER_PAGE_GENERIC
    }
}

impl EStickerbookPageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStickerbookPageType>("EStickerbookPageType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cdota_gcmessages_common.proto\x12\x04dota\x1a\x13steammessages.prot\
    o\x1a\x16gcsdk_gcmessages.proto\x1a\x17dota_shared_enums.proto\"\x9e\x17\
    \n\x18CSODOTAGameAccountClient\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountId\x12\x12\n\x04wins\x18\x03\x20\x01(\rR\x04wins\x12\x16\n\x06l\
    osses\x18\x04\x20\x01(\rR\x06losses\x12\x0e\n\x02xp\x18\x0c\x20\x01(\rR\
    \x02xp\x12\x14\n\x05level\x18\r\x20\x01(\rR\x05level\x12#\n\rinitial_ski\
    ll\x18\x0e\x20\x01(\rR\x0cinitialSkill\x12!\n\x0cleaver_count\x18\x0f\
    \x20\x01(\rR\x0bleaverCount\x124\n\x16secondary_leaver_count\x18:\x20\
    \x01(\rR\x14secondaryLeaverCount\x125\n\x17low_priority_until_date\x18\
    \x12\x20\x01(\rR\x14lowPriorityUntilDate\x12>\n\x1cprevent_text_chat_unt\
    il_date\x18\x14\x20\x01(\rR\x18preventTextChatUntilDate\x127\n\x18preven\
    t_voice_until_date\x18\x15\x20\x01(\rR\x15preventVoiceUntilDate\x12K\n#p\
    revent_public_text_chat_until_date\x18V\x20\x01(\rR\x1epreventPublicText\
    ChatUntilDate\x12I\n\"prevent_new_player_chat_until_date\x18z\x20\x01(\r\
    R\x1dpreventNewPlayerChatUntilDate\x127\n\x18last_abandoned_game_date\
    \x18\x16\x20\x01(\rR\x15lastAbandonedGameDate\x12J\n\"last_secondary_aba\
    ndoned_game_date\x18;\x20\x01(\rR\x1elastSecondaryAbandonedGameDate\x120\
    \n\x14leaver_penalty_count\x18\x17\x20\x01(\rR\x12leaverPenaltyCount\x12\
    2\n\x15completed_game_streak\x18\x18\x20\x01(\rR\x13completedGameStreak\
    \x12=\n\x1baccount_disabled_until_date\x18&\x20\x01(\rR\x18accountDisabl\
    edUntilDate\x124\n\x16account_disabled_count\x18'\x20\x01(\rR\x14account\
    DisabledCount\x129\n\x19match_disabled_until_date\x18)\x20\x01(\rR\x16ma\
    tchDisabledUntilDate\x120\n\x14match_disabled_count\x18*\x20\x01(\rR\x12\
    matchDisabledCount\x12D\n\x1dshutdownlawterminatetimestamp\x18/\x20\x01(\
    \rR\x1dshutdownlawterminatetimestamp\x12?\n\x1clow_priority_games_remain\
    ing\x180\x20\x01(\rR\x19lowPriorityGamesRemaining\x12+\n\x11recruitment_\
    level\x187\x20\x01(\rR\x10recruitmentLevel\x122\n\x15has_new_notificatio\
    ns\x188\x20\x01(\x08R\x13hasNewNotifications\x12&\n\x0fis_league_admin\
    \x189\x20\x01(\x08R\risLeagueAdmin\x12.\n\x13casual_games_played\x18<\
    \x20\x01(\rR\x11casualGamesPlayed\x12A\n\x1dsolo_competitive_games_playe\
    d\x18=\x20\x01(\rR\x1asoloCompetitiveGamesPlayed\x12C\n\x1eparty_competi\
    tive_games_played\x18>\x20\x01(\rR\x1bpartyCompetitiveGamesPlayed\x125\n\
    \x17casual_1v1_games_played\x18A\x20\x01(\rR\x14casual1v1GamesPlayed\x12\
    :\n\x1acurr_all_hero_challenge_id\x18C\x20\x01(\rR\x16currAllHeroChallen\
    geId\x12(\n\x10play_time_points\x18D\x20\x01(\rR\x0eplayTimePoints\x12#\
    \n\raccount_flags\x18E\x20\x01(\rR\x0caccountFlags\x12&\n\x0fplay_time_l\
    evel\x18F\x20\x01(\rR\rplayTimeLevel\x12K\n#player_behavior_seq_num_last\
    _report\x18G\x20\x01(\rR\x1eplayerBehaviorSeqNumLastReport\x12H\n!player\
    _behavior_score_last_report\x18H\x20\x01(\rR\x1dplayerBehaviorScoreLastR\
    eport\x12D\n\x1fplayer_behavior_report_old_data\x18I\x20\x01(\x08R\x1bpl\
    ayerBehaviorReportOldData\x12.\n\x13tourney_skill_level\x18J\x20\x01(\rR\
    \x11tourneySkillLevel\x12I\n!tourney_recent_participation_date\x18U\x20\
    \x01(\rR\x1etourneyRecentParticipationDate\x127\n\x18anchored_phone_numb\
    er_id\x18X\x20\x01(\x04R\x15anchoredPhoneNumberId\x12H\n!ranked_matchmak\
    ing_ban_until_date\x18Y\x20\x01(\rR\x1drankedMatchmakingBanUntilDate\x12\
    +\n\x12recent_game_time_1\x18Z\x20\x01(\rR\x0frecentGameTime1\x12+\n\x12\
    recent_game_time_2\x18[\x20\x01(\rR\x0frecentGameTime2\x12+\n\x12recent_\
    game_time_3\x18\\\x20\x01(\rR\x0frecentGameTime3\x120\n\x14favorite_team\
    _packed\x18g\x20\x01(\x04R\x12favoriteTeamPacked\x12,\n\x12recent_report\
    _time\x18h\x20\x01(\rR\x10recentReportTime\x12D\n\x1fcustom_game_disable\
    d_until_date\x18i\x20\x01(\rR\x1bcustomGameDisabledUntilDate\x12)\n\x11r\
    ecent_win_time_1\x18j\x20\x01(\rR\x0erecentWinTime1\x12)\n\x11recent_win\
    _time_2\x18k\x20\x01(\rR\x0erecentWinTime2\x12)\n\x11recent_win_time_3\
    \x18l\x20\x01(\rR\x0erecentWinTime3\x12!\n\x0ccoach_rating\x18m\x20\x01(\
    \rR\x0bcoachRating\x12!\n\x0cqueue_points\x18r\x20\x01(\rR\x0bqueuePoint\
    s\x12R\n\x0erole_handicaps\x18s\x20\x03(\x0b2+.dota.CSODOTAGameAccountCl\
    ient.RoleHandicapR\rroleHandicaps\x123\n\x16event_mode_recent_time\x18x\
    \x20\x01(\rR\x13eventModeRecentTime\x124\n\x16mmr_recalibration_time\x18\
    y\x20\x01(\rR\x14mmrRecalibrationTime\x1a>\n\x0cRoleHandicap\x12\x12\n\
    \x04role\x18\x01\x20\x01(\rR\x04role\x12\x1a\n\x08handicap\x18\x02\x20\
    \x01(\x02R\x08handicap\"\xe1\x02\n\x16CSODOTAGameAccountPlus\x12\x1d\n\n\
    account_id\x18\x01\x20\x01(\rR\taccountId\x12.\n\x13original_start_date\
    \x18\x02\x20\x01(\rR\x11originalStartDate\x12\x1d\n\nplus_flags\x18\x03\
    \x20\x01(\rR\tplusFlags\x12\x1f\n\x0bplus_status\x18\x04\x20\x01(\rR\npl\
    usStatus\x12,\n\x12prepaid_time_start\x18\x05\x20\x01(\rR\x10prepaidTime\
    Start\x120\n\x14prepaid_time_balance\x18\x06\x20\x01(\rR\x12prepaidTimeB\
    alance\x12*\n\x11next_payment_date\x18\x07\x20\x01(\x07R\x0fnextPaymentD\
    ate\x12,\n\x12steam_agreement_id\x18\x08\x20\x01(\x06R\x10steamAgreement\
    Id\"\xec\x01\n!CMsgLobbyFeaturedGamemodeProgress\x12S\n\x08accounts\x18\
    \x01\x20\x03(\x0b27.dota.CMsgLobbyFeaturedGamemodeProgress.AccountProgre\
    ssR\x08accounts\x1ar\n\x0fAccountProgress\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12#\n\rcurrent_value\x18\x02\x20\x01(\rR\x0ccur\
    rentValue\x12\x1b\n\tmax_value\x18\x03\x20\x01(\rR\x08maxValue\"\xa6\x02\
    \n\x14CMsgBattleCupVictory\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\tac\
    countId\x12\x19\n\x08win_date\x18\x02\x20\x01(\rR\x07winDate\x12\x1f\n\
    \x0bvalid_until\x18\x03\x20\x01(\rR\nvalidUntil\x12\x1f\n\x0bskill_level\
    \x18\x04\x20\x01(\rR\nskillLevel\x12#\n\rtournament_id\x18\x05\x20\x01(\
    \rR\x0ctournamentId\x12\x1f\n\x0bdivision_id\x18\x06\x20\x01(\rR\ndivisi\
    onId\x12\x17\n\x07team_id\x18\x07\x20\x01(\rR\x06teamId\x12\x16\n\x06str\
    eak\x18\x08\x20\x01(\rR\x06streak\x12\x1b\n\ttrophy_id\x18\t\x20\x01(\rR\
    \x08trophyId\"U\n\x1dCMsgLobbyBattleCupVictoryList\x124\n\x07winners\x18\
    \x01\x20\x03(\x0b2\x1a.dota.CMsgBattleCupVictoryR\x07winners\"9\n\x1dCMs\
    gDOTABroadcastNotification\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07m\
    essage\"\x97\x02\n\x14CProtoItemHeroStatue\x12\x17\n\x07hero_id\x18\x01\
    \x20\x01(\rR\x06heroId\x12.\n\x13status_effect_index\x18\x02\x20\x01(\rR\
    \x11statusEffectIndex\x12#\n\rsequence_name\x18\x03\x20\x01(\tR\x0cseque\
    nceName\x12\x14\n\x05cycle\x18\x04\x20\x01(\x02R\x05cycle\x12\x1a\n\x08w\
    earable\x18\x05\x20\x03(\rR\x08wearable\x12\x20\n\x0binscription\x18\x06\
    \x20\x01(\tR\x0binscription\x12\x14\n\x05style\x18\x07\x20\x03(\rR\x05st\
    yle\x12'\n\x0ftournament_drop\x18\x08\x20\x01(\x08R\x0etournamentDrop\"J\
    \n\x1aCMatchPlayerAbilityUpgrade\x12\x18\n\x07ability\x18\x01\x20\x01(\
    \x05R\x07ability\x12\x12\n\x04time\x18\x02\x20\x01(\rR\x04time\"m\n\x1bC\
    MatchPlayerTimedCustomStat\x128\n\x04stat\x18\x02\x20\x01(\x0e2$.dota.ED\
    OTAMatchPlayerTimeCustomStatR\x04stat\x12\x14\n\x05value\x18\x03\x20\x01\
    (\x02R\x05value\"\xb9\x0b\n\x16CMatchPlayerTimedStats\x12\x12\n\x04time\
    \x18\x01\x20\x01(\rR\x04time\x12\x14\n\x05kills\x18\x02\x20\x01(\rR\x05k\
    ills\x12\x16\n\x06deaths\x18\x03\x20\x01(\rR\x06deaths\x12\x18\n\x07assi\
    sts\x18\x04\x20\x01(\rR\x07assists\x12\x1b\n\tnet_worth\x18\x05\x20\x01(\
    \rR\x08netWorth\x12\x0e\n\x02xp\x18\x06\x20\x01(\rR\x02xp\x12\x1b\n\tlas\
    t_hits\x18\x07\x20\x01(\rR\x08lastHits\x12\x16\n\x06denies\x18\x08\x20\
    \x01(\rR\x06denies\x12(\n\x10bounty_rune_gold\x18\t\x20\x01(\rR\x0ebount\
    yRuneGold\x127\n\x18range_creep_upgrade_gold\x18\n\x20\x01(\rR\x15rangeC\
    reepUpgradeGold\x126\n\x17observer_wards_dewarded\x18\x0b\x20\x01(\rR\
    \x15observerWardsDewarded\x120\n\x14reliable_gold_earned\x18\x0c\x20\x01\
    (\rR\x12reliableGoldEarned\x12.\n\x13gold_loss_prevented\x18\r\x20\x01(\
    \rR\x11goldLossPrevented\x12$\n\x0ehero_kill_gold\x18\x0e\x20\x01(\rR\
    \x0cheroKillGold\x12&\n\x0fcreep_kill_gold\x18\x0f\x20\x01(\rR\rcreepKil\
    lGold\x12#\n\rbuilding_gold\x18\x10\x20\x01(\rR\x0cbuildingGold\x12\x1d\
    \n\nother_gold\x18\x11\x20\x01(\rR\totherGold\x12#\n\rcomeback_gold\x18\
    \x12\x20\x01(\rR\x0ccomebackGold\x12+\n\x11experimental_gold\x18\x13\x20\
    \x01(\rR\x10experimentalGold\x12-\n\x12experimental2_gold\x18\x14\x20\
    \x01(\rR\x11experimental2Gold\x12&\n\x0fcreep_deny_gold\x18\x15\x20\x01(\
    \rR\rcreepDenyGold\x123\n\x16tp_scrolls_purchased_1\x18\x16\x20\x01(\rR\
    \x13tpScrollsPurchased1\x123\n\x16tp_scrolls_purchased_2\x18\x17\x20\x01\
    (\rR\x13tpScrollsPurchased2\x123\n\x16tp_scrolls_purchased_3\x18\x18\x20\
    \x01(\rR\x13tpScrollsPurchased3\x123\n\x16tp_scrolls_purchased_4\x18\x19\
    \x20\x01(\rR\x13tpScrollsPurchased4\x123\n\x16tp_scrolls_purchased_5\x18\
    \x1a\x20\x01(\rR\x13tpScrollsPurchased5\x12!\n\x0cneutral_gold\x18\x1b\
    \x20\x01(\rR\x0bneutralGold\x12!\n\x0ccourier_gold\x18\x1c\x20\x01(\rR\
    \x0bcourierGold\x12\x1f\n\x0broshan_gold\x18\x1d\x20\x01(\rR\nroshanGold\
    \x12\x1f\n\x0bincome_gold\x18\x1e\x20\x01(\rR\nincomeGold\x12\x1d\n\nite\
    m_value\x18$\x20\x01(\rR\titemValue\x12,\n\x12support_gold_spent\x18%\
    \x20\x01(\rR\x10supportGoldSpent\x12#\n\rcamps_stacked\x18&\x20\x01(\rR\
    \x0ccampsStacked\x12!\n\x0cwards_placed\x18'\x20\x01(\rR\x0bwardsPlaced\
    \x12!\n\x0ctriple_kills\x18(\x20\x01(\rR\x0btripleKills\x12\x1a\n\x08ram\
    pages\x18)\x20\x01(\rR\x08rampages\x12D\n\x0ccustom_stats\x18*\x20\x03(\
    \x0b2!.dota.CMatchPlayerTimedCustomStatR\x0bcustomStats\"\xf2\x01\n\x14C\
    MatchTeamTimedStats\x12\x12\n\x04time\x18\x01\x20\x01(\rR\x04time\x12.\n\
    \x13enemy_towers_killed\x18\x02\x20\x01(\rR\x11enemyTowersKilled\x122\n\
    \x15enemy_barracks_killed\x18\x03\x20\x01(\rR\x13enemyBarracksKilled\x12\
    .\n\x13enemy_towers_status\x18\x04\x20\x01(\rR\x11enemyTowersStatus\x122\
    \n\x15enemy_barracks_status\x18\x05\x20\x01(\rR\x13enemyBarracksStatus\"\
    R\n\x1dCMatchAdditionalUnitInventory\x12\x1b\n\tunit_name\x18\x01\x20\
    \x01(\tR\x08unitName\x12\x14\n\x05items\x18\x02\x20\x03(\x05R\x05items\"\
    \x82\x01\n\x19CMatchPlayerPermanentBuff\x12%\n\x0epermanent_buff\x18\x01\
    \x20\x01(\rR\rpermanentBuff\x12\x1f\n\x0bstack_count\x18\x02\x20\x01(\rR\
    \nstackCount\x12\x1d\n\ngrant_time\x18\x03\x20\x01(\rR\tgrantTime\"]\n\
    \x15CMatchHeroSelectEvent\x12\x17\n\x07is_pick\x18\x01\x20\x01(\x08R\x06\
    isPick\x12\x12\n\x04team\x18\x02\x20\x01(\rR\x04team\x12\x17\n\x07hero_i\
    d\x18\x03\x20\x01(\rR\x06heroId\"\xba\x02\n\nCMatchClip\x12\x19\n\x08mat\
    ch_id\x18\x01\x20\x01(\x04R\x07matchId\x12*\n\x11player_account_id\x18\
    \x02\x20\x01(\rR\x0fplayerAccountId\x12*\n\x11game_time_seconds\x18\x03\
    \x20\x01(\rR\x0fgameTimeSeconds\x12)\n\x10duration_seconds\x18\x04\x20\
    \x01(\rR\x0fdurationSeconds\x12\x1b\n\tplayer_id\x18\x05\x20\x01(\rR\x08\
    playerId\x12\x17\n\x07hero_id\x18\x06\x20\x01(\rR\x06heroId\x12\x1d\n\na\
    bility_id\x18\x07\x20\x01(\x05R\tabilityId\x12\x1f\n\x0bcamera_mode\x18\
    \x08\x20\x01(\rR\ncameraMode\x12\x18\n\x07comment\x18\t\x20\x01(\tR\x07c\
    omment\"z\n\x17CPartySearchClientParty\x12\x19\n\x08party_id\x18\x01\x20\
    \x01(\x06R\x07partyId\x12\x1f\n\x0bbeacon_type\x18\x02\x20\x01(\x05R\nbe\
    aconType\x12#\n\rparty_members\x18\x03\x20\x03(\x07R\x0cpartyMembers\"N\
    \n\x14CMsgDOTAHasItemQuery\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\tac\
    countId\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\"4\n\x17CMs\
    gDOTAHasItemResponse\x12\x19\n\x08has_item\x18\x01\x20\x01(\x08R\x07hasI\
    tem\"\x91\x01\n\x1bCMsgGCGetPlayerCardItemInfo\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12/\n\x14player_card_item_ids\x18\x02\x20\
    \x03(\x04R\x11playerCardItemIds\x12\"\n\rall_for_event\x18\x03\x20\x01(\
    \rR\x0ballForEvent\"\x93\x02\n#CMsgGCGetPlayerCardItemInfoResponse\x12d\
    \n\x11player_card_infos\x18\x01\x20\x03(\x0b28.dota.CMsgGCGetPlayerCardI\
    temInfoResponse.PlayerCardInfoR\x0fplayerCardInfos\x1a\x85\x01\n\x0ePlay\
    erCardInfo\x12-\n\x13player_card_item_id\x18\x01\x20\x01(\x04R\x10player\
    CardItemId\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12%\n\
    \x0epacked_bonuses\x18\x03\x20\x01(\x04R\rpackedBonuses\"w\n\x17CSODOTAM\
    apLocationState\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x1f\n\x0blocation_id\x18\x02\x20\x01(\x05R\nlocationId\x12\x1c\n\tcompl\
    eted\x18\x03\x20\x01(\x08R\tcompleted\"6\n\x13CMsgLeagueAdminList\x12\
    \x1f\n\x0baccount_ids\x18\x01\x20\x03(\rR\naccountIds\"\xe9\x0c\n\x13CMs\
    gDOTAProfileCard\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x124\n\x05slots\x18\x03\x20\x03(\x0b2\x1e.dota.CMsgDOTAProfileCard.Slot\
    R\x05slots\x12!\n\x0cbadge_points\x18\x04\x20\x01(\rR\x0bbadgePoints\x12\
    !\n\x0cevent_points\x18\x05\x20\x01(\rR\x0beventPoints\x12\x19\n\x08even\
    t_id\x18\x06\x20\x01(\rR\x07eventId\x12U\n\x19recent_battle_cup_victory\
    \x18\x07\x20\x01(\x0b2\x1a.dota.CMsgBattleCupVictoryR\x16recentBattleCup\
    Victory\x12\x1b\n\trank_tier\x18\x08\x20\x01(\rR\x08rankTier\x12)\n\x10l\
    eaderboard_rank\x18\t\x20\x01(\rR\x0fleaderboardRank\x12,\n\x12is_plus_s\
    ubscriber\x18\n\x20\x01(\x08R\x10isPlusSubscriber\x127\n\x18plus_origina\
    l_start_date\x18\x0b\x20\x01(\rR\x15plusOriginalStartDate\x12&\n\x0frank\
    _tier_score\x18\x0c\x20\x01(\rR\rrankTierScore\x122\n\x15leaderboard_ran\
    k_core\x18\x11\x20\x01(\rR\x13leaderboardRankCore\x12\x14\n\x05title\x18\
    \x17\x20\x01(\rR\x05title\x120\n\x14favorite_team_packed\x18\x18\x20\x01\
    (\x04R\x12favoriteTeamPacked\x12%\n\x0elifetime_games\x18\x19\x20\x01(\r\
    R\rlifetimeGames\x1a\xab\x06\n\x04Slot\x12\x17\n\x07slot_id\x18\x01\x20\
    \x01(\rR\x06slotId\x12=\n\x06trophy\x18\x02\x20\x01(\x0b2%.dota.CMsgDOTA\
    ProfileCard.Slot.TrophyR\x06trophy\x127\n\x04stat\x18\x03\x20\x01(\x0b2#\
    .dota.CMsgDOTAProfileCard.Slot.StatR\x04stat\x127\n\x04item\x18\x04\x20\
    \x01(\x0b2#.dota.CMsgDOTAProfileCard.Slot.ItemR\x04item\x127\n\x04hero\
    \x18\x05\x20\x01(\x0b2#.dota.CMsgDOTAProfileCard.Slot.HeroR\x04hero\x12C\
    \n\x08emoticon\x18\x06\x20\x01(\x0b2'.dota.CMsgDOTAProfileCard.Slot.Emot\
    iconR\x08emoticon\x127\n\x04team\x18\x07\x20\x01(\x0b2#.dota.CMsgDOTAPro\
    fileCard.Slot.TeamR\x04team\x1aH\n\x06Trophy\x12\x1b\n\ttrophy_id\x18\
    \x01\x20\x01(\rR\x08trophyId\x12!\n\x0ctrophy_score\x18\x02\x20\x01(\rR\
    \x0btrophyScore\x1aa\n\x04Stat\x12:\n\x07stat_id\x18\x01\x20\x01(\x0e2!.\
    dota.CMsgDOTAProfileCard.EStatIDR\x06statId\x12\x1d\n\nstat_score\x18\
    \x02\x20\x01(\rR\tstatScore\x1aH\n\x04Item\x12'\n\x0fserialized_item\x18\
    \x01\x20\x01(\x0cR\x0eserializedItem\x12\x17\n\x07item_id\x18\x02\x20\
    \x01(\x04R\x06itemId\x1a]\n\x04Hero\x12\x17\n\x07hero_id\x18\x01\x20\x01\
    (\rR\x06heroId\x12\x1b\n\thero_wins\x18\x02\x20\x01(\rR\x08heroWins\x12\
    \x1f\n\x0bhero_losses\x18\x03\x20\x01(\rR\nheroLosses\x1a+\n\x08Emoticon\
    \x12\x1f\n\x0bemoticon_id\x18\x01\x20\x01(\rR\nemoticonId\x1a\x1f\n\x04T\
    eam\x12\x17\n\x07team_id\x18\x01\x20\x01(\rR\x06teamId\"\x9c\x01\n\x07ES\
    tatID\x12\x10\n\x0ck_eStat_Wins\x10\x03\x12\x14\n\x10k_eStat_Commends\
    \x10\x04\x12\x17\n\x13k_eStat_GamesPlayed\x10\x05\x12\x1a\n\x16k_eStat_F\
    irstMatchDate\x10\x06\x12\x1e\n\x1ak_eStat_PreviousSeasonRank\x10\x07\
    \x12\x14\n\x10k_eStat_GamesMVP\x10\x08\"\xad\x04\n\x16CSODOTAPlayerChall\
    enge\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08e\
    vent_id\x18\x02\x20\x01(\rR\x07eventId\x12\x17\n\x07slot_id\x18\x03\x20\
    \x01(\rR\x06slotId\x12\x1e\n\x0bint_param_0\x18\x05\x20\x01(\rR\tintPara\
    m0\x12\x1e\n\x0bint_param_1\x18\x06\x20\x01(\rR\tintParam1\x12!\n\x0ccre\
    ated_time\x18\x07\x20\x01(\rR\x0bcreatedTime\x12\x1c\n\tcompleted\x18\
    \x08\x20\x01(\rR\tcompleted\x12\x1f\n\x0bsequence_id\x18\t\x20\x01(\rR\n\
    sequenceId\x12%\n\x0echallenge_tier\x18\n\x20\x01(\rR\rchallengeTier\x12\
    \x14\n\x05flags\x18\x0b\x20\x01(\rR\x05flags\x12\x1a\n\x08attempts\x18\
    \x0c\x20\x01(\rR\x08attempts\x12%\n\x0ecomplete_limit\x18\r\x20\x01(\rR\
    \rcompleteLimit\x12\x1d\n\nquest_rank\x18\x0e\x20\x01(\rR\tquestRank\x12\
    $\n\x0emax_quest_rank\x18\x0f\x20\x01(\rR\x0cmaxQuestRank\x12\x1f\n\x0bi\
    nstance_id\x18\x10\x20\x01(\rR\ninstanceId\x12\x17\n\x07hero_id\x18\x11\
    \x20\x01(\rR\x06heroId\x12\x1f\n\x0btemplate_id\x18\x12\x20\x01(\rR\ntem\
    plateId\"\x88\x01\n#CMsgClientToGCRerollPlayerChallenge\x12'\n\x08event_\
    id\x18\x01\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x12\x1f\n\x0bsequen\
    ce_id\x18\x03\x20\x01(\rR\nsequenceId\x12\x17\n\x07hero_id\x18\x04\x20\
    \x01(\rR\x06heroId\"\xec\x01\n#CMsgGCRerollPlayerChallengeResponse\x12I\
    \n\x06result\x18\x01\x20\x01(\x0e21.dota.CMsgGCRerollPlayerChallengeResp\
    onse.EResultR\x06result\"z\n\x07EResult\x12\x13\n\x0feResult_Success\x10\
    \0\x12\x13\n\x0feResult_Dropped\x10\x01\x12\x14\n\x10eResult_NotFound\
    \x10\x02\x12\x16\n\x12eResult_CantReroll\x10\x03\x12\x17\n\x13eResult_Se\
    rverError\x10\x04\"k\n\x18CMsgGCTopCustomGamesList\x12(\n\x10top_custom_\
    games\x18\x01\x20\x03(\x04R\x0etopCustomGames\x12%\n\x0fgame_of_the_day\
    \x18\x02\x20\x01(\x04R\x0cgameOfTheDay\"\xf2%\n\x19CMsgDOTARealtimeGameS\
    tats\x12B\n\x05match\x18\x01\x20\x01(\x0b2,.dota.CMsgDOTARealtimeGameSta\
    ts.MatchDetailsR\x05match\x12A\n\x05teams\x18\x02\x20\x03(\x0b2+.dota.CM\
    sgDOTARealtimeGameStats.TeamDetailsR\x05teams\x12M\n\tbuildings\x18\x03\
    \x20\x03(\x0b2/.dota.CMsgDOTARealtimeGameStats.BuildingDetailsR\tbuildin\
    gs\x12H\n\ngraph_data\x18\x04\x20\x01(\x0b2).dota.CMsgDOTARealtimeGameSt\
    ats.GraphDataR\tgraphData\x12\x1f\n\x0bdelta_frame\x18\x05\x20\x01(\x08R\
    \ndeltaFrame\x1a\xf1\x02\n\x0bTeamDetails\x12\x1f\n\x0bteam_number\x18\
    \x01\x20\x01(\rR\nteamNumber\x12\x17\n\x07team_id\x18\x02\x20\x01(\rR\
    \x06teamId\x12\x1b\n\tteam_name\x18\x03\x20\x01(\tR\x08teamName\x12\x1b\
    \n\tteam_logo\x18\x04\x20\x01(\x06R\x08teamLogo\x12\x19\n\x08team_tag\
    \x18\n\x20\x01(\tR\x07teamTag\x12\x14\n\x05score\x18\x05\x20\x01(\rR\x05\
    score\x12\x1b\n\tnet_worth\x18\t\x20\x01(\rR\x08netWorth\x12G\n\x07playe\
    rs\x18\x06\x20\x03(\x0b2-.dota.CMsgDOTARealtimeGameStats.PlayerDetailsR\
    \x07players\x12\x1b\n\tonly_team\x18\x07\x20\x01(\x08R\x08onlyTeam\x12\
    \x16\n\x06cheers\x18\x08\x20\x01(\rR\x06cheers\x12\"\n\rteam_logo_url\
    \x18\x0b\x20\x01(\tR\x0bteamLogoUrl\x1a\x91\x01\n\x0bItemDetails\x12&\n\
    \x0fitem_ability_id\x18\x01\x20\x01(\x05R\ritemAbilityId\x12\x12\n\x04na\
    me\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04time\x18\x03\x20\x01(\x05R\
    \x04time\x12\x12\n\x04sold\x18\x04\x20\x01(\x08R\x04sold\x12\x1e\n\nstac\
    kcount\x18\x05\x20\x01(\rR\nstackcount\x1a\x89\x01\n\x0eAbilityDetails\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x14\n\x05level\x18\x03\x20\x01(\rR\x05level\x12\
    \x1a\n\x08cooldown\x18\x04\x20\x01(\x02R\x08cooldown\x12!\n\x0ccooldown_\
    max\x18\x05\x20\x01(\x02R\x0bcooldownMax\x1a]\n\x0fHeroToHeroStats\x12\
    \x1a\n\x08victimid\x18\x01\x20\x01(\x05R\x08victimid\x12\x14\n\x05kills\
    \x18\x02\x20\x01(\rR\x05kills\x12\x18\n\x07assists\x18\x03\x20\x01(\rR\
    \x07assists\x1a\x1d\n\x0bAbilityList\x12\x0e\n\x02id\x18\x01\x20\x03(\
    \x05R\x02id\x1a\xbe\x0e\n\rPlayerDetails\x12\x1c\n\taccountid\x18\x01\
    \x20\x01(\rR\taccountid\x12\x1a\n\x08playerid\x18\x02\x20\x01(\x05R\x08p\
    layerid\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x12\n\x04team\
    \x18\x04\x20\x01(\rR\x04team\x12\x16\n\x06heroid\x18\x05\x20\x01(\rR\x06\
    heroid\x12\"\n\x0chealthpoints\x18\x06\x20\x01(\rR\x0chealthpoints\x12(\
    \n\x0fmaxhealthpoints\x18\x07\x20\x01(\rR\x0fmaxhealthpoints\x12(\n\x0fh\
    ealthregenrate\x18\x08\x20\x01(\x02R\x0fhealthregenrate\x12\x1e\n\nmanap\
    oints\x18\t\x20\x01(\rR\nmanapoints\x12$\n\rmaxmanapoints\x18\n\x20\x01(\
    \rR\rmaxmanapoints\x12$\n\rmanaregenrate\x18\x0b\x20\x01(\x02R\rmanarege\
    nrate\x12#\n\rbase_strength\x18\x0c\x20\x01(\rR\x0cbaseStrength\x12!\n\
    \x0cbase_agility\x18\r\x20\x01(\rR\x0bbaseAgility\x12+\n\x11base_intelli\
    gence\x18\x0e\x20\x01(\rR\x10baseIntelligence\x12\x1d\n\nbase_armor\x18\
    \x0f\x20\x01(\x05R\tbaseArmor\x12%\n\x0ebase_movespeed\x18\x10\x20\x01(\
    \rR\rbaseMovespeed\x12\x1f\n\x0bbase_damage\x18\x11\x20\x01(\rR\nbaseDam\
    age\x12\x1a\n\x08strength\x18\x12\x20\x01(\rR\x08strength\x12\x18\n\x07a\
    gility\x18\x13\x20\x01(\rR\x07agility\x12\"\n\x0cintelligence\x18\x14\
    \x20\x01(\rR\x0cintelligence\x12\x14\n\x05armor\x18\x15\x20\x01(\x05R\
    \x05armor\x12\x1c\n\tmovespeed\x18\x16\x20\x01(\rR\tmovespeed\x12\x16\n\
    \x06damage\x18\x17\x20\x01(\rR\x06damage\x12\x1f\n\x0bhero_damage\x18\
    \x18\x20\x01(\rR\nheroDamage\x12!\n\x0ctower_damage\x18\x19\x20\x01(\rR\
    \x0btowerDamage\x12L\n\tabilities\x18\x1a\x20\x03(\x0b2..dota.CMsgDOTARe\
    altimeGameStats.AbilityDetailsR\tabilities\x12\x14\n\x05level\x18\x1b\
    \x20\x01(\rR\x05level\x12\x1d\n\nkill_count\x18\x1c\x20\x01(\rR\tkillCou\
    nt\x12\x1f\n\x0bdeath_count\x18\x1d\x20\x01(\rR\ndeathCount\x12#\n\rassi\
    sts_count\x18\x1e\x20\x01(\rR\x0cassistsCount\x12!\n\x0cdenies_count\x18\
    \x1f\x20\x01(\rR\x0bdeniesCount\x12\x19\n\x08lh_count\x18\x20\x20\x01(\r\
    R\x07lhCount\x12!\n\x0chero_healing\x18!\x20\x01(\rR\x0bheroHealing\x12\
    \x20\n\x0cgold_per_min\x18\"\x20\x01(\rR\ngoldPerMin\x12\x1c\n\nxp_per_m\
    in\x18#\x20\x01(\rR\x08xpPerMin\x12\x19\n\x08net_gold\x18$\x20\x01(\rR\
    \x07netGold\x12\x12\n\x04gold\x18%\x20\x01(\rR\x04gold\x12\x0c\n\x01x\
    \x18&\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18'\x20\x01(\x02R\x01y\x12!\n\
    \x0crespawn_time\x18(\x20\x01(\x05R\x0brespawnTime\x12+\n\x11ultimate_co\
    oldown\x18)\x20\x01(\rR\x10ultimateCooldown\x12\x1f\n\x0bhas_buyback\x18\
    *\x20\x01(\x08R\nhasBuyback\x12A\n\x05items\x18+\x20\x03(\x0b2+.dota.CMs\
    gDOTARealtimeGameStats.ItemDetailsR\x05items\x12K\n\nstashitems\x18,\x20\
    \x03(\x0b2+.dota.CMsgDOTARealtimeGameStats.ItemDetailsR\nstashitems\x12W\
    \n\x10itemshoppinglist\x18-\x20\x03(\x0b2+.dota.CMsgDOTARealtimeGameStat\
    s.ItemDetailsR\x10itemshoppinglist\x12M\n\x0blevelpoints\x18.\x20\x03(\
    \x0b2+.dota.CMsgDOTARealtimeGameStats.AbilityListR\x0blevelpoints\x12\\\
    \n\x12hero_to_hero_stats\x18/\x20\x03(\x0b2/.dota.CMsgDOTARealtimeGameSt\
    ats.HeroToHeroStatsR\x0fheroToHeroStats\x12!\n\x0chas_ultimate\x180\x20\
    \x01(\x08R\x0bhasUltimate\x12*\n\x11has_ultimate_mana\x181\x20\x01(\x08R\
    \x0fhasUltimateMana\x1a\xb5\x01\n\x0fBuildingDetails\x12\x12\n\x04team\
    \x18\x02\x20\x01(\rR\x04team\x12\x18\n\x07heading\x18\x03\x20\x01(\x02R\
    \x07heading\x12\x12\n\x04lane\x18\x04\x20\x01(\rR\x04lane\x12\x12\n\x04t\
    ier\x18\x05\x20\x01(\rR\x04tier\x12\x12\n\x04type\x18\x06\x20\x01(\rR\
    \x04type\x12\x0c\n\x01x\x18\x07\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\
    \x08\x20\x01(\x02R\x01y\x12\x1c\n\tdestroyed\x18\t\x20\x01(\x08R\tdestro\
    yed\x1as\n\x0bKillDetails\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08\
    playerId\x12\x1d\n\ndeath_time\x18\x02\x20\x01(\x05R\tdeathTime\x12(\n\
    \x10killer_player_id\x18\x03\x20\x01(\x05R\x0ekillerPlayerId\x1a1\n\x12B\
    roadcasterDetails\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\
    \x1a8\n\x0ePickBanDetails\x12\x12\n\x04hero\x18\x01\x20\x01(\rR\x04hero\
    \x12\x12\n\x04team\x18\x02\x20\x01(\rR\x04team\x1a\xd6\x06\n\x0cMatchDet\
    ails\x12&\n\x0fserver_steam_id\x18\x01\x20\x01(\x06R\rserverSteamId\x12\
    \x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\x12\x1c\n\ttimestamp\
    \x18\x03\x20\x01(\rR\ttimestamp\x12\x1e\n\x0btime_of_day\x18\x04\x20\x01\
    (\x02R\ttimeOfDay\x122\n\x15is_nightstalker_night\x18\x05\x20\x01(\x08R\
    \x13isNightstalkerNight\x12\x1b\n\tgame_time\x18\x06\x20\x01(\x05R\x08ga\
    meTime\x12\x1d\n\ngame_state\x18\x13\x20\x01(\rR\tgameState\x12%\n\x0ete\
    amid_radiant\x18\x08\x20\x01(\rR\rteamidRadiant\x12\x1f\n\x0bteamid_dire\
    \x18\t\x20\x01(\rR\nteamidDire\x12D\n\x05picks\x18\n\x20\x03(\x0b2..dota\
    .CMsgDOTARealtimeGameStats.PickBanDetailsR\x05picks\x12B\n\x04bans\x18\
    \x0b\x20\x03(\x0b2..dota.CMsgDOTARealtimeGameStats.PickBanDetailsR\x04ba\
    ns\x12A\n\x05kills\x18\x0c\x20\x03(\x0b2+.dota.CMsgDOTARealtimeGameStats\
    .KillDetailsR\x05kills\x12V\n\x0cbroadcasters\x18\r\x20\x03(\x0b22.dota.\
    CMsgDOTARealtimeGameStats.BroadcasterDetailsR\x0cbroadcasters\x12\x1b\n\
    \tgame_mode\x18\x0e\x20\x01(\rR\x08gameMode\x12\x1b\n\tleague_id\x18\x0f\
    \x20\x01(\rR\x08leagueId\x12$\n\x0eleague_node_id\x18\x12\x20\x01(\rR\
    \x0cleagueNodeId\x12\x1f\n\x0bsingle_team\x18\x10\x20\x01(\x08R\nsingleT\
    eam\x12\x1f\n\x0bcheers_peak\x18\x11\x20\x01(\rR\ncheersPeak\x12\x1d\n\n\
    lobby_type\x18\x14\x20\x01(\rR\tlobbyType\x12'\n\x0fstart_timestamp\x18\
    \x15\x20\x01(\rR\x0estartTimestamp\x1a\xcd\x04\n\tGraphData\x12\x1d\n\ng\
    raph_gold\x18\x01\x20\x03(\x05R\tgraphGold\x12\x19\n\x08graph_xp\x18\x02\
    \x20\x03(\x05R\x07graphXp\x12\x1d\n\ngraph_kill\x18\x03\x20\x03(\x05R\tg\
    raphKill\x12\x1f\n\x0bgraph_tower\x18\x04\x20\x03(\x05R\ngraphTower\x12\
    \x1b\n\tgraph_rax\x18\x05\x20\x03(\x05R\x08graphRax\x12a\n\x0eteam_loc_s\
    tats\x18\x06\x20\x03(\x0b2;.dota.CMsgDOTARealtimeGameStats.GraphData.Tea\
    mLocationStatsR\x0cteamLocStats\x1a%\n\rLocationStats\x12\x14\n\x05stats\
    \x18\x01\x20\x03(\x05R\x05stats\x1ai\n\x11TeamLocationStats\x12T\n\tloc_\
    stats\x18\x01\x20\x03(\x0b27.dota.CMsgDOTARealtimeGameStats.GraphData.Lo\
    cationStatsR\x08locStats\"[\n\x05eStat\x12\x13\n\x0fCreepGoldEarned\x10\
    \0\x12\x12\n\x0eKillGoldEarned\x10\x01\x12\x1b\n\x17DeathAndBuybackGoldL\
    ost\x10\x02\x12\x0c\n\x08XPEarned\x10\x03\"W\n\teLocation\x12\x0b\n\x07B\
    otLane\x10\0\x12\x0b\n\x07MidLane\x10\x01\x12\x0b\n\x07TopLane\x10\x02\
    \x12\n\n\x06Jungle\x10\x03\x12\x0c\n\x08Ancients\x10\x04\x12\t\n\x05Othe\
    r\x10\x05\"\xca\x0f\n\x1eCMsgDOTARealtimeGameStatsTerse\x12G\n\x05match\
    \x18\x01\x20\x01(\x0b21.dota.CMsgDOTARealtimeGameStatsTerse.MatchDetails\
    R\x05match\x12F\n\x05teams\x18\x02\x20\x03(\x0b20.dota.CMsgDOTARealtimeG\
    ameStatsTerse.TeamDetailsR\x05teams\x12R\n\tbuildings\x18\x03\x20\x03(\
    \x0b24.dota.CMsgDOTARealtimeGameStatsTerse.BuildingDetailsR\tbuildings\
    \x12M\n\ngraph_data\x18\x04\x20\x01(\x0b2..dota.CMsgDOTARealtimeGameStat\
    sTerse.GraphDataR\tgraphData\x12\x1f\n\x0bdelta_frame\x18\x05\x20\x01(\
    \x08R\ndeltaFrame\x1a\xc1\x02\n\x0bTeamDetails\x12\x1f\n\x0bteam_number\
    \x18\x01\x20\x01(\rR\nteamNumber\x12\x17\n\x07team_id\x18\x02\x20\x01(\r\
    R\x06teamId\x12\x1b\n\tteam_name\x18\x03\x20\x01(\tR\x08teamName\x12\x19\
    \n\x08team_tag\x18\x08\x20\x01(\tR\x07teamTag\x12\x1b\n\tteam_logo\x18\
    \x04\x20\x01(\x06R\x08teamLogo\x12\x14\n\x05score\x18\x05\x20\x01(\rR\
    \x05score\x12\x1b\n\tnet_worth\x18\x07\x20\x01(\rR\x08netWorth\x12\"\n\r\
    team_logo_url\x18\t\x20\x01(\tR\x0bteamLogoUrl\x12L\n\x07players\x18\x06\
    \x20\x03(\x0b22.dota.CMsgDOTARealtimeGameStatsTerse.PlayerDetailsR\x07pl\
    ayers\x1a\xc3\x03\n\rPlayerDetails\x12\x1c\n\taccountid\x18\x01\x20\x01(\
    \rR\taccountid\x12\x1a\n\x08playerid\x18\x02\x20\x01(\x05R\x08playerid\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x12\n\x04team\x18\x04\
    \x20\x01(\rR\x04team\x12\x16\n\x06heroid\x18\x05\x20\x01(\rR\x06heroid\
    \x12\x14\n\x05level\x18\x06\x20\x01(\rR\x05level\x12\x1d\n\nkill_count\
    \x18\x07\x20\x01(\rR\tkillCount\x12\x1f\n\x0bdeath_count\x18\x08\x20\x01\
    (\rR\ndeathCount\x12#\n\rassists_count\x18\t\x20\x01(\rR\x0cassistsCount\
    \x12!\n\x0cdenies_count\x18\n\x20\x01(\rR\x0bdeniesCount\x12\x19\n\x08lh\
    _count\x18\x0b\x20\x01(\rR\x07lhCount\x12\x12\n\x04gold\x18\x0c\x20\x01(\
    \rR\x04gold\x12\x0c\n\x01x\x18\r\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\
    \x0e\x20\x01(\x02R\x01y\x12\x1b\n\tnet_worth\x18\x0f\x20\x01(\rR\x08netW\
    orth\x12\x1c\n\tabilities\x18\x10\x20\x03(\x05R\tabilities\x12\x14\n\x05\
    items\x18\x11\x20\x03(\x05R\x05items\x1a\xb5\x01\n\x0fBuildingDetails\
    \x12\x12\n\x04team\x18\x01\x20\x01(\rR\x04team\x12\x18\n\x07heading\x18\
    \x02\x20\x01(\x02R\x07heading\x12\x12\n\x04type\x18\x03\x20\x01(\rR\x04t\
    ype\x12\x12\n\x04lane\x18\x04\x20\x01(\rR\x04lane\x12\x12\n\x04tier\x18\
    \x05\x20\x01(\rR\x04tier\x12\x0c\n\x01x\x18\x06\x20\x01(\x02R\x01x\x12\
    \x0c\n\x01y\x18\x07\x20\x01(\x02R\x01y\x12\x1c\n\tdestroyed\x18\x08\x20\
    \x01(\x08R\tdestroyed\x1a8\n\x0ePickBanDetails\x12\x12\n\x04hero\x18\x01\
    \x20\x01(\rR\x04hero\x12\x12\n\x04team\x18\x02\x20\x01(\rR\x04team\x1a\
    \xaa\x04\n\x0cMatchDetails\x12&\n\x0fserver_steam_id\x18\x01\x20\x01(\
    \x06R\rserverSteamId\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matc\
    hId\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimestamp\x12\x1b\n\tgame_\
    time\x18\x04\x20\x01(\x05R\x08gameTime\x12A\n\x1dsteam_broadcaster_accou\
    nt_ids\x18\x06\x20\x03(\rR\x1asteamBroadcasterAccountIds\x12\x1b\n\tgame\
    _mode\x18\x07\x20\x01(\rR\x08gameMode\x12\x1b\n\tleague_id\x18\x08\x20\
    \x01(\rR\x08leagueId\x12$\n\x0eleague_node_id\x18\t\x20\x01(\rR\x0cleagu\
    eNodeId\x12\x1d\n\ngame_state\x18\n\x20\x01(\rR\tgameState\x12I\n\x05pic\
    ks\x18\x0b\x20\x03(\x0b23.dota.CMsgDOTARealtimeGameStatsTerse.PickBanDet\
    ailsR\x05picks\x12G\n\x04bans\x18\x0c\x20\x03(\x0b23.dota.CMsgDOTARealti\
    meGameStatsTerse.PickBanDetailsR\x04bans\x12\x1d\n\nlobby_type\x18\r\x20\
    \x01(\rR\tlobbyType\x12'\n\x0fstart_timestamp\x18\x0e\x20\x01(\rR\x0esta\
    rtTimestamp\x1a*\n\tGraphData\x12\x1d\n\ngraph_gold\x18\x01\x20\x03(\x05\
    R\tgraphGold\"\xa8\x01\n\x1eCMsgDOTABroadcastTimelineEvent\x123\n\x05eve\
    nt\x18\x01\x20\x01(\x0e2\x1d.dota.EBroadcastTimelineEventR\x05event\x12\
    \x1c\n\ttimestamp\x18\x02\x20\x01(\x07R\ttimestamp\x12\x12\n\x04data\x18\
    \x03\x20\x01(\rR\x04data\x12\x1f\n\x0bstring_data\x18\x04\x20\x01(\tR\ns\
    tringData\"S\n\x20CMsgGCToClientMatchGroupsVersion\x12/\n\x13matchgroups\
    _version\x18\x01\x20\x01(\rR\x12matchgroupsVersion\"\x91\x02\n\x1bCMsgDO\
    TASDOHeroStatsHistory\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07mat\
    chId\x12\x1b\n\tgame_mode\x18\x02\x20\x01(\rR\x08gameMode\x12\x1d\n\nlob\
    by_type\x18\x03\x20\x01(\rR\tlobbyType\x12\x1d\n\nstart_time\x18\x04\x20\
    \x01(\rR\tstartTime\x12\x10\n\x03won\x18\x05\x20\x01(\x08R\x03won\x12\
    \x10\n\x03gpm\x18\x06\x20\x01(\rR\x03gpm\x12\x10\n\x03xpm\x18\x07\x20\
    \x01(\rR\x03xpm\x12\x14\n\x05kills\x18\x08\x20\x01(\rR\x05kills\x12\x16\
    \n\x06deaths\x18\t\x20\x01(\rR\x06deaths\x12\x18\n\x07assists\x18\n\x20\
    \x01(\rR\x07assists\"\x88\x01\n\x14CMsgPredictionChoice\x12\x14\n\x05val\
    ue\x18\x01\x20\x01(\rR\x05value\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\"\n\rmin_raw_value\x18\x03\x20\x01(\rR\x0bminRawValue\x12\"\
    \n\rmax_raw_value\x18\x04\x20\x01(\rR\x0bmaxRawValue\"\xdb\t\n\x14CMsgIn\
    GamePrediction\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04na\
    me\x18\x02\x20\x01(\tR\x04name\x12>\n\x04type\x18\x03\x20\x01(\x0e2*.dot\
    a.CMsgInGamePrediction.EPredictionTypeR\x04type\x12H\n\x05group\x18\x04\
    \x20\x01(\x0e22.dota.CMsgInGamePrediction.ERandomSelectionGroup_tR\x05gr\
    oup\x12\x1a\n\x08question\x18\x05\x20\x01(\tR\x08question\x124\n\x07choi\
    ces\x18\x06\x20\x03(\x0b2\x1a.dota.CMsgPredictionChoiceR\x07choices\x12'\
    \n\x0frequired_heroes\x18\x07\x20\x03(\tR\x0erequiredHeroes\x12\x1d\n\nq\
    uery_name\x18\x08\x20\x01(\tR\tqueryName\x12L\n\x0cquery_values\x18\t\
    \x20\x03(\x0b2).dota.CMsgInGamePrediction.QueryKeyValuesR\x0bqueryValues\
    \x12b\n\x16answer_resolution_type\x18\n\x20\x01(\x0e2,.dota.CMsgInGamePr\
    ediction.EResolutionType_tR\x14answerResolutionType\x12&\n\x0fpoints_to_\
    grant\x18\x0b\x20\x01(\rR\rpointsToGrant\x12#\n\rreward_action\x18\x0c\
    \x20\x01(\rR\x0crewardAction\x122\n\x15debug_force_selection\x18\r\x20\
    \x01(\rR\x13debugForceSelection\x12P\n\x0eraw_value_type\x18\x0e\x20\x01\
    (\x0e2*.dota.CMsgInGamePrediction.ERawValueType_tR\x0crawValueType\x1a:\
    \n\x0eQueryKeyValues\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"'\n\x0fERawValueType_t\x12\
    \n\n\x06Number\x10\0\x12\x08\n\x04Time\x10\x01\"j\n\x0fEPredictionType\
    \x12\x0b\n\x07Generic\x10\0\x12\x08\n\x04Hero\x10\x01\x12\x08\n\x04Team\
    \x10\x02\x12\n\n\x06Player\x10\x03\x12\x0b\n\x07Special\x10\x04\x12\t\n\
    \x05YesNo\x10\x05\x12\x12\n\x0eQualifiersTeam\x10\x06\"\xd4\x01\n\x11ERe\
    solutionType_t\x12\x10\n\x0cInvalidQuery\x10\0\x12\x14\n\x10FirstToPassQ\
    uery\x10\x01\x12\x13\n\x0fLastToPassQuery\x10\x02\x12\x16\n\x12LastRemai\
    ningQuery\x10\x03\x12\x12\n\x0eMaxToPassQuery\x10\x04\x12\x12\n\x0eMinTo\
    PassQuery\x10\x05\x12\x0c\n\x08SumQuery\x10\x06\x12\x19\n\x15MaxTeamSumT\
    oPassQuery\x10\x07\x12\x19\n\x15MinTeamSumToPassQuery\x10\x08\"N\n\x17ER\
    andomSelectionGroup_t\x12\r\n\tEarlyGame\x10\0\x12\x0b\n\x07MidGame\x10\
    \x01\x12\x0c\n\x08LateGame\x10\x02\x12\t\n\x05Count\x10\x03\"\xf8\x0b\n\
    \x19CMsgDOTASeasonPredictions\x12L\n\x0bpredictions\x18\x01\x20\x03(\x0b\
    2*.dota.CMsgDOTASeasonPredictions.PredictionR\x0bpredictions\x12J\n\x13i\
    n_game_predictions\x18\x02\x20\x03(\x0b2\x1a.dota.CMsgInGamePredictionR\
    \x11inGamePredictions\x12G\n!in_game_prediction_count_per_game\x18\x03\
    \x20\x01(\rR\x1cinGamePredictionCountPerGame\x12U\n(in_game_prediction_v\
    oting_period_minutes\x18\x04\x20\x01(\rR#inGamePredictionVotingPeriodMin\
    utes\x1a\xa0\t\n\nPrediction\x12N\n\x04type\x18\x01\x20\x01(\x0e2:.dota.\
    CMsgDOTASeasonPredictions.Prediction.EPredictionTypeR\x04type\x12\x1a\n\
    \x08question\x18\x02\x20\x01(\tR\x08question\x124\n\x07choices\x18\x03\
    \x20\x03(\x0b2\x1a.dota.CMsgPredictionChoiceR\x07choices\x12!\n\x0cselec\
    tion_id\x18\x04\x20\x01(\rR\x0bselectionId\x12\x1d\n\nstart_date\x18\x05\
    \x20\x01(\rR\tstartDate\x12\x1b\n\tlock_date\x18\x06\x20\x01(\rR\x08lock\
    Date\x12\x16\n\x06reward\x18\x07\x20\x01(\rR\x06reward\x12W\n\x0banswer_\
    type\x18\x08\x20\x01(\x0e26.dota.CMsgDOTASeasonPredictions.Prediction.EA\
    nswerTypeR\nanswerType\x12\x1b\n\tanswer_id\x18\t\x20\x01(\rR\x08answerI\
    d\x12L\n\x07answers\x18\n\x20\x03(\x0b22.dota.CMsgDOTASeasonPredictions.\
    Prediction.AnswersR\x07answers\x12\x1d\n\nquery_name\x18\x0b\x20\x01(\tR\
    \tqueryName\x12/\n\x14lock_on_selection_id\x18\r\x20\x01(\rR\x11lockOnSe\
    lectionId\x125\n\x17lock_on_selection_value\x18\x0e\x20\x01(\rR\x14lockO\
    nSelectionValue\x121\n\x15lock_on_selection_set\x18\x0f\x20\x01(\x08R\
    \x12lockOnSelectionSet\x125\n\x17use_answer_value_ranges\x18\x10\x20\x01\
    (\x08R\x14useAnswerValueRanges\x12+\n\x06region\x18\x11\x20\x01(\x0e2\
    \x13.dota.ELeagueRegionR\x06region\x12*\n\x06phases\x18\x12\x20\x03(\x0e\
    2\x12.dota.ELeaguePhaseR\x06phases\x12/\n\x0creward_event\x18\x13\x20\
    \x01(\x0e2\x0c.dota.EEventR\x0brewardEvent\x1a&\n\x07Answers\x12\x1b\n\t\
    answer_id\x18\x01\x20\x01(\rR\x08answerId\"~\n\x0fEPredictionType\x12\
    \x0b\n\x07Generic\x10\0\x12\x08\n\x04Hero\x10\x01\x12\x08\n\x04Team\x10\
    \x02\x12\n\n\x06Player\x10\x03\x12\x0b\n\x07Special\x10\x04\x12\t\n\x05Y\
    esNo\x10\x05\x12\x12\n\x0eQualifiersTeam\x10\x06\x12\x12\n\x0eLastChance\
    Team\x10\x07\"\x91\x01\n\x0bEAnswerType\x12\r\n\tSingleInt\x10\0\x12\x0f\
    \n\x0bSingleFloat\x10\x01\x12\x0f\n\x0bMultipleInt\x10\x02\x12\x11\n\rMu\
    ltipleFloat\x10\x03\x12\x0e\n\nAnswerTeam\x10\x04\x12\x0e\n\nSingleTime\
    \x10\x05\x12\x10\n\x0cMultipleTime\x10\x06\x12\x0c\n\x08NoAnswer\x10\x07\
    \"\xe3\x01\n\x18CMsgAvailablePredictions\x12[\n\x11match_predictions\x18\
    \x01\x20\x03(\x0b2..dota.CMsgAvailablePredictions.MatchPredictionR\x10ma\
    tchPredictions\x1aj\n\x0fMatchPrediction\x12\x19\n\x08match_id\x18\x01\
    \x20\x01(\x04R\x07matchId\x12<\n\x0bpredictions\x18\x02\x20\x03(\x0b2\
    \x1a.dota.CMsgInGamePredictionR\x0bpredictions\"\xf2\x01\n\x16CMsgLeague\
    WatchedGames\x12=\n\x07leagues\x18\x01\x20\x03(\x0b2#.dota.CMsgLeagueWat\
    chedGames.LeagueR\x07leagues\x1a5\n\x06Series\x12\x17\n\x07node_id\x18\
    \x01\x20\x01(\rR\x06nodeId\x12\x12\n\x04game\x18\x02\x20\x03(\rR\x04game\
    \x1ab\n\x06League\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\
    \x12;\n\x06series\x18\x02\x20\x03(\x0b2#.dota.CMsgLeagueWatchedGames.Ser\
    iesR\x06series\"\xe4.\n\rCMsgDOTAMatch\x12\x1a\n\x08duration\x18\x03\x20\
    \x01(\rR\x08duration\x12\x1c\n\tstarttime\x18\x04\x20\x01(\x07R\tstartti\
    me\x124\n\x07players\x18\x05\x20\x03(\x0b2\x1a.dota.CMsgDOTAMatch.Player\
    R\x07players\x12\x19\n\x08match_id\x18\x06\x20\x01(\x04R\x07matchId\x12!\
    \n\x0ctower_status\x18\x08\x20\x03(\rR\x0btowerStatus\x12'\n\x0fbarracks\
    _status\x18\t\x20\x03(\rR\x0ebarracksStatus\x12\x18\n\x07cluster\x18\n\
    \x20\x01(\rR\x07cluster\x12(\n\x10first_blood_time\x18\x0c\x20\x01(\rR\
    \x0efirstBloodTime\x12\x1f\n\x0breplay_salt\x18\r\x20\x01(\x07R\nreplayS\
    alt\x12\x1b\n\tserver_ip\x18\x0e\x20\x01(\x07R\x08serverIp\x12\x1f\n\x0b\
    server_port\x18\x0f\x20\x01(\rR\nserverPort\x12\x1d\n\nlobby_type\x18\
    \x10\x20\x01(\rR\tlobbyType\x12#\n\rhuman_players\x18\x11\x20\x01(\rR\
    \x0chumanPlayers\x12#\n\raverage_skill\x18\x12\x20\x01(\rR\x0caverageSki\
    ll\x12!\n\x0cgame_balance\x18\x13\x20\x01(\x02R\x0bgameBalance\x12&\n\
    \x0fradiant_team_id\x18\x14\x20\x01(\rR\rradiantTeamId\x12\x20\n\x0cdire\
    _team_id\x18\x15\x20\x01(\rR\ndireTeamId\x12\x1a\n\x08leagueid\x18\x16\
    \x20\x01(\rR\x08leagueid\x12*\n\x11radiant_team_name\x18\x17\x20\x01(\tR\
    \x0fradiantTeamName\x12$\n\x0edire_team_name\x18\x18\x20\x01(\tR\x0cdire\
    TeamName\x12*\n\x11radiant_team_logo\x18\x19\x20\x01(\x04R\x0fradiantTea\
    mLogo\x12$\n\x0edire_team_logo\x18\x1a\x20\x01(\x04R\x0cdireTeamLogo\x12\
    1\n\x15radiant_team_logo_url\x186\x20\x01(\tR\x12radiantTeamLogoUrl\x12+\
    \n\x12dire_team_logo_url\x187\x20\x01(\tR\x0fdireTeamLogoUrl\x122\n\x15r\
    adiant_team_complete\x18\x1b\x20\x01(\rR\x13radiantTeamComplete\x12,\n\
    \x12dire_team_complete\x18\x1c\x20\x01(\rR\x10direTeamComplete\x12%\n\
    \x0epositive_votes\x18\x1d\x20\x01(\rR\rpositiveVotes\x12%\n\x0enegative\
    _votes\x18\x1e\x20\x01(\rR\rnegativeVotes\x120\n\tgame_mode\x18\x1f\x20\
    \x01(\x0e2\x13.dota.DOTA_GameModeR\x08gameMode\x12:\n\npicks_bans\x18\
    \x20\x20\x03(\x0b2\x1b.dota.CMatchHeroSelectEventR\tpicksBans\x12\"\n\rm\
    atch_seq_num\x18!\x20\x01(\x04R\x0bmatchSeqNum\x12B\n\x0creplay_state\
    \x18\"\x20\x01(\x0e2\x1f.dota.CMsgDOTAMatch.ReplayStateR\x0breplayState\
    \x12(\n\x10radiant_guild_id\x18#\x20\x01(\rR\x0eradiantGuildId\x12\"\n\r\
    dire_guild_id\x18$\x20\x01(\rR\x0bdireGuildId\x12(\n\x10radiant_team_tag\
    \x18%\x20\x01(\tR\x0eradiantTeamTag\x12\"\n\rdire_team_tag\x18&\x20\x01(\
    \tR\x0bdireTeamTag\x12\x1b\n\tseries_id\x18'\x20\x01(\rR\x08seriesId\x12\
    \x1f\n\x0bseries_type\x18(\x20\x01(\rR\nseriesType\x12Y\n\x14broadcaster\
    _channels\x18+\x20\x03(\x0b2&.dota.CMsgDOTAMatch.BroadcasterChannelR\x13\
    broadcasterChannels\x12\x16\n\x06engine\x18,\x20\x01(\rR\x06engine\x12L\
    \n\x10custom_game_data\x18-\x20\x01(\x0b2\".dota.CMsgDOTAMatch.CustomGam\
    eDataR\x0ecustomGameData\x12\x1f\n\x0bmatch_flags\x18.\x20\x01(\rR\nmatc\
    hFlags\x120\n\x14private_metadata_key\x18/\x20\x01(\x07R\x12privateMetad\
    ataKey\x12,\n\x12radiant_team_score\x180\x20\x01(\rR\x10radiantTeamScore\
    \x12&\n\x0fdire_team_score\x181\x20\x01(\rR\rdireTeamScore\x128\n\rmatch\
    _outcome\x182\x20\x01(\x0e2\x13.dota.EMatchOutcomeR\x0cmatchOutcome\x12#\
    \n\rtournament_id\x183\x20\x01(\rR\x0ctournamentId\x12)\n\x10tournament_\
    round\x184\x20\x01(\rR\x0ftournamentRound\x12*\n\x11pre_game_duration\
    \x185\x20\x01(\rR\x0fpreGameDuration\x123\n\x07coaches\x189\x20\x03(\x0b\
    2\x19.dota.CMsgDOTAMatch.CoachR\x07coaches\x1a\x95\x19\n\x06Player\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1f\n\x0bplayer_sl\
    ot\x18\x02\x20\x01(\rR\nplayerSlot\x12\x17\n\x07hero_id\x18\x03\x20\x01(\
    \rR\x06heroId\x12\x15\n\x06item_0\x18\x04\x20\x01(\x05R\x05item0\x12\x15\
    \n\x06item_1\x18\x05\x20\x01(\x05R\x05item1\x12\x15\n\x06item_2\x18\x06\
    \x20\x01(\x05R\x05item2\x12\x15\n\x06item_3\x18\x07\x20\x01(\x05R\x05ite\
    m3\x12\x15\n\x06item_4\x18\x08\x20\x01(\x05R\x05item4\x12\x15\n\x06item_\
    5\x18\t\x20\x01(\x05R\x05item5\x12\x15\n\x06item_6\x18;\x20\x01(\x05R\
    \x05item6\x12\x15\n\x06item_7\x18<\x20\x01(\x05R\x05item7\x12\x15\n\x06i\
    tem_8\x18=\x20\x01(\x05R\x05item8\x12\x15\n\x06item_9\x18L\x20\x01(\x05R\
    \x05item9\x12<\n\x1aexpected_team_contribution\x18\n\x20\x01(\x02R\x18ex\
    pectedTeamContribution\x12#\n\rscaled_metric\x18\x0b\x20\x01(\x02R\x0csc\
    aledMetric\x12#\n\rprevious_rank\x18\x0c\x20\x01(\rR\x0cpreviousRank\x12\
    \x1f\n\x0brank_change\x18\r\x20\x01(\x11R\nrankChange\x12\x19\n\x08mmr_t\
    ype\x18J\x20\x01(\rR\x07mmrType\x12\x14\n\x05kills\x18\x0e\x20\x01(\rR\
    \x05kills\x12\x16\n\x06deaths\x18\x0f\x20\x01(\rR\x06deaths\x12\x18\n\
    \x07assists\x18\x10\x20\x01(\rR\x07assists\x12#\n\rleaver_status\x18\x11\
    \x20\x01(\rR\x0cleaverStatus\x12\x12\n\x04gold\x18\x12\x20\x01(\rR\x04go\
    ld\x12\x1b\n\tlast_hits\x18\x13\x20\x01(\rR\x08lastHits\x12\x16\n\x06den\
    ies\x18\x14\x20\x01(\rR\x06denies\x12\x20\n\x0cgold_per_min\x18\x15\x20\
    \x01(\rR\ngoldPerMin\x12\x1c\n\nxp_per_min\x18\x16\x20\x01(\rR\x08xpPerM\
    in\x12\x1d\n\ngold_spent\x18\x17\x20\x01(\rR\tgoldSpent\x12\x1f\n\x0bher\
    o_damage\x18\x18\x20\x01(\rR\nheroDamage\x12!\n\x0ctower_damage\x18\x19\
    \x20\x01(\rR\x0btowerDamage\x12!\n\x0chero_healing\x18\x1a\x20\x01(\rR\
    \x0bheroHealing\x12\x14\n\x05level\x18\x1b\x20\x01(\rR\x05level\x12$\n\
    \x0etime_last_seen\x18\x1c\x20\x01(\rR\x0ctimeLastSeen\x12\x1f\n\x0bplay\
    er_name\x18\x1d\x20\x01(\tR\nplayerName\x122\n\x15support_ability_value\
    \x18\x1e\x20\x01(\rR\x13supportAbilityValue\x12)\n\x10feeding_detected\
    \x18\x20\x20\x01(\x08R\x0ffeedingDetected\x12\x1f\n\x0bsearch_rank\x18\"\
    \x20\x01(\rR\nsearchRank\x126\n\x17search_rank_uncertainty\x18#\x20\x01(\
    \rR\x15searchRankUncertainty\x126\n\x17rank_uncertainty_change\x18$\x20\
    \x01(\x05R\x15rankUncertaintyChange\x12&\n\x0fhero_play_count\x18%\x20\
    \x01(\rR\rheroPlayCount\x12\x19\n\x08party_id\x18&\x20\x01(\x06R\x07part\
    yId\x12,\n\x12scaled_hero_damage\x186\x20\x01(\rR\x10scaledHeroDamage\
    \x12.\n\x13scaled_tower_damage\x187\x20\x01(\rR\x11scaledTowerDamage\x12\
    .\n\x13scaled_hero_healing\x188\x20\x01(\rR\x11scaledHeroHealing\x12!\n\
    \x0cscaled_kills\x18'\x20\x01(\x02R\x0bscaledKills\x12#\n\rscaled_deaths\
    \x18(\x20\x01(\x02R\x0cscaledDeaths\x12%\n\x0escaled_assists\x18)\x20\
    \x01(\x02R\rscaledAssists\x12*\n\x11claimed_farm_gold\x18*\x20\x01(\rR\
    \x0fclaimedFarmGold\x12!\n\x0csupport_gold\x18+\x20\x01(\rR\x0bsupportGo\
    ld\x12%\n\x0eclaimed_denies\x18,\x20\x01(\rR\rclaimedDenies\x12%\n\x0ecl\
    aimed_misses\x18-\x20\x01(\rR\rclaimedMisses\x12\x16\n\x06misses\x18.\
    \x20\x01(\rR\x06misses\x12K\n\x10ability_upgrades\x18/\x20\x03(\x0b2\x20\
    .dota.CMatchPlayerAbilityUpgradeR\x0fabilityUpgrades\x12a\n\x1aadditiona\
    l_units_inventory\x180\x20\x03(\x0b2#.dota.CMatchAdditionalUnitInventory\
    R\x18additionalUnitsInventory\x12H\n\x0fpermanent_buffs\x189\x20\x03(\
    \x0b2\x1f.dota.CMatchPlayerPermanentBuffR\x0epermanentBuffs\x12\x19\n\
    \x08pro_name\x18H\x20\x01(\tR\x07proName\x12\x1b\n\treal_name\x18I\x20\
    \x01(\tR\x08realName\x12S\n\x10custom_game_data\x182\x20\x01(\x0b2).dota\
    .CMsgDOTAMatch.Player.CustomGameDataR\x0ecustomGameData\x128\n\x18active\
    _plus_subscription\x183\x20\x01(\x08R\x16activePlusSubscription\x12\x1b\
    \n\tnet_worth\x184\x20\x01(\rR\x08netWorth\x12%\n\x0ebot_difficulty\x18:\
    \x20\x01(\rR\rbotDifficulty\x12&\n\x0fhero_pick_order\x18?\x20\x01(\rR\r\
    heroPickOrder\x12*\n\x11hero_was_randomed\x18@\x20\x01(\x08R\x0fheroWasR\
    andomed\x12@\n\x1dhero_was_dota_plus_suggestion\x18E\x20\x01(\x08R\x19he\
    roWasDotaPlusSuggestion\x12_\n\x14hero_damage_received\x18C\x20\x03(\x0b\
    2-.dota.CMsgDOTAMatch.Player.HeroDamageReceivedR\x12heroDamageReceived\
    \x12Y\n\x11hero_damage_dealt\x18O\x20\x03(\x0b2-.dota.CMsgDOTAMatch.Play\
    er.HeroDamageReceivedR\x0fheroDamageDealt\x12!\n\x0cseconds_dead\x18F\
    \x20\x01(\rR\x0bsecondsDead\x12+\n\x12gold_lost_to_death\x18G\x20\x01(\r\
    R\x0fgoldLostToDeath\x120\n\x14lane_selection_flags\x18K\x20\x01(\rR\x12\
    laneSelectionFlags\x12!\n\x0cbounty_runes\x18M\x20\x01(\rR\x0bbountyRune\
    s\x12+\n\x11outposts_captured\x18N\x20\x01(\rR\x10outpostsCaptured\x123\
    \n\x0bteam_number\x18P\x20\x01(\x0e2\x12.dota.DOTA_GC_TEAMR\nteamNumber\
    \x12\x1b\n\tteam_slot\x18Q\x20\x01(\rR\x08teamSlot\x1aE\n\x0eCustomGameD\
    ata\x12\x1b\n\tdota_team\x18\x01\x20\x01(\rR\x08dotaTeam\x12\x16\n\x06wi\
    nner\x18\x02\x20\x01(\x08R\x06winner\x1a\xac\x01\n\x12HeroDamageReceived\
    \x12#\n\rpre_reduction\x18\x01\x20\x01(\rR\x0cpreReduction\x12%\n\x0epos\
    t_reduction\x18\x02\x20\x01(\rR\rpostReduction\x12J\n\x0bdamage_type\x18\
    \x03\x20\x01(\x0e2).dota.CMsgDOTAMatch.Player.HeroDamageTypeR\ndamageTyp\
    e\"Y\n\x0eHeroDamageType\x12\x18\n\x14HERO_DAMAGE_PHYSICAL\x10\0\x12\x17\
    \n\x13HERO_DAMAGE_MAGICAL\x10\x01\x12\x14\n\x10HERO_DAMAGE_PURE\x10\x02\
    \x1aD\n\x0fBroadcasterInfo\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\tac\
    countId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x1a\xd0\x01\n\x12B\
    roadcasterChannel\x12!\n\x0ccountry_code\x18\x01\x20\x01(\tR\x0bcountryC\
    ode\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12P\n\
    \x11broadcaster_infos\x18\x03\x20\x03(\x0b2#.dota.CMsgDOTAMatch.Broadcas\
    terInfoR\x10broadcasterInfos\x12#\n\rlanguage_code\x18\x04\x20\x01(\tR\
    \x0clanguageCode\x1a\xd7\x01\n\x05Coach\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12\x1d\n\ncoach_name\x18\x02\x20\x01(\tR\tcoach\
    Name\x12!\n\x0ccoach_rating\x18\x03\x20\x01(\rR\x0bcoachRating\x12\x1d\n\
    \ncoach_team\x18\x04\x20\x01(\rR\tcoachTeam\x12$\n\x0ecoach_party_id\x18\
    \x05\x20\x01(\x04R\x0ccoachPartyId\x12(\n\x10is_private_coach\x18\x06\
    \x20\x01(\x08R\x0eisPrivateCoach\x1aQ\n\x0eCustomGameData\x12$\n\x0ecust\
    om_game_id\x18\x01\x20\x01(\x04R\x0ccustomGameId\x12\x19\n\x08map_name\
    \x18\x02\x20\x01(\tR\x07mapName\"P\n\x0bReplayState\x12\x14\n\x10REPLAY_\
    AVAILABLE\x10\0\x12\x17\n\x13REPLAY_NOT_RECORDED\x10\x01\x12\x12\n\x0eRE\
    PLAY_EXPIRED\x10\x02\"\xb1\x01\n\x0eCMsgPlayerCard\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12F\n\rstat_modifier\x18\x02\x20\x03(\
    \x0b2!.dota.CMsgPlayerCard.StatModifierR\x0cstatModifier\x1a8\n\x0cStatM\
    odifier\x12\x12\n\x04stat\x18\x01\x20\x01(\rR\x04stat\x12\x14\n\x05value\
    \x18\x02\x20\x01(\rR\x05value\"\x87\x05\n\x1aCMsgDOTAFantasyPlayerStats\
    \x12*\n\x11player_account_id\x18\x01\x20\x01(\rR\x0fplayerAccountId\x12\
    \x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\x12'\n\x0fmatch_comp\
    leted\x18\x03\x20\x01(\x08R\x0ematchCompleted\x12\x17\n\x07team_id\x18\
    \x04\x20\x01(\rR\x06teamId\x12\x1b\n\tleague_id\x18\x05\x20\x01(\rR\x08l\
    eagueId\x12\x14\n\x05delay\x18\x06\x20\x01(\rR\x05delay\x12\x1b\n\tserie\
    s_id\x18\x07\x20\x01(\rR\x08seriesId\x12\x1f\n\x0bseries_type\x18\x08\
    \x20\x01(\rR\nseriesType\x12\x14\n\x05kills\x18\n\x20\x01(\rR\x05kills\
    \x12\x16\n\x06deaths\x18\x0b\x20\x01(\rR\x06deaths\x12\x0e\n\x02cs\x18\
    \x0c\x20\x01(\rR\x02cs\x12\x10\n\x03gpm\x18\r\x20\x01(\x02R\x03gpm\x12\
    \x1f\n\x0btower_kills\x18\x0e\x20\x01(\rR\ntowerKills\x12!\n\x0croshan_k\
    ills\x18\x0f\x20\x01(\rR\x0broshanKills\x127\n\x17teamfight_participatio\
    n\x18\x10\x20\x01(\x02R\x16teamfightParticipation\x12!\n\x0cwards_placed\
    \x18\x11\x20\x01(\rR\x0bwardsPlaced\x12#\n\rcamps_stacked\x18\x12\x20\
    \x01(\rR\x0ccampsStacked\x12#\n\rrunes_grabbed\x18\x13\x20\x01(\rR\x0cru\
    nesGrabbed\x12\x1f\n\x0bfirst_blood\x18\x14\x20\x01(\rR\nfirstBlood\x12\
    \x14\n\x05stuns\x18\x15\x20\x01(\x02R\x05stuns\"]\n\x1fCMsgDOTAFantasyPl\
    ayerMatchStats\x12:\n\x07matches\x18\x01\x20\x03(\x0b2\x20.dota.CMsgDOTA\
    FantasyPlayerStatsR\x07matches\"\xdf\n\n\x14CMsgDOTABotDebugInfo\x122\n\
    \x04bots\x18\x01\x20\x03(\x0b2\x1e.dota.CMsgDOTABotDebugInfo.BotR\x04bot\
    s\x12/\n\x14desire_push_lane_top\x18\x02\x20\x01(\x02R\x11desirePushLane\
    Top\x12/\n\x14desire_push_lane_mid\x18\x03\x20\x01(\x02R\x11desirePushLa\
    neMid\x12/\n\x14desire_push_lane_bot\x18\x04\x20\x01(\x02R\x11desirePush\
    LaneBot\x123\n\x16desire_defend_lane_top\x18\x05\x20\x01(\x02R\x13desire\
    DefendLaneTop\x123\n\x16desire_defend_lane_mid\x18\x06\x20\x01(\x02R\x13\
    desireDefendLaneMid\x123\n\x16desire_defend_lane_bot\x18\x07\x20\x01(\
    \x02R\x13desireDefendLaneBot\x12/\n\x14desire_farm_lane_top\x18\x08\x20\
    \x01(\x02R\x11desireFarmLaneTop\x12/\n\x14desire_farm_lane_mid\x18\t\x20\
    \x01(\x02R\x11desireFarmLaneMid\x12/\n\x14desire_farm_lane_bot\x18\n\x20\
    \x01(\x02R\x11desireFarmLaneBot\x12,\n\x12desire_farm_roshan\x18\x0b\x20\
    \x01(\x02R\x10desireFarmRoshan\x12%\n\x0eexecution_time\x18\x0c\x20\x01(\
    \x02R\rexecutionTime\x12\x1f\n\x0brune_status\x18\r\x20\x03(\rR\nruneSta\
    tus\x1a\xd7\x05\n\x03Bot\x12&\n\x0fplayer_owner_id\x18\x01\x20\x01(\x05R\
    \rplayerOwnerId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\x12\
    \x1e\n\ndifficulty\x18\x03\x20\x01(\rR\ndifficulty\x12#\n\rpower_current\
    \x18\x04\x20\x01(\rR\x0cpowerCurrent\x12\x1b\n\tpower_max\x18\x05\x20\
    \x01(\rR\x08powerMax\x12\"\n\rmove_target_x\x18\x06\x20\x01(\rR\x0bmoveT\
    argetX\x12\"\n\rmove_target_y\x18\x07\x20\x01(\rR\x0bmoveTargetY\x12\"\n\
    \rmove_target_z\x18\x08\x20\x01(\rR\x0bmoveTargetZ\x12$\n\x0eactive_mode\
    _id\x18\t\x20\x01(\rR\x0cactiveModeId\x12%\n\x0eexecution_time\x18\n\x20\
    \x01(\x02R\rexecutionTime\x129\n\x05modes\x18\x0b\x20\x03(\x0b2#.dota.CM\
    sgDOTABotDebugInfo.Bot.ModeR\x05modes\x12=\n\x06action\x18\x0c\x20\x01(\
    \x0b2%.dota.CMsgDOTABotDebugInfo.Bot.ActionR\x06action\x1a\xad\x01\n\x04\
    Mode\x12\x17\n\x07mode_id\x18\x01\x20\x01(\rR\x06modeId\x12\x16\n\x06des\
    ire\x18\x02\x20\x01(\x02R\x06desire\x12#\n\rtarget_entity\x18\x03\x20\
    \x01(\x05R\x0ctargetEntity\x12\x19\n\x08target_x\x18\x04\x20\x01(\rR\x07\
    targetX\x12\x19\n\x08target_y\x18\x05\x20\x01(\rR\x07targetY\x12\x19\n\
    \x08target_z\x18\x06\x20\x01(\rR\x07targetZ\x1aJ\n\x06Action\x12\x1b\n\t\
    action_id\x18\x01\x20\x01(\rR\x08actionId\x12#\n\raction_target\x18\x02\
    \x20\x01(\tR\x0cactionTarget\"u\n\x12CMsgSuccessfulHero\x12\x17\n\x07her\
    o_id\x18\x01\x20\x01(\rR\x06heroId\x12\x1f\n\x0bwin_percent\x18\x02\x20\
    \x01(\x02R\nwinPercent\x12%\n\x0elongest_streak\x18\x03\x20\x01(\rR\rlon\
    gestStreak\"\xff\x02\n\x13CMsgRecentMatchInfo\x12\x19\n\x08match_id\x18\
    \x01\x20\x01(\x04R\x07matchId\x120\n\tgame_mode\x18\x02\x20\x01(\x0e2\
    \x13.dota.DOTA_GameModeR\x08gameMode\x12\x14\n\x05kills\x18\x03\x20\x01(\
    \rR\x05kills\x12\x16\n\x06deaths\x18\x04\x20\x01(\rR\x06deaths\x12\x18\n\
    \x07assists\x18\x05\x20\x01(\rR\x07assists\x12\x1a\n\x08duration\x18\x06\
    \x20\x01(\rR\x08duration\x12\x1f\n\x0bplayer_slot\x18\x07\x20\x01(\rR\np\
    layerSlot\x128\n\rmatch_outcome\x18\x08\x20\x01(\x0e2\x13.dota.EMatchOut\
    comeR\x0cmatchOutcome\x12\x1c\n\ttimestamp\x18\t\x20\x01(\rR\ttimestamp\
    \x12\x1d\n\nlobby_type\x18\n\x20\x01(\rR\tlobbyType\x12\x1f\n\x0bteam_nu\
    mber\x18\x0b\x20\x01(\rR\nteamNumber\"\xf0\x01\n\rCMsgMatchTips\x121\n\
    \x04tips\x18\x02\x20\x03(\x0b2\x1d.dota.CMsgMatchTips.SingleTipR\x04tips\
    \x1a\xab\x01\n\tSingleTip\x12*\n\x11source_account_id\x18\x01\x20\x01(\r\
    R\x0fsourceAccountId\x12*\n\x11target_account_id\x18\x02\x20\x01(\rR\x0f\
    targetAccountId\x12\x1d\n\ntip_amount\x18\x03\x20\x01(\rR\ttipAmount\x12\
    '\n\x08event_id\x18\x04\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\"\x9b\
    \x0b\n\x14CMsgDOTAMatchMinimal\x12\x19\n\x08match_id\x18\x01\x20\x01(\
    \x04R\x07matchId\x12\x1d\n\nstart_time\x18\x02\x20\x01(\x07R\tstartTime\
    \x12\x1a\n\x08duration\x18\x03\x20\x01(\rR\x08duration\x120\n\tgame_mode\
    \x18\x04\x20\x01(\x0e2\x13.dota.DOTA_GameModeR\x08gameMode\x12;\n\x07pla\
    yers\x18\x06\x20\x03(\x0b2!.dota.CMsgDOTAMatchMinimal.PlayerR\x07players\
    \x12<\n\x07tourney\x18\x07\x20\x01(\x0b2\".dota.CMsgDOTAMatchMinimal.Tou\
    rneyR\x07tourney\x128\n\rmatch_outcome\x18\x08\x20\x01(\x0e2\x13.dota.EM\
    atchOutcomeR\x0cmatchOutcome\x12#\n\rradiant_score\x18\t\x20\x01(\rR\x0c\
    radiantScore\x12\x1d\n\ndire_score\x18\n\x20\x01(\rR\tdireScore\x12\x1d\
    \n\nlobby_type\x18\x0b\x20\x01(\rR\tlobbyType\x1a\xa5\x02\n\x06Player\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x17\n\x07hero_\
    id\x18\x02\x20\x01(\rR\x06heroId\x12\x14\n\x05kills\x18\x03\x20\x01(\rR\
    \x05kills\x12\x16\n\x06deaths\x18\x04\x20\x01(\rR\x06deaths\x12\x18\n\
    \x07assists\x18\x05\x20\x01(\rR\x07assists\x12\x14\n\x05items\x18\x06\
    \x20\x03(\x05R\x05items\x12\x1f\n\x0bplayer_slot\x18\x07\x20\x01(\rR\npl\
    ayerSlot\x12\x19\n\x08pro_name\x18\x08\x20\x01(\tR\x07proName\x12\x14\n\
    \x05level\x18\t\x20\x01(\rR\x05level\x123\n\x0bteam_number\x18\n\x20\x01\
    (\x0e2\x12.dota.DOTA_GC_TEAMR\nteamNumber\x1a\xba\x05\n\x07Tourney\x12\
    \x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\x12\x1f\n\x0bseries_ty\
    pe\x18\x08\x20\x01(\rR\nseriesType\x12\x1f\n\x0bseries_game\x18\t\x20\
    \x01(\rR\nseriesGame\x12A\n\x1dweekend_tourney_tournament_id\x18\n\x20\
    \x01(\rR\x1aweekendTourneyTournamentId\x12F\n\x20weekend_tourney_season_\
    trophy_id\x18\x0b\x20\x01(\rR\x1cweekendTourneySeasonTrophyId\x128\n\x18\
    weekend_tourney_division\x18\x0c\x20\x01(\rR\x16weekendTourneyDivision\
    \x12=\n\x1bweekend_tourney_skill_level\x18\r\x20\x01(\rR\x18weekendTourn\
    eySkillLevel\x12&\n\x0fradiant_team_id\x18\x02\x20\x01(\rR\rradiantTeamI\
    d\x12*\n\x11radiant_team_name\x18\x03\x20\x01(\tR\x0fradiantTeamName\x12\
    *\n\x11radiant_team_logo\x18\x04\x20\x01(\x06R\x0fradiantTeamLogo\x121\n\
    \x15radiant_team_logo_url\x18\x0e\x20\x01(\tR\x12radiantTeamLogoUrl\x12\
    \x20\n\x0cdire_team_id\x18\x05\x20\x01(\rR\ndireTeamId\x12$\n\x0edire_te\
    am_name\x18\x06\x20\x01(\tR\x0cdireTeamName\x12$\n\x0edire_team_logo\x18\
    \x07\x20\x01(\x06R\x0cdireTeamLogo\x12+\n\x12dire_team_logo_url\x18\x0f\
    \x20\x01(\tR\x0fdireTeamLogoUrl\"Y\n\x13CMsgConsumableUsage\x12\x19\n\
    \x08item_def\x18\x01\x20\x01(\rR\x07itemDef\x12'\n\x0fquantity_change\
    \x18\x02\x20\x01(\x05R\x0equantityChange\"\xf2\x01\n\x18CMsgMatchConsuma\
    bleUsage\x12b\n\x17player_consumables_used\x18\x01\x20\x03(\x0b2*.dota.C\
    MsgMatchConsumableUsage.PlayerUsageR\x15playerConsumablesUsed\x1ar\n\x0b\
    PlayerUsage\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12D\n\
    \x10consumables_used\x18\x02\x20\x03(\x0b2\x19.dota.CMsgConsumableUsageR\
    \x0fconsumablesUsed\"\xe5\x01\n\x1aCMsgMatchEventActionGrants\x12R\n\rpl\
    ayer_grants\x18\x01\x20\x03(\x0b2-.dota.CMsgMatchEventActionGrants.Playe\
    rGrantsR\x0cplayerGrants\x1as\n\x0cPlayerGrants\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12D\n\x0factions_granted\x18\x03\x20\
    \x03(\x0b2\x1b.dota.CMsgPendingEventAwardR\x0eactionsGranted\"\x96\x01\n\
    \x17CMsgCustomGameWhitelist\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07\
    version\x124\n\x16custom_games_whitelist\x18\x02\x20\x03(\x04R\x14custom\
    GamesWhitelist\x12+\n\x11disable_whitelist\x18\x03\x20\x01(\x08R\x10disa\
    bleWhitelist\"\x85\x02\n\x1eCMsgCustomGameWhitelistForEdit\x12`\n\x11whi\
    telist_entries\x18\x01\x20\x03(\x0b23.dota.CMsgCustomGameWhitelistForEdi\
    t.WhitelistEntryR\x10whitelistEntries\x1a\x80\x01\n\x0eWhitelistEntry\
    \x12$\n\x0ecustom_game_id\x18\x01\x20\x01(\x04R\x0ccustomGameId\x12H\n\
    \x0fwhitelist_state\x18\x02\x20\x01(\x0e2\x1f.dota.ECustomGameWhitelistS\
    tateR\x0ewhitelistState\"\xe3\x01\n\x19CMsgPlayerRecentMatchInfo\x12\x19\
    \n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1c\n\ttimestamp\x18\
    \x02\x20\x01(\rR\ttimestamp\x12\x1a\n\x08duration\x18\x03\x20\x01(\rR\
    \x08duration\x12\x10\n\x03win\x18\x04\x20\x01(\x08R\x03win\x12\x17\n\x07\
    hero_id\x18\x05\x20\x01(\rR\x06heroId\x12\x14\n\x05kills\x18\x06\x20\x01\
    (\rR\x05kills\x12\x16\n\x06deaths\x18\x07\x20\x01(\rR\x06deaths\x12\x18\
    \n\x07assists\x18\x08\x20\x01(\rR\x07assists\"C\n\x15CMsgPlayerMatchReco\
    rd\x12\x12\n\x04wins\x18\x01\x20\x01(\rR\x04wins\x12\x16\n\x06losses\x18\
    \x02\x20\x01(\rR\x06losses\"\\\n\x1dCMsgPlayerRecentMatchOutcomes\x12\
    \x1a\n\x08outcomes\x18\x01\x20\x01(\rR\x08outcomes\x12\x1f\n\x0bmatch_co\
    unt\x18\x02\x20\x01(\rR\nmatchCount\"W\n\x18CMsgPlayerRecentCommends\x12\
    \x1a\n\x08commends\x18\x01\x20\x01(\rR\x08commends\x12\x1f\n\x0bmatch_co\
    unt\x18\x02\x20\x01(\rR\nmatchCount\"\x95\x04\n\x1fCMsgPlayerRecentAccom\
    plishments\x12L\n\x0frecent_outcomes\x18\x01\x20\x01(\x0b2#.dota.CMsgPla\
    yerRecentMatchOutcomesR\x0erecentOutcomes\x12>\n\x0ctotal_record\x18\x02\
    \x20\x01(\x0b2\x1b.dota.CMsgPlayerMatchRecordR\x0btotalRecord\x12+\n\x11\
    prediction_streak\x18\x03\x20\x01(\rR\x10predictionStreak\x124\n\x16plus\
    _prediction_streak\x18\x04\x20\x01(\rR\x14plusPredictionStreak\x12G\n\
    \x0frecent_commends\x18\x05\x20\x01(\x0b2\x1e.dota.CMsgPlayerRecentComme\
    ndsR\x0erecentCommends\x122\n\x15first_match_timestamp\x18\x06\x20\x01(\
    \rR\x13firstMatchTimestamp\x12>\n\nlast_match\x18\x07\x20\x01(\x0b2\x1f.\
    dota.CMsgPlayerRecentMatchInfoR\tlastMatch\x12D\n\x0brecent_mvps\x18\x08\
    \x20\x01(\x0b2#.dota.CMsgPlayerRecentMatchOutcomesR\nrecentMvps\"\xf3\
    \x01\n#CMsgPlayerHeroRecentAccomplishments\x12L\n\x0frecent_outcomes\x18\
    \x01\x20\x01(\x0b2#.dota.CMsgPlayerRecentMatchOutcomesR\x0erecentOutcome\
    s\x12>\n\x0ctotal_record\x18\x02\x20\x01(\x0b2\x1b.dota.CMsgPlayerMatchR\
    ecordR\x0btotalRecord\x12>\n\nlast_match\x18\x03\x20\x01(\x0b2\x1f.dota.\
    CMsgPlayerRecentMatchInfoR\tlastMatch\"\xd7\x01\n\x19CMsgRecentAccomplis\
    hments\x12\\\n\x16player_accomplishments\x18\x01\x20\x01(\x0b2%.dota.CMs\
    gPlayerRecentAccomplishmentsR\x15playerAccomplishments\x12\\\n\x14hero_a\
    ccomplishments\x18\x02\x20\x01(\x0b2).dota.CMsgPlayerHeroRecentAccomplis\
    hmentsR\x13heroAccomplishments\"j\n0CMsgServerToGCRequestPlayerRecentAcc\
    omplishments\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\"\xc8\x02\n8CMsgServerTo\
    GCRequestPlayerRecentAccomplishmentsResponse\x12`\n\x06result\x18\x01\
    \x20\x01(\x0e2H.dota.CMsgServerToGCRequestPlayerRecentAccomplishmentsRes\
    ponse.EResponseR\x06result\x12V\n\x16player_accomplishments\x18\x02\x20\
    \x01(\x0b2\x1f.dota.CMsgRecentAccomplishmentsR\x15playerAccomplishments\
    \"R\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSucce\
    ss\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\
    \x03\"m\n\x18CMsgArcanaVoteMatchVotes\x12\x19\n\x08match_id\x18\x01\x20\
    \x01(\rR\x07matchId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\
    \x12\x1d\n\nvote_count\x18\x03\x20\x01(\rR\tvoteCount\"\xe7\x01\n(CMsgGC\
    toGCAssociatedExploiterAccountInfo\x12\x1d\n\naccount_id\x18\x01\x20\x01\
    (\rR\taccountId\x121\n\x15num_matches_to_search\x18\x02\x20\x01(\rR\x12n\
    umMatchesToSearch\x123\n\x16min_shared_match_count\x18\x03\x20\x01(\rR\
    \x13minSharedMatchCount\x124\n\x16num_additional_players\x18\x04\x20\x01\
    (\rR\x14numAdditionalPlayers\"\xac\x03\n0CMsgGCtoGCAssociatedExploiterAc\
    countInfoResponse\x12Z\n\x08accounts\x18\x01\x20\x03(\x0b2>.dota.CMsgGCt\
    oGCAssociatedExploiterAccountInfoResponse.AccountR\x08accounts\x1a\x9b\
    \x02\n\x07Account\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12,\n\x12num_common_matches\x18\x02\x20\x01(\rR\x10numCommonMatches\
    \x122\n\x15earliest_common_match\x18\x03\x20\x01(\rR\x13earliestCommonMa\
    tch\x12.\n\x13latest_common_match\x18\x04\x20\x01(\rR\x11latestCommonMat\
    ch\x12\x1e\n\ngeneration\x18\x05\x20\x01(\rR\ngeneration\x12\x18\n\x07pe\
    rsona\x18\x06\x20\x01(\tR\x07persona\x12%\n\x0ealready_banned\x18\x07\
    \x20\x01(\x08R\ralreadyBanned\"\x8d\x03\n\x10CMsgPullTabsData\x121\n\x05\
    slots\x18\x01\x20\x03(\x0b2\x1b.dota.CMsgPullTabsData.SlotR\x05slots\x12\
    :\n\x08jackpots\x18\x02\x20\x03(\x0b2\x1e.dota.CMsgPullTabsData.JackpotR\
    \x08jackpots\x12\x1d\n\nlast_board\x18\x03\x20\x01(\rR\tlastBoard\x1a\
    \x8e\x01\n\x04Slot\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\
    \x12\x19\n\x08board_id\x18\x02\x20\x01(\rR\x07boardId\x12\x17\n\x07hero_\
    id\x18\x03\x20\x01(\rR\x06heroId\x12\x1b\n\taction_id\x18\x04\x20\x01(\r\
    R\x08actionId\x12\x1a\n\x08redeemed\x18\x05\x20\x01(\x08R\x08redeemed\
    \x1aZ\n\x07Jackpot\x12\x19\n\x08board_id\x18\x01\x20\x01(\rR\x07boardId\
    \x12\x1b\n\taction_id\x18\x02\x20\x01(\rR\x08actionId\x12\x17\n\x07hero_\
    id\x18\x03\x20\x01(\rR\x06heroId\"\xb4\x03\n\x12CMsgUnderDraftData\x12C\
    \n\x0bbench_slots\x18\x01\x20\x03(\x0b2\".dota.CMsgUnderDraftData.BenchS\
    lotR\nbenchSlots\x12@\n\nshop_slots\x18\x02\x20\x03(\x0b2!.dota.CMsgUnde\
    rDraftData.ShopSlotR\tshopSlots\x12\x12\n\x04gold\x18\x03\x20\x01(\rR\
    \x04gold\x12\x1d\n\ntotal_gold\x18\x04\x20\x01(\rR\ttotalGold\x12%\n\x0e\
    not_restorable\x18\x05\x20\x01(\x08R\rnotRestorable\x1aS\n\tBenchSlot\
    \x12\x17\n\x07slot_id\x18\x01\x20\x01(\rR\x06slotId\x12\x17\n\x07hero_id\
    \x18\x02\x20\x01(\rR\x06heroId\x12\x14\n\x05stars\x18\x03\x20\x01(\rR\
    \x05stars\x1ah\n\x08ShopSlot\x12\x17\n\x07slot_id\x18\x01\x20\x01(\rR\
    \x06slotId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\x12*\n\x11\
    is_special_reward\x18\x03\x20\x01(\x08R\x0fisSpecialReward\"^\n\x13CMsgP\
    layerTitleData\x12\x14\n\x05title\x18\x01\x20\x03(\rR\x05title\x12\x19\n\
    \x08event_id\x18\x02\x20\x03(\rR\x07eventId\x12\x16\n\x06active\x18\x03\
    \x20\x01(\rR\x06active\"\x94\x02\n\x16CMsgDOTATriviaQuestion\x12\x1f\n\
    \x0bquestion_id\x18\x01\x20\x01(\rR\nquestionId\x12=\n\x08category\x18\
    \x02\x20\x01(\x0e2!.dota.EDOTATriviaQuestionCategoryR\x08category\x12\
    \x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimestamp\x12%\n\x0equestion_valu\
    e\x18\x04\x20\x01(\tR\rquestionValue\x12#\n\ranswer_values\x18\x05\x20\
    \x03(\tR\x0canswerValues\x120\n\x14correct_answer_index\x18\x06\x20\x01(\
    \rR\x12correctAnswerIndex\"v\n$CMsgDOTATriviaQuestionAnswersSummary\x12+\
    \n\x11summary_available\x18\x01\x20\x01(\x08R\x10summaryAvailable\x12!\n\
    \x0cpicked_count\x18\x02\x20\x03(\rR\x0bpickedCount\"g\n\x1dCMsgGameData\
    SpecialValueBonus\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\
    \n\x05value\x18\x02\x20\x01(\x02R\x05value\x12\x1c\n\toperation\x18\x03\
    \x20\x01(\rR\toperation\"\xd7\x01\n\x19CMsgGameDataSpecialValues\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12!\n\x0cvalues_float\x18\x02\
    \x20\x03(\x02R\x0bvaluesFloat\x12#\n\ris_percentage\x18\x04\x20\x01(\x08\
    R\x0cisPercentage\x12\x1f\n\x0bheading_loc\x18\x05\x20\x01(\tR\nheadingL\
    oc\x12=\n\x07bonuses\x18\x06\x20\x03(\x0b2#.dota.CMsgGameDataSpecialValu\
    eBonusR\x07bonuses\"\xad\n\n\x19CMsgGameDataAbilityOrItem\x12\x0e\n\x02i\
    d\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04n\
    ame\x12\x19\n\x08name_loc\x18\x05\x20\x01(\tR\x07nameLoc\x12\x19\n\x08de\
    sc_loc\x18\x06\x20\x01(\tR\x07descLoc\x12\x19\n\x08lore_loc\x18\x07\x20\
    \x01(\tR\x07loreLoc\x12\x1b\n\tnotes_loc\x18\x08\x20\x03(\tR\x08notesLoc\
    \x12\x1b\n\tshard_loc\x18\t\x20\x01(\tR\x08shardLoc\x12\x1f\n\x0bscepter\
    _loc\x18\n\x20\x01(\tR\nscepterLoc\x12\x12\n\x04type\x18\x14\x20\x01(\rR\
    \x04type\x12\x1a\n\x08behavior\x18\x15\x20\x01(\x04R\x08behavior\x12\x1f\
    \n\x0btarget_team\x18\x16\x20\x01(\rR\ntargetTeam\x12\x1f\n\x0btarget_ty\
    pe\x18\x17\x20\x01(\rR\ntargetType\x12\x14\n\x05flags\x18\x18\x20\x01(\r\
    R\x05flags\x12\x16\n\x06damage\x18\x19\x20\x01(\rR\x06damage\x12\x1a\n\
    \x08immunity\x18\x1a\x20\x01(\rR\x08immunity\x12\x20\n\x0bdispellable\
    \x18\x1b\x20\x01(\rR\x0bdispellable\x12\x1b\n\tmax_level\x18\x1c\x20\x01\
    (\rR\x08maxLevel\x12\x1f\n\x0bcast_ranges\x18\x1e\x20\x03(\rR\ncastRange\
    s\x12\x1f\n\x0bcast_points\x18\x1f\x20\x03(\x02R\ncastPoints\x12#\n\rcha\
    nnel_times\x18\x20\x20\x03(\x02R\x0cchannelTimes\x12\x1c\n\tcooldowns\
    \x18!\x20\x03(\x02R\tcooldowns\x12\x1c\n\tdurations\x18\"\x20\x03(\x02R\
    \tdurations\x12\x18\n\x07damages\x18#\x20\x03(\rR\x07damages\x12\x1d\n\n\
    mana_costs\x18$\x20\x03(\rR\tmanaCosts\x12\x1d\n\ngold_costs\x18%\x20\
    \x03(\rR\tgoldCosts\x12!\n\x0chealth_costs\x18&\x20\x03(\rR\x0bhealthCos\
    ts\x12F\n\x0especial_values\x18(\x20\x03(\x0b2\x1f.dota.CMsgGameDataSpec\
    ialValuesR\rspecialValues\x12\x17\n\x07is_item\x182\x20\x01(\x08R\x06isI\
    tem\x12.\n\x13ability_has_scepter\x18<\x20\x01(\x08R\x11abilityHasScepte\
    r\x12*\n\x11ability_has_shard\x18=\x20\x01(\x08R\x0fabilityHasShard\x12@\
    \n\x1dability_is_granted_by_scepter\x18>\x20\x01(\x08R\x19abilityIsGrant\
    edByScepter\x12<\n\x1bability_is_granted_by_shard\x18?\x20\x01(\x08R\x17\
    abilityIsGrantedByShard\x12\x1b\n\titem_cost\x18F\x20\x01(\rR\x08itemCos\
    t\x120\n\x14item_initial_charges\x18G\x20\x01(\rR\x12itemInitialCharges\
    \x12*\n\x11item_neutral_tier\x18H\x20\x01(\rR\x0fitemNeutralTier\x12$\n\
    \x0eitem_stock_max\x18I\x20\x01(\rR\x0citemStockMax\x12&\n\x0fitem_stock\
    _time\x18J\x20\x01(\x02R\ritemStockTime\x12!\n\x0citem_quality\x18U\x20\
    \x01(\rR\x0bitemQuality\"\xf1\x08\n\x10CMsgGameDataHero\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \x12\x19\n\x08order_id\x18\x03\x20\x01(\rR\x07orderId\x12\x19\n\x08name_\
    loc\x18\x05\x20\x01(\tR\x07nameLoc\x12\x17\n\x07bio_loc\x18\x06\x20\x01(\
    \tR\x06bioLoc\x12\x19\n\x08hype_loc\x18\x07\x20\x01(\tR\x07hypeLoc\x12\
    \x20\n\x0cnpe_desc_loc\x18\x08\x20\x01(\tR\nnpeDescLoc\x12\x19\n\x08str_\
    base\x18\n\x20\x01(\rR\x07strBase\x12\x19\n\x08str_gain\x18\x0b\x20\x01(\
    \x02R\x07strGain\x12\x19\n\x08agi_base\x18\x0c\x20\x01(\rR\x07agiBase\
    \x12\x19\n\x08agi_gain\x18\r\x20\x01(\x02R\x07agiGain\x12\x19\n\x08int_b\
    ase\x18\x0e\x20\x01(\rR\x07intBase\x12\x19\n\x08int_gain\x18\x0f\x20\x01\
    (\x02R\x07intGain\x12!\n\x0cprimary_attr\x18\x14\x20\x01(\rR\x0bprimaryA\
    ttr\x12\x1e\n\ncomplexity\x18\x15\x20\x01(\rR\ncomplexity\x12+\n\x11atta\
    ck_capability\x18\x16\x20\x01(\rR\x10attackCapability\x12\x1f\n\x0brole_\
    levels\x18\x17\x20\x03(\rR\nroleLevels\x12\x1d\n\ndamage_min\x18\x18\x20\
    \x01(\rR\tdamageMin\x12\x1d\n\ndamage_max\x18\x19\x20\x01(\rR\tdamageMax\
    \x12\x1f\n\x0battack_rate\x18\x1a\x20\x01(\x02R\nattackRate\x12!\n\x0cat\
    tack_range\x18\x1b\x20\x01(\rR\x0battackRange\x12)\n\x10projectile_speed\
    \x18\x1c\x20\x01(\rR\x0fprojectileSpeed\x12\x14\n\x05armor\x18\x1d\x20\
    \x01(\x02R\x05armor\x12)\n\x10magic_resistance\x18\x1e\x20\x01(\rR\x0fma\
    gicResistance\x12%\n\x0emovement_speed\x18\x1f\x20\x01(\rR\rmovementSpee\
    d\x12\x1b\n\tturn_rate\x18\x20\x20\x01(\x02R\x08turnRate\x12&\n\x0fsight\
    _range_day\x18!\x20\x01(\rR\rsightRangeDay\x12*\n\x11sight_range_night\
    \x18\"\x20\x01(\rR\x0fsightRangeNight\x12\x1d\n\nmax_health\x18#\x20\x01\
    (\rR\tmaxHealth\x12!\n\x0chealth_regen\x18$\x20\x01(\x02R\x0bhealthRegen\
    \x12\x19\n\x08max_mana\x18%\x20\x01(\rR\x07maxMana\x12\x1d\n\nmana_regen\
    \x18&\x20\x01(\x02R\tmanaRegen\x12=\n\tabilities\x18(\x20\x03(\x0b2\x1f.\
    dota.CMsgGameDataAbilityOrItemR\tabilities\x129\n\x07talents\x18)\x20\
    \x03(\x0b2\x1f.dota.CMsgGameDataAbilityOrItemR\x07talents\"V\n\x15CMsgGa\
    meDataAbilities\x12=\n\tabilities\x18\x01\x20\x03(\x0b2\x1f.dota.CMsgGam\
    eDataAbilityOrItemR\tabilities\"J\n\x11CMsgGameDataItems\x125\n\x05items\
    \x18\x01\x20\x03(\x0b2\x1f.dota.CMsgGameDataAbilityOrItemR\x05items\"D\n\
    \x12CMsgGameDataHeroes\x12.\n\x06heroes\x18\x01\x20\x03(\x0b2\x16.dota.C\
    MsgGameDataHeroR\x06heroes\"\x8c\x02\n\x14CMsgGameDataHeroList\x12;\n\
    \x06heroes\x18\x01\x20\x03(\x0b2#.dota.CMsgGameDataHeroList.HeroInfoR\
    \x06heroes\x1a\xb6\x01\n\x08HeroInfo\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x19\n\x08name_l\
    oc\x18\x03\x20\x01(\tR\x07nameLoc\x12(\n\x10name_english_loc\x18\x04\x20\
    \x01(\tR\x0enameEnglishLoc\x12!\n\x0cprimary_attr\x18\x05\x20\x01(\rR\
    \x0bprimaryAttr\x12\x1e\n\ncomplexity\x18\x06\x20\x01(\rR\ncomplexity\"\
    \x9f\x02\n\x1bCMsgGameDataItemAbilityList\x12W\n\ritemabilities\x18\x01\
    \x20\x03(\x0b21.dota.CMsgGameDataItemAbilityList.ItemAbilityInfoR\ritema\
    bilities\x1a\xa6\x01\n\x0fItemAbilityInfo\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\x05R\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x19\n\
    \x08name_loc\x18\x03\x20\x01(\tR\x07nameLoc\x12(\n\x10name_english_loc\
    \x18\x04\x20\x01(\tR\x0enameEnglishLoc\x12*\n\x11neutral_item_tier\x18\
    \x05\x20\x01(\x05R\x0fneutralItemTier\"K\n\x19CMsgLobbyAbilityDraftData\
    \x12.\n\x13shuffle_draft_order\x18\x01\x20\x01(\x08R\x11shuffleDraftOrde\
    r\"\x95\x02\n\x18CSOEconItemDropRateBonus\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12'\n\x0fexpiration_date\x18\x02\x20\x01(\x07R\
    \x0eexpirationDate\x12\x14\n\x05bonus\x18\x03\x20\x01(\x02R\x05bonus\x12\
    \x1f\n\x0bbonus_count\x18\x04\x20\x01(\rR\nbonusCount\x12\x17\n\x07item_\
    id\x18\x05\x20\x01(\x04R\x06itemId\x12\x1b\n\tdef_index\x18\x06\x20\x01(\
    \rR\x08defIndex\x12!\n\x0cseconds_left\x18\x07\x20\x01(\rR\x0bsecondsLef\
    t\x12!\n\x0cbooster_type\x18\x08\x20\x01(\rR\x0bboosterType\"\xad\x02\n\
    \x1dCSOEconItemTournamentPassport\x12\x1d\n\naccount_id\x18\x01\x20\x01(\
    \rR\taccountId\x12\x1b\n\tleague_id\x18\x02\x20\x01(\rR\x08leagueId\x12\
    \x17\n\x07item_id\x18\x03\x20\x01(\x04R\x06itemId\x122\n\x15original_pur\
    chaser_id\x18\x04\x20\x01(\rR\x13originalPurchaserId\x12)\n\x10passports\
    _bought\x18\x05\x20\x01(\rR\x0fpassportsBought\x12\x18\n\x07version\x18\
    \x06\x20\x01(\rR\x07version\x12\x1b\n\tdef_index\x18\x07\x20\x01(\rR\x08\
    defIndex\x12!\n\x0creward_flags\x18\x08\x20\x01(\rR\x0brewardFlags\"\xc7\
    \x02\n\x16CMsgStickerbookSticker\x12\x1e\n\x0bitem_def_id\x18\x01\x20\
    \x01(\rR\titemDefId\x12\x1f\n\x0bsticker_num\x18\x02\x20\x01(\rR\nsticke\
    rNum\x12\x18\n\x07quality\x18\x03\x20\x01(\rR\x07quality\x12\x1d\n\nposi\
    tion_x\x18\x04\x20\x01(\x02R\tpositionX\x12\x1d\n\nposition_y\x18\x05\
    \x20\x01(\x02R\tpositionY\x12\x1d\n\nposition_z\x18\x08\x20\x01(\x02R\tp\
    ositionZ\x12\x1a\n\x08rotation\x18\x06\x20\x01(\x02R\x08rotation\x12\x14\
    \n\x05scale\x18\x07\x20\x01(\x02R\x05scale\x12$\n\x0esource_item_id\x18\
    \t\x20\x01(\x04R\x0csourceItemId\x12\x1d\n\ndepth_bias\x18\n\x20\x01(\rR\
    \tdepthBias\"\xe5\x01\n\x13CMsgStickerbookPage\x12\x19\n\x08page_num\x18\
    \x01\x20\x01(\rR\x07pageNum\x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\x0c\
    .dota.EEventR\x07eventId\x12\x17\n\x07team_id\x18\x03\x20\x01(\rR\x06tea\
    mId\x128\n\x08stickers\x18\x04\x20\x03(\x0b2\x1c.dota.CMsgStickerbookSti\
    ckerR\x08stickers\x127\n\tpage_type\x18\x05\x20\x01(\x0e2\x1a.dota.EStic\
    kerbookPageTypeR\x08pageType\"I\n$CMsgStickerbookTeamPageOrderSequence\
    \x12!\n\x0cpage_numbers\x18\x01\x20\x03(\rR\x0bpageNumbers\"\xd3\x01\n\
    \x0fCMsgStickerbook\x12/\n\x05pages\x18\x01\x20\x03(\x0b2\x19.dota.CMsgS\
    tickerbookPageR\x05pages\x12c\n\x18team_page_order_sequence\x18\x02\x20\
    \x01(\x0b2*.dota.CMsgStickerbookTeamPageOrderSequenceR\x15teamPageOrderS\
    equence\x12*\n\x11favorite_page_num\x18\x03\x20\x01(\rR\x0ffavoritePageN\
    um\"\x8a\x01\n\x0fCMsgStickerHero\x12\x17\n\x07hero_id\x18\x01\x20\x01(\
    \rR\x06heroId\x12\x1e\n\x0bitem_def_id\x18\x02\x20\x01(\rR\titemDefId\
    \x12\x18\n\x07quality\x18\x03\x20\x01(\rR\x07quality\x12$\n\x0esource_it\
    em_id\x18\x04\x20\x01(\x04R\x0csourceItemId\"B\n\x11CMsgStickerHeroes\
    \x12-\n\x06heroes\x18\x01\x20\x03(\x0b2\x15.dota.CMsgStickerHeroR\x06her\
    oes\"\x83\x01\n\x11CMsgHeroRoleStats\x120\n\x14lane_selection_flags\x18\
    \x01\x20\x01(\rR\x12laneSelectionFlags\x12\x1f\n\x0bmatch_count\x18\x02\
    \x20\x01(\rR\nmatchCount\x12\x1b\n\twin_count\x18\x03\x20\x01(\rR\x08win\
    Count\"h\n\x15CMsgHeroRoleHeroStats\x12\x17\n\x07hero_id\x18\x01\x20\x01\
    (\rR\x06heroId\x126\n\nrole_stats\x18\x02\x20\x03(\x0b2\x17.dota.CMsgHer\
    oRoleStatsR\troleStats\"p\n\x15CMsgHeroRoleRankStats\x12\x1b\n\trank_tie\
    r\x18\x01\x20\x01(\rR\x08rankTier\x12:\n\nhero_stats\x18\x02\x20\x03(\
    \x0b2\x1b.dota.CMsgHeroRoleHeroStatsR\theroStats\"\xa5\x01\n\x19CMsgHero\
    RoleAllRanksStats\x12'\n\x0fstart_timestamp\x18\x01\x20\x01(\rR\x0estart\
    Timestamp\x12#\n\rend_timestamp\x18\x02\x20\x01(\rR\x0cendTimestamp\x12:\
    \n\nrank_stats\x18\x03\x20\x03(\x0b2\x1b.dota.CMsgHeroRoleRankStatsR\tra\
    nkStats\"\xaf\x03\n\x14CMsgMapStatsSnapshot\x12\x1c\n\ttimestamp\x18\x01\
    \x20\x01(\rR\ttimestamp\x12'\n\x0ffamangos_gained\x18\x02\x20\x01(\x04R\
    \x0efamangosGained\x12.\n\x13wisdom_runes_gained\x18\x03\x20\x01(\x04R\
    \x11wisdomRunesGained\x12(\n\x10roshan_kills_day\x18\x04\x20\x01(\x04R\
    \x0eroshanKillsDay\x12,\n\x12roshan_kills_night\x18\x05\x20\x01(\x04R\
    \x10roshanKillsNight\x12!\n\x0cportals_used\x18\x06\x20\x01(\x04R\x0bpor\
    talsUsed\x12!\n\x0clanterns_lit\x18\x07\x20\x01(\x04R\x0blanternsLit\x12\
    %\n\x0eminiboss_kills\x18\x08\x20\x01(\x04R\rminibossKills\x12+\n\x11out\
    posts_captured\x18\t\x20\x01(\x04R\x10outpostsCaptured\x12.\n\x13shield_\
    runes_gained\x18\n\x20\x01(\x04R\x11shieldRunesGained\"\xc4\x01\n\x12CMs\
    gGlobalMapStats\x124\n\x07current\x18\x01\x20\x01(\x0b2\x1a.dota.CMsgMap\
    StatsSnapshotR\x07current\x12=\n\x0cwindow_start\x18\x02\x20\x01(\x0b2\
    \x1a.dota.CMsgMapStatsSnapshotR\x0bwindowStart\x129\n\nwindow_end\x18\
    \x03\x20\x01(\x0b2\x1a.dota.CMsgMapStatsSnapshotR\twindowEnd*U\n\x11ESpe\
    cialPingValue\x12\x1f\n\x1ak_ESpecialPingValue_NoData\x10\xfe\x7f\x12\
    \x1f\n\x1ak_ESpecialPingValue_Failed\x10\xff\x7f*\x86\x05\n\x12EDOTAGCSe\
    ssionNeed\x12\x20\n\x1ck_EDOTAGCSessionNeed_Unknown\x10\0\x12,\n(k_EDOTA\
    GCSessionNeed_UserNoSessionNeeded\x10d\x12)\n%k_EDOTAGCSessionNeed_UserI\
    nOnlineGame\x10e\x12(\n$k_EDOTAGCSessionNeed_UserInLocalGame\x10f\x12-\n\
    )k_EDOTAGCSessionNeed_UserInUIWasConnected\x10g\x12/\n+k_EDOTAGCSessionN\
    eed_UserInUINeverConnected\x10h\x12&\n\"k_EDOTAGCSessionNeed_UserTutoria\
    ls\x10i\x121\n-k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle\x10j\x123\n\
    /k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle\x10k\x12*\n%k_EDOTAGCSe\
    ssionNeed_GameServerOnline\x10\xc8\x01\x12)\n$k_EDOTAGCSessionNeed_GameS\
    erverLocal\x10\xc9\x01\x12(\n#k_EDOTAGCSessionNeed_GameServerIdle\x10\
    \xca\x01\x12)\n$k_EDOTAGCSessionNeed_GameServerRelay\x10\xcb\x01\x12/\n*\
    k_EDOTAGCSessionNeed_GameServerLocalUpload\x10\xcc\x01*\x86\x02\n\x1eEDO\
    TAMatchPlayerTimeCustomStat\x12:\n6k_EDOTA_MatchPlayerTimeCustomStat_HPR\
    egenUnderT1Towers\x10\x01\x12O\nKk_EDOTA_MatchPlayerTimeCustomStat_Magic\
    DamageReducedWithNewFormula_Absolute\x10\x02\x12W\nSk_EDOTA_MatchPlayerT\
    imeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP\x10\x03*\
    \xf6\x01\n\x15DOTA_TournamentEvents\x12\x12\n\x0eTE_FIRST_BLOOD\x10\0\
    \x12\x0f\n\x0bTE_GAME_END\x10\x01\x12\x11\n\rTE_MULTI_KILL\x10\x02\x12\
    \x10\n\x0cTE_HERO_DENY\x10\x03\x12\x11\n\rTE_AEGIS_DENY\x10\x04\x12\x13\
    \n\x0fTE_AEGIS_STOLEN\x10\x05\x12\x0e\n\nTE_GODLIKE\x10\x06\x12\x13\n\
    \x0fTE_COURIER_KILL\x10\x07\x12\x0f\n\x0bTE_ECHOSLAM\x10\x08\x12\r\n\tTE\
    _RAPIER\x10\t\x12\x13\n\x0fTE_EARLY_ROSHAN\x10\n\x12\x11\n\rTE_BLACK_HOL\
    E\x10\x0b*\x8d\x03\n\x17EBroadcastTimelineEvent\x12(\n$EBroadcastTimelin\
    eEvent_MatchStarted\x10\x01\x12,\n(EBroadcastTimelineEvent_GameStateChan\
    ged\x10\x02\x12&\n\"EBroadcastTimelineEvent_TowerDeath\x10\x03\x12)\n%EB\
    roadcastTimelineEvent_BarracksDeath\x10\x04\x12(\n$EBroadcastTimelineEve\
    nt_AncientDeath\x10\x05\x12'\n#EBroadcastTimelineEvent_RoshanDeath\x10\
    \x06\x12%\n!EBroadcastTimelineEvent_HeroDeath\x10\x07\x12%\n!EBroadcastT\
    imelineEvent_TeamFight\x10\x08\x12&\n\"EBroadcastTimelineEvent_FirstBloo\
    d\x10\t*\x98\x01\n\x19ECustomGameWhitelistState\x12'\n#CUSTOM_GAME_WHITE\
    LIST_STATE_UNKNOWN\x10\0\x12(\n$CUSTOM_GAME_WHITELIST_STATE_APPROVED\x10\
    \x01\x12(\n$CUSTOM_GAME_WHITELIST_STATE_REJECTED\x10\x02*\x9a\x07\n\x1bE\
    DOTATriviaQuestionCategory\x12-\n)k_EDOTATriviaQuestionCategory_AbilityI\
    con\x10\0\x121\n-k_EDOTATriviaQuestionCategory_AbilityCooldown\x10\x01\
    \x120\n,k_EDOTATriviaQuestionCategory_HeroAttributes\x10\x02\x123\n/k_ED\
    OTATriviaQuestionCategory_HeroMovementSpeed\x10\x03\x12,\n(k_EDOTATrivia\
    QuestionCategory_TalentTree\x10\x04\x12+\n'k_EDOTATriviaQuestionCategory\
    _HeroStats\x10\x05\x12+\n'k_EDOTATriviaQuestionCategory_ItemPrice\x10\
    \x06\x12.\n*k_EDOTATriviaQuestionCategory_AbilitySound\x10\x07\x12/\n+k_\
    EDOTATriviaQuestionCategory_InvokerSpells\x10\x08\x121\n-k_EDOTATriviaQu\
    estionCategory_AbilityManaCost\x10\t\x121\n-k_EDOTATriviaQuestionCategor\
    y_HeroAttackSound\x10\n\x12-\n)k_EDOTATriviaQuestionCategory_AbilityName\
    \x10\x0b\x120\n,k_EDOTATriviaQuestionCategory_ItemComponents\x10\x0c\x12\
    *\n&k_EDOTATriviaQuestionCategory_ItemLore\x10\r\x12.\n*k_EDOTATriviaQue\
    stionCategory_ItemPassives\x10\x0e\x126\n2k_EDOTATriviaQuestionCategory_\
    STATIC_QUESTIONS_END\x10\x0f\x129\n5k_EDOTATriviaQuestionCategory_DYNAMI\
    C_QUESTIONS_START\x10c\x123\n/k_EDOTATriviaQuestionCategory_Dynamic_Item\
    Build\x10d*\xa9\x01\n\x14EOverwatchConviction\x12\x1f\n\x1bk_EOverwatchC\
    onviction_None\x10\0\x12$\n\x20k_EOverwatchConviction_NotGuilty\x10\x01\
    \x12'\n#k_EOverwatchConviction_GuiltUnclear\x10\x02\x12!\n\x1dk_EOverwat\
    chConviction_Guilty\x10\x03*t\n\x10EHeroRelicRarity\x12&\n\x19HERO_RELIC\
    _RARITY_INVALID\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x1c\n\
    \x18HERO_RELIC_RARITY_COMMON\x10\0\x12\x1a\n\x16HERO_RELIC_RARITY_RARE\
    \x10\x01*\xd1\x01\n\x17EStickerbookAuditAction\x12!\n\x1dSTICKERBOOK_AUD\
    IT_CREATE_PAGE\x10\0\x12!\n\x1dSTICKERBOOK_AUDIT_DELETE_PAGE\x10\x01\x12\
    $\n\x20STICKERBOOK_AUDIT_STICK_STICKERS\x10\x02\x12&\n\"STICKERBOOK_AUDI\
    T_REPLACE_STICKERS\x10\x03\x12\"\n\x1eSTICKERBOOK_AUDIT_HERO_STICKER\x10\
    \x04*`\n\x14EStickerbookPageType\x12\x18\n\x14STICKER_PAGE_GENERIC\x10\0\
    \x12\x15\n\x11STICKER_PAGE_TEAM\x10\x01\x12\x17\n\x13STICKER_PAGE_TALENT\
    \x10\x02B%Z#github.com/dotabuff/manta/dota;dotaJ\xcf\xb0\x05\n\x07\x12\
    \x05\0\0\xf5\x0c\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\
    \x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\x0b\x12\
    \x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1c\n\t\n\x02\x03\x01\x12\
    \x03\x06\x07\x1f\n\t\n\x02\x03\x02\x12\x03\x07\x07\x20\n\n\n\x02\x05\0\
    \x12\x04\t\0\x0c\x01\n\n\n\x03\x05\0\x01\x12\x03\t\x05\x16\n\x0b\n\x04\
    \x05\0\x02\0\x12\x03\n\x08+\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\n\x08\"\
    \n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\n%*\n\x0b\n\x04\x05\0\x02\x01\x12\
    \x03\x0b\x08+\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x0b\x08\"\n\x0c\n\
    \x05\x05\0\x02\x01\x02\x12\x03\x0b%*\n\n\n\x02\x05\x01\x12\x04\x0e\0\x1d\
    \x01\n\n\n\x03\x05\x01\x01\x12\x03\x0e\x05\x17\n\x0b\n\x04\x05\x01\x02\0\
    \x12\x03\x0f\x08)\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x0f\x08$\n\x0c\n\
    \x05\x05\x01\x02\0\x02\x12\x03\x0f'(\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\
    \x10\x087\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\x10\x080\n\x0c\n\x05\
    \x05\x01\x02\x01\x02\x12\x03\x1036\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\
    \x11\x084\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x11\x08-\n\x0c\n\x05\
    \x05\x01\x02\x02\x02\x12\x03\x1103\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\
    \x12\x083\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x12\x08,\n\x0c\n\x05\
    \x05\x01\x02\x03\x02\x12\x03\x12/2\n\x0b\n\x04\x05\x01\x02\x04\x12\x03\
    \x13\x088\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x13\x081\n\x0c\n\x05\
    \x05\x01\x02\x04\x02\x12\x03\x1347\n\x0b\n\x04\x05\x01\x02\x05\x12\x03\
    \x14\x08:\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03\x14\x083\n\x0c\n\x05\
    \x05\x01\x02\x05\x02\x12\x03\x1469\n\x0b\n\x04\x05\x01\x02\x06\x12\x03\
    \x15\x081\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\x03\x15\x08*\n\x0c\n\x05\
    \x05\x01\x02\x06\x02\x12\x03\x15-0\n\x0b\n\x04\x05\x01\x02\x07\x12\x03\
    \x16\x08<\n\x0c\n\x05\x05\x01\x02\x07\x01\x12\x03\x16\x085\n\x0c\n\x05\
    \x05\x01\x02\x07\x02\x12\x03\x168;\n\x0b\n\x04\x05\x01\x02\x08\x12\x03\
    \x17\x08>\n\x0c\n\x05\x05\x01\x02\x08\x01\x12\x03\x17\x087\n\x0c\n\x05\
    \x05\x01\x02\x08\x02\x12\x03\x17:=\n\x0b\n\x04\x05\x01\x02\t\x12\x03\x18\
    \x084\n\x0c\n\x05\x05\x01\x02\t\x01\x12\x03\x18\x08-\n\x0c\n\x05\x05\x01\
    \x02\t\x02\x12\x03\x1803\n\x0b\n\x04\x05\x01\x02\n\x12\x03\x19\x083\n\
    \x0c\n\x05\x05\x01\x02\n\x01\x12\x03\x19\x08,\n\x0c\n\x05\x05\x01\x02\n\
    \x02\x12\x03\x19/2\n\x0b\n\x04\x05\x01\x02\x0b\x12\x03\x1a\x082\n\x0c\n\
    \x05\x05\x01\x02\x0b\x01\x12\x03\x1a\x08+\n\x0c\n\x05\x05\x01\x02\x0b\
    \x02\x12\x03\x1a.1\n\x0b\n\x04\x05\x01\x02\x0c\x12\x03\x1b\x083\n\x0c\n\
    \x05\x05\x01\x02\x0c\x01\x12\x03\x1b\x08,\n\x0c\n\x05\x05\x01\x02\x0c\
    \x02\x12\x03\x1b/2\n\x0b\n\x04\x05\x01\x02\r\x12\x03\x1c\x089\n\x0c\n\
    \x05\x05\x01\x02\r\x01\x12\x03\x1c\x082\n\x0c\n\x05\x05\x01\x02\r\x02\
    \x12\x03\x1c58\n\n\n\x02\x05\x02\x12\x04\x1f\0#\x01\n\n\n\x03\x05\x02\
    \x01\x12\x03\x1f\x05#\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x20\x08C\n\x0c\n\
    \x05\x05\x02\x02\0\x01\x12\x03\x20\x08>\n\x0c\n\x05\x05\x02\x02\0\x02\
    \x12\x03\x20AB\n\x0b\n\x04\x05\x02\x02\x01\x12\x03!\x08X\n\x0c\n\x05\x05\
    \x02\x02\x01\x01\x12\x03!\x08S\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03!V\
    W\n\x0b\n\x04\x05\x02\x02\x02\x12\x03\"\x08`\n\x0c\n\x05\x05\x02\x02\x02\
    \x01\x12\x03\"\x08[\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03\"^_\n\n\n\
    \x02\x05\x03\x12\x04%\02\x01\n\n\n\x03\x05\x03\x01\x12\x03%\x05\x1a\n\
    \x0b\n\x04\x05\x03\x02\0\x12\x03&\x08\x1b\n\x0c\n\x05\x05\x03\x02\0\x01\
    \x12\x03&\x08\x16\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03&\x19\x1a\n\x0b\n\
    \x04\x05\x03\x02\x01\x12\x03'\x08\x18\n\x0c\n\x05\x05\x03\x02\x01\x01\
    \x12\x03'\x08\x13\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03'\x16\x17\n\x0b\
    \n\x04\x05\x03\x02\x02\x12\x03(\x08\x1a\n\x0c\n\x05\x05\x03\x02\x02\x01\
    \x12\x03(\x08\x15\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\x03(\x18\x19\n\x0b\
    \n\x04\x05\x03\x02\x03\x12\x03)\x08\x19\n\x0c\n\x05\x05\x03\x02\x03\x01\
    \x12\x03)\x08\x14\n\x0c\n\x05\x05\x03\x02\x03\x02\x12\x03)\x17\x18\n\x0b\
    \n\x04\x05\x03\x02\x04\x12\x03*\x08\x1a\n\x0c\n\x05\x05\x03\x02\x04\x01\
    \x12\x03*\x08\x15\n\x0c\n\x05\x05\x03\x02\x04\x02\x12\x03*\x18\x19\n\x0b\
    \n\x04\x05\x03\x02\x05\x12\x03+\x08\x1c\n\x0c\n\x05\x05\x03\x02\x05\x01\
    \x12\x03+\x08\x17\n\x0c\n\x05\x05\x03\x02\x05\x02\x12\x03+\x1a\x1b\n\x0b\
    \n\x04\x05\x03\x02\x06\x12\x03,\x08\x17\n\x0c\n\x05\x05\x03\x02\x06\x01\
    \x12\x03,\x08\x12\n\x0c\n\x05\x05\x03\x02\x06\x02\x12\x03,\x15\x16\n\x0b\
    \n\x04\x05\x03\x02\x07\x12\x03-\x08\x1c\n\x0c\n\x05\x05\x03\x02\x07\x01\
    \x12\x03-\x08\x17\n\x0c\n\x05\x05\x03\x02\x07\x02\x12\x03-\x1a\x1b\n\x0b\
    \n\x04\x05\x03\x02\x08\x12\x03.\x08\x18\n\x0c\n\x05\x05\x03\x02\x08\x01\
    \x12\x03.\x08\x13\n\x0c\n\x05\x05\x03\x02\x08\x02\x12\x03.\x16\x17\n\x0b\
    \n\x04\x05\x03\x02\t\x12\x03/\x08\x16\n\x0c\n\x05\x05\x03\x02\t\x01\x12\
    \x03/\x08\x11\n\x0c\n\x05\x05\x03\x02\t\x02\x12\x03/\x14\x15\n\x0b\n\x04\
    \x05\x03\x02\n\x12\x030\x08\x1d\n\x0c\n\x05\x05\x03\x02\n\x01\x12\x030\
    \x08\x17\n\x0c\n\x05\x05\x03\x02\n\x02\x12\x030\x1a\x1c\n\x0b\n\x04\x05\
    \x03\x02\x0b\x12\x031\x08\x1b\n\x0c\n\x05\x05\x03\x02\x0b\x01\x12\x031\
    \x08\x15\n\x0c\n\x05\x05\x03\x02\x0b\x02\x12\x031\x18\x1a\n\n\n\x02\x05\
    \x04\x12\x044\0>\x01\n\n\n\x03\x05\x04\x01\x12\x034\x05\x1c\n\x0b\n\x04\
    \x05\x04\x02\0\x12\x035\x081\n\x0c\n\x05\x05\x04\x02\0\x01\x12\x035\x08,\
    \n\x0c\n\x05\x05\x04\x02\0\x02\x12\x035/0\n\x0b\n\x04\x05\x04\x02\x01\
    \x12\x036\x085\n\x0c\n\x05\x05\x04\x02\x01\x01\x12\x036\x080\n\x0c\n\x05\
    \x05\x04\x02\x01\x02\x12\x03634\n\x0b\n\x04\x05\x04\x02\x02\x12\x037\x08\
    /\n\x0c\n\x05\x05\x04\x02\x02\x01\x12\x037\x08*\n\x0c\n\x05\x05\x04\x02\
    \x02\x02\x12\x037-.\n\x0b\n\x04\x05\x04\x02\x03\x12\x038\x082\n\x0c\n\
    \x05\x05\x04\x02\x03\x01\x12\x038\x08-\n\x0c\n\x05\x05\x04\x02\x03\x02\
    \x12\x03801\n\x0b\n\x04\x05\x04\x02\x04\x12\x039\x081\n\x0c\n\x05\x05\
    \x04\x02\x04\x01\x12\x039\x08,\n\x0c\n\x05\x05\x04\x02\x04\x02\x12\x039/\
    0\n\x0b\n\x04\x05\x04\x02\x05\x12\x03:\x080\n\x0c\n\x05\x05\x04\x02\x05\
    \x01\x12\x03:\x08+\n\x0c\n\x05\x05\x04\x02\x05\x02\x12\x03:./\n\x0b\n\
    \x04\x05\x04\x02\x06\x12\x03;\x08.\n\x0c\n\x05\x05\x04\x02\x06\x01\x12\
    \x03;\x08)\n\x0c\n\x05\x05\x04\x02\x06\x02\x12\x03;,-\n\x0b\n\x04\x05\
    \x04\x02\x07\x12\x03<\x08.\n\x0c\n\x05\x05\x04\x02\x07\x01\x12\x03<\x08)\
    \n\x0c\n\x05\x05\x04\x02\x07\x02\x12\x03<,-\n\x0b\n\x04\x05\x04\x02\x08\
    \x12\x03=\x08/\n\x0c\n\x05\x05\x04\x02\x08\x01\x12\x03=\x08*\n\x0c\n\x05\
    \x05\x04\x02\x08\x02\x12\x03=-.\n\n\n\x02\x05\x05\x12\x04@\0D\x01\n\n\n\
    \x03\x05\x05\x01\x12\x03@\x05\x1e\n\x0b\n\x04\x05\x05\x02\0\x12\x03A\x08\
    0\n\x0c\n\x05\x05\x05\x02\0\x01\x12\x03A\x08+\n\x0c\n\x05\x05\x05\x02\0\
    \x02\x12\x03A./\n\x0b\n\x04\x05\x05\x02\x01\x12\x03B\x081\n\x0c\n\x05\
    \x05\x05\x02\x01\x01\x12\x03B\x08,\n\x0c\n\x05\x05\x05\x02\x01\x02\x12\
    \x03B/0\n\x0b\n\x04\x05\x05\x02\x02\x12\x03C\x081\n\x0c\n\x05\x05\x05\
    \x02\x02\x01\x12\x03C\x08,\n\x0c\n\x05\x05\x05\x02\x02\x02\x12\x03C/0\n\
    \n\n\x02\x05\x06\x12\x04F\0Y\x01\n\n\n\x03\x05\x06\x01\x12\x03F\x05\x20\
    \n\x0b\n\x04\x05\x06\x02\0\x12\x03G\x086\n\x0c\n\x05\x05\x06\x02\0\x01\
    \x12\x03G\x081\n\x0c\n\x05\x05\x06\x02\0\x02\x12\x03G45\n\x0b\n\x04\x05\
    \x06\x02\x01\x12\x03H\x08:\n\x0c\n\x05\x05\x06\x02\x01\x01\x12\x03H\x085\
    \n\x0c\n\x05\x05\x06\x02\x01\x02\x12\x03H89\n\x0b\n\x04\x05\x06\x02\x02\
    \x12\x03I\x089\n\x0c\n\x05\x05\x06\x02\x02\x01\x12\x03I\x084\n\x0c\n\x05\
    \x05\x06\x02\x02\x02\x12\x03I78\n\x0b\n\x04\x05\x06\x02\x03\x12\x03J\x08\
    <\n\x0c\n\x05\x05\x06\x02\x03\x01\x12\x03J\x087\n\x0c\n\x05\x05\x06\x02\
    \x03\x02\x12\x03J:;\n\x0b\n\x04\x05\x06\x02\x04\x12\x03K\x085\n\x0c\n\
    \x05\x05\x06\x02\x04\x01\x12\x03K\x080\n\x0c\n\x05\x05\x06\x02\x04\x02\
    \x12\x03K34\n\x0b\n\x04\x05\x06\x02\x05\x12\x03L\x084\n\x0c\n\x05\x05\
    \x06\x02\x05\x01\x12\x03L\x08/\n\x0c\n\x05\x05\x06\x02\x05\x02\x12\x03L2\
    3\n\x0b\n\x04\x05\x06\x02\x06\x12\x03M\x084\n\x0c\n\x05\x05\x06\x02\x06\
    \x01\x12\x03M\x08/\n\x0c\n\x05\x05\x06\x02\x06\x02\x12\x03M23\n\x0b\n\
    \x04\x05\x06\x02\x07\x12\x03N\x087\n\x0c\n\x05\x05\x06\x02\x07\x01\x12\
    \x03N\x082\n\x0c\n\x05\x05\x06\x02\x07\x02\x12\x03N56\n\x0b\n\x04\x05\
    \x06\x02\x08\x12\x03O\x088\n\x0c\n\x05\x05\x06\x02\x08\x01\x12\x03O\x083\
    \n\x0c\n\x05\x05\x06\x02\x08\x02\x12\x03O67\n\x0b\n\x04\x05\x06\x02\t\
    \x12\x03P\x08:\n\x0c\n\x05\x05\x06\x02\t\x01\x12\x03P\x085\n\x0c\n\x05\
    \x05\x06\x02\t\x02\x12\x03P89\n\x0b\n\x04\x05\x06\x02\n\x12\x03Q\x08;\n\
    \x0c\n\x05\x05\x06\x02\n\x01\x12\x03Q\x085\n\x0c\n\x05\x05\x06\x02\n\x02\
    \x12\x03Q8:\n\x0b\n\x04\x05\x06\x02\x0b\x12\x03R\x087\n\x0c\n\x05\x05\
    \x06\x02\x0b\x01\x12\x03R\x081\n\x0c\n\x05\x05\x06\x02\x0b\x02\x12\x03R4\
    6\n\x0b\n\x04\x05\x06\x02\x0c\x12\x03S\x08:\n\x0c\n\x05\x05\x06\x02\x0c\
    \x01\x12\x03S\x084\n\x0c\n\x05\x05\x06\x02\x0c\x02\x12\x03S79\n\x0b\n\
    \x04\x05\x06\x02\r\x12\x03T\x084\n\x0c\n\x05\x05\x06\x02\r\x01\x12\x03T\
    \x08.\n\x0c\n\x05\x05\x06\x02\r\x02\x12\x03T13\n\x0b\n\x04\x05\x06\x02\
    \x0e\x12\x03U\x088\n\x0c\n\x05\x05\x06\x02\x0e\x01\x12\x03U\x082\n\x0c\n\
    \x05\x05\x06\x02\x0e\x02\x12\x03U57\n\x0b\n\x04\x05\x06\x02\x0f\x12\x03V\
    \x08@\n\x0c\n\x05\x05\x06\x02\x0f\x01\x12\x03V\x08:\n\x0c\n\x05\x05\x06\
    \x02\x0f\x02\x12\x03V=?\n\x0b\n\x04\x05\x06\x02\x10\x12\x03W\x08C\n\x0c\
    \n\x05\x05\x06\x02\x10\x01\x12\x03W\x08=\n\x0c\n\x05\x05\x06\x02\x10\x02\
    \x12\x03W@B\n\x0b\n\x04\x05\x06\x02\x11\x12\x03X\x08>\n\x0c\n\x05\x05\
    \x06\x02\x11\x01\x12\x03X\x087\n\x0c\n\x05\x05\x06\x02\x11\x02\x12\x03X:\
    =\n\n\n\x02\x05\x07\x12\x04[\0`\x01\n\n\n\x03\x05\x07\x01\x12\x03[\x05\
    \x19\n\x0b\n\x04\x05\x07\x02\0\x12\x03\\\x08(\n\x0c\n\x05\x05\x07\x02\0\
    \x01\x12\x03\\\x08#\n\x0c\n\x05\x05\x07\x02\0\x02\x12\x03\\&'\n\x0b\n\
    \x04\x05\x07\x02\x01\x12\x03]\x08-\n\x0c\n\x05\x05\x07\x02\x01\x01\x12\
    \x03]\x08(\n\x0c\n\x05\x05\x07\x02\x01\x02\x12\x03]+,\n\x0b\n\x04\x05\
    \x07\x02\x02\x12\x03^\x080\n\x0c\n\x05\x05\x07\x02\x02\x01\x12\x03^\x08+\
    \n\x0c\n\x05\x05\x07\x02\x02\x02\x12\x03^./\n\x0b\n\x04\x05\x07\x02\x03\
    \x12\x03_\x08*\n\x0c\n\x05\x05\x07\x02\x03\x01\x12\x03_\x08%\n\x0c\n\x05\
    \x05\x07\x02\x03\x02\x12\x03_()\n\n\n\x02\x05\x08\x12\x04b\0f\x01\n\n\n\
    \x03\x05\x08\x01\x12\x03b\x05\x15\n\x0b\n\x04\x05\x08\x02\0\x12\x03c\x08\
    '\n\x0c\n\x05\x05\x08\x02\0\x01\x12\x03c\x08!\n\x0c\n\x05\x05\x08\x02\0\
    \x02\x12\x03c$&\n\x0b\n\x04\x05\x08\x02\x01\x12\x03d\x08%\n\x0c\n\x05\
    \x05\x08\x02\x01\x01\x12\x03d\x08\x20\n\x0c\n\x05\x05\x08\x02\x01\x02\
    \x12\x03d#$\n\x0b\n\x04\x05\x08\x02\x02\x12\x03e\x08#\n\x0c\n\x05\x05\
    \x08\x02\x02\x01\x12\x03e\x08\x1e\n\x0c\n\x05\x05\x08\x02\x02\x02\x12\
    \x03e!\"\n\n\n\x02\x05\t\x12\x04h\0n\x01\n\n\n\x03\x05\t\x01\x12\x03h\
    \x05\x1c\n\x0b\n\x04\x05\t\x02\0\x12\x03i\x08*\n\x0c\n\x05\x05\t\x02\0\
    \x01\x12\x03i\x08%\n\x0c\n\x05\x05\t\x02\0\x02\x12\x03i()\n\x0b\n\x04\
    \x05\t\x02\x01\x12\x03j\x08*\n\x0c\n\x05\x05\t\x02\x01\x01\x12\x03j\x08%\
    \n\x0c\n\x05\x05\t\x02\x01\x02\x12\x03j()\n\x0b\n\x04\x05\t\x02\x02\x12\
    \x03k\x08-\n\x0c\n\x05\x05\t\x02\x02\x01\x12\x03k\x08(\n\x0c\n\x05\x05\t\
    \x02\x02\x02\x12\x03k+,\n\x0b\n\x04\x05\t\x02\x03\x12\x03l\x08/\n\x0c\n\
    \x05\x05\t\x02\x03\x01\x12\x03l\x08*\n\x0c\n\x05\x05\t\x02\x03\x02\x12\
    \x03l-.\n\x0b\n\x04\x05\t\x02\x04\x12\x03m\x08+\n\x0c\n\x05\x05\t\x02\
    \x04\x01\x12\x03m\x08&\n\x0c\n\x05\x05\t\x02\x04\x02\x12\x03m)*\n\n\n\
    \x02\x05\n\x12\x04p\0t\x01\n\n\n\x03\x05\n\x01\x12\x03p\x05\x19\n\x0b\n\
    \x04\x05\n\x02\0\x12\x03q\x08!\n\x0c\n\x05\x05\n\x02\0\x01\x12\x03q\x08\
    \x1c\n\x0c\n\x05\x05\n\x02\0\x02\x12\x03q\x1f\x20\n\x0b\n\x04\x05\n\x02\
    \x01\x12\x03r\x08\x1e\n\x0c\n\x05\x05\n\x02\x01\x01\x12\x03r\x08\x19\n\
    \x0c\n\x05\x05\n\x02\x01\x02\x12\x03r\x1c\x1d\n\x0b\n\x04\x05\n\x02\x02\
    \x12\x03s\x08\x20\n\x0c\n\x05\x05\n\x02\x02\x01\x12\x03s\x08\x1b\n\x0c\n\
    \x05\x05\n\x02\x02\x02\x12\x03s\x1e\x1f\n\x0b\n\x02\x04\0\x12\x05v\0\xb3\
    \x01\x01\n\n\n\x03\x04\0\x01\x12\x03v\x08\x20\n\x0c\n\x04\x04\0\x03\0\
    \x12\x04w\x08z\t\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03w\x10\x1c\n\r\n\x06\
    \x04\0\x03\0\x02\0\x12\x03x\x10)\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\x12\
    \x03x\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03x\x19\x1f\n\x0e\n\
    \x07\x04\0\x03\0\x02\0\x01\x12\x03x\x20$\n\x0e\n\x07\x04\0\x03\0\x02\0\
    \x03\x12\x03x'(\n\r\n\x06\x04\0\x03\0\x02\x01\x12\x03y\x10,\n\x0e\n\x07\
    \x04\0\x03\0\x02\x01\x04\x12\x03y\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\
    \x01\x05\x12\x03y\x19\x1e\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03y\
    \x1f'\n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\x03y*+\n\x0b\n\x04\x04\0\
    \x02\0\x12\x03|\x08'\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03|\x08\x10\n\x0c\
    \n\x05\x04\0\x02\0\x05\x12\x03|\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03|\x18\"\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03|%&\n\x0b\n\x04\x04\0\x02\
    \x01\x12\x03}\x08!\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03}\x08\x10\n\x0c\
    \n\x05\x04\0\x02\x01\x05\x12\x03}\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03}\x18\x1c\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03}\x1f\x20\n\x0b\n\
    \x04\x04\0\x02\x02\x12\x03~\x08#\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03~\
    \x08\x10\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03~\x11\x17\n\x0c\n\x05\x04\
    \0\x02\x02\x01\x12\x03~\x18\x1e\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03~!\
    \"\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x7f\x08\x20\n\x0c\n\x05\x04\0\x02\
    \x03\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x7f\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x7f\x18\x1a\n\x0c\n\x05\
    \x04\0\x02\x03\x03\x12\x03\x7f\x1d\x1f\n\x0c\n\x04\x04\0\x02\x04\x12\x04\
    \x80\x01\x08#\n\r\n\x05\x04\0\x02\x04\x04\x12\x04\x80\x01\x08\x10\n\r\n\
    \x05\x04\0\x02\x04\x05\x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\0\x02\x04\
    \x01\x12\x04\x80\x01\x18\x1d\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\x80\x01\
    \x20\"\n\x0c\n\x04\x04\0\x02\x05\x12\x04\x81\x01\x08+\n\r\n\x05\x04\0\
    \x02\x05\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\0\x02\x05\x05\x12\x04\
    \x81\x01\x11\x17\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\x81\x01\x18%\n\r\n\
    \x05\x04\0\x02\x05\x03\x12\x04\x81\x01(*\n\x0c\n\x04\x04\0\x02\x06\x12\
    \x04\x82\x01\x08*\n\r\n\x05\x04\0\x02\x06\x04\x12\x04\x82\x01\x08\x10\n\
    \r\n\x05\x04\0\x02\x06\x05\x12\x04\x82\x01\x11\x17\n\r\n\x05\x04\0\x02\
    \x06\x01\x12\x04\x82\x01\x18$\n\r\n\x05\x04\0\x02\x06\x03\x12\x04\x82\
    \x01')\n\x0c\n\x04\x04\0\x02\x07\x12\x04\x83\x01\x084\n\r\n\x05\x04\0\
    \x02\x07\x04\x12\x04\x83\x01\x08\x10\n\r\n\x05\x04\0\x02\x07\x05\x12\x04\
    \x83\x01\x11\x17\n\r\n\x05\x04\0\x02\x07\x01\x12\x04\x83\x01\x18.\n\r\n\
    \x05\x04\0\x02\x07\x03\x12\x04\x83\x0113\n\x0c\n\x04\x04\0\x02\x08\x12\
    \x04\x84\x01\x085\n\r\n\x05\x04\0\x02\x08\x04\x12\x04\x84\x01\x08\x10\n\
    \r\n\x05\x04\0\x02\x08\x05\x12\x04\x84\x01\x11\x17\n\r\n\x05\x04\0\x02\
    \x08\x01\x12\x04\x84\x01\x18/\n\r\n\x05\x04\0\x02\x08\x03\x12\x04\x84\
    \x0124\n\x0c\n\x04\x04\0\x02\t\x12\x04\x85\x01\x08:\n\r\n\x05\x04\0\x02\
    \t\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\0\x02\t\x05\x12\x04\x85\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\t\x01\x12\x04\x85\x01\x184\n\r\n\x05\x04\0\
    \x02\t\x03\x12\x04\x85\x0179\n\x0c\n\x04\x04\0\x02\n\x12\x04\x86\x01\x08\
    6\n\r\n\x05\x04\0\x02\n\x04\x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\0\x02\
    \n\x05\x12\x04\x86\x01\x11\x17\n\r\n\x05\x04\0\x02\n\x01\x12\x04\x86\x01\
    \x180\n\r\n\x05\x04\0\x02\n\x03\x12\x04\x86\x0135\n\x0c\n\x04\x04\0\x02\
    \x0b\x12\x04\x87\x01\x08A\n\r\n\x05\x04\0\x02\x0b\x04\x12\x04\x87\x01\
    \x08\x10\n\r\n\x05\x04\0\x02\x0b\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\
    \x04\0\x02\x0b\x01\x12\x04\x87\x01\x18;\n\r\n\x05\x04\0\x02\x0b\x03\x12\
    \x04\x87\x01>@\n\x0c\n\x04\x04\0\x02\x0c\x12\x04\x88\x01\x08A\n\r\n\x05\
    \x04\0\x02\x0c\x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\0\x02\x0c\x05\
    \x12\x04\x88\x01\x11\x17\n\r\n\x05\x04\0\x02\x0c\x01\x12\x04\x88\x01\x18\
    :\n\r\n\x05\x04\0\x02\x0c\x03\x12\x04\x88\x01=@\n\x0c\n\x04\x04\0\x02\r\
    \x12\x04\x89\x01\x086\n\r\n\x05\x04\0\x02\r\x04\x12\x04\x89\x01\x08\x10\
    \n\r\n\x05\x04\0\x02\r\x05\x12\x04\x89\x01\x11\x17\n\r\n\x05\x04\0\x02\r\
    \x01\x12\x04\x89\x01\x180\n\r\n\x05\x04\0\x02\r\x03\x12\x04\x89\x0135\n\
    \x0c\n\x04\x04\0\x02\x0e\x12\x04\x8a\x01\x08@\n\r\n\x05\x04\0\x02\x0e\
    \x04\x12\x04\x8a\x01\x08\x10\n\r\n\x05\x04\0\x02\x0e\x05\x12\x04\x8a\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\x0e\x01\x12\x04\x8a\x01\x18:\n\r\n\x05\x04\
    \0\x02\x0e\x03\x12\x04\x8a\x01=?\n\x0c\n\x04\x04\0\x02\x0f\x12\x04\x8b\
    \x01\x082\n\r\n\x05\x04\0\x02\x0f\x04\x12\x04\x8b\x01\x08\x10\n\r\n\x05\
    \x04\0\x02\x0f\x05\x12\x04\x8b\x01\x11\x17\n\r\n\x05\x04\0\x02\x0f\x01\
    \x12\x04\x8b\x01\x18,\n\r\n\x05\x04\0\x02\x0f\x03\x12\x04\x8b\x01/1\n\
    \x0c\n\x04\x04\0\x02\x10\x12\x04\x8c\x01\x083\n\r\n\x05\x04\0\x02\x10\
    \x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\0\x02\x10\x05\x12\x04\x8c\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\x10\x01\x12\x04\x8c\x01\x18-\n\r\n\x05\x04\
    \0\x02\x10\x03\x12\x04\x8c\x0102\n\x0c\n\x04\x04\0\x02\x11\x12\x04\x8d\
    \x01\x089\n\r\n\x05\x04\0\x02\x11\x04\x12\x04\x8d\x01\x08\x10\n\r\n\x05\
    \x04\0\x02\x11\x05\x12\x04\x8d\x01\x11\x17\n\r\n\x05\x04\0\x02\x11\x01\
    \x12\x04\x8d\x01\x183\n\r\n\x05\x04\0\x02\x11\x03\x12\x04\x8d\x0168\n\
    \x0c\n\x04\x04\0\x02\x12\x12\x04\x8e\x01\x084\n\r\n\x05\x04\0\x02\x12\
    \x04\x12\x04\x8e\x01\x08\x10\n\r\n\x05\x04\0\x02\x12\x05\x12\x04\x8e\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\x12\x01\x12\x04\x8e\x01\x18.\n\r\n\x05\x04\
    \0\x02\x12\x03\x12\x04\x8e\x0113\n\x0c\n\x04\x04\0\x02\x13\x12\x04\x8f\
    \x01\x087\n\r\n\x05\x04\0\x02\x13\x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\
    \x04\0\x02\x13\x05\x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\0\x02\x13\x01\
    \x12\x04\x8f\x01\x181\n\r\n\x05\x04\0\x02\x13\x03\x12\x04\x8f\x0146\n\
    \x0c\n\x04\x04\0\x02\x14\x12\x04\x90\x01\x082\n\r\n\x05\x04\0\x02\x14\
    \x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\0\x02\x14\x05\x12\x04\x90\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\x14\x01\x12\x04\x90\x01\x18,\n\r\n\x05\x04\
    \0\x02\x14\x03\x12\x04\x90\x01/1\n\x0c\n\x04\x04\0\x02\x15\x12\x04\x91\
    \x01\x08;\n\r\n\x05\x04\0\x02\x15\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\
    \x04\0\x02\x15\x05\x12\x04\x91\x01\x11\x17\n\r\n\x05\x04\0\x02\x15\x01\
    \x12\x04\x91\x01\x185\n\r\n\x05\x04\0\x02\x15\x03\x12\x04\x91\x018:\n\
    \x0c\n\x04\x04\0\x02\x16\x12\x04\x92\x01\x08:\n\r\n\x05\x04\0\x02\x16\
    \x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\0\x02\x16\x05\x12\x04\x92\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\x16\x01\x12\x04\x92\x01\x184\n\r\n\x05\x04\
    \0\x02\x16\x03\x12\x04\x92\x0179\n\x0c\n\x04\x04\0\x02\x17\x12\x04\x93\
    \x01\x08/\n\r\n\x05\x04\0\x02\x17\x04\x12\x04\x93\x01\x08\x10\n\r\n\x05\
    \x04\0\x02\x17\x05\x12\x04\x93\x01\x11\x17\n\r\n\x05\x04\0\x02\x17\x01\
    \x12\x04\x93\x01\x18)\n\r\n\x05\x04\0\x02\x17\x03\x12\x04\x93\x01,.\n\
    \x0c\n\x04\x04\0\x02\x18\x12\x04\x94\x01\x081\n\r\n\x05\x04\0\x02\x18\
    \x04\x12\x04\x94\x01\x08\x10\n\r\n\x05\x04\0\x02\x18\x05\x12\x04\x94\x01\
    \x11\x15\n\r\n\x05\x04\0\x02\x18\x01\x12\x04\x94\x01\x16+\n\r\n\x05\x04\
    \0\x02\x18\x03\x12\x04\x94\x01.0\n\x0c\n\x04\x04\0\x02\x19\x12\x04\x95\
    \x01\x08+\n\r\n\x05\x04\0\x02\x19\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\
    \x04\0\x02\x19\x05\x12\x04\x95\x01\x11\x15\n\r\n\x05\x04\0\x02\x19\x01\
    \x12\x04\x95\x01\x16%\n\r\n\x05\x04\0\x02\x19\x03\x12\x04\x95\x01(*\n\
    \x0c\n\x04\x04\0\x02\x1a\x12\x04\x96\x01\x081\n\r\n\x05\x04\0\x02\x1a\
    \x04\x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\0\x02\x1a\x05\x12\x04\x96\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\x1a\x01\x12\x04\x96\x01\x18+\n\r\n\x05\x04\
    \0\x02\x1a\x03\x12\x04\x96\x01.0\n\x0c\n\x04\x04\0\x02\x1b\x12\x04\x97\
    \x01\x08;\n\r\n\x05\x04\0\x02\x1b\x04\x12\x04\x97\x01\x08\x10\n\r\n\x05\
    \x04\0\x02\x1b\x05\x12\x04\x97\x01\x11\x17\n\r\n\x05\x04\0\x02\x1b\x01\
    \x12\x04\x97\x01\x185\n\r\n\x05\x04\0\x02\x1b\x03\x12\x04\x97\x018:\n\
    \x0c\n\x04\x04\0\x02\x1c\x12\x04\x98\x01\x08<\n\r\n\x05\x04\0\x02\x1c\
    \x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\0\x02\x1c\x05\x12\x04\x98\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\x1c\x01\x12\x04\x98\x01\x186\n\r\n\x05\x04\
    \0\x02\x1c\x03\x12\x04\x98\x019;\n\x0c\n\x04\x04\0\x02\x1d\x12\x04\x99\
    \x01\x085\n\r\n\x05\x04\0\x02\x1d\x04\x12\x04\x99\x01\x08\x10\n\r\n\x05\
    \x04\0\x02\x1d\x05\x12\x04\x99\x01\x11\x17\n\r\n\x05\x04\0\x02\x1d\x01\
    \x12\x04\x99\x01\x18/\n\r\n\x05\x04\0\x02\x1d\x03\x12\x04\x99\x0124\n\
    \x0c\n\x04\x04\0\x02\x1e\x12\x04\x9a\x01\x088\n\r\n\x05\x04\0\x02\x1e\
    \x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\0\x02\x1e\x05\x12\x04\x9a\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\x1e\x01\x12\x04\x9a\x01\x182\n\r\n\x05\x04\
    \0\x02\x1e\x03\x12\x04\x9a\x0157\n\x0c\n\x04\x04\0\x02\x1f\x12\x04\x9b\
    \x01\x08.\n\r\n\x05\x04\0\x02\x1f\x04\x12\x04\x9b\x01\x08\x10\n\r\n\x05\
    \x04\0\x02\x1f\x05\x12\x04\x9b\x01\x11\x17\n\r\n\x05\x04\0\x02\x1f\x01\
    \x12\x04\x9b\x01\x18(\n\r\n\x05\x04\0\x02\x1f\x03\x12\x04\x9b\x01+-\n\
    \x0c\n\x04\x04\0\x02\x20\x12\x04\x9c\x01\x08+\n\r\n\x05\x04\0\x02\x20\
    \x04\x12\x04\x9c\x01\x08\x10\n\r\n\x05\x04\0\x02\x20\x05\x12\x04\x9c\x01\
    \x11\x17\n\r\n\x05\x04\0\x02\x20\x01\x12\x04\x9c\x01\x18%\n\r\n\x05\x04\
    \0\x02\x20\x03\x12\x04\x9c\x01(*\n\x0c\n\x04\x04\0\x02!\x12\x04\x9d\x01\
    \x08-\n\r\n\x05\x04\0\x02!\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\0\
    \x02!\x05\x12\x04\x9d\x01\x11\x17\n\r\n\x05\x04\0\x02!\x01\x12\x04\x9d\
    \x01\x18'\n\r\n\x05\x04\0\x02!\x03\x12\x04\x9d\x01*,\n\x0c\n\x04\x04\0\
    \x02\"\x12\x04\x9e\x01\x08A\n\r\n\x05\x04\0\x02\"\x04\x12\x04\x9e\x01\
    \x08\x10\n\r\n\x05\x04\0\x02\"\x05\x12\x04\x9e\x01\x11\x17\n\r\n\x05\x04\
    \0\x02\"\x01\x12\x04\x9e\x01\x18;\n\r\n\x05\x04\0\x02\"\x03\x12\x04\x9e\
    \x01>@\n\x0c\n\x04\x04\0\x02#\x12\x04\x9f\x01\x08?\n\r\n\x05\x04\0\x02#\
    \x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\x04\0\x02#\x05\x12\x04\x9f\x01\
    \x11\x17\n\r\n\x05\x04\0\x02#\x01\x12\x04\x9f\x01\x189\n\r\n\x05\x04\0\
    \x02#\x03\x12\x04\x9f\x01<>\n\x0c\n\x04\x04\0\x02$\x12\x04\xa0\x01\x08;\
    \n\r\n\x05\x04\0\x02$\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\0\x02$\
    \x05\x12\x04\xa0\x01\x11\x15\n\r\n\x05\x04\0\x02$\x01\x12\x04\xa0\x01\
    \x165\n\r\n\x05\x04\0\x02$\x03\x12\x04\xa0\x018:\n\x0c\n\x04\x04\0\x02%\
    \x12\x04\xa1\x01\x081\n\r\n\x05\x04\0\x02%\x04\x12\x04\xa1\x01\x08\x10\n\
    \r\n\x05\x04\0\x02%\x05\x12\x04\xa1\x01\x11\x17\n\r\n\x05\x04\0\x02%\x01\
    \x12\x04\xa1\x01\x18+\n\r\n\x05\x04\0\x02%\x03\x12\x04\xa1\x01.0\n\x0c\n\
    \x04\x04\0\x02&\x12\x04\xa2\x01\x08?\n\r\n\x05\x04\0\x02&\x04\x12\x04\
    \xa2\x01\x08\x10\n\r\n\x05\x04\0\x02&\x05\x12\x04\xa2\x01\x11\x17\n\r\n\
    \x05\x04\0\x02&\x01\x12\x04\xa2\x01\x189\n\r\n\x05\x04\0\x02&\x03\x12\
    \x04\xa2\x01<>\n\x0c\n\x04\x04\0\x02'\x12\x04\xa3\x01\x086\n\r\n\x05\x04\
    \0\x02'\x04\x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\0\x02'\x05\x12\x04\xa3\
    \x01\x11\x17\n\r\n\x05\x04\0\x02'\x01\x12\x04\xa3\x01\x180\n\r\n\x05\x04\
    \0\x02'\x03\x12\x04\xa3\x0135\n\x0c\n\x04\x04\0\x02(\x12\x04\xa4\x01\x08\
    ?\n\r\n\x05\x04\0\x02(\x04\x12\x04\xa4\x01\x08\x10\n\r\n\x05\x04\0\x02(\
    \x05\x12\x04\xa4\x01\x11\x17\n\r\n\x05\x04\0\x02(\x01\x12\x04\xa4\x01\
    \x189\n\r\n\x05\x04\0\x02(\x03\x12\x04\xa4\x01<>\n\x0c\n\x04\x04\0\x02)\
    \x12\x04\xa5\x01\x080\n\r\n\x05\x04\0\x02)\x04\x12\x04\xa5\x01\x08\x10\n\
    \r\n\x05\x04\0\x02)\x05\x12\x04\xa5\x01\x11\x17\n\r\n\x05\x04\0\x02)\x01\
    \x12\x04\xa5\x01\x18*\n\r\n\x05\x04\0\x02)\x03\x12\x04\xa5\x01-/\n\x0c\n\
    \x04\x04\0\x02*\x12\x04\xa6\x01\x080\n\r\n\x05\x04\0\x02*\x04\x12\x04\
    \xa6\x01\x08\x10\n\r\n\x05\x04\0\x02*\x05\x12\x04\xa6\x01\x11\x17\n\r\n\
    \x05\x04\0\x02*\x01\x12\x04\xa6\x01\x18*\n\r\n\x05\x04\0\x02*\x03\x12\
    \x04\xa6\x01-/\n\x0c\n\x04\x04\0\x02+\x12\x04\xa7\x01\x080\n\r\n\x05\x04\
    \0\x02+\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\0\x02+\x05\x12\x04\xa7\
    \x01\x11\x17\n\r\n\x05\x04\0\x02+\x01\x12\x04\xa7\x01\x18*\n\r\n\x05\x04\
    \0\x02+\x03\x12\x04\xa7\x01-/\n\x0c\n\x04\x04\0\x02,\x12\x04\xa8\x01\x08\
    3\n\r\n\x05\x04\0\x02,\x04\x12\x04\xa8\x01\x08\x10\n\r\n\x05\x04\0\x02,\
    \x05\x12\x04\xa8\x01\x11\x17\n\r\n\x05\x04\0\x02,\x01\x12\x04\xa8\x01\
    \x18,\n\r\n\x05\x04\0\x02,\x03\x12\x04\xa8\x01/2\n\x0c\n\x04\x04\0\x02-\
    \x12\x04\xa9\x01\x081\n\r\n\x05\x04\0\x02-\x04\x12\x04\xa9\x01\x08\x10\n\
    \r\n\x05\x04\0\x02-\x05\x12\x04\xa9\x01\x11\x17\n\r\n\x05\x04\0\x02-\x01\
    \x12\x04\xa9\x01\x18*\n\r\n\x05\x04\0\x02-\x03\x12\x04\xa9\x01-0\n\x0c\n\
    \x04\x04\0\x02.\x12\x04\xaa\x01\x08>\n\r\n\x05\x04\0\x02.\x04\x12\x04\
    \xaa\x01\x08\x10\n\r\n\x05\x04\0\x02.\x05\x12\x04\xaa\x01\x11\x17\n\r\n\
    \x05\x04\0\x02.\x01\x12\x04\xaa\x01\x187\n\r\n\x05\x04\0\x02.\x03\x12\
    \x04\xaa\x01:=\n\x0c\n\x04\x04\0\x02/\x12\x04\xab\x01\x080\n\r\n\x05\x04\
    \0\x02/\x04\x12\x04\xab\x01\x08\x10\n\r\n\x05\x04\0\x02/\x05\x12\x04\xab\
    \x01\x11\x17\n\r\n\x05\x04\0\x02/\x01\x12\x04\xab\x01\x18)\n\r\n\x05\x04\
    \0\x02/\x03\x12\x04\xab\x01,/\n\x0c\n\x04\x04\0\x020\x12\x04\xac\x01\x08\
    0\n\r\n\x05\x04\0\x020\x04\x12\x04\xac\x01\x08\x10\n\r\n\x05\x04\0\x020\
    \x05\x12\x04\xac\x01\x11\x17\n\r\n\x05\x04\0\x020\x01\x12\x04\xac\x01\
    \x18)\n\r\n\x05\x04\0\x020\x03\x12\x04\xac\x01,/\n\x0c\n\x04\x04\0\x021\
    \x12\x04\xad\x01\x080\n\r\n\x05\x04\0\x021\x04\x12\x04\xad\x01\x08\x10\n\
    \r\n\x05\x04\0\x021\x05\x12\x04\xad\x01\x11\x17\n\r\n\x05\x04\0\x021\x01\
    \x12\x04\xad\x01\x18)\n\r\n\x05\x04\0\x021\x03\x12\x04\xad\x01,/\n\x0c\n\
    \x04\x04\0\x022\x12\x04\xae\x01\x08+\n\r\n\x05\x04\0\x022\x04\x12\x04\
    \xae\x01\x08\x10\n\r\n\x05\x04\0\x022\x05\x12\x04\xae\x01\x11\x17\n\r\n\
    \x05\x04\0\x022\x01\x12\x04\xae\x01\x18$\n\r\n\x05\x04\0\x022\x03\x12\
    \x04\xae\x01'*\n\x0c\n\x04\x04\0\x023\x12\x04\xaf\x01\x08+\n\r\n\x05\x04\
    \0\x023\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\0\x023\x05\x12\x04\xaf\
    \x01\x11\x17\n\r\n\x05\x04\0\x023\x01\x12\x04\xaf\x01\x18$\n\r\n\x05\x04\
    \0\x023\x03\x12\x04\xaf\x01'*\n\x0c\n\x04\x04\0\x024\x12\x04\xb0\x01\x08\
    L\n\r\n\x05\x04\0\x024\x04\x12\x04\xb0\x01\x08\x10\n\r\n\x05\x04\0\x024\
    \x06\x12\x04\xb0\x01\x116\n\r\n\x05\x04\0\x024\x01\x12\x04\xb0\x017E\n\r\
    \n\x05\x04\0\x024\x03\x12\x04\xb0\x01HK\n\x0c\n\x04\x04\0\x025\x12\x04\
    \xb1\x01\x085\n\r\n\x05\x04\0\x025\x04\x12\x04\xb1\x01\x08\x10\n\r\n\x05\
    \x04\0\x025\x05\x12\x04\xb1\x01\x11\x17\n\r\n\x05\x04\0\x025\x01\x12\x04\
    \xb1\x01\x18.\n\r\n\x05\x04\0\x025\x03\x12\x04\xb1\x0114\n\x0c\n\x04\x04\
    \0\x026\x12\x04\xb2\x01\x085\n\r\n\x05\x04\0\x026\x04\x12\x04\xb2\x01\
    \x08\x10\n\r\n\x05\x04\0\x026\x05\x12\x04\xb2\x01\x11\x17\n\r\n\x05\x04\
    \0\x026\x01\x12\x04\xb2\x01\x18.\n\r\n\x05\x04\0\x026\x03\x12\x04\xb2\
    \x0114\n\x0c\n\x02\x04\x01\x12\x06\xb5\x01\0\xbe\x01\x01\n\x0b\n\x03\x04\
    \x01\x01\x12\x04\xb5\x01\x08\x1e\n\x0c\n\x04\x04\x01\x02\0\x12\x04\xb6\
    \x01\x08'\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\xb6\x01\x08\x10\n\r\n\x05\
    \x04\x01\x02\0\x05\x12\x04\xb6\x01\x11\x17\n\r\n\x05\x04\x01\x02\0\x01\
    \x12\x04\xb6\x01\x18\"\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xb6\x01%&\n\
    \x0c\n\x04\x04\x01\x02\x01\x12\x04\xb7\x01\x080\n\r\n\x05\x04\x01\x02\
    \x01\x04\x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\
    \xb7\x01\x11\x17\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xb7\x01\x18+\n\r\
    \n\x05\x04\x01\x02\x01\x03\x12\x04\xb7\x01./\n\x0c\n\x04\x04\x01\x02\x02\
    \x12\x04\xb8\x01\x08'\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\xb8\x01\x08\
    \x10\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xb8\x01\x11\x17\n\r\n\x05\x04\
    \x01\x02\x02\x01\x12\x04\xb8\x01\x18\"\n\r\n\x05\x04\x01\x02\x02\x03\x12\
    \x04\xb8\x01%&\n\x0c\n\x04\x04\x01\x02\x03\x12\x04\xb9\x01\x08(\n\r\n\
    \x05\x04\x01\x02\x03\x04\x12\x04\xb9\x01\x08\x10\n\r\n\x05\x04\x01\x02\
    \x03\x05\x12\x04\xb9\x01\x11\x17\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\
    \xb9\x01\x18#\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\xb9\x01&'\n\x0c\n\
    \x04\x04\x01\x02\x04\x12\x04\xba\x01\x08/\n\r\n\x05\x04\x01\x02\x04\x04\
    \x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\x01\x02\x04\x05\x12\x04\xba\x01\
    \x11\x17\n\r\n\x05\x04\x01\x02\x04\x01\x12\x04\xba\x01\x18*\n\r\n\x05\
    \x04\x01\x02\x04\x03\x12\x04\xba\x01-.\n\x0c\n\x04\x04\x01\x02\x05\x12\
    \x04\xbb\x01\x081\n\r\n\x05\x04\x01\x02\x05\x04\x12\x04\xbb\x01\x08\x10\
    \n\r\n\x05\x04\x01\x02\x05\x05\x12\x04\xbb\x01\x11\x17\n\r\n\x05\x04\x01\
    \x02\x05\x01\x12\x04\xbb\x01\x18,\n\r\n\x05\x04\x01\x02\x05\x03\x12\x04\
    \xbb\x01/0\n\x0c\n\x04\x04\x01\x02\x06\x12\x04\xbc\x01\x08/\n\r\n\x05\
    \x04\x01\x02\x06\x04\x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\x01\x02\x06\
    \x05\x12\x04\xbc\x01\x11\x18\n\r\n\x05\x04\x01\x02\x06\x01\x12\x04\xbc\
    \x01\x19*\n\r\n\x05\x04\x01\x02\x06\x03\x12\x04\xbc\x01-.\n\x0c\n\x04\
    \x04\x01\x02\x07\x12\x04\xbd\x01\x080\n\r\n\x05\x04\x01\x02\x07\x04\x12\
    \x04\xbd\x01\x08\x10\n\r\n\x05\x04\x01\x02\x07\x05\x12\x04\xbd\x01\x11\
    \x18\n\r\n\x05\x04\x01\x02\x07\x01\x12\x04\xbd\x01\x19+\n\r\n\x05\x04\
    \x01\x02\x07\x03\x12\x04\xbd\x01./\n\x0c\n\x02\x04\x02\x12\x06\xc0\x01\0\
    \xc8\x01\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\xc0\x01\x08)\n\x0e\n\x04\
    \x04\x02\x03\0\x12\x06\xc1\x01\x08\xc5\x01\t\n\r\n\x05\x04\x02\x03\0\x01\
    \x12\x04\xc1\x01\x10\x1f\n\x0e\n\x06\x04\x02\x03\0\x02\0\x12\x04\xc2\x01\
    \x10/\n\x0f\n\x07\x04\x02\x03\0\x02\0\x04\x12\x04\xc2\x01\x10\x18\n\x0f\
    \n\x07\x04\x02\x03\0\x02\0\x05\x12\x04\xc2\x01\x19\x1f\n\x0f\n\x07\x04\
    \x02\x03\0\x02\0\x01\x12\x04\xc2\x01\x20*\n\x0f\n\x07\x04\x02\x03\0\x02\
    \0\x03\x12\x04\xc2\x01-.\n\x0e\n\x06\x04\x02\x03\0\x02\x01\x12\x04\xc3\
    \x01\x102\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x04\x12\x04\xc3\x01\x10\x18\
    \n\x0f\n\x07\x04\x02\x03\0\x02\x01\x05\x12\x04\xc3\x01\x19\x1f\n\x0f\n\
    \x07\x04\x02\x03\0\x02\x01\x01\x12\x04\xc3\x01\x20-\n\x0f\n\x07\x04\x02\
    \x03\0\x02\x01\x03\x12\x04\xc3\x0101\n\x0e\n\x06\x04\x02\x03\0\x02\x02\
    \x12\x04\xc4\x01\x10.\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x04\xc4\
    \x01\x10\x18\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x05\x12\x04\xc4\x01\x19\
    \x1f\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x01\x12\x04\xc4\x01\x20)\n\x0f\n\
    \x07\x04\x02\x03\0\x02\x02\x03\x12\x04\xc4\x01,-\n\x0c\n\x04\x04\x02\x02\
    \0\x12\x04\xc7\x01\x08P\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\xc7\x01\x08\
    \x10\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xc7\x01\x11B\n\r\n\x05\x04\x02\
    \x02\0\x01\x12\x04\xc7\x01CK\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xc7\x01\
    NO\n\x0c\n\x02\x04\x03\x12\x06\xca\x01\0\xd4\x01\x01\n\x0b\n\x03\x04\x03\
    \x01\x12\x04\xca\x01\x08\x1c\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xcb\x01\
    \x08'\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\x04\
    \x03\x02\0\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\x04\x03\x02\0\x01\x12\
    \x04\xcb\x01\x18\"\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xcb\x01%&\n\x0c\n\
    \x04\x04\x03\x02\x01\x12\x04\xcc\x01\x08%\n\r\n\x05\x04\x03\x02\x01\x04\
    \x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\xcc\x01\
    \x11\x17\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xcc\x01\x18\x20\n\r\n\x05\
    \x04\x03\x02\x01\x03\x12\x04\xcc\x01#$\n\x0c\n\x04\x04\x03\x02\x02\x12\
    \x04\xcd\x01\x08(\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04\xcd\x01\x08\x10\
    \n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\xcd\x01\x11\x17\n\r\n\x05\x04\x03\
    \x02\x02\x01\x12\x04\xcd\x01\x18#\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\
    \xcd\x01&'\n\x0c\n\x04\x04\x03\x02\x03\x12\x04\xce\x01\x08(\n\r\n\x05\
    \x04\x03\x02\x03\x04\x12\x04\xce\x01\x08\x10\n\r\n\x05\x04\x03\x02\x03\
    \x05\x12\x04\xce\x01\x11\x17\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xce\
    \x01\x18#\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xce\x01&'\n\x0c\n\x04\
    \x04\x03\x02\x04\x12\x04\xcf\x01\x08*\n\r\n\x05\x04\x03\x02\x04\x04\x12\
    \x04\xcf\x01\x08\x10\n\r\n\x05\x04\x03\x02\x04\x05\x12\x04\xcf\x01\x11\
    \x17\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\xcf\x01\x18%\n\r\n\x05\x04\
    \x03\x02\x04\x03\x12\x04\xcf\x01()\n\x0c\n\x04\x04\x03\x02\x05\x12\x04\
    \xd0\x01\x08(\n\r\n\x05\x04\x03\x02\x05\x04\x12\x04\xd0\x01\x08\x10\n\r\
    \n\x05\x04\x03\x02\x05\x05\x12\x04\xd0\x01\x11\x17\n\r\n\x05\x04\x03\x02\
    \x05\x01\x12\x04\xd0\x01\x18#\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\xd0\
    \x01&'\n\x0c\n\x04\x04\x03\x02\x06\x12\x04\xd1\x01\x08$\n\r\n\x05\x04\
    \x03\x02\x06\x04\x12\x04\xd1\x01\x08\x10\n\r\n\x05\x04\x03\x02\x06\x05\
    \x12\x04\xd1\x01\x11\x17\n\r\n\x05\x04\x03\x02\x06\x01\x12\x04\xd1\x01\
    \x18\x1f\n\r\n\x05\x04\x03\x02\x06\x03\x12\x04\xd1\x01\"#\n\x0c\n\x04\
    \x04\x03\x02\x07\x12\x04\xd2\x01\x08#\n\r\n\x05\x04\x03\x02\x07\x04\x12\
    \x04\xd2\x01\x08\x10\n\r\n\x05\x04\x03\x02\x07\x05\x12\x04\xd2\x01\x11\
    \x17\n\r\n\x05\x04\x03\x02\x07\x01\x12\x04\xd2\x01\x18\x1e\n\r\n\x05\x04\
    \x03\x02\x07\x03\x12\x04\xd2\x01!\"\n\x0c\n\x04\x04\x03\x02\x08\x12\x04\
    \xd3\x01\x08&\n\r\n\x05\x04\x03\x02\x08\x04\x12\x04\xd3\x01\x08\x10\n\r\
    \n\x05\x04\x03\x02\x08\x05\x12\x04\xd3\x01\x11\x17\n\r\n\x05\x04\x03\x02\
    \x08\x01\x12\x04\xd3\x01\x18!\n\r\n\x05\x04\x03\x02\x08\x03\x12\x04\xd3\
    \x01$%\n\x0c\n\x02\x04\x04\x12\x06\xd6\x01\0\xd8\x01\x01\n\x0b\n\x03\x04\
    \x04\x01\x12\x04\xd6\x01\x08%\n\x0c\n\x04\x04\x04\x02\0\x12\x04\xd7\x01\
    \x082\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\
    \x04\x02\0\x06\x12\x04\xd7\x01\x11%\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\
    \xd7\x01&-\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xd7\x0101\n\x0c\n\x02\x04\
    \x05\x12\x06\xda\x01\0\xdc\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\xda\
    \x01\x08%\n\x0c\n\x04\x04\x05\x02\0\x12\x04\xdb\x01\x08$\n\r\n\x05\x04\
    \x05\x02\0\x04\x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\x05\x12\
    \x04\xdb\x01\x11\x17\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xdb\x01\x18\x1f\
    \n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xdb\x01\"#\n\x0c\n\x02\x04\x06\x12\
    \x06\xde\x01\0\xe7\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xde\x01\x08\
    \x1c\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xdf\x01\x08$\n\r\n\x05\x04\x06\
    \x02\0\x04\x12\x04\xdf\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\
    \xdf\x01\x11\x17\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xdf\x01\x18\x1f\n\r\
    \n\x05\x04\x06\x02\0\x03\x12\x04\xdf\x01\"#\n\x0c\n\x04\x04\x06\x02\x01\
    \x12\x04\xe0\x01\x080\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xe0\x01\x08\
    \x10\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xe0\x01\x11\x17\n\r\n\x05\x04\
    \x06\x02\x01\x01\x12\x04\xe0\x01\x18+\n\r\n\x05\x04\x06\x02\x01\x03\x12\
    \x04\xe0\x01./\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xe1\x01\x08*\n\r\n\
    \x05\x04\x06\x02\x02\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x06\x02\
    \x02\x05\x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\
    \xe1\x01\x18%\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xe1\x01()\n\x0c\n\
    \x04\x04\x06\x02\x03\x12\x04\xe2\x01\x08!\n\r\n\x05\x04\x06\x02\x03\x04\
    \x12\x04\xe2\x01\x08\x10\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\xe2\x01\
    \x11\x16\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xe2\x01\x17\x1c\n\r\n\x05\
    \x04\x06\x02\x03\x03\x12\x04\xe2\x01\x1f\x20\n\x0c\n\x04\x04\x06\x02\x04\
    \x12\x04\xe3\x01\x08%\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04\xe3\x01\x08\
    \x10\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\xe3\x01\x11\x17\n\r\n\x05\x04\
    \x06\x02\x04\x01\x12\x04\xe3\x01\x18\x20\n\r\n\x05\x04\x06\x02\x04\x03\
    \x12\x04\xe3\x01#$\n\x0c\n\x04\x04\x06\x02\x05\x12\x04\xe4\x01\x08(\n\r\
    \n\x05\x04\x06\x02\x05\x04\x12\x04\xe4\x01\x08\x10\n\r\n\x05\x04\x06\x02\
    \x05\x05\x12\x04\xe4\x01\x11\x17\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\
    \xe4\x01\x18#\n\r\n\x05\x04\x06\x02\x05\x03\x12\x04\xe4\x01&'\n\x0c\n\
    \x04\x04\x06\x02\x06\x12\x04\xe5\x01\x08\"\n\r\n\x05\x04\x06\x02\x06\x04\
    \x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x06\x02\x06\x05\x12\x04\xe5\x01\
    \x11\x17\n\r\n\x05\x04\x06\x02\x06\x01\x12\x04\xe5\x01\x18\x1d\n\r\n\x05\
    \x04\x06\x02\x06\x03\x12\x04\xe5\x01\x20!\n\x0c\n\x04\x04\x06\x02\x07\
    \x12\x04\xe6\x01\x08*\n\r\n\x05\x04\x06\x02\x07\x04\x12\x04\xe6\x01\x08\
    \x10\n\r\n\x05\x04\x06\x02\x07\x05\x12\x04\xe6\x01\x11\x15\n\r\n\x05\x04\
    \x06\x02\x07\x01\x12\x04\xe6\x01\x16%\n\r\n\x05\x04\x06\x02\x07\x03\x12\
    \x04\xe6\x01()\n\x0c\n\x02\x04\x07\x12\x06\xe9\x01\0\xec\x01\x01\n\x0b\n\
    \x03\x04\x07\x01\x12\x04\xe9\x01\x08\"\n\x0c\n\x04\x04\x07\x02\0\x12\x04\
    \xea\x01\x08#\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xea\x01\x08\x10\n\r\n\
    \x05\x04\x07\x02\0\x05\x12\x04\xea\x01\x11\x16\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\xea\x01\x17\x1e\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xea\x01\
    !\"\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xeb\x01\x08!\n\r\n\x05\x04\x07\
    \x02\x01\x04\x12\x04\xeb\x01\x08\x10\n\r\n\x05\x04\x07\x02\x01\x05\x12\
    \x04\xeb\x01\x11\x17\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xeb\x01\x18\
    \x1c\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xeb\x01\x1f\x20\n\x0c\n\x02\
    \x04\x08\x12\x06\xee\x01\0\xf1\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \xee\x01\x08#\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xef\x01\x089\n\r\n\x05\
    \x04\x08\x02\0\x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\x04\x08\x02\0\x06\
    \x12\x04\xef\x01\x11/\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xef\x0104\n\r\
    \n\x05\x04\x08\x02\0\x03\x12\x04\xef\x0178\n\x0c\n\x04\x04\x08\x02\x01\
    \x12\x04\xf0\x01\x08!\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xf0\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xf0\x01\x11\x16\n\r\n\x05\x04\
    \x08\x02\x01\x01\x12\x04\xf0\x01\x17\x1c\n\r\n\x05\x04\x08\x02\x01\x03\
    \x12\x04\xf0\x01\x1f\x20\n\x0c\n\x02\x04\t\x12\x06\xf3\x01\0\x99\x02\x01\
    \n\x0b\n\x03\x04\t\x01\x12\x04\xf3\x01\x08\x1e\n\x0c\n\x04\x04\t\x02\0\
    \x12\x04\xf4\x01\x08!\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xf4\x01\x08\x10\
    \n\r\n\x05\x04\t\x02\0\x05\x12\x04\xf4\x01\x11\x17\n\r\n\x05\x04\t\x02\0\
    \x01\x12\x04\xf4\x01\x18\x1c\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xf4\x01\
    \x1f\x20\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xf5\x01\x08\"\n\r\n\x05\x04\t\
    \x02\x01\x04\x12\x04\xf5\x01\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\
    \xf5\x01\x11\x17\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xf5\x01\x18\x1d\n\r\
    \n\x05\x04\t\x02\x01\x03\x12\x04\xf5\x01\x20!\n\x0c\n\x04\x04\t\x02\x02\
    \x12\x04\xf6\x01\x08#\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xf6\x01\x08\
    \x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xf6\x01\x11\x17\n\r\n\x05\x04\t\
    \x02\x02\x01\x12\x04\xf6\x01\x18\x1e\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\
    \xf6\x01!\"\n\x0c\n\x04\x04\t\x02\x03\x12\x04\xf7\x01\x08$\n\r\n\x05\x04\
    \t\x02\x03\x04\x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\t\x02\x03\x05\x12\
    \x04\xf7\x01\x11\x17\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xf7\x01\x18\x1f\
    \n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xf7\x01\"#\n\x0c\n\x04\x04\t\x02\
    \x04\x12\x04\xf8\x01\x08&\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\xf8\x01\
    \x08\x10\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xf8\x01\x11\x17\n\r\n\x05\
    \x04\t\x02\x04\x01\x12\x04\xf8\x01\x18!\n\r\n\x05\x04\t\x02\x04\x03\x12\
    \x04\xf8\x01$%\n\x0c\n\x04\x04\t\x02\x05\x12\x04\xf9\x01\x08\x1f\n\r\n\
    \x05\x04\t\x02\x05\x04\x12\x04\xf9\x01\x08\x10\n\r\n\x05\x04\t\x02\x05\
    \x05\x12\x04\xf9\x01\x11\x17\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xf9\x01\
    \x18\x1a\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xf9\x01\x1d\x1e\n\x0c\n\x04\
    \x04\t\x02\x06\x12\x04\xfa\x01\x08&\n\r\n\x05\x04\t\x02\x06\x04\x12\x04\
    \xfa\x01\x08\x10\n\r\n\x05\x04\t\x02\x06\x05\x12\x04\xfa\x01\x11\x17\n\r\
    \n\x05\x04\t\x02\x06\x01\x12\x04\xfa\x01\x18!\n\r\n\x05\x04\t\x02\x06\
    \x03\x12\x04\xfa\x01$%\n\x0c\n\x04\x04\t\x02\x07\x12\x04\xfb\x01\x08#\n\
    \r\n\x05\x04\t\x02\x07\x04\x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04\t\x02\
    \x07\x05\x12\x04\xfb\x01\x11\x17\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xfb\
    \x01\x18\x1e\n\r\n\x05\x04\t\x02\x07\x03\x12\x04\xfb\x01!\"\n\x0c\n\x04\
    \x04\t\x02\x08\x12\x04\xfc\x01\x08-\n\r\n\x05\x04\t\x02\x08\x04\x12\x04\
    \xfc\x01\x08\x10\n\r\n\x05\x04\t\x02\x08\x05\x12\x04\xfc\x01\x11\x17\n\r\
    \n\x05\x04\t\x02\x08\x01\x12\x04\xfc\x01\x18(\n\r\n\x05\x04\t\x02\x08\
    \x03\x12\x04\xfc\x01+,\n\x0c\n\x04\x04\t\x02\t\x12\x04\xfd\x01\x086\n\r\
    \n\x05\x04\t\x02\t\x04\x12\x04\xfd\x01\x08\x10\n\r\n\x05\x04\t\x02\t\x05\
    \x12\x04\xfd\x01\x11\x17\n\r\n\x05\x04\t\x02\t\x01\x12\x04\xfd\x01\x180\
    \n\r\n\x05\x04\t\x02\t\x03\x12\x04\xfd\x0135\n\x0c\n\x04\x04\t\x02\n\x12\
    \x04\xfe\x01\x085\n\r\n\x05\x04\t\x02\n\x04\x12\x04\xfe\x01\x08\x10\n\r\
    \n\x05\x04\t\x02\n\x05\x12\x04\xfe\x01\x11\x17\n\r\n\x05\x04\t\x02\n\x01\
    \x12\x04\xfe\x01\x18/\n\r\n\x05\x04\t\x02\n\x03\x12\x04\xfe\x0124\n\x0c\
    \n\x04\x04\t\x02\x0b\x12\x04\xff\x01\x082\n\r\n\x05\x04\t\x02\x0b\x04\
    \x12\x04\xff\x01\x08\x10\n\r\n\x05\x04\t\x02\x0b\x05\x12\x04\xff\x01\x11\
    \x17\n\r\n\x05\x04\t\x02\x0b\x01\x12\x04\xff\x01\x18,\n\r\n\x05\x04\t\
    \x02\x0b\x03\x12\x04\xff\x01/1\n\x0c\n\x04\x04\t\x02\x0c\x12\x04\x80\x02\
    \x081\n\r\n\x05\x04\t\x02\x0c\x04\x12\x04\x80\x02\x08\x10\n\r\n\x05\x04\
    \t\x02\x0c\x05\x12\x04\x80\x02\x11\x17\n\r\n\x05\x04\t\x02\x0c\x01\x12\
    \x04\x80\x02\x18+\n\r\n\x05\x04\t\x02\x0c\x03\x12\x04\x80\x02.0\n\x0c\n\
    \x04\x04\t\x02\r\x12\x04\x81\x02\x08,\n\r\n\x05\x04\t\x02\r\x04\x12\x04\
    \x81\x02\x08\x10\n\r\n\x05\x04\t\x02\r\x05\x12\x04\x81\x02\x11\x17\n\r\n\
    \x05\x04\t\x02\r\x01\x12\x04\x81\x02\x18&\n\r\n\x05\x04\t\x02\r\x03\x12\
    \x04\x81\x02)+\n\x0c\n\x04\x04\t\x02\x0e\x12\x04\x82\x02\x08-\n\r\n\x05\
    \x04\t\x02\x0e\x04\x12\x04\x82\x02\x08\x10\n\r\n\x05\x04\t\x02\x0e\x05\
    \x12\x04\x82\x02\x11\x17\n\r\n\x05\x04\t\x02\x0e\x01\x12\x04\x82\x02\x18\
    '\n\r\n\x05\x04\t\x02\x0e\x03\x12\x04\x82\x02*,\n\x0c\n\x04\x04\t\x02\
    \x0f\x12\x04\x83\x02\x08+\n\r\n\x05\x04\t\x02\x0f\x04\x12\x04\x83\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\x0f\x05\x12\x04\x83\x02\x11\x17\n\r\n\x05\
    \x04\t\x02\x0f\x01\x12\x04\x83\x02\x18%\n\r\n\x05\x04\t\x02\x0f\x03\x12\
    \x04\x83\x02(*\n\x0c\n\x04\x04\t\x02\x10\x12\x04\x84\x02\x08(\n\r\n\x05\
    \x04\t\x02\x10\x04\x12\x04\x84\x02\x08\x10\n\r\n\x05\x04\t\x02\x10\x05\
    \x12\x04\x84\x02\x11\x17\n\r\n\x05\x04\t\x02\x10\x01\x12\x04\x84\x02\x18\
    \"\n\r\n\x05\x04\t\x02\x10\x03\x12\x04\x84\x02%'\n\x0c\n\x04\x04\t\x02\
    \x11\x12\x04\x85\x02\x08+\n\r\n\x05\x04\t\x02\x11\x04\x12\x04\x85\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\x11\x05\x12\x04\x85\x02\x11\x17\n\r\n\x05\
    \x04\t\x02\x11\x01\x12\x04\x85\x02\x18%\n\r\n\x05\x04\t\x02\x11\x03\x12\
    \x04\x85\x02(*\n\x0c\n\x04\x04\t\x02\x12\x12\x04\x86\x02\x08/\n\r\n\x05\
    \x04\t\x02\x12\x04\x12\x04\x86\x02\x08\x10\n\r\n\x05\x04\t\x02\x12\x05\
    \x12\x04\x86\x02\x11\x17\n\r\n\x05\x04\t\x02\x12\x01\x12\x04\x86\x02\x18\
    )\n\r\n\x05\x04\t\x02\x12\x03\x12\x04\x86\x02,.\n\x0c\n\x04\x04\t\x02\
    \x13\x12\x04\x87\x02\x080\n\r\n\x05\x04\t\x02\x13\x04\x12\x04\x87\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\x13\x05\x12\x04\x87\x02\x11\x17\n\r\n\x05\
    \x04\t\x02\x13\x01\x12\x04\x87\x02\x18*\n\r\n\x05\x04\t\x02\x13\x03\x12\
    \x04\x87\x02-/\n\x0c\n\x04\x04\t\x02\x14\x12\x04\x88\x02\x08-\n\r\n\x05\
    \x04\t\x02\x14\x04\x12\x04\x88\x02\x08\x10\n\r\n\x05\x04\t\x02\x14\x05\
    \x12\x04\x88\x02\x11\x17\n\r\n\x05\x04\t\x02\x14\x01\x12\x04\x88\x02\x18\
    '\n\r\n\x05\x04\t\x02\x14\x03\x12\x04\x88\x02*,\n\x0c\n\x04\x04\t\x02\
    \x15\x12\x04\x89\x02\x084\n\r\n\x05\x04\t\x02\x15\x04\x12\x04\x89\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\x15\x05\x12\x04\x89\x02\x11\x17\n\r\n\x05\
    \x04\t\x02\x15\x01\x12\x04\x89\x02\x18.\n\r\n\x05\x04\t\x02\x15\x03\x12\
    \x04\x89\x0213\n\x0c\n\x04\x04\t\x02\x16\x12\x04\x8a\x02\x084\n\r\n\x05\
    \x04\t\x02\x16\x04\x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04\t\x02\x16\x05\
    \x12\x04\x8a\x02\x11\x17\n\r\n\x05\x04\t\x02\x16\x01\x12\x04\x8a\x02\x18\
    .\n\r\n\x05\x04\t\x02\x16\x03\x12\x04\x8a\x0213\n\x0c\n\x04\x04\t\x02\
    \x17\x12\x04\x8b\x02\x084\n\r\n\x05\x04\t\x02\x17\x04\x12\x04\x8b\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\x17\x05\x12\x04\x8b\x02\x11\x17\n\r\n\x05\
    \x04\t\x02\x17\x01\x12\x04\x8b\x02\x18.\n\r\n\x05\x04\t\x02\x17\x03\x12\
    \x04\x8b\x0213\n\x0c\n\x04\x04\t\x02\x18\x12\x04\x8c\x02\x084\n\r\n\x05\
    \x04\t\x02\x18\x04\x12\x04\x8c\x02\x08\x10\n\r\n\x05\x04\t\x02\x18\x05\
    \x12\x04\x8c\x02\x11\x17\n\r\n\x05\x04\t\x02\x18\x01\x12\x04\x8c\x02\x18\
    .\n\r\n\x05\x04\t\x02\x18\x03\x12\x04\x8c\x0213\n\x0c\n\x04\x04\t\x02\
    \x19\x12\x04\x8d\x02\x084\n\r\n\x05\x04\t\x02\x19\x04\x12\x04\x8d\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\x19\x05\x12\x04\x8d\x02\x11\x17\n\r\n\x05\
    \x04\t\x02\x19\x01\x12\x04\x8d\x02\x18.\n\r\n\x05\x04\t\x02\x19\x03\x12\
    \x04\x8d\x0213\n\x0c\n\x04\x04\t\x02\x1a\x12\x04\x8e\x02\x08*\n\r\n\x05\
    \x04\t\x02\x1a\x04\x12\x04\x8e\x02\x08\x10\n\r\n\x05\x04\t\x02\x1a\x05\
    \x12\x04\x8e\x02\x11\x17\n\r\n\x05\x04\t\x02\x1a\x01\x12\x04\x8e\x02\x18\
    $\n\r\n\x05\x04\t\x02\x1a\x03\x12\x04\x8e\x02')\n\x0c\n\x04\x04\t\x02\
    \x1b\x12\x04\x8f\x02\x08*\n\r\n\x05\x04\t\x02\x1b\x04\x12\x04\x8f\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\x1b\x05\x12\x04\x8f\x02\x11\x17\n\r\n\x05\
    \x04\t\x02\x1b\x01\x12\x04\x8f\x02\x18$\n\r\n\x05\x04\t\x02\x1b\x03\x12\
    \x04\x8f\x02')\n\x0c\n\x04\x04\t\x02\x1c\x12\x04\x90\x02\x08)\n\r\n\x05\
    \x04\t\x02\x1c\x04\x12\x04\x90\x02\x08\x10\n\r\n\x05\x04\t\x02\x1c\x05\
    \x12\x04\x90\x02\x11\x17\n\r\n\x05\x04\t\x02\x1c\x01\x12\x04\x90\x02\x18\
    #\n\r\n\x05\x04\t\x02\x1c\x03\x12\x04\x90\x02&(\n\x0c\n\x04\x04\t\x02\
    \x1d\x12\x04\x91\x02\x08)\n\r\n\x05\x04\t\x02\x1d\x04\x12\x04\x91\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\x1d\x05\x12\x04\x91\x02\x11\x17\n\r\n\x05\
    \x04\t\x02\x1d\x01\x12\x04\x91\x02\x18#\n\r\n\x05\x04\t\x02\x1d\x03\x12\
    \x04\x91\x02&(\n\x0c\n\x04\x04\t\x02\x1e\x12\x04\x92\x02\x08(\n\r\n\x05\
    \x04\t\x02\x1e\x04\x12\x04\x92\x02\x08\x10\n\r\n\x05\x04\t\x02\x1e\x05\
    \x12\x04\x92\x02\x11\x17\n\r\n\x05\x04\t\x02\x1e\x01\x12\x04\x92\x02\x18\
    \"\n\r\n\x05\x04\t\x02\x1e\x03\x12\x04\x92\x02%'\n\x0c\n\x04\x04\t\x02\
    \x1f\x12\x04\x93\x02\x080\n\r\n\x05\x04\t\x02\x1f\x04\x12\x04\x93\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\x1f\x05\x12\x04\x93\x02\x11\x17\n\r\n\x05\
    \x04\t\x02\x1f\x01\x12\x04\x93\x02\x18*\n\r\n\x05\x04\t\x02\x1f\x03\x12\
    \x04\x93\x02-/\n\x0c\n\x04\x04\t\x02\x20\x12\x04\x94\x02\x08+\n\r\n\x05\
    \x04\t\x02\x20\x04\x12\x04\x94\x02\x08\x10\n\r\n\x05\x04\t\x02\x20\x05\
    \x12\x04\x94\x02\x11\x17\n\r\n\x05\x04\t\x02\x20\x01\x12\x04\x94\x02\x18\
    %\n\r\n\x05\x04\t\x02\x20\x03\x12\x04\x94\x02(*\n\x0c\n\x04\x04\t\x02!\
    \x12\x04\x95\x02\x08*\n\r\n\x05\x04\t\x02!\x04\x12\x04\x95\x02\x08\x10\n\
    \r\n\x05\x04\t\x02!\x05\x12\x04\x95\x02\x11\x17\n\r\n\x05\x04\t\x02!\x01\
    \x12\x04\x95\x02\x18$\n\r\n\x05\x04\t\x02!\x03\x12\x04\x95\x02')\n\x0c\n\
    \x04\x04\t\x02\"\x12\x04\x96\x02\x08*\n\r\n\x05\x04\t\x02\"\x04\x12\x04\
    \x96\x02\x08\x10\n\r\n\x05\x04\t\x02\"\x05\x12\x04\x96\x02\x11\x17\n\r\n\
    \x05\x04\t\x02\"\x01\x12\x04\x96\x02\x18$\n\r\n\x05\x04\t\x02\"\x03\x12\
    \x04\x96\x02')\n\x0c\n\x04\x04\t\x02#\x12\x04\x97\x02\x08&\n\r\n\x05\x04\
    \t\x02#\x04\x12\x04\x97\x02\x08\x10\n\r\n\x05\x04\t\x02#\x05\x12\x04\x97\
    \x02\x11\x17\n\r\n\x05\x04\t\x02#\x01\x12\x04\x97\x02\x18\x20\n\r\n\x05\
    \x04\t\x02#\x03\x12\x04\x97\x02#%\n\x0c\n\x04\x04\t\x02$\x12\x04\x98\x02\
    \x08?\n\r\n\x05\x04\t\x02$\x04\x12\x04\x98\x02\x08\x10\n\r\n\x05\x04\t\
    \x02$\x06\x12\x04\x98\x02\x11,\n\r\n\x05\x04\t\x02$\x01\x12\x04\x98\x02-\
    9\n\r\n\x05\x04\t\x02$\x03\x12\x04\x98\x02<>\n\x0c\n\x02\x04\n\x12\x06\
    \x9b\x02\0\xa1\x02\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x9b\x02\x08\x1c\n\
    \x0c\n\x04\x04\n\x02\0\x12\x04\x9c\x02\x08!\n\r\n\x05\x04\n\x02\0\x04\
    \x12\x04\x9c\x02\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x9c\x02\x11\
    \x17\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x9c\x02\x18\x1c\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\x9c\x02\x1f\x20\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x9d\
    \x02\x080\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x9d\x02\x08\x10\n\r\n\x05\
    \x04\n\x02\x01\x05\x12\x04\x9d\x02\x11\x17\n\r\n\x05\x04\n\x02\x01\x01\
    \x12\x04\x9d\x02\x18+\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x9d\x02./\n\
    \x0c\n\x04\x04\n\x02\x02\x12\x04\x9e\x02\x082\n\r\n\x05\x04\n\x02\x02\
    \x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\x9e\x02\
    \x11\x17\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x9e\x02\x18-\n\r\n\x05\x04\
    \n\x02\x02\x03\x12\x04\x9e\x0201\n\x0c\n\x04\x04\n\x02\x03\x12\x04\x9f\
    \x02\x080\n\r\n\x05\x04\n\x02\x03\x04\x12\x04\x9f\x02\x08\x10\n\r\n\x05\
    \x04\n\x02\x03\x05\x12\x04\x9f\x02\x11\x17\n\r\n\x05\x04\n\x02\x03\x01\
    \x12\x04\x9f\x02\x18+\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\x9f\x02./\n\
    \x0c\n\x04\x04\n\x02\x04\x12\x04\xa0\x02\x082\n\r\n\x05\x04\n\x02\x04\
    \x04\x12\x04\xa0\x02\x08\x10\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xa0\x02\
    \x11\x17\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xa0\x02\x18-\n\r\n\x05\x04\
    \n\x02\x04\x03\x12\x04\xa0\x0201\n\x0c\n\x02\x04\x0b\x12\x06\xa3\x02\0\
    \xa6\x02\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xa3\x02\x08%\n\x0c\n\x04\
    \x04\x0b\x02\0\x12\x04\xa4\x02\x08&\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\
    \xa4\x02\x08\x10\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xa4\x02\x11\x17\n\r\
    \n\x05\x04\x0b\x02\0\x01\x12\x04\xa4\x02\x18!\n\r\n\x05\x04\x0b\x02\0\
    \x03\x12\x04\xa4\x02$%\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xa5\x02\x08!\
    \n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04\x0b\
    \x02\x01\x05\x12\x04\xa5\x02\x11\x16\n\r\n\x05\x04\x0b\x02\x01\x01\x12\
    \x04\xa5\x02\x17\x1c\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xa5\x02\x1f\
    \x20\n\x0c\n\x02\x04\x0c\x12\x06\xa8\x02\0\xac\x02\x01\n\x0b\n\x03\x04\
    \x0c\x01\x12\x04\xa8\x02\x08!\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xa9\x02\
    \x08+\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xa9\x02\x08\x10\n\r\n\x05\x04\
    \x0c\x02\0\x05\x12\x04\xa9\x02\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\
    \x04\xa9\x02\x18&\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xa9\x02)*\n\x0c\n\
    \x04\x04\x0c\x02\x01\x12\x04\xaa\x02\x08(\n\r\n\x05\x04\x0c\x02\x01\x04\
    \x12\x04\xaa\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xaa\x02\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xaa\x02\x18#\n\r\n\x05\
    \x04\x0c\x02\x01\x03\x12\x04\xaa\x02&'\n\x0c\n\x04\x04\x0c\x02\x02\x12\
    \x04\xab\x02\x08'\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xab\x02\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x02\x01\x12\x04\xab\x02\x18\"\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\
    \xab\x02%&\n\x0c\n\x02\x04\r\x12\x06\xae\x02\0\xb2\x02\x01\n\x0b\n\x03\
    \x04\r\x01\x12\x04\xae\x02\x08\x1d\n\x0c\n\x04\x04\r\x02\0\x12\x04\xaf\
    \x02\x08\"\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xaf\x02\x08\x10\n\r\n\x05\
    \x04\r\x02\0\x05\x12\x04\xaf\x02\x11\x15\n\r\n\x05\x04\r\x02\0\x01\x12\
    \x04\xaf\x02\x16\x1d\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xaf\x02\x20!\n\
    \x0c\n\x04\x04\r\x02\x01\x12\x04\xb0\x02\x08!\n\r\n\x05\x04\r\x02\x01\
    \x04\x12\x04\xb0\x02\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xb0\x02\
    \x11\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xb0\x02\x18\x1c\n\r\n\x05\
    \x04\r\x02\x01\x03\x12\x04\xb0\x02\x1f\x20\n\x0c\n\x04\x04\r\x02\x02\x12\
    \x04\xb1\x02\x08$\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xb1\x02\x08\x10\n\
    \r\n\x05\x04\r\x02\x02\x05\x12\x04\xb1\x02\x11\x17\n\r\n\x05\x04\r\x02\
    \x02\x01\x12\x04\xb1\x02\x18\x1f\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xb1\
    \x02\"#\n\x0c\n\x02\x04\x0e\x12\x06\xb4\x02\0\xbe\x02\x01\n\x0b\n\x03\
    \x04\x0e\x01\x12\x04\xb4\x02\x08\x12\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\
    \xb5\x02\x08%\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xb5\x02\x08\x10\n\r\n\
    \x05\x04\x0e\x02\0\x05\x12\x04\xb5\x02\x11\x17\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\xb5\x02\x18\x20\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xb5\x02\
    #$\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xb6\x02\x08.\n\r\n\x05\x04\x0e\
    \x02\x01\x04\x12\x04\xb6\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x05\x12\
    \x04\xb6\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xb6\x02\x18)\
    \n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xb6\x02,-\n\x0c\n\x04\x04\x0e\x02\
    \x02\x12\x04\xb7\x02\x08.\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\xb7\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xb7\x02\x11\x17\n\r\n\x05\
    \x04\x0e\x02\x02\x01\x12\x04\xb7\x02\x18)\n\r\n\x05\x04\x0e\x02\x02\x03\
    \x12\x04\xb7\x02,-\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xb8\x02\x08-\n\r\
    \n\x05\x04\x0e\x02\x03\x04\x12\x04\xb8\x02\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x03\x05\x12\x04\xb8\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\
    \xb8\x02\x18(\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xb8\x02+,\n\x0c\n\
    \x04\x04\x0e\x02\x04\x12\x04\xb9\x02\x08&\n\r\n\x05\x04\x0e\x02\x04\x04\
    \x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\xb9\x02\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xb9\x02\x18!\n\r\n\x05\
    \x04\x0e\x02\x04\x03\x12\x04\xb9\x02$%\n\x0c\n\x04\x04\x0e\x02\x05\x12\
    \x04\xba\x02\x08$\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\xba\x02\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xba\x02\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x05\x01\x12\x04\xba\x02\x18\x1f\n\r\n\x05\x04\x0e\x02\x05\x03\x12\
    \x04\xba\x02\"#\n\x0c\n\x04\x04\x0e\x02\x06\x12\x04\xbb\x02\x08&\n\r\n\
    \x05\x04\x0e\x02\x06\x04\x12\x04\xbb\x02\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x06\x05\x12\x04\xbb\x02\x11\x16\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\
    \xbb\x02\x17!\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xbb\x02$%\n\x0c\n\
    \x04\x04\x0e\x02\x07\x12\x04\xbc\x02\x08(\n\r\n\x05\x04\x0e\x02\x07\x04\
    \x12\x04\xbc\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x07\x05\x12\x04\xbc\x02\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xbc\x02\x18#\n\r\n\x05\
    \x04\x0e\x02\x07\x03\x12\x04\xbc\x02&'\n\x0c\n\x04\x04\x0e\x02\x08\x12\
    \x04\xbd\x02\x08$\n\r\n\x05\x04\x0e\x02\x08\x04\x12\x04\xbd\x02\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\xbd\x02\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x08\x01\x12\x04\xbd\x02\x18\x1f\n\r\n\x05\x04\x0e\x02\x08\x03\x12\
    \x04\xbd\x02\"#\n\x0c\n\x02\x04\x0f\x12\x06\xc0\x02\0\xc4\x02\x01\n\x0b\
    \n\x03\x04\x0f\x01\x12\x04\xc0\x02\x08\x1f\n\x0c\n\x04\x04\x0f\x02\0\x12\
    \x04\xc1\x02\x08&\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xc1\x02\x08\x10\n\
    \r\n\x05\x04\x0f\x02\0\x05\x12\x04\xc1\x02\x11\x18\n\r\n\x05\x04\x0f\x02\
    \0\x01\x12\x04\xc1\x02\x19!\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xc1\x02$\
    %\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xc2\x02\x08'\n\r\n\x05\x04\x0f\x02\
    \x01\x04\x12\x04\xc2\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\
    \xc2\x02\x11\x16\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xc2\x02\x17\"\n\r\
    \n\x05\x04\x0f\x02\x01\x03\x12\x04\xc2\x02%&\n\x0c\n\x04\x04\x0f\x02\x02\
    \x12\x04\xc3\x02\x08+\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xc3\x02\x08\
    \x10\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xc3\x02\x11\x18\n\r\n\x05\x04\
    \x0f\x02\x02\x01\x12\x04\xc3\x02\x19&\n\r\n\x05\x04\x0f\x02\x02\x03\x12\
    \x04\xc3\x02)*\n\x0c\n\x02\x04\x10\x12\x06\xc6\x02\0\xc9\x02\x01\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\xc6\x02\x08\x1c\n\x0c\n\x04\x04\x10\x02\0\x12\
    \x04\xc7\x02\x08'\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xc7\x02\x08\x10\n\
    \r\n\x05\x04\x10\x02\0\x05\x12\x04\xc7\x02\x11\x17\n\r\n\x05\x04\x10\x02\
    \0\x01\x12\x04\xc7\x02\x18\"\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xc7\x02\
    %&\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xc8\x02\x08$\n\r\n\x05\x04\x10\
    \x02\x01\x04\x12\x04\xc8\x02\x08\x10\n\r\n\x05\x04\x10\x02\x01\x05\x12\
    \x04\xc8\x02\x11\x17\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xc8\x02\x18\
    \x1f\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xc8\x02\"#\n\x0c\n\x02\x04\
    \x11\x12\x06\xcb\x02\0\xcd\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xcb\
    \x02\x08\x1f\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xcc\x02\x08#\n\r\n\x05\
    \x04\x11\x02\0\x04\x12\x04\xcc\x02\x08\x10\n\r\n\x05\x04\x11\x02\0\x05\
    \x12\x04\xcc\x02\x11\x15\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xcc\x02\x16\
    \x1e\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xcc\x02!\"\n\x0c\n\x02\x04\x12\
    \x12\x06\xcf\x02\0\xd3\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xcf\x02\
    \x08#\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xd0\x02\x08'\n\r\n\x05\x04\x12\
    \x02\0\x04\x12\x04\xd0\x02\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\
    \xd0\x02\x11\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xd0\x02\x18\"\n\r\n\
    \x05\x04\x12\x02\0\x03\x12\x04\xd0\x02%&\n\x0c\n\x04\x04\x12\x02\x01\x12\
    \x04\xd1\x02\x081\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xd1\x02\x08\x10\
    \n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xd1\x02\x11\x17\n\r\n\x05\x04\x12\
    \x02\x01\x01\x12\x04\xd1\x02\x18,\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\
    \xd1\x02/0\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xd2\x02\x08*\n\r\n\x05\
    \x04\x12\x02\x02\x04\x12\x04\xd2\x02\x08\x10\n\r\n\x05\x04\x12\x02\x02\
    \x05\x12\x04\xd2\x02\x11\x17\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xd2\
    \x02\x18%\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xd2\x02()\n\x0c\n\x02\
    \x04\x13\x12\x06\xd5\x02\0\xdd\x02\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \xd5\x02\x08+\n\x0e\n\x04\x04\x13\x03\0\x12\x06\xd6\x02\x08\xda\x02\t\n\
    \r\n\x05\x04\x13\x03\0\x01\x12\x04\xd6\x02\x10\x1e\n\x0e\n\x06\x04\x13\
    \x03\0\x02\0\x12\x04\xd7\x02\x108\n\x0f\n\x07\x04\x13\x03\0\x02\0\x04\
    \x12\x04\xd7\x02\x10\x18\n\x0f\n\x07\x04\x13\x03\0\x02\0\x05\x12\x04\xd7\
    \x02\x19\x1f\n\x0f\n\x07\x04\x13\x03\0\x02\0\x01\x12\x04\xd7\x02\x203\n\
    \x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\x04\xd7\x0267\n\x0e\n\x06\x04\x13\
    \x03\0\x02\x01\x12\x04\xd8\x02\x10/\n\x0f\n\x07\x04\x13\x03\0\x02\x01\
    \x04\x12\x04\xd8\x02\x10\x18\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x05\x12\
    \x04\xd8\x02\x19\x1f\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x01\x12\x04\xd8\
    \x02\x20*\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x03\x12\x04\xd8\x02-.\n\x0e\
    \n\x06\x04\x13\x03\0\x02\x02\x12\x04\xd9\x02\x103\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x02\x04\x12\x04\xd9\x02\x10\x18\n\x0f\n\x07\x04\x13\x03\0\x02\
    \x02\x05\x12\x04\xd9\x02\x19\x1f\n\x0f\n\x07\x04\x13\x03\0\x02\x02\x01\
    \x12\x04\xd9\x02\x20.\n\x0f\n\x07\x04\x13\x03\0\x02\x02\x03\x12\x04\xd9\
    \x0212\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xdc\x02\x08Z\n\r\n\x05\x04\x13\
    \x02\0\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\
    \xdc\x02\x11C\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xdc\x02DU\n\r\n\x05\
    \x04\x13\x02\0\x03\x12\x04\xdc\x02XY\n\x0c\n\x02\x04\x14\x12\x06\xdf\x02\
    \0\xe3\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xdf\x02\x08\x1f\n\x0c\n\
    \x04\x04\x14\x02\0\x12\x04\xe0\x02\x08'\n\r\n\x05\x04\x14\x02\0\x04\x12\
    \x04\xe0\x02\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xe0\x02\x11\x17\
    \n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xe0\x02\x18\"\n\r\n\x05\x04\x14\x02\
    \0\x03\x12\x04\xe0\x02%&\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xe1\x02\x08\
    '\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xe1\x02\x08\x10\n\r\n\x05\x04\
    \x14\x02\x01\x05\x12\x04\xe1\x02\x11\x16\n\r\n\x05\x04\x14\x02\x01\x01\
    \x12\x04\xe1\x02\x17\"\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xe1\x02%&\n\
    \x0c\n\x04\x04\x14\x02\x02\x12\x04\xe2\x02\x08$\n\r\n\x05\x04\x14\x02\
    \x02\x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\
    \xe2\x02\x11\x15\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xe2\x02\x16\x1f\n\
    \r\n\x05\x04\x14\x02\x02\x03\x12\x04\xe2\x02\"#\n\x0c\n\x02\x04\x15\x12\
    \x06\xe5\x02\0\xe7\x02\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xe5\x02\x08\
    \x1b\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xe6\x02\x08(\n\r\n\x05\x04\x15\
    \x02\0\x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\
    \xe6\x02\x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xe6\x02\x18#\n\r\n\
    \x05\x04\x15\x02\0\x03\x12\x04\xe6\x02&'\n\x0c\n\x02\x04\x16\x12\x06\xe9\
    \x02\0\xa9\x03\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xe9\x02\x08\x1b\n\x0e\
    \n\x04\x04\x16\x03\0\x12\x06\xea\x02\x08\x8f\x03\t\n\r\n\x05\x04\x16\x03\
    \0\x01\x12\x04\xea\x02\x10\x14\n\x10\n\x06\x04\x16\x03\0\x03\0\x12\x06\
    \xeb\x02\x10\xee\x02\x11\n\x0f\n\x07\x04\x16\x03\0\x03\0\x01\x12\x04\xeb\
    \x02\x18\x1e\n\x10\n\x08\x04\x16\x03\0\x03\0\x02\0\x12\x04\xec\x02\x186\
    \n\x11\n\t\x04\x16\x03\0\x03\0\x02\0\x04\x12\x04\xec\x02\x18\x20\n\x11\n\
    \t\x04\x16\x03\0\x03\0\x02\0\x05\x12\x04\xec\x02!'\n\x11\n\t\x04\x16\x03\
    \0\x03\0\x02\0\x01\x12\x04\xec\x02(1\n\x11\n\t\x04\x16\x03\0\x03\0\x02\0\
    \x03\x12\x04\xec\x0245\n\x10\n\x08\x04\x16\x03\0\x03\0\x02\x01\x12\x04\
    \xed\x02\x189\n\x11\n\t\x04\x16\x03\0\x03\0\x02\x01\x04\x12\x04\xed\x02\
    \x18\x20\n\x11\n\t\x04\x16\x03\0\x03\0\x02\x01\x05\x12\x04\xed\x02!'\n\
    \x11\n\t\x04\x16\x03\0\x03\0\x02\x01\x01\x12\x04\xed\x02(4\n\x11\n\t\x04\
    \x16\x03\0\x03\0\x02\x01\x03\x12\x04\xed\x0278\n\x10\n\x06\x04\x16\x03\0\
    \x03\x01\x12\x06\xf0\x02\x10\xf3\x02\x11\n\x0f\n\x07\x04\x16\x03\0\x03\
    \x01\x01\x12\x04\xf0\x02\x18\x1c\n\x10\n\x08\x04\x16\x03\0\x03\x01\x02\0\
    \x12\x04\xf1\x02\x18I\n\x11\n\t\x04\x16\x03\0\x03\x01\x02\0\x04\x12\x04\
    \xf1\x02\x18\x20\n\x11\n\t\x04\x16\x03\0\x03\x01\x02\0\x06\x12\x04\xf1\
    \x02!<\n\x11\n\t\x04\x16\x03\0\x03\x01\x02\0\x01\x12\x04\xf1\x02=D\n\x11\
    \n\t\x04\x16\x03\0\x03\x01\x02\0\x03\x12\x04\xf1\x02GH\n\x10\n\x08\x04\
    \x16\x03\0\x03\x01\x02\x01\x12\x04\xf2\x02\x187\n\x11\n\t\x04\x16\x03\0\
    \x03\x01\x02\x01\x04\x12\x04\xf2\x02\x18\x20\n\x11\n\t\x04\x16\x03\0\x03\
    \x01\x02\x01\x05\x12\x04\xf2\x02!'\n\x11\n\t\x04\x16\x03\0\x03\x01\x02\
    \x01\x01\x12\x04\xf2\x02(2\n\x11\n\t\x04\x16\x03\0\x03\x01\x02\x01\x03\
    \x12\x04\xf2\x0256\n\x10\n\x06\x04\x16\x03\0\x03\x02\x12\x06\xf5\x02\x10\
    \xf8\x02\x11\n\x0f\n\x07\x04\x16\x03\0\x03\x02\x01\x12\x04\xf5\x02\x18\
    \x1c\n\x10\n\x08\x04\x16\x03\0\x03\x02\x02\0\x12\x04\xf6\x02\x18;\n\x11\
    \n\t\x04\x16\x03\0\x03\x02\x02\0\x04\x12\x04\xf6\x02\x18\x20\n\x11\n\t\
    \x04\x16\x03\0\x03\x02\x02\0\x05\x12\x04\xf6\x02!&\n\x11\n\t\x04\x16\x03\
    \0\x03\x02\x02\0\x01\x12\x04\xf6\x02'6\n\x11\n\t\x04\x16\x03\0\x03\x02\
    \x02\0\x03\x12\x04\xf6\x029:\n\x10\n\x08\x04\x16\x03\0\x03\x02\x02\x01\
    \x12\x04\xf7\x02\x184\n\x11\n\t\x04\x16\x03\0\x03\x02\x02\x01\x04\x12\
    \x04\xf7\x02\x18\x20\n\x11\n\t\x04\x16\x03\0\x03\x02\x02\x01\x05\x12\x04\
    \xf7\x02!'\n\x11\n\t\x04\x16\x03\0\x03\x02\x02\x01\x01\x12\x04\xf7\x02(/\
    \n\x11\n\t\x04\x16\x03\0\x03\x02\x02\x01\x03\x12\x04\xf7\x0223\n\x10\n\
    \x06\x04\x16\x03\0\x03\x03\x12\x06\xfa\x02\x10\xfe\x02\x11\n\x0f\n\x07\
    \x04\x16\x03\0\x03\x03\x01\x12\x04\xfa\x02\x18\x1c\n\x10\n\x08\x04\x16\
    \x03\0\x03\x03\x02\0\x12\x04\xfb\x02\x184\n\x11\n\t\x04\x16\x03\0\x03\
    \x03\x02\0\x04\x12\x04\xfb\x02\x18\x20\n\x11\n\t\x04\x16\x03\0\x03\x03\
    \x02\0\x05\x12\x04\xfb\x02!'\n\x11\n\t\x04\x16\x03\0\x03\x03\x02\0\x01\
    \x12\x04\xfb\x02(/\n\x11\n\t\x04\x16\x03\0\x03\x03\x02\0\x03\x12\x04\xfb\
    \x0223\n\x10\n\x08\x04\x16\x03\0\x03\x03\x02\x01\x12\x04\xfc\x02\x186\n\
    \x11\n\t\x04\x16\x03\0\x03\x03\x02\x01\x04\x12\x04\xfc\x02\x18\x20\n\x11\
    \n\t\x04\x16\x03\0\x03\x03\x02\x01\x05\x12\x04\xfc\x02!'\n\x11\n\t\x04\
    \x16\x03\0\x03\x03\x02\x01\x01\x12\x04\xfc\x02(1\n\x11\n\t\x04\x16\x03\0\
    \x03\x03\x02\x01\x03\x12\x04\xfc\x0245\n\x10\n\x08\x04\x16\x03\0\x03\x03\
    \x02\x02\x12\x04\xfd\x02\x188\n\x11\n\t\x04\x16\x03\0\x03\x03\x02\x02\
    \x04\x12\x04\xfd\x02\x18\x20\n\x11\n\t\x04\x16\x03\0\x03\x03\x02\x02\x05\
    \x12\x04\xfd\x02!'\n\x11\n\t\x04\x16\x03\0\x03\x03\x02\x02\x01\x12\x04\
    \xfd\x02(3\n\x11\n\t\x04\x16\x03\0\x03\x03\x02\x02\x03\x12\x04\xfd\x0267\
    \n\x10\n\x06\x04\x16\x03\0\x03\x04\x12\x06\x80\x03\x10\x82\x03\x11\n\x0f\
    \n\x07\x04\x16\x03\0\x03\x04\x01\x12\x04\x80\x03\x18\x20\n\x10\n\x08\x04\
    \x16\x03\0\x03\x04\x02\0\x12\x04\x81\x03\x188\n\x11\n\t\x04\x16\x03\0\
    \x03\x04\x02\0\x04\x12\x04\x81\x03\x18\x20\n\x11\n\t\x04\x16\x03\0\x03\
    \x04\x02\0\x05\x12\x04\x81\x03!'\n\x11\n\t\x04\x16\x03\0\x03\x04\x02\0\
    \x01\x12\x04\x81\x03(3\n\x11\n\t\x04\x16\x03\0\x03\x04\x02\0\x03\x12\x04\
    \x81\x0367\n\x10\n\x06\x04\x16\x03\0\x03\x05\x12\x06\x84\x03\x10\x86\x03\
    \x11\n\x0f\n\x07\x04\x16\x03\0\x03\x05\x01\x12\x04\x84\x03\x18\x1c\n\x10\
    \n\x08\x04\x16\x03\0\x03\x05\x02\0\x12\x04\x85\x03\x184\n\x11\n\t\x04\
    \x16\x03\0\x03\x05\x02\0\x04\x12\x04\x85\x03\x18\x20\n\x11\n\t\x04\x16\
    \x03\0\x03\x05\x02\0\x05\x12\x04\x85\x03!'\n\x11\n\t\x04\x16\x03\0\x03\
    \x05\x02\0\x01\x12\x04\x85\x03(/\n\x11\n\t\x04\x16\x03\0\x03\x05\x02\0\
    \x03\x12\x04\x85\x0323\n\x0e\n\x06\x04\x16\x03\0\x02\0\x12\x04\x88\x03\
    \x10,\n\x0f\n\x07\x04\x16\x03\0\x02\0\x04\x12\x04\x88\x03\x10\x18\n\x0f\
    \n\x07\x04\x16\x03\0\x02\0\x05\x12\x04\x88\x03\x19\x1f\n\x0f\n\x07\x04\
    \x16\x03\0\x02\0\x01\x12\x04\x88\x03\x20'\n\x0f\n\x07\x04\x16\x03\0\x02\
    \0\x03\x12\x04\x88\x03*+\n\x0e\n\x06\x04\x16\x03\0\x02\x01\x12\x04\x89\
    \x03\x10D\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x04\x12\x04\x89\x03\x10\x18\
    \n\x0f\n\x07\x04\x16\x03\0\x02\x01\x06\x12\x04\x89\x03\x198\n\x0f\n\x07\
    \x04\x16\x03\0\x02\x01\x01\x12\x04\x89\x039?\n\x0f\n\x07\x04\x16\x03\0\
    \x02\x01\x03\x12\x04\x89\x03BC\n\x0e\n\x06\x04\x16\x03\0\x02\x02\x12\x04\
    \x8a\x03\x10@\n\x0f\n\x07\x04\x16\x03\0\x02\x02\x04\x12\x04\x8a\x03\x10\
    \x18\n\x0f\n\x07\x04\x16\x03\0\x02\x02\x06\x12\x04\x8a\x03\x196\n\x0f\n\
    \x07\x04\x16\x03\0\x02\x02\x01\x12\x04\x8a\x037;\n\x0f\n\x07\x04\x16\x03\
    \0\x02\x02\x03\x12\x04\x8a\x03>?\n\x0e\n\x06\x04\x16\x03\0\x02\x03\x12\
    \x04\x8b\x03\x10@\n\x0f\n\x07\x04\x16\x03\0\x02\x03\x04\x12\x04\x8b\x03\
    \x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\x03\x06\x12\x04\x8b\x03\x196\n\
    \x0f\n\x07\x04\x16\x03\0\x02\x03\x01\x12\x04\x8b\x037;\n\x0f\n\x07\x04\
    \x16\x03\0\x02\x03\x03\x12\x04\x8b\x03>?\n\x0e\n\x06\x04\x16\x03\0\x02\
    \x04\x12\x04\x8c\x03\x10@\n\x0f\n\x07\x04\x16\x03\0\x02\x04\x04\x12\x04\
    \x8c\x03\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\x04\x06\x12\x04\x8c\x03\
    \x196\n\x0f\n\x07\x04\x16\x03\0\x02\x04\x01\x12\x04\x8c\x037;\n\x0f\n\
    \x07\x04\x16\x03\0\x02\x04\x03\x12\x04\x8c\x03>?\n\x0e\n\x06\x04\x16\x03\
    \0\x02\x05\x12\x04\x8d\x03\x10H\n\x0f\n\x07\x04\x16\x03\0\x02\x05\x04\
    \x12\x04\x8d\x03\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\x05\x06\x12\x04\
    \x8d\x03\x19:\n\x0f\n\x07\x04\x16\x03\0\x02\x05\x01\x12\x04\x8d\x03;C\n\
    \x0f\n\x07\x04\x16\x03\0\x02\x05\x03\x12\x04\x8d\x03FG\n\x0e\n\x06\x04\
    \x16\x03\0\x02\x06\x12\x04\x8e\x03\x10@\n\x0f\n\x07\x04\x16\x03\0\x02\
    \x06\x04\x12\x04\x8e\x03\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\x06\x06\
    \x12\x04\x8e\x03\x196\n\x0f\n\x07\x04\x16\x03\0\x02\x06\x01\x12\x04\x8e\
    \x037;\n\x0f\n\x07\x04\x16\x03\0\x02\x06\x03\x12\x04\x8e\x03>?\n\x0e\n\
    \x04\x04\x16\x04\0\x12\x06\x91\x03\x08\x98\x03\t\n\r\n\x05\x04\x16\x04\0\
    \x01\x12\x04\x91\x03\r\x14\n\x0e\n\x06\x04\x16\x04\0\x02\0\x12\x04\x92\
    \x03\x10!\n\x0f\n\x07\x04\x16\x04\0\x02\0\x01\x12\x04\x92\x03\x10\x1c\n\
    \x0f\n\x07\x04\x16\x04\0\x02\0\x02\x12\x04\x92\x03\x1f\x20\n\x0e\n\x06\
    \x04\x16\x04\0\x02\x01\x12\x04\x93\x03\x10%\n\x0f\n\x07\x04\x16\x04\0\
    \x02\x01\x01\x12\x04\x93\x03\x10\x20\n\x0f\n\x07\x04\x16\x04\0\x02\x01\
    \x02\x12\x04\x93\x03#$\n\x0e\n\x06\x04\x16\x04\0\x02\x02\x12\x04\x94\x03\
    \x10(\n\x0f\n\x07\x04\x16\x04\0\x02\x02\x01\x12\x04\x94\x03\x10#\n\x0f\n\
    \x07\x04\x16\x04\0\x02\x02\x02\x12\x04\x94\x03&'\n\x0e\n\x06\x04\x16\x04\
    \0\x02\x03\x12\x04\x95\x03\x10+\n\x0f\n\x07\x04\x16\x04\0\x02\x03\x01\
    \x12\x04\x95\x03\x10&\n\x0f\n\x07\x04\x16\x04\0\x02\x03\x02\x12\x04\x95\
    \x03)*\n\x0e\n\x06\x04\x16\x04\0\x02\x04\x12\x04\x96\x03\x10/\n\x0f\n\
    \x07\x04\x16\x04\0\x02\x04\x01\x12\x04\x96\x03\x10*\n\x0f\n\x07\x04\x16\
    \x04\0\x02\x04\x02\x12\x04\x96\x03-.\n\x0e\n\x06\x04\x16\x04\0\x02\x05\
    \x12\x04\x97\x03\x10%\n\x0f\n\x07\x04\x16\x04\0\x02\x05\x01\x12\x04\x97\
    \x03\x10\x20\n\x0f\n\x07\x04\x16\x04\0\x02\x05\x02\x12\x04\x97\x03#$\n\
    \x0c\n\x04\x04\x16\x02\0\x12\x04\x9a\x03\x08'\n\r\n\x05\x04\x16\x02\0\
    \x04\x12\x04\x9a\x03\x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x9a\x03\
    \x11\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x9a\x03\x18\"\n\r\n\x05\x04\
    \x16\x02\0\x03\x12\x04\x9a\x03%&\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x9b\
    \x03\x084\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\x9b\x03\x08\x10\n\r\n\
    \x05\x04\x16\x02\x01\x06\x12\x04\x9b\x03\x11)\n\r\n\x05\x04\x16\x02\x01\
    \x01\x12\x04\x9b\x03*/\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x9b\x0323\n\
    \x0c\n\x04\x04\x16\x02\x02\x12\x04\x9c\x03\x08)\n\r\n\x05\x04\x16\x02\
    \x02\x04\x12\x04\x9c\x03\x08\x10\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\
    \x9c\x03\x11\x17\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\x9c\x03\x18$\n\r\
    \n\x05\x04\x16\x02\x02\x03\x12\x04\x9c\x03'(\n\x0c\n\x04\x04\x16\x02\x03\
    \x12\x04\x9d\x03\x08)\n\r\n\x05\x04\x16\x02\x03\x04\x12\x04\x9d\x03\x08\
    \x10\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\x9d\x03\x11\x17\n\r\n\x05\x04\
    \x16\x02\x03\x01\x12\x04\x9d\x03\x18$\n\r\n\x05\x04\x16\x02\x03\x03\x12\
    \x04\x9d\x03'(\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\x9e\x03\x08%\n\r\n\
    \x05\x04\x16\x02\x04\x04\x12\x04\x9e\x03\x08\x10\n\r\n\x05\x04\x16\x02\
    \x04\x05\x12\x04\x9e\x03\x11\x17\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\
    \x9e\x03\x18\x20\n\r\n\x05\x04\x16\x02\x04\x03\x12\x04\x9e\x03#$\n\x0c\n\
    \x04\x04\x16\x02\x05\x12\x04\x9f\x03\x08D\n\r\n\x05\x04\x16\x02\x05\x04\
    \x12\x04\x9f\x03\x08\x10\n\r\n\x05\x04\x16\x02\x05\x06\x12\x04\x9f\x03\
    \x11%\n\r\n\x05\x04\x16\x02\x05\x01\x12\x04\x9f\x03&?\n\r\n\x05\x04\x16\
    \x02\x05\x03\x12\x04\x9f\x03BC\n\x0c\n\x04\x04\x16\x02\x06\x12\x04\xa0\
    \x03\x08&\n\r\n\x05\x04\x16\x02\x06\x04\x12\x04\xa0\x03\x08\x10\n\r\n\
    \x05\x04\x16\x02\x06\x05\x12\x04\xa0\x03\x11\x17\n\r\n\x05\x04\x16\x02\
    \x06\x01\x12\x04\xa0\x03\x18!\n\r\n\x05\x04\x16\x02\x06\x03\x12\x04\xa0\
    \x03$%\n\x0c\n\x04\x04\x16\x02\x07\x12\x04\xa1\x03\x08-\n\r\n\x05\x04\
    \x16\x02\x07\x04\x12\x04\xa1\x03\x08\x10\n\r\n\x05\x04\x16\x02\x07\x05\
    \x12\x04\xa1\x03\x11\x17\n\r\n\x05\x04\x16\x02\x07\x01\x12\x04\xa1\x03\
    \x18(\n\r\n\x05\x04\x16\x02\x07\x03\x12\x04\xa1\x03+,\n\x0c\n\x04\x04\
    \x16\x02\x08\x12\x04\xa2\x03\x08.\n\r\n\x05\x04\x16\x02\x08\x04\x12\x04\
    \xa2\x03\x08\x10\n\r\n\x05\x04\x16\x02\x08\x05\x12\x04\xa2\x03\x11\x15\n\
    \r\n\x05\x04\x16\x02\x08\x01\x12\x04\xa2\x03\x16(\n\r\n\x05\x04\x16\x02\
    \x08\x03\x12\x04\xa2\x03+-\n\x0c\n\x04\x04\x16\x02\t\x12\x04\xa3\x03\x08\
    6\n\r\n\x05\x04\x16\x02\t\x04\x12\x04\xa3\x03\x08\x10\n\r\n\x05\x04\x16\
    \x02\t\x05\x12\x04\xa3\x03\x11\x17\n\r\n\x05\x04\x16\x02\t\x01\x12\x04\
    \xa3\x03\x180\n\r\n\x05\x04\x16\x02\t\x03\x12\x04\xa3\x0335\n\x0c\n\x04\
    \x04\x16\x02\n\x12\x04\xa4\x03\x08-\n\r\n\x05\x04\x16\x02\n\x04\x12\x04\
    \xa4\x03\x08\x10\n\r\n\x05\x04\x16\x02\n\x05\x12\x04\xa4\x03\x11\x17\n\r\
    \n\x05\x04\x16\x02\n\x01\x12\x04\xa4\x03\x18'\n\r\n\x05\x04\x16\x02\n\
    \x03\x12\x04\xa4\x03*,\n\x0c\n\x04\x04\x16\x02\x0b\x12\x04\xa5\x03\x083\
    \n\r\n\x05\x04\x16\x02\x0b\x04\x12\x04\xa5\x03\x08\x10\n\r\n\x05\x04\x16\
    \x02\x0b\x05\x12\x04\xa5\x03\x11\x17\n\r\n\x05\x04\x16\x02\x0b\x01\x12\
    \x04\xa5\x03\x18-\n\r\n\x05\x04\x16\x02\x0b\x03\x12\x04\xa5\x0302\n\x0c\
    \n\x04\x04\x16\x02\x0c\x12\x04\xa6\x03\x08#\n\r\n\x05\x04\x16\x02\x0c\
    \x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04\x16\x02\x0c\x05\x12\x04\xa6\
    \x03\x11\x17\n\r\n\x05\x04\x16\x02\x0c\x01\x12\x04\xa6\x03\x18\x1d\n\r\n\
    \x05\x04\x16\x02\x0c\x03\x12\x04\xa6\x03\x20\"\n\x0c\n\x04\x04\x16\x02\r\
    \x12\x04\xa7\x03\x082\n\r\n\x05\x04\x16\x02\r\x04\x12\x04\xa7\x03\x08\
    \x10\n\r\n\x05\x04\x16\x02\r\x05\x12\x04\xa7\x03\x11\x17\n\r\n\x05\x04\
    \x16\x02\r\x01\x12\x04\xa7\x03\x18,\n\r\n\x05\x04\x16\x02\r\x03\x12\x04\
    \xa7\x03/1\n\x0c\n\x04\x04\x16\x02\x0e\x12\x04\xa8\x03\x08,\n\r\n\x05\
    \x04\x16\x02\x0e\x04\x12\x04\xa8\x03\x08\x10\n\r\n\x05\x04\x16\x02\x0e\
    \x05\x12\x04\xa8\x03\x11\x17\n\r\n\x05\x04\x16\x02\x0e\x01\x12\x04\xa8\
    \x03\x18&\n\r\n\x05\x04\x16\x02\x0e\x03\x12\x04\xa8\x03)+\n\x0c\n\x02\
    \x04\x17\x12\x06\xab\x03\0\xbd\x03\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\
    \xab\x03\x08\x1e\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xac\x03\x08'\n\r\n\
    \x05\x04\x17\x02\0\x04\x12\x04\xac\x03\x08\x10\n\r\n\x05\x04\x17\x02\0\
    \x05\x12\x04\xac\x03\x11\x17\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xac\x03\
    \x18\"\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xac\x03%&\n\x0c\n\x04\x04\x17\
    \x02\x01\x12\x04\xad\x03\x08%\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xad\
    \x03\x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xad\x03\x11\x17\n\r\n\
    \x05\x04\x17\x02\x01\x01\x12\x04\xad\x03\x18\x20\n\r\n\x05\x04\x17\x02\
    \x01\x03\x12\x04\xad\x03#$\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xae\x03\
    \x08$\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\
    \x04\x17\x02\x02\x05\x12\x04\xae\x03\x11\x17\n\r\n\x05\x04\x17\x02\x02\
    \x01\x12\x04\xae\x03\x18\x1f\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xae\
    \x03\"#\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\xaf\x03\x08(\n\r\n\x05\x04\
    \x17\x02\x03\x04\x12\x04\xaf\x03\x08\x10\n\r\n\x05\x04\x17\x02\x03\x05\
    \x12\x04\xaf\x03\x11\x17\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xaf\x03\
    \x18#\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xaf\x03&'\n\x0c\n\x04\x04\
    \x17\x02\x04\x12\x04\xb0\x03\x08(\n\r\n\x05\x04\x17\x02\x04\x04\x12\x04\
    \xb0\x03\x08\x10\n\r\n\x05\x04\x17\x02\x04\x05\x12\x04\xb0\x03\x11\x17\n\
    \r\n\x05\x04\x17\x02\x04\x01\x12\x04\xb0\x03\x18#\n\r\n\x05\x04\x17\x02\
    \x04\x03\x12\x04\xb0\x03&'\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xb1\x03\
    \x08)\n\r\n\x05\x04\x17\x02\x05\x04\x12\x04\xb1\x03\x08\x10\n\r\n\x05\
    \x04\x17\x02\x05\x05\x12\x04\xb1\x03\x11\x17\n\r\n\x05\x04\x17\x02\x05\
    \x01\x12\x04\xb1\x03\x18$\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\xb1\x03'\
    (\n\x0c\n\x04\x04\x17\x02\x06\x12\x04\xb2\x03\x08&\n\r\n\x05\x04\x17\x02\
    \x06\x04\x12\x04\xb2\x03\x08\x10\n\r\n\x05\x04\x17\x02\x06\x05\x12\x04\
    \xb2\x03\x11\x17\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\xb2\x03\x18!\n\r\
    \n\x05\x04\x17\x02\x06\x03\x12\x04\xb2\x03$%\n\x0c\n\x04\x04\x17\x02\x07\
    \x12\x04\xb3\x03\x08(\n\r\n\x05\x04\x17\x02\x07\x04\x12\x04\xb3\x03\x08\
    \x10\n\r\n\x05\x04\x17\x02\x07\x05\x12\x04\xb3\x03\x11\x17\n\r\n\x05\x04\
    \x17\x02\x07\x01\x12\x04\xb3\x03\x18#\n\r\n\x05\x04\x17\x02\x07\x03\x12\
    \x04\xb3\x03&'\n\x0c\n\x04\x04\x17\x02\x08\x12\x04\xb4\x03\x08,\n\r\n\
    \x05\x04\x17\x02\x08\x04\x12\x04\xb4\x03\x08\x10\n\r\n\x05\x04\x17\x02\
    \x08\x05\x12\x04\xb4\x03\x11\x17\n\r\n\x05\x04\x17\x02\x08\x01\x12\x04\
    \xb4\x03\x18&\n\r\n\x05\x04\x17\x02\x08\x03\x12\x04\xb4\x03)+\n\x0c\n\
    \x04\x04\x17\x02\t\x12\x04\xb5\x03\x08#\n\r\n\x05\x04\x17\x02\t\x04\x12\
    \x04\xb5\x03\x08\x10\n\r\n\x05\x04\x17\x02\t\x05\x12\x04\xb5\x03\x11\x17\
    \n\r\n\x05\x04\x17\x02\t\x01\x12\x04\xb5\x03\x18\x1d\n\r\n\x05\x04\x17\
    \x02\t\x03\x12\x04\xb5\x03\x20\"\n\x0c\n\x04\x04\x17\x02\n\x12\x04\xb6\
    \x03\x08&\n\r\n\x05\x04\x17\x02\n\x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\
    \x04\x17\x02\n\x05\x12\x04\xb6\x03\x11\x17\n\r\n\x05\x04\x17\x02\n\x01\
    \x12\x04\xb6\x03\x18\x20\n\r\n\x05\x04\x17\x02\n\x03\x12\x04\xb6\x03#%\n\
    \x0c\n\x04\x04\x17\x02\x0b\x12\x04\xb7\x03\x08,\n\r\n\x05\x04\x17\x02\
    \x0b\x04\x12\x04\xb7\x03\x08\x10\n\r\n\x05\x04\x17\x02\x0b\x05\x12\x04\
    \xb7\x03\x11\x17\n\r\n\x05\x04\x17\x02\x0b\x01\x12\x04\xb7\x03\x18&\n\r\
    \n\x05\x04\x17\x02\x0b\x03\x12\x04\xb7\x03)+\n\x0c\n\x04\x04\x17\x02\x0c\
    \x12\x04\xb8\x03\x08(\n\r\n\x05\x04\x17\x02\x0c\x04\x12\x04\xb8\x03\x08\
    \x10\n\r\n\x05\x04\x17\x02\x0c\x05\x12\x04\xb8\x03\x11\x17\n\r\n\x05\x04\
    \x17\x02\x0c\x01\x12\x04\xb8\x03\x18\"\n\r\n\x05\x04\x17\x02\x0c\x03\x12\
    \x04\xb8\x03%'\n\x0c\n\x04\x04\x17\x02\r\x12\x04\xb9\x03\x08,\n\r\n\x05\
    \x04\x17\x02\r\x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\x04\x17\x02\r\x05\
    \x12\x04\xb9\x03\x11\x17\n\r\n\x05\x04\x17\x02\r\x01\x12\x04\xb9\x03\x18\
    &\n\r\n\x05\x04\x17\x02\r\x03\x12\x04\xb9\x03)+\n\x0c\n\x04\x04\x17\x02\
    \x0e\x12\x04\xba\x03\x08)\n\r\n\x05\x04\x17\x02\x0e\x04\x12\x04\xba\x03\
    \x08\x10\n\r\n\x05\x04\x17\x02\x0e\x05\x12\x04\xba\x03\x11\x17\n\r\n\x05\
    \x04\x17\x02\x0e\x01\x12\x04\xba\x03\x18#\n\r\n\x05\x04\x17\x02\x0e\x03\
    \x12\x04\xba\x03&(\n\x0c\n\x04\x04\x17\x02\x0f\x12\x04\xbb\x03\x08%\n\r\
    \n\x05\x04\x17\x02\x0f\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x04\x17\x02\
    \x0f\x05\x12\x04\xbb\x03\x11\x17\n\r\n\x05\x04\x17\x02\x0f\x01\x12\x04\
    \xbb\x03\x18\x1f\n\r\n\x05\x04\x17\x02\x0f\x03\x12\x04\xbb\x03\"$\n\x0c\
    \n\x04\x04\x17\x02\x10\x12\x04\xbc\x03\x08)\n\r\n\x05\x04\x17\x02\x10\
    \x04\x12\x04\xbc\x03\x08\x10\n\r\n\x05\x04\x17\x02\x10\x05\x12\x04\xbc\
    \x03\x11\x17\n\r\n\x05\x04\x17\x02\x10\x01\x12\x04\xbc\x03\x18#\n\r\n\
    \x05\x04\x17\x02\x10\x03\x12\x04\xbc\x03&(\n\x0c\n\x02\x04\x18\x12\x06\
    \xbf\x03\0\xc3\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xbf\x03\x08+\n\
    \x0c\n\x04\x04\x18\x02\0\x12\x04\xc0\x03\x08%\n\r\n\x05\x04\x18\x02\0\
    \x04\x12\x04\xc0\x03\x08\x10\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\xc0\x03\
    \x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xc0\x03\x18\x20\n\r\n\x05\
    \x04\x18\x02\0\x03\x12\x04\xc0\x03#$\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\
    \xc1\x03\x08(\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xc1\x03\x08\x10\n\r\
    \n\x05\x04\x18\x02\x01\x05\x12\x04\xc1\x03\x11\x17\n\r\n\x05\x04\x18\x02\
    \x01\x01\x12\x04\xc1\x03\x18#\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xc1\
    \x03&'\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xc2\x03\x08$\n\r\n\x05\x04\
    \x18\x02\x02\x04\x12\x04\xc2\x03\x08\x10\n\r\n\x05\x04\x18\x02\x02\x05\
    \x12\x04\xc2\x03\x11\x17\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xc2\x03\
    \x18\x1f\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xc2\x03\"#\n\x0c\n\x02\
    \x04\x19\x12\x06\xc5\x03\0\xcf\x03\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\
    \xc5\x03\x08+\n\x0e\n\x04\x04\x19\x04\0\x12\x06\xc6\x03\x08\xcc\x03\t\n\
    \r\n\x05\x04\x19\x04\0\x01\x12\x04\xc6\x03\r\x14\n\x0e\n\x06\x04\x19\x04\
    \0\x02\0\x12\x04\xc7\x03\x10$\n\x0f\n\x07\x04\x19\x04\0\x02\0\x01\x12\
    \x04\xc7\x03\x10\x1f\n\x0f\n\x07\x04\x19\x04\0\x02\0\x02\x12\x04\xc7\x03\
    \"#\n\x0e\n\x06\x04\x19\x04\0\x02\x01\x12\x04\xc8\x03\x10$\n\x0f\n\x07\
    \x04\x19\x04\0\x02\x01\x01\x12\x04\xc8\x03\x10\x1f\n\x0f\n\x07\x04\x19\
    \x04\0\x02\x01\x02\x12\x04\xc8\x03\"#\n\x0e\n\x06\x04\x19\x04\0\x02\x02\
    \x12\x04\xc9\x03\x10%\n\x0f\n\x07\x04\x19\x04\0\x02\x02\x01\x12\x04\xc9\
    \x03\x10\x20\n\x0f\n\x07\x04\x19\x04\0\x02\x02\x02\x12\x04\xc9\x03#$\n\
    \x0e\n\x06\x04\x19\x04\0\x02\x03\x12\x04\xca\x03\x10'\n\x0f\n\x07\x04\
    \x19\x04\0\x02\x03\x01\x12\x04\xca\x03\x10\"\n\x0f\n\x07\x04\x19\x04\0\
    \x02\x03\x02\x12\x04\xca\x03%&\n\x0e\n\x06\x04\x19\x04\0\x02\x04\x12\x04\
    \xcb\x03\x10(\n\x0f\n\x07\x04\x19\x04\0\x02\x04\x01\x12\x04\xcb\x03\x10#\
    \n\x0f\n\x07\x04\x19\x04\0\x02\x04\x02\x12\x04\xcb\x03&'\n\x0c\n\x04\x04\
    \x19\x02\0\x12\x04\xce\x03\x08H\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xce\
    \x03\x08\x10\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xce\x03\x11<\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xce\x03=C\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \xce\x03FG\n\x0c\n\x02\x04\x1a\x12\x06\xd1\x03\0\xd4\x03\x01\n\x0b\n\x03\
    \x04\x1a\x01\x12\x04\xd1\x03\x08\x20\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\
    \xd2\x03\x08-\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xd2\x03\x08\x10\n\r\n\
    \x05\x04\x1a\x02\0\x05\x12\x04\xd2\x03\x11\x17\n\r\n\x05\x04\x1a\x02\0\
    \x01\x12\x04\xd2\x03\x18(\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd2\x03+,\
    \n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xd3\x03\x08,\n\r\n\x05\x04\x1a\x02\
    \x01\x04\x12\x04\xd3\x03\x08\x10\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\
    \xd3\x03\x11\x17\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xd3\x03\x18'\n\r\
    \n\x05\x04\x1a\x02\x01\x03\x12\x04\xd3\x03*+\n\x0c\n\x02\x04\x1b\x12\x06\
    \xd6\x03\0\x8a\x05\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xd6\x03\x08!\n\
    \x0e\n\x04\x04\x1b\x03\0\x12\x06\xd7\x03\x08\xe3\x03\t\n\r\n\x05\x04\x1b\
    \x03\0\x01\x12\x04\xd7\x03\x10\x1b\n\x0e\n\x06\x04\x1b\x03\0\x02\0\x12\
    \x04\xd8\x03\x100\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x04\x12\x04\xd8\x03\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x05\x12\x04\xd8\x03\x19\x1f\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\0\x01\x12\x04\xd8\x03\x20+\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\0\x03\x12\x04\xd8\x03./\n\x0e\n\x06\x04\x1b\x03\0\x02\x01\
    \x12\x04\xd9\x03\x10,\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x04\x12\x04\xd9\
    \x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x05\x12\x04\xd9\x03\x19\
    \x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x01\x12\x04\xd9\x03\x20'\n\x0f\n\
    \x07\x04\x1b\x03\0\x02\x01\x03\x12\x04\xd9\x03*+\n\x0e\n\x06\x04\x1b\x03\
    \0\x02\x02\x12\x04\xda\x03\x10.\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x04\
    \x12\x04\xda\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x05\x12\x04\
    \xda\x03\x19\x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x01\x12\x04\xda\x03\
    \x20)\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x03\x12\x04\xda\x03,-\n\x0e\n\
    \x06\x04\x1b\x03\0\x02\x03\x12\x04\xdb\x03\x10/\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\x03\x04\x12\x04\xdb\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\
    \x05\x12\x04\xdb\x03\x19\x20\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x01\x12\
    \x04\xdb\x03!*\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x03\x12\x04\xdb\x03-.\n\
    \x0e\n\x06\x04\x1b\x03\0\x02\x04\x12\x04\xdc\x03\x10.\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x04\x04\x12\x04\xdc\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x04\x05\x12\x04\xdc\x03\x19\x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\x04\
    \x01\x12\x04\xdc\x03\x20(\n\x0f\n\x07\x04\x1b\x03\0\x02\x04\x03\x12\x04\
    \xdc\x03+-\n\x0e\n\x06\x04\x1b\x03\0\x02\x05\x12\x04\xdd\x03\x10*\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\x05\x04\x12\x04\xdd\x03\x10\x18\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x05\x05\x12\x04\xdd\x03\x19\x1f\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x05\x01\x12\x04\xdd\x03\x20%\n\x0f\n\x07\x04\x1b\x03\0\x02\x05\x03\
    \x12\x04\xdd\x03()\n\x0e\n\x06\x04\x1b\x03\0\x02\x06\x12\x04\xde\x03\x10\
    .\n\x0f\n\x07\x04\x1b\x03\0\x02\x06\x04\x12\x04\xde\x03\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\0\x02\x06\x05\x12\x04\xde\x03\x19\x1f\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x06\x01\x12\x04\xde\x03\x20)\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x06\x03\x12\x04\xde\x03,-\n\x0e\n\x06\x04\x1b\x03\0\x02\x07\x12\x04\
    \xdf\x03\x10M\n\x0f\n\x07\x04\x1b\x03\0\x02\x07\x04\x12\x04\xdf\x03\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x07\x06\x12\x04\xdf\x03\x19@\n\x0f\n\
    \x07\x04\x1b\x03\0\x02\x07\x01\x12\x04\xdf\x03AH\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\x07\x03\x12\x04\xdf\x03KL\n\x0e\n\x06\x04\x1b\x03\0\x02\x08\x12\
    \x04\xe0\x03\x10,\n\x0f\n\x07\x04\x1b\x03\0\x02\x08\x04\x12\x04\xe0\x03\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x08\x05\x12\x04\xe0\x03\x19\x1d\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\x08\x01\x12\x04\xe0\x03\x1e'\n\x0f\n\x07\
    \x04\x1b\x03\0\x02\x08\x03\x12\x04\xe0\x03*+\n\x0e\n\x06\x04\x1b\x03\0\
    \x02\t\x12\x04\xe1\x03\x10+\n\x0f\n\x07\x04\x1b\x03\0\x02\t\x04\x12\x04\
    \xe1\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\t\x05\x12\x04\xe1\x03\x19\
    \x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\t\x01\x12\x04\xe1\x03\x20&\n\x0f\n\
    \x07\x04\x1b\x03\0\x02\t\x03\x12\x04\xe1\x03)*\n\x0e\n\x06\x04\x1b\x03\0\
    \x02\n\x12\x04\xe2\x03\x103\n\x0f\n\x07\x04\x1b\x03\0\x02\n\x04\x12\x04\
    \xe2\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\n\x05\x12\x04\xe2\x03\x19\
    \x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\n\x01\x12\x04\xe2\x03\x20-\n\x0f\n\
    \x07\x04\x1b\x03\0\x02\n\x03\x12\x04\xe2\x0302\n\x0e\n\x04\x04\x1b\x03\
    \x01\x12\x06\xe5\x03\x08\xeb\x03\t\n\r\n\x05\x04\x1b\x03\x01\x01\x12\x04\
    \xe5\x03\x10\x1b\n\x0e\n\x06\x04\x1b\x03\x01\x02\0\x12\x04\xe6\x03\x103\
    \n\x0f\n\x07\x04\x1b\x03\x01\x02\0\x04\x12\x04\xe6\x03\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\x01\x02\0\x05\x12\x04\xe6\x03\x19\x1e\n\x0f\n\x07\x04\
    \x1b\x03\x01\x02\0\x01\x12\x04\xe6\x03\x1f.\n\x0f\n\x07\x04\x1b\x03\x01\
    \x02\0\x03\x12\x04\xe6\x0312\n\x0e\n\x06\x04\x1b\x03\x01\x02\x01\x12\x04\
    \xe7\x03\x10)\n\x0f\n\x07\x04\x1b\x03\x01\x02\x01\x04\x12\x04\xe7\x03\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\x01\x02\x01\x05\x12\x04\xe7\x03\x19\x1f\
    \n\x0f\n\x07\x04\x1b\x03\x01\x02\x01\x01\x12\x04\xe7\x03\x20$\n\x0f\n\
    \x07\x04\x1b\x03\x01\x02\x01\x03\x12\x04\xe7\x03'(\n\x0e\n\x06\x04\x1b\
    \x03\x01\x02\x02\x12\x04\xe8\x03\x10(\n\x0f\n\x07\x04\x1b\x03\x01\x02\
    \x02\x04\x12\x04\xe8\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\x01\x02\x02\x05\
    \x12\x04\xe8\x03\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x01\x02\x02\x01\x12\x04\
    \xe8\x03\x1f#\n\x0f\n\x07\x04\x1b\x03\x01\x02\x02\x03\x12\x04\xe8\x03&'\
    \n\x0e\n\x06\x04\x1b\x03\x01\x02\x03\x12\x04\xe9\x03\x10'\n\x0f\n\x07\
    \x04\x1b\x03\x01\x02\x03\x04\x12\x04\xe9\x03\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x01\x02\x03\x05\x12\x04\xe9\x03\x19\x1d\n\x0f\n\x07\x04\x1b\x03\x01\
    \x02\x03\x01\x12\x04\xe9\x03\x1e\"\n\x0f\n\x07\x04\x1b\x03\x01\x02\x03\
    \x03\x12\x04\xe9\x03%&\n\x0e\n\x06\x04\x1b\x03\x01\x02\x04\x12\x04\xea\
    \x03\x10/\n\x0f\n\x07\x04\x1b\x03\x01\x02\x04\x04\x12\x04\xea\x03\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\x01\x02\x04\x05\x12\x04\xea\x03\x19\x1f\n\
    \x0f\n\x07\x04\x1b\x03\x01\x02\x04\x01\x12\x04\xea\x03\x20*\n\x0f\n\x07\
    \x04\x1b\x03\x01\x02\x04\x03\x12\x04\xea\x03-.\n\x0e\n\x04\x04\x1b\x03\
    \x02\x12\x06\xed\x03\x08\xf3\x03\t\n\r\n\x05\x04\x1b\x03\x02\x01\x12\x04\
    \xed\x03\x10\x1e\n\x0e\n\x06\x04\x1b\x03\x02\x02\0\x12\x04\xee\x03\x10&\
    \n\x0f\n\x07\x04\x1b\x03\x02\x02\0\x04\x12\x04\xee\x03\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\x02\x02\0\x05\x12\x04\xee\x03\x19\x1e\n\x0f\n\x07\x04\
    \x1b\x03\x02\x02\0\x01\x12\x04\xee\x03\x1f!\n\x0f\n\x07\x04\x1b\x03\x02\
    \x02\0\x03\x12\x04\xee\x03$%\n\x0e\n\x06\x04\x1b\x03\x02\x02\x01\x12\x04\
    \xef\x03\x10)\n\x0f\n\x07\x04\x1b\x03\x02\x02\x01\x04\x12\x04\xef\x03\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\x02\x02\x01\x05\x12\x04\xef\x03\x19\x1f\
    \n\x0f\n\x07\x04\x1b\x03\x02\x02\x01\x01\x12\x04\xef\x03\x20$\n\x0f\n\
    \x07\x04\x1b\x03\x02\x02\x01\x03\x12\x04\xef\x03'(\n\x0e\n\x06\x04\x1b\
    \x03\x02\x02\x02\x12\x04\xf0\x03\x10*\n\x0f\n\x07\x04\x1b\x03\x02\x02\
    \x02\x04\x12\x04\xf0\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\x02\x02\x02\x05\
    \x12\x04\xf0\x03\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x02\x02\x02\x01\x12\x04\
    \xf0\x03\x20%\n\x0f\n\x07\x04\x1b\x03\x02\x02\x02\x03\x12\x04\xf0\x03()\
    \n\x0e\n\x06\x04\x1b\x03\x02\x02\x03\x12\x04\xf1\x03\x10,\n\x0f\n\x07\
    \x04\x1b\x03\x02\x02\x03\x04\x12\x04\xf1\x03\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x02\x02\x03\x05\x12\x04\xf1\x03\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x02\
    \x02\x03\x01\x12\x04\xf1\x03\x1f'\n\x0f\n\x07\x04\x1b\x03\x02\x02\x03\
    \x03\x12\x04\xf1\x03*+\n\x0e\n\x06\x04\x1b\x03\x02\x02\x04\x12\x04\xf2\
    \x03\x100\n\x0f\n\x07\x04\x1b\x03\x02\x02\x04\x04\x12\x04\xf2\x03\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\x02\x02\x04\x05\x12\x04\xf2\x03\x19\x1e\n\
    \x0f\n\x07\x04\x1b\x03\x02\x02\x04\x01\x12\x04\xf2\x03\x1f+\n\x0f\n\x07\
    \x04\x1b\x03\x02\x02\x04\x03\x12\x04\xf2\x03./\n\x0e\n\x04\x04\x1b\x03\
    \x03\x12\x06\xf5\x03\x08\xf9\x03\t\n\r\n\x05\x04\x1b\x03\x03\x01\x12\x04\
    \xf5\x03\x10\x1f\n\x0e\n\x06\x04\x1b\x03\x03\x02\0\x12\x04\xf6\x03\x10,\
    \n\x0f\n\x07\x04\x1b\x03\x03\x02\0\x04\x12\x04\xf6\x03\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\x03\x02\0\x05\x12\x04\xf6\x03\x19\x1e\n\x0f\n\x07\x04\
    \x1b\x03\x03\x02\0\x01\x12\x04\xf6\x03\x1f'\n\x0f\n\x07\x04\x1b\x03\x03\
    \x02\0\x03\x12\x04\xf6\x03*+\n\x0e\n\x06\x04\x1b\x03\x03\x02\x01\x12\x04\
    \xf7\x03\x10*\n\x0f\n\x07\x04\x1b\x03\x03\x02\x01\x04\x12\x04\xf7\x03\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\x03\x02\x01\x05\x12\x04\xf7\x03\x19\x1f\
    \n\x0f\n\x07\x04\x1b\x03\x03\x02\x01\x01\x12\x04\xf7\x03\x20%\n\x0f\n\
    \x07\x04\x1b\x03\x03\x02\x01\x03\x12\x04\xf7\x03()\n\x0e\n\x06\x04\x1b\
    \x03\x03\x02\x02\x12\x04\xf8\x03\x10,\n\x0f\n\x07\x04\x1b\x03\x03\x02\
    \x02\x04\x12\x04\xf8\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\x03\x02\x02\x05\
    \x12\x04\xf8\x03\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x03\x02\x02\x01\x12\x04\
    \xf8\x03\x20'\n\x0f\n\x07\x04\x1b\x03\x03\x02\x02\x03\x12\x04\xf8\x03*+\
    \n\x0e\n\x04\x04\x1b\x03\x04\x12\x06\xfb\x03\x08\xfd\x03\t\n\r\n\x05\x04\
    \x1b\x03\x04\x01\x12\x04\xfb\x03\x10\x1b\n\x0e\n\x06\x04\x1b\x03\x04\x02\
    \0\x12\x04\xfc\x03\x10&\n\x0f\n\x07\x04\x1b\x03\x04\x02\0\x04\x12\x04\
    \xfc\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\x04\x02\0\x05\x12\x04\xfc\x03\
    \x19\x1e\n\x0f\n\x07\x04\x1b\x03\x04\x02\0\x01\x12\x04\xfc\x03\x1f!\n\
    \x0f\n\x07\x04\x1b\x03\x04\x02\0\x03\x12\x04\xfc\x03$%\n\x0e\n\x04\x04\
    \x1b\x03\x05\x12\x06\xff\x03\x08\xb1\x04\t\n\r\n\x05\x04\x1b\x03\x05\x01\
    \x12\x04\xff\x03\x10\x1d\n\x0e\n\x06\x04\x1b\x03\x05\x02\0\x12\x04\x80\
    \x04\x10.\n\x0f\n\x07\x04\x1b\x03\x05\x02\0\x04\x12\x04\x80\x04\x10\x18\
    \n\x0f\n\x07\x04\x1b\x03\x05\x02\0\x05\x12\x04\x80\x04\x19\x1f\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\0\x01\x12\x04\x80\x04\x20)\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02\0\x03\x12\x04\x80\x04,-\n\x0e\n\x06\x04\x1b\x03\x05\x02\x01\
    \x12\x04\x81\x04\x10,\n\x0f\n\x07\x04\x1b\x03\x05\x02\x01\x04\x12\x04\
    \x81\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x01\x05\x12\x04\x81\x04\
    \x19\x1e\n\x0f\n\x07\x04\x1b\x03\x05\x02\x01\x01\x12\x04\x81\x04\x1f'\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02\x01\x03\x12\x04\x81\x04*+\n\x0e\n\x06\x04\
    \x1b\x03\x05\x02\x02\x12\x04\x82\x04\x10)\n\x0f\n\x07\x04\x1b\x03\x05\
    \x02\x02\x04\x12\x04\x82\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x02\
    \x05\x12\x04\x82\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x02\x01\x12\
    \x04\x82\x04\x20$\n\x0f\n\x07\x04\x1b\x03\x05\x02\x02\x03\x12\x04\x82\
    \x04'(\n\x0e\n\x06\x04\x1b\x03\x05\x02\x03\x12\x04\x83\x04\x10)\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\x03\x04\x12\x04\x83\x04\x10\x18\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\x03\x05\x12\x04\x83\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\x03\x01\x12\x04\x83\x04\x20$\n\x0f\n\x07\x04\x1b\x03\x05\x02\
    \x03\x03\x12\x04\x83\x04'(\n\x0e\n\x06\x04\x1b\x03\x05\x02\x04\x12\x04\
    \x84\x04\x10+\n\x0f\n\x07\x04\x1b\x03\x05\x02\x04\x04\x12\x04\x84\x04\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x04\x05\x12\x04\x84\x04\x19\x1f\
    \n\x0f\n\x07\x04\x1b\x03\x05\x02\x04\x01\x12\x04\x84\x04\x20&\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\x04\x03\x12\x04\x84\x04)*\n\x0e\n\x06\x04\x1b\
    \x03\x05\x02\x05\x12\x04\x85\x04\x101\n\x0f\n\x07\x04\x1b\x03\x05\x02\
    \x05\x04\x12\x04\x85\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x05\x05\
    \x12\x04\x85\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x05\x01\x12\x04\
    \x85\x04\x20,\n\x0f\n\x07\x04\x1b\x03\x05\x02\x05\x03\x12\x04\x85\x04/0\
    \n\x0e\n\x06\x04\x1b\x03\x05\x02\x06\x12\x04\x86\x04\x104\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02\x06\x04\x12\x04\x86\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02\x06\x05\x12\x04\x86\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\
    \x02\x06\x01\x12\x04\x86\x04\x20/\n\x0f\n\x07\x04\x1b\x03\x05\x02\x06\
    \x03\x12\x04\x86\x0423\n\x0e\n\x06\x04\x1b\x03\x05\x02\x07\x12\x04\x87\
    \x04\x103\n\x0f\n\x07\x04\x1b\x03\x05\x02\x07\x04\x12\x04\x87\x04\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x07\x05\x12\x04\x87\x04\x19\x1e\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02\x07\x01\x12\x04\x87\x04\x1f.\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02\x07\x03\x12\x04\x87\x0412\n\x0e\n\x06\x04\x1b\x03\
    \x05\x02\x08\x12\x04\x88\x04\x10/\n\x0f\n\x07\x04\x1b\x03\x05\x02\x08\
    \x04\x12\x04\x88\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x08\x05\x12\
    \x04\x88\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x08\x01\x12\x04\x88\
    \x04\x20*\n\x0f\n\x07\x04\x1b\x03\x05\x02\x08\x03\x12\x04\x88\x04-.\n\
    \x0e\n\x06\x04\x1b\x03\x05\x02\t\x12\x04\x89\x04\x103\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\t\x04\x12\x04\x89\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\t\x05\x12\x04\x89\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\t\
    \x01\x12\x04\x89\x04\x20-\n\x0f\n\x07\x04\x1b\x03\x05\x02\t\x03\x12\x04\
    \x89\x0402\n\x0e\n\x06\x04\x1b\x03\x05\x02\n\x12\x04\x8a\x04\x102\n\x0f\
    \n\x07\x04\x1b\x03\x05\x02\n\x04\x12\x04\x8a\x04\x10\x18\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\n\x05\x12\x04\x8a\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\n\x01\x12\x04\x8a\x04\x1f,\n\x0f\n\x07\x04\x1b\x03\x05\x02\n\
    \x03\x12\x04\x8a\x04/1\n\x0e\n\x06\x04\x1b\x03\x05\x02\x0b\x12\x04\x8b\
    \x04\x103\n\x0f\n\x07\x04\x1b\x03\x05\x02\x0b\x04\x12\x04\x8b\x04\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x0b\x05\x12\x04\x8b\x04\x19\x1f\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02\x0b\x01\x12\x04\x8b\x04\x20-\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02\x0b\x03\x12\x04\x8b\x0402\n\x0e\n\x06\x04\x1b\x03\
    \x05\x02\x0c\x12\x04\x8c\x04\x102\n\x0f\n\x07\x04\x1b\x03\x05\x02\x0c\
    \x04\x12\x04\x8c\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x0c\x05\x12\
    \x04\x8c\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x0c\x01\x12\x04\x8c\
    \x04\x20,\n\x0f\n\x07\x04\x1b\x03\x05\x02\x0c\x03\x12\x04\x8c\x04/1\n\
    \x0e\n\x06\x04\x1b\x03\x05\x02\r\x12\x04\x8d\x04\x107\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\r\x04\x12\x04\x8d\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\r\x05\x12\x04\x8d\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\r\
    \x01\x12\x04\x8d\x04\x201\n\x0f\n\x07\x04\x1b\x03\x05\x02\r\x03\x12\x04\
    \x8d\x0446\n\x0e\n\x06\x04\x1b\x03\x05\x02\x0e\x12\x04\x8e\x04\x10/\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02\x0e\x04\x12\x04\x8e\x04\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\x0e\x05\x12\x04\x8e\x04\x19\x1e\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\x0e\x01\x12\x04\x8e\x04\x1f)\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\x0e\x03\x12\x04\x8e\x04,.\n\x0e\n\x06\x04\x1b\x03\x05\x02\x0f\
    \x12\x04\x8f\x04\x104\n\x0f\n\x07\x04\x1b\x03\x05\x02\x0f\x04\x12\x04\
    \x8f\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x0f\x05\x12\x04\x8f\x04\
    \x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x0f\x01\x12\x04\x8f\x04\x20.\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02\x0f\x03\x12\x04\x8f\x0413\n\x0e\n\x06\x04\
    \x1b\x03\x05\x02\x10\x12\x04\x90\x04\x101\n\x0f\n\x07\x04\x1b\x03\x05\
    \x02\x10\x04\x12\x04\x90\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x10\
    \x05\x12\x04\x90\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x10\x01\x12\
    \x04\x90\x04\x20+\n\x0f\n\x07\x04\x1b\x03\x05\x02\x10\x03\x12\x04\x90\
    \x04.0\n\x0e\n\x06\x04\x1b\x03\x05\x02\x11\x12\x04\x91\x04\x10.\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\x11\x04\x12\x04\x91\x04\x10\x18\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\x11\x05\x12\x04\x91\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\x11\x01\x12\x04\x91\x04\x20(\n\x0f\n\x07\x04\x1b\x03\x05\x02\
    \x11\x03\x12\x04\x91\x04+-\n\x0e\n\x06\x04\x1b\x03\x05\x02\x12\x12\x04\
    \x92\x04\x10-\n\x0f\n\x07\x04\x1b\x03\x05\x02\x12\x04\x12\x04\x92\x04\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x12\x05\x12\x04\x92\x04\x19\x1f\
    \n\x0f\n\x07\x04\x1b\x03\x05\x02\x12\x01\x12\x04\x92\x04\x20'\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\x12\x03\x12\x04\x92\x04*,\n\x0e\n\x06\x04\x1b\
    \x03\x05\x02\x13\x12\x04\x93\x04\x102\n\x0f\n\x07\x04\x1b\x03\x05\x02\
    \x13\x04\x12\x04\x93\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x13\x05\
    \x12\x04\x93\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x13\x01\x12\x04\
    \x93\x04\x20,\n\x0f\n\x07\x04\x1b\x03\x05\x02\x13\x03\x12\x04\x93\x04/1\
    \n\x0e\n\x06\x04\x1b\x03\x05\x02\x14\x12\x04\x94\x04\x10*\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02\x14\x04\x12\x04\x94\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02\x14\x05\x12\x04\x94\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x05\
    \x02\x14\x01\x12\x04\x94\x04\x1f$\n\x0f\n\x07\x04\x1b\x03\x05\x02\x14\
    \x03\x12\x04\x94\x04')\n\x0e\n\x06\x04\x1b\x03\x05\x02\x15\x12\x04\x95\
    \x04\x10/\n\x0f\n\x07\x04\x1b\x03\x05\x02\x15\x04\x12\x04\x95\x04\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x15\x05\x12\x04\x95\x04\x19\x1f\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02\x15\x01\x12\x04\x95\x04\x20)\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02\x15\x03\x12\x04\x95\x04,.\n\x0e\n\x06\x04\x1b\x03\
    \x05\x02\x16\x12\x04\x96\x04\x10,\n\x0f\n\x07\x04\x1b\x03\x05\x02\x16\
    \x04\x12\x04\x96\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x16\x05\x12\
    \x04\x96\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x16\x01\x12\x04\x96\
    \x04\x20&\n\x0f\n\x07\x04\x1b\x03\x05\x02\x16\x03\x12\x04\x96\x04)+\n\
    \x0e\n\x06\x04\x1b\x03\x05\x02\x17\x12\x04\x97\x04\x101\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\x17\x04\x12\x04\x97\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\x17\x05\x12\x04\x97\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\
    \x17\x01\x12\x04\x97\x04\x20+\n\x0f\n\x07\x04\x1b\x03\x05\x02\x17\x03\
    \x12\x04\x97\x04.0\n\x0e\n\x06\x04\x1b\x03\x05\x02\x18\x12\x04\x98\x04\
    \x102\n\x0f\n\x07\x04\x1b\x03\x05\x02\x18\x04\x12\x04\x98\x04\x10\x18\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02\x18\x05\x12\x04\x98\x04\x19\x1f\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\x18\x01\x12\x04\x98\x04\x20,\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\x18\x03\x12\x04\x98\x04/1\n\x0e\n\x06\x04\x1b\x03\x05\
    \x02\x19\x12\x04\x99\x04\x10Q\n\x0f\n\x07\x04\x1b\x03\x05\x02\x19\x04\
    \x12\x04\x99\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x19\x06\x12\x04\
    \x99\x04\x19A\n\x0f\n\x07\x04\x1b\x03\x05\x02\x19\x01\x12\x04\x99\x04BK\
    \n\x0f\n\x07\x04\x1b\x03\x05\x02\x19\x03\x12\x04\x99\x04NP\n\x0e\n\x06\
    \x04\x1b\x03\x05\x02\x1a\x12\x04\x9a\x04\x10+\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\x1a\x04\x12\x04\x9a\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\
    \x1a\x05\x12\x04\x9a\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1a\x01\
    \x12\x04\x9a\x04\x20%\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1a\x03\x12\x04\
    \x9a\x04(*\n\x0e\n\x06\x04\x1b\x03\x05\x02\x1b\x12\x04\x9b\x04\x100\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02\x1b\x04\x12\x04\x9b\x04\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\x1b\x05\x12\x04\x9b\x04\x19\x1f\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\x1b\x01\x12\x04\x9b\x04\x20*\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\x1b\x03\x12\x04\x9b\x04-/\n\x0e\n\x06\x04\x1b\x03\x05\x02\x1c\
    \x12\x04\x9c\x04\x101\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1c\x04\x12\x04\
    \x9c\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1c\x05\x12\x04\x9c\x04\
    \x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1c\x01\x12\x04\x9c\x04\x20+\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02\x1c\x03\x12\x04\x9c\x04.0\n\x0e\n\x06\x04\
    \x1b\x03\x05\x02\x1d\x12\x04\x9d\x04\x103\n\x0f\n\x07\x04\x1b\x03\x05\
    \x02\x1d\x04\x12\x04\x9d\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1d\
    \x05\x12\x04\x9d\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1d\x01\x12\
    \x04\x9d\x04\x20-\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1d\x03\x12\x04\x9d\
    \x0402\n\x0e\n\x06\x04\x1b\x03\x05\x02\x1e\x12\x04\x9e\x04\x102\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\x1e\x04\x12\x04\x9e\x04\x10\x18\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\x1e\x05\x12\x04\x9e\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\x1e\x01\x12\x04\x9e\x04\x20,\n\x0f\n\x07\x04\x1b\x03\x05\x02\
    \x1e\x03\x12\x04\x9e\x04/1\n\x0e\n\x06\x04\x1b\x03\x05\x02\x1f\x12\x04\
    \x9f\x04\x10.\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1f\x04\x12\x04\x9f\x04\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x1f\x05\x12\x04\x9f\x04\x19\x1f\
    \n\x0f\n\x07\x04\x1b\x03\x05\x02\x1f\x01\x12\x04\x9f\x04\x20(\n\x0f\n\
    \x07\x04\x1b\x03\x05\x02\x1f\x03\x12\x04\x9f\x04+-\n\x0e\n\x06\x04\x1b\
    \x03\x05\x02\x20\x12\x04\xa0\x04\x102\n\x0f\n\x07\x04\x1b\x03\x05\x02\
    \x20\x04\x12\x04\xa0\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02\x20\x05\
    \x12\x04\xa0\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02\x20\x01\x12\x04\
    \xa0\x04\x20,\n\x0f\n\x07\x04\x1b\x03\x05\x02\x20\x03\x12\x04\xa0\x04/1\
    \n\x0e\n\x06\x04\x1b\x03\x05\x02!\x12\x04\xa1\x04\x102\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02!\x04\x12\x04\xa1\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02!\x05\x12\x04\xa1\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02!\
    \x01\x12\x04\xa1\x04\x20,\n\x0f\n\x07\x04\x1b\x03\x05\x02!\x03\x12\x04\
    \xa1\x04/1\n\x0e\n\x06\x04\x1b\x03\x05\x02\"\x12\x04\xa2\x04\x100\n\x0f\
    \n\x07\x04\x1b\x03\x05\x02\"\x04\x12\x04\xa2\x04\x10\x18\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02\"\x05\x12\x04\xa2\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02\"\x01\x12\x04\xa2\x04\x20*\n\x0f\n\x07\x04\x1b\x03\x05\x02\"\
    \x03\x12\x04\xa2\x04-/\n\x0e\n\x06\x04\x1b\x03\x05\x02#\x12\x04\xa3\x04\
    \x10.\n\x0f\n\x07\x04\x1b\x03\x05\x02#\x04\x12\x04\xa3\x04\x10\x18\n\x0f\
    \n\x07\x04\x1b\x03\x05\x02#\x05\x12\x04\xa3\x04\x19\x1f\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02#\x01\x12\x04\xa3\x04\x20(\n\x0f\n\x07\x04\x1b\x03\x05\
    \x02#\x03\x12\x04\xa3\x04+-\n\x0e\n\x06\x04\x1b\x03\x05\x02$\x12\x04\xa4\
    \x04\x10*\n\x0f\n\x07\x04\x1b\x03\x05\x02$\x04\x12\x04\xa4\x04\x10\x18\n\
    \x0f\n\x07\x04\x1b\x03\x05\x02$\x05\x12\x04\xa4\x04\x19\x1f\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02$\x01\x12\x04\xa4\x04\x20$\n\x0f\n\x07\x04\x1b\x03\
    \x05\x02$\x03\x12\x04\xa4\x04')\n\x0e\n\x06\x04\x1b\x03\x05\x02%\x12\x04\
    \xa5\x04\x10&\n\x0f\n\x07\x04\x1b\x03\x05\x02%\x04\x12\x04\xa5\x04\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\x05\x02%\x05\x12\x04\xa5\x04\x19\x1e\n\x0f\
    \n\x07\x04\x1b\x03\x05\x02%\x01\x12\x04\xa5\x04\x1f\x20\n\x0f\n\x07\x04\
    \x1b\x03\x05\x02%\x03\x12\x04\xa5\x04#%\n\x0e\n\x06\x04\x1b\x03\x05\x02&\
    \x12\x04\xa6\x04\x10&\n\x0f\n\x07\x04\x1b\x03\x05\x02&\x04\x12\x04\xa6\
    \x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02&\x05\x12\x04\xa6\x04\x19\
    \x1e\n\x0f\n\x07\x04\x1b\x03\x05\x02&\x01\x12\x04\xa6\x04\x1f\x20\n\x0f\
    \n\x07\x04\x1b\x03\x05\x02&\x03\x12\x04\xa6\x04#%\n\x0e\n\x06\x04\x1b\
    \x03\x05\x02'\x12\x04\xa7\x04\x101\n\x0f\n\x07\x04\x1b\x03\x05\x02'\x04\
    \x12\x04\xa7\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02'\x05\x12\x04\
    \xa7\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x05\x02'\x01\x12\x04\xa7\x04\
    \x1f+\n\x0f\n\x07\x04\x1b\x03\x05\x02'\x03\x12\x04\xa7\x04.0\n\x0e\n\x06\
    \x04\x1b\x03\x05\x02(\x12\x04\xa8\x04\x107\n\x0f\n\x07\x04\x1b\x03\x05\
    \x02(\x04\x12\x04\xa8\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\x02(\x05\
    \x12\x04\xa8\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x05\x02(\x01\x12\x04\
    \xa8\x04\x201\n\x0f\n\x07\x04\x1b\x03\x05\x02(\x03\x12\x04\xa8\x0446\n\
    \x0e\n\x06\x04\x1b\x03\x05\x02)\x12\x04\xa9\x04\x10/\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02)\x04\x12\x04\xa9\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x05\
    \x02)\x05\x12\x04\xa9\x04\x19\x1d\n\x0f\n\x07\x04\x1b\x03\x05\x02)\x01\
    \x12\x04\xa9\x04\x1e)\n\x0f\n\x07\x04\x1b\x03\x05\x02)\x03\x12\x04\xa9\
    \x04,.\n\x0e\n\x06\x04\x1b\x03\x05\x02*\x12\x04\xaa\x04\x10J\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02*\x04\x12\x04\xaa\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02*\x06\x12\x04\xaa\x04\x19>\n\x0f\n\x07\x04\x1b\x03\x05\x02*\
    \x01\x12\x04\xaa\x04?D\n\x0f\n\x07\x04\x1b\x03\x05\x02*\x03\x12\x04\xaa\
    \x04GI\n\x0e\n\x06\x04\x1b\x03\x05\x02+\x12\x04\xab\x04\x10O\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02+\x04\x12\x04\xab\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02+\x06\x12\x04\xab\x04\x19>\n\x0f\n\x07\x04\x1b\x03\x05\x02+\
    \x01\x12\x04\xab\x04?I\n\x0f\n\x07\x04\x1b\x03\x05\x02+\x03\x12\x04\xab\
    \x04LN\n\x0e\n\x06\x04\x1b\x03\x05\x02,\x12\x04\xac\x04\x10U\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02,\x04\x12\x04\xac\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02,\x06\x12\x04\xac\x04\x19>\n\x0f\n\x07\x04\x1b\x03\x05\x02,\
    \x01\x12\x04\xac\x04?O\n\x0f\n\x07\x04\x1b\x03\x05\x02,\x03\x12\x04\xac\
    \x04RT\n\x0e\n\x06\x04\x1b\x03\x05\x02-\x12\x04\xad\x04\x10P\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02-\x04\x12\x04\xad\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02-\x06\x12\x04\xad\x04\x19>\n\x0f\n\x07\x04\x1b\x03\x05\x02-\
    \x01\x12\x04\xad\x04?J\n\x0f\n\x07\x04\x1b\x03\x05\x02-\x03\x12\x04\xad\
    \x04MO\n\x0e\n\x06\x04\x1b\x03\x05\x02.\x12\x04\xae\x04\x10[\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02.\x04\x12\x04\xae\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02.\x06\x12\x04\xae\x04\x19B\n\x0f\n\x07\x04\x1b\x03\x05\x02.\
    \x01\x12\x04\xae\x04CU\n\x0f\n\x07\x04\x1b\x03\x05\x02.\x03\x12\x04\xae\
    \x04XZ\n\x0e\n\x06\x04\x1b\x03\x05\x02/\x12\x04\xaf\x04\x100\n\x0f\n\x07\
    \x04\x1b\x03\x05\x02/\x04\x12\x04\xaf\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x05\x02/\x05\x12\x04\xaf\x04\x19\x1d\n\x0f\n\x07\x04\x1b\x03\x05\
    \x02/\x01\x12\x04\xaf\x04\x1e*\n\x0f\n\x07\x04\x1b\x03\x05\x02/\x03\x12\
    \x04\xaf\x04-/\n\x0e\n\x06\x04\x1b\x03\x05\x020\x12\x04\xb0\x04\x105\n\
    \x0f\n\x07\x04\x1b\x03\x05\x020\x04\x12\x04\xb0\x04\x10\x18\n\x0f\n\x07\
    \x04\x1b\x03\x05\x020\x05\x12\x04\xb0\x04\x19\x1d\n\x0f\n\x07\x04\x1b\
    \x03\x05\x020\x01\x12\x04\xb0\x04\x1e/\n\x0f\n\x07\x04\x1b\x03\x05\x020\
    \x03\x12\x04\xb0\x0424\n\x0e\n\x04\x04\x1b\x03\x06\x12\x06\xb3\x04\x08\
    \xbc\x04\t\n\r\n\x05\x04\x1b\x03\x06\x01\x12\x04\xb3\x04\x10\x1f\n\x0e\n\
    \x06\x04\x1b\x03\x06\x02\0\x12\x04\xb4\x04\x10)\n\x0f\n\x07\x04\x1b\x03\
    \x06\x02\0\x04\x12\x04\xb4\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x06\x02\0\
    \x05\x12\x04\xb4\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x06\x02\0\x01\x12\
    \x04\xb4\x04\x20$\n\x0f\n\x07\x04\x1b\x03\x06\x02\0\x03\x12\x04\xb4\x04'\
    (\n\x0e\n\x06\x04\x1b\x03\x06\x02\x01\x12\x04\xb5\x04\x10+\n\x0f\n\x07\
    \x04\x1b\x03\x06\x02\x01\x04\x12\x04\xb5\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x06\x02\x01\x05\x12\x04\xb5\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x06\
    \x02\x01\x01\x12\x04\xb5\x04\x1f&\n\x0f\n\x07\x04\x1b\x03\x06\x02\x01\
    \x03\x12\x04\xb5\x04)*\n\x0e\n\x06\x04\x1b\x03\x06\x02\x02\x12\x04\xb6\
    \x04\x10)\n\x0f\n\x07\x04\x1b\x03\x06\x02\x02\x04\x12\x04\xb6\x04\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\x06\x02\x02\x05\x12\x04\xb6\x04\x19\x1f\n\
    \x0f\n\x07\x04\x1b\x03\x06\x02\x02\x01\x12\x04\xb6\x04\x20$\n\x0f\n\x07\
    \x04\x1b\x03\x06\x02\x02\x03\x12\x04\xb6\x04'(\n\x0e\n\x06\x04\x1b\x03\
    \x06\x02\x03\x12\x04\xb7\x04\x10)\n\x0f\n\x07\x04\x1b\x03\x06\x02\x03\
    \x04\x12\x04\xb7\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x06\x02\x03\x05\x12\
    \x04\xb7\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x06\x02\x03\x01\x12\x04\xb7\
    \x04\x20$\n\x0f\n\x07\x04\x1b\x03\x06\x02\x03\x03\x12\x04\xb7\x04'(\n\
    \x0e\n\x06\x04\x1b\x03\x06\x02\x04\x12\x04\xb8\x04\x10)\n\x0f\n\x07\x04\
    \x1b\x03\x06\x02\x04\x04\x12\x04\xb8\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\
    \x06\x02\x04\x05\x12\x04\xb8\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x06\x02\
    \x04\x01\x12\x04\xb8\x04\x20$\n\x0f\n\x07\x04\x1b\x03\x06\x02\x04\x03\
    \x12\x04\xb8\x04'(\n\x0e\n\x06\x04\x1b\x03\x06\x02\x05\x12\x04\xb9\x04\
    \x10%\n\x0f\n\x07\x04\x1b\x03\x06\x02\x05\x04\x12\x04\xb9\x04\x10\x18\n\
    \x0f\n\x07\x04\x1b\x03\x06\x02\x05\x05\x12\x04\xb9\x04\x19\x1e\n\x0f\n\
    \x07\x04\x1b\x03\x06\x02\x05\x01\x12\x04\xb9\x04\x1f\x20\n\x0f\n\x07\x04\
    \x1b\x03\x06\x02\x05\x03\x12\x04\xb9\x04#$\n\x0e\n\x06\x04\x1b\x03\x06\
    \x02\x06\x12\x04\xba\x04\x10%\n\x0f\n\x07\x04\x1b\x03\x06\x02\x06\x04\
    \x12\x04\xba\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x06\x02\x06\x05\x12\x04\
    \xba\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x06\x02\x06\x01\x12\x04\xba\x04\
    \x1f\x20\n\x0f\n\x07\x04\x1b\x03\x06\x02\x06\x03\x12\x04\xba\x04#$\n\x0e\
    \n\x06\x04\x1b\x03\x06\x02\x07\x12\x04\xbb\x04\x10,\n\x0f\n\x07\x04\x1b\
    \x03\x06\x02\x07\x04\x12\x04\xbb\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x06\
    \x02\x07\x05\x12\x04\xbb\x04\x19\x1d\n\x0f\n\x07\x04\x1b\x03\x06\x02\x07\
    \x01\x12\x04\xbb\x04\x1e'\n\x0f\n\x07\x04\x1b\x03\x06\x02\x07\x03\x12\
    \x04\xbb\x04*+\n\x0e\n\x04\x04\x1b\x03\x07\x12\x06\xbe\x04\x08\xc2\x04\t\
    \n\r\n\x05\x04\x1b\x03\x07\x01\x12\x04\xbe\x04\x10\x1b\n\x0e\n\x06\x04\
    \x1b\x03\x07\x02\0\x12\x04\xbf\x04\x10-\n\x0f\n\x07\x04\x1b\x03\x07\x02\
    \0\x04\x12\x04\xbf\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x07\x02\0\x05\x12\
    \x04\xbf\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x07\x02\0\x01\x12\x04\xbf\
    \x04\x1f(\n\x0f\n\x07\x04\x1b\x03\x07\x02\0\x03\x12\x04\xbf\x04+,\n\x0e\
    \n\x06\x04\x1b\x03\x07\x02\x01\x12\x04\xc0\x04\x10.\n\x0f\n\x07\x04\x1b\
    \x03\x07\x02\x01\x04\x12\x04\xc0\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x07\
    \x02\x01\x05\x12\x04\xc0\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x07\x02\x01\
    \x01\x12\x04\xc0\x04\x1f)\n\x0f\n\x07\x04\x1b\x03\x07\x02\x01\x03\x12\
    \x04\xc0\x04,-\n\x0e\n\x06\x04\x1b\x03\x07\x02\x02\x12\x04\xc1\x04\x104\
    \n\x0f\n\x07\x04\x1b\x03\x07\x02\x02\x04\x12\x04\xc1\x04\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\x07\x02\x02\x05\x12\x04\xc1\x04\x19\x1e\n\x0f\n\x07\x04\
    \x1b\x03\x07\x02\x02\x01\x12\x04\xc1\x04\x1f/\n\x0f\n\x07\x04\x1b\x03\
    \x07\x02\x02\x03\x12\x04\xc1\x0423\n\x0e\n\x04\x04\x1b\x03\x08\x12\x06\
    \xc4\x04\x08\xc6\x04\t\n\r\n\x05\x04\x1b\x03\x08\x01\x12\x04\xc4\x04\x10\
    \"\n\x0e\n\x06\x04\x1b\x03\x08\x02\0\x12\x04\xc5\x04\x10-\n\x0f\n\x07\
    \x04\x1b\x03\x08\x02\0\x04\x12\x04\xc5\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x08\x02\0\x05\x12\x04\xc5\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x08\
    \x02\0\x01\x12\x04\xc5\x04\x1f(\n\x0f\n\x07\x04\x1b\x03\x08\x02\0\x03\
    \x12\x04\xc5\x04+,\n\x0e\n\x04\x04\x1b\x03\t\x12\x06\xc8\x04\x08\xcb\x04\
    \t\n\r\n\x05\x04\x1b\x03\t\x01\x12\x04\xc8\x04\x10\x1e\n\x0e\n\x06\x04\
    \x1b\x03\t\x02\0\x12\x04\xc9\x04\x10)\n\x0f\n\x07\x04\x1b\x03\t\x02\0\
    \x04\x12\x04\xc9\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\t\x02\0\x05\x12\x04\
    \xc9\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\t\x02\0\x01\x12\x04\xc9\x04\x20\
    $\n\x0f\n\x07\x04\x1b\x03\t\x02\0\x03\x12\x04\xc9\x04'(\n\x0e\n\x06\x04\
    \x1b\x03\t\x02\x01\x12\x04\xca\x04\x10)\n\x0f\n\x07\x04\x1b\x03\t\x02\
    \x01\x04\x12\x04\xca\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\t\x02\x01\x05\
    \x12\x04\xca\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\t\x02\x01\x01\x12\x04\
    \xca\x04\x20$\n\x0f\n\x07\x04\x1b\x03\t\x02\x01\x03\x12\x04\xca\x04'(\n\
    \x0e\n\x04\x04\x1b\x03\n\x12\x06\xcd\x04\x08\xe2\x04\t\n\r\n\x05\x04\x1b\
    \x03\n\x01\x12\x04\xcd\x04\x10\x1c\n\x0e\n\x06\x04\x1b\x03\n\x02\0\x12\
    \x04\xce\x04\x105\n\x0f\n\x07\x04\x1b\x03\n\x02\0\x04\x12\x04\xce\x04\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\0\x05\x12\x04\xce\x04\x19\x20\n\
    \x0f\n\x07\x04\x1b\x03\n\x02\0\x01\x12\x04\xce\x04!0\n\x0f\n\x07\x04\x1b\
    \x03\n\x02\0\x03\x12\x04\xce\x0434\n\x0e\n\x06\x04\x1b\x03\n\x02\x01\x12\
    \x04\xcf\x04\x10-\n\x0f\n\x07\x04\x1b\x03\n\x02\x01\x04\x12\x04\xcf\x04\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x01\x05\x12\x04\xcf\x04\x19\x1f\n\
    \x0f\n\x07\x04\x1b\x03\n\x02\x01\x01\x12\x04\xcf\x04\x20(\n\x0f\n\x07\
    \x04\x1b\x03\n\x02\x01\x03\x12\x04\xcf\x04+,\n\x0e\n\x06\x04\x1b\x03\n\
    \x02\x02\x12\x04\xd0\x04\x10.\n\x0f\n\x07\x04\x1b\x03\n\x02\x02\x04\x12\
    \x04\xd0\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x02\x05\x12\x04\xd0\
    \x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\n\x02\x02\x01\x12\x04\xd0\x04\x20)\
    \n\x0f\n\x07\x04\x1b\x03\n\x02\x02\x03\x12\x04\xd0\x04,-\n\x0e\n\x06\x04\
    \x1b\x03\n\x02\x03\x12\x04\xd1\x04\x10/\n\x0f\n\x07\x04\x1b\x03\n\x02\
    \x03\x04\x12\x04\xd1\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x03\x05\
    \x12\x04\xd1\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\n\x02\x03\x01\x12\x04\
    \xd1\x04\x1f*\n\x0f\n\x07\x04\x1b\x03\n\x02\x03\x03\x12\x04\xd1\x04-.\n\
    \x0e\n\x06\x04\x1b\x03\n\x02\x04\x12\x04\xd2\x04\x108\n\x0f\n\x07\x04\
    \x1b\x03\n\x02\x04\x04\x12\x04\xd2\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\
    \x02\x04\x05\x12\x04\xd2\x04\x19\x1d\n\x0f\n\x07\x04\x1b\x03\n\x02\x04\
    \x01\x12\x04\xd2\x04\x1e3\n\x0f\n\x07\x04\x1b\x03\n\x02\x04\x03\x12\x04\
    \xd2\x0467\n\x0e\n\x06\x04\x1b\x03\n\x02\x05\x12\x04\xd3\x04\x10-\n\x0f\
    \n\x07\x04\x1b\x03\n\x02\x05\x04\x12\x04\xd3\x04\x10\x18\n\x0f\n\x07\x04\
    \x1b\x03\n\x02\x05\x05\x12\x04\xd3\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\n\
    \x02\x05\x01\x12\x04\xd3\x04\x1f(\n\x0f\n\x07\x04\x1b\x03\n\x02\x05\x03\
    \x12\x04\xd3\x04+,\n\x0e\n\x06\x04\x1b\x03\n\x02\x06\x12\x04\xd4\x04\x10\
    0\n\x0f\n\x07\x04\x1b\x03\n\x02\x06\x04\x12\x04\xd4\x04\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\n\x02\x06\x05\x12\x04\xd4\x04\x19\x1f\n\x0f\n\x07\x04\
    \x1b\x03\n\x02\x06\x01\x12\x04\xd4\x04\x20*\n\x0f\n\x07\x04\x1b\x03\n\
    \x02\x06\x03\x12\x04\xd4\x04-/\n\x0e\n\x06\x04\x1b\x03\n\x02\x07\x12\x04\
    \xd5\x04\x103\n\x0f\n\x07\x04\x1b\x03\n\x02\x07\x04\x12\x04\xd5\x04\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x07\x05\x12\x04\xd5\x04\x19\x1f\n\x0f\
    \n\x07\x04\x1b\x03\n\x02\x07\x01\x12\x04\xd5\x04\x20.\n\x0f\n\x07\x04\
    \x1b\x03\n\x02\x07\x03\x12\x04\xd5\x0412\n\x0e\n\x06\x04\x1b\x03\n\x02\
    \x08\x12\x04\xd6\x04\x100\n\x0f\n\x07\x04\x1b\x03\n\x02\x08\x04\x12\x04\
    \xd6\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x08\x05\x12\x04\xd6\x04\
    \x19\x1f\n\x0f\n\x07\x04\x1b\x03\n\x02\x08\x01\x12\x04\xd6\x04\x20+\n\
    \x0f\n\x07\x04\x1b\x03\n\x02\x08\x03\x12\x04\xd6\x04./\n\x0e\n\x06\x04\
    \x1b\x03\n\x02\t\x12\x04\xd7\x04\x10M\n\x0f\n\x07\x04\x1b\x03\n\x02\t\
    \x04\x12\x04\xd7\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\t\x06\x12\x04\
    \xd7\x04\x19A\n\x0f\n\x07\x04\x1b\x03\n\x02\t\x01\x12\x04\xd7\x04BG\n\
    \x0f\n\x07\x04\x1b\x03\n\x02\t\x03\x12\x04\xd7\x04JL\n\x0e\n\x06\x04\x1b\
    \x03\n\x02\n\x12\x04\xd8\x04\x10L\n\x0f\n\x07\x04\x1b\x03\n\x02\n\x04\
    \x12\x04\xd8\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\n\x06\x12\x04\xd8\
    \x04\x19A\n\x0f\n\x07\x04\x1b\x03\n\x02\n\x01\x12\x04\xd8\x04BF\n\x0f\n\
    \x07\x04\x1b\x03\n\x02\n\x03\x12\x04\xd8\x04IK\n\x0e\n\x06\x04\x1b\x03\n\
    \x02\x0b\x12\x04\xd9\x04\x10J\n\x0f\n\x07\x04\x1b\x03\n\x02\x0b\x04\x12\
    \x04\xd9\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x0b\x06\x12\x04\xd9\
    \x04\x19>\n\x0f\n\x07\x04\x1b\x03\n\x02\x0b\x01\x12\x04\xd9\x04?D\n\x0f\
    \n\x07\x04\x1b\x03\n\x02\x0b\x03\x12\x04\xd9\x04GI\n\x0e\n\x06\x04\x1b\
    \x03\n\x02\x0c\x12\x04\xda\x04\x10X\n\x0f\n\x07\x04\x1b\x03\n\x02\x0c\
    \x04\x12\x04\xda\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x0c\x06\x12\
    \x04\xda\x04\x19E\n\x0f\n\x07\x04\x1b\x03\n\x02\x0c\x01\x12\x04\xda\x04F\
    R\n\x0f\n\x07\x04\x1b\x03\n\x02\x0c\x03\x12\x04\xda\x04UW\n\x0e\n\x06\
    \x04\x1b\x03\n\x02\r\x12\x04\xdb\x04\x10/\n\x0f\n\x07\x04\x1b\x03\n\x02\
    \r\x04\x12\x04\xdb\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\r\x05\x12\
    \x04\xdb\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\n\x02\r\x01\x12\x04\xdb\x04\
    \x20)\n\x0f\n\x07\x04\x1b\x03\n\x02\r\x03\x12\x04\xdb\x04,.\n\x0e\n\x06\
    \x04\x1b\x03\n\x02\x0e\x12\x04\xdc\x04\x10/\n\x0f\n\x07\x04\x1b\x03\n\
    \x02\x0e\x04\x12\x04\xdc\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x0e\
    \x05\x12\x04\xdc\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\n\x02\x0e\x01\x12\
    \x04\xdc\x04\x20)\n\x0f\n\x07\x04\x1b\x03\n\x02\x0e\x03\x12\x04\xdc\x04,\
    .\n\x0e\n\x06\x04\x1b\x03\n\x02\x0f\x12\x04\xdd\x04\x104\n\x0f\n\x07\x04\
    \x1b\x03\n\x02\x0f\x04\x12\x04\xdd\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\
    \x02\x0f\x05\x12\x04\xdd\x04\x19\x1f\n\x0f\n\x07\x04\x1b\x03\n\x02\x0f\
    \x01\x12\x04\xdd\x04\x20.\n\x0f\n\x07\x04\x1b\x03\n\x02\x0f\x03\x12\x04\
    \xdd\x0413\n\x0e\n\x06\x04\x1b\x03\n\x02\x10\x12\x04\xde\x04\x10/\n\x0f\
    \n\x07\x04\x1b\x03\n\x02\x10\x04\x12\x04\xde\x04\x10\x18\n\x0f\n\x07\x04\
    \x1b\x03\n\x02\x10\x05\x12\x04\xde\x04\x19\x1d\n\x0f\n\x07\x04\x1b\x03\n\
    \x02\x10\x01\x12\x04\xde\x04\x1e)\n\x0f\n\x07\x04\x1b\x03\n\x02\x10\x03\
    \x12\x04\xde\x04,.\n\x0e\n\x06\x04\x1b\x03\n\x02\x11\x12\x04\xdf\x04\x10\
    1\n\x0f\n\x07\x04\x1b\x03\n\x02\x11\x04\x12\x04\xdf\x04\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\n\x02\x11\x05\x12\x04\xdf\x04\x19\x1f\n\x0f\n\x07\x04\
    \x1b\x03\n\x02\x11\x01\x12\x04\xdf\x04\x20+\n\x0f\n\x07\x04\x1b\x03\n\
    \x02\x11\x03\x12\x04\xdf\x04.0\n\x0e\n\x06\x04\x1b\x03\n\x02\x12\x12\x04\
    \xe0\x04\x100\n\x0f\n\x07\x04\x1b\x03\n\x02\x12\x04\x12\x04\xe0\x04\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x12\x05\x12\x04\xe0\x04\x19\x1f\n\x0f\
    \n\x07\x04\x1b\x03\n\x02\x12\x01\x12\x04\xe0\x04\x20*\n\x0f\n\x07\x04\
    \x1b\x03\n\x02\x12\x03\x12\x04\xe0\x04-/\n\x0e\n\x06\x04\x1b\x03\n\x02\
    \x13\x12\x04\xe1\x04\x105\n\x0f\n\x07\x04\x1b\x03\n\x02\x13\x04\x12\x04\
    \xe1\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\n\x02\x13\x05\x12\x04\xe1\x04\
    \x19\x1f\n\x0f\n\x07\x04\x1b\x03\n\x02\x13\x01\x12\x04\xe1\x04\x20/\n\
    \x0f\n\x07\x04\x1b\x03\n\x02\x13\x03\x12\x04\xe1\x0424\n\x0e\n\x04\x04\
    \x1b\x03\x0b\x12\x06\xe4\x04\x08\x83\x05\t\n\r\n\x05\x04\x1b\x03\x0b\x01\
    \x12\x04\xe4\x04\x10\x19\n\x10\n\x06\x04\x1b\x03\x0b\x03\0\x12\x06\xe5\
    \x04\x10\xe7\x04\x11\n\x0f\n\x07\x04\x1b\x03\x0b\x03\0\x01\x12\x04\xe5\
    \x04\x18%\n\x10\n\x08\x04\x1b\x03\x0b\x03\0\x02\0\x12\x04\xe6\x04\x181\n\
    \x11\n\t\x04\x1b\x03\x0b\x03\0\x02\0\x04\x12\x04\xe6\x04\x18\x20\n\x11\n\
    \t\x04\x1b\x03\x0b\x03\0\x02\0\x05\x12\x04\xe6\x04!&\n\x11\n\t\x04\x1b\
    \x03\x0b\x03\0\x02\0\x01\x12\x04\xe6\x04',\n\x11\n\t\x04\x1b\x03\x0b\x03\
    \0\x02\0\x03\x12\x04\xe6\x04/0\n\x10\n\x06\x04\x1b\x03\x0b\x03\x01\x12\
    \x06\xe9\x04\x10\xeb\x04\x11\n\x0f\n\x07\x04\x1b\x03\x0b\x03\x01\x01\x12\
    \x04\xe9\x04\x18)\n\x10\n\x08\x04\x1b\x03\x0b\x03\x01\x02\0\x12\x04\xea\
    \x04\x18a\n\x11\n\t\x04\x1b\x03\x0b\x03\x01\x02\0\x04\x12\x04\xea\x04\
    \x18\x20\n\x11\n\t\x04\x1b\x03\x0b\x03\x01\x02\0\x06\x12\x04\xea\x04!R\n\
    \x11\n\t\x04\x1b\x03\x0b\x03\x01\x02\0\x01\x12\x04\xea\x04S\\\n\x11\n\t\
    \x04\x1b\x03\x0b\x03\x01\x02\0\x03\x12\x04\xea\x04_`\n\x10\n\x06\x04\x1b\
    \x03\x0b\x04\0\x12\x06\xed\x04\x10\xf2\x04\x11\n\x0f\n\x07\x04\x1b\x03\
    \x0b\x04\0\x01\x12\x04\xed\x04\x15\x1a\n\x10\n\x08\x04\x1b\x03\x0b\x04\0\
    \x02\0\x12\x04\xee\x04\x18,\n\x11\n\t\x04\x1b\x03\x0b\x04\0\x02\0\x01\
    \x12\x04\xee\x04\x18'\n\x11\n\t\x04\x1b\x03\x0b\x04\0\x02\0\x02\x12\x04\
    \xee\x04*+\n\x10\n\x08\x04\x1b\x03\x0b\x04\0\x02\x01\x12\x04\xef\x04\x18\
    +\n\x11\n\t\x04\x1b\x03\x0b\x04\0\x02\x01\x01\x12\x04\xef\x04\x18&\n\x11\
    \n\t\x04\x1b\x03\x0b\x04\0\x02\x01\x02\x12\x04\xef\x04)*\n\x10\n\x08\x04\
    \x1b\x03\x0b\x04\0\x02\x02\x12\x04\xf0\x04\x184\n\x11\n\t\x04\x1b\x03\
    \x0b\x04\0\x02\x02\x01\x12\x04\xf0\x04\x18/\n\x11\n\t\x04\x1b\x03\x0b\
    \x04\0\x02\x02\x02\x12\x04\xf0\x0423\n\x10\n\x08\x04\x1b\x03\x0b\x04\0\
    \x02\x03\x12\x04\xf1\x04\x18%\n\x11\n\t\x04\x1b\x03\x0b\x04\0\x02\x03\
    \x01\x12\x04\xf1\x04\x18\x20\n\x11\n\t\x04\x1b\x03\x0b\x04\0\x02\x03\x02\
    \x12\x04\xf1\x04#$\n\x10\n\x06\x04\x1b\x03\x0b\x04\x01\x12\x06\xf4\x04\
    \x10\xfb\x04\x11\n\x0f\n\x07\x04\x1b\x03\x0b\x04\x01\x01\x12\x04\xf4\x04\
    \x15\x1e\n\x10\n\x08\x04\x1b\x03\x0b\x04\x01\x02\0\x12\x04\xf5\x04\x18$\
    \n\x11\n\t\x04\x1b\x03\x0b\x04\x01\x02\0\x01\x12\x04\xf5\x04\x18\x1f\n\
    \x11\n\t\x04\x1b\x03\x0b\x04\x01\x02\0\x02\x12\x04\xf5\x04\"#\n\x10\n\
    \x08\x04\x1b\x03\x0b\x04\x01\x02\x01\x12\x04\xf6\x04\x18$\n\x11\n\t\x04\
    \x1b\x03\x0b\x04\x01\x02\x01\x01\x12\x04\xf6\x04\x18\x1f\n\x11\n\t\x04\
    \x1b\x03\x0b\x04\x01\x02\x01\x02\x12\x04\xf6\x04\"#\n\x10\n\x08\x04\x1b\
    \x03\x0b\x04\x01\x02\x02\x12\x04\xf7\x04\x18$\n\x11\n\t\x04\x1b\x03\x0b\
    \x04\x01\x02\x02\x01\x12\x04\xf7\x04\x18\x1f\n\x11\n\t\x04\x1b\x03\x0b\
    \x04\x01\x02\x02\x02\x12\x04\xf7\x04\"#\n\x10\n\x08\x04\x1b\x03\x0b\x04\
    \x01\x02\x03\x12\x04\xf8\x04\x18#\n\x11\n\t\x04\x1b\x03\x0b\x04\x01\x02\
    \x03\x01\x12\x04\xf8\x04\x18\x1e\n\x11\n\t\x04\x1b\x03\x0b\x04\x01\x02\
    \x03\x02\x12\x04\xf8\x04!\"\n\x10\n\x08\x04\x1b\x03\x0b\x04\x01\x02\x04\
    \x12\x04\xf9\x04\x18%\n\x11\n\t\x04\x1b\x03\x0b\x04\x01\x02\x04\x01\x12\
    \x04\xf9\x04\x18\x20\n\x11\n\t\x04\x1b\x03\x0b\x04\x01\x02\x04\x02\x12\
    \x04\xf9\x04#$\n\x10\n\x08\x04\x1b\x03\x0b\x04\x01\x02\x05\x12\x04\xfa\
    \x04\x18\"\n\x11\n\t\x04\x1b\x03\x0b\x04\x01\x02\x05\x01\x12\x04\xfa\x04\
    \x18\x1d\n\x11\n\t\x04\x1b\x03\x0b\x04\x01\x02\x05\x02\x12\x04\xfa\x04\
    \x20!\n\x0e\n\x06\x04\x1b\x03\x0b\x02\0\x12\x04\xfd\x04\x10.\n\x0f\n\x07\
    \x04\x1b\x03\x0b\x02\0\x04\x12\x04\xfd\x04\x10\x18\n\x0f\n\x07\x04\x1b\
    \x03\x0b\x02\0\x05\x12\x04\xfd\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x0b\
    \x02\0\x01\x12\x04\xfd\x04\x1f)\n\x0f\n\x07\x04\x1b\x03\x0b\x02\0\x03\
    \x12\x04\xfd\x04,-\n\x0e\n\x06\x04\x1b\x03\x0b\x02\x01\x12\x04\xfe\x04\
    \x10,\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x01\x04\x12\x04\xfe\x04\x10\x18\n\
    \x0f\n\x07\x04\x1b\x03\x0b\x02\x01\x05\x12\x04\xfe\x04\x19\x1e\n\x0f\n\
    \x07\x04\x1b\x03\x0b\x02\x01\x01\x12\x04\xfe\x04\x1f'\n\x0f\n\x07\x04\
    \x1b\x03\x0b\x02\x01\x03\x12\x04\xfe\x04*+\n\x0e\n\x06\x04\x1b\x03\x0b\
    \x02\x02\x12\x04\xff\x04\x10.\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x02\x04\
    \x12\x04\xff\x04\x10\x18\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x02\x05\x12\x04\
    \xff\x04\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x02\x01\x12\x04\xff\x04\
    \x1f)\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x02\x03\x12\x04\xff\x04,-\n\x0e\n\
    \x06\x04\x1b\x03\x0b\x02\x03\x12\x04\x80\x05\x10/\n\x0f\n\x07\x04\x1b\
    \x03\x0b\x02\x03\x04\x12\x04\x80\x05\x10\x18\n\x0f\n\x07\x04\x1b\x03\x0b\
    \x02\x03\x05\x12\x04\x80\x05\x19\x1e\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x03\
    \x01\x12\x04\x80\x05\x1f*\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x03\x03\x12\
    \x04\x80\x05-.\n\x0e\n\x06\x04\x1b\x03\x0b\x02\x04\x12\x04\x81\x05\x10-\
    \n\x0f\n\x07\x04\x1b\x03\x0b\x02\x04\x04\x12\x04\x81\x05\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\x0b\x02\x04\x05\x12\x04\x81\x05\x19\x1e\n\x0f\n\x07\x04\
    \x1b\x03\x0b\x02\x04\x01\x12\x04\x81\x05\x1f(\n\x0f\n\x07\x04\x1b\x03\
    \x0b\x02\x04\x03\x12\x04\x81\x05+,\n\x0e\n\x06\x04\x1b\x03\x0b\x02\x05\
    \x12\x04\x82\x05\x10b\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x05\x04\x12\x04\
    \x82\x05\x10\x18\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x05\x06\x12\x04\x82\x05\
    \x19N\n\x0f\n\x07\x04\x1b\x03\x0b\x02\x05\x01\x12\x04\x82\x05O]\n\x0f\n\
    \x07\x04\x1b\x03\x0b\x02\x05\x03\x12\x04\x82\x05`a\n\x0c\n\x04\x04\x1b\
    \x02\0\x12\x04\x85\x05\x08B\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\x85\x05\
    \x08\x10\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\x85\x05\x117\n\r\n\x05\x04\
    \x1b\x02\0\x01\x12\x04\x85\x058=\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\x85\
    \x05@A\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\x86\x05\x08A\n\r\n\x05\x04\
    \x1b\x02\x01\x04\x12\x04\x86\x05\x08\x10\n\r\n\x05\x04\x1b\x02\x01\x06\
    \x12\x04\x86\x05\x116\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\x86\x057<\n\
    \r\n\x05\x04\x1b\x02\x01\x03\x12\x04\x86\x05?@\n\x0c\n\x04\x04\x1b\x02\
    \x02\x12\x04\x87\x05\x08I\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\x87\x05\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x02\x06\x12\x04\x87\x05\x11:\n\r\n\x05\
    \x04\x1b\x02\x02\x01\x12\x04\x87\x05;D\n\r\n\x05\x04\x1b\x02\x02\x03\x12\
    \x04\x87\x05GH\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\x88\x05\x08D\n\r\n\
    \x05\x04\x1b\x02\x03\x04\x12\x04\x88\x05\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x03\x06\x12\x04\x88\x05\x114\n\r\n\x05\x04\x1b\x02\x03\x01\x12\x04\x88\
    \x055?\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\x88\x05BC\n\x0c\n\x04\x04\
    \x1b\x02\x04\x12\x04\x89\x05\x08&\n\r\n\x05\x04\x1b\x02\x04\x04\x12\x04\
    \x89\x05\x08\x10\n\r\n\x05\x04\x1b\x02\x04\x05\x12\x04\x89\x05\x11\x15\n\
    \r\n\x05\x04\x1b\x02\x04\x01\x12\x04\x89\x05\x16!\n\r\n\x05\x04\x1b\x02\
    \x04\x03\x12\x04\x89\x05$%\n\x0c\n\x02\x04\x1c\x12\x06\x8c\x05\0\xd6\x05\
    \x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x8c\x05\x08&\n\x0e\n\x04\x04\x1c\
    \x03\0\x12\x06\x8d\x05\x08\x97\x05\t\n\r\n\x05\x04\x1c\x03\0\x01\x12\x04\
    \x8d\x05\x10\x1b\n\x0e\n\x06\x04\x1c\x03\0\x02\0\x12\x04\x8e\x05\x100\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\0\x04\x12\x04\x8e\x05\x10\x18\n\x0f\n\x07\
    \x04\x1c\x03\0\x02\0\x05\x12\x04\x8e\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\
    \0\x02\0\x01\x12\x04\x8e\x05\x20+\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x03\
    \x12\x04\x8e\x05./\n\x0e\n\x06\x04\x1c\x03\0\x02\x01\x12\x04\x8f\x05\x10\
    ,\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x04\x12\x04\x8f\x05\x10\x18\n\x0f\n\
    \x07\x04\x1c\x03\0\x02\x01\x05\x12\x04\x8f\x05\x19\x1f\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x01\x01\x12\x04\x8f\x05\x20'\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x01\x03\x12\x04\x8f\x05*+\n\x0e\n\x06\x04\x1c\x03\0\x02\x02\x12\x04\
    \x90\x05\x10.\n\x0f\n\x07\x04\x1c\x03\0\x02\x02\x04\x12\x04\x90\x05\x10\
    \x18\n\x0f\n\x07\x04\x1c\x03\0\x02\x02\x05\x12\x04\x90\x05\x19\x1f\n\x0f\
    \n\x07\x04\x1c\x03\0\x02\x02\x01\x12\x04\x90\x05\x20)\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x02\x03\x12\x04\x90\x05,-\n\x0e\n\x06\x04\x1c\x03\0\x02\
    \x03\x12\x04\x91\x05\x10-\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x04\x12\x04\
    \x91\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x05\x12\x04\x91\x05\
    \x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x01\x12\x04\x91\x05\x20(\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\x03\x03\x12\x04\x91\x05+,\n\x0e\n\x06\x04\
    \x1c\x03\0\x02\x04\x12\x04\x92\x05\x10/\n\x0f\n\x07\x04\x1c\x03\0\x02\
    \x04\x04\x12\x04\x92\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\x02\x04\x05\
    \x12\x04\x92\x05\x19\x20\n\x0f\n\x07\x04\x1c\x03\0\x02\x04\x01\x12\x04\
    \x92\x05!*\n\x0f\n\x07\x04\x1c\x03\0\x02\x04\x03\x12\x04\x92\x05-.\n\x0e\
    \n\x06\x04\x1c\x03\0\x02\x05\x12\x04\x93\x05\x10*\n\x0f\n\x07\x04\x1c\
    \x03\0\x02\x05\x04\x12\x04\x93\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\x02\
    \x05\x05\x12\x04\x93\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\x02\x05\x01\
    \x12\x04\x93\x05\x20%\n\x0f\n\x07\x04\x1c\x03\0\x02\x05\x03\x12\x04\x93\
    \x05()\n\x0e\n\x06\x04\x1c\x03\0\x02\x06\x12\x04\x94\x05\x10.\n\x0f\n\
    \x07\x04\x1c\x03\0\x02\x06\x04\x12\x04\x94\x05\x10\x18\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x06\x05\x12\x04\x94\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x06\x01\x12\x04\x94\x05\x20)\n\x0f\n\x07\x04\x1c\x03\0\x02\x06\x03\
    \x12\x04\x94\x05,-\n\x0e\n\x06\x04\x1c\x03\0\x02\x07\x12\x04\x95\x05\x10\
    2\n\x0f\n\x07\x04\x1c\x03\0\x02\x07\x04\x12\x04\x95\x05\x10\x18\n\x0f\n\
    \x07\x04\x1c\x03\0\x02\x07\x05\x12\x04\x95\x05\x19\x1f\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x07\x01\x12\x04\x95\x05\x20-\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x07\x03\x12\x04\x95\x0501\n\x0e\n\x06\x04\x1c\x03\0\x02\x08\x12\x04\
    \x96\x05\x10R\n\x0f\n\x07\x04\x1c\x03\0\x02\x08\x04\x12\x04\x96\x05\x10\
    \x18\n\x0f\n\x07\x04\x1c\x03\0\x02\x08\x06\x12\x04\x96\x05\x19E\n\x0f\n\
    \x07\x04\x1c\x03\0\x02\x08\x01\x12\x04\x96\x05FM\n\x0f\n\x07\x04\x1c\x03\
    \0\x02\x08\x03\x12\x04\x96\x05PQ\n\x0e\n\x04\x04\x1c\x03\x01\x12\x06\x99\
    \x05\x08\xab\x05\t\n\r\n\x05\x04\x1c\x03\x01\x01\x12\x04\x99\x05\x10\x1d\
    \n\x0e\n\x06\x04\x1c\x03\x01\x02\0\x12\x04\x9a\x05\x10.\n\x0f\n\x07\x04\
    \x1c\x03\x01\x02\0\x04\x12\x04\x9a\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\
    \x01\x02\0\x05\x12\x04\x9a\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x01\x02\0\
    \x01\x12\x04\x9a\x05\x20)\n\x0f\n\x07\x04\x1c\x03\x01\x02\0\x03\x12\x04\
    \x9a\x05,-\n\x0e\n\x06\x04\x1c\x03\x01\x02\x01\x12\x04\x9b\x05\x10,\n\
    \x0f\n\x07\x04\x1c\x03\x01\x02\x01\x04\x12\x04\x9b\x05\x10\x18\n\x0f\n\
    \x07\x04\x1c\x03\x01\x02\x01\x05\x12\x04\x9b\x05\x19\x1e\n\x0f\n\x07\x04\
    \x1c\x03\x01\x02\x01\x01\x12\x04\x9b\x05\x1f'\n\x0f\n\x07\x04\x1c\x03\
    \x01\x02\x01\x03\x12\x04\x9b\x05*+\n\x0e\n\x06\x04\x1c\x03\x01\x02\x02\
    \x12\x04\x9c\x05\x10)\n\x0f\n\x07\x04\x1c\x03\x01\x02\x02\x04\x12\x04\
    \x9c\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\x02\x05\x12\x04\x9c\x05\
    \x19\x1f\n\x0f\n\x07\x04\x1c\x03\x01\x02\x02\x01\x12\x04\x9c\x05\x20$\n\
    \x0f\n\x07\x04\x1c\x03\x01\x02\x02\x03\x12\x04\x9c\x05'(\n\x0e\n\x06\x04\
    \x1c\x03\x01\x02\x03\x12\x04\x9d\x05\x10)\n\x0f\n\x07\x04\x1c\x03\x01\
    \x02\x03\x04\x12\x04\x9d\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\x03\
    \x05\x12\x04\x9d\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x01\x02\x03\x01\x12\
    \x04\x9d\x05\x20$\n\x0f\n\x07\x04\x1c\x03\x01\x02\x03\x03\x12\x04\x9d\
    \x05'(\n\x0e\n\x06\x04\x1c\x03\x01\x02\x04\x12\x04\x9e\x05\x10+\n\x0f\n\
    \x07\x04\x1c\x03\x01\x02\x04\x04\x12\x04\x9e\x05\x10\x18\n\x0f\n\x07\x04\
    \x1c\x03\x01\x02\x04\x05\x12\x04\x9e\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\
    \x01\x02\x04\x01\x12\x04\x9e\x05\x20&\n\x0f\n\x07\x04\x1c\x03\x01\x02\
    \x04\x03\x12\x04\x9e\x05)*\n\x0e\n\x06\x04\x1c\x03\x01\x02\x05\x12\x04\
    \x9f\x05\x10*\n\x0f\n\x07\x04\x1c\x03\x01\x02\x05\x04\x12\x04\x9f\x05\
    \x10\x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\x05\x05\x12\x04\x9f\x05\x19\x1f\
    \n\x0f\n\x07\x04\x1c\x03\x01\x02\x05\x01\x12\x04\x9f\x05\x20%\n\x0f\n\
    \x07\x04\x1c\x03\x01\x02\x05\x03\x12\x04\x9f\x05()\n\x0e\n\x06\x04\x1c\
    \x03\x01\x02\x06\x12\x04\xa0\x05\x10/\n\x0f\n\x07\x04\x1c\x03\x01\x02\
    \x06\x04\x12\x04\xa0\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\x06\x05\
    \x12\x04\xa0\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x01\x02\x06\x01\x12\x04\
    \xa0\x05\x20*\n\x0f\n\x07\x04\x1c\x03\x01\x02\x06\x03\x12\x04\xa0\x05-.\
    \n\x0e\n\x06\x04\x1c\x03\x01\x02\x07\x12\x04\xa1\x05\x100\n\x0f\n\x07\
    \x04\x1c\x03\x01\x02\x07\x04\x12\x04\xa1\x05\x10\x18\n\x0f\n\x07\x04\x1c\
    \x03\x01\x02\x07\x05\x12\x04\xa1\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x01\
    \x02\x07\x01\x12\x04\xa1\x05\x20+\n\x0f\n\x07\x04\x1c\x03\x01\x02\x07\
    \x03\x12\x04\xa1\x05./\n\x0e\n\x06\x04\x1c\x03\x01\x02\x08\x12\x04\xa2\
    \x05\x102\n\x0f\n\x07\x04\x1c\x03\x01\x02\x08\x04\x12\x04\xa2\x05\x10\
    \x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\x08\x05\x12\x04\xa2\x05\x19\x1f\n\
    \x0f\n\x07\x04\x1c\x03\x01\x02\x08\x01\x12\x04\xa2\x05\x20-\n\x0f\n\x07\
    \x04\x1c\x03\x01\x02\x08\x03\x12\x04\xa2\x0501\n\x0e\n\x06\x04\x1c\x03\
    \x01\x02\t\x12\x04\xa3\x05\x102\n\x0f\n\x07\x04\x1c\x03\x01\x02\t\x04\
    \x12\x04\xa3\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\t\x05\x12\x04\
    \xa3\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x01\x02\t\x01\x12\x04\xa3\x05\
    \x20,\n\x0f\n\x07\x04\x1c\x03\x01\x02\t\x03\x12\x04\xa3\x05/1\n\x0e\n\
    \x06\x04\x1c\x03\x01\x02\n\x12\x04\xa4\x05\x10.\n\x0f\n\x07\x04\x1c\x03\
    \x01\x02\n\x04\x12\x04\xa4\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\n\
    \x05\x12\x04\xa4\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x01\x02\n\x01\x12\
    \x04\xa4\x05\x20(\n\x0f\n\x07\x04\x1c\x03\x01\x02\n\x03\x12\x04\xa4\x05+\
    -\n\x0e\n\x06\x04\x1c\x03\x01\x02\x0b\x12\x04\xa5\x05\x10*\n\x0f\n\x07\
    \x04\x1c\x03\x01\x02\x0b\x04\x12\x04\xa5\x05\x10\x18\n\x0f\n\x07\x04\x1c\
    \x03\x01\x02\x0b\x05\x12\x04\xa5\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x01\
    \x02\x0b\x01\x12\x04\xa5\x05\x20$\n\x0f\n\x07\x04\x1c\x03\x01\x02\x0b\
    \x03\x12\x04\xa5\x05')\n\x0e\n\x06\x04\x1c\x03\x01\x02\x0c\x12\x04\xa6\
    \x05\x10&\n\x0f\n\x07\x04\x1c\x03\x01\x02\x0c\x04\x12\x04\xa6\x05\x10\
    \x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\x0c\x05\x12\x04\xa6\x05\x19\x1e\n\
    \x0f\n\x07\x04\x1c\x03\x01\x02\x0c\x01\x12\x04\xa6\x05\x1f\x20\n\x0f\n\
    \x07\x04\x1c\x03\x01\x02\x0c\x03\x12\x04\xa6\x05#%\n\x0e\n\x06\x04\x1c\
    \x03\x01\x02\r\x12\x04\xa7\x05\x10&\n\x0f\n\x07\x04\x1c\x03\x01\x02\r\
    \x04\x12\x04\xa7\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\r\x05\x12\
    \x04\xa7\x05\x19\x1e\n\x0f\n\x07\x04\x1c\x03\x01\x02\r\x01\x12\x04\xa7\
    \x05\x1f\x20\n\x0f\n\x07\x04\x1c\x03\x01\x02\r\x03\x12\x04\xa7\x05#%\n\
    \x0e\n\x06\x04\x1c\x03\x01\x02\x0e\x12\x04\xa8\x05\x10/\n\x0f\n\x07\x04\
    \x1c\x03\x01\x02\x0e\x04\x12\x04\xa8\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\
    \x01\x02\x0e\x05\x12\x04\xa8\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x01\x02\
    \x0e\x01\x12\x04\xa8\x05\x20)\n\x0f\n\x07\x04\x1c\x03\x01\x02\x0e\x03\
    \x12\x04\xa8\x05,.\n\x0e\n\x06\x04\x1c\x03\x01\x02\x0f\x12\x04\xa9\x05\
    \x10.\n\x0f\n\x07\x04\x1c\x03\x01\x02\x0f\x04\x12\x04\xa9\x05\x10\x18\n\
    \x0f\n\x07\x04\x1c\x03\x01\x02\x0f\x05\x12\x04\xa9\x05\x19\x1e\n\x0f\n\
    \x07\x04\x1c\x03\x01\x02\x0f\x01\x12\x04\xa9\x05\x1f(\n\x0f\n\x07\x04\
    \x1c\x03\x01\x02\x0f\x03\x12\x04\xa9\x05+-\n\x0e\n\x06\x04\x1c\x03\x01\
    \x02\x10\x12\x04\xaa\x05\x10*\n\x0f\n\x07\x04\x1c\x03\x01\x02\x10\x04\
    \x12\x04\xaa\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x01\x02\x10\x05\x12\x04\
    \xaa\x05\x19\x1e\n\x0f\n\x07\x04\x1c\x03\x01\x02\x10\x01\x12\x04\xaa\x05\
    \x1f$\n\x0f\n\x07\x04\x1c\x03\x01\x02\x10\x03\x12\x04\xaa\x05')\n\x0e\n\
    \x04\x04\x1c\x03\x02\x12\x06\xad\x05\x08\xb6\x05\t\n\r\n\x05\x04\x1c\x03\
    \x02\x01\x12\x04\xad\x05\x10\x1f\n\x0e\n\x06\x04\x1c\x03\x02\x02\0\x12\
    \x04\xae\x05\x10)\n\x0f\n\x07\x04\x1c\x03\x02\x02\0\x04\x12\x04\xae\x05\
    \x10\x18\n\x0f\n\x07\x04\x1c\x03\x02\x02\0\x05\x12\x04\xae\x05\x19\x1f\n\
    \x0f\n\x07\x04\x1c\x03\x02\x02\0\x01\x12\x04\xae\x05\x20$\n\x0f\n\x07\
    \x04\x1c\x03\x02\x02\0\x03\x12\x04\xae\x05'(\n\x0e\n\x06\x04\x1c\x03\x02\
    \x02\x01\x12\x04\xaf\x05\x10+\n\x0f\n\x07\x04\x1c\x03\x02\x02\x01\x04\
    \x12\x04\xaf\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x02\x02\x01\x05\x12\x04\
    \xaf\x05\x19\x1e\n\x0f\n\x07\x04\x1c\x03\x02\x02\x01\x01\x12\x04\xaf\x05\
    \x1f&\n\x0f\n\x07\x04\x1c\x03\x02\x02\x01\x03\x12\x04\xaf\x05)*\n\x0e\n\
    \x06\x04\x1c\x03\x02\x02\x02\x12\x04\xb0\x05\x10)\n\x0f\n\x07\x04\x1c\
    \x03\x02\x02\x02\x04\x12\x04\xb0\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x02\
    \x02\x02\x05\x12\x04\xb0\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x02\x02\x02\
    \x01\x12\x04\xb0\x05\x20$\n\x0f\n\x07\x04\x1c\x03\x02\x02\x02\x03\x12\
    \x04\xb0\x05'(\n\x0e\n\x06\x04\x1c\x03\x02\x02\x03\x12\x04\xb1\x05\x10)\
    \n\x0f\n\x07\x04\x1c\x03\x02\x02\x03\x04\x12\x04\xb1\x05\x10\x18\n\x0f\n\
    \x07\x04\x1c\x03\x02\x02\x03\x05\x12\x04\xb1\x05\x19\x1f\n\x0f\n\x07\x04\
    \x1c\x03\x02\x02\x03\x01\x12\x04\xb1\x05\x20$\n\x0f\n\x07\x04\x1c\x03\
    \x02\x02\x03\x03\x12\x04\xb1\x05'(\n\x0e\n\x06\x04\x1c\x03\x02\x02\x04\
    \x12\x04\xb2\x05\x10)\n\x0f\n\x07\x04\x1c\x03\x02\x02\x04\x04\x12\x04\
    \xb2\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x02\x02\x04\x05\x12\x04\xb2\x05\
    \x19\x1f\n\x0f\n\x07\x04\x1c\x03\x02\x02\x04\x01\x12\x04\xb2\x05\x20$\n\
    \x0f\n\x07\x04\x1c\x03\x02\x02\x04\x03\x12\x04\xb2\x05'(\n\x0e\n\x06\x04\
    \x1c\x03\x02\x02\x05\x12\x04\xb3\x05\x10%\n\x0f\n\x07\x04\x1c\x03\x02\
    \x02\x05\x04\x12\x04\xb3\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x02\x02\x05\
    \x05\x12\x04\xb3\x05\x19\x1e\n\x0f\n\x07\x04\x1c\x03\x02\x02\x05\x01\x12\
    \x04\xb3\x05\x1f\x20\n\x0f\n\x07\x04\x1c\x03\x02\x02\x05\x03\x12\x04\xb3\
    \x05#$\n\x0e\n\x06\x04\x1c\x03\x02\x02\x06\x12\x04\xb4\x05\x10%\n\x0f\n\
    \x07\x04\x1c\x03\x02\x02\x06\x04\x12\x04\xb4\x05\x10\x18\n\x0f\n\x07\x04\
    \x1c\x03\x02\x02\x06\x05\x12\x04\xb4\x05\x19\x1e\n\x0f\n\x07\x04\x1c\x03\
    \x02\x02\x06\x01\x12\x04\xb4\x05\x1f\x20\n\x0f\n\x07\x04\x1c\x03\x02\x02\
    \x06\x03\x12\x04\xb4\x05#$\n\x0e\n\x06\x04\x1c\x03\x02\x02\x07\x12\x04\
    \xb5\x05\x10,\n\x0f\n\x07\x04\x1c\x03\x02\x02\x07\x04\x12\x04\xb5\x05\
    \x10\x18\n\x0f\n\x07\x04\x1c\x03\x02\x02\x07\x05\x12\x04\xb5\x05\x19\x1d\
    \n\x0f\n\x07\x04\x1c\x03\x02\x02\x07\x01\x12\x04\xb5\x05\x1e'\n\x0f\n\
    \x07\x04\x1c\x03\x02\x02\x07\x03\x12\x04\xb5\x05*+\n\x0e\n\x04\x04\x1c\
    \x03\x03\x12\x06\xb8\x05\x08\xbb\x05\t\n\r\n\x05\x04\x1c\x03\x03\x01\x12\
    \x04\xb8\x05\x10\x1e\n\x0e\n\x06\x04\x1c\x03\x03\x02\0\x12\x04\xb9\x05\
    \x10)\n\x0f\n\x07\x04\x1c\x03\x03\x02\0\x04\x12\x04\xb9\x05\x10\x18\n\
    \x0f\n\x07\x04\x1c\x03\x03\x02\0\x05\x12\x04\xb9\x05\x19\x1f\n\x0f\n\x07\
    \x04\x1c\x03\x03\x02\0\x01\x12\x04\xb9\x05\x20$\n\x0f\n\x07\x04\x1c\x03\
    \x03\x02\0\x03\x12\x04\xb9\x05'(\n\x0e\n\x06\x04\x1c\x03\x03\x02\x01\x12\
    \x04\xba\x05\x10)\n\x0f\n\x07\x04\x1c\x03\x03\x02\x01\x04\x12\x04\xba\
    \x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x03\x02\x01\x05\x12\x04\xba\x05\x19\
    \x1f\n\x0f\n\x07\x04\x1c\x03\x03\x02\x01\x01\x12\x04\xba\x05\x20$\n\x0f\
    \n\x07\x04\x1c\x03\x03\x02\x01\x03\x12\x04\xba\x05'(\n\x0e\n\x04\x04\x1c\
    \x03\x04\x12\x06\xbd\x05\x08\xcb\x05\t\n\r\n\x05\x04\x1c\x03\x04\x01\x12\
    \x04\xbd\x05\x10\x1c\n\x0e\n\x06\x04\x1c\x03\x04\x02\0\x12\x04\xbe\x05\
    \x105\n\x0f\n\x07\x04\x1c\x03\x04\x02\0\x04\x12\x04\xbe\x05\x10\x18\n\
    \x0f\n\x07\x04\x1c\x03\x04\x02\0\x05\x12\x04\xbe\x05\x19\x20\n\x0f\n\x07\
    \x04\x1c\x03\x04\x02\0\x01\x12\x04\xbe\x05!0\n\x0f\n\x07\x04\x1c\x03\x04\
    \x02\0\x03\x12\x04\xbe\x0534\n\x0e\n\x06\x04\x1c\x03\x04\x02\x01\x12\x04\
    \xbf\x05\x10-\n\x0f\n\x07\x04\x1c\x03\x04\x02\x01\x04\x12\x04\xbf\x05\
    \x10\x18\n\x0f\n\x07\x04\x1c\x03\x04\x02\x01\x05\x12\x04\xbf\x05\x19\x1f\
    \n\x0f\n\x07\x04\x1c\x03\x04\x02\x01\x01\x12\x04\xbf\x05\x20(\n\x0f\n\
    \x07\x04\x1c\x03\x04\x02\x01\x03\x12\x04\xbf\x05+,\n\x0e\n\x06\x04\x1c\
    \x03\x04\x02\x02\x12\x04\xc0\x05\x10.\n\x0f\n\x07\x04\x1c\x03\x04\x02\
    \x02\x04\x12\x04\xc0\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x04\x02\x02\x05\
    \x12\x04\xc0\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x04\x02\x02\x01\x12\x04\
    \xc0\x05\x20)\n\x0f\n\x07\x04\x1c\x03\x04\x02\x02\x03\x12\x04\xc0\x05,-\
    \n\x0e\n\x06\x04\x1c\x03\x04\x02\x03\x12\x04\xc1\x05\x10-\n\x0f\n\x07\
    \x04\x1c\x03\x04\x02\x03\x04\x12\x04\xc1\x05\x10\x18\n\x0f\n\x07\x04\x1c\
    \x03\x04\x02\x03\x05\x12\x04\xc1\x05\x19\x1e\n\x0f\n\x07\x04\x1c\x03\x04\
    \x02\x03\x01\x12\x04\xc1\x05\x1f(\n\x0f\n\x07\x04\x1c\x03\x04\x02\x03\
    \x03\x12\x04\xc1\x05+,\n\x0e\n\x06\x04\x1c\x03\x04\x02\x04\x12\x04\xc2\
    \x05\x10B\n\x0f\n\x07\x04\x1c\x03\x04\x02\x04\x04\x12\x04\xc2\x05\x10\
    \x18\n\x0f\n\x07\x04\x1c\x03\x04\x02\x04\x05\x12\x04\xc2\x05\x19\x1f\n\
    \x0f\n\x07\x04\x1c\x03\x04\x02\x04\x01\x12\x04\xc2\x05\x20=\n\x0f\n\x07\
    \x04\x1c\x03\x04\x02\x04\x03\x12\x04\xc2\x05@A\n\x0e\n\x06\x04\x1c\x03\
    \x04\x02\x05\x12\x04\xc3\x05\x10.\n\x0f\n\x07\x04\x1c\x03\x04\x02\x05\
    \x04\x12\x04\xc3\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x04\x02\x05\x05\x12\
    \x04\xc3\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x04\x02\x05\x01\x12\x04\xc3\
    \x05\x20)\n\x0f\n\x07\x04\x1c\x03\x04\x02\x05\x03\x12\x04\xc3\x05,-\n\
    \x0e\n\x06\x04\x1c\x03\x04\x02\x06\x12\x04\xc4\x05\x10.\n\x0f\n\x07\x04\
    \x1c\x03\x04\x02\x06\x04\x12\x04\xc4\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\
    \x04\x02\x06\x05\x12\x04\xc4\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x04\x02\
    \x06\x01\x12\x04\xc4\x05\x20)\n\x0f\n\x07\x04\x1c\x03\x04\x02\x06\x03\
    \x12\x04\xc4\x05,-\n\x0e\n\x06\x04\x1c\x03\x04\x02\x07\x12\x04\xc5\x05\
    \x103\n\x0f\n\x07\x04\x1c\x03\x04\x02\x07\x04\x12\x04\xc5\x05\x10\x18\n\
    \x0f\n\x07\x04\x1c\x03\x04\x02\x07\x05\x12\x04\xc5\x05\x19\x1f\n\x0f\n\
    \x07\x04\x1c\x03\x04\x02\x07\x01\x12\x04\xc5\x05\x20.\n\x0f\n\x07\x04\
    \x1c\x03\x04\x02\x07\x03\x12\x04\xc5\x0512\n\x0e\n\x06\x04\x1c\x03\x04\
    \x02\x08\x12\x04\xc6\x05\x100\n\x0f\n\x07\x04\x1c\x03\x04\x02\x08\x04\
    \x12\x04\xc6\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x04\x02\x08\x05\x12\x04\
    \xc6\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x04\x02\x08\x01\x12\x04\xc6\x05\
    \x20*\n\x0f\n\x07\x04\x1c\x03\x04\x02\x08\x03\x12\x04\xc6\x05-/\n\x0e\n\
    \x06\x04\x1c\x03\x04\x02\t\x12\x04\xc7\x05\x10R\n\x0f\n\x07\x04\x1c\x03\
    \x04\x02\t\x04\x12\x04\xc7\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x04\x02\t\
    \x06\x12\x04\xc7\x05\x19F\n\x0f\n\x07\x04\x1c\x03\x04\x02\t\x01\x12\x04\
    \xc7\x05GL\n\x0f\n\x07\x04\x1c\x03\x04\x02\t\x03\x12\x04\xc7\x05OQ\n\x0e\
    \n\x06\x04\x1c\x03\x04\x02\n\x12\x04\xc8\x05\x10Q\n\x0f\n\x07\x04\x1c\
    \x03\x04\x02\n\x04\x12\x04\xc8\x05\x10\x18\n\x0f\n\x07\x04\x1c\x03\x04\
    \x02\n\x06\x12\x04\xc8\x05\x19F\n\x0f\n\x07\x04\x1c\x03\x04\x02\n\x01\
    \x12\x04\xc8\x05GK\n\x0f\n\x07\x04\x1c\x03\x04\x02\n\x03\x12\x04\xc8\x05\
    NP\n\x0e\n\x06\x04\x1c\x03\x04\x02\x0b\x12\x04\xc9\x05\x100\n\x0f\n\x07\
    \x04\x1c\x03\x04\x02\x0b\x04\x12\x04\xc9\x05\x10\x18\n\x0f\n\x07\x04\x1c\
    \x03\x04\x02\x0b\x05\x12\x04\xc9\x05\x19\x1f\n\x0f\n\x07\x04\x1c\x03\x04\
    \x02\x0b\x01\x12\x04\xc9\x05\x20*\n\x0f\n\x07\x04\x1c\x03\x04\x02\x0b\
    \x03\x12\x04\xc9\x05-/\n\x0e\n\x06\x04\x1c\x03\x04\x02\x0c\x12\x04\xca\
    \x05\x105\n\x0f\n\x07\x04\x1c\x03\x04\x02\x0c\x04\x12\x04\xca\x05\x10\
    \x18\n\x0f\n\x07\x04\x1c\x03\x04\x02\x0c\x05\x12\x04\xca\x05\x19\x1f\n\
    \x0f\n\x07\x04\x1c\x03\x04\x02\x0c\x01\x12\x04\xca\x05\x20/\n\x0f\n\x07\
    \x04\x1c\x03\x04\x02\x0c\x03\x12\x04\xca\x0524\n\x0e\n\x04\x04\x1c\x03\
    \x05\x12\x06\xcd\x05\x08\xcf\x05\t\n\r\n\x05\x04\x1c\x03\x05\x01\x12\x04\
    \xcd\x05\x10\x19\n\x0e\n\x06\x04\x1c\x03\x05\x02\0\x12\x04\xce\x05\x10.\
    \n\x0f\n\x07\x04\x1c\x03\x05\x02\0\x04\x12\x04\xce\x05\x10\x18\n\x0f\n\
    \x07\x04\x1c\x03\x05\x02\0\x05\x12\x04\xce\x05\x19\x1e\n\x0f\n\x07\x04\
    \x1c\x03\x05\x02\0\x01\x12\x04\xce\x05\x1f)\n\x0f\n\x07\x04\x1c\x03\x05\
    \x02\0\x03\x12\x04\xce\x05,-\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xd1\x05\
    \x08G\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xd1\x05\x08\x10\n\r\n\x05\x04\
    \x1c\x02\0\x06\x12\x04\xd1\x05\x11<\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\
    \xd1\x05=B\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xd1\x05EF\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\xd2\x05\x08F\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\
    \xd2\x05\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\xd2\x05\x11;\n\r\
    \n\x05\x04\x1c\x02\x01\x01\x12\x04\xd2\x05<A\n\r\n\x05\x04\x1c\x02\x01\
    \x03\x12\x04\xd2\x05DE\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\xd3\x05\x08N\
    \n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\xd3\x05\x08\x10\n\r\n\x05\x04\x1c\
    \x02\x02\x06\x12\x04\xd3\x05\x11?\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\
    \xd3\x05@I\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xd3\x05LM\n\x0c\n\x04\
    \x04\x1c\x02\x03\x12\x04\xd4\x05\x08I\n\r\n\x05\x04\x1c\x02\x03\x04\x12\
    \x04\xd4\x05\x08\x10\n\r\n\x05\x04\x1c\x02\x03\x06\x12\x04\xd4\x05\x119\
    \n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xd4\x05:D\n\r\n\x05\x04\x1c\x02\
    \x03\x03\x12\x04\xd4\x05GH\n\x0c\n\x04\x04\x1c\x02\x04\x12\x04\xd5\x05\
    \x08&\n\r\n\x05\x04\x1c\x02\x04\x04\x12\x04\xd5\x05\x08\x10\n\r\n\x05\
    \x04\x1c\x02\x04\x05\x12\x04\xd5\x05\x11\x15\n\r\n\x05\x04\x1c\x02\x04\
    \x01\x12\x04\xd5\x05\x16!\n\r\n\x05\x04\x1c\x02\x04\x03\x12\x04\xd5\x05$\
    %\n\x0c\n\x02\x04\x1d\x12\x06\xd8\x05\0\xdd\x05\x01\n\x0b\n\x03\x04\x1d\
    \x01\x12\x04\xd8\x05\x08&\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xd9\x05\x083\
    \n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xd9\x05\x08\x10\n\r\n\x05\x04\x1d\
    \x02\0\x06\x12\x04\xd9\x05\x11(\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xd9\
    \x05).\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xd9\x0512\n\x0c\n\x04\x04\x1d\
    \x02\x01\x12\x04\xda\x05\x08'\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xda\
    \x05\x08\x10\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xda\x05\x11\x18\n\r\n\
    \x05\x04\x1d\x02\x01\x01\x12\x04\xda\x05\x19\"\n\r\n\x05\x04\x1d\x02\x01\
    \x03\x12\x04\xda\x05%&\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xdb\x05\x08!\
    \n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\xdb\x05\x08\x10\n\r\n\x05\x04\x1d\
    \x02\x02\x05\x12\x04\xdb\x05\x11\x17\n\r\n\x05\x04\x1d\x02\x02\x01\x12\
    \x04\xdb\x05\x18\x1c\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xdb\x05\x1f\
    \x20\n\x0c\n\x04\x04\x1d\x02\x03\x12\x04\xdc\x05\x08(\n\r\n\x05\x04\x1d\
    \x02\x03\x04\x12\x04\xdc\x05\x08\x10\n\r\n\x05\x04\x1d\x02\x03\x05\x12\
    \x04\xdc\x05\x11\x17\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\xdc\x05\x18#\
    \n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\xdc\x05&'\n\x0c\n\x02\x04\x1e\x12\
    \x06\xdf\x05\0\xe1\x05\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xdf\x05\x08(\
    \n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xe0\x05\x080\n\r\n\x05\x04\x1e\x02\0\
    \x04\x12\x04\xe0\x05\x08\x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xe0\x05\
    \x11\x17\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xe0\x05\x18+\n\r\n\x05\x04\
    \x1e\x02\0\x03\x12\x04\xe0\x05./\n\x0c\n\x02\x04\x1f\x12\x06\xe3\x05\0\
    \xee\x05\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xe3\x05\x08#\n\x0c\n\x04\
    \x04\x1f\x02\0\x12\x04\xe4\x05\x08%\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\
    \xe4\x05\x08\x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xe4\x05\x11\x17\n\r\
    \n\x05\x04\x1f\x02\0\x01\x12\x04\xe4\x05\x18\x20\n\r\n\x05\x04\x1f\x02\0\
    \x03\x12\x04\xe4\x05#$\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xe5\x05\x08&\
    \n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\xe5\x05\x08\x10\n\r\n\x05\x04\x1f\
    \x02\x01\x05\x12\x04\xe5\x05\x11\x17\n\r\n\x05\x04\x1f\x02\x01\x01\x12\
    \x04\xe5\x05\x18!\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xe5\x05$%\n\x0c\
    \n\x04\x04\x1f\x02\x02\x12\x04\xe6\x05\x08'\n\r\n\x05\x04\x1f\x02\x02\
    \x04\x12\x04\xe6\x05\x08\x10\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\xe6\
    \x05\x11\x17\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xe6\x05\x18\"\n\r\n\
    \x05\x04\x1f\x02\x02\x03\x12\x04\xe6\x05%&\n\x0c\n\x04\x04\x1f\x02\x03\
    \x12\x04\xe7\x05\x08'\n\r\n\x05\x04\x1f\x02\x03\x04\x12\x04\xe7\x05\x08\
    \x10\n\r\n\x05\x04\x1f\x02\x03\x05\x12\x04\xe7\x05\x11\x17\n\r\n\x05\x04\
    \x1f\x02\x03\x01\x12\x04\xe7\x05\x18\"\n\r\n\x05\x04\x1f\x02\x03\x03\x12\
    \x04\xe7\x05%&\n\x0c\n\x04\x04\x1f\x02\x04\x12\x04\xe8\x05\x08\x1e\n\r\n\
    \x05\x04\x1f\x02\x04\x04\x12\x04\xe8\x05\x08\x10\n\r\n\x05\x04\x1f\x02\
    \x04\x05\x12\x04\xe8\x05\x11\x15\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\
    \xe8\x05\x16\x19\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\xe8\x05\x1c\x1d\n\
    \x0c\n\x04\x04\x1f\x02\x05\x12\x04\xe9\x05\x08\x20\n\r\n\x05\x04\x1f\x02\
    \x05\x04\x12\x04\xe9\x05\x08\x10\n\r\n\x05\x04\x1f\x02\x05\x05\x12\x04\
    \xe9\x05\x11\x17\n\r\n\x05\x04\x1f\x02\x05\x01\x12\x04\xe9\x05\x18\x1b\n\
    \r\n\x05\x04\x1f\x02\x05\x03\x12\x04\xe9\x05\x1e\x1f\n\x0c\n\x04\x04\x1f\
    \x02\x06\x12\x04\xea\x05\x08\x20\n\r\n\x05\x04\x1f\x02\x06\x04\x12\x04\
    \xea\x05\x08\x10\n\r\n\x05\x04\x1f\x02\x06\x05\x12\x04\xea\x05\x11\x17\n\
    \r\n\x05\x04\x1f\x02\x06\x01\x12\x04\xea\x05\x18\x1b\n\r\n\x05\x04\x1f\
    \x02\x06\x03\x12\x04\xea\x05\x1e\x1f\n\x0c\n\x04\x04\x1f\x02\x07\x12\x04\
    \xeb\x05\x08\"\n\r\n\x05\x04\x1f\x02\x07\x04\x12\x04\xeb\x05\x08\x10\n\r\
    \n\x05\x04\x1f\x02\x07\x05\x12\x04\xeb\x05\x11\x17\n\r\n\x05\x04\x1f\x02\
    \x07\x01\x12\x04\xeb\x05\x18\x1d\n\r\n\x05\x04\x1f\x02\x07\x03\x12\x04\
    \xeb\x05\x20!\n\x0c\n\x04\x04\x1f\x02\x08\x12\x04\xec\x05\x08#\n\r\n\x05\
    \x04\x1f\x02\x08\x04\x12\x04\xec\x05\x08\x10\n\r\n\x05\x04\x1f\x02\x08\
    \x05\x12\x04\xec\x05\x11\x17\n\r\n\x05\x04\x1f\x02\x08\x01\x12\x04\xec\
    \x05\x18\x1e\n\r\n\x05\x04\x1f\x02\x08\x03\x12\x04\xec\x05!\"\n\x0c\n\
    \x04\x04\x1f\x02\t\x12\x04\xed\x05\x08%\n\r\n\x05\x04\x1f\x02\t\x04\x12\
    \x04\xed\x05\x08\x10\n\r\n\x05\x04\x1f\x02\t\x05\x12\x04\xed\x05\x11\x17\
    \n\r\n\x05\x04\x1f\x02\t\x01\x12\x04\xed\x05\x18\x1f\n\r\n\x05\x04\x1f\
    \x02\t\x03\x12\x04\xed\x05\"$\n\x0c\n\x02\x04\x20\x12\x06\xf0\x05\0\xf5\
    \x05\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xf0\x05\x08\x1c\n\x0c\n\x04\x04\
    \x20\x02\0\x12\x04\xf1\x05\x08\"\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\xf1\
    \x05\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xf1\x05\x11\x17\n\r\n\
    \x05\x04\x20\x02\0\x01\x12\x04\xf1\x05\x18\x1d\n\r\n\x05\x04\x20\x02\0\
    \x03\x12\x04\xf1\x05\x20!\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\xf2\x05\
    \x08!\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\xf2\x05\x08\x10\n\r\n\x05\
    \x04\x20\x02\x01\x05\x12\x04\xf2\x05\x11\x17\n\r\n\x05\x04\x20\x02\x01\
    \x01\x12\x04\xf2\x05\x18\x1c\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xf2\
    \x05\x1f\x20\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\xf3\x05\x08*\n\r\n\x05\
    \x04\x20\x02\x02\x04\x12\x04\xf3\x05\x08\x10\n\r\n\x05\x04\x20\x02\x02\
    \x05\x12\x04\xf3\x05\x11\x17\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\xf3\
    \x05\x18%\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xf3\x05()\n\x0c\n\x04\
    \x04\x20\x02\x03\x12\x04\xf4\x05\x08*\n\r\n\x05\x04\x20\x02\x03\x04\x12\
    \x04\xf4\x05\x08\x10\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\xf4\x05\x11\
    \x17\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\xf4\x05\x18%\n\r\n\x05\x04\
    \x20\x02\x03\x03\x12\x04\xf4\x05()\n\x0c\n\x02\x04!\x12\x06\xf7\x05\0\
    \xad\x06\x01\n\x0b\n\x03\x04!\x01\x12\x04\xf7\x05\x08\x1c\n\x0e\n\x04\
    \x04!\x03\0\x12\x06\xf8\x05\x08\xfb\x05\t\n\r\n\x05\x04!\x03\0\x01\x12\
    \x04\xf8\x05\x10\x1e\n\x0e\n\x06\x04!\x03\0\x02\0\x12\x04\xf9\x05\x10)\n\
    \x0f\n\x07\x04!\x03\0\x02\0\x04\x12\x04\xf9\x05\x10\x18\n\x0f\n\x07\x04!\
    \x03\0\x02\0\x05\x12\x04\xf9\x05\x19\x1f\n\x0f\n\x07\x04!\x03\0\x02\0\
    \x01\x12\x04\xf9\x05\x20$\n\x0f\n\x07\x04!\x03\0\x02\0\x03\x12\x04\xf9\
    \x05'(\n\x0e\n\x06\x04!\x03\0\x02\x01\x12\x04\xfa\x05\x10*\n\x0f\n\x07\
    \x04!\x03\0\x02\x01\x04\x12\x04\xfa\x05\x10\x18\n\x0f\n\x07\x04!\x03\0\
    \x02\x01\x05\x12\x04\xfa\x05\x19\x1f\n\x0f\n\x07\x04!\x03\0\x02\x01\x01\
    \x12\x04\xfa\x05\x20%\n\x0f\n\x07\x04!\x03\0\x02\x01\x03\x12\x04\xfa\x05\
    ()\n\x0e\n\x04\x04!\x04\0\x12\x06\xfd\x05\x08\x80\x06\t\n\r\n\x05\x04!\
    \x04\0\x01\x12\x04\xfd\x05\r\x1c\n\x0e\n\x06\x04!\x04\0\x02\0\x12\x04\
    \xfe\x05\x10\x1b\n\x0f\n\x07\x04!\x04\0\x02\0\x01\x12\x04\xfe\x05\x10\
    \x16\n\x0f\n\x07\x04!\x04\0\x02\0\x02\x12\x04\xfe\x05\x19\x1a\n\x0e\n\
    \x06\x04!\x04\0\x02\x01\x12\x04\xff\x05\x10\x19\n\x0f\n\x07\x04!\x04\0\
    \x02\x01\x01\x12\x04\xff\x05\x10\x14\n\x0f\n\x07\x04!\x04\0\x02\x01\x02\
    \x12\x04\xff\x05\x17\x18\n\x0e\n\x04\x04!\x04\x01\x12\x06\x82\x06\x08\
    \x8a\x06\t\n\r\n\x05\x04!\x04\x01\x01\x12\x04\x82\x06\r\x1c\n\x0e\n\x06\
    \x04!\x04\x01\x02\0\x12\x04\x83\x06\x10\x1c\n\x0f\n\x07\x04!\x04\x01\x02\
    \0\x01\x12\x04\x83\x06\x10\x17\n\x0f\n\x07\x04!\x04\x01\x02\0\x02\x12\
    \x04\x83\x06\x1a\x1b\n\x0e\n\x06\x04!\x04\x01\x02\x01\x12\x04\x84\x06\
    \x10\x19\n\x0f\n\x07\x04!\x04\x01\x02\x01\x01\x12\x04\x84\x06\x10\x14\n\
    \x0f\n\x07\x04!\x04\x01\x02\x01\x02\x12\x04\x84\x06\x17\x18\n\x0e\n\x06\
    \x04!\x04\x01\x02\x02\x12\x04\x85\x06\x10\x19\n\x0f\n\x07\x04!\x04\x01\
    \x02\x02\x01\x12\x04\x85\x06\x10\x14\n\x0f\n\x07\x04!\x04\x01\x02\x02\
    \x02\x12\x04\x85\x06\x17\x18\n\x0e\n\x06\x04!\x04\x01\x02\x03\x12\x04\
    \x86\x06\x10\x1b\n\x0f\n\x07\x04!\x04\x01\x02\x03\x01\x12\x04\x86\x06\
    \x10\x16\n\x0f\n\x07\x04!\x04\x01\x02\x03\x02\x12\x04\x86\x06\x19\x1a\n\
    \x0e\n\x06\x04!\x04\x01\x02\x04\x12\x04\x87\x06\x10\x1c\n\x0f\n\x07\x04!\
    \x04\x01\x02\x04\x01\x12\x04\x87\x06\x10\x17\n\x0f\n\x07\x04!\x04\x01\
    \x02\x04\x02\x12\x04\x87\x06\x1a\x1b\n\x0e\n\x06\x04!\x04\x01\x02\x05\
    \x12\x04\x88\x06\x10\x1a\n\x0f\n\x07\x04!\x04\x01\x02\x05\x01\x12\x04\
    \x88\x06\x10\x15\n\x0f\n\x07\x04!\x04\x01\x02\x05\x02\x12\x04\x88\x06\
    \x18\x19\n\x0e\n\x06\x04!\x04\x01\x02\x06\x12\x04\x89\x06\x10#\n\x0f\n\
    \x07\x04!\x04\x01\x02\x06\x01\x12\x04\x89\x06\x10\x1e\n\x0f\n\x07\x04!\
    \x04\x01\x02\x06\x02\x12\x04\x89\x06!\"\n\x0e\n\x04\x04!\x04\x02\x12\x06\
    \x8c\x06\x08\x96\x06\t\n\r\n\x05\x04!\x04\x02\x01\x12\x04\x8c\x06\r\x1e\
    \n\x0e\n\x06\x04!\x04\x02\x02\0\x12\x04\x8d\x06\x10!\n\x0f\n\x07\x04!\
    \x04\x02\x02\0\x01\x12\x04\x8d\x06\x10\x1c\n\x0f\n\x07\x04!\x04\x02\x02\
    \0\x02\x12\x04\x8d\x06\x1f\x20\n\x0e\n\x06\x04!\x04\x02\x02\x01\x12\x04\
    \x8e\x06\x10%\n\x0f\n\x07\x04!\x04\x02\x02\x01\x01\x12\x04\x8e\x06\x10\
    \x20\n\x0f\n\x07\x04!\x04\x02\x02\x01\x02\x12\x04\x8e\x06#$\n\x0e\n\x06\
    \x04!\x04\x02\x02\x02\x12\x04\x8f\x06\x10$\n\x0f\n\x07\x04!\x04\x02\x02\
    \x02\x01\x12\x04\x8f\x06\x10\x1f\n\x0f\n\x07\x04!\x04\x02\x02\x02\x02\
    \x12\x04\x8f\x06\"#\n\x0e\n\x06\x04!\x04\x02\x02\x03\x12\x04\x90\x06\x10\
    '\n\x0f\n\x07\x04!\x04\x02\x02\x03\x01\x12\x04\x90\x06\x10\"\n\x0f\n\x07\
    \x04!\x04\x02\x02\x03\x02\x12\x04\x90\x06%&\n\x0e\n\x06\x04!\x04\x02\x02\
    \x04\x12\x04\x91\x06\x10#\n\x0f\n\x07\x04!\x04\x02\x02\x04\x01\x12\x04\
    \x91\x06\x10\x1e\n\x0f\n\x07\x04!\x04\x02\x02\x04\x02\x12\x04\x91\x06!\"\
    \n\x0e\n\x06\x04!\x04\x02\x02\x05\x12\x04\x92\x06\x10#\n\x0f\n\x07\x04!\
    \x04\x02\x02\x05\x01\x12\x04\x92\x06\x10\x1e\n\x0f\n\x07\x04!\x04\x02\
    \x02\x05\x02\x12\x04\x92\x06!\"\n\x0e\n\x06\x04!\x04\x02\x02\x06\x12\x04\
    \x93\x06\x10\x1d\n\x0f\n\x07\x04!\x04\x02\x02\x06\x01\x12\x04\x93\x06\
    \x10\x18\n\x0f\n\x07\x04!\x04\x02\x02\x06\x02\x12\x04\x93\x06\x1b\x1c\n\
    \x0e\n\x06\x04!\x04\x02\x02\x07\x12\x04\x94\x06\x10*\n\x0f\n\x07\x04!\
    \x04\x02\x02\x07\x01\x12\x04\x94\x06\x10%\n\x0f\n\x07\x04!\x04\x02\x02\
    \x07\x02\x12\x04\x94\x06()\n\x0e\n\x06\x04!\x04\x02\x02\x08\x12\x04\x95\
    \x06\x10*\n\x0f\n\x07\x04!\x04\x02\x02\x08\x01\x12\x04\x95\x06\x10%\n\
    \x0f\n\x07\x04!\x04\x02\x02\x08\x02\x12\x04\x95\x06()\n\x0e\n\x04\x04!\
    \x04\x03\x12\x06\x98\x06\x08\x9d\x06\t\n\r\n\x05\x04!\x04\x03\x01\x12\
    \x04\x98\x06\r$\n\x0e\n\x06\x04!\x04\x03\x02\0\x12\x04\x99\x06\x10\x1e\n\
    \x0f\n\x07\x04!\x04\x03\x02\0\x01\x12\x04\x99\x06\x10\x19\n\x0f\n\x07\
    \x04!\x04\x03\x02\0\x02\x12\x04\x99\x06\x1c\x1d\n\x0e\n\x06\x04!\x04\x03\
    \x02\x01\x12\x04\x9a\x06\x10\x1c\n\x0f\n\x07\x04!\x04\x03\x02\x01\x01\
    \x12\x04\x9a\x06\x10\x17\n\x0f\n\x07\x04!\x04\x03\x02\x01\x02\x12\x04\
    \x9a\x06\x1a\x1b\n\x0e\n\x06\x04!\x04\x03\x02\x02\x12\x04\x9b\x06\x10\
    \x1d\n\x0f\n\x07\x04!\x04\x03\x02\x02\x01\x12\x04\x9b\x06\x10\x18\n\x0f\
    \n\x07\x04!\x04\x03\x02\x02\x02\x12\x04\x9b\x06\x1b\x1c\n\x0e\n\x06\x04!\
    \x04\x03\x02\x03\x12\x04\x9c\x06\x10\x1a\n\x0f\n\x07\x04!\x04\x03\x02\
    \x03\x01\x12\x04\x9c\x06\x10\x15\n\x0f\n\x07\x04!\x04\x03\x02\x03\x02\
    \x12\x04\x9c\x06\x18\x19\n\x0c\n\x04\x04!\x02\0\x12\x04\x9f\x06\x08\x1f\
    \n\r\n\x05\x04!\x02\0\x04\x12\x04\x9f\x06\x08\x10\n\r\n\x05\x04!\x02\0\
    \x05\x12\x04\x9f\x06\x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\x9f\x06\
    \x18\x1a\n\r\n\x05\x04!\x02\0\x03\x12\x04\x9f\x06\x1d\x1e\n\x0c\n\x04\
    \x04!\x02\x01\x12\x04\xa0\x06\x08!\n\r\n\x05\x04!\x02\x01\x04\x12\x04\
    \xa0\x06\x08\x10\n\r\n\x05\x04!\x02\x01\x05\x12\x04\xa0\x06\x11\x17\n\r\
    \n\x05\x04!\x02\x01\x01\x12\x04\xa0\x06\x18\x1c\n\r\n\x05\x04!\x02\x01\
    \x03\x12\x04\xa0\x06\x1f\x20\n\x0c\n\x04\x04!\x02\x02\x12\x04\xa1\x06\
    \x08?\n\r\n\x05\x04!\x02\x02\x04\x12\x04\xa1\x06\x08\x10\n\r\n\x05\x04!\
    \x02\x02\x06\x12\x04\xa1\x06\x115\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xa1\
    \x066:\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xa1\x06=>\n\x0c\n\x04\x04!\x02\
    \x03\x12\x04\xa2\x06\x08H\n\r\n\x05\x04!\x02\x03\x04\x12\x04\xa2\x06\x08\
    \x10\n\r\n\x05\x04!\x02\x03\x06\x12\x04\xa2\x06\x11=\n\r\n\x05\x04!\x02\
    \x03\x01\x12\x04\xa2\x06>C\n\r\n\x05\x04!\x02\x03\x03\x12\x04\xa2\x06FG\
    \n\x0c\n\x04\x04!\x02\x04\x12\x04\xa3\x06\x08%\n\r\n\x05\x04!\x02\x04\
    \x04\x12\x04\xa3\x06\x08\x10\n\r\n\x05\x04!\x02\x04\x05\x12\x04\xa3\x06\
    \x11\x17\n\r\n\x05\x04!\x02\x04\x01\x12\x04\xa3\x06\x18\x20\n\r\n\x05\
    \x04!\x02\x04\x03\x12\x04\xa3\x06#$\n\x0c\n\x04\x04!\x02\x05\x12\x04\xa4\
    \x06\x082\n\r\n\x05\x04!\x02\x05\x04\x12\x04\xa4\x06\x08\x10\n\r\n\x05\
    \x04!\x02\x05\x06\x12\x04\xa4\x06\x11%\n\r\n\x05\x04!\x02\x05\x01\x12\
    \x04\xa4\x06&-\n\r\n\x05\x04!\x02\x05\x03\x12\x04\xa4\x0601\n\x0c\n\x04\
    \x04!\x02\x06\x12\x04\xa5\x06\x08,\n\r\n\x05\x04!\x02\x06\x04\x12\x04\
    \xa5\x06\x08\x10\n\r\n\x05\x04!\x02\x06\x05\x12\x04\xa5\x06\x11\x17\n\r\
    \n\x05\x04!\x02\x06\x01\x12\x04\xa5\x06\x18'\n\r\n\x05\x04!\x02\x06\x03\
    \x12\x04\xa5\x06*+\n\x0c\n\x04\x04!\x02\x07\x12\x04\xa6\x06\x08'\n\r\n\
    \x05\x04!\x02\x07\x04\x12\x04\xa6\x06\x08\x10\n\r\n\x05\x04!\x02\x07\x05\
    \x12\x04\xa6\x06\x11\x17\n\r\n\x05\x04!\x02\x07\x01\x12\x04\xa6\x06\x18\
    \"\n\r\n\x05\x04!\x02\x07\x03\x12\x04\xa6\x06%&\n\x0c\n\x04\x04!\x02\x08\
    \x12\x04\xa7\x06\x08F\n\r\n\x05\x04!\x02\x08\x04\x12\x04\xa7\x06\x08\x10\
    \n\r\n\x05\x04!\x02\x08\x06\x12\x04\xa7\x06\x114\n\r\n\x05\x04!\x02\x08\
    \x01\x12\x04\xa7\x065A\n\r\n\x05\x04!\x02\x08\x03\x12\x04\xa7\x06DE\n\
    \x0c\n\x04\x04!\x02\t\x12\x04\xa8\x06\x08T\n\r\n\x05\x04!\x02\t\x04\x12\
    \x04\xa8\x06\x08\x10\n\r\n\x05\x04!\x02\t\x06\x12\x04\xa8\x06\x117\n\r\n\
    \x05\x04!\x02\t\x01\x12\x04\xa8\x068N\n\r\n\x05\x04!\x02\t\x03\x12\x04\
    \xa8\x06QS\n\x0c\n\x04\x04!\x02\n\x12\x04\xa9\x06\x08-\n\r\n\x05\x04!\
    \x02\n\x04\x12\x04\xa9\x06\x08\x10\n\r\n\x05\x04!\x02\n\x05\x12\x04\xa9\
    \x06\x11\x17\n\r\n\x05\x04!\x02\n\x01\x12\x04\xa9\x06\x18'\n\r\n\x05\x04\
    !\x02\n\x03\x12\x04\xa9\x06*,\n\x0c\n\x04\x04!\x02\x0b\x12\x04\xaa\x06\
    \x08+\n\r\n\x05\x04!\x02\x0b\x04\x12\x04\xaa\x06\x08\x10\n\r\n\x05\x04!\
    \x02\x0b\x05\x12\x04\xaa\x06\x11\x17\n\r\n\x05\x04!\x02\x0b\x01\x12\x04\
    \xaa\x06\x18%\n\r\n\x05\x04!\x02\x0b\x03\x12\x04\xaa\x06(*\n\x0c\n\x04\
    \x04!\x02\x0c\x12\x04\xab\x06\x083\n\r\n\x05\x04!\x02\x0c\x04\x12\x04\
    \xab\x06\x08\x10\n\r\n\x05\x04!\x02\x0c\x05\x12\x04\xab\x06\x11\x17\n\r\
    \n\x05\x04!\x02\x0c\x01\x12\x04\xab\x06\x18-\n\r\n\x05\x04!\x02\x0c\x03\
    \x12\x04\xab\x0602\n\x0c\n\x04\x04!\x02\r\x12\x04\xac\x06\x08J\n\r\n\x05\
    \x04!\x02\r\x04\x12\x04\xac\x06\x08\x10\n\r\n\x05\x04!\x02\r\x06\x12\x04\
    \xac\x06\x115\n\r\n\x05\x04!\x02\r\x01\x12\x04\xac\x066D\n\r\n\x05\x04!\
    \x02\r\x03\x12\x04\xac\x06GI\n\x0c\n\x02\x04\"\x12\x06\xaf\x06\0\xe3\x06\
    \x01\n\x0b\n\x03\x04\"\x01\x12\x04\xaf\x06\x08!\n\x0e\n\x04\x04\"\x03\0\
    \x12\x06\xb0\x06\x08\xdd\x06\t\n\r\n\x05\x04\"\x03\0\x01\x12\x04\xb0\x06\
    \x10\x1a\n\x10\n\x06\x04\"\x03\0\x03\0\x12\x06\xb1\x06\x10\xb3\x06\x11\n\
    \x0f\n\x07\x04\"\x03\0\x03\0\x01\x12\x04\xb1\x06\x18\x1f\n\x10\n\x08\x04\
    \"\x03\0\x03\0\x02\0\x12\x04\xb2\x06\x186\n\x11\n\t\x04\"\x03\0\x03\0\
    \x02\0\x04\x12\x04\xb2\x06\x18\x20\n\x11\n\t\x04\"\x03\0\x03\0\x02\0\x05\
    \x12\x04\xb2\x06!'\n\x11\n\t\x04\"\x03\0\x03\0\x02\0\x01\x12\x04\xb2\x06\
    (1\n\x11\n\t\x04\"\x03\0\x03\0\x02\0\x03\x12\x04\xb2\x0645\n\x10\n\x06\
    \x04\"\x03\0\x04\0\x12\x06\xb5\x06\x10\xbe\x06\x11\n\x0f\n\x07\x04\"\x03\
    \0\x04\0\x01\x12\x04\xb5\x06\x15$\n\x10\n\x08\x04\"\x03\0\x04\0\x02\0\
    \x12\x04\xb6\x06\x18$\n\x11\n\t\x04\"\x03\0\x04\0\x02\0\x01\x12\x04\xb6\
    \x06\x18\x1f\n\x11\n\t\x04\"\x03\0\x04\0\x02\0\x02\x12\x04\xb6\x06\"#\n\
    \x10\n\x08\x04\"\x03\0\x04\0\x02\x01\x12\x04\xb7\x06\x18!\n\x11\n\t\x04\
    \"\x03\0\x04\0\x02\x01\x01\x12\x04\xb7\x06\x18\x1c\n\x11\n\t\x04\"\x03\0\
    \x04\0\x02\x01\x02\x12\x04\xb7\x06\x1f\x20\n\x10\n\x08\x04\"\x03\0\x04\0\
    \x02\x02\x12\x04\xb8\x06\x18!\n\x11\n\t\x04\"\x03\0\x04\0\x02\x02\x01\
    \x12\x04\xb8\x06\x18\x1c\n\x11\n\t\x04\"\x03\0\x04\0\x02\x02\x02\x12\x04\
    \xb8\x06\x1f\x20\n\x10\n\x08\x04\"\x03\0\x04\0\x02\x03\x12\x04\xb9\x06\
    \x18#\n\x11\n\t\x04\"\x03\0\x04\0\x02\x03\x01\x12\x04\xb9\x06\x18\x1e\n\
    \x11\n\t\x04\"\x03\0\x04\0\x02\x03\x02\x12\x04\xb9\x06!\"\n\x10\n\x08\
    \x04\"\x03\0\x04\0\x02\x04\x12\x04\xba\x06\x18$\n\x11\n\t\x04\"\x03\0\
    \x04\0\x02\x04\x01\x12\x04\xba\x06\x18\x1f\n\x11\n\t\x04\"\x03\0\x04\0\
    \x02\x04\x02\x12\x04\xba\x06\"#\n\x10\n\x08\x04\"\x03\0\x04\0\x02\x05\
    \x12\x04\xbb\x06\x18\"\n\x11\n\t\x04\"\x03\0\x04\0\x02\x05\x01\x12\x04\
    \xbb\x06\x18\x1d\n\x11\n\t\x04\"\x03\0\x04\0\x02\x05\x02\x12\x04\xbb\x06\
    \x20!\n\x10\n\x08\x04\"\x03\0\x04\0\x02\x06\x12\x04\xbc\x06\x18+\n\x11\n\
    \t\x04\"\x03\0\x04\0\x02\x06\x01\x12\x04\xbc\x06\x18&\n\x11\n\t\x04\"\
    \x03\0\x04\0\x02\x06\x02\x12\x04\xbc\x06)*\n\x10\n\x08\x04\"\x03\0\x04\0\
    \x02\x07\x12\x04\xbd\x06\x18+\n\x11\n\t\x04\"\x03\0\x04\0\x02\x07\x01\
    \x12\x04\xbd\x06\x18&\n\x11\n\t\x04\"\x03\0\x04\0\x02\x07\x02\x12\x04\
    \xbd\x06)*\n\x10\n\x06\x04\"\x03\0\x04\x01\x12\x06\xc0\x06\x10\xc9\x06\
    \x11\n\x0f\n\x07\x04\"\x03\0\x04\x01\x01\x12\x04\xc0\x06\x15\x20\n\x10\n\
    \x08\x04\"\x03\0\x04\x01\x02\0\x12\x04\xc1\x06\x18&\n\x11\n\t\x04\"\x03\
    \0\x04\x01\x02\0\x01\x12\x04\xc1\x06\x18!\n\x11\n\t\x04\"\x03\0\x04\x01\
    \x02\0\x02\x12\x04\xc1\x06$%\n\x10\n\x08\x04\"\x03\0\x04\x01\x02\x01\x12\
    \x04\xc2\x06\x18(\n\x11\n\t\x04\"\x03\0\x04\x01\x02\x01\x01\x12\x04\xc2\
    \x06\x18#\n\x11\n\t\x04\"\x03\0\x04\x01\x02\x01\x02\x12\x04\xc2\x06&'\n\
    \x10\n\x08\x04\"\x03\0\x04\x01\x02\x02\x12\x04\xc3\x06\x18(\n\x11\n\t\
    \x04\"\x03\0\x04\x01\x02\x02\x01\x12\x04\xc3\x06\x18#\n\x11\n\t\x04\"\
    \x03\0\x04\x01\x02\x02\x02\x12\x04\xc3\x06&'\n\x10\n\x08\x04\"\x03\0\x04\
    \x01\x02\x03\x12\x04\xc4\x06\x18*\n\x11\n\t\x04\"\x03\0\x04\x01\x02\x03\
    \x01\x12\x04\xc4\x06\x18%\n\x11\n\t\x04\"\x03\0\x04\x01\x02\x03\x02\x12\
    \x04\xc4\x06()\n\x10\n\x08\x04\"\x03\0\x04\x01\x02\x04\x12\x04\xc5\x06\
    \x18'\n\x11\n\t\x04\"\x03\0\x04\x01\x02\x04\x01\x12\x04\xc5\x06\x18\"\n\
    \x11\n\t\x04\"\x03\0\x04\x01\x02\x04\x02\x12\x04\xc5\x06%&\n\x10\n\x08\
    \x04\"\x03\0\x04\x01\x02\x05\x12\x04\xc6\x06\x18'\n\x11\n\t\x04\"\x03\0\
    \x04\x01\x02\x05\x01\x12\x04\xc6\x06\x18\"\n\x11\n\t\x04\"\x03\0\x04\x01\
    \x02\x05\x02\x12\x04\xc6\x06%&\n\x10\n\x08\x04\"\x03\0\x04\x01\x02\x06\
    \x12\x04\xc7\x06\x18)\n\x11\n\t\x04\"\x03\0\x04\x01\x02\x06\x01\x12\x04\
    \xc7\x06\x18$\n\x11\n\t\x04\"\x03\0\x04\x01\x02\x06\x02\x12\x04\xc7\x06'\
    (\n\x10\n\x08\x04\"\x03\0\x04\x01\x02\x07\x12\x04\xc8\x06\x18%\n\x11\n\t\
    \x04\"\x03\0\x04\x01\x02\x07\x01\x12\x04\xc8\x06\x18\x20\n\x11\n\t\x04\"\
    \x03\0\x04\x01\x02\x07\x02\x12\x04\xc8\x06#$\n\x0e\n\x06\x04\"\x03\0\x02\
    \0\x12\x04\xcb\x06\x10W\n\x0f\n\x07\x04\"\x03\0\x02\0\x04\x12\x04\xcb\
    \x06\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\0\x06\x12\x04\xcb\x06\x19M\n\
    \x0f\n\x07\x04\"\x03\0\x02\0\x01\x12\x04\xcb\x06NR\n\x0f\n\x07\x04\"\x03\
    \0\x02\0\x03\x12\x04\xcb\x06UV\n\x0e\n\x06\x04\"\x03\0\x02\x01\x12\x04\
    \xcc\x06\x10-\n\x0f\n\x07\x04\"\x03\0\x02\x01\x04\x12\x04\xcc\x06\x10\
    \x18\n\x0f\n\x07\x04\"\x03\0\x02\x01\x05\x12\x04\xcc\x06\x19\x1f\n\x0f\n\
    \x07\x04\"\x03\0\x02\x01\x01\x12\x04\xcc\x06\x20(\n\x0f\n\x07\x04\"\x03\
    \0\x02\x01\x03\x12\x04\xcc\x06+,\n\x0e\n\x06\x04\"\x03\0\x02\x02\x12\x04\
    \xcd\x06\x10:\n\x0f\n\x07\x04\"\x03\0\x02\x02\x04\x12\x04\xcd\x06\x10\
    \x18\n\x0f\n\x07\x04\"\x03\0\x02\x02\x06\x12\x04\xcd\x06\x19-\n\x0f\n\
    \x07\x04\"\x03\0\x02\x02\x01\x12\x04\xcd\x06.5\n\x0f\n\x07\x04\"\x03\0\
    \x02\x02\x03\x12\x04\xcd\x0689\n\x0e\n\x06\x04\"\x03\0\x02\x03\x12\x04\
    \xce\x06\x101\n\x0f\n\x07\x04\"\x03\0\x02\x03\x04\x12\x04\xce\x06\x10\
    \x18\n\x0f\n\x07\x04\"\x03\0\x02\x03\x05\x12\x04\xce\x06\x19\x1f\n\x0f\n\
    \x07\x04\"\x03\0\x02\x03\x01\x12\x04\xce\x06\x20,\n\x0f\n\x07\x04\"\x03\
    \0\x02\x03\x03\x12\x04\xce\x06/0\n\x0e\n\x06\x04\"\x03\0\x02\x04\x12\x04\
    \xcf\x06\x10/\n\x0f\n\x07\x04\"\x03\0\x02\x04\x04\x12\x04\xcf\x06\x10\
    \x18\n\x0f\n\x07\x04\"\x03\0\x02\x04\x05\x12\x04\xcf\x06\x19\x1f\n\x0f\n\
    \x07\x04\"\x03\0\x02\x04\x01\x12\x04\xcf\x06\x20*\n\x0f\n\x07\x04\"\x03\
    \0\x02\x04\x03\x12\x04\xcf\x06-.\n\x0e\n\x06\x04\"\x03\0\x02\x05\x12\x04\
    \xd0\x06\x10.\n\x0f\n\x07\x04\"\x03\0\x02\x05\x04\x12\x04\xd0\x06\x10\
    \x18\n\x0f\n\x07\x04\"\x03\0\x02\x05\x05\x12\x04\xd0\x06\x19\x1f\n\x0f\n\
    \x07\x04\"\x03\0\x02\x05\x01\x12\x04\xd0\x06\x20)\n\x0f\n\x07\x04\"\x03\
    \0\x02\x05\x03\x12\x04\xd0\x06,-\n\x0e\n\x06\x04\"\x03\0\x02\x06\x12\x04\
    \xd1\x06\x10+\n\x0f\n\x07\x04\"\x03\0\x02\x06\x04\x12\x04\xd1\x06\x10\
    \x18\n\x0f\n\x07\x04\"\x03\0\x02\x06\x05\x12\x04\xd1\x06\x19\x1f\n\x0f\n\
    \x07\x04\"\x03\0\x02\x06\x01\x12\x04\xd1\x06\x20&\n\x0f\n\x07\x04\"\x03\
    \0\x02\x06\x03\x12\x04\xd1\x06)*\n\x0e\n\x06\x04\"\x03\0\x02\x07\x12\x04\
    \xd2\x06\x10Z\n\x0f\n\x07\x04\"\x03\0\x02\x07\x04\x12\x04\xd2\x06\x10\
    \x18\n\x0f\n\x07\x04\"\x03\0\x02\x07\x06\x12\x04\xd2\x06\x19I\n\x0f\n\
    \x07\x04\"\x03\0\x02\x07\x01\x12\x04\xd2\x06JU\n\x0f\n\x07\x04\"\x03\0\
    \x02\x07\x03\x12\x04\xd2\x06XY\n\x0e\n\x06\x04\"\x03\0\x02\x08\x12\x04\
    \xd3\x06\x10.\n\x0f\n\x07\x04\"\x03\0\x02\x08\x04\x12\x04\xd3\x06\x10\
    \x18\n\x0f\n\x07\x04\"\x03\0\x02\x08\x05\x12\x04\xd3\x06\x19\x1f\n\x0f\n\
    \x07\x04\"\x03\0\x02\x08\x01\x12\x04\xd3\x06\x20)\n\x0f\n\x07\x04\"\x03\
    \0\x02\x08\x03\x12\x04\xd3\x06,-\n\x0e\n\x06\x04\"\x03\0\x02\t\x12\x04\
    \xd4\x06\x10S\n\x0f\n\x07\x04\"\x03\0\x02\t\x04\x12\x04\xd4\x06\x10\x18\
    \n\x0f\n\x07\x04\"\x03\0\x02\t\x06\x12\x04\xd4\x06\x19E\n\x0f\n\x07\x04\
    \"\x03\0\x02\t\x01\x12\x04\xd4\x06FM\n\x0f\n\x07\x04\"\x03\0\x02\t\x03\
    \x12\x04\xd4\x06PR\n\x0e\n\x06\x04\"\x03\0\x02\n\x12\x04\xd5\x06\x100\n\
    \x0f\n\x07\x04\"\x03\0\x02\n\x04\x12\x04\xd5\x06\x10\x18\n\x0f\n\x07\x04\
    \"\x03\0\x02\n\x05\x12\x04\xd5\x06\x19\x1f\n\x0f\n\x07\x04\"\x03\0\x02\n\
    \x01\x12\x04\xd5\x06\x20*\n\x0f\n\x07\x04\"\x03\0\x02\n\x03\x12\x04\xd5\
    \x06-/\n\x0e\n\x06\x04\"\x03\0\x02\x0b\x12\x04\xd6\x06\x10:\n\x0f\n\x07\
    \x04\"\x03\0\x02\x0b\x04\x12\x04\xd6\x06\x10\x18\n\x0f\n\x07\x04\"\x03\0\
    \x02\x0b\x05\x12\x04\xd6\x06\x19\x1f\n\x0f\n\x07\x04\"\x03\0\x02\x0b\x01\
    \x12\x04\xd6\x06\x204\n\x0f\n\x07\x04\"\x03\0\x02\x0b\x03\x12\x04\xd6\
    \x0679\n\x0e\n\x06\x04\"\x03\0\x02\x0c\x12\x04\xd7\x06\x10=\n\x0f\n\x07\
    \x04\"\x03\0\x02\x0c\x04\x12\x04\xd7\x06\x10\x18\n\x0f\n\x07\x04\"\x03\0\
    \x02\x0c\x05\x12\x04\xd7\x06\x19\x1f\n\x0f\n\x07\x04\"\x03\0\x02\x0c\x01\
    \x12\x04\xd7\x06\x207\n\x0f\n\x07\x04\"\x03\0\x02\x0c\x03\x12\x04\xd7\
    \x06:<\n\x0e\n\x06\x04\"\x03\0\x02\r\x12\x04\xd8\x06\x109\n\x0f\n\x07\
    \x04\"\x03\0\x02\r\x04\x12\x04\xd8\x06\x10\x18\n\x0f\n\x07\x04\"\x03\0\
    \x02\r\x05\x12\x04\xd8\x06\x19\x1d\n\x0f\n\x07\x04\"\x03\0\x02\r\x01\x12\
    \x04\xd8\x06\x1e3\n\x0f\n\x07\x04\"\x03\0\x02\r\x03\x12\x04\xd8\x0668\n\
    \x0e\n\x06\x04\"\x03\0\x02\x0e\x12\x04\xd9\x06\x10;\n\x0f\n\x07\x04\"\
    \x03\0\x02\x0e\x04\x12\x04\xd9\x06\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\
    \x0e\x05\x12\x04\xd9\x06\x19\x1d\n\x0f\n\x07\x04\"\x03\0\x02\x0e\x01\x12\
    \x04\xd9\x06\x1e5\n\x0f\n\x07\x04\"\x03\0\x02\x0e\x03\x12\x04\xd9\x068:\
    \n\x0e\n\x06\x04\"\x03\0\x02\x0f\x12\x04\xda\x06\x103\n\x0f\n\x07\x04\"\
    \x03\0\x02\x0f\x04\x12\x04\xda\x06\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\
    \x0f\x06\x12\x04\xda\x06\x19&\n\x0f\n\x07\x04\"\x03\0\x02\x0f\x01\x12\
    \x04\xda\x06'-\n\x0f\n\x07\x04\"\x03\0\x02\x0f\x03\x12\x04\xda\x0602\n\
    \x0e\n\x06\x04\"\x03\0\x02\x10\x12\x04\xdb\x06\x102\n\x0f\n\x07\x04\"\
    \x03\0\x02\x10\x04\x12\x04\xdb\x06\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\
    \x10\x06\x12\x04\xdb\x06\x19%\n\x0f\n\x07\x04\"\x03\0\x02\x10\x01\x12\
    \x04\xdb\x06&,\n\x0f\n\x07\x04\"\x03\0\x02\x10\x03\x12\x04\xdb\x06/1\n\
    \x0e\n\x06\x04\"\x03\0\x02\x11\x12\x04\xdc\x06\x102\n\x0f\n\x07\x04\"\
    \x03\0\x02\x11\x04\x12\x04\xdc\x06\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\
    \x11\x06\x12\x04\xdc\x06\x19\x1f\n\x0f\n\x07\x04\"\x03\0\x02\x11\x01\x12\
    \x04\xdc\x06\x20,\n\x0f\n\x07\x04\"\x03\0\x02\x11\x03\x12\x04\xdc\x06/1\
    \n\x0c\n\x04\x04\"\x02\0\x12\x04\xdf\x06\x08F\n\r\n\x05\x04\"\x02\0\x04\
    \x12\x04\xdf\x06\x08\x10\n\r\n\x05\x04\"\x02\0\x06\x12\x04\xdf\x06\x115\
    \n\r\n\x05\x04\"\x02\0\x01\x12\x04\xdf\x066A\n\r\n\x05\x04\"\x02\0\x03\
    \x12\x04\xdf\x06DE\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xe0\x06\x08>\n\r\n\
    \x05\x04\"\x02\x01\x04\x12\x04\xe0\x06\x08\x10\n\r\n\x05\x04\"\x02\x01\
    \x06\x12\x04\xe0\x06\x11%\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xe0\x06&9\
    \n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xe0\x06<=\n\x0c\n\x04\x04\"\x02\x02\
    \x12\x04\xe1\x06\x08>\n\r\n\x05\x04\"\x02\x02\x04\x12\x04\xe1\x06\x08\
    \x10\n\r\n\x05\x04\"\x02\x02\x05\x12\x04\xe1\x06\x11\x17\n\r\n\x05\x04\"\
    \x02\x02\x01\x12\x04\xe1\x06\x189\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\
    \xe1\x06<=\n\x0c\n\x04\x04\"\x02\x03\x12\x04\xe2\x06\x08E\n\r\n\x05\x04\
    \"\x02\x03\x04\x12\x04\xe2\x06\x08\x10\n\r\n\x05\x04\"\x02\x03\x05\x12\
    \x04\xe2\x06\x11\x17\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\xe2\x06\x18@\n\
    \r\n\x05\x04\"\x02\x03\x03\x12\x04\xe2\x06CD\n\x0c\n\x02\x04#\x12\x06\
    \xe5\x06\0\xec\x06\x01\n\x0b\n\x03\x04#\x01\x12\x04\xe5\x06\x08\x20\n\
    \x0e\n\x04\x04#\x03\0\x12\x06\xe6\x06\x08\xe9\x06\t\n\r\n\x05\x04#\x03\0\
    \x01\x12\x04\xe6\x06\x10\x1f\n\x0e\n\x06\x04#\x03\0\x02\0\x12\x04\xe7\
    \x06\x10-\n\x0f\n\x07\x04#\x03\0\x02\0\x04\x12\x04\xe7\x06\x10\x18\n\x0f\
    \n\x07\x04#\x03\0\x02\0\x05\x12\x04\xe7\x06\x19\x1f\n\x0f\n\x07\x04#\x03\
    \0\x02\0\x01\x12\x04\xe7\x06\x20(\n\x0f\n\x07\x04#\x03\0\x02\0\x03\x12\
    \x04\xe7\x06+,\n\x0e\n\x06\x04#\x03\0\x02\x01\x12\x04\xe8\x06\x10>\n\x0f\
    \n\x07\x04#\x03\0\x02\x01\x04\x12\x04\xe8\x06\x10\x18\n\x0f\n\x07\x04#\
    \x03\0\x02\x01\x06\x12\x04\xe8\x06\x19-\n\x0f\n\x07\x04#\x03\0\x02\x01\
    \x01\x12\x04\xe8\x06.9\n\x0f\n\x07\x04#\x03\0\x02\x01\x03\x12\x04\xe8\
    \x06<=\n\x0c\n\x04\x04#\x02\0\x12\x04\xeb\x06\x08P\n\r\n\x05\x04#\x02\0\
    \x04\x12\x04\xeb\x06\x08\x10\n\r\n\x05\x04#\x02\0\x06\x12\x04\xeb\x06\
    \x119\n\r\n\x05\x04#\x02\0\x01\x12\x04\xeb\x06:K\n\r\n\x05\x04#\x02\0\
    \x03\x12\x04\xeb\x06NO\n\x0c\n\x02\x04$\x12\x06\xee\x06\0\xfa\x06\x01\n\
    \x0b\n\x03\x04$\x01\x12\x04\xee\x06\x08\x1e\n\x0e\n\x04\x04$\x03\0\x12\
    \x06\xef\x06\x08\xf2\x06\t\n\r\n\x05\x04$\x03\0\x01\x12\x04\xef\x06\x10\
    \x16\n\x0e\n\x06\x04$\x03\0\x02\0\x12\x04\xf0\x06\x10,\n\x0f\n\x07\x04$\
    \x03\0\x02\0\x04\x12\x04\xf0\x06\x10\x18\n\x0f\n\x07\x04$\x03\0\x02\0\
    \x05\x12\x04\xf0\x06\x19\x1f\n\x0f\n\x07\x04$\x03\0\x02\0\x01\x12\x04\
    \xf0\x06\x20'\n\x0f\n\x07\x04$\x03\0\x02\0\x03\x12\x04\xf0\x06*+\n\x0e\n\
    \x06\x04$\x03\0\x02\x01\x12\x04\xf1\x06\x10)\n\x0f\n\x07\x04$\x03\0\x02\
    \x01\x04\x12\x04\xf1\x06\x10\x18\n\x0f\n\x07\x04$\x03\0\x02\x01\x05\x12\
    \x04\xf1\x06\x19\x1f\n\x0f\n\x07\x04$\x03\0\x02\x01\x01\x12\x04\xf1\x06\
    \x20$\n\x0f\n\x07\x04$\x03\0\x02\x01\x03\x12\x04\xf1\x06'(\n\x0e\n\x04\
    \x04$\x03\x01\x12\x06\xf4\x06\x08\xf7\x06\t\n\r\n\x05\x04$\x03\x01\x01\
    \x12\x04\xf4\x06\x10\x16\n\x0e\n\x06\x04$\x03\x01\x02\0\x12\x04\xf5\x06\
    \x10.\n\x0f\n\x07\x04$\x03\x01\x02\0\x04\x12\x04\xf5\x06\x10\x18\n\x0f\n\
    \x07\x04$\x03\x01\x02\0\x05\x12\x04\xf5\x06\x19\x1f\n\x0f\n\x07\x04$\x03\
    \x01\x02\0\x01\x12\x04\xf5\x06\x20)\n\x0f\n\x07\x04$\x03\x01\x02\0\x03\
    \x12\x04\xf5\x06,-\n\x0e\n\x06\x04$\x03\x01\x02\x01\x12\x04\xf6\x06\x10B\
    \n\x0f\n\x07\x04$\x03\x01\x02\x01\x04\x12\x04\xf6\x06\x10\x18\n\x0f\n\
    \x07\x04$\x03\x01\x02\x01\x06\x12\x04\xf6\x06\x196\n\x0f\n\x07\x04$\x03\
    \x01\x02\x01\x01\x12\x04\xf6\x067=\n\x0f\n\x07\x04$\x03\x01\x02\x01\x03\
    \x12\x04\xf6\x06@A\n\x0c\n\x04\x04$\x02\0\x12\x04\xf9\x06\x08;\n\r\n\x05\
    \x04$\x02\0\x04\x12\x04\xf9\x06\x08\x10\n\r\n\x05\x04$\x02\0\x06\x12\x04\
    \xf9\x06\x11.\n\r\n\x05\x04$\x02\0\x01\x12\x04\xf9\x06/6\n\r\n\x05\x04$\
    \x02\0\x03\x12\x04\xf9\x069:\n\x0c\n\x02\x04%\x12\x06\xfc\x06\0\xac\x08\
    \x01\n\x0b\n\x03\x04%\x01\x12\x04\xfc\x06\x08\x15\n\x0e\n\x04\x04%\x03\0\
    \x12\x06\xfd\x06\x08\xd8\x07\t\n\r\n\x05\x04%\x03\0\x01\x12\x04\xfd\x06\
    \x10\x16\n\x10\n\x06\x04%\x03\0\x03\0\x12\x06\xfe\x06\x10\x81\x07\x11\n\
    \x0f\n\x07\x04%\x03\0\x03\0\x01\x12\x04\xfe\x06\x18&\n\x10\n\x08\x04%\
    \x03\0\x03\0\x02\0\x12\x04\xff\x06\x186\n\x11\n\t\x04%\x03\0\x03\0\x02\0\
    \x04\x12\x04\xff\x06\x18\x20\n\x11\n\t\x04%\x03\0\x03\0\x02\0\x05\x12\
    \x04\xff\x06!'\n\x11\n\t\x04%\x03\0\x03\0\x02\0\x01\x12\x04\xff\x06(1\n\
    \x11\n\t\x04%\x03\0\x03\0\x02\0\x03\x12\x04\xff\x0645\n\x10\n\x08\x04%\
    \x03\0\x03\0\x02\x01\x12\x04\x80\x07\x181\n\x11\n\t\x04%\x03\0\x03\0\x02\
    \x01\x04\x12\x04\x80\x07\x18\x20\n\x11\n\t\x04%\x03\0\x03\0\x02\x01\x05\
    \x12\x04\x80\x07!%\n\x11\n\t\x04%\x03\0\x03\0\x02\x01\x01\x12\x04\x80\
    \x07&,\n\x11\n\t\x04%\x03\0\x03\0\x02\x01\x03\x12\x04\x80\x07/0\n\x10\n\
    \x06\x04%\x03\0\x03\x01\x12\x06\x83\x07\x10\x87\x07\x11\n\x0f\n\x07\x04%\
    \x03\0\x03\x01\x01\x12\x04\x83\x07\x18*\n\x10\n\x08\x04%\x03\0\x03\x01\
    \x02\0\x12\x04\x84\x07\x18:\n\x11\n\t\x04%\x03\0\x03\x01\x02\0\x04\x12\
    \x04\x84\x07\x18\x20\n\x11\n\t\x04%\x03\0\x03\x01\x02\0\x05\x12\x04\x84\
    \x07!'\n\x11\n\t\x04%\x03\0\x03\x01\x02\0\x01\x12\x04\x84\x07(5\n\x11\n\
    \t\x04%\x03\0\x03\x01\x02\0\x03\x12\x04\x84\x0789\n\x10\n\x08\x04%\x03\0\
    \x03\x01\x02\x01\x12\x04\x85\x07\x18;\n\x11\n\t\x04%\x03\0\x03\x01\x02\
    \x01\x04\x12\x04\x85\x07\x18\x20\n\x11\n\t\x04%\x03\0\x03\x01\x02\x01\
    \x05\x12\x04\x85\x07!'\n\x11\n\t\x04%\x03\0\x03\x01\x02\x01\x01\x12\x04\
    \x85\x07(6\n\x11\n\t\x04%\x03\0\x03\x01\x02\x01\x03\x12\x04\x85\x079:\n\
    \x10\n\x08\x04%\x03\0\x03\x01\x02\x02\x12\x04\x86\x07\x18U\n\x11\n\t\x04\
    %\x03\0\x03\x01\x02\x02\x04\x12\x04\x86\x07\x18\x20\n\x11\n\t\x04%\x03\0\
    \x03\x01\x02\x02\x06\x12\x04\x86\x07!D\n\x11\n\t\x04%\x03\0\x03\x01\x02\
    \x02\x01\x12\x04\x86\x07EP\n\x11\n\t\x04%\x03\0\x03\x01\x02\x02\x03\x12\
    \x04\x86\x07ST\n\x10\n\x06\x04%\x03\0\x04\0\x12\x06\x89\x07\x10\x8d\x07\
    \x11\n\x0f\n\x07\x04%\x03\0\x04\0\x01\x12\x04\x89\x07\x15#\n\x10\n\x08\
    \x04%\x03\0\x04\0\x02\0\x12\x04\x8a\x07\x181\n\x11\n\t\x04%\x03\0\x04\0\
    \x02\0\x01\x12\x04\x8a\x07\x18,\n\x11\n\t\x04%\x03\0\x04\0\x02\0\x02\x12\
    \x04\x8a\x07/0\n\x10\n\x08\x04%\x03\0\x04\0\x02\x01\x12\x04\x8b\x07\x180\
    \n\x11\n\t\x04%\x03\0\x04\0\x02\x01\x01\x12\x04\x8b\x07\x18+\n\x11\n\t\
    \x04%\x03\0\x04\0\x02\x01\x02\x12\x04\x8b\x07./\n\x10\n\x08\x04%\x03\0\
    \x04\0\x02\x02\x12\x04\x8c\x07\x18-\n\x11\n\t\x04%\x03\0\x04\0\x02\x02\
    \x01\x12\x04\x8c\x07\x18(\n\x11\n\t\x04%\x03\0\x04\0\x02\x02\x02\x12\x04\
    \x8c\x07+,\n\x0e\n\x06\x04%\x03\0\x02\0\x12\x04\x8f\x07\x10/\n\x0f\n\x07\
    \x04%\x03\0\x02\0\x04\x12\x04\x8f\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\
    \0\x05\x12\x04\x8f\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\0\x01\x12\x04\
    \x8f\x07\x20*\n\x0f\n\x07\x04%\x03\0\x02\0\x03\x12\x04\x8f\x07-.\n\x0e\n\
    \x06\x04%\x03\0\x02\x01\x12\x04\x90\x07\x100\n\x0f\n\x07\x04%\x03\0\x02\
    \x01\x04\x12\x04\x90\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\x01\x05\x12\
    \x04\x90\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\x01\x01\x12\x04\x90\x07\
    \x20+\n\x0f\n\x07\x04%\x03\0\x02\x01\x03\x12\x04\x90\x07./\n\x0e\n\x06\
    \x04%\x03\0\x02\x02\x12\x04\x91\x07\x10,\n\x0f\n\x07\x04%\x03\0\x02\x02\
    \x04\x12\x04\x91\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\x02\x05\x12\x04\
    \x91\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\x02\x01\x12\x04\x91\x07\x20'\
    \n\x0f\n\x07\x04%\x03\0\x02\x02\x03\x12\x04\x91\x07*+\n\x0e\n\x06\x04%\
    \x03\0\x02\x03\x12\x04\x92\x07\x10*\n\x0f\n\x07\x04%\x03\0\x02\x03\x04\
    \x12\x04\x92\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\x03\x05\x12\x04\x92\
    \x07\x19\x1e\n\x0f\n\x07\x04%\x03\0\x02\x03\x01\x12\x04\x92\x07\x1f%\n\
    \x0f\n\x07\x04%\x03\0\x02\x03\x03\x12\x04\x92\x07()\n\x0e\n\x06\x04%\x03\
    \0\x02\x04\x12\x04\x93\x07\x10*\n\x0f\n\x07\x04%\x03\0\x02\x04\x04\x12\
    \x04\x93\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\x04\x05\x12\x04\x93\x07\
    \x19\x1e\n\x0f\n\x07\x04%\x03\0\x02\x04\x01\x12\x04\x93\x07\x1f%\n\x0f\n\
    \x07\x04%\x03\0\x02\x04\x03\x12\x04\x93\x07()\n\x0e\n\x06\x04%\x03\0\x02\
    \x05\x12\x04\x94\x07\x10*\n\x0f\n\x07\x04%\x03\0\x02\x05\x04\x12\x04\x94\
    \x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\x05\x05\x12\x04\x94\x07\x19\x1e\
    \n\x0f\n\x07\x04%\x03\0\x02\x05\x01\x12\x04\x94\x07\x1f%\n\x0f\n\x07\x04\
    %\x03\0\x02\x05\x03\x12\x04\x94\x07()\n\x0e\n\x06\x04%\x03\0\x02\x06\x12\
    \x04\x95\x07\x10*\n\x0f\n\x07\x04%\x03\0\x02\x06\x04\x12\x04\x95\x07\x10\
    \x18\n\x0f\n\x07\x04%\x03\0\x02\x06\x05\x12\x04\x95\x07\x19\x1e\n\x0f\n\
    \x07\x04%\x03\0\x02\x06\x01\x12\x04\x95\x07\x1f%\n\x0f\n\x07\x04%\x03\0\
    \x02\x06\x03\x12\x04\x95\x07()\n\x0e\n\x06\x04%\x03\0\x02\x07\x12\x04\
    \x96\x07\x10*\n\x0f\n\x07\x04%\x03\0\x02\x07\x04\x12\x04\x96\x07\x10\x18\
    \n\x0f\n\x07\x04%\x03\0\x02\x07\x05\x12\x04\x96\x07\x19\x1e\n\x0f\n\x07\
    \x04%\x03\0\x02\x07\x01\x12\x04\x96\x07\x1f%\n\x0f\n\x07\x04%\x03\0\x02\
    \x07\x03\x12\x04\x96\x07()\n\x0e\n\x06\x04%\x03\0\x02\x08\x12\x04\x97\
    \x07\x10*\n\x0f\n\x07\x04%\x03\0\x02\x08\x04\x12\x04\x97\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x08\x05\x12\x04\x97\x07\x19\x1e\n\x0f\n\x07\
    \x04%\x03\0\x02\x08\x01\x12\x04\x97\x07\x1f%\n\x0f\n\x07\x04%\x03\0\x02\
    \x08\x03\x12\x04\x97\x07()\n\x0e\n\x06\x04%\x03\0\x02\t\x12\x04\x98\x07\
    \x10+\n\x0f\n\x07\x04%\x03\0\x02\t\x04\x12\x04\x98\x07\x10\x18\n\x0f\n\
    \x07\x04%\x03\0\x02\t\x05\x12\x04\x98\x07\x19\x1e\n\x0f\n\x07\x04%\x03\0\
    \x02\t\x01\x12\x04\x98\x07\x1f%\n\x0f\n\x07\x04%\x03\0\x02\t\x03\x12\x04\
    \x98\x07(*\n\x0e\n\x06\x04%\x03\0\x02\n\x12\x04\x99\x07\x10+\n\x0f\n\x07\
    \x04%\x03\0\x02\n\x04\x12\x04\x99\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\
    \n\x05\x12\x04\x99\x07\x19\x1e\n\x0f\n\x07\x04%\x03\0\x02\n\x01\x12\x04\
    \x99\x07\x1f%\n\x0f\n\x07\x04%\x03\0\x02\n\x03\x12\x04\x99\x07(*\n\x0e\n\
    \x06\x04%\x03\0\x02\x0b\x12\x04\x9a\x07\x10+\n\x0f\n\x07\x04%\x03\0\x02\
    \x0b\x04\x12\x04\x9a\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\x0b\x05\x12\
    \x04\x9a\x07\x19\x1e\n\x0f\n\x07\x04%\x03\0\x02\x0b\x01\x12\x04\x9a\x07\
    \x1f%\n\x0f\n\x07\x04%\x03\0\x02\x0b\x03\x12\x04\x9a\x07(*\n\x0e\n\x06\
    \x04%\x03\0\x02\x0c\x12\x04\x9b\x07\x10+\n\x0f\n\x07\x04%\x03\0\x02\x0c\
    \x04\x12\x04\x9b\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\x0c\x05\x12\x04\
    \x9b\x07\x19\x1e\n\x0f\n\x07\x04%\x03\0\x02\x0c\x01\x12\x04\x9b\x07\x1f%\
    \n\x0f\n\x07\x04%\x03\0\x02\x0c\x03\x12\x04\x9b\x07(*\n\x0e\n\x06\x04%\
    \x03\0\x02\r\x12\x04\x9c\x07\x10?\n\x0f\n\x07\x04%\x03\0\x02\r\x04\x12\
    \x04\x9c\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\r\x05\x12\x04\x9c\x07\
    \x19\x1e\n\x0f\n\x07\x04%\x03\0\x02\r\x01\x12\x04\x9c\x07\x1f9\n\x0f\n\
    \x07\x04%\x03\0\x02\r\x03\x12\x04\x9c\x07<>\n\x0e\n\x06\x04%\x03\0\x02\
    \x0e\x12\x04\x9d\x07\x102\n\x0f\n\x07\x04%\x03\0\x02\x0e\x04\x12\x04\x9d\
    \x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\x0e\x05\x12\x04\x9d\x07\x19\x1e\
    \n\x0f\n\x07\x04%\x03\0\x02\x0e\x01\x12\x04\x9d\x07\x1f,\n\x0f\n\x07\x04\
    %\x03\0\x02\x0e\x03\x12\x04\x9d\x07/1\n\x0e\n\x06\x04%\x03\0\x02\x0f\x12\
    \x04\x9e\x07\x103\n\x0f\n\x07\x04%\x03\0\x02\x0f\x04\x12\x04\x9e\x07\x10\
    \x18\n\x0f\n\x07\x04%\x03\0\x02\x0f\x05\x12\x04\x9e\x07\x19\x1f\n\x0f\n\
    \x07\x04%\x03\0\x02\x0f\x01\x12\x04\x9e\x07\x20-\n\x0f\n\x07\x04%\x03\0\
    \x02\x0f\x03\x12\x04\x9e\x0702\n\x0e\n\x06\x04%\x03\0\x02\x10\x12\x04\
    \x9f\x07\x101\n\x0f\n\x07\x04%\x03\0\x02\x10\x04\x12\x04\x9f\x07\x10\x18\
    \n\x0f\n\x07\x04%\x03\0\x02\x10\x05\x12\x04\x9f\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x10\x01\x12\x04\x9f\x07\x20+\n\x0f\n\x07\x04%\x03\0\x02\
    \x10\x03\x12\x04\x9f\x07.0\n\x0e\n\x06\x04%\x03\0\x02\x11\x12\x04\xa0\
    \x07\x10.\n\x0f\n\x07\x04%\x03\0\x02\x11\x04\x12\x04\xa0\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x11\x05\x12\x04\xa0\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x11\x01\x12\x04\xa0\x07\x20(\n\x0f\n\x07\x04%\x03\0\x02\
    \x11\x03\x12\x04\xa0\x07+-\n\x0e\n\x06\x04%\x03\0\x02\x12\x12\x04\xa1\
    \x07\x10+\n\x0f\n\x07\x04%\x03\0\x02\x12\x04\x12\x04\xa1\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x12\x05\x12\x04\xa1\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x12\x01\x12\x04\xa1\x07\x20%\n\x0f\n\x07\x04%\x03\0\x02\
    \x12\x03\x12\x04\xa1\x07(*\n\x0e\n\x06\x04%\x03\0\x02\x13\x12\x04\xa2\
    \x07\x10,\n\x0f\n\x07\x04%\x03\0\x02\x13\x04\x12\x04\xa2\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x13\x05\x12\x04\xa2\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x13\x01\x12\x04\xa2\x07\x20&\n\x0f\n\x07\x04%\x03\0\x02\
    \x13\x03\x12\x04\xa2\x07)+\n\x0e\n\x06\x04%\x03\0\x02\x14\x12\x04\xa3\
    \x07\x10-\n\x0f\n\x07\x04%\x03\0\x02\x14\x04\x12\x04\xa3\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x14\x05\x12\x04\xa3\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x14\x01\x12\x04\xa3\x07\x20'\n\x0f\n\x07\x04%\x03\0\x02\
    \x14\x03\x12\x04\xa3\x07*,\n\x0e\n\x06\x04%\x03\0\x02\x15\x12\x04\xa4\
    \x07\x103\n\x0f\n\x07\x04%\x03\0\x02\x15\x04\x12\x04\xa4\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x15\x05\x12\x04\xa4\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x15\x01\x12\x04\xa4\x07\x20-\n\x0f\n\x07\x04%\x03\0\x02\
    \x15\x03\x12\x04\xa4\x0702\n\x0e\n\x06\x04%\x03\0\x02\x16\x12\x04\xa5\
    \x07\x10*\n\x0f\n\x07\x04%\x03\0\x02\x16\x04\x12\x04\xa5\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x16\x05\x12\x04\xa5\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x16\x01\x12\x04\xa5\x07\x20$\n\x0f\n\x07\x04%\x03\0\x02\
    \x16\x03\x12\x04\xa5\x07')\n\x0e\n\x06\x04%\x03\0\x02\x17\x12\x04\xa6\
    \x07\x10/\n\x0f\n\x07\x04%\x03\0\x02\x17\x04\x12\x04\xa6\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x17\x05\x12\x04\xa6\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x17\x01\x12\x04\xa6\x07\x20)\n\x0f\n\x07\x04%\x03\0\x02\
    \x17\x03\x12\x04\xa6\x07,.\n\x0e\n\x06\x04%\x03\0\x02\x18\x12\x04\xa7\
    \x07\x10,\n\x0f\n\x07\x04%\x03\0\x02\x18\x04\x12\x04\xa7\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x18\x05\x12\x04\xa7\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x18\x01\x12\x04\xa7\x07\x20&\n\x0f\n\x07\x04%\x03\0\x02\
    \x18\x03\x12\x04\xa7\x07)+\n\x0e\n\x06\x04%\x03\0\x02\x19\x12\x04\xa8\
    \x07\x102\n\x0f\n\x07\x04%\x03\0\x02\x19\x04\x12\x04\xa8\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x19\x05\x12\x04\xa8\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x19\x01\x12\x04\xa8\x07\x20,\n\x0f\n\x07\x04%\x03\0\x02\
    \x19\x03\x12\x04\xa8\x07/1\n\x0e\n\x06\x04%\x03\0\x02\x1a\x12\x04\xa9\
    \x07\x100\n\x0f\n\x07\x04%\x03\0\x02\x1a\x04\x12\x04\xa9\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x1a\x05\x12\x04\xa9\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x1a\x01\x12\x04\xa9\x07\x20*\n\x0f\n\x07\x04%\x03\0\x02\
    \x1a\x03\x12\x04\xa9\x07-/\n\x0e\n\x06\x04%\x03\0\x02\x1b\x12\x04\xaa\
    \x07\x100\n\x0f\n\x07\x04%\x03\0\x02\x1b\x04\x12\x04\xaa\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x1b\x05\x12\x04\xaa\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x1b\x01\x12\x04\xaa\x07\x20*\n\x0f\n\x07\x04%\x03\0\x02\
    \x1b\x03\x12\x04\xaa\x07-/\n\x0e\n\x06\x04%\x03\0\x02\x1c\x12\x04\xab\
    \x07\x101\n\x0f\n\x07\x04%\x03\0\x02\x1c\x04\x12\x04\xab\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x1c\x05\x12\x04\xab\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x1c\x01\x12\x04\xab\x07\x20+\n\x0f\n\x07\x04%\x03\0\x02\
    \x1c\x03\x12\x04\xab\x07.0\n\x0e\n\x06\x04%\x03\0\x02\x1d\x12\x04\xac\
    \x07\x102\n\x0f\n\x07\x04%\x03\0\x02\x1d\x04\x12\x04\xac\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x1d\x05\x12\x04\xac\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x1d\x01\x12\x04\xac\x07\x20,\n\x0f\n\x07\x04%\x03\0\x02\
    \x1d\x03\x12\x04\xac\x07/1\n\x0e\n\x06\x04%\x03\0\x02\x1e\x12\x04\xad\
    \x07\x102\n\x0f\n\x07\x04%\x03\0\x02\x1e\x04\x12\x04\xad\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x1e\x05\x12\x04\xad\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x1e\x01\x12\x04\xad\x07\x20,\n\x0f\n\x07\x04%\x03\0\x02\
    \x1e\x03\x12\x04\xad\x07/1\n\x0e\n\x06\x04%\x03\0\x02\x1f\x12\x04\xae\
    \x07\x10+\n\x0f\n\x07\x04%\x03\0\x02\x1f\x04\x12\x04\xae\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x1f\x05\x12\x04\xae\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x1f\x01\x12\x04\xae\x07\x20%\n\x0f\n\x07\x04%\x03\0\x02\
    \x1f\x03\x12\x04\xae\x07(*\n\x0e\n\x06\x04%\x03\0\x02\x20\x12\x04\xaf\
    \x07\x104\n\x0f\n\x07\x04%\x03\0\x02\x20\x04\x12\x04\xaf\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x20\x05\x12\x04\xaf\x07\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x20\x01\x12\x04\xaf\x07\x20.\n\x0f\n\x07\x04%\x03\0\x02\
    \x20\x03\x12\x04\xaf\x0713\n\x0e\n\x06\x04%\x03\0\x02!\x12\x04\xb0\x07\
    \x101\n\x0f\n\x07\x04%\x03\0\x02!\x04\x12\x04\xb0\x07\x10\x18\n\x0f\n\
    \x07\x04%\x03\0\x02!\x05\x12\x04\xb0\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\
    \x02!\x01\x12\x04\xb0\x07\x20+\n\x0f\n\x07\x04%\x03\0\x02!\x03\x12\x04\
    \xb0\x07.0\n\x0e\n\x06\x04%\x03\0\x02\"\x12\x04\xb1\x07\x10;\n\x0f\n\x07\
    \x04%\x03\0\x02\"\x04\x12\x04\xb1\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\
    \"\x05\x12\x04\xb1\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\"\x01\x12\x04\
    \xb1\x07\x205\n\x0f\n\x07\x04%\x03\0\x02\"\x03\x12\x04\xb1\x078:\n\x0e\n\
    \x06\x04%\x03\0\x02#\x12\x04\xb2\x07\x104\n\x0f\n\x07\x04%\x03\0\x02#\
    \x04\x12\x04\xb2\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02#\x05\x12\x04\xb2\
    \x07\x19\x1d\n\x0f\n\x07\x04%\x03\0\x02#\x01\x12\x04\xb2\x07\x1e.\n\x0f\
    \n\x07\x04%\x03\0\x02#\x03\x12\x04\xb2\x0713\n\x0e\n\x06\x04%\x03\0\x02$\
    \x12\x04\xb3\x07\x101\n\x0f\n\x07\x04%\x03\0\x02$\x04\x12\x04\xb3\x07\
    \x10\x18\n\x0f\n\x07\x04%\x03\0\x02$\x05\x12\x04\xb3\x07\x19\x1f\n\x0f\n\
    \x07\x04%\x03\0\x02$\x01\x12\x04\xb3\x07\x20+\n\x0f\n\x07\x04%\x03\0\x02\
    $\x03\x12\x04\xb3\x07.0\n\x0e\n\x06\x04%\x03\0\x02%\x12\x04\xb4\x07\x10=\
    \n\x0f\n\x07\x04%\x03\0\x02%\x04\x12\x04\xb4\x07\x10\x18\n\x0f\n\x07\x04\
    %\x03\0\x02%\x05\x12\x04\xb4\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02%\x01\
    \x12\x04\xb4\x07\x207\n\x0f\n\x07\x04%\x03\0\x02%\x03\x12\x04\xb4\x07:<\
    \n\x0e\n\x06\x04%\x03\0\x02&\x12\x04\xb5\x07\x10<\n\x0f\n\x07\x04%\x03\0\
    \x02&\x04\x12\x04\xb5\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02&\x05\x12\
    \x04\xb5\x07\x19\x1e\n\x0f\n\x07\x04%\x03\0\x02&\x01\x12\x04\xb5\x07\x1f\
    6\n\x0f\n\x07\x04%\x03\0\x02&\x03\x12\x04\xb5\x079;\n\x0e\n\x06\x04%\x03\
    \0\x02'\x12\x04\xb6\x07\x105\n\x0f\n\x07\x04%\x03\0\x02'\x04\x12\x04\xb6\
    \x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02'\x05\x12\x04\xb6\x07\x19\x1f\n\
    \x0f\n\x07\x04%\x03\0\x02'\x01\x12\x04\xb6\x07\x20/\n\x0f\n\x07\x04%\x03\
    \0\x02'\x03\x12\x04\xb6\x0724\n\x0e\n\x06\x04%\x03\0\x02(\x12\x04\xb7\
    \x07\x10/\n\x0f\n\x07\x04%\x03\0\x02(\x04\x12\x04\xb7\x07\x10\x18\n\x0f\
    \n\x07\x04%\x03\0\x02(\x05\x12\x04\xb7\x07\x19\x20\n\x0f\n\x07\x04%\x03\
    \0\x02(\x01\x12\x04\xb7\x07!)\n\x0f\n\x07\x04%\x03\0\x02(\x03\x12\x04\
    \xb7\x07,.\n\x0e\n\x06\x04%\x03\0\x02)\x12\x04\xb8\x07\x108\n\x0f\n\x07\
    \x04%\x03\0\x02)\x04\x12\x04\xb8\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02)\
    \x05\x12\x04\xb8\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02)\x01\x12\x04\xb8\
    \x07\x202\n\x0f\n\x07\x04%\x03\0\x02)\x03\x12\x04\xb8\x0757\n\x0e\n\x06\
    \x04%\x03\0\x02*\x12\x04\xb9\x07\x109\n\x0f\n\x07\x04%\x03\0\x02*\x04\
    \x12\x04\xb9\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02*\x05\x12\x04\xb9\x07\
    \x19\x1f\n\x0f\n\x07\x04%\x03\0\x02*\x01\x12\x04\xb9\x07\x203\n\x0f\n\
    \x07\x04%\x03\0\x02*\x03\x12\x04\xb9\x0768\n\x0e\n\x06\x04%\x03\0\x02+\
    \x12\x04\xba\x07\x109\n\x0f\n\x07\x04%\x03\0\x02+\x04\x12\x04\xba\x07\
    \x10\x18\n\x0f\n\x07\x04%\x03\0\x02+\x05\x12\x04\xba\x07\x19\x1f\n\x0f\n\
    \x07\x04%\x03\0\x02+\x01\x12\x04\xba\x07\x203\n\x0f\n\x07\x04%\x03\0\x02\
    +\x03\x12\x04\xba\x0768\n\x0e\n\x06\x04%\x03\0\x02,\x12\x04\xbb\x07\x101\
    \n\x0f\n\x07\x04%\x03\0\x02,\x04\x12\x04\xbb\x07\x10\x18\n\x0f\n\x07\x04\
    %\x03\0\x02,\x05\x12\x04\xbb\x07\x19\x1e\n\x0f\n\x07\x04%\x03\0\x02,\x01\
    \x12\x04\xbb\x07\x1f+\n\x0f\n\x07\x04%\x03\0\x02,\x03\x12\x04\xbb\x07.0\
    \n\x0e\n\x06\x04%\x03\0\x02-\x12\x04\xbc\x07\x102\n\x0f\n\x07\x04%\x03\0\
    \x02-\x04\x12\x04\xbc\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02-\x05\x12\
    \x04\xbc\x07\x19\x1e\n\x0f\n\x07\x04%\x03\0\x02-\x01\x12\x04\xbc\x07\x1f\
    ,\n\x0f\n\x07\x04%\x03\0\x02-\x03\x12\x04\xbc\x07/1\n\x0e\n\x06\x04%\x03\
    \0\x02.\x12\x04\xbd\x07\x103\n\x0f\n\x07\x04%\x03\0\x02.\x04\x12\x04\xbd\
    \x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02.\x05\x12\x04\xbd\x07\x19\x1e\n\
    \x0f\n\x07\x04%\x03\0\x02.\x01\x12\x04\xbd\x07\x1f-\n\x0f\n\x07\x04%\x03\
    \0\x02.\x03\x12\x04\xbd\x0702\n\x0e\n\x06\x04%\x03\0\x02/\x12\x04\xbe\
    \x07\x107\n\x0f\n\x07\x04%\x03\0\x02/\x04\x12\x04\xbe\x07\x10\x18\n\x0f\
    \n\x07\x04%\x03\0\x02/\x05\x12\x04\xbe\x07\x19\x1f\n\x0f\n\x07\x04%\x03\
    \0\x02/\x01\x12\x04\xbe\x07\x201\n\x0f\n\x07\x04%\x03\0\x02/\x03\x12\x04\
    \xbe\x0746\n\x0e\n\x06\x04%\x03\0\x020\x12\x04\xbf\x07\x102\n\x0f\n\x07\
    \x04%\x03\0\x020\x04\x12\x04\xbf\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x020\
    \x05\x12\x04\xbf\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x020\x01\x12\x04\xbf\
    \x07\x20,\n\x0f\n\x07\x04%\x03\0\x020\x03\x12\x04\xbf\x07/1\n\x0e\n\x06\
    \x04%\x03\0\x021\x12\x04\xc0\x07\x104\n\x0f\n\x07\x04%\x03\0\x021\x04\
    \x12\x04\xc0\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x021\x05\x12\x04\xc0\x07\
    \x19\x1f\n\x0f\n\x07\x04%\x03\0\x021\x01\x12\x04\xc0\x07\x20.\n\x0f\n\
    \x07\x04%\x03\0\x021\x03\x12\x04\xc0\x0713\n\x0e\n\x06\x04%\x03\0\x022\
    \x12\x04\xc1\x07\x104\n\x0f\n\x07\x04%\x03\0\x022\x04\x12\x04\xc1\x07\
    \x10\x18\n\x0f\n\x07\x04%\x03\0\x022\x05\x12\x04\xc1\x07\x19\x1f\n\x0f\n\
    \x07\x04%\x03\0\x022\x01\x12\x04\xc1\x07\x20.\n\x0f\n\x07\x04%\x03\0\x02\
    2\x03\x12\x04\xc1\x0713\n\x0e\n\x06\x04%\x03\0\x023\x12\x04\xc2\x07\x10,\
    \n\x0f\n\x07\x04%\x03\0\x023\x04\x12\x04\xc2\x07\x10\x18\n\x0f\n\x07\x04\
    %\x03\0\x023\x05\x12\x04\xc2\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x023\x01\
    \x12\x04\xc2\x07\x20&\n\x0f\n\x07\x04%\x03\0\x023\x03\x12\x04\xc2\x07)+\
    \n\x0e\n\x06\x04%\x03\0\x024\x12\x04\xc3\x07\x10J\n\x0f\n\x07\x04%\x03\0\
    \x024\x04\x12\x04\xc3\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x024\x06\x12\
    \x04\xc3\x07\x193\n\x0f\n\x07\x04%\x03\0\x024\x01\x12\x04\xc3\x074D\n\
    \x0f\n\x07\x04%\x03\0\x024\x03\x12\x04\xc3\x07GI\n\x0e\n\x06\x04%\x03\0\
    \x025\x12\x04\xc4\x07\x10W\n\x0f\n\x07\x04%\x03\0\x025\x04\x12\x04\xc4\
    \x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x025\x06\x12\x04\xc4\x07\x196\n\x0f\
    \n\x07\x04%\x03\0\x025\x01\x12\x04\xc4\x077Q\n\x0f\n\x07\x04%\x03\0\x025\
    \x03\x12\x04\xc4\x07TV\n\x0e\n\x06\x04%\x03\0\x026\x12\x04\xc5\x07\x10H\
    \n\x0f\n\x07\x04%\x03\0\x026\x04\x12\x04\xc5\x07\x10\x18\n\x0f\n\x07\x04\
    %\x03\0\x026\x06\x12\x04\xc5\x07\x192\n\x0f\n\x07\x04%\x03\0\x026\x01\
    \x12\x04\xc5\x073B\n\x0f\n\x07\x04%\x03\0\x026\x03\x12\x04\xc5\x07EG\n\
    \x0e\n\x06\x04%\x03\0\x027\x12\x04\xc6\x07\x10.\n\x0f\n\x07\x04%\x03\0\
    \x027\x04\x12\x04\xc6\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x027\x05\x12\
    \x04\xc6\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x027\x01\x12\x04\xc6\x07\x20\
    (\n\x0f\n\x07\x04%\x03\0\x027\x03\x12\x04\xc6\x07+-\n\x0e\n\x06\x04%\x03\
    \0\x028\x12\x04\xc7\x07\x10/\n\x0f\n\x07\x04%\x03\0\x028\x04\x12\x04\xc7\
    \x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x028\x05\x12\x04\xc7\x07\x19\x1f\n\
    \x0f\n\x07\x04%\x03\0\x028\x01\x12\x04\xc7\x07\x20)\n\x0f\n\x07\x04%\x03\
    \0\x028\x03\x12\x04\xc7\x07,.\n\x0e\n\x06\x04%\x03\0\x029\x12\x04\xc8\
    \x07\x10S\n\x0f\n\x07\x04%\x03\0\x029\x04\x12\x04\xc8\x07\x10\x18\n\x0f\
    \n\x07\x04%\x03\0\x029\x06\x12\x04\xc8\x07\x19<\n\x0f\n\x07\x04%\x03\0\
    \x029\x01\x12\x04\xc8\x07=M\n\x0f\n\x07\x04%\x03\0\x029\x03\x12\x04\xc8\
    \x07PR\n\x0e\n\x06\x04%\x03\0\x02:\x12\x04\xc9\x07\x10<\n\x0f\n\x07\x04%\
    \x03\0\x02:\x04\x12\x04\xc9\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02:\x05\
    \x12\x04\xc9\x07\x19\x1d\n\x0f\n\x07\x04%\x03\0\x02:\x01\x12\x04\xc9\x07\
    \x1e6\n\x0f\n\x07\x04%\x03\0\x02:\x03\x12\x04\xc9\x079;\n\x0e\n\x06\x04%\
    \x03\0\x02;\x12\x04\xca\x07\x10/\n\x0f\n\x07\x04%\x03\0\x02;\x04\x12\x04\
    \xca\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02;\x05\x12\x04\xca\x07\x19\x1f\
    \n\x0f\n\x07\x04%\x03\0\x02;\x01\x12\x04\xca\x07\x20)\n\x0f\n\x07\x04%\
    \x03\0\x02;\x03\x12\x04\xca\x07,.\n\x0e\n\x06\x04%\x03\0\x02<\x12\x04\
    \xcb\x07\x104\n\x0f\n\x07\x04%\x03\0\x02<\x04\x12\x04\xcb\x07\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02<\x05\x12\x04\xcb\x07\x19\x1f\n\x0f\n\x07\x04%\
    \x03\0\x02<\x01\x12\x04\xcb\x07\x20.\n\x0f\n\x07\x04%\x03\0\x02<\x03\x12\
    \x04\xcb\x0713\n\x0e\n\x06\x04%\x03\0\x02=\x12\x04\xcc\x07\x105\n\x0f\n\
    \x07\x04%\x03\0\x02=\x04\x12\x04\xcc\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\
    \x02=\x05\x12\x04\xcc\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02=\x01\x12\
    \x04\xcc\x07\x20/\n\x0f\n\x07\x04%\x03\0\x02=\x03\x12\x04\xcc\x0724\n\
    \x0e\n\x06\x04%\x03\0\x02>\x12\x04\xcd\x07\x105\n\x0f\n\x07\x04%\x03\0\
    \x02>\x04\x12\x04\xcd\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02>\x05\x12\
    \x04\xcd\x07\x19\x1d\n\x0f\n\x07\x04%\x03\0\x02>\x01\x12\x04\xcd\x07\x1e\
    /\n\x0f\n\x07\x04%\x03\0\x02>\x03\x12\x04\xcd\x0724\n\x0e\n\x06\x04%\x03\
    \0\x02?\x12\x04\xce\x07\x10A\n\x0f\n\x07\x04%\x03\0\x02?\x04\x12\x04\xce\
    \x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02?\x05\x12\x04\xce\x07\x19\x1d\n\
    \x0f\n\x07\x04%\x03\0\x02?\x01\x12\x04\xce\x07\x1e;\n\x0f\n\x07\x04%\x03\
    \0\x02?\x03\x12\x04\xce\x07>@\n\x0e\n\x06\x04%\x03\0\x02@\x12\x04\xcf\
    \x07\x10[\n\x0f\n\x07\x04%\x03\0\x02@\x04\x12\x04\xcf\x07\x10\x18\n\x0f\
    \n\x07\x04%\x03\0\x02@\x06\x12\x04\xcf\x07\x19@\n\x0f\n\x07\x04%\x03\0\
    \x02@\x01\x12\x04\xcf\x07AU\n\x0f\n\x07\x04%\x03\0\x02@\x03\x12\x04\xcf\
    \x07XZ\n\x0e\n\x06\x04%\x03\0\x02A\x12\x04\xd0\x07\x10X\n\x0f\n\x07\x04%\
    \x03\0\x02A\x04\x12\x04\xd0\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02A\x06\
    \x12\x04\xd0\x07\x19@\n\x0f\n\x07\x04%\x03\0\x02A\x01\x12\x04\xd0\x07AR\
    \n\x0f\n\x07\x04%\x03\0\x02A\x03\x12\x04\xd0\x07UW\n\x0e\n\x06\x04%\x03\
    \0\x02B\x12\x04\xd1\x07\x102\n\x0f\n\x07\x04%\x03\0\x02B\x04\x12\x04\xd1\
    \x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02B\x05\x12\x04\xd1\x07\x19\x1f\n\
    \x0f\n\x07\x04%\x03\0\x02B\x01\x12\x04\xd1\x07\x20,\n\x0f\n\x07\x04%\x03\
    \0\x02B\x03\x12\x04\xd1\x07/1\n\x0e\n\x06\x04%\x03\0\x02C\x12\x04\xd2\
    \x07\x108\n\x0f\n\x07\x04%\x03\0\x02C\x04\x12\x04\xd2\x07\x10\x18\n\x0f\
    \n\x07\x04%\x03\0\x02C\x05\x12\x04\xd2\x07\x19\x1f\n\x0f\n\x07\x04%\x03\
    \0\x02C\x01\x12\x04\xd2\x07\x202\n\x0f\n\x07\x04%\x03\0\x02C\x03\x12\x04\
    \xd2\x0757\n\x0e\n\x06\x04%\x03\0\x02D\x12\x04\xd3\x07\x10:\n\x0f\n\x07\
    \x04%\x03\0\x02D\x04\x12\x04\xd3\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02D\
    \x05\x12\x04\xd3\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02D\x01\x12\x04\xd3\
    \x07\x204\n\x0f\n\x07\x04%\x03\0\x02D\x03\x12\x04\xd3\x0779\n\x0e\n\x06\
    \x04%\x03\0\x02E\x12\x04\xd4\x07\x102\n\x0f\n\x07\x04%\x03\0\x02E\x04\
    \x12\x04\xd4\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02E\x05\x12\x04\xd4\x07\
    \x19\x1f\n\x0f\n\x07\x04%\x03\0\x02E\x01\x12\x04\xd4\x07\x20,\n\x0f\n\
    \x07\x04%\x03\0\x02E\x03\x12\x04\xd4\x07/1\n\x0e\n\x06\x04%\x03\0\x02F\
    \x12\x04\xd5\x07\x107\n\x0f\n\x07\x04%\x03\0\x02F\x04\x12\x04\xd5\x07\
    \x10\x18\n\x0f\n\x07\x04%\x03\0\x02F\x05\x12\x04\xd5\x07\x19\x1f\n\x0f\n\
    \x07\x04%\x03\0\x02F\x01\x12\x04\xd5\x07\x201\n\x0f\n\x07\x04%\x03\0\x02\
    F\x03\x12\x04\xd5\x0746\n\x0e\n\x06\x04%\x03\0\x02G\x12\x04\xd6\x07\x107\
    \n\x0f\n\x07\x04%\x03\0\x02G\x04\x12\x04\xd6\x07\x10\x18\n\x0f\n\x07\x04\
    %\x03\0\x02G\x06\x12\x04\xd6\x07\x19%\n\x0f\n\x07\x04%\x03\0\x02G\x01\
    \x12\x04\xd6\x07&1\n\x0f\n\x07\x04%\x03\0\x02G\x03\x12\x04\xd6\x0746\n\
    \x0e\n\x06\x04%\x03\0\x02H\x12\x04\xd7\x07\x10/\n\x0f\n\x07\x04%\x03\0\
    \x02H\x04\x12\x04\xd7\x07\x10\x18\n\x0f\n\x07\x04%\x03\0\x02H\x05\x12\
    \x04\xd7\x07\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02H\x01\x12\x04\xd7\x07\x20\
    )\n\x0f\n\x07\x04%\x03\0\x02H\x03\x12\x04\xd7\x07,.\n\x0e\n\x04\x04%\x03\
    \x01\x12\x06\xda\x07\x08\xdd\x07\t\n\r\n\x05\x04%\x03\x01\x01\x12\x04\
    \xda\x07\x10\x1f\n\x0e\n\x06\x04%\x03\x01\x02\0\x12\x04\xdb\x07\x10/\n\
    \x0f\n\x07\x04%\x03\x01\x02\0\x04\x12\x04\xdb\x07\x10\x18\n\x0f\n\x07\
    \x04%\x03\x01\x02\0\x05\x12\x04\xdb\x07\x19\x1f\n\x0f\n\x07\x04%\x03\x01\
    \x02\0\x01\x12\x04\xdb\x07\x20*\n\x0f\n\x07\x04%\x03\x01\x02\0\x03\x12\
    \x04\xdb\x07-.\n\x0e\n\x06\x04%\x03\x01\x02\x01\x12\x04\xdc\x07\x10)\n\
    \x0f\n\x07\x04%\x03\x01\x02\x01\x04\x12\x04\xdc\x07\x10\x18\n\x0f\n\x07\
    \x04%\x03\x01\x02\x01\x05\x12\x04\xdc\x07\x19\x1f\n\x0f\n\x07\x04%\x03\
    \x01\x02\x01\x01\x12\x04\xdc\x07\x20$\n\x0f\n\x07\x04%\x03\x01\x02\x01\
    \x03\x12\x04\xdc\x07'(\n\x0e\n\x04\x04%\x03\x02\x12\x06\xdf\x07\x08\xe4\
    \x07\t\n\r\n\x05\x04%\x03\x02\x01\x12\x04\xdf\x07\x10\"\n\x0e\n\x06\x04%\
    \x03\x02\x02\0\x12\x04\xe0\x07\x101\n\x0f\n\x07\x04%\x03\x02\x02\0\x04\
    \x12\x04\xe0\x07\x10\x18\n\x0f\n\x07\x04%\x03\x02\x02\0\x05\x12\x04\xe0\
    \x07\x19\x1f\n\x0f\n\x07\x04%\x03\x02\x02\0\x01\x12\x04\xe0\x07\x20,\n\
    \x0f\n\x07\x04%\x03\x02\x02\0\x03\x12\x04\xe0\x07/0\n\x0e\n\x06\x04%\x03\
    \x02\x02\x01\x12\x04\xe1\x07\x100\n\x0f\n\x07\x04%\x03\x02\x02\x01\x04\
    \x12\x04\xe1\x07\x10\x18\n\x0f\n\x07\x04%\x03\x02\x02\x01\x05\x12\x04\
    \xe1\x07\x19\x1f\n\x0f\n\x07\x04%\x03\x02\x02\x01\x01\x12\x04\xe1\x07\
    \x20+\n\x0f\n\x07\x04%\x03\x02\x02\x01\x03\x12\x04\xe1\x07./\n\x0e\n\x06\
    \x04%\x03\x02\x02\x02\x12\x04\xe2\x07\x10M\n\x0f\n\x07\x04%\x03\x02\x02\
    \x02\x04\x12\x04\xe2\x07\x10\x18\n\x0f\n\x07\x04%\x03\x02\x02\x02\x06\
    \x12\x04\xe2\x07\x196\n\x0f\n\x07\x04%\x03\x02\x02\x02\x01\x12\x04\xe2\
    \x077H\n\x0f\n\x07\x04%\x03\x02\x02\x02\x03\x12\x04\xe2\x07KL\n\x0e\n\
    \x06\x04%\x03\x02\x02\x03\x12\x04\xe3\x07\x102\n\x0f\n\x07\x04%\x03\x02\
    \x02\x03\x04\x12\x04\xe3\x07\x10\x18\n\x0f\n\x07\x04%\x03\x02\x02\x03\
    \x05\x12\x04\xe3\x07\x19\x1f\n\x0f\n\x07\x04%\x03\x02\x02\x03\x01\x12\
    \x04\xe3\x07\x20-\n\x0f\n\x07\x04%\x03\x02\x02\x03\x03\x12\x04\xe3\x0701\
    \n\x0e\n\x04\x04%\x03\x03\x12\x06\xe6\x07\x08\xed\x07\t\n\r\n\x05\x04%\
    \x03\x03\x01\x12\x04\xe6\x07\x10\x15\n\x0e\n\x06\x04%\x03\x03\x02\0\x12\
    \x04\xe7\x07\x10/\n\x0f\n\x07\x04%\x03\x03\x02\0\x04\x12\x04\xe7\x07\x10\
    \x18\n\x0f\n\x07\x04%\x03\x03\x02\0\x05\x12\x04\xe7\x07\x19\x1f\n\x0f\n\
    \x07\x04%\x03\x03\x02\0\x01\x12\x04\xe7\x07\x20*\n\x0f\n\x07\x04%\x03\
    \x03\x02\0\x03\x12\x04\xe7\x07-.\n\x0e\n\x06\x04%\x03\x03\x02\x01\x12\
    \x04\xe8\x07\x10/\n\x0f\n\x07\x04%\x03\x03\x02\x01\x04\x12\x04\xe8\x07\
    \x10\x18\n\x0f\n\x07\x04%\x03\x03\x02\x01\x05\x12\x04\xe8\x07\x19\x1f\n\
    \x0f\n\x07\x04%\x03\x03\x02\x01\x01\x12\x04\xe8\x07\x20*\n\x0f\n\x07\x04\
    %\x03\x03\x02\x01\x03\x12\x04\xe8\x07-.\n\x0e\n\x06\x04%\x03\x03\x02\x02\
    \x12\x04\xe9\x07\x101\n\x0f\n\x07\x04%\x03\x03\x02\x02\x04\x12\x04\xe9\
    \x07\x10\x18\n\x0f\n\x07\x04%\x03\x03\x02\x02\x05\x12\x04\xe9\x07\x19\
    \x1f\n\x0f\n\x07\x04%\x03\x03\x02\x02\x01\x12\x04\xe9\x07\x20,\n\x0f\n\
    \x07\x04%\x03\x03\x02\x02\x03\x12\x04\xe9\x07/0\n\x0e\n\x06\x04%\x03\x03\
    \x02\x03\x12\x04\xea\x07\x10/\n\x0f\n\x07\x04%\x03\x03\x02\x03\x04\x12\
    \x04\xea\x07\x10\x18\n\x0f\n\x07\x04%\x03\x03\x02\x03\x05\x12\x04\xea\
    \x07\x19\x1f\n\x0f\n\x07\x04%\x03\x03\x02\x03\x01\x12\x04\xea\x07\x20*\n\
    \x0f\n\x07\x04%\x03\x03\x02\x03\x03\x12\x04\xea\x07-.\n\x0e\n\x06\x04%\
    \x03\x03\x02\x04\x12\x04\xeb\x07\x103\n\x0f\n\x07\x04%\x03\x03\x02\x04\
    \x04\x12\x04\xeb\x07\x10\x18\n\x0f\n\x07\x04%\x03\x03\x02\x04\x05\x12\
    \x04\xeb\x07\x19\x1f\n\x0f\n\x07\x04%\x03\x03\x02\x04\x01\x12\x04\xeb\
    \x07\x20.\n\x0f\n\x07\x04%\x03\x03\x02\x04\x03\x12\x04\xeb\x0712\n\x0e\n\
    \x06\x04%\x03\x03\x02\x05\x12\x04\xec\x07\x103\n\x0f\n\x07\x04%\x03\x03\
    \x02\x05\x04\x12\x04\xec\x07\x10\x18\n\x0f\n\x07\x04%\x03\x03\x02\x05\
    \x05\x12\x04\xec\x07\x19\x1d\n\x0f\n\x07\x04%\x03\x03\x02\x05\x01\x12\
    \x04\xec\x07\x1e.\n\x0f\n\x07\x04%\x03\x03\x02\x05\x03\x12\x04\xec\x0712\
    \n\x0e\n\x04\x04%\x03\x04\x12\x06\xef\x07\x08\xf2\x07\t\n\r\n\x05\x04%\
    \x03\x04\x01\x12\x04\xef\x07\x10\x1e\n\x0e\n\x06\x04%\x03\x04\x02\0\x12\
    \x04\xf0\x07\x103\n\x0f\n\x07\x04%\x03\x04\x02\0\x04\x12\x04\xf0\x07\x10\
    \x18\n\x0f\n\x07\x04%\x03\x04\x02\0\x05\x12\x04\xf0\x07\x19\x1f\n\x0f\n\
    \x07\x04%\x03\x04\x02\0\x01\x12\x04\xf0\x07\x20.\n\x0f\n\x07\x04%\x03\
    \x04\x02\0\x03\x12\x04\xf0\x0712\n\x0e\n\x06\x04%\x03\x04\x02\x01\x12\
    \x04\xf1\x07\x10-\n\x0f\n\x07\x04%\x03\x04\x02\x01\x04\x12\x04\xf1\x07\
    \x10\x18\n\x0f\n\x07\x04%\x03\x04\x02\x01\x05\x12\x04\xf1\x07\x19\x1f\n\
    \x0f\n\x07\x04%\x03\x04\x02\x01\x01\x12\x04\xf1\x07\x20(\n\x0f\n\x07\x04\
    %\x03\x04\x02\x01\x03\x12\x04\xf1\x07+,\n\x0e\n\x04\x04%\x04\0\x12\x06\
    \xf4\x07\x08\xf8\x07\t\n\r\n\x05\x04%\x04\0\x01\x12\x04\xf4\x07\r\x18\n\
    \x0e\n\x06\x04%\x04\0\x02\0\x12\x04\xf5\x07\x10%\n\x0f\n\x07\x04%\x04\0\
    \x02\0\x01\x12\x04\xf5\x07\x10\x20\n\x0f\n\x07\x04%\x04\0\x02\0\x02\x12\
    \x04\xf5\x07#$\n\x0e\n\x06\x04%\x04\0\x02\x01\x12\x04\xf6\x07\x10(\n\x0f\
    \n\x07\x04%\x04\0\x02\x01\x01\x12\x04\xf6\x07\x10#\n\x0f\n\x07\x04%\x04\
    \0\x02\x01\x02\x12\x04\xf6\x07&'\n\x0e\n\x06\x04%\x04\0\x02\x02\x12\x04\
    \xf7\x07\x10#\n\x0f\n\x07\x04%\x04\0\x02\x02\x01\x12\x04\xf7\x07\x10\x1e\
    \n\x0f\n\x07\x04%\x04\0\x02\x02\x02\x12\x04\xf7\x07!\"\n\x0c\n\x04\x04%\
    \x02\0\x12\x04\xfa\x07\x08%\n\r\n\x05\x04%\x02\0\x04\x12\x04\xfa\x07\x08\
    \x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\xfa\x07\x11\x17\n\r\n\x05\x04%\x02\
    \0\x01\x12\x04\xfa\x07\x18\x20\n\r\n\x05\x04%\x02\0\x03\x12\x04\xfa\x07#\
    $\n\x0c\n\x04\x04%\x02\x01\x12\x04\xfb\x07\x08'\n\r\n\x05\x04%\x02\x01\
    \x04\x12\x04\xfb\x07\x08\x10\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xfb\x07\
    \x11\x18\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xfb\x07\x19\"\n\r\n\x05\x04%\
    \x02\x01\x03\x12\x04\xfb\x07%&\n\x0c\n\x04\x04%\x02\x02\x12\x04\xfc\x07\
    \x082\n\r\n\x05\x04%\x02\x02\x04\x12\x04\xfc\x07\x08\x10\n\r\n\x05\x04%\
    \x02\x02\x06\x12\x04\xfc\x07\x11%\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xfc\
    \x07&-\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xfc\x0701\n\x0c\n\x04\x04%\x02\
    \x03\x12\x04\xfd\x07\x08%\n\r\n\x05\x04%\x02\x03\x04\x12\x04\xfd\x07\x08\
    \x10\n\r\n\x05\x04%\x02\x03\x05\x12\x04\xfd\x07\x11\x17\n\r\n\x05\x04%\
    \x02\x03\x01\x12\x04\xfd\x07\x18\x20\n\r\n\x05\x04%\x02\x03\x03\x12\x04\
    \xfd\x07#$\n\x0c\n\x04\x04%\x02\x04\x12\x04\xfe\x07\x08)\n\r\n\x05\x04%\
    \x02\x04\x04\x12\x04\xfe\x07\x08\x10\n\r\n\x05\x04%\x02\x04\x05\x12\x04\
    \xfe\x07\x11\x17\n\r\n\x05\x04%\x02\x04\x01\x12\x04\xfe\x07\x18$\n\r\n\
    \x05\x04%\x02\x04\x03\x12\x04\xfe\x07'(\n\x0c\n\x04\x04%\x02\x05\x12\x04\
    \xff\x07\x08,\n\r\n\x05\x04%\x02\x05\x04\x12\x04\xff\x07\x08\x10\n\r\n\
    \x05\x04%\x02\x05\x05\x12\x04\xff\x07\x11\x17\n\r\n\x05\x04%\x02\x05\x01\
    \x12\x04\xff\x07\x18'\n\r\n\x05\x04%\x02\x05\x03\x12\x04\xff\x07*+\n\x0c\
    \n\x04\x04%\x02\x06\x12\x04\x80\x08\x08%\n\r\n\x05\x04%\x02\x06\x04\x12\
    \x04\x80\x08\x08\x10\n\r\n\x05\x04%\x02\x06\x05\x12\x04\x80\x08\x11\x17\
    \n\r\n\x05\x04%\x02\x06\x01\x12\x04\x80\x08\x18\x1f\n\r\n\x05\x04%\x02\
    \x06\x03\x12\x04\x80\x08\"$\n\x0c\n\x04\x04%\x02\x07\x12\x04\x81\x08\x08\
    .\n\r\n\x05\x04%\x02\x07\x04\x12\x04\x81\x08\x08\x10\n\r\n\x05\x04%\x02\
    \x07\x05\x12\x04\x81\x08\x11\x17\n\r\n\x05\x04%\x02\x07\x01\x12\x04\x81\
    \x08\x18(\n\r\n\x05\x04%\x02\x07\x03\x12\x04\x81\x08+-\n\x0c\n\x04\x04%\
    \x02\x08\x12\x04\x82\x08\x08*\n\r\n\x05\x04%\x02\x08\x04\x12\x04\x82\x08\
    \x08\x10\n\r\n\x05\x04%\x02\x08\x05\x12\x04\x82\x08\x11\x18\n\r\n\x05\
    \x04%\x02\x08\x01\x12\x04\x82\x08\x19$\n\r\n\x05\x04%\x02\x08\x03\x12\
    \x04\x82\x08')\n\x0c\n\x04\x04%\x02\t\x12\x04\x83\x08\x08(\n\r\n\x05\x04\
    %\x02\t\x04\x12\x04\x83\x08\x08\x10\n\r\n\x05\x04%\x02\t\x05\x12\x04\x83\
    \x08\x11\x18\n\r\n\x05\x04%\x02\t\x01\x12\x04\x83\x08\x19\"\n\r\n\x05\
    \x04%\x02\t\x03\x12\x04\x83\x08%'\n\x0c\n\x04\x04%\x02\n\x12\x04\x84\x08\
    \x08)\n\r\n\x05\x04%\x02\n\x04\x12\x04\x84\x08\x08\x10\n\r\n\x05\x04%\
    \x02\n\x05\x12\x04\x84\x08\x11\x17\n\r\n\x05\x04%\x02\n\x01\x12\x04\x84\
    \x08\x18#\n\r\n\x05\x04%\x02\n\x03\x12\x04\x84\x08&(\n\x0c\n\x04\x04%\
    \x02\x0b\x12\x04\x85\x08\x08(\n\r\n\x05\x04%\x02\x0b\x04\x12\x04\x85\x08\
    \x08\x10\n\r\n\x05\x04%\x02\x0b\x05\x12\x04\x85\x08\x11\x17\n\r\n\x05\
    \x04%\x02\x0b\x01\x12\x04\x85\x08\x18\"\n\r\n\x05\x04%\x02\x0b\x03\x12\
    \x04\x85\x08%'\n\x0c\n\x04\x04%\x02\x0c\x12\x04\x86\x08\x08+\n\r\n\x05\
    \x04%\x02\x0c\x04\x12\x04\x86\x08\x08\x10\n\r\n\x05\x04%\x02\x0c\x05\x12\
    \x04\x86\x08\x11\x17\n\r\n\x05\x04%\x02\x0c\x01\x12\x04\x86\x08\x18%\n\r\
    \n\x05\x04%\x02\x0c\x03\x12\x04\x86\x08(*\n\x0c\n\x04\x04%\x02\r\x12\x04\
    \x87\x08\x08+\n\r\n\x05\x04%\x02\r\x04\x12\x04\x87\x08\x08\x10\n\r\n\x05\
    \x04%\x02\r\x05\x12\x04\x87\x08\x11\x17\n\r\n\x05\x04%\x02\r\x01\x12\x04\
    \x87\x08\x18%\n\r\n\x05\x04%\x02\r\x03\x12\x04\x87\x08(*\n\x0c\n\x04\x04\
    %\x02\x0e\x12\x04\x88\x08\x08)\n\r\n\x05\x04%\x02\x0e\x04\x12\x04\x88\
    \x08\x08\x10\n\r\n\x05\x04%\x02\x0e\x05\x12\x04\x88\x08\x11\x16\n\r\n\
    \x05\x04%\x02\x0e\x01\x12\x04\x88\x08\x17#\n\r\n\x05\x04%\x02\x0e\x03\
    \x12\x04\x88\x08&(\n\x0c\n\x04\x04%\x02\x0f\x12\x04\x89\x08\x08-\n\r\n\
    \x05\x04%\x02\x0f\x04\x12\x04\x89\x08\x08\x10\n\r\n\x05\x04%\x02\x0f\x05\
    \x12\x04\x89\x08\x11\x17\n\r\n\x05\x04%\x02\x0f\x01\x12\x04\x89\x08\x18'\
    \n\r\n\x05\x04%\x02\x0f\x03\x12\x04\x89\x08*,\n\x0c\n\x04\x04%\x02\x10\
    \x12\x04\x8a\x08\x08*\n\r\n\x05\x04%\x02\x10\x04\x12\x04\x8a\x08\x08\x10\
    \n\r\n\x05\x04%\x02\x10\x05\x12\x04\x8a\x08\x11\x17\n\r\n\x05\x04%\x02\
    \x10\x01\x12\x04\x8a\x08\x18$\n\r\n\x05\x04%\x02\x10\x03\x12\x04\x8a\x08\
    ')\n\x0c\n\x04\x04%\x02\x11\x12\x04\x8b\x08\x08&\n\r\n\x05\x04%\x02\x11\
    \x04\x12\x04\x8b\x08\x08\x10\n\r\n\x05\x04%\x02\x11\x05\x12\x04\x8b\x08\
    \x11\x17\n\r\n\x05\x04%\x02\x11\x01\x12\x04\x8b\x08\x18\x20\n\r\n\x05\
    \x04%\x02\x11\x03\x12\x04\x8b\x08#%\n\x0c\n\x04\x04%\x02\x12\x12\x04\x8c\
    \x08\x08/\n\r\n\x05\x04%\x02\x12\x04\x12\x04\x8c\x08\x08\x10\n\r\n\x05\
    \x04%\x02\x12\x05\x12\x04\x8c\x08\x11\x17\n\r\n\x05\x04%\x02\x12\x01\x12\
    \x04\x8c\x08\x18)\n\r\n\x05\x04%\x02\x12\x03\x12\x04\x8c\x08,.\n\x0c\n\
    \x04\x04%\x02\x13\x12\x04\x8d\x08\x08,\n\r\n\x05\x04%\x02\x13\x04\x12\
    \x04\x8d\x08\x08\x10\n\r\n\x05\x04%\x02\x13\x05\x12\x04\x8d\x08\x11\x17\
    \n\r\n\x05\x04%\x02\x13\x01\x12\x04\x8d\x08\x18&\n\r\n\x05\x04%\x02\x13\
    \x03\x12\x04\x8d\x08)+\n\x0c\n\x04\x04%\x02\x14\x12\x04\x8e\x08\x08/\n\r\
    \n\x05\x04%\x02\x14\x04\x12\x04\x8e\x08\x08\x10\n\r\n\x05\x04%\x02\x14\
    \x05\x12\x04\x8e\x08\x11\x17\n\r\n\x05\x04%\x02\x14\x01\x12\x04\x8e\x08\
    \x18)\n\r\n\x05\x04%\x02\x14\x03\x12\x04\x8e\x08,.\n\x0c\n\x04\x04%\x02\
    \x15\x12\x04\x8f\x08\x08,\n\r\n\x05\x04%\x02\x15\x04\x12\x04\x8f\x08\x08\
    \x10\n\r\n\x05\x04%\x02\x15\x05\x12\x04\x8f\x08\x11\x17\n\r\n\x05\x04%\
    \x02\x15\x01\x12\x04\x8f\x08\x18&\n\r\n\x05\x04%\x02\x15\x03\x12\x04\x8f\
    \x08)+\n\x0c\n\x04\x04%\x02\x16\x12\x04\x90\x08\x083\n\r\n\x05\x04%\x02\
    \x16\x04\x12\x04\x90\x08\x08\x10\n\r\n\x05\x04%\x02\x16\x05\x12\x04\x90\
    \x08\x11\x17\n\r\n\x05\x04%\x02\x16\x01\x12\x04\x90\x08\x18-\n\r\n\x05\
    \x04%\x02\x16\x03\x12\x04\x90\x0802\n\x0c\n\x04\x04%\x02\x17\x12\x04\x91\
    \x08\x080\n\r\n\x05\x04%\x02\x17\x04\x12\x04\x91\x08\x08\x10\n\r\n\x05\
    \x04%\x02\x17\x05\x12\x04\x91\x08\x11\x17\n\r\n\x05\x04%\x02\x17\x01\x12\
    \x04\x91\x08\x18*\n\r\n\x05\x04%\x02\x17\x03\x12\x04\x91\x08-/\n\x0c\n\
    \x04\x04%\x02\x18\x12\x04\x92\x08\x083\n\r\n\x05\x04%\x02\x18\x04\x12\
    \x04\x92\x08\x08\x10\n\r\n\x05\x04%\x02\x18\x05\x12\x04\x92\x08\x11\x17\
    \n\r\n\x05\x04%\x02\x18\x01\x12\x04\x92\x08\x18-\n\r\n\x05\x04%\x02\x18\
    \x03\x12\x04\x92\x0802\n\x0c\n\x04\x04%\x02\x19\x12\x04\x93\x08\x080\n\r\
    \n\x05\x04%\x02\x19\x04\x12\x04\x93\x08\x08\x10\n\r\n\x05\x04%\x02\x19\
    \x05\x12\x04\x93\x08\x11\x17\n\r\n\x05\x04%\x02\x19\x01\x12\x04\x93\x08\
    \x18*\n\r\n\x05\x04%\x02\x19\x03\x12\x04\x93\x08-/\n\x0c\n\x04\x04%\x02\
    \x1a\x12\x04\x94\x08\x08,\n\r\n\x05\x04%\x02\x1a\x04\x12\x04\x94\x08\x08\
    \x10\n\r\n\x05\x04%\x02\x1a\x05\x12\x04\x94\x08\x11\x17\n\r\n\x05\x04%\
    \x02\x1a\x01\x12\x04\x94\x08\x18&\n\r\n\x05\x04%\x02\x1a\x03\x12\x04\x94\
    \x08)+\n\x0c\n\x04\x04%\x02\x1b\x12\x04\x95\x08\x08,\n\r\n\x05\x04%\x02\
    \x1b\x04\x12\x04\x95\x08\x08\x10\n\r\n\x05\x04%\x02\x1b\x05\x12\x04\x95\
    \x08\x11\x17\n\r\n\x05\x04%\x02\x1b\x01\x12\x04\x95\x08\x18&\n\r\n\x05\
    \x04%\x02\x1b\x03\x12\x04\x95\x08)+\n\x0c\n\x04\x04%\x02\x1c\x12\x04\x96\
    \x08\x08.\n\r\n\x05\x04%\x02\x1c\x04\x12\x04\x96\x08\x08\x10\n\r\n\x05\
    \x04%\x02\x1c\x06\x12\x04\x96\x08\x11\x1e\n\r\n\x05\x04%\x02\x1c\x01\x12\
    \x04\x96\x08\x1f(\n\r\n\x05\x04%\x02\x1c\x03\x12\x04\x96\x08+-\n\x0c\n\
    \x04\x04%\x02\x1d\x12\x04\x97\x08\x087\n\r\n\x05\x04%\x02\x1d\x04\x12\
    \x04\x97\x08\x08\x10\n\r\n\x05\x04%\x02\x1d\x06\x12\x04\x97\x08\x11&\n\r\
    \n\x05\x04%\x02\x1d\x01\x12\x04\x97\x08'1\n\r\n\x05\x04%\x02\x1d\x03\x12\
    \x04\x97\x0846\n\x0c\n\x04\x04%\x02\x1e\x12\x04\x98\x08\x08+\n\r\n\x05\
    \x04%\x02\x1e\x04\x12\x04\x98\x08\x08\x10\n\r\n\x05\x04%\x02\x1e\x05\x12\
    \x04\x98\x08\x11\x17\n\r\n\x05\x04%\x02\x1e\x01\x12\x04\x98\x08\x18%\n\r\
    \n\x05\x04%\x02\x1e\x03\x12\x04\x98\x08(*\n\x0c\n\x04\x04%\x02\x1f\x12\
    \x04\x99\x08\x08=\n\r\n\x05\x04%\x02\x1f\x04\x12\x04\x99\x08\x08\x10\n\r\
    \n\x05\x04%\x02\x1f\x06\x12\x04\x99\x08\x11*\n\r\n\x05\x04%\x02\x1f\x01\
    \x12\x04\x99\x08+7\n\r\n\x05\x04%\x02\x1f\x03\x12\x04\x99\x08:<\n\x0c\n\
    \x04\x04%\x02\x20\x12\x04\x9a\x08\x08.\n\r\n\x05\x04%\x02\x20\x04\x12\
    \x04\x9a\x08\x08\x10\n\r\n\x05\x04%\x02\x20\x05\x12\x04\x9a\x08\x11\x17\
    \n\r\n\x05\x04%\x02\x20\x01\x12\x04\x9a\x08\x18(\n\r\n\x05\x04%\x02\x20\
    \x03\x12\x04\x9a\x08+-\n\x0c\n\x04\x04%\x02!\x12\x04\x9b\x08\x08+\n\r\n\
    \x05\x04%\x02!\x04\x12\x04\x9b\x08\x08\x10\n\r\n\x05\x04%\x02!\x05\x12\
    \x04\x9b\x08\x11\x17\n\r\n\x05\x04%\x02!\x01\x12\x04\x9b\x08\x18%\n\r\n\
    \x05\x04%\x02!\x03\x12\x04\x9b\x08(*\n\x0c\n\x04\x04%\x02\"\x12\x04\x9c\
    \x08\x08.\n\r\n\x05\x04%\x02\"\x04\x12\x04\x9c\x08\x08\x10\n\r\n\x05\x04\
    %\x02\"\x05\x12\x04\x9c\x08\x11\x17\n\r\n\x05\x04%\x02\"\x01\x12\x04\x9c\
    \x08\x18(\n\r\n\x05\x04%\x02\"\x03\x12\x04\x9c\x08+-\n\x0c\n\x04\x04%\
    \x02#\x12\x04\x9d\x08\x08+\n\r\n\x05\x04%\x02#\x04\x12\x04\x9d\x08\x08\
    \x10\n\r\n\x05\x04%\x02#\x05\x12\x04\x9d\x08\x11\x17\n\r\n\x05\x04%\x02#\
    \x01\x12\x04\x9d\x08\x18%\n\r\n\x05\x04%\x02#\x03\x12\x04\x9d\x08(*\n\
    \x0c\n\x04\x04%\x02$\x12\x04\x9e\x08\x08'\n\r\n\x05\x04%\x02$\x04\x12\
    \x04\x9e\x08\x08\x10\n\r\n\x05\x04%\x02$\x05\x12\x04\x9e\x08\x11\x17\n\r\
    \n\x05\x04%\x02$\x01\x12\x04\x9e\x08\x18!\n\r\n\x05\x04%\x02$\x03\x12\
    \x04\x9e\x08$&\n\x0c\n\x04\x04%\x02%\x12\x04\x9f\x08\x08)\n\r\n\x05\x04%\
    \x02%\x04\x12\x04\x9f\x08\x08\x10\n\r\n\x05\x04%\x02%\x05\x12\x04\x9f\
    \x08\x11\x17\n\r\n\x05\x04%\x02%\x01\x12\x04\x9f\x08\x18#\n\r\n\x05\x04%\
    \x02%\x03\x12\x04\x9f\x08&(\n\x0c\n\x04\x04%\x02&\x12\x04\xa0\x08\x08L\n\
    \r\n\x05\x04%\x02&\x04\x12\x04\xa0\x08\x08\x10\n\r\n\x05\x04%\x02&\x06\
    \x12\x04\xa0\x08\x111\n\r\n\x05\x04%\x02&\x01\x12\x04\xa0\x082F\n\r\n\
    \x05\x04%\x02&\x03\x12\x04\xa0\x08IK\n\x0c\n\x04\x04%\x02'\x12\x04\xa1\
    \x08\x08$\n\r\n\x05\x04%\x02'\x04\x12\x04\xa1\x08\x08\x10\n\r\n\x05\x04%\
    \x02'\x05\x12\x04\xa1\x08\x11\x17\n\r\n\x05\x04%\x02'\x01\x12\x04\xa1\
    \x08\x18\x1e\n\r\n\x05\x04%\x02'\x03\x12\x04\xa1\x08!#\n\x0c\n\x04\x04%\
    \x02(\x12\x04\xa2\x08\x08D\n\r\n\x05\x04%\x02(\x04\x12\x04\xa2\x08\x08\
    \x10\n\r\n\x05\x04%\x02(\x06\x12\x04\xa2\x08\x11-\n\r\n\x05\x04%\x02(\
    \x01\x12\x04\xa2\x08.>\n\r\n\x05\x04%\x02(\x03\x12\x04\xa2\x08AC\n\x0c\n\
    \x04\x04%\x02)\x12\x04\xa3\x08\x08)\n\r\n\x05\x04%\x02)\x04\x12\x04\xa3\
    \x08\x08\x10\n\r\n\x05\x04%\x02)\x05\x12\x04\xa3\x08\x11\x17\n\r\n\x05\
    \x04%\x02)\x01\x12\x04\xa3\x08\x18#\n\r\n\x05\x04%\x02)\x03\x12\x04\xa3\
    \x08&(\n\x0c\n\x04\x04%\x02*\x12\x04\xa4\x08\x083\n\r\n\x05\x04%\x02*\
    \x04\x12\x04\xa4\x08\x08\x10\n\r\n\x05\x04%\x02*\x05\x12\x04\xa4\x08\x11\
    \x18\n\r\n\x05\x04%\x02*\x01\x12\x04\xa4\x08\x19-\n\r\n\x05\x04%\x02*\
    \x03\x12\x04\xa4\x0802\n\x0c\n\x04\x04%\x02+\x12\x04\xa5\x08\x080\n\r\n\
    \x05\x04%\x02+\x04\x12\x04\xa5\x08\x08\x10\n\r\n\x05\x04%\x02+\x05\x12\
    \x04\xa5\x08\x11\x17\n\r\n\x05\x04%\x02+\x01\x12\x04\xa5\x08\x18*\n\r\n\
    \x05\x04%\x02+\x03\x12\x04\xa5\x08-/\n\x0c\n\x04\x04%\x02,\x12\x04\xa6\
    \x08\x08-\n\r\n\x05\x04%\x02,\x04\x12\x04\xa6\x08\x08\x10\n\r\n\x05\x04%\
    \x02,\x05\x12\x04\xa6\x08\x11\x17\n\r\n\x05\x04%\x02,\x01\x12\x04\xa6\
    \x08\x18'\n\r\n\x05\x04%\x02,\x03\x12\x04\xa6\x08*,\n\x0c\n\x04\x04%\x02\
    -\x12\x04\xa7\x08\x082\n\r\n\x05\x04%\x02-\x04\x12\x04\xa7\x08\x08\x10\n\
    \r\n\x05\x04%\x02-\x06\x12\x04\xa7\x08\x11\x1e\n\r\n\x05\x04%\x02-\x01\
    \x12\x04\xa7\x08\x1f,\n\r\n\x05\x04%\x02-\x03\x12\x04\xa7\x08/1\n\x0c\n\
    \x04\x04%\x02.\x12\x04\xa8\x08\x08+\n\r\n\x05\x04%\x02.\x04\x12\x04\xa8\
    \x08\x08\x10\n\r\n\x05\x04%\x02.\x05\x12\x04\xa8\x08\x11\x17\n\r\n\x05\
    \x04%\x02.\x01\x12\x04\xa8\x08\x18%\n\r\n\x05\x04%\x02.\x03\x12\x04\xa8\
    \x08(*\n\x0c\n\x04\x04%\x02/\x12\x04\xa9\x08\x08.\n\r\n\x05\x04%\x02/\
    \x04\x12\x04\xa9\x08\x08\x10\n\r\n\x05\x04%\x02/\x05\x12\x04\xa9\x08\x11\
    \x17\n\r\n\x05\x04%\x02/\x01\x12\x04\xa9\x08\x18(\n\r\n\x05\x04%\x02/\
    \x03\x12\x04\xa9\x08+-\n\x0c\n\x04\x04%\x020\x12\x04\xaa\x08\x08/\n\r\n\
    \x05\x04%\x020\x04\x12\x04\xaa\x08\x08\x10\n\r\n\x05\x04%\x020\x05\x12\
    \x04\xaa\x08\x11\x17\n\r\n\x05\x04%\x020\x01\x12\x04\xaa\x08\x18)\n\r\n\
    \x05\x04%\x020\x03\x12\x04\xaa\x08,.\n\x0c\n\x04\x04%\x021\x12\x04\xab\
    \x08\x082\n\r\n\x05\x04%\x021\x04\x12\x04\xab\x08\x08\x10\n\r\n\x05\x04%\
    \x021\x06\x12\x04\xab\x08\x11$\n\r\n\x05\x04%\x021\x01\x12\x04\xab\x08%,\
    \n\r\n\x05\x04%\x021\x03\x12\x04\xab\x08/1\n\x0c\n\x02\x04&\x12\x06\xae\
    \x08\0\xb6\x08\x01\n\x0b\n\x03\x04&\x01\x12\x04\xae\x08\x08\x16\n\x0e\n\
    \x04\x04&\x03\0\x12\x06\xaf\x08\x08\xb2\x08\t\n\r\n\x05\x04&\x03\0\x01\
    \x12\x04\xaf\x08\x10\x1c\n\x0e\n\x06\x04&\x03\0\x02\0\x12\x04\xb0\x08\
    \x10)\n\x0f\n\x07\x04&\x03\0\x02\0\x04\x12\x04\xb0\x08\x10\x18\n\x0f\n\
    \x07\x04&\x03\0\x02\0\x05\x12\x04\xb0\x08\x19\x1f\n\x0f\n\x07\x04&\x03\0\
    \x02\0\x01\x12\x04\xb0\x08\x20$\n\x0f\n\x07\x04&\x03\0\x02\0\x03\x12\x04\
    \xb0\x08'(\n\x0e\n\x06\x04&\x03\0\x02\x01\x12\x04\xb1\x08\x10*\n\x0f\n\
    \x07\x04&\x03\0\x02\x01\x04\x12\x04\xb1\x08\x10\x18\n\x0f\n\x07\x04&\x03\
    \0\x02\x01\x05\x12\x04\xb1\x08\x19\x1f\n\x0f\n\x07\x04&\x03\0\x02\x01\
    \x01\x12\x04\xb1\x08\x20%\n\x0f\n\x07\x04&\x03\0\x02\x01\x03\x12\x04\xb1\
    \x08()\n\x0c\n\x04\x04&\x02\0\x12\x04\xb4\x08\x08'\n\r\n\x05\x04&\x02\0\
    \x04\x12\x04\xb4\x08\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\xb4\x08\
    \x11\x17\n\r\n\x05\x04&\x02\0\x01\x12\x04\xb4\x08\x18\"\n\r\n\x05\x04&\
    \x02\0\x03\x12\x04\xb4\x08%&\n\x0c\n\x04\x04&\x02\x01\x12\x04\xb5\x08\
    \x08?\n\r\n\x05\x04&\x02\x01\x04\x12\x04\xb5\x08\x08\x10\n\r\n\x05\x04&\
    \x02\x01\x06\x12\x04\xb5\x08\x11,\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xb5\
    \x08-:\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xb5\x08=>\n\x0c\n\x02\x04'\x12\
    \x06\xb8\x08\0\xcd\x08\x01\n\x0b\n\x03\x04'\x01\x12\x04\xb8\x08\x08\"\n\
    \x0c\n\x04\x04'\x02\0\x12\x04\xb9\x08\x08.\n\r\n\x05\x04'\x02\0\x04\x12\
    \x04\xb9\x08\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xb9\x08\x11\x17\n\
    \r\n\x05\x04'\x02\0\x01\x12\x04\xb9\x08\x18)\n\r\n\x05\x04'\x02\0\x03\
    \x12\x04\xb9\x08,-\n\x0c\n\x04\x04'\x02\x01\x12\x04\xba\x08\x08%\n\r\n\
    \x05\x04'\x02\x01\x04\x12\x04\xba\x08\x08\x10\n\r\n\x05\x04'\x02\x01\x05\
    \x12\x04\xba\x08\x11\x17\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xba\x08\x18\
    \x20\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xba\x08#$\n\x0c\n\x04\x04'\x02\
    \x02\x12\x04\xbb\x08\x08*\n\r\n\x05\x04'\x02\x02\x04\x12\x04\xbb\x08\x08\
    \x10\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xbb\x08\x11\x15\n\r\n\x05\x04'\
    \x02\x02\x01\x12\x04\xbb\x08\x16%\n\r\n\x05\x04'\x02\x02\x03\x12\x04\xbb\
    \x08()\n\x0c\n\x04\x04'\x02\x03\x12\x04\xbc\x08\x08$\n\r\n\x05\x04'\x02\
    \x03\x04\x12\x04\xbc\x08\x08\x10\n\r\n\x05\x04'\x02\x03\x05\x12\x04\xbc\
    \x08\x11\x17\n\r\n\x05\x04'\x02\x03\x01\x12\x04\xbc\x08\x18\x1f\n\r\n\
    \x05\x04'\x02\x03\x03\x12\x04\xbc\x08\"#\n\x0c\n\x04\x04'\x02\x04\x12\
    \x04\xbd\x08\x08&\n\r\n\x05\x04'\x02\x04\x04\x12\x04\xbd\x08\x08\x10\n\r\
    \n\x05\x04'\x02\x04\x05\x12\x04\xbd\x08\x11\x17\n\r\n\x05\x04'\x02\x04\
    \x01\x12\x04\xbd\x08\x18!\n\r\n\x05\x04'\x02\x04\x03\x12\x04\xbd\x08$%\n\
    \x0c\n\x04\x04'\x02\x05\x12\x04\xbe\x08\x08\"\n\r\n\x05\x04'\x02\x05\x04\
    \x12\x04\xbe\x08\x08\x10\n\r\n\x05\x04'\x02\x05\x05\x12\x04\xbe\x08\x11\
    \x17\n\r\n\x05\x04'\x02\x05\x01\x12\x04\xbe\x08\x18\x1d\n\r\n\x05\x04'\
    \x02\x05\x03\x12\x04\xbe\x08\x20!\n\x0c\n\x04\x04'\x02\x06\x12\x04\xbf\
    \x08\x08&\n\r\n\x05\x04'\x02\x06\x04\x12\x04\xbf\x08\x08\x10\n\r\n\x05\
    \x04'\x02\x06\x05\x12\x04\xbf\x08\x11\x17\n\r\n\x05\x04'\x02\x06\x01\x12\
    \x04\xbf\x08\x18!\n\r\n\x05\x04'\x02\x06\x03\x12\x04\xbf\x08$%\n\x0c\n\
    \x04\x04'\x02\x07\x12\x04\xc0\x08\x08(\n\r\n\x05\x04'\x02\x07\x04\x12\
    \x04\xc0\x08\x08\x10\n\r\n\x05\x04'\x02\x07\x05\x12\x04\xc0\x08\x11\x17\
    \n\r\n\x05\x04'\x02\x07\x01\x12\x04\xc0\x08\x18#\n\r\n\x05\x04'\x02\x07\
    \x03\x12\x04\xc0\x08&'\n\x0c\n\x04\x04'\x02\x08\x12\x04\xc1\x08\x08#\n\r\
    \n\x05\x04'\x02\x08\x04\x12\x04\xc1\x08\x08\x10\n\r\n\x05\x04'\x02\x08\
    \x05\x12\x04\xc1\x08\x11\x17\n\r\n\x05\x04'\x02\x08\x01\x12\x04\xc1\x08\
    \x18\x1d\n\r\n\x05\x04'\x02\x08\x03\x12\x04\xc1\x08\x20\"\n\x0c\n\x04\
    \x04'\x02\t\x12\x04\xc2\x08\x08$\n\r\n\x05\x04'\x02\t\x04\x12\x04\xc2\
    \x08\x08\x10\n\r\n\x05\x04'\x02\t\x05\x12\x04\xc2\x08\x11\x17\n\r\n\x05\
    \x04'\x02\t\x01\x12\x04\xc2\x08\x18\x1e\n\r\n\x05\x04'\x02\t\x03\x12\x04\
    \xc2\x08!#\n\x0c\n\x04\x04'\x02\n\x12\x04\xc3\x08\x08\x20\n\r\n\x05\x04'\
    \x02\n\x04\x12\x04\xc3\x08\x08\x10\n\r\n\x05\x04'\x02\n\x05\x12\x04\xc3\
    \x08\x11\x17\n\r\n\x05\x04'\x02\n\x01\x12\x04\xc3\x08\x18\x1a\n\r\n\x05\
    \x04'\x02\n\x03\x12\x04\xc3\x08\x1d\x1f\n\x0c\n\x04\x04'\x02\x0b\x12\x04\
    \xc4\x08\x08\x20\n\r\n\x05\x04'\x02\x0b\x04\x12\x04\xc4\x08\x08\x10\n\r\
    \n\x05\x04'\x02\x0b\x05\x12\x04\xc4\x08\x11\x16\n\r\n\x05\x04'\x02\x0b\
    \x01\x12\x04\xc4\x08\x17\x1a\n\r\n\x05\x04'\x02\x0b\x03\x12\x04\xc4\x08\
    \x1d\x1f\n\x0c\n\x04\x04'\x02\x0c\x12\x04\xc5\x08\x08)\n\r\n\x05\x04'\
    \x02\x0c\x04\x12\x04\xc5\x08\x08\x10\n\r\n\x05\x04'\x02\x0c\x05\x12\x04\
    \xc5\x08\x11\x17\n\r\n\x05\x04'\x02\x0c\x01\x12\x04\xc5\x08\x18#\n\r\n\
    \x05\x04'\x02\x0c\x03\x12\x04\xc5\x08&(\n\x0c\n\x04\x04'\x02\r\x12\x04\
    \xc6\x08\x08*\n\r\n\x05\x04'\x02\r\x04\x12\x04\xc6\x08\x08\x10\n\r\n\x05\
    \x04'\x02\r\x05\x12\x04\xc6\x08\x11\x17\n\r\n\x05\x04'\x02\r\x01\x12\x04\
    \xc6\x08\x18$\n\r\n\x05\x04'\x02\r\x03\x12\x04\xc6\x08')\n\x0c\n\x04\x04\
    '\x02\x0e\x12\x04\xc7\x08\x084\n\r\n\x05\x04'\x02\x0e\x04\x12\x04\xc7\
    \x08\x08\x10\n\r\n\x05\x04'\x02\x0e\x05\x12\x04\xc7\x08\x11\x16\n\r\n\
    \x05\x04'\x02\x0e\x01\x12\x04\xc7\x08\x17.\n\r\n\x05\x04'\x02\x0e\x03\
    \x12\x04\xc7\x0813\n\x0c\n\x04\x04'\x02\x0f\x12\x04\xc8\x08\x08*\n\r\n\
    \x05\x04'\x02\x0f\x04\x12\x04\xc8\x08\x08\x10\n\r\n\x05\x04'\x02\x0f\x05\
    \x12\x04\xc8\x08\x11\x17\n\r\n\x05\x04'\x02\x0f\x01\x12\x04\xc8\x08\x18$\
    \n\r\n\x05\x04'\x02\x0f\x03\x12\x04\xc8\x08')\n\x0c\n\x04\x04'\x02\x10\
    \x12\x04\xc9\x08\x08+\n\r\n\x05\x04'\x02\x10\x04\x12\x04\xc9\x08\x08\x10\
    \n\r\n\x05\x04'\x02\x10\x05\x12\x04\xc9\x08\x11\x17\n\r\n\x05\x04'\x02\
    \x10\x01\x12\x04\xc9\x08\x18%\n\r\n\x05\x04'\x02\x10\x03\x12\x04\xc9\x08\
    (*\n\x0c\n\x04\x04'\x02\x11\x12\x04\xca\x08\x08+\n\r\n\x05\x04'\x02\x11\
    \x04\x12\x04\xca\x08\x08\x10\n\r\n\x05\x04'\x02\x11\x05\x12\x04\xca\x08\
    \x11\x17\n\r\n\x05\x04'\x02\x11\x01\x12\x04\xca\x08\x18%\n\r\n\x05\x04'\
    \x02\x11\x03\x12\x04\xca\x08(*\n\x0c\n\x04\x04'\x02\x12\x12\x04\xcb\x08\
    \x08)\n\r\n\x05\x04'\x02\x12\x04\x12\x04\xcb\x08\x08\x10\n\r\n\x05\x04'\
    \x02\x12\x05\x12\x04\xcb\x08\x11\x17\n\r\n\x05\x04'\x02\x12\x01\x12\x04\
    \xcb\x08\x18#\n\r\n\x05\x04'\x02\x12\x03\x12\x04\xcb\x08&(\n\x0c\n\x04\
    \x04'\x02\x13\x12\x04\xcc\x08\x08\"\n\r\n\x05\x04'\x02\x13\x04\x12\x04\
    \xcc\x08\x08\x10\n\r\n\x05\x04'\x02\x13\x05\x12\x04\xcc\x08\x11\x16\n\r\
    \n\x05\x04'\x02\x13\x01\x12\x04\xcc\x08\x17\x1c\n\r\n\x05\x04'\x02\x13\
    \x03\x12\x04\xcc\x08\x1f!\n\x0c\n\x02\x04(\x12\x06\xcf\x08\0\xd1\x08\x01\
    \n\x0b\n\x03\x04(\x01\x12\x04\xcf\x08\x08'\n\x0c\n\x04\x04(\x02\0\x12\
    \x04\xd0\x08\x088\n\r\n\x05\x04(\x02\0\x04\x12\x04\xd0\x08\x08\x10\n\r\n\
    \x05\x04(\x02\0\x06\x12\x04\xd0\x08\x11+\n\r\n\x05\x04(\x02\0\x01\x12\
    \x04\xd0\x08,3\n\r\n\x05\x04(\x02\0\x03\x12\x04\xd0\x0867\n\x0c\n\x02\
    \x04)\x12\x06\xd3\x08\0\xfe\x08\x01\n\x0b\n\x03\x04)\x01\x12\x04\xd3\x08\
    \x08\x1c\n\x0e\n\x04\x04)\x03\0\x12\x06\xd4\x08\x08\xef\x08\t\n\r\n\x05\
    \x04)\x03\0\x01\x12\x04\xd4\x08\x10\x13\n\x10\n\x06\x04)\x03\0\x03\0\x12\
    \x06\xd5\x08\x10\xdc\x08\x11\n\x0f\n\x07\x04)\x03\0\x03\0\x01\x12\x04\
    \xd5\x08\x18\x1c\n\x10\n\x08\x04)\x03\0\x03\0\x02\0\x12\x04\xd6\x08\x184\
    \n\x11\n\t\x04)\x03\0\x03\0\x02\0\x04\x12\x04\xd6\x08\x18\x20\n\x11\n\t\
    \x04)\x03\0\x03\0\x02\0\x05\x12\x04\xd6\x08!'\n\x11\n\t\x04)\x03\0\x03\0\
    \x02\0\x01\x12\x04\xd6\x08(/\n\x11\n\t\x04)\x03\0\x03\0\x02\0\x03\x12\
    \x04\xd6\x0823\n\x10\n\x08\x04)\x03\0\x03\0\x02\x01\x12\x04\xd7\x08\x182\
    \n\x11\n\t\x04)\x03\0\x03\0\x02\x01\x04\x12\x04\xd7\x08\x18\x20\n\x11\n\
    \t\x04)\x03\0\x03\0\x02\x01\x05\x12\x04\xd7\x08!&\n\x11\n\t\x04)\x03\0\
    \x03\0\x02\x01\x01\x12\x04\xd7\x08'-\n\x11\n\t\x04)\x03\0\x03\0\x02\x01\
    \x03\x12\x04\xd7\x0801\n\x10\n\x08\x04)\x03\0\x03\0\x02\x02\x12\x04\xd8\
    \x08\x189\n\x11\n\t\x04)\x03\0\x03\0\x02\x02\x04\x12\x04\xd8\x08\x18\x20\
    \n\x11\n\t\x04)\x03\0\x03\0\x02\x02\x05\x12\x04\xd8\x08!&\n\x11\n\t\x04)\
    \x03\0\x03\0\x02\x02\x01\x12\x04\xd8\x08'4\n\x11\n\t\x04)\x03\0\x03\0\
    \x02\x02\x03\x12\x04\xd8\x0878\n\x10\n\x08\x04)\x03\0\x03\0\x02\x03\x12\
    \x04\xd9\x08\x185\n\x11\n\t\x04)\x03\0\x03\0\x02\x03\x04\x12\x04\xd9\x08\
    \x18\x20\n\x11\n\t\x04)\x03\0\x03\0\x02\x03\x05\x12\x04\xd9\x08!'\n\x11\
    \n\t\x04)\x03\0\x03\0\x02\x03\x01\x12\x04\xd9\x08(0\n\x11\n\t\x04)\x03\0\
    \x03\0\x02\x03\x03\x12\x04\xd9\x0834\n\x10\n\x08\x04)\x03\0\x03\0\x02\
    \x04\x12\x04\xda\x08\x185\n\x11\n\t\x04)\x03\0\x03\0\x02\x04\x04\x12\x04\
    \xda\x08\x18\x20\n\x11\n\t\x04)\x03\0\x03\0\x02\x04\x05\x12\x04\xda\x08!\
    '\n\x11\n\t\x04)\x03\0\x03\0\x02\x04\x01\x12\x04\xda\x08(0\n\x11\n\t\x04\
    )\x03\0\x03\0\x02\x04\x03\x12\x04\xda\x0834\n\x10\n\x08\x04)\x03\0\x03\0\
    \x02\x05\x12\x04\xdb\x08\x185\n\x11\n\t\x04)\x03\0\x03\0\x02\x05\x04\x12\
    \x04\xdb\x08\x18\x20\n\x11\n\t\x04)\x03\0\x03\0\x02\x05\x05\x12\x04\xdb\
    \x08!'\n\x11\n\t\x04)\x03\0\x03\0\x02\x05\x01\x12\x04\xdb\x08(0\n\x11\n\
    \t\x04)\x03\0\x03\0\x02\x05\x03\x12\x04\xdb\x0834\n\x10\n\x06\x04)\x03\0\
    \x03\x01\x12\x06\xde\x08\x10\xe1\x08\x11\n\x0f\n\x07\x04)\x03\0\x03\x01\
    \x01\x12\x04\xde\x08\x18\x1e\n\x10\n\x08\x04)\x03\0\x03\x01\x02\0\x12\
    \x04\xdf\x08\x186\n\x11\n\t\x04)\x03\0\x03\x01\x02\0\x04\x12\x04\xdf\x08\
    \x18\x20\n\x11\n\t\x04)\x03\0\x03\x01\x02\0\x05\x12\x04\xdf\x08!'\n\x11\
    \n\t\x04)\x03\0\x03\x01\x02\0\x01\x12\x04\xdf\x08(1\n\x11\n\t\x04)\x03\0\
    \x03\x01\x02\0\x03\x12\x04\xdf\x0845\n\x10\n\x08\x04)\x03\0\x03\x01\x02\
    \x01\x12\x04\xe0\x08\x18:\n\x11\n\t\x04)\x03\0\x03\x01\x02\x01\x04\x12\
    \x04\xe0\x08\x18\x20\n\x11\n\t\x04)\x03\0\x03\x01\x02\x01\x05\x12\x04\
    \xe0\x08!'\n\x11\n\t\x04)\x03\0\x03\x01\x02\x01\x01\x12\x04\xe0\x08(5\n\
    \x11\n\t\x04)\x03\0\x03\x01\x02\x01\x03\x12\x04\xe0\x0889\n\x0e\n\x06\
    \x04)\x03\0\x02\0\x12\x04\xe3\x08\x103\n\x0f\n\x07\x04)\x03\0\x02\0\x04\
    \x12\x04\xe3\x08\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\0\x05\x12\x04\xe3\
    \x08\x19\x1e\n\x0f\n\x07\x04)\x03\0\x02\0\x01\x12\x04\xe3\x08\x1f.\n\x0f\
    \n\x07\x04)\x03\0\x02\0\x03\x12\x04\xe3\x0812\n\x0e\n\x06\x04)\x03\0\x02\
    \x01\x12\x04\xe4\x08\x10,\n\x0f\n\x07\x04)\x03\0\x02\x01\x04\x12\x04\xe4\
    \x08\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\x01\x05\x12\x04\xe4\x08\x19\x1f\
    \n\x0f\n\x07\x04)\x03\0\x02\x01\x01\x12\x04\xe4\x08\x20'\n\x0f\n\x07\x04\
    )\x03\0\x02\x01\x03\x12\x04\xe4\x08*+\n\x0e\n\x06\x04)\x03\0\x02\x02\x12\
    \x04\xe5\x08\x10/\n\x0f\n\x07\x04)\x03\0\x02\x02\x04\x12\x04\xe5\x08\x10\
    \x18\n\x0f\n\x07\x04)\x03\0\x02\x02\x05\x12\x04\xe5\x08\x19\x1f\n\x0f\n\
    \x07\x04)\x03\0\x02\x02\x01\x12\x04\xe5\x08\x20*\n\x0f\n\x07\x04)\x03\0\
    \x02\x02\x03\x12\x04\xe5\x08-.\n\x0e\n\x06\x04)\x03\0\x02\x03\x12\x04\
    \xe6\x08\x102\n\x0f\n\x07\x04)\x03\0\x02\x03\x04\x12\x04\xe6\x08\x10\x18\
    \n\x0f\n\x07\x04)\x03\0\x02\x03\x05\x12\x04\xe6\x08\x19\x1f\n\x0f\n\x07\
    \x04)\x03\0\x02\x03\x01\x12\x04\xe6\x08\x20-\n\x0f\n\x07\x04)\x03\0\x02\
    \x03\x03\x12\x04\xe6\x0801\n\x0e\n\x06\x04)\x03\0\x02\x04\x12\x04\xe7\
    \x08\x10.\n\x0f\n\x07\x04)\x03\0\x02\x04\x04\x12\x04\xe7\x08\x10\x18\n\
    \x0f\n\x07\x04)\x03\0\x02\x04\x05\x12\x04\xe7\x08\x19\x1f\n\x0f\n\x07\
    \x04)\x03\0\x02\x04\x01\x12\x04\xe7\x08\x20)\n\x0f\n\x07\x04)\x03\0\x02\
    \x04\x03\x12\x04\xe7\x08,-\n\x0e\n\x06\x04)\x03\0\x02\x05\x12\x04\xe8\
    \x08\x102\n\x0f\n\x07\x04)\x03\0\x02\x05\x04\x12\x04\xe8\x08\x10\x18\n\
    \x0f\n\x07\x04)\x03\0\x02\x05\x05\x12\x04\xe8\x08\x19\x1f\n\x0f\n\x07\
    \x04)\x03\0\x02\x05\x01\x12\x04\xe8\x08\x20-\n\x0f\n\x07\x04)\x03\0\x02\
    \x05\x03\x12\x04\xe8\x0801\n\x0e\n\x06\x04)\x03\0\x02\x06\x12\x04\xe9\
    \x08\x102\n\x0f\n\x07\x04)\x03\0\x02\x06\x04\x12\x04\xe9\x08\x10\x18\n\
    \x0f\n\x07\x04)\x03\0\x02\x06\x05\x12\x04\xe9\x08\x19\x1f\n\x0f\n\x07\
    \x04)\x03\0\x02\x06\x01\x12\x04\xe9\x08\x20-\n\x0f\n\x07\x04)\x03\0\x02\
    \x06\x03\x12\x04\xe9\x0801\n\x0e\n\x06\x04)\x03\0\x02\x07\x12\x04\xea\
    \x08\x102\n\x0f\n\x07\x04)\x03\0\x02\x07\x04\x12\x04\xea\x08\x10\x18\n\
    \x0f\n\x07\x04)\x03\0\x02\x07\x05\x12\x04\xea\x08\x19\x1f\n\x0f\n\x07\
    \x04)\x03\0\x02\x07\x01\x12\x04\xea\x08\x20-\n\x0f\n\x07\x04)\x03\0\x02\
    \x07\x03\x12\x04\xea\x0801\n\x0e\n\x06\x04)\x03\0\x02\x08\x12\x04\xeb\
    \x08\x103\n\x0f\n\x07\x04)\x03\0\x02\x08\x04\x12\x04\xeb\x08\x10\x18\n\
    \x0f\n\x07\x04)\x03\0\x02\x08\x05\x12\x04\xeb\x08\x19\x1f\n\x0f\n\x07\
    \x04)\x03\0\x02\x08\x01\x12\x04\xeb\x08\x20.\n\x0f\n\x07\x04)\x03\0\x02\
    \x08\x03\x12\x04\xeb\x0812\n\x0e\n\x06\x04)\x03\0\x02\t\x12\x04\xec\x08\
    \x103\n\x0f\n\x07\x04)\x03\0\x02\t\x04\x12\x04\xec\x08\x10\x18\n\x0f\n\
    \x07\x04)\x03\0\x02\t\x05\x12\x04\xec\x08\x19\x1e\n\x0f\n\x07\x04)\x03\0\
    \x02\t\x01\x12\x04\xec\x08\x1f-\n\x0f\n\x07\x04)\x03\0\x02\t\x03\x12\x04\
    \xec\x0802\n\x0e\n\x06\x04)\x03\0\x02\n\x12\x04\xed\x08\x10B\n\x0f\n\x07\
    \x04)\x03\0\x02\n\x04\x12\x04\xed\x08\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\
    \n\x06\x12\x04\xed\x08\x196\n\x0f\n\x07\x04)\x03\0\x02\n\x01\x12\x04\xed\
    \x087<\n\x0f\n\x07\x04)\x03\0\x02\n\x03\x12\x04\xed\x08?A\n\x0e\n\x06\
    \x04)\x03\0\x02\x0b\x12\x04\xee\x08\x10E\n\x0f\n\x07\x04)\x03\0\x02\x0b\
    \x04\x12\x04\xee\x08\x10\x18\n\x0f\n\x07\x04)\x03\0\x02\x0b\x06\x12\x04\
    \xee\x08\x198\n\x0f\n\x07\x04)\x03\0\x02\x0b\x01\x12\x04\xee\x089?\n\x0f\
    \n\x07\x04)\x03\0\x02\x0b\x03\x12\x04\xee\x08BD\n\x0c\n\x04\x04)\x02\0\
    \x12\x04\xf1\x08\x083\n\r\n\x05\x04)\x02\0\x04\x12\x04\xf1\x08\x08\x10\n\
    \r\n\x05\x04)\x02\0\x06\x12\x04\xf1\x08\x11)\n\r\n\x05\x04)\x02\0\x01\
    \x12\x04\xf1\x08*.\n\r\n\x05\x04)\x02\0\x03\x12\x04\xf1\x0812\n\x0c\n\
    \x04\x04)\x02\x01\x12\x04\xf2\x08\x080\n\r\n\x05\x04)\x02\x01\x04\x12\
    \x04\xf2\x08\x08\x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xf2\x08\x11\x16\
    \n\r\n\x05\x04)\x02\x01\x01\x12\x04\xf2\x08\x17+\n\r\n\x05\x04)\x02\x01\
    \x03\x12\x04\xf2\x08./\n\x0c\n\x04\x04)\x02\x02\x12\x04\xf3\x08\x080\n\r\
    \n\x05\x04)\x02\x02\x04\x12\x04\xf3\x08\x08\x10\n\r\n\x05\x04)\x02\x02\
    \x05\x12\x04\xf3\x08\x11\x16\n\r\n\x05\x04)\x02\x02\x01\x12\x04\xf3\x08\
    \x17+\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xf3\x08./\n\x0c\n\x04\x04)\x02\
    \x03\x12\x04\xf4\x08\x080\n\r\n\x05\x04)\x02\x03\x04\x12\x04\xf4\x08\x08\
    \x10\n\r\n\x05\x04)\x02\x03\x05\x12\x04\xf4\x08\x11\x16\n\r\n\x05\x04)\
    \x02\x03\x01\x12\x04\xf4\x08\x17+\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xf4\
    \x08./\n\x0c\n\x04\x04)\x02\x04\x12\x04\xf5\x08\x082\n\r\n\x05\x04)\x02\
    \x04\x04\x12\x04\xf5\x08\x08\x10\n\r\n\x05\x04)\x02\x04\x05\x12\x04\xf5\
    \x08\x11\x16\n\r\n\x05\x04)\x02\x04\x01\x12\x04\xf5\x08\x17-\n\r\n\x05\
    \x04)\x02\x04\x03\x12\x04\xf5\x0801\n\x0c\n\x04\x04)\x02\x05\x12\x04\xf6\
    \x08\x082\n\r\n\x05\x04)\x02\x05\x04\x12\x04\xf6\x08\x08\x10\n\r\n\x05\
    \x04)\x02\x05\x05\x12\x04\xf6\x08\x11\x16\n\r\n\x05\x04)\x02\x05\x01\x12\
    \x04\xf6\x08\x17-\n\r\n\x05\x04)\x02\x05\x03\x12\x04\xf6\x0801\n\x0c\n\
    \x04\x04)\x02\x06\x12\x04\xf7\x08\x082\n\r\n\x05\x04)\x02\x06\x04\x12\
    \x04\xf7\x08\x08\x10\n\r\n\x05\x04)\x02\x06\x05\x12\x04\xf7\x08\x11\x16\
    \n\r\n\x05\x04)\x02\x06\x01\x12\x04\xf7\x08\x17-\n\r\n\x05\x04)\x02\x06\
    \x03\x12\x04\xf7\x0801\n\x0c\n\x04\x04)\x02\x07\x12\x04\xf8\x08\x080\n\r\
    \n\x05\x04)\x02\x07\x04\x12\x04\xf8\x08\x08\x10\n\r\n\x05\x04)\x02\x07\
    \x05\x12\x04\xf8\x08\x11\x16\n\r\n\x05\x04)\x02\x07\x01\x12\x04\xf8\x08\
    \x17+\n\r\n\x05\x04)\x02\x07\x03\x12\x04\xf8\x08./\n\x0c\n\x04\x04)\x02\
    \x08\x12\x04\xf9\x08\x080\n\r\n\x05\x04)\x02\x08\x04\x12\x04\xf9\x08\x08\
    \x10\n\r\n\x05\x04)\x02\x08\x05\x12\x04\xf9\x08\x11\x16\n\r\n\x05\x04)\
    \x02\x08\x01\x12\x04\xf9\x08\x17+\n\r\n\x05\x04)\x02\x08\x03\x12\x04\xf9\
    \x08./\n\x0c\n\x04\x04)\x02\t\x12\x04\xfa\x08\x081\n\r\n\x05\x04)\x02\t\
    \x04\x12\x04\xfa\x08\x08\x10\n\r\n\x05\x04)\x02\t\x05\x12\x04\xfa\x08\
    \x11\x16\n\r\n\x05\x04)\x02\t\x01\x12\x04\xfa\x08\x17+\n\r\n\x05\x04)\
    \x02\t\x03\x12\x04\xfa\x08.0\n\x0c\n\x04\x04)\x02\n\x12\x04\xfb\x08\x08/\
    \n\r\n\x05\x04)\x02\n\x04\x12\x04\xfb\x08\x08\x10\n\r\n\x05\x04)\x02\n\
    \x05\x12\x04\xfb\x08\x11\x16\n\r\n\x05\x04)\x02\n\x01\x12\x04\xfb\x08\
    \x17)\n\r\n\x05\x04)\x02\n\x03\x12\x04\xfb\x08,.\n\x0c\n\x04\x04)\x02\
    \x0b\x12\x04\xfc\x08\x08+\n\r\n\x05\x04)\x02\x0b\x04\x12\x04\xfc\x08\x08\
    \x10\n\r\n\x05\x04)\x02\x0b\x05\x12\x04\xfc\x08\x11\x16\n\r\n\x05\x04)\
    \x02\x0b\x01\x12\x04\xfc\x08\x17%\n\r\n\x05\x04)\x02\x0b\x03\x12\x04\xfc\
    \x08(*\n\x0c\n\x04\x04)\x02\x0c\x12\x04\xfd\x08\x08)\n\r\n\x05\x04)\x02\
    \x0c\x04\x12\x04\xfd\x08\x08\x10\n\r\n\x05\x04)\x02\x0c\x05\x12\x04\xfd\
    \x08\x11\x17\n\r\n\x05\x04)\x02\x0c\x01\x12\x04\xfd\x08\x18#\n\r\n\x05\
    \x04)\x02\x0c\x03\x12\x04\xfd\x08&(\n\x0c\n\x02\x04*\x12\x06\x80\t\0\x84\
    \t\x01\n\x0b\n\x03\x04*\x01\x12\x04\x80\t\x08\x1a\n\x0c\n\x04\x04*\x02\0\
    \x12\x04\x81\t\x08$\n\r\n\x05\x04*\x02\0\x04\x12\x04\x81\t\x08\x10\n\r\n\
    \x05\x04*\x02\0\x05\x12\x04\x81\t\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\
    \x04\x81\t\x18\x1f\n\r\n\x05\x04*\x02\0\x03\x12\x04\x81\t\"#\n\x0c\n\x04\
    \x04*\x02\x01\x12\x04\x82\t\x08'\n\r\n\x05\x04*\x02\x01\x04\x12\x04\x82\
    \t\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\x04\x82\t\x11\x16\n\r\n\x05\
    \x04*\x02\x01\x01\x12\x04\x82\t\x17\"\n\r\n\x05\x04*\x02\x01\x03\x12\x04\
    \x82\t%&\n\x0c\n\x04\x04*\x02\x02\x12\x04\x83\t\x08+\n\r\n\x05\x04*\x02\
    \x02\x04\x12\x04\x83\t\x08\x10\n\r\n\x05\x04*\x02\x02\x05\x12\x04\x83\t\
    \x11\x17\n\r\n\x05\x04*\x02\x02\x01\x12\x04\x83\t\x18&\n\r\n\x05\x04*\
    \x02\x02\x03\x12\x04\x83\t)*\n\x0c\n\x02\x04+\x12\x06\x86\t\0\x92\t\x01\
    \n\x0b\n\x03\x04+\x01\x12\x04\x86\t\x08\x1b\n\x0c\n\x04\x04+\x02\0\x12\
    \x04\x87\t\x08%\n\r\n\x05\x04+\x02\0\x04\x12\x04\x87\t\x08\x10\n\r\n\x05\
    \x04+\x02\0\x05\x12\x04\x87\t\x11\x17\n\r\n\x05\x04+\x02\0\x01\x12\x04\
    \x87\t\x18\x20\n\r\n\x05\x04+\x02\0\x03\x12\x04\x87\t#$\n\x0c\n\x04\x04+\
    \x02\x01\x12\x04\x88\t\x08-\n\r\n\x05\x04+\x02\x01\x04\x12\x04\x88\t\x08\
    \x10\n\r\n\x05\x04+\x02\x01\x06\x12\x04\x88\t\x11\x1e\n\r\n\x05\x04+\x02\
    \x01\x01\x12\x04\x88\t\x1f(\n\r\n\x05\x04+\x02\x01\x03\x12\x04\x88\t+,\n\
    \x0c\n\x04\x04+\x02\x02\x12\x04\x89\t\x08\"\n\r\n\x05\x04+\x02\x02\x04\
    \x12\x04\x89\t\x08\x10\n\r\n\x05\x04+\x02\x02\x05\x12\x04\x89\t\x11\x17\
    \n\r\n\x05\x04+\x02\x02\x01\x12\x04\x89\t\x18\x1d\n\r\n\x05\x04+\x02\x02\
    \x03\x12\x04\x89\t\x20!\n\x0c\n\x04\x04+\x02\x03\x12\x04\x8a\t\x08#\n\r\
    \n\x05\x04+\x02\x03\x04\x12\x04\x8a\t\x08\x10\n\r\n\x05\x04+\x02\x03\x05\
    \x12\x04\x8a\t\x11\x17\n\r\n\x05\x04+\x02\x03\x01\x12\x04\x8a\t\x18\x1e\
    \n\r\n\x05\x04+\x02\x03\x03\x12\x04\x8a\t!\"\n\x0c\n\x04\x04+\x02\x04\
    \x12\x04\x8b\t\x08$\n\r\n\x05\x04+\x02\x04\x04\x12\x04\x8b\t\x08\x10\n\r\
    \n\x05\x04+\x02\x04\x05\x12\x04\x8b\t\x11\x17\n\r\n\x05\x04+\x02\x04\x01\
    \x12\x04\x8b\t\x18\x1f\n\r\n\x05\x04+\x02\x04\x03\x12\x04\x8b\t\"#\n\x0c\
    \n\x04\x04+\x02\x05\x12\x04\x8c\t\x08%\n\r\n\x05\x04+\x02\x05\x04\x12\
    \x04\x8c\t\x08\x10\n\r\n\x05\x04+\x02\x05\x05\x12\x04\x8c\t\x11\x17\n\r\
    \n\x05\x04+\x02\x05\x01\x12\x04\x8c\t\x18\x20\n\r\n\x05\x04+\x02\x05\x03\
    \x12\x04\x8c\t#$\n\x0c\n\x04\x04+\x02\x06\x12\x04\x8d\t\x08(\n\r\n\x05\
    \x04+\x02\x06\x04\x12\x04\x8d\t\x08\x10\n\r\n\x05\x04+\x02\x06\x05\x12\
    \x04\x8d\t\x11\x17\n\r\n\x05\x04+\x02\x06\x01\x12\x04\x8d\t\x18#\n\r\n\
    \x05\x04+\x02\x06\x03\x12\x04\x8d\t&'\n\x0c\n\x04\x04+\x02\x07\x12\x04\
    \x8e\t\x081\n\r\n\x05\x04+\x02\x07\x04\x12\x04\x8e\t\x08\x10\n\r\n\x05\
    \x04+\x02\x07\x06\x12\x04\x8e\t\x11\x1e\n\r\n\x05\x04+\x02\x07\x01\x12\
    \x04\x8e\t\x1f,\n\r\n\x05\x04+\x02\x07\x03\x12\x04\x8e\t/0\n\x0c\n\x04\
    \x04+\x02\x08\x12\x04\x8f\t\x08&\n\r\n\x05\x04+\x02\x08\x04\x12\x04\x8f\
    \t\x08\x10\n\r\n\x05\x04+\x02\x08\x05\x12\x04\x8f\t\x11\x17\n\r\n\x05\
    \x04+\x02\x08\x01\x12\x04\x8f\t\x18!\n\r\n\x05\x04+\x02\x08\x03\x12\x04\
    \x8f\t$%\n\x0c\n\x04\x04+\x02\t\x12\x04\x90\t\x08(\n\r\n\x05\x04+\x02\t\
    \x04\x12\x04\x90\t\x08\x10\n\r\n\x05\x04+\x02\t\x05\x12\x04\x90\t\x11\
    \x17\n\r\n\x05\x04+\x02\t\x01\x12\x04\x90\t\x18\"\n\r\n\x05\x04+\x02\t\
    \x03\x12\x04\x90\t%'\n\x0c\n\x04\x04+\x02\n\x12\x04\x91\t\x08)\n\r\n\x05\
    \x04+\x02\n\x04\x12\x04\x91\t\x08\x10\n\r\n\x05\x04+\x02\n\x05\x12\x04\
    \x91\t\x11\x17\n\r\n\x05\x04+\x02\n\x01\x12\x04\x91\t\x18#\n\r\n\x05\x04\
    +\x02\n\x03\x12\x04\x91\t&(\n\x0c\n\x02\x04,\x12\x06\x94\t\0\x9d\t\x01\n\
    \x0b\n\x03\x04,\x01\x12\x04\x94\t\x08\x15\n\x0e\n\x04\x04,\x03\0\x12\x06\
    \x95\t\x08\x9a\t\t\n\r\n\x05\x04,\x03\0\x01\x12\x04\x95\t\x10\x19\n\x0e\
    \n\x06\x04,\x03\0\x02\0\x12\x04\x96\t\x106\n\x0f\n\x07\x04,\x03\0\x02\0\
    \x04\x12\x04\x96\t\x10\x18\n\x0f\n\x07\x04,\x03\0\x02\0\x05\x12\x04\x96\
    \t\x19\x1f\n\x0f\n\x07\x04,\x03\0\x02\0\x01\x12\x04\x96\t\x201\n\x0f\n\
    \x07\x04,\x03\0\x02\0\x03\x12\x04\x96\t45\n\x0e\n\x06\x04,\x03\0\x02\x01\
    \x12\x04\x97\t\x106\n\x0f\n\x07\x04,\x03\0\x02\x01\x04\x12\x04\x97\t\x10\
    \x18\n\x0f\n\x07\x04,\x03\0\x02\x01\x05\x12\x04\x97\t\x19\x1f\n\x0f\n\
    \x07\x04,\x03\0\x02\x01\x01\x12\x04\x97\t\x201\n\x0f\n\x07\x04,\x03\0\
    \x02\x01\x03\x12\x04\x97\t45\n\x0e\n\x06\x04,\x03\0\x02\x02\x12\x04\x98\
    \t\x10/\n\x0f\n\x07\x04,\x03\0\x02\x02\x04\x12\x04\x98\t\x10\x18\n\x0f\n\
    \x07\x04,\x03\0\x02\x02\x05\x12\x04\x98\t\x19\x1f\n\x0f\n\x07\x04,\x03\0\
    \x02\x02\x01\x12\x04\x98\t\x20*\n\x0f\n\x07\x04,\x03\0\x02\x02\x03\x12\
    \x04\x98\t-.\n\x0e\n\x06\x04,\x03\0\x02\x03\x12\x04\x99\t\x10-\n\x0f\n\
    \x07\x04,\x03\0\x02\x03\x04\x12\x04\x99\t\x10\x18\n\x0f\n\x07\x04,\x03\0\
    \x02\x03\x06\x12\x04\x99\t\x19\x1f\n\x0f\n\x07\x04,\x03\0\x02\x03\x01\
    \x12\x04\x99\t\x20(\n\x0f\n\x07\x04,\x03\0\x02\x03\x03\x12\x04\x99\t+,\n\
    \x0c\n\x04\x04,\x02\0\x12\x04\x9c\t\x082\n\r\n\x05\x04,\x02\0\x04\x12\
    \x04\x9c\t\x08\x10\n\r\n\x05\x04,\x02\0\x06\x12\x04\x9c\t\x11(\n\r\n\x05\
    \x04,\x02\0\x01\x12\x04\x9c\t)-\n\r\n\x05\x04,\x02\0\x03\x12\x04\x9c\t01\
    \n\x0c\n\x02\x04-\x12\x06\x9f\t\0\xc9\t\x01\n\x0b\n\x03\x04-\x01\x12\x04\
    \x9f\t\x08\x1c\n\x0e\n\x04\x04-\x03\0\x12\x06\xa0\t\x08\xab\t\t\n\r\n\
    \x05\x04-\x03\0\x01\x12\x04\xa0\t\x10\x16\n\x0e\n\x06\x04-\x03\0\x02\0\
    \x12\x04\xa1\t\x10/\n\x0f\n\x07\x04-\x03\0\x02\0\x04\x12\x04\xa1\t\x10\
    \x18\n\x0f\n\x07\x04-\x03\0\x02\0\x05\x12\x04\xa1\t\x19\x1f\n\x0f\n\x07\
    \x04-\x03\0\x02\0\x01\x12\x04\xa1\t\x20*\n\x0f\n\x07\x04-\x03\0\x02\0\
    \x03\x12\x04\xa1\t-.\n\x0e\n\x06\x04-\x03\0\x02\x01\x12\x04\xa2\t\x10,\n\
    \x0f\n\x07\x04-\x03\0\x02\x01\x04\x12\x04\xa2\t\x10\x18\n\x0f\n\x07\x04-\
    \x03\0\x02\x01\x05\x12\x04\xa2\t\x19\x1f\n\x0f\n\x07\x04-\x03\0\x02\x01\
    \x01\x12\x04\xa2\t\x20'\n\x0f\n\x07\x04-\x03\0\x02\x01\x03\x12\x04\xa2\t\
    *+\n\x0e\n\x06\x04-\x03\0\x02\x02\x12\x04\xa3\t\x10*\n\x0f\n\x07\x04-\
    \x03\0\x02\x02\x04\x12\x04\xa3\t\x10\x18\n\x0f\n\x07\x04-\x03\0\x02\x02\
    \x05\x12\x04\xa3\t\x19\x1f\n\x0f\n\x07\x04-\x03\0\x02\x02\x01\x12\x04\
    \xa3\t\x20%\n\x0f\n\x07\x04-\x03\0\x02\x02\x03\x12\x04\xa3\t()\n\x0e\n\
    \x06\x04-\x03\0\x02\x03\x12\x04\xa4\t\x10+\n\x0f\n\x07\x04-\x03\0\x02\
    \x03\x04\x12\x04\xa4\t\x10\x18\n\x0f\n\x07\x04-\x03\0\x02\x03\x05\x12\
    \x04\xa4\t\x19\x1f\n\x0f\n\x07\x04-\x03\0\x02\x03\x01\x12\x04\xa4\t\x20&\
    \n\x0f\n\x07\x04-\x03\0\x02\x03\x03\x12\x04\xa4\t)*\n\x0e\n\x06\x04-\x03\
    \0\x02\x04\x12\x04\xa5\t\x10,\n\x0f\n\x07\x04-\x03\0\x02\x04\x04\x12\x04\
    \xa5\t\x10\x18\n\x0f\n\x07\x04-\x03\0\x02\x04\x05\x12\x04\xa5\t\x19\x1f\
    \n\x0f\n\x07\x04-\x03\0\x02\x04\x01\x12\x04\xa5\t\x20'\n\x0f\n\x07\x04-\
    \x03\0\x02\x04\x03\x12\x04\xa5\t*+\n\x0e\n\x06\x04-\x03\0\x02\x05\x12\
    \x04\xa6\t\x10)\n\x0f\n\x07\x04-\x03\0\x02\x05\x04\x12\x04\xa6\t\x10\x18\
    \n\x0f\n\x07\x04-\x03\0\x02\x05\x05\x12\x04\xa6\t\x19\x1e\n\x0f\n\x07\
    \x04-\x03\0\x02\x05\x01\x12\x04\xa6\t\x1f$\n\x0f\n\x07\x04-\x03\0\x02\
    \x05\x03\x12\x04\xa6\t'(\n\x0e\n\x06\x04-\x03\0\x02\x06\x12\x04\xa7\t\
    \x100\n\x0f\n\x07\x04-\x03\0\x02\x06\x04\x12\x04\xa7\t\x10\x18\n\x0f\n\
    \x07\x04-\x03\0\x02\x06\x05\x12\x04\xa7\t\x19\x1f\n\x0f\n\x07\x04-\x03\0\
    \x02\x06\x01\x12\x04\xa7\t\x20+\n\x0f\n\x07\x04-\x03\0\x02\x06\x03\x12\
    \x04\xa7\t./\n\x0e\n\x06\x04-\x03\0\x02\x07\x12\x04\xa8\t\x10-\n\x0f\n\
    \x07\x04-\x03\0\x02\x07\x04\x12\x04\xa8\t\x10\x18\n\x0f\n\x07\x04-\x03\0\
    \x02\x07\x05\x12\x04\xa8\t\x19\x1f\n\x0f\n\x07\x04-\x03\0\x02\x07\x01\
    \x12\x04\xa8\t\x20(\n\x0f\n\x07\x04-\x03\0\x02\x07\x03\x12\x04\xa8\t+,\n\
    \x0e\n\x06\x04-\x03\0\x02\x08\x12\x04\xa9\t\x10*\n\x0f\n\x07\x04-\x03\0\
    \x02\x08\x04\x12\x04\xa9\t\x10\x18\n\x0f\n\x07\x04-\x03\0\x02\x08\x05\
    \x12\x04\xa9\t\x19\x1f\n\x0f\n\x07\x04-\x03\0\x02\x08\x01\x12\x04\xa9\t\
    \x20%\n\x0f\n\x07\x04-\x03\0\x02\x08\x03\x12\x04\xa9\t()\n\x0e\n\x06\x04\
    -\x03\0\x02\t\x12\x04\xaa\t\x107\n\x0f\n\x07\x04-\x03\0\x02\t\x04\x12\
    \x04\xaa\t\x10\x18\n\x0f\n\x07\x04-\x03\0\x02\t\x06\x12\x04\xaa\t\x19%\n\
    \x0f\n\x07\x04-\x03\0\x02\t\x01\x12\x04\xaa\t&1\n\x0f\n\x07\x04-\x03\0\
    \x02\t\x03\x12\x04\xaa\t46\n\x0e\n\x04\x04-\x03\x01\x12\x06\xad\t\x08\
    \xbd\t\t\n\r\n\x05\x04-\x03\x01\x01\x12\x04\xad\t\x10\x17\n\x0e\n\x06\
    \x04-\x03\x01\x02\0\x12\x04\xae\t\x10.\n\x0f\n\x07\x04-\x03\x01\x02\0\
    \x04\x12\x04\xae\t\x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\0\x05\x12\x04\
    \xae\t\x19\x1f\n\x0f\n\x07\x04-\x03\x01\x02\0\x01\x12\x04\xae\t\x20)\n\
    \x0f\n\x07\x04-\x03\x01\x02\0\x03\x12\x04\xae\t,-\n\x0e\n\x06\x04-\x03\
    \x01\x02\x01\x12\x04\xaf\t\x100\n\x0f\n\x07\x04-\x03\x01\x02\x01\x04\x12\
    \x04\xaf\t\x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x01\x05\x12\x04\xaf\t\
    \x19\x1f\n\x0f\n\x07\x04-\x03\x01\x02\x01\x01\x12\x04\xaf\t\x20+\n\x0f\n\
    \x07\x04-\x03\x01\x02\x01\x03\x12\x04\xaf\t./\n\x0e\n\x06\x04-\x03\x01\
    \x02\x02\x12\x04\xb0\t\x100\n\x0f\n\x07\x04-\x03\x01\x02\x02\x04\x12\x04\
    \xb0\t\x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x02\x05\x12\x04\xb0\t\x19\
    \x1f\n\x0f\n\x07\x04-\x03\x01\x02\x02\x01\x12\x04\xb0\t\x20+\n\x0f\n\x07\
    \x04-\x03\x01\x02\x02\x03\x12\x04\xb0\t./\n\x0e\n\x06\x04-\x03\x01\x02\
    \x03\x12\x04\xb1\t\x10C\n\x0f\n\x07\x04-\x03\x01\x02\x03\x04\x12\x04\xb1\
    \t\x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x03\x05\x12\x04\xb1\t\x19\x1f\n\
    \x0f\n\x07\x04-\x03\x01\x02\x03\x01\x12\x04\xb1\t\x20=\n\x0f\n\x07\x04-\
    \x03\x01\x02\x03\x03\x12\x04\xb1\t@B\n\x0e\n\x06\x04-\x03\x01\x02\x04\
    \x12\x04\xb2\t\x10F\n\x0f\n\x07\x04-\x03\x01\x02\x04\x04\x12\x04\xb2\t\
    \x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x04\x05\x12\x04\xb2\t\x19\x1f\n\
    \x0f\n\x07\x04-\x03\x01\x02\x04\x01\x12\x04\xb2\t\x20@\n\x0f\n\x07\x04-\
    \x03\x01\x02\x04\x03\x12\x04\xb2\tCE\n\x0e\n\x06\x04-\x03\x01\x02\x05\
    \x12\x04\xb3\t\x10>\n\x0f\n\x07\x04-\x03\x01\x02\x05\x04\x12\x04\xb3\t\
    \x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x05\x05\x12\x04\xb3\t\x19\x1f\n\
    \x0f\n\x07\x04-\x03\x01\x02\x05\x01\x12\x04\xb3\t\x208\n\x0f\n\x07\x04-\
    \x03\x01\x02\x05\x03\x12\x04\xb3\t;=\n\x0e\n\x06\x04-\x03\x01\x02\x06\
    \x12\x04\xb4\t\x10A\n\x0f\n\x07\x04-\x03\x01\x02\x06\x04\x12\x04\xb4\t\
    \x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x06\x05\x12\x04\xb4\t\x19\x1f\n\
    \x0f\n\x07\x04-\x03\x01\x02\x06\x01\x12\x04\xb4\t\x20;\n\x0f\n\x07\x04-\
    \x03\x01\x02\x06\x03\x12\x04\xb4\t>@\n\x0e\n\x06\x04-\x03\x01\x02\x07\
    \x12\x04\xb5\t\x104\n\x0f\n\x07\x04-\x03\x01\x02\x07\x04\x12\x04\xb5\t\
    \x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x07\x05\x12\x04\xb5\t\x19\x1f\n\
    \x0f\n\x07\x04-\x03\x01\x02\x07\x01\x12\x04\xb5\t\x20/\n\x0f\n\x07\x04-\
    \x03\x01\x02\x07\x03\x12\x04\xb5\t23\n\x0e\n\x06\x04-\x03\x01\x02\x08\
    \x12\x04\xb6\t\x106\n\x0f\n\x07\x04-\x03\x01\x02\x08\x04\x12\x04\xb6\t\
    \x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x08\x05\x12\x04\xb6\t\x19\x1f\n\
    \x0f\n\x07\x04-\x03\x01\x02\x08\x01\x12\x04\xb6\t\x201\n\x0f\n\x07\x04-\
    \x03\x01\x02\x08\x03\x12\x04\xb6\t45\n\x0e\n\x06\x04-\x03\x01\x02\t\x12\
    \x04\xb7\t\x107\n\x0f\n\x07\x04-\x03\x01\x02\t\x04\x12\x04\xb7\t\x10\x18\
    \n\x0f\n\x07\x04-\x03\x01\x02\t\x05\x12\x04\xb7\t\x19\x20\n\x0f\n\x07\
    \x04-\x03\x01\x02\t\x01\x12\x04\xb7\t!2\n\x0f\n\x07\x04-\x03\x01\x02\t\
    \x03\x12\x04\xb7\t56\n\x0e\n\x06\x04-\x03\x01\x02\n\x12\x04\xb8\t\x10;\n\
    \x0f\n\x07\x04-\x03\x01\x02\n\x04\x12\x04\xb8\t\x10\x18\n\x0f\n\x07\x04-\
    \x03\x01\x02\n\x05\x12\x04\xb8\t\x19\x1f\n\x0f\n\x07\x04-\x03\x01\x02\n\
    \x01\x12\x04\xb8\t\x205\n\x0f\n\x07\x04-\x03\x01\x02\n\x03\x12\x04\xb8\t\
    8:\n\x0e\n\x06\x04-\x03\x01\x02\x0b\x12\x04\xb9\t\x101\n\x0f\n\x07\x04-\
    \x03\x01\x02\x0b\x04\x12\x04\xb9\t\x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\
    \x0b\x05\x12\x04\xb9\t\x19\x1f\n\x0f\n\x07\x04-\x03\x01\x02\x0b\x01\x12\
    \x04\xb9\t\x20,\n\x0f\n\x07\x04-\x03\x01\x02\x0b\x03\x12\x04\xb9\t/0\n\
    \x0e\n\x06\x04-\x03\x01\x02\x0c\x12\x04\xba\t\x103\n\x0f\n\x07\x04-\x03\
    \x01\x02\x0c\x04\x12\x04\xba\t\x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x0c\
    \x05\x12\x04\xba\t\x19\x1f\n\x0f\n\x07\x04-\x03\x01\x02\x0c\x01\x12\x04\
    \xba\t\x20.\n\x0f\n\x07\x04-\x03\x01\x02\x0c\x03\x12\x04\xba\t12\n\x0e\n\
    \x06\x04-\x03\x01\x02\r\x12\x04\xbb\t\x104\n\x0f\n\x07\x04-\x03\x01\x02\
    \r\x04\x12\x04\xbb\t\x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\r\x05\x12\x04\
    \xbb\t\x19\x20\n\x0f\n\x07\x04-\x03\x01\x02\r\x01\x12\x04\xbb\t!/\n\x0f\
    \n\x07\x04-\x03\x01\x02\r\x03\x12\x04\xbb\t23\n\x0e\n\x06\x04-\x03\x01\
    \x02\x0e\x12\x04\xbc\t\x108\n\x0f\n\x07\x04-\x03\x01\x02\x0e\x04\x12\x04\
    \xbc\t\x10\x18\n\x0f\n\x07\x04-\x03\x01\x02\x0e\x05\x12\x04\xbc\t\x19\
    \x1f\n\x0f\n\x07\x04-\x03\x01\x02\x0e\x01\x12\x04\xbc\t\x202\n\x0f\n\x07\
    \x04-\x03\x01\x02\x0e\x03\x12\x04\xbc\t57\n\x0c\n\x04\x04-\x02\0\x12\x04\
    \xbf\t\x08%\n\r\n\x05\x04-\x02\0\x04\x12\x04\xbf\t\x08\x10\n\r\n\x05\x04\
    -\x02\0\x05\x12\x04\xbf\t\x11\x17\n\r\n\x05\x04-\x02\0\x01\x12\x04\xbf\t\
    \x18\x20\n\r\n\x05\x04-\x02\0\x03\x12\x04\xbf\t#$\n\x0c\n\x04\x04-\x02\
    \x01\x12\x04\xc0\t\x08(\n\r\n\x05\x04-\x02\x01\x04\x12\x04\xc0\t\x08\x10\
    \n\r\n\x05\x04-\x02\x01\x05\x12\x04\xc0\t\x11\x18\n\r\n\x05\x04-\x02\x01\
    \x01\x12\x04\xc0\t\x19#\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xc0\t&'\n\x0c\
    \n\x04\x04-\x02\x02\x12\x04\xc1\t\x08%\n\r\n\x05\x04-\x02\x02\x04\x12\
    \x04\xc1\t\x08\x10\n\r\n\x05\x04-\x02\x02\x05\x12\x04\xc1\t\x11\x17\n\r\
    \n\x05\x04-\x02\x02\x01\x12\x04\xc1\t\x18\x20\n\r\n\x05\x04-\x02\x02\x03\
    \x12\x04\xc1\t#$\n\x0c\n\x04\x04-\x02\x03\x12\x04\xc2\t\x08-\n\r\n\x05\
    \x04-\x02\x03\x04\x12\x04\xc2\t\x08\x10\n\r\n\x05\x04-\x02\x03\x06\x12\
    \x04\xc2\t\x11\x1e\n\r\n\x05\x04-\x02\x03\x01\x12\x04\xc2\t\x1f(\n\r\n\
    \x05\x04-\x02\x03\x03\x12\x04\xc2\t+,\n\x0c\n\x04\x04-\x02\x04\x12\x04\
    \xc3\t\x089\n\r\n\x05\x04-\x02\x04\x04\x12\x04\xc3\t\x08\x10\n\r\n\x05\
    \x04-\x02\x04\x06\x12\x04\xc3\t\x11,\n\r\n\x05\x04-\x02\x04\x01\x12\x04\
    \xc3\t-4\n\r\n\x05\x04-\x02\x04\x03\x12\x04\xc3\t78\n\x0c\n\x04\x04-\x02\
    \x05\x12\x04\xc4\t\x08:\n\r\n\x05\x04-\x02\x05\x04\x12\x04\xc4\t\x08\x10\
    \n\r\n\x05\x04-\x02\x05\x06\x12\x04\xc4\t\x11-\n\r\n\x05\x04-\x02\x05\
    \x01\x12\x04\xc4\t.5\n\r\n\x05\x04-\x02\x05\x03\x12\x04\xc4\t89\n\x0c\n\
    \x04\x04-\x02\x06\x12\x04\xc5\t\x081\n\r\n\x05\x04-\x02\x06\x04\x12\x04\
    \xc5\t\x08\x10\n\r\n\x05\x04-\x02\x06\x06\x12\x04\xc5\t\x11\x1e\n\r\n\
    \x05\x04-\x02\x06\x01\x12\x04\xc5\t\x1f,\n\r\n\x05\x04-\x02\x06\x03\x12\
    \x04\xc5\t/0\n\x0c\n\x04\x04-\x02\x07\x12\x04\xc6\t\x08*\n\r\n\x05\x04-\
    \x02\x07\x04\x12\x04\xc6\t\x08\x10\n\r\n\x05\x04-\x02\x07\x05\x12\x04\
    \xc6\t\x11\x17\n\r\n\x05\x04-\x02\x07\x01\x12\x04\xc6\t\x18%\n\r\n\x05\
    \x04-\x02\x07\x03\x12\x04\xc6\t()\n\x0c\n\x04\x04-\x02\x08\x12\x04\xc7\t\
    \x08(\n\r\n\x05\x04-\x02\x08\x04\x12\x04\xc7\t\x08\x10\n\r\n\x05\x04-\
    \x02\x08\x05\x12\x04\xc7\t\x11\x17\n\r\n\x05\x04-\x02\x08\x01\x12\x04\
    \xc7\t\x18\"\n\r\n\x05\x04-\x02\x08\x03\x12\x04\xc7\t%'\n\x0c\n\x04\x04-\
    \x02\t\x12\x04\xc8\t\x08(\n\r\n\x05\x04-\x02\t\x04\x12\x04\xc8\t\x08\x10\
    \n\r\n\x05\x04-\x02\t\x05\x12\x04\xc8\t\x11\x17\n\r\n\x05\x04-\x02\t\x01\
    \x12\x04\xc8\t\x18\"\n\r\n\x05\x04-\x02\t\x03\x12\x04\xc8\t%'\n\x0c\n\
    \x02\x04.\x12\x06\xcb\t\0\xce\t\x01\n\x0b\n\x03\x04.\x01\x12\x04\xcb\t\
    \x08\x1b\n\x0c\n\x04\x04.\x02\0\x12\x04\xcc\t\x08%\n\r\n\x05\x04.\x02\0\
    \x04\x12\x04\xcc\t\x08\x10\n\r\n\x05\x04.\x02\0\x05\x12\x04\xcc\t\x11\
    \x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\xcc\t\x18\x20\n\r\n\x05\x04.\x02\0\
    \x03\x12\x04\xcc\t#$\n\x0c\n\x04\x04.\x02\x01\x12\x04\xcd\t\x08+\n\r\n\
    \x05\x04.\x02\x01\x04\x12\x04\xcd\t\x08\x10\n\r\n\x05\x04.\x02\x01\x05\
    \x12\x04\xcd\t\x11\x16\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xcd\t\x17&\n\r\
    \n\x05\x04.\x02\x01\x03\x12\x04\xcd\t)*\n\x0c\n\x02\x04/\x12\x06\xd0\t\0\
    \xd7\t\x01\n\x0b\n\x03\x04/\x01\x12\x04\xd0\t\x08\x20\n\x0e\n\x04\x04/\
    \x03\0\x12\x06\xd1\t\x08\xd4\t\t\n\r\n\x05\x04/\x03\0\x01\x12\x04\xd1\t\
    \x10\x1b\n\x0e\n\x06\x04/\x03\0\x02\0\x12\x04\xd2\t\x10/\n\x0f\n\x07\x04\
    /\x03\0\x02\0\x04\x12\x04\xd2\t\x10\x18\n\x0f\n\x07\x04/\x03\0\x02\0\x05\
    \x12\x04\xd2\t\x19\x1f\n\x0f\n\x07\x04/\x03\0\x02\0\x01\x12\x04\xd2\t\
    \x20*\n\x0f\n\x07\x04/\x03\0\x02\0\x03\x12\x04\xd2\t-.\n\x0e\n\x06\x04/\
    \x03\0\x02\x01\x12\x04\xd3\t\x10B\n\x0f\n\x07\x04/\x03\0\x02\x01\x04\x12\
    \x04\xd3\t\x10\x18\n\x0f\n\x07\x04/\x03\0\x02\x01\x06\x12\x04\xd3\t\x19,\
    \n\x0f\n\x07\x04/\x03\0\x02\x01\x01\x12\x04\xd3\t-=\n\x0f\n\x07\x04/\x03\
    \0\x02\x01\x03\x12\x04\xd3\t@A\n\x0c\n\x04\x04/\x02\0\x12\x04\xd6\t\x08R\
    \n\r\n\x05\x04/\x02\0\x04\x12\x04\xd6\t\x08\x10\n\r\n\x05\x04/\x02\0\x06\
    \x12\x04\xd6\t\x115\n\r\n\x05\x04/\x02\0\x01\x12\x04\xd6\t6M\n\r\n\x05\
    \x04/\x02\0\x03\x12\x04\xd6\tPQ\n\x0c\n\x02\x040\x12\x06\xd9\t\0\xe0\t\
    \x01\n\x0b\n\x03\x040\x01\x12\x04\xd9\t\x08\"\n\x0e\n\x04\x040\x03\0\x12\
    \x06\xda\t\x08\xdd\t\t\n\r\n\x05\x040\x03\0\x01\x12\x04\xda\t\x10\x1c\n\
    \x0e\n\x06\x040\x03\0\x02\0\x12\x04\xdb\t\x10/\n\x0f\n\x07\x040\x03\0\
    \x02\0\x04\x12\x04\xdb\t\x10\x18\n\x0f\n\x07\x040\x03\0\x02\0\x05\x12\
    \x04\xdb\t\x19\x1f\n\x0f\n\x07\x040\x03\0\x02\0\x01\x12\x04\xdb\t\x20*\n\
    \x0f\n\x07\x040\x03\0\x02\0\x03\x12\x04\xdb\t-.\n\x0e\n\x06\x040\x03\0\
    \x02\x01\x12\x04\xdc\t\x10C\n\x0f\n\x07\x040\x03\0\x02\x01\x04\x12\x04\
    \xdc\t\x10\x18\n\x0f\n\x07\x040\x03\0\x02\x01\x06\x12\x04\xdc\t\x19.\n\
    \x0f\n\x07\x040\x03\0\x02\x01\x01\x12\x04\xdc\t/>\n\x0f\n\x07\x040\x03\0\
    \x02\x01\x03\x12\x04\xdc\tAB\n\x0c\n\x04\x040\x02\0\x12\x04\xdf\t\x08K\n\
    \r\n\x05\x040\x02\0\x04\x12\x04\xdf\t\x08\x10\n\r\n\x05\x040\x02\0\x06\
    \x12\x04\xdf\t\x118\n\r\n\x05\x040\x02\0\x01\x12\x04\xdf\t9F\n\r\n\x05\
    \x040\x02\0\x03\x12\x04\xdf\tIJ\n\x0c\n\x02\x041\x12\x06\xe2\t\0\xe6\t\
    \x01\n\x0b\n\x03\x041\x01\x12\x04\xe2\t\x08\x1f\n\x0c\n\x04\x041\x02\0\
    \x12\x04\xe3\t\x08$\n\r\n\x05\x041\x02\0\x04\x12\x04\xe3\t\x08\x10\n\r\n\
    \x05\x041\x02\0\x05\x12\x04\xe3\t\x11\x17\n\r\n\x05\x041\x02\0\x01\x12\
    \x04\xe3\t\x18\x1f\n\r\n\x05\x041\x02\0\x03\x12\x04\xe3\t\"#\n\x0c\n\x04\
    \x041\x02\x01\x12\x04\xe4\t\x083\n\r\n\x05\x041\x02\x01\x04\x12\x04\xe4\
    \t\x08\x10\n\r\n\x05\x041\x02\x01\x05\x12\x04\xe4\t\x11\x17\n\r\n\x05\
    \x041\x02\x01\x01\x12\x04\xe4\t\x18.\n\r\n\x05\x041\x02\x01\x03\x12\x04\
    \xe4\t12\n\x0c\n\x04\x041\x02\x02\x12\x04\xe5\t\x08,\n\r\n\x05\x041\x02\
    \x02\x04\x12\x04\xe5\t\x08\x10\n\r\n\x05\x041\x02\x02\x05\x12\x04\xe5\t\
    \x11\x15\n\r\n\x05\x041\x02\x02\x01\x12\x04\xe5\t\x16'\n\r\n\x05\x041\
    \x02\x02\x03\x12\x04\xe5\t*+\n\x0c\n\x02\x042\x12\x06\xe8\t\0\xef\t\x01\
    \n\x0b\n\x03\x042\x01\x12\x04\xe8\t\x08&\n\x0e\n\x04\x042\x03\0\x12\x06\
    \xe9\t\x08\xec\t\t\n\r\n\x05\x042\x03\0\x01\x12\x04\xe9\t\x10\x1e\n\x0e\
    \n\x06\x042\x03\0\x02\0\x12\x04\xea\t\x103\n\x0f\n\x07\x042\x03\0\x02\0\
    \x04\x12\x04\xea\t\x10\x18\n\x0f\n\x07\x042\x03\0\x02\0\x05\x12\x04\xea\
    \t\x19\x1f\n\x0f\n\x07\x042\x03\0\x02\0\x01\x12\x04\xea\t\x20.\n\x0f\n\
    \x07\x042\x03\0\x02\0\x03\x12\x04\xea\t12\n\x0e\n\x06\x042\x03\0\x02\x01\
    \x12\x04\xeb\t\x10G\n\x0f\n\x07\x042\x03\0\x02\x01\x04\x12\x04\xeb\t\x10\
    \x18\n\x0f\n\x07\x042\x03\0\x02\x01\x06\x12\x04\xeb\t\x192\n\x0f\n\x07\
    \x042\x03\0\x02\x01\x01\x12\x04\xeb\t3B\n\x0f\n\x07\x042\x03\0\x02\x01\
    \x03\x12\x04\xeb\tEF\n\x0c\n\x04\x042\x02\0\x12\x04\xee\t\x08U\n\r\n\x05\
    \x042\x02\0\x04\x12\x04\xee\t\x08\x10\n\r\n\x05\x042\x02\0\x06\x12\x04\
    \xee\t\x11>\n\r\n\x05\x042\x02\0\x01\x12\x04\xee\t?P\n\r\n\x05\x042\x02\
    \0\x03\x12\x04\xee\tST\n\x0c\n\x02\x043\x12\x06\xf1\t\0\xfa\t\x01\n\x0b\
    \n\x03\x043\x01\x12\x04\xf1\t\x08!\n\x0c\n\x04\x043\x02\0\x12\x04\xf2\t\
    \x08%\n\r\n\x05\x043\x02\0\x04\x12\x04\xf2\t\x08\x10\n\r\n\x05\x043\x02\
    \0\x05\x12\x04\xf2\t\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\xf2\t\x18\
    \x20\n\r\n\x05\x043\x02\0\x03\x12\x04\xf2\t#$\n\x0c\n\x04\x043\x02\x01\
    \x12\x04\xf3\t\x08&\n\r\n\x05\x043\x02\x01\x04\x12\x04\xf3\t\x08\x10\n\r\
    \n\x05\x043\x02\x01\x05\x12\x04\xf3\t\x11\x17\n\r\n\x05\x043\x02\x01\x01\
    \x12\x04\xf3\t\x18!\n\r\n\x05\x043\x02\x01\x03\x12\x04\xf3\t$%\n\x0c\n\
    \x04\x043\x02\x02\x12\x04\xf4\t\x08%\n\r\n\x05\x043\x02\x02\x04\x12\x04\
    \xf4\t\x08\x10\n\r\n\x05\x043\x02\x02\x05\x12\x04\xf4\t\x11\x17\n\r\n\
    \x05\x043\x02\x02\x01\x12\x04\xf4\t\x18\x20\n\r\n\x05\x043\x02\x02\x03\
    \x12\x04\xf4\t#$\n\x0c\n\x04\x043\x02\x03\x12\x04\xf5\t\x08\x1e\n\r\n\
    \x05\x043\x02\x03\x04\x12\x04\xf5\t\x08\x10\n\r\n\x05\x043\x02\x03\x05\
    \x12\x04\xf5\t\x11\x15\n\r\n\x05\x043\x02\x03\x01\x12\x04\xf5\t\x16\x19\
    \n\r\n\x05\x043\x02\x03\x03\x12\x04\xf5\t\x1c\x1d\n\x0c\n\x04\x043\x02\
    \x04\x12\x04\xf6\t\x08$\n\r\n\x05\x043\x02\x04\x04\x12\x04\xf6\t\x08\x10\
    \n\r\n\x05\x043\x02\x04\x05\x12\x04\xf6\t\x11\x17\n\r\n\x05\x043\x02\x04\
    \x01\x12\x04\xf6\t\x18\x1f\n\r\n\x05\x043\x02\x04\x03\x12\x04\xf6\t\"#\n\
    \x0c\n\x04\x043\x02\x05\x12\x04\xf7\t\x08\"\n\r\n\x05\x043\x02\x05\x04\
    \x12\x04\xf7\t\x08\x10\n\r\n\x05\x043\x02\x05\x05\x12\x04\xf7\t\x11\x17\
    \n\r\n\x05\x043\x02\x05\x01\x12\x04\xf7\t\x18\x1d\n\r\n\x05\x043\x02\x05\
    \x03\x12\x04\xf7\t\x20!\n\x0c\n\x04\x043\x02\x06\x12\x04\xf8\t\x08#\n\r\
    \n\x05\x043\x02\x06\x04\x12\x04\xf8\t\x08\x10\n\r\n\x05\x043\x02\x06\x05\
    \x12\x04\xf8\t\x11\x17\n\r\n\x05\x043\x02\x06\x01\x12\x04\xf8\t\x18\x1e\
    \n\r\n\x05\x043\x02\x06\x03\x12\x04\xf8\t!\"\n\x0c\n\x04\x043\x02\x07\
    \x12\x04\xf9\t\x08$\n\r\n\x05\x043\x02\x07\x04\x12\x04\xf9\t\x08\x10\n\r\
    \n\x05\x043\x02\x07\x05\x12\x04\xf9\t\x11\x17\n\r\n\x05\x043\x02\x07\x01\
    \x12\x04\xf9\t\x18\x1f\n\r\n\x05\x043\x02\x07\x03\x12\x04\xf9\t\"#\n\x0c\
    \n\x02\x044\x12\x06\xfc\t\0\xff\t\x01\n\x0b\n\x03\x044\x01\x12\x04\xfc\t\
    \x08\x1d\n\x0c\n\x04\x044\x02\0\x12\x04\xfd\t\x08!\n\r\n\x05\x044\x02\0\
    \x04\x12\x04\xfd\t\x08\x10\n\r\n\x05\x044\x02\0\x05\x12\x04\xfd\t\x11\
    \x17\n\r\n\x05\x044\x02\0\x01\x12\x04\xfd\t\x18\x1c\n\r\n\x05\x044\x02\0\
    \x03\x12\x04\xfd\t\x1f\x20\n\x0c\n\x04\x044\x02\x01\x12\x04\xfe\t\x08#\n\
    \r\n\x05\x044\x02\x01\x04\x12\x04\xfe\t\x08\x10\n\r\n\x05\x044\x02\x01\
    \x05\x12\x04\xfe\t\x11\x17\n\r\n\x05\x044\x02\x01\x01\x12\x04\xfe\t\x18\
    \x1e\n\r\n\x05\x044\x02\x01\x03\x12\x04\xfe\t!\"\n\x0c\n\x02\x045\x12\
    \x06\x81\n\0\x84\n\x01\n\x0b\n\x03\x045\x01\x12\x04\x81\n\x08%\n\x0c\n\
    \x04\x045\x02\0\x12\x04\x82\n\x08%\n\r\n\x05\x045\x02\0\x04\x12\x04\x82\
    \n\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\x04\x82\n\x11\x17\n\r\n\x05\x045\
    \x02\0\x01\x12\x04\x82\n\x18\x20\n\r\n\x05\x045\x02\0\x03\x12\x04\x82\n#\
    $\n\x0c\n\x04\x045\x02\x01\x12\x04\x83\n\x08(\n\r\n\x05\x045\x02\x01\x04\
    \x12\x04\x83\n\x08\x10\n\r\n\x05\x045\x02\x01\x05\x12\x04\x83\n\x11\x17\
    \n\r\n\x05\x045\x02\x01\x01\x12\x04\x83\n\x18#\n\r\n\x05\x045\x02\x01\
    \x03\x12\x04\x83\n&'\n\x0c\n\x02\x046\x12\x06\x86\n\0\x89\n\x01\n\x0b\n\
    \x03\x046\x01\x12\x04\x86\n\x08\x20\n\x0c\n\x04\x046\x02\0\x12\x04\x87\n\
    \x08%\n\r\n\x05\x046\x02\0\x04\x12\x04\x87\n\x08\x10\n\r\n\x05\x046\x02\
    \0\x05\x12\x04\x87\n\x11\x17\n\r\n\x05\x046\x02\0\x01\x12\x04\x87\n\x18\
    \x20\n\r\n\x05\x046\x02\0\x03\x12\x04\x87\n#$\n\x0c\n\x04\x046\x02\x01\
    \x12\x04\x88\n\x08(\n\r\n\x05\x046\x02\x01\x04\x12\x04\x88\n\x08\x10\n\r\
    \n\x05\x046\x02\x01\x05\x12\x04\x88\n\x11\x17\n\r\n\x05\x046\x02\x01\x01\
    \x12\x04\x88\n\x18#\n\r\n\x05\x046\x02\x01\x03\x12\x04\x88\n&'\n\x0c\n\
    \x02\x047\x12\x06\x8b\n\0\x94\n\x01\n\x0b\n\x03\x047\x01\x12\x04\x8b\n\
    \x08'\n\x0c\n\x04\x047\x02\0\x12\x04\x8c\n\x08C\n\r\n\x05\x047\x02\0\x04\
    \x12\x04\x8c\n\x08\x10\n\r\n\x05\x047\x02\0\x06\x12\x04\x8c\n\x11.\n\r\n\
    \x05\x047\x02\0\x01\x12\x04\x8c\n/>\n\r\n\x05\x047\x02\0\x03\x12\x04\x8c\
    \nAB\n\x0c\n\x04\x047\x02\x01\x12\x04\x8d\n\x088\n\r\n\x05\x047\x02\x01\
    \x04\x12\x04\x8d\n\x08\x10\n\r\n\x05\x047\x02\x01\x06\x12\x04\x8d\n\x11&\
    \n\r\n\x05\x047\x02\x01\x01\x12\x04\x8d\n'3\n\r\n\x05\x047\x02\x01\x03\
    \x12\x04\x8d\n67\n\x0c\n\x04\x047\x02\x02\x12\x04\x8e\n\x08.\n\r\n\x05\
    \x047\x02\x02\x04\x12\x04\x8e\n\x08\x10\n\r\n\x05\x047\x02\x02\x05\x12\
    \x04\x8e\n\x11\x17\n\r\n\x05\x047\x02\x02\x01\x12\x04\x8e\n\x18)\n\r\n\
    \x05\x047\x02\x02\x03\x12\x04\x8e\n,-\n\x0c\n\x04\x047\x02\x03\x12\x04\
    \x8f\n\x083\n\r\n\x05\x047\x02\x03\x04\x12\x04\x8f\n\x08\x10\n\r\n\x05\
    \x047\x02\x03\x05\x12\x04\x8f\n\x11\x17\n\r\n\x05\x047\x02\x03\x01\x12\
    \x04\x8f\n\x18.\n\r\n\x05\x047\x02\x03\x03\x12\x04\x8f\n12\n\x0c\n\x04\
    \x047\x02\x04\x12\x04\x90\n\x08>\n\r\n\x05\x047\x02\x04\x04\x12\x04\x90\
    \n\x08\x10\n\r\n\x05\x047\x02\x04\x06\x12\x04\x90\n\x11)\n\r\n\x05\x047\
    \x02\x04\x01\x12\x04\x90\n*9\n\r\n\x05\x047\x02\x04\x03\x12\x04\x90\n<=\
    \n\x0c\n\x04\x047\x02\x05\x12\x04\x91\n\x082\n\r\n\x05\x047\x02\x05\x04\
    \x12\x04\x91\n\x08\x10\n\r\n\x05\x047\x02\x05\x05\x12\x04\x91\n\x11\x17\
    \n\r\n\x05\x047\x02\x05\x01\x12\x04\x91\n\x18-\n\r\n\x05\x047\x02\x05\
    \x03\x12\x04\x91\n01\n\x0c\n\x04\x047\x02\x06\x12\x04\x92\n\x08:\n\r\n\
    \x05\x047\x02\x06\x04\x12\x04\x92\n\x08\x10\n\r\n\x05\x047\x02\x06\x06\
    \x12\x04\x92\n\x11*\n\r\n\x05\x047\x02\x06\x01\x12\x04\x92\n+5\n\r\n\x05\
    \x047\x02\x06\x03\x12\x04\x92\n89\n\x0c\n\x04\x047\x02\x07\x12\x04\x93\n\
    \x08?\n\r\n\x05\x047\x02\x07\x04\x12\x04\x93\n\x08\x10\n\r\n\x05\x047\
    \x02\x07\x06\x12\x04\x93\n\x11.\n\r\n\x05\x047\x02\x07\x01\x12\x04\x93\n\
    /:\n\r\n\x05\x047\x02\x07\x03\x12\x04\x93\n=>\n\x0c\n\x02\x048\x12\x06\
    \x96\n\0\x9a\n\x01\n\x0b\n\x03\x048\x01\x12\x04\x96\n\x08+\n\x0c\n\x04\
    \x048\x02\0\x12\x04\x97\n\x08C\n\r\n\x05\x048\x02\0\x04\x12\x04\x97\n\
    \x08\x10\n\r\n\x05\x048\x02\0\x06\x12\x04\x97\n\x11.\n\r\n\x05\x048\x02\
    \0\x01\x12\x04\x97\n/>\n\r\n\x05\x048\x02\0\x03\x12\x04\x97\nAB\n\x0c\n\
    \x04\x048\x02\x01\x12\x04\x98\n\x088\n\r\n\x05\x048\x02\x01\x04\x12\x04\
    \x98\n\x08\x10\n\r\n\x05\x048\x02\x01\x06\x12\x04\x98\n\x11&\n\r\n\x05\
    \x048\x02\x01\x01\x12\x04\x98\n'3\n\r\n\x05\x048\x02\x01\x03\x12\x04\x98\
    \n67\n\x0c\n\x04\x048\x02\x02\x12\x04\x99\n\x08:\n\r\n\x05\x048\x02\x02\
    \x04\x12\x04\x99\n\x08\x10\n\r\n\x05\x048\x02\x02\x06\x12\x04\x99\n\x11*\
    \n\r\n\x05\x048\x02\x02\x01\x12\x04\x99\n+5\n\r\n\x05\x048\x02\x02\x03\
    \x12\x04\x99\n89\n\x0c\n\x02\x049\x12\x06\x9c\n\0\x9f\n\x01\n\x0b\n\x03\
    \x049\x01\x12\x04\x9c\n\x08!\n\x0c\n\x04\x049\x02\0\x12\x04\x9d\n\x08L\n\
    \r\n\x05\x049\x02\0\x04\x12\x04\x9d\n\x08\x10\n\r\n\x05\x049\x02\0\x06\
    \x12\x04\x9d\n\x110\n\r\n\x05\x049\x02\0\x01\x12\x04\x9d\n1G\n\r\n\x05\
    \x049\x02\0\x03\x12\x04\x9d\nJK\n\x0c\n\x04\x049\x02\x01\x12\x04\x9e\n\
    \x08N\n\r\n\x05\x049\x02\x01\x04\x12\x04\x9e\n\x08\x10\n\r\n\x05\x049\
    \x02\x01\x06\x12\x04\x9e\n\x114\n\r\n\x05\x049\x02\x01\x01\x12\x04\x9e\n\
    5I\n\r\n\x05\x049\x02\x01\x03\x12\x04\x9e\nLM\n\x0c\n\x02\x04:\x12\x06\
    \xa1\n\0\xa4\n\x01\n\x0b\n\x03\x04:\x01\x12\x04\xa1\n\x088\n\x0c\n\x04\
    \x04:\x02\0\x12\x04\xa2\n\x08'\n\r\n\x05\x04:\x02\0\x04\x12\x04\xa2\n\
    \x08\x10\n\r\n\x05\x04:\x02\0\x05\x12\x04\xa2\n\x11\x17\n\r\n\x05\x04:\
    \x02\0\x01\x12\x04\xa2\n\x18\"\n\r\n\x05\x04:\x02\0\x03\x12\x04\xa2\n%&\
    \n\x0c\n\x04\x04:\x02\x01\x12\x04\xa3\n\x08$\n\r\n\x05\x04:\x02\x01\x04\
    \x12\x04\xa3\n\x08\x10\n\r\n\x05\x04:\x02\x01\x05\x12\x04\xa3\n\x11\x17\
    \n\r\n\x05\x04:\x02\x01\x01\x12\x04\xa3\n\x18\x1f\n\r\n\x05\x04:\x02\x01\
    \x03\x12\x04\xa3\n\"#\n\x0c\n\x02\x04;\x12\x06\xa6\n\0\xb0\n\x01\n\x0b\n\
    \x03\x04;\x01\x12\x04\xa6\n\x08@\n\x0e\n\x04\x04;\x04\0\x12\x06\xa7\n\
    \x08\xac\n\t\n\r\n\x05\x04;\x04\0\x01\x12\x04\xa7\n\r\x16\n\x0e\n\x06\
    \x04;\x04\0\x02\0\x12\x04\xa8\n\x10%\n\x0f\n\x07\x04;\x04\0\x02\0\x01\
    \x12\x04\xa8\n\x10\x20\n\x0f\n\x07\x04;\x04\0\x02\0\x02\x12\x04\xa8\n#$\
    \n\x0e\n\x06\x04;\x04\0\x02\x01\x12\x04\xa9\n\x10\x1f\n\x0f\n\x07\x04;\
    \x04\0\x02\x01\x01\x12\x04\xa9\n\x10\x1a\n\x0f\n\x07\x04;\x04\0\x02\x01\
    \x02\x12\x04\xa9\n\x1d\x1e\n\x0e\n\x06\x04;\x04\0\x02\x02\x12\x04\xaa\n\
    \x10\x1f\n\x0f\n\x07\x04;\x04\0\x02\x02\x01\x12\x04\xaa\n\x10\x1a\n\x0f\
    \n\x07\x04;\x04\0\x02\x02\x02\x12\x04\xaa\n\x1d\x1e\n\x0e\n\x06\x04;\x04\
    \0\x02\x03\x12\x04\xab\n\x10\x20\n\x0f\n\x07\x04;\x04\0\x02\x03\x01\x12\
    \x04\xab\n\x10\x1b\n\x0f\n\x07\x04;\x04\0\x02\x03\x02\x12\x04\xab\n\x1e\
    \x1f\n\x0c\n\x04\x04;\x02\0\x12\x04\xae\n\x08_\n\r\n\x05\x04;\x02\0\x04\
    \x12\x04\xae\n\x08\x10\n\r\n\x05\x04;\x02\0\x06\x12\x04\xae\n\x11S\n\r\n\
    \x05\x04;\x02\0\x01\x12\x04\xae\nTZ\n\r\n\x05\x04;\x02\0\x03\x12\x04\xae\
    \n]^\n\x0c\n\x04\x04;\x02\x01\x12\x04\xaf\n\x08F\n\r\n\x05\x04;\x02\x01\
    \x04\x12\x04\xaf\n\x08\x10\n\r\n\x05\x04;\x02\x01\x06\x12\x04\xaf\n\x11*\
    \n\r\n\x05\x04;\x02\x01\x01\x12\x04\xaf\n+A\n\r\n\x05\x04;\x02\x01\x03\
    \x12\x04\xaf\nDE\n\x0c\n\x02\x04<\x12\x06\xb2\n\0\xb6\n\x01\n\x0b\n\x03\
    \x04<\x01\x12\x04\xb2\n\x08\x20\n\x0c\n\x04\x04<\x02\0\x12\x04\xb3\n\x08\
    %\n\r\n\x05\x04<\x02\0\x04\x12\x04\xb3\n\x08\x10\n\r\n\x05\x04<\x02\0\
    \x05\x12\x04\xb3\n\x11\x17\n\r\n\x05\x04<\x02\0\x01\x12\x04\xb3\n\x18\
    \x20\n\r\n\x05\x04<\x02\0\x03\x12\x04\xb3\n#$\n\x0c\n\x04\x04<\x02\x01\
    \x12\x04\xb4\n\x08$\n\r\n\x05\x04<\x02\x01\x04\x12\x04\xb4\n\x08\x10\n\r\
    \n\x05\x04<\x02\x01\x05\x12\x04\xb4\n\x11\x17\n\r\n\x05\x04<\x02\x01\x01\
    \x12\x04\xb4\n\x18\x1f\n\r\n\x05\x04<\x02\x01\x03\x12\x04\xb4\n\"#\n\x0c\
    \n\x04\x04<\x02\x02\x12\x04\xb5\n\x08'\n\r\n\x05\x04<\x02\x02\x04\x12\
    \x04\xb5\n\x08\x10\n\r\n\x05\x04<\x02\x02\x05\x12\x04\xb5\n\x11\x17\n\r\
    \n\x05\x04<\x02\x02\x01\x12\x04\xb5\n\x18\"\n\r\n\x05\x04<\x02\x02\x03\
    \x12\x04\xb5\n%&\n\x0c\n\x02\x04=\x12\x06\xb8\n\0\xbd\n\x01\n\x0b\n\x03\
    \x04=\x01\x12\x04\xb8\n\x080\n\x0c\n\x04\x04=\x02\0\x12\x04\xb9\n\x08'\n\
    \r\n\x05\x04=\x02\0\x04\x12\x04\xb9\n\x08\x10\n\r\n\x05\x04=\x02\0\x05\
    \x12\x04\xb9\n\x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\xb9\n\x18\"\n\r\
    \n\x05\x04=\x02\0\x03\x12\x04\xb9\n%&\n\x0c\n\x04\x04=\x02\x01\x12\x04\
    \xba\n\x082\n\r\n\x05\x04=\x02\x01\x04\x12\x04\xba\n\x08\x10\n\r\n\x05\
    \x04=\x02\x01\x05\x12\x04\xba\n\x11\x17\n\r\n\x05\x04=\x02\x01\x01\x12\
    \x04\xba\n\x18-\n\r\n\x05\x04=\x02\x01\x03\x12\x04\xba\n01\n\x0c\n\x04\
    \x04=\x02\x02\x12\x04\xbb\n\x083\n\r\n\x05\x04=\x02\x02\x04\x12\x04\xbb\
    \n\x08\x10\n\r\n\x05\x04=\x02\x02\x05\x12\x04\xbb\n\x11\x17\n\r\n\x05\
    \x04=\x02\x02\x01\x12\x04\xbb\n\x18.\n\r\n\x05\x04=\x02\x02\x03\x12\x04\
    \xbb\n12\n\x0c\n\x04\x04=\x02\x03\x12\x04\xbc\n\x083\n\r\n\x05\x04=\x02\
    \x03\x04\x12\x04\xbc\n\x08\x10\n\r\n\x05\x04=\x02\x03\x05\x12\x04\xbc\n\
    \x11\x17\n\r\n\x05\x04=\x02\x03\x01\x12\x04\xbc\n\x18.\n\r\n\x05\x04=\
    \x02\x03\x03\x12\x04\xbc\n12\n\x0c\n\x02\x04>\x12\x06\xbf\n\0\xcb\n\x01\
    \n\x0b\n\x03\x04>\x01\x12\x04\xbf\n\x088\n\x0e\n\x04\x04>\x03\0\x12\x06\
    \xc0\n\x08\xc8\n\t\n\r\n\x05\x04>\x03\0\x01\x12\x04\xc0\n\x10\x17\n\x0e\
    \n\x06\x04>\x03\0\x02\0\x12\x04\xc1\n\x10/\n\x0f\n\x07\x04>\x03\0\x02\0\
    \x04\x12\x04\xc1\n\x10\x18\n\x0f\n\x07\x04>\x03\0\x02\0\x05\x12\x04\xc1\
    \n\x19\x1f\n\x0f\n\x07\x04>\x03\0\x02\0\x01\x12\x04\xc1\n\x20*\n\x0f\n\
    \x07\x04>\x03\0\x02\0\x03\x12\x04\xc1\n-.\n\x0e\n\x06\x04>\x03\0\x02\x01\
    \x12\x04\xc2\n\x107\n\x0f\n\x07\x04>\x03\0\x02\x01\x04\x12\x04\xc2\n\x10\
    \x18\n\x0f\n\x07\x04>\x03\0\x02\x01\x05\x12\x04\xc2\n\x19\x1f\n\x0f\n\
    \x07\x04>\x03\0\x02\x01\x01\x12\x04\xc2\n\x202\n\x0f\n\x07\x04>\x03\0\
    \x02\x01\x03\x12\x04\xc2\n56\n\x0e\n\x06\x04>\x03\0\x02\x02\x12\x04\xc3\
    \n\x10:\n\x0f\n\x07\x04>\x03\0\x02\x02\x04\x12\x04\xc3\n\x10\x18\n\x0f\n\
    \x07\x04>\x03\0\x02\x02\x05\x12\x04\xc3\n\x19\x1f\n\x0f\n\x07\x04>\x03\0\
    \x02\x02\x01\x12\x04\xc3\n\x205\n\x0f\n\x07\x04>\x03\0\x02\x02\x03\x12\
    \x04\xc3\n89\n\x0e\n\x06\x04>\x03\0\x02\x03\x12\x04\xc4\n\x108\n\x0f\n\
    \x07\x04>\x03\0\x02\x03\x04\x12\x04\xc4\n\x10\x18\n\x0f\n\x07\x04>\x03\0\
    \x02\x03\x05\x12\x04\xc4\n\x19\x1f\n\x0f\n\x07\x04>\x03\0\x02\x03\x01\
    \x12\x04\xc4\n\x203\n\x0f\n\x07\x04>\x03\0\x02\x03\x03\x12\x04\xc4\n67\n\
    \x0e\n\x06\x04>\x03\0\x02\x04\x12\x04\xc5\n\x10/\n\x0f\n\x07\x04>\x03\0\
    \x02\x04\x04\x12\x04\xc5\n\x10\x18\n\x0f\n\x07\x04>\x03\0\x02\x04\x05\
    \x12\x04\xc5\n\x19\x1f\n\x0f\n\x07\x04>\x03\0\x02\x04\x01\x12\x04\xc5\n\
    \x20*\n\x0f\n\x07\x04>\x03\0\x02\x04\x03\x12\x04\xc5\n-.\n\x0e\n\x06\x04\
    >\x03\0\x02\x05\x12\x04\xc6\n\x10,\n\x0f\n\x07\x04>\x03\0\x02\x05\x04\
    \x12\x04\xc6\n\x10\x18\n\x0f\n\x07\x04>\x03\0\x02\x05\x05\x12\x04\xc6\n\
    \x19\x1f\n\x0f\n\x07\x04>\x03\0\x02\x05\x01\x12\x04\xc6\n\x20'\n\x0f\n\
    \x07\x04>\x03\0\x02\x05\x03\x12\x04\xc6\n*+\n\x0e\n\x06\x04>\x03\0\x02\
    \x06\x12\x04\xc7\n\x101\n\x0f\n\x07\x04>\x03\0\x02\x06\x04\x12\x04\xc7\n\
    \x10\x18\n\x0f\n\x07\x04>\x03\0\x02\x06\x05\x12\x04\xc7\n\x19\x1d\n\x0f\
    \n\x07\x04>\x03\0\x02\x06\x01\x12\x04\xc7\n\x1e,\n\x0f\n\x07\x04>\x03\0\
    \x02\x06\x03\x12\x04\xc7\n/0\n\x0c\n\x04\x04>\x02\0\x12\x04\xca\n\x08W\n\
    \r\n\x05\x04>\x02\0\x04\x12\x04\xca\n\x08\x10\n\r\n\x05\x04>\x02\0\x06\
    \x12\x04\xca\n\x11I\n\r\n\x05\x04>\x02\0\x01\x12\x04\xca\nJR\n\r\n\x05\
    \x04>\x02\0\x03\x12\x04\xca\nUV\n\x0c\n\x02\x04?\x12\x06\xcd\n\0\xdf\n\
    \x01\n\x0b\n\x03\x04?\x01\x12\x04\xcd\n\x08\x18\n\x0e\n\x04\x04?\x03\0\
    \x12\x06\xce\n\x08\xd4\n\t\n\r\n\x05\x04?\x03\0\x01\x12\x04\xce\n\x10\
    \x14\n\x0e\n\x06\x04?\x03\0\x02\0\x12\x04\xcf\n\x10-\n\x0f\n\x07\x04?\
    \x03\0\x02\0\x04\x12\x04\xcf\n\x10\x18\n\x0f\n\x07\x04?\x03\0\x02\0\x05\
    \x12\x04\xcf\n\x19\x1f\n\x0f\n\x07\x04?\x03\0\x02\0\x01\x12\x04\xcf\n\
    \x20(\n\x0f\n\x07\x04?\x03\0\x02\0\x03\x12\x04\xcf\n+,\n\x0e\n\x06\x04?\
    \x03\0\x02\x01\x12\x04\xd0\n\x10-\n\x0f\n\x07\x04?\x03\0\x02\x01\x04\x12\
    \x04\xd0\n\x10\x18\n\x0f\n\x07\x04?\x03\0\x02\x01\x05\x12\x04\xd0\n\x19\
    \x1f\n\x0f\n\x07\x04?\x03\0\x02\x01\x01\x12\x04\xd0\n\x20(\n\x0f\n\x07\
    \x04?\x03\0\x02\x01\x03\x12\x04\xd0\n+,\n\x0e\n\x06\x04?\x03\0\x02\x02\
    \x12\x04\xd1\n\x10,\n\x0f\n\x07\x04?\x03\0\x02\x02\x04\x12\x04\xd1\n\x10\
    \x18\n\x0f\n\x07\x04?\x03\0\x02\x02\x05\x12\x04\xd1\n\x19\x1f\n\x0f\n\
    \x07\x04?\x03\0\x02\x02\x01\x12\x04\xd1\n\x20'\n\x0f\n\x07\x04?\x03\0\
    \x02\x02\x03\x12\x04\xd1\n*+\n\x0e\n\x06\x04?\x03\0\x02\x03\x12\x04\xd2\
    \n\x10.\n\x0f\n\x07\x04?\x03\0\x02\x03\x04\x12\x04\xd2\n\x10\x18\n\x0f\n\
    \x07\x04?\x03\0\x02\x03\x05\x12\x04\xd2\n\x19\x1f\n\x0f\n\x07\x04?\x03\0\
    \x02\x03\x01\x12\x04\xd2\n\x20)\n\x0f\n\x07\x04?\x03\0\x02\x03\x03\x12\
    \x04\xd2\n,-\n\x0e\n\x06\x04?\x03\0\x02\x04\x12\x04\xd3\n\x10+\n\x0f\n\
    \x07\x04?\x03\0\x02\x04\x04\x12\x04\xd3\n\x10\x18\n\x0f\n\x07\x04?\x03\0\
    \x02\x04\x05\x12\x04\xd3\n\x19\x1d\n\x0f\n\x07\x04?\x03\0\x02\x04\x01\
    \x12\x04\xd3\n\x1e&\n\x0f\n\x07\x04?\x03\0\x02\x04\x03\x12\x04\xd3\n)*\n\
    \x0e\n\x04\x04?\x03\x01\x12\x06\xd6\n\x08\xda\n\t\n\r\n\x05\x04?\x03\x01\
    \x01\x12\x04\xd6\n\x10\x17\n\x0e\n\x06\x04?\x03\x01\x02\0\x12\x04\xd7\n\
    \x10-\n\x0f\n\x07\x04?\x03\x01\x02\0\x04\x12\x04\xd7\n\x10\x18\n\x0f\n\
    \x07\x04?\x03\x01\x02\0\x05\x12\x04\xd7\n\x19\x1f\n\x0f\n\x07\x04?\x03\
    \x01\x02\0\x01\x12\x04\xd7\n\x20(\n\x0f\n\x07\x04?\x03\x01\x02\0\x03\x12\
    \x04\xd7\n+,\n\x0e\n\x06\x04?\x03\x01\x02\x01\x12\x04\xd8\n\x10.\n\x0f\n\
    \x07\x04?\x03\x01\x02\x01\x04\x12\x04\xd8\n\x10\x18\n\x0f\n\x07\x04?\x03\
    \x01\x02\x01\x05\x12\x04\xd8\n\x19\x1f\n\x0f\n\x07\x04?\x03\x01\x02\x01\
    \x01\x12\x04\xd8\n\x20)\n\x0f\n\x07\x04?\x03\x01\x02\x01\x03\x12\x04\xd8\
    \n,-\n\x0e\n\x06\x04?\x03\x01\x02\x02\x12\x04\xd9\n\x10,\n\x0f\n\x07\x04\
    ?\x03\x01\x02\x02\x04\x12\x04\xd9\n\x10\x18\n\x0f\n\x07\x04?\x03\x01\x02\
    \x02\x05\x12\x04\xd9\n\x19\x1f\n\x0f\n\x07\x04?\x03\x01\x02\x02\x01\x12\
    \x04\xd9\n\x20'\n\x0f\n\x07\x04?\x03\x01\x02\x02\x03\x12\x04\xd9\n*+\n\
    \x0c\n\x04\x04?\x02\0\x12\x04\xdc\n\x081\n\r\n\x05\x04?\x02\0\x04\x12\
    \x04\xdc\n\x08\x10\n\r\n\x05\x04?\x02\0\x06\x12\x04\xdc\n\x11&\n\r\n\x05\
    \x04?\x02\0\x01\x12\x04\xdc\n',\n\r\n\x05\x04?\x02\0\x03\x12\x04\xdc\n/0\
    \n\x0c\n\x04\x04?\x02\x01\x12\x04\xdd\n\x087\n\r\n\x05\x04?\x02\x01\x04\
    \x12\x04\xdd\n\x08\x10\n\r\n\x05\x04?\x02\x01\x06\x12\x04\xdd\n\x11)\n\r\
    \n\x05\x04?\x02\x01\x01\x12\x04\xdd\n*2\n\r\n\x05\x04?\x02\x01\x03\x12\
    \x04\xdd\n56\n\x0c\n\x04\x04?\x02\x02\x12\x04\xde\n\x08'\n\r\n\x05\x04?\
    \x02\x02\x04\x12\x04\xde\n\x08\x10\n\r\n\x05\x04?\x02\x02\x05\x12\x04\
    \xde\n\x11\x17\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xde\n\x18\"\n\r\n\x05\
    \x04?\x02\x02\x03\x12\x04\xde\n%&\n\x0c\n\x02\x04@\x12\x06\xe1\n\0\xf3\n\
    \x01\n\x0b\n\x03\x04@\x01\x12\x04\xe1\n\x08\x1a\n\x0e\n\x04\x04@\x03\0\
    \x12\x06\xe2\n\x08\xe6\n\t\n\r\n\x05\x04@\x03\0\x01\x12\x04\xe2\n\x10\
    \x19\n\x0e\n\x06\x04@\x03\0\x02\0\x12\x04\xe3\n\x10,\n\x0f\n\x07\x04@\
    \x03\0\x02\0\x04\x12\x04\xe3\n\x10\x18\n\x0f\n\x07\x04@\x03\0\x02\0\x05\
    \x12\x04\xe3\n\x19\x1f\n\x0f\n\x07\x04@\x03\0\x02\0\x01\x12\x04\xe3\n\
    \x20'\n\x0f\n\x07\x04@\x03\0\x02\0\x03\x12\x04\xe3\n*+\n\x0e\n\x06\x04@\
    \x03\0\x02\x01\x12\x04\xe4\n\x10,\n\x0f\n\x07\x04@\x03\0\x02\x01\x04\x12\
    \x04\xe4\n\x10\x18\n\x0f\n\x07\x04@\x03\0\x02\x01\x05\x12\x04\xe4\n\x19\
    \x1f\n\x0f\n\x07\x04@\x03\0\x02\x01\x01\x12\x04\xe4\n\x20'\n\x0f\n\x07\
    \x04@\x03\0\x02\x01\x03\x12\x04\xe4\n*+\n\x0e\n\x06\x04@\x03\0\x02\x02\
    \x12\x04\xe5\n\x10*\n\x0f\n\x07\x04@\x03\0\x02\x02\x04\x12\x04\xe5\n\x10\
    \x18\n\x0f\n\x07\x04@\x03\0\x02\x02\x05\x12\x04\xe5\n\x19\x1f\n\x0f\n\
    \x07\x04@\x03\0\x02\x02\x01\x12\x04\xe5\n\x20%\n\x0f\n\x07\x04@\x03\0\
    \x02\x02\x03\x12\x04\xe5\n()\n\x0e\n\x04\x04@\x03\x01\x12\x06\xe8\n\x08\
    \xec\n\t\n\r\n\x05\x04@\x03\x01\x01\x12\x04\xe8\n\x10\x18\n\x0e\n\x06\
    \x04@\x03\x01\x02\0\x12\x04\xe9\n\x10,\n\x0f\n\x07\x04@\x03\x01\x02\0\
    \x04\x12\x04\xe9\n\x10\x18\n\x0f\n\x07\x04@\x03\x01\x02\0\x05\x12\x04\
    \xe9\n\x19\x1f\n\x0f\n\x07\x04@\x03\x01\x02\0\x01\x12\x04\xe9\n\x20'\n\
    \x0f\n\x07\x04@\x03\x01\x02\0\x03\x12\x04\xe9\n*+\n\x0e\n\x06\x04@\x03\
    \x01\x02\x01\x12\x04\xea\n\x10,\n\x0f\n\x07\x04@\x03\x01\x02\x01\x04\x12\
    \x04\xea\n\x10\x18\n\x0f\n\x07\x04@\x03\x01\x02\x01\x05\x12\x04\xea\n\
    \x19\x1f\n\x0f\n\x07\x04@\x03\x01\x02\x01\x01\x12\x04\xea\n\x20'\n\x0f\n\
    \x07\x04@\x03\x01\x02\x01\x03\x12\x04\xea\n*+\n\x0e\n\x06\x04@\x03\x01\
    \x02\x02\x12\x04\xeb\n\x104\n\x0f\n\x07\x04@\x03\x01\x02\x02\x04\x12\x04\
    \xeb\n\x10\x18\n\x0f\n\x07\x04@\x03\x01\x02\x02\x05\x12\x04\xeb\n\x19\
    \x1d\n\x0f\n\x07\x04@\x03\x01\x02\x02\x01\x12\x04\xeb\n\x1e/\n\x0f\n\x07\
    \x04@\x03\x01\x02\x02\x03\x12\x04\xeb\n23\n\x0c\n\x04\x04@\x02\0\x12\x04\
    \xee\n\x08>\n\r\n\x05\x04@\x02\0\x04\x12\x04\xee\n\x08\x10\n\r\n\x05\x04\
    @\x02\0\x06\x12\x04\xee\n\x11-\n\r\n\x05\x04@\x02\0\x01\x12\x04\xee\n.9\
    \n\r\n\x05\x04@\x02\0\x03\x12\x04\xee\n<=\n\x0c\n\x04\x04@\x02\x01\x12\
    \x04\xef\n\x08<\n\r\n\x05\x04@\x02\x01\x04\x12\x04\xef\n\x08\x10\n\r\n\
    \x05\x04@\x02\x01\x06\x12\x04\xef\n\x11,\n\r\n\x05\x04@\x02\x01\x01\x12\
    \x04\xef\n-7\n\r\n\x05\x04@\x02\x01\x03\x12\x04\xef\n:;\n\x0c\n\x04\x04@\
    \x02\x02\x12\x04\xf0\n\x08!\n\r\n\x05\x04@\x02\x02\x04\x12\x04\xf0\n\x08\
    \x10\n\r\n\x05\x04@\x02\x02\x05\x12\x04\xf0\n\x11\x17\n\r\n\x05\x04@\x02\
    \x02\x01\x12\x04\xf0\n\x18\x1c\n\r\n\x05\x04@\x02\x02\x03\x12\x04\xf0\n\
    \x1f\x20\n\x0c\n\x04\x04@\x02\x03\x12\x04\xf1\n\x08'\n\r\n\x05\x04@\x02\
    \x03\x04\x12\x04\xf1\n\x08\x10\n\r\n\x05\x04@\x02\x03\x05\x12\x04\xf1\n\
    \x11\x17\n\r\n\x05\x04@\x02\x03\x01\x12\x04\xf1\n\x18\"\n\r\n\x05\x04@\
    \x02\x03\x03\x12\x04\xf1\n%&\n\x0c\n\x04\x04@\x02\x04\x12\x04\xf2\n\x08)\
    \n\r\n\x05\x04@\x02\x04\x04\x12\x04\xf2\n\x08\x10\n\r\n\x05\x04@\x02\x04\
    \x05\x12\x04\xf2\n\x11\x15\n\r\n\x05\x04@\x02\x04\x01\x12\x04\xf2\n\x16$\
    \n\r\n\x05\x04@\x02\x04\x03\x12\x04\xf2\n'(\n\x0c\n\x02\x04A\x12\x06\xf5\
    \n\0\xf9\n\x01\n\x0b\n\x03\x04A\x01\x12\x04\xf5\n\x08\x1b\n\x0c\n\x04\
    \x04A\x02\0\x12\x04\xf6\n\x08\"\n\r\n\x05\x04A\x02\0\x04\x12\x04\xf6\n\
    \x08\x10\n\r\n\x05\x04A\x02\0\x05\x12\x04\xf6\n\x11\x17\n\r\n\x05\x04A\
    \x02\0\x01\x12\x04\xf6\n\x18\x1d\n\r\n\x05\x04A\x02\0\x03\x12\x04\xf6\n\
    \x20!\n\x0c\n\x04\x04A\x02\x01\x12\x04\xf7\n\x08%\n\r\n\x05\x04A\x02\x01\
    \x04\x12\x04\xf7\n\x08\x10\n\r\n\x05\x04A\x02\x01\x05\x12\x04\xf7\n\x11\
    \x17\n\r\n\x05\x04A\x02\x01\x01\x12\x04\xf7\n\x18\x20\n\r\n\x05\x04A\x02\
    \x01\x03\x12\x04\xf7\n#$\n\x0c\n\x04\x04A\x02\x02\x12\x04\xf8\n\x08#\n\r\
    \n\x05\x04A\x02\x02\x04\x12\x04\xf8\n\x08\x10\n\r\n\x05\x04A\x02\x02\x05\
    \x12\x04\xf8\n\x11\x17\n\r\n\x05\x04A\x02\x02\x01\x12\x04\xf8\n\x18\x1e\
    \n\r\n\x05\x04A\x02\x02\x03\x12\x04\xf8\n!\"\n\x0c\n\x02\x04B\x12\x06\
    \xfb\n\0\x82\x0b\x01\n\x0b\n\x03\x04B\x01\x12\x04\xfb\n\x08\x1e\n\x0c\n\
    \x04\x04B\x02\0\x12\x04\xfc\n\x08(\n\r\n\x05\x04B\x02\0\x04\x12\x04\xfc\
    \n\x08\x10\n\r\n\x05\x04B\x02\0\x05\x12\x04\xfc\n\x11\x17\n\r\n\x05\x04B\
    \x02\0\x01\x12\x04\xfc\n\x18#\n\r\n\x05\x04B\x02\0\x03\x12\x04\xfc\n&'\n\
    \x0c\n\x04\x04B\x02\x01\x12\x04\xfd\n\x08:\n\r\n\x05\x04B\x02\x01\x04\
    \x12\x04\xfd\n\x08\x10\n\r\n\x05\x04B\x02\x01\x06\x12\x04\xfd\n\x11,\n\r\
    \n\x05\x04B\x02\x01\x01\x12\x04\xfd\n-5\n\r\n\x05\x04B\x02\x01\x03\x12\
    \x04\xfd\n89\n\x0c\n\x04\x04B\x02\x02\x12\x04\xfe\n\x08&\n\r\n\x05\x04B\
    \x02\x02\x04\x12\x04\xfe\n\x08\x10\n\r\n\x05\x04B\x02\x02\x05\x12\x04\
    \xfe\n\x11\x17\n\r\n\x05\x04B\x02\x02\x01\x12\x04\xfe\n\x18!\n\r\n\x05\
    \x04B\x02\x02\x03\x12\x04\xfe\n$%\n\x0c\n\x04\x04B\x02\x03\x12\x04\xff\n\
    \x08+\n\r\n\x05\x04B\x02\x03\x04\x12\x04\xff\n\x08\x10\n\r\n\x05\x04B\
    \x02\x03\x05\x12\x04\xff\n\x11\x17\n\r\n\x05\x04B\x02\x03\x01\x12\x04\
    \xff\n\x18&\n\r\n\x05\x04B\x02\x03\x03\x12\x04\xff\n)*\n\x0c\n\x04\x04B\
    \x02\x04\x12\x04\x80\x0b\x08*\n\r\n\x05\x04B\x02\x04\x04\x12\x04\x80\x0b\
    \x08\x10\n\r\n\x05\x04B\x02\x04\x05\x12\x04\x80\x0b\x11\x17\n\r\n\x05\
    \x04B\x02\x04\x01\x12\x04\x80\x0b\x18%\n\r\n\x05\x04B\x02\x04\x03\x12\
    \x04\x80\x0b()\n\x0c\n\x04\x04B\x02\x05\x12\x04\x81\x0b\x081\n\r\n\x05\
    \x04B\x02\x05\x04\x12\x04\x81\x0b\x08\x10\n\r\n\x05\x04B\x02\x05\x05\x12\
    \x04\x81\x0b\x11\x17\n\r\n\x05\x04B\x02\x05\x01\x12\x04\x81\x0b\x18,\n\r\
    \n\x05\x04B\x02\x05\x03\x12\x04\x81\x0b/0\n\x0c\n\x02\x04C\x12\x06\x84\
    \x0b\0\x87\x0b\x01\n\x0b\n\x03\x04C\x01\x12\x04\x84\x0b\x08,\n\x0c\n\x04\
    \x04C\x02\0\x12\x04\x85\x0b\x08,\n\r\n\x05\x04C\x02\0\x04\x12\x04\x85\
    \x0b\x08\x10\n\r\n\x05\x04C\x02\0\x05\x12\x04\x85\x0b\x11\x15\n\r\n\x05\
    \x04C\x02\0\x01\x12\x04\x85\x0b\x16'\n\r\n\x05\x04C\x02\0\x03\x12\x04\
    \x85\x0b*+\n\x0c\n\x04\x04C\x02\x01\x12\x04\x86\x0b\x08)\n\r\n\x05\x04C\
    \x02\x01\x04\x12\x04\x86\x0b\x08\x10\n\r\n\x05\x04C\x02\x01\x05\x12\x04\
    \x86\x0b\x11\x17\n\r\n\x05\x04C\x02\x01\x01\x12\x04\x86\x0b\x18$\n\r\n\
    \x05\x04C\x02\x01\x03\x12\x04\x86\x0b'(\n\x0c\n\x02\x04D\x12\x06\x89\x0b\
    \0\x8d\x0b\x01\n\x0b\n\x03\x04D\x01\x12\x04\x89\x0b\x08%\n\x0c\n\x04\x04\
    D\x02\0\x12\x04\x8a\x0b\x08!\n\r\n\x05\x04D\x02\0\x04\x12\x04\x8a\x0b\
    \x08\x10\n\r\n\x05\x04D\x02\0\x05\x12\x04\x8a\x0b\x11\x17\n\r\n\x05\x04D\
    \x02\0\x01\x12\x04\x8a\x0b\x18\x1c\n\r\n\x05\x04D\x02\0\x03\x12\x04\x8a\
    \x0b\x1f\x20\n\x0c\n\x04\x04D\x02\x01\x12\x04\x8b\x0b\x08!\n\r\n\x05\x04\
    D\x02\x01\x04\x12\x04\x8b\x0b\x08\x10\n\r\n\x05\x04D\x02\x01\x05\x12\x04\
    \x8b\x0b\x11\x16\n\r\n\x05\x04D\x02\x01\x01\x12\x04\x8b\x0b\x17\x1c\n\r\
    \n\x05\x04D\x02\x01\x03\x12\x04\x8b\x0b\x1f\x20\n\x0c\n\x04\x04D\x02\x02\
    \x12\x04\x8c\x0b\x08&\n\r\n\x05\x04D\x02\x02\x04\x12\x04\x8c\x0b\x08\x10\
    \n\r\n\x05\x04D\x02\x02\x05\x12\x04\x8c\x0b\x11\x17\n\r\n\x05\x04D\x02\
    \x02\x01\x12\x04\x8c\x0b\x18!\n\r\n\x05\x04D\x02\x02\x03\x12\x04\x8c\x0b\
    $%\n\x0c\n\x02\x04E\x12\x06\x8f\x0b\0\x95\x0b\x01\n\x0b\n\x03\x04E\x01\
    \x12\x04\x8f\x0b\x08!\n\x0c\n\x04\x04E\x02\0\x12\x04\x90\x0b\x08!\n\r\n\
    \x05\x04E\x02\0\x04\x12\x04\x90\x0b\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\
    \x04\x90\x0b\x11\x17\n\r\n\x05\x04E\x02\0\x01\x12\x04\x90\x0b\x18\x1c\n\
    \r\n\x05\x04E\x02\0\x03\x12\x04\x90\x0b\x1f\x20\n\x0c\n\x04\x04E\x02\x01\
    \x12\x04\x91\x0b\x08(\n\r\n\x05\x04E\x02\x01\x04\x12\x04\x91\x0b\x08\x10\
    \n\r\n\x05\x04E\x02\x01\x05\x12\x04\x91\x0b\x11\x16\n\r\n\x05\x04E\x02\
    \x01\x01\x12\x04\x91\x0b\x17#\n\r\n\x05\x04E\x02\x01\x03\x12\x04\x91\x0b\
    &'\n\x0c\n\x04\x04E\x02\x02\x12\x04\x92\x0b\x08(\n\r\n\x05\x04E\x02\x02\
    \x04\x12\x04\x92\x0b\x08\x10\n\r\n\x05\x04E\x02\x02\x05\x12\x04\x92\x0b\
    \x11\x15\n\r\n\x05\x04E\x02\x02\x01\x12\x04\x92\x0b\x16#\n\r\n\x05\x04E\
    \x02\x02\x03\x12\x04\x92\x0b&'\n\x0c\n\x04\x04E\x02\x03\x12\x04\x93\x0b\
    \x08(\n\r\n\x05\x04E\x02\x03\x04\x12\x04\x93\x0b\x08\x10\n\r\n\x05\x04E\
    \x02\x03\x05\x12\x04\x93\x0b\x11\x17\n\r\n\x05\x04E\x02\x03\x01\x12\x04\
    \x93\x0b\x18#\n\r\n\x05\x04E\x02\x03\x03\x12\x04\x93\x0b&'\n\x0c\n\x04\
    \x04E\x02\x04\x12\x04\x94\x0b\x08;\n\r\n\x05\x04E\x02\x04\x04\x12\x04\
    \x94\x0b\x08\x10\n\r\n\x05\x04E\x02\x04\x06\x12\x04\x94\x0b\x11.\n\r\n\
    \x05\x04E\x02\x04\x01\x12\x04\x94\x0b/6\n\r\n\x05\x04E\x02\x04\x03\x12\
    \x04\x94\x0b9:\n\x0c\n\x02\x04F\x12\x06\x97\x0b\0\xbe\x0b\x01\n\x0b\n\
    \x03\x04F\x01\x12\x04\x97\x0b\x08!\n\x0c\n\x04\x04F\x02\0\x12\x04\x98\
    \x0b\x08\x1e\n\r\n\x05\x04F\x02\0\x04\x12\x04\x98\x0b\x08\x10\n\r\n\x05\
    \x04F\x02\0\x05\x12\x04\x98\x0b\x11\x16\n\r\n\x05\x04F\x02\0\x01\x12\x04\
    \x98\x0b\x17\x19\n\r\n\x05\x04F\x02\0\x03\x12\x04\x98\x0b\x1c\x1d\n\x0c\
    \n\x04\x04F\x02\x01\x12\x04\x99\x0b\x08!\n\r\n\x05\x04F\x02\x01\x04\x12\
    \x04\x99\x0b\x08\x10\n\r\n\x05\x04F\x02\x01\x05\x12\x04\x99\x0b\x11\x17\
    \n\r\n\x05\x04F\x02\x01\x01\x12\x04\x99\x0b\x18\x1c\n\r\n\x05\x04F\x02\
    \x01\x03\x12\x04\x99\x0b\x1f\x20\n\x0c\n\x04\x04F\x02\x02\x12\x04\x9a\
    \x0b\x08%\n\r\n\x05\x04F\x02\x02\x04\x12\x04\x9a\x0b\x08\x10\n\r\n\x05\
    \x04F\x02\x02\x05\x12\x04\x9a\x0b\x11\x17\n\r\n\x05\x04F\x02\x02\x01\x12\
    \x04\x9a\x0b\x18\x20\n\r\n\x05\x04F\x02\x02\x03\x12\x04\x9a\x0b#$\n\x0c\
    \n\x04\x04F\x02\x03\x12\x04\x9b\x0b\x08%\n\r\n\x05\x04F\x02\x03\x04\x12\
    \x04\x9b\x0b\x08\x10\n\r\n\x05\x04F\x02\x03\x05\x12\x04\x9b\x0b\x11\x17\
    \n\r\n\x05\x04F\x02\x03\x01\x12\x04\x9b\x0b\x18\x20\n\r\n\x05\x04F\x02\
    \x03\x03\x12\x04\x9b\x0b#$\n\x0c\n\x04\x04F\x02\x04\x12\x04\x9c\x0b\x08%\
    \n\r\n\x05\x04F\x02\x04\x04\x12\x04\x9c\x0b\x08\x10\n\r\n\x05\x04F\x02\
    \x04\x05\x12\x04\x9c\x0b\x11\x17\n\r\n\x05\x04F\x02\x04\x01\x12\x04\x9c\
    \x0b\x18\x20\n\r\n\x05\x04F\x02\x04\x03\x12\x04\x9c\x0b#$\n\x0c\n\x04\
    \x04F\x02\x05\x12\x04\x9d\x0b\x08&\n\r\n\x05\x04F\x02\x05\x04\x12\x04\
    \x9d\x0b\x08\x10\n\r\n\x05\x04F\x02\x05\x05\x12\x04\x9d\x0b\x11\x17\n\r\
    \n\x05\x04F\x02\x05\x01\x12\x04\x9d\x0b\x18!\n\r\n\x05\x04F\x02\x05\x03\
    \x12\x04\x9d\x0b$%\n\x0c\n\x04\x04F\x02\x06\x12\x04\x9e\x0b\x08&\n\r\n\
    \x05\x04F\x02\x06\x04\x12\x04\x9e\x0b\x08\x10\n\r\n\x05\x04F\x02\x06\x05\
    \x12\x04\x9e\x0b\x11\x17\n\r\n\x05\x04F\x02\x06\x01\x12\x04\x9e\x0b\x18!\
    \n\r\n\x05\x04F\x02\x06\x03\x12\x04\x9e\x0b$%\n\x0c\n\x04\x04F\x02\x07\
    \x12\x04\x9f\x0b\x08)\n\r\n\x05\x04F\x02\x07\x04\x12\x04\x9f\x0b\x08\x10\
    \n\r\n\x05\x04F\x02\x07\x05\x12\x04\x9f\x0b\x11\x17\n\r\n\x05\x04F\x02\
    \x07\x01\x12\x04\x9f\x0b\x18#\n\r\n\x05\x04F\x02\x07\x03\x12\x04\x9f\x0b\
    &(\n\x0c\n\x04\x04F\x02\x08\x12\x04\xa0\x0b\x08\"\n\r\n\x05\x04F\x02\x08\
    \x04\x12\x04\xa0\x0b\x08\x10\n\r\n\x05\x04F\x02\x08\x05\x12\x04\xa0\x0b\
    \x11\x17\n\r\n\x05\x04F\x02\x08\x01\x12\x04\xa0\x0b\x18\x1c\n\r\n\x05\
    \x04F\x02\x08\x03\x12\x04\xa0\x0b\x1f!\n\x0c\n\x04\x04F\x02\t\x12\x04\
    \xa1\x0b\x08&\n\r\n\x05\x04F\x02\t\x04\x12\x04\xa1\x0b\x08\x10\n\r\n\x05\
    \x04F\x02\t\x05\x12\x04\xa1\x0b\x11\x17\n\r\n\x05\x04F\x02\t\x01\x12\x04\
    \xa1\x0b\x18\x20\n\r\n\x05\x04F\x02\t\x03\x12\x04\xa1\x0b#%\n\x0c\n\x04\
    \x04F\x02\n\x12\x04\xa2\x0b\x08)\n\r\n\x05\x04F\x02\n\x04\x12\x04\xa2\
    \x0b\x08\x10\n\r\n\x05\x04F\x02\n\x05\x12\x04\xa2\x0b\x11\x17\n\r\n\x05\
    \x04F\x02\n\x01\x12\x04\xa2\x0b\x18#\n\r\n\x05\x04F\x02\n\x03\x12\x04\
    \xa2\x0b&(\n\x0c\n\x04\x04F\x02\x0b\x12\x04\xa3\x0b\x08)\n\r\n\x05\x04F\
    \x02\x0b\x04\x12\x04\xa3\x0b\x08\x10\n\r\n\x05\x04F\x02\x0b\x05\x12\x04\
    \xa3\x0b\x11\x17\n\r\n\x05\x04F\x02\x0b\x01\x12\x04\xa3\x0b\x18#\n\r\n\
    \x05\x04F\x02\x0b\x03\x12\x04\xa3\x0b&(\n\x0c\n\x04\x04F\x02\x0c\x12\x04\
    \xa4\x0b\x08#\n\r\n\x05\x04F\x02\x0c\x04\x12\x04\xa4\x0b\x08\x10\n\r\n\
    \x05\x04F\x02\x0c\x05\x12\x04\xa4\x0b\x11\x17\n\r\n\x05\x04F\x02\x0c\x01\
    \x12\x04\xa4\x0b\x18\x1d\n\r\n\x05\x04F\x02\x0c\x03\x12\x04\xa4\x0b\x20\
    \"\n\x0c\n\x04\x04F\x02\r\x12\x04\xa5\x0b\x08$\n\r\n\x05\x04F\x02\r\x04\
    \x12\x04\xa5\x0b\x08\x10\n\r\n\x05\x04F\x02\r\x05\x12\x04\xa5\x0b\x11\
    \x17\n\r\n\x05\x04F\x02\r\x01\x12\x04\xa5\x0b\x18\x1e\n\r\n\x05\x04F\x02\
    \r\x03\x12\x04\xa5\x0b!#\n\x0c\n\x04\x04F\x02\x0e\x12\x04\xa6\x0b\x08&\n\
    \r\n\x05\x04F\x02\x0e\x04\x12\x04\xa6\x0b\x08\x10\n\r\n\x05\x04F\x02\x0e\
    \x05\x12\x04\xa6\x0b\x11\x17\n\r\n\x05\x04F\x02\x0e\x01\x12\x04\xa6\x0b\
    \x18\x20\n\r\n\x05\x04F\x02\x0e\x03\x12\x04\xa6\x0b#%\n\x0c\n\x04\x04F\
    \x02\x0f\x12\x04\xa7\x0b\x08)\n\r\n\x05\x04F\x02\x0f\x04\x12\x04\xa7\x0b\
    \x08\x10\n\r\n\x05\x04F\x02\x0f\x05\x12\x04\xa7\x0b\x11\x17\n\r\n\x05\
    \x04F\x02\x0f\x01\x12\x04\xa7\x0b\x18#\n\r\n\x05\x04F\x02\x0f\x03\x12\
    \x04\xa7\x0b&(\n\x0c\n\x04\x04F\x02\x10\x12\x04\xa8\x0b\x08'\n\r\n\x05\
    \x04F\x02\x10\x04\x12\x04\xa8\x0b\x08\x10\n\r\n\x05\x04F\x02\x10\x05\x12\
    \x04\xa8\x0b\x11\x17\n\r\n\x05\x04F\x02\x10\x01\x12\x04\xa8\x0b\x18!\n\r\
    \n\x05\x04F\x02\x10\x03\x12\x04\xa8\x0b$&\n\x0c\n\x04\x04F\x02\x11\x12\
    \x04\xa9\x0b\x08)\n\r\n\x05\x04F\x02\x11\x04\x12\x04\xa9\x0b\x08\x10\n\r\
    \n\x05\x04F\x02\x11\x05\x12\x04\xa9\x0b\x11\x17\n\r\n\x05\x04F\x02\x11\
    \x01\x12\x04\xa9\x0b\x18#\n\r\n\x05\x04F\x02\x11\x03\x12\x04\xa9\x0b&(\n\
    \x0c\n\x04\x04F\x02\x12\x12\x04\xaa\x0b\x08(\n\r\n\x05\x04F\x02\x12\x04\
    \x12\x04\xaa\x0b\x08\x10\n\r\n\x05\x04F\x02\x12\x05\x12\x04\xaa\x0b\x11\
    \x16\n\r\n\x05\x04F\x02\x12\x01\x12\x04\xaa\x0b\x17\"\n\r\n\x05\x04F\x02\
    \x12\x03\x12\x04\xaa\x0b%'\n\x0c\n\x04\x04F\x02\x13\x12\x04\xab\x0b\x08*\
    \n\r\n\x05\x04F\x02\x13\x04\x12\x04\xab\x0b\x08\x10\n\r\n\x05\x04F\x02\
    \x13\x05\x12\x04\xab\x0b\x11\x16\n\r\n\x05\x04F\x02\x13\x01\x12\x04\xab\
    \x0b\x17$\n\r\n\x05\x04F\x02\x13\x03\x12\x04\xab\x0b')\n\x0c\n\x04\x04F\
    \x02\x14\x12\x04\xac\x0b\x08&\n\r\n\x05\x04F\x02\x14\x04\x12\x04\xac\x0b\
    \x08\x10\n\r\n\x05\x04F\x02\x14\x05\x12\x04\xac\x0b\x11\x16\n\r\n\x05\
    \x04F\x02\x14\x01\x12\x04\xac\x0b\x17\x20\n\r\n\x05\x04F\x02\x14\x03\x12\
    \x04\xac\x0b#%\n\x0c\n\x04\x04F\x02\x15\x12\x04\xad\x0b\x08&\n\r\n\x05\
    \x04F\x02\x15\x04\x12\x04\xad\x0b\x08\x10\n\r\n\x05\x04F\x02\x15\x05\x12\
    \x04\xad\x0b\x11\x16\n\r\n\x05\x04F\x02\x15\x01\x12\x04\xad\x0b\x17\x20\
    \n\r\n\x05\x04F\x02\x15\x03\x12\x04\xad\x0b#%\n\x0c\n\x04\x04F\x02\x16\
    \x12\x04\xae\x0b\x08%\n\r\n\x05\x04F\x02\x16\x04\x12\x04\xae\x0b\x08\x10\
    \n\r\n\x05\x04F\x02\x16\x05\x12\x04\xae\x0b\x11\x17\n\r\n\x05\x04F\x02\
    \x16\x01\x12\x04\xae\x0b\x18\x1f\n\r\n\x05\x04F\x02\x16\x03\x12\x04\xae\
    \x0b\"$\n\x0c\n\x04\x04F\x02\x17\x12\x04\xaf\x0b\x08(\n\r\n\x05\x04F\x02\
    \x17\x04\x12\x04\xaf\x0b\x08\x10\n\r\n\x05\x04F\x02\x17\x05\x12\x04\xaf\
    \x0b\x11\x17\n\r\n\x05\x04F\x02\x17\x01\x12\x04\xaf\x0b\x18\"\n\r\n\x05\
    \x04F\x02\x17\x03\x12\x04\xaf\x0b%'\n\x0c\n\x04\x04F\x02\x18\x12\x04\xb0\
    \x0b\x08(\n\r\n\x05\x04F\x02\x18\x04\x12\x04\xb0\x0b\x08\x10\n\r\n\x05\
    \x04F\x02\x18\x05\x12\x04\xb0\x0b\x11\x17\n\r\n\x05\x04F\x02\x18\x01\x12\
    \x04\xb0\x0b\x18\"\n\r\n\x05\x04F\x02\x18\x03\x12\x04\xb0\x0b%'\n\x0c\n\
    \x04\x04F\x02\x19\x12\x04\xb1\x0b\x08*\n\r\n\x05\x04F\x02\x19\x04\x12\
    \x04\xb1\x0b\x08\x10\n\r\n\x05\x04F\x02\x19\x05\x12\x04\xb1\x0b\x11\x17\
    \n\r\n\x05\x04F\x02\x19\x01\x12\x04\xb1\x0b\x18$\n\r\n\x05\x04F\x02\x19\
    \x03\x12\x04\xb1\x0b')\n\x0c\n\x04\x04F\x02\x1a\x12\x04\xb2\x0b\x08?\n\r\
    \n\x05\x04F\x02\x1a\x04\x12\x04\xb2\x0b\x08\x10\n\r\n\x05\x04F\x02\x1a\
    \x06\x12\x04\xb2\x0b\x11*\n\r\n\x05\x04F\x02\x1a\x01\x12\x04\xb2\x0b+9\n\
    \r\n\x05\x04F\x02\x1a\x03\x12\x04\xb2\x0b<>\n\x0c\n\x04\x04F\x02\x1b\x12\
    \x04\xb3\x0b\x08#\n\r\n\x05\x04F\x02\x1b\x04\x12\x04\xb3\x0b\x08\x10\n\r\
    \n\x05\x04F\x02\x1b\x05\x12\x04\xb3\x0b\x11\x15\n\r\n\x05\x04F\x02\x1b\
    \x01\x12\x04\xb3\x0b\x16\x1d\n\r\n\x05\x04F\x02\x1b\x03\x12\x04\xb3\x0b\
    \x20\"\n\x0c\n\x04\x04F\x02\x1c\x12\x04\xb4\x0b\x08/\n\r\n\x05\x04F\x02\
    \x1c\x04\x12\x04\xb4\x0b\x08\x10\n\r\n\x05\x04F\x02\x1c\x05\x12\x04\xb4\
    \x0b\x11\x15\n\r\n\x05\x04F\x02\x1c\x01\x12\x04\xb4\x0b\x16)\n\r\n\x05\
    \x04F\x02\x1c\x03\x12\x04\xb4\x0b,.\n\x0c\n\x04\x04F\x02\x1d\x12\x04\xb5\
    \x0b\x08-\n\r\n\x05\x04F\x02\x1d\x04\x12\x04\xb5\x0b\x08\x10\n\r\n\x05\
    \x04F\x02\x1d\x05\x12\x04\xb5\x0b\x11\x15\n\r\n\x05\x04F\x02\x1d\x01\x12\
    \x04\xb5\x0b\x16'\n\r\n\x05\x04F\x02\x1d\x03\x12\x04\xb5\x0b*,\n\x0c\n\
    \x04\x04F\x02\x1e\x12\x04\xb6\x0b\x089\n\r\n\x05\x04F\x02\x1e\x04\x12\
    \x04\xb6\x0b\x08\x10\n\r\n\x05\x04F\x02\x1e\x05\x12\x04\xb6\x0b\x11\x15\
    \n\r\n\x05\x04F\x02\x1e\x01\x12\x04\xb6\x0b\x163\n\r\n\x05\x04F\x02\x1e\
    \x03\x12\x04\xb6\x0b68\n\x0c\n\x04\x04F\x02\x1f\x12\x04\xb7\x0b\x087\n\r\
    \n\x05\x04F\x02\x1f\x04\x12\x04\xb7\x0b\x08\x10\n\r\n\x05\x04F\x02\x1f\
    \x05\x12\x04\xb7\x0b\x11\x15\n\r\n\x05\x04F\x02\x1f\x01\x12\x04\xb7\x0b\
    \x161\n\r\n\x05\x04F\x02\x1f\x03\x12\x04\xb7\x0b46\n\x0c\n\x04\x04F\x02\
    \x20\x12\x04\xb8\x0b\x08'\n\r\n\x05\x04F\x02\x20\x04\x12\x04\xb8\x0b\x08\
    \x10\n\r\n\x05\x04F\x02\x20\x05\x12\x04\xb8\x0b\x11\x17\n\r\n\x05\x04F\
    \x02\x20\x01\x12\x04\xb8\x0b\x18!\n\r\n\x05\x04F\x02\x20\x03\x12\x04\xb8\
    \x0b$&\n\x0c\n\x04\x04F\x02!\x12\x04\xb9\x0b\x082\n\r\n\x05\x04F\x02!\
    \x04\x12\x04\xb9\x0b\x08\x10\n\r\n\x05\x04F\x02!\x05\x12\x04\xb9\x0b\x11\
    \x17\n\r\n\x05\x04F\x02!\x01\x12\x04\xb9\x0b\x18,\n\r\n\x05\x04F\x02!\
    \x03\x12\x04\xb9\x0b/1\n\x0c\n\x04\x04F\x02\"\x12\x04\xba\x0b\x08/\n\r\n\
    \x05\x04F\x02\"\x04\x12\x04\xba\x0b\x08\x10\n\r\n\x05\x04F\x02\"\x05\x12\
    \x04\xba\x0b\x11\x17\n\r\n\x05\x04F\x02\"\x01\x12\x04\xba\x0b\x18)\n\r\n\
    \x05\x04F\x02\"\x03\x12\x04\xba\x0b,.\n\x0c\n\x04\x04F\x02#\x12\x04\xbb\
    \x0b\x08,\n\r\n\x05\x04F\x02#\x04\x12\x04\xbb\x0b\x08\x10\n\r\n\x05\x04F\
    \x02#\x05\x12\x04\xbb\x0b\x11\x17\n\r\n\x05\x04F\x02#\x01\x12\x04\xbb\
    \x0b\x18&\n\r\n\x05\x04F\x02#\x03\x12\x04\xbb\x0b)+\n\x0c\n\x04\x04F\x02\
    $\x12\x04\xbc\x0b\x08,\n\r\n\x05\x04F\x02$\x04\x12\x04\xbc\x0b\x08\x10\n\
    \r\n\x05\x04F\x02$\x05\x12\x04\xbc\x0b\x11\x16\n\r\n\x05\x04F\x02$\x01\
    \x12\x04\xbc\x0b\x17&\n\r\n\x05\x04F\x02$\x03\x12\x04\xbc\x0b)+\n\x0c\n\
    \x04\x04F\x02%\x12\x04\xbd\x0b\x08*\n\r\n\x05\x04F\x02%\x04\x12\x04\xbd\
    \x0b\x08\x10\n\r\n\x05\x04F\x02%\x05\x12\x04\xbd\x0b\x11\x17\n\r\n\x05\
    \x04F\x02%\x01\x12\x04\xbd\x0b\x18$\n\r\n\x05\x04F\x02%\x03\x12\x04\xbd\
    \x0b')\n\x0c\n\x02\x04G\x12\x06\xc0\x0b\0\xe3\x0b\x01\n\x0b\n\x03\x04G\
    \x01\x12\x04\xc0\x0b\x08\x18\n\x0c\n\x04\x04G\x02\0\x12\x04\xc1\x0b\x08\
    \x1f\n\r\n\x05\x04G\x02\0\x04\x12\x04\xc1\x0b\x08\x10\n\r\n\x05\x04G\x02\
    \0\x05\x12\x04\xc1\x0b\x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\xc1\x0b\
    \x18\x1a\n\r\n\x05\x04G\x02\0\x03\x12\x04\xc1\x0b\x1d\x1e\n\x0c\n\x04\
    \x04G\x02\x01\x12\x04\xc2\x0b\x08!\n\r\n\x05\x04G\x02\x01\x04\x12\x04\
    \xc2\x0b\x08\x10\n\r\n\x05\x04G\x02\x01\x05\x12\x04\xc2\x0b\x11\x17\n\r\
    \n\x05\x04G\x02\x01\x01\x12\x04\xc2\x0b\x18\x1c\n\r\n\x05\x04G\x02\x01\
    \x03\x12\x04\xc2\x0b\x1f\x20\n\x0c\n\x04\x04G\x02\x02\x12\x04\xc3\x0b\
    \x08%\n\r\n\x05\x04G\x02\x02\x04\x12\x04\xc3\x0b\x08\x10\n\r\n\x05\x04G\
    \x02\x02\x05\x12\x04\xc3\x0b\x11\x17\n\r\n\x05\x04G\x02\x02\x01\x12\x04\
    \xc3\x0b\x18\x20\n\r\n\x05\x04G\x02\x02\x03\x12\x04\xc3\x0b#$\n\x0c\n\
    \x04\x04G\x02\x03\x12\x04\xc4\x0b\x08%\n\r\n\x05\x04G\x02\x03\x04\x12\
    \x04\xc4\x0b\x08\x10\n\r\n\x05\x04G\x02\x03\x05\x12\x04\xc4\x0b\x11\x17\
    \n\r\n\x05\x04G\x02\x03\x01\x12\x04\xc4\x0b\x18\x20\n\r\n\x05\x04G\x02\
    \x03\x03\x12\x04\xc4\x0b#$\n\x0c\n\x04\x04G\x02\x04\x12\x04\xc5\x0b\x08$\
    \n\r\n\x05\x04G\x02\x04\x04\x12\x04\xc5\x0b\x08\x10\n\r\n\x05\x04G\x02\
    \x04\x05\x12\x04\xc5\x0b\x11\x17\n\r\n\x05\x04G\x02\x04\x01\x12\x04\xc5\
    \x0b\x18\x1f\n\r\n\x05\x04G\x02\x04\x03\x12\x04\xc5\x0b\"#\n\x0c\n\x04\
    \x04G\x02\x05\x12\x04\xc6\x0b\x08%\n\r\n\x05\x04G\x02\x05\x04\x12\x04\
    \xc6\x0b\x08\x10\n\r\n\x05\x04G\x02\x05\x05\x12\x04\xc6\x0b\x11\x17\n\r\
    \n\x05\x04G\x02\x05\x01\x12\x04\xc6\x0b\x18\x20\n\r\n\x05\x04G\x02\x05\
    \x03\x12\x04\xc6\x0b#$\n\x0c\n\x04\x04G\x02\x06\x12\x04\xc7\x0b\x08)\n\r\
    \n\x05\x04G\x02\x06\x04\x12\x04\xc7\x0b\x08\x10\n\r\n\x05\x04G\x02\x06\
    \x05\x12\x04\xc7\x0b\x11\x17\n\r\n\x05\x04G\x02\x06\x01\x12\x04\xc7\x0b\
    \x18$\n\r\n\x05\x04G\x02\x06\x03\x12\x04\xc7\x0b'(\n\x0c\n\x04\x04G\x02\
    \x07\x12\x04\xc8\x0b\x08&\n\r\n\x05\x04G\x02\x07\x04\x12\x04\xc8\x0b\x08\
    \x10\n\r\n\x05\x04G\x02\x07\x05\x12\x04\xc8\x0b\x11\x17\n\r\n\x05\x04G\
    \x02\x07\x01\x12\x04\xc8\x0b\x18\x20\n\r\n\x05\x04G\x02\x07\x03\x12\x04\
    \xc8\x0b#%\n\x0c\n\x04\x04G\x02\x08\x12\x04\xc9\x0b\x08%\n\r\n\x05\x04G\
    \x02\x08\x04\x12\x04\xc9\x0b\x08\x10\n\r\n\x05\x04G\x02\x08\x05\x12\x04\
    \xc9\x0b\x11\x16\n\r\n\x05\x04G\x02\x08\x01\x12\x04\xc9\x0b\x17\x1f\n\r\
    \n\x05\x04G\x02\x08\x03\x12\x04\xc9\x0b\"$\n\x0c\n\x04\x04G\x02\t\x12\
    \x04\xca\x0b\x08&\n\r\n\x05\x04G\x02\t\x04\x12\x04\xca\x0b\x08\x10\n\r\n\
    \x05\x04G\x02\t\x05\x12\x04\xca\x0b\x11\x17\n\r\n\x05\x04G\x02\t\x01\x12\
    \x04\xca\x0b\x18\x20\n\r\n\x05\x04G\x02\t\x03\x12\x04\xca\x0b#%\n\x0c\n\
    \x04\x04G\x02\n\x12\x04\xcb\x0b\x08%\n\r\n\x05\x04G\x02\n\x04\x12\x04\
    \xcb\x0b\x08\x10\n\r\n\x05\x04G\x02\n\x05\x12\x04\xcb\x0b\x11\x16\n\r\n\
    \x05\x04G\x02\n\x01\x12\x04\xcb\x0b\x17\x1f\n\r\n\x05\x04G\x02\n\x03\x12\
    \x04\xcb\x0b\"$\n\x0c\n\x04\x04G\x02\x0b\x12\x04\xcc\x0b\x08&\n\r\n\x05\
    \x04G\x02\x0b\x04\x12\x04\xcc\x0b\x08\x10\n\r\n\x05\x04G\x02\x0b\x05\x12\
    \x04\xcc\x0b\x11\x17\n\r\n\x05\x04G\x02\x0b\x01\x12\x04\xcc\x0b\x18\x20\
    \n\r\n\x05\x04G\x02\x0b\x03\x12\x04\xcc\x0b#%\n\x0c\n\x04\x04G\x02\x0c\
    \x12\x04\xcd\x0b\x08%\n\r\n\x05\x04G\x02\x0c\x04\x12\x04\xcd\x0b\x08\x10\
    \n\r\n\x05\x04G\x02\x0c\x05\x12\x04\xcd\x0b\x11\x16\n\r\n\x05\x04G\x02\
    \x0c\x01\x12\x04\xcd\x0b\x17\x1f\n\r\n\x05\x04G\x02\x0c\x03\x12\x04\xcd\
    \x0b\"$\n\x0c\n\x04\x04G\x02\r\x12\x04\xce\x0b\x08*\n\r\n\x05\x04G\x02\r\
    \x04\x12\x04\xce\x0b\x08\x10\n\r\n\x05\x04G\x02\r\x05\x12\x04\xce\x0b\
    \x11\x17\n\r\n\x05\x04G\x02\r\x01\x12\x04\xce\x0b\x18$\n\r\n\x05\x04G\
    \x02\r\x03\x12\x04\xce\x0b')\n\x0c\n\x04\x04G\x02\x0e\x12\x04\xcf\x0b\
    \x08(\n\r\n\x05\x04G\x02\x0e\x04\x12\x04\xcf\x0b\x08\x10\n\r\n\x05\x04G\
    \x02\x0e\x05\x12\x04\xcf\x0b\x11\x17\n\r\n\x05\x04G\x02\x0e\x01\x12\x04\
    \xcf\x0b\x18\"\n\r\n\x05\x04G\x02\x0e\x03\x12\x04\xcf\x0b%'\n\x0c\n\x04\
    \x04G\x02\x0f\x12\x04\xd0\x0b\x08/\n\r\n\x05\x04G\x02\x0f\x04\x12\x04\
    \xd0\x0b\x08\x10\n\r\n\x05\x04G\x02\x0f\x05\x12\x04\xd0\x0b\x11\x17\n\r\
    \n\x05\x04G\x02\x0f\x01\x12\x04\xd0\x0b\x18)\n\r\n\x05\x04G\x02\x0f\x03\
    \x12\x04\xd0\x0b,.\n\x0c\n\x04\x04G\x02\x10\x12\x04\xd1\x0b\x08)\n\r\n\
    \x05\x04G\x02\x10\x04\x12\x04\xd1\x0b\x08\x10\n\r\n\x05\x04G\x02\x10\x05\
    \x12\x04\xd1\x0b\x11\x17\n\r\n\x05\x04G\x02\x10\x01\x12\x04\xd1\x0b\x18#\
    \n\r\n\x05\x04G\x02\x10\x03\x12\x04\xd1\x0b&(\n\x0c\n\x04\x04G\x02\x11\
    \x12\x04\xd2\x0b\x08(\n\r\n\x05\x04G\x02\x11\x04\x12\x04\xd2\x0b\x08\x10\
    \n\r\n\x05\x04G\x02\x11\x05\x12\x04\xd2\x0b\x11\x17\n\r\n\x05\x04G\x02\
    \x11\x01\x12\x04\xd2\x0b\x18\"\n\r\n\x05\x04G\x02\x11\x03\x12\x04\xd2\
    \x0b%'\n\x0c\n\x04\x04G\x02\x12\x12\x04\xd3\x0b\x08(\n\r\n\x05\x04G\x02\
    \x12\x04\x12\x04\xd3\x0b\x08\x10\n\r\n\x05\x04G\x02\x12\x05\x12\x04\xd3\
    \x0b\x11\x17\n\r\n\x05\x04G\x02\x12\x01\x12\x04\xd3\x0b\x18\"\n\r\n\x05\
    \x04G\x02\x12\x03\x12\x04\xd3\x0b%'\n\x0c\n\x04\x04G\x02\x13\x12\x04\xd4\
    \x0b\x08(\n\r\n\x05\x04G\x02\x13\x04\x12\x04\xd4\x0b\x08\x10\n\r\n\x05\
    \x04G\x02\x13\x05\x12\x04\xd4\x0b\x11\x16\n\r\n\x05\x04G\x02\x13\x01\x12\
    \x04\xd4\x0b\x17\"\n\r\n\x05\x04G\x02\x13\x03\x12\x04\xd4\x0b%'\n\x0c\n\
    \x04\x04G\x02\x14\x12\x04\xd5\x0b\x08*\n\r\n\x05\x04G\x02\x14\x04\x12\
    \x04\xd5\x0b\x08\x10\n\r\n\x05\x04G\x02\x14\x05\x12\x04\xd5\x0b\x11\x17\
    \n\r\n\x05\x04G\x02\x14\x01\x12\x04\xd5\x0b\x18$\n\r\n\x05\x04G\x02\x14\
    \x03\x12\x04\xd5\x0b')\n\x0c\n\x04\x04G\x02\x15\x12\x04\xd6\x0b\x08.\n\r\
    \n\x05\x04G\x02\x15\x04\x12\x04\xd6\x0b\x08\x10\n\r\n\x05\x04G\x02\x15\
    \x05\x12\x04\xd6\x0b\x11\x17\n\r\n\x05\x04G\x02\x15\x01\x12\x04\xd6\x0b\
    \x18(\n\r\n\x05\x04G\x02\x15\x03\x12\x04\xd6\x0b+-\n\x0c\n\x04\x04G\x02\
    \x16\x12\x04\xd7\x0b\x08\"\n\r\n\x05\x04G\x02\x16\x04\x12\x04\xd7\x0b\
    \x08\x10\n\r\n\x05\x04G\x02\x16\x05\x12\x04\xd7\x0b\x11\x16\n\r\n\x05\
    \x04G\x02\x16\x01\x12\x04\xd7\x0b\x17\x1c\n\r\n\x05\x04G\x02\x16\x03\x12\
    \x04\xd7\x0b\x1f!\n\x0c\n\x04\x04G\x02\x17\x12\x04\xd8\x0b\x08.\n\r\n\
    \x05\x04G\x02\x17\x04\x12\x04\xd8\x0b\x08\x10\n\r\n\x05\x04G\x02\x17\x05\
    \x12\x04\xd8\x0b\x11\x17\n\r\n\x05\x04G\x02\x17\x01\x12\x04\xd8\x0b\x18(\
    \n\r\n\x05\x04G\x02\x17\x03\x12\x04\xd8\x0b+-\n\x0c\n\x04\x04G\x02\x18\
    \x12\x04\xd9\x0b\x08,\n\r\n\x05\x04G\x02\x18\x04\x12\x04\xd9\x0b\x08\x10\
    \n\r\n\x05\x04G\x02\x18\x05\x12\x04\xd9\x0b\x11\x17\n\r\n\x05\x04G\x02\
    \x18\x01\x12\x04\xd9\x0b\x18&\n\r\n\x05\x04G\x02\x18\x03\x12\x04\xd9\x0b\
    )+\n\x0c\n\x04\x04G\x02\x19\x12\x04\xda\x0b\x08&\n\r\n\x05\x04G\x02\x19\
    \x04\x12\x04\xda\x0b\x08\x10\n\r\n\x05\x04G\x02\x19\x05\x12\x04\xda\x0b\
    \x11\x16\n\r\n\x05\x04G\x02\x19\x01\x12\x04\xda\x0b\x17\x20\n\r\n\x05\
    \x04G\x02\x19\x03\x12\x04\xda\x0b#%\n\x0c\n\x04\x04G\x02\x1a\x12\x04\xdb\
    \x0b\x08-\n\r\n\x05\x04G\x02\x1a\x04\x12\x04\xdb\x0b\x08\x10\n\r\n\x05\
    \x04G\x02\x1a\x05\x12\x04\xdb\x0b\x11\x17\n\r\n\x05\x04G\x02\x1a\x01\x12\
    \x04\xdb\x0b\x18'\n\r\n\x05\x04G\x02\x1a\x03\x12\x04\xdb\x0b*,\n\x0c\n\
    \x04\x04G\x02\x1b\x12\x04\xdc\x0b\x08/\n\r\n\x05\x04G\x02\x1b\x04\x12\
    \x04\xdc\x0b\x08\x10\n\r\n\x05\x04G\x02\x1b\x05\x12\x04\xdc\x0b\x11\x17\
    \n\r\n\x05\x04G\x02\x1b\x01\x12\x04\xdc\x0b\x18)\n\r\n\x05\x04G\x02\x1b\
    \x03\x12\x04\xdc\x0b,.\n\x0c\n\x04\x04G\x02\x1c\x12\x04\xdd\x0b\x08(\n\r\
    \n\x05\x04G\x02\x1c\x04\x12\x04\xdd\x0b\x08\x10\n\r\n\x05\x04G\x02\x1c\
    \x05\x12\x04\xdd\x0b\x11\x17\n\r\n\x05\x04G\x02\x1c\x01\x12\x04\xdd\x0b\
    \x18\"\n\r\n\x05\x04G\x02\x1c\x03\x12\x04\xdd\x0b%'\n\x0c\n\x04\x04G\x02\
    \x1d\x12\x04\xde\x0b\x08)\n\r\n\x05\x04G\x02\x1d\x04\x12\x04\xde\x0b\x08\
    \x10\n\r\n\x05\x04G\x02\x1d\x05\x12\x04\xde\x0b\x11\x16\n\r\n\x05\x04G\
    \x02\x1d\x01\x12\x04\xde\x0b\x17#\n\r\n\x05\x04G\x02\x1d\x03\x12\x04\xde\
    \x0b&(\n\x0c\n\x04\x04G\x02\x1e\x12\x04\xdf\x0b\x08&\n\r\n\x05\x04G\x02\
    \x1e\x04\x12\x04\xdf\x0b\x08\x10\n\r\n\x05\x04G\x02\x1e\x05\x12\x04\xdf\
    \x0b\x11\x17\n\r\n\x05\x04G\x02\x1e\x01\x12\x04\xdf\x0b\x18\x20\n\r\n\
    \x05\x04G\x02\x1e\x03\x12\x04\xdf\x0b#%\n\x0c\n\x04\x04G\x02\x1f\x12\x04\
    \xe0\x0b\x08'\n\r\n\x05\x04G\x02\x1f\x04\x12\x04\xe0\x0b\x08\x10\n\r\n\
    \x05\x04G\x02\x1f\x05\x12\x04\xe0\x0b\x11\x16\n\r\n\x05\x04G\x02\x1f\x01\
    \x12\x04\xe0\x0b\x17!\n\r\n\x05\x04G\x02\x1f\x03\x12\x04\xe0\x0b$&\n\x0c\
    \n\x04\x04G\x02\x20\x12\x04\xe1\x0b\x08:\n\r\n\x05\x04G\x02\x20\x04\x12\
    \x04\xe1\x0b\x08\x10\n\r\n\x05\x04G\x02\x20\x06\x12\x04\xe1\x0b\x11*\n\r\
    \n\x05\x04G\x02\x20\x01\x12\x04\xe1\x0b+4\n\r\n\x05\x04G\x02\x20\x03\x12\
    \x04\xe1\x0b79\n\x0c\n\x04\x04G\x02!\x12\x04\xe2\x0b\x088\n\r\n\x05\x04G\
    \x02!\x04\x12\x04\xe2\x0b\x08\x10\n\r\n\x05\x04G\x02!\x06\x12\x04\xe2\
    \x0b\x11*\n\r\n\x05\x04G\x02!\x01\x12\x04\xe2\x0b+2\n\r\n\x05\x04G\x02!\
    \x03\x12\x04\xe2\x0b57\n\x0c\n\x02\x04H\x12\x06\xe5\x0b\0\xe7\x0b\x01\n\
    \x0b\n\x03\x04H\x01\x12\x04\xe5\x0b\x08\x1d\n\x0c\n\x04\x04H\x02\0\x12\
    \x04\xe6\x0b\x089\n\r\n\x05\x04H\x02\0\x04\x12\x04\xe6\x0b\x08\x10\n\r\n\
    \x05\x04H\x02\0\x06\x12\x04\xe6\x0b\x11*\n\r\n\x05\x04H\x02\0\x01\x12\
    \x04\xe6\x0b+4\n\r\n\x05\x04H\x02\0\x03\x12\x04\xe6\x0b78\n\x0c\n\x02\
    \x04I\x12\x06\xe9\x0b\0\xeb\x0b\x01\n\x0b\n\x03\x04I\x01\x12\x04\xe9\x0b\
    \x08\x19\n\x0c\n\x04\x04I\x02\0\x12\x04\xea\x0b\x085\n\r\n\x05\x04I\x02\
    \0\x04\x12\x04\xea\x0b\x08\x10\n\r\n\x05\x04I\x02\0\x06\x12\x04\xea\x0b\
    \x11*\n\r\n\x05\x04I\x02\0\x01\x12\x04\xea\x0b+0\n\r\n\x05\x04I\x02\0\
    \x03\x12\x04\xea\x0b34\n\x0c\n\x02\x04J\x12\x06\xed\x0b\0\xef\x0b\x01\n\
    \x0b\n\x03\x04J\x01\x12\x04\xed\x0b\x08\x1a\n\x0c\n\x04\x04J\x02\0\x12\
    \x04\xee\x0b\x08-\n\r\n\x05\x04J\x02\0\x04\x12\x04\xee\x0b\x08\x10\n\r\n\
    \x05\x04J\x02\0\x06\x12\x04\xee\x0b\x11!\n\r\n\x05\x04J\x02\0\x01\x12\
    \x04\xee\x0b\"(\n\r\n\x05\x04J\x02\0\x03\x12\x04\xee\x0b+,\n\x0c\n\x02\
    \x04K\x12\x06\xf1\x0b\0\xfc\x0b\x01\n\x0b\n\x03\x04K\x01\x12\x04\xf1\x0b\
    \x08\x1c\n\x0e\n\x04\x04K\x03\0\x12\x06\xf2\x0b\x08\xf9\x0b\t\n\r\n\x05\
    \x04K\x03\0\x01\x12\x04\xf2\x0b\x10\x18\n\x0e\n\x06\x04K\x03\0\x02\0\x12\
    \x04\xf3\x0b\x10'\n\x0f\n\x07\x04K\x03\0\x02\0\x04\x12\x04\xf3\x0b\x10\
    \x18\n\x0f\n\x07\x04K\x03\0\x02\0\x05\x12\x04\xf3\x0b\x19\x1f\n\x0f\n\
    \x07\x04K\x03\0\x02\0\x01\x12\x04\xf3\x0b\x20\"\n\x0f\n\x07\x04K\x03\0\
    \x02\0\x03\x12\x04\xf3\x0b%&\n\x0e\n\x06\x04K\x03\0\x02\x01\x12\x04\xf4\
    \x0b\x10)\n\x0f\n\x07\x04K\x03\0\x02\x01\x04\x12\x04\xf4\x0b\x10\x18\n\
    \x0f\n\x07\x04K\x03\0\x02\x01\x05\x12\x04\xf4\x0b\x19\x1f\n\x0f\n\x07\
    \x04K\x03\0\x02\x01\x01\x12\x04\xf4\x0b\x20$\n\x0f\n\x07\x04K\x03\0\x02\
    \x01\x03\x12\x04\xf4\x0b'(\n\x0e\n\x06\x04K\x03\0\x02\x02\x12\x04\xf5\
    \x0b\x10-\n\x0f\n\x07\x04K\x03\0\x02\x02\x04\x12\x04\xf5\x0b\x10\x18\n\
    \x0f\n\x07\x04K\x03\0\x02\x02\x05\x12\x04\xf5\x0b\x19\x1f\n\x0f\n\x07\
    \x04K\x03\0\x02\x02\x01\x12\x04\xf5\x0b\x20(\n\x0f\n\x07\x04K\x03\0\x02\
    \x02\x03\x12\x04\xf5\x0b+,\n\x0e\n\x06\x04K\x03\0\x02\x03\x12\x04\xf6\
    \x0b\x105\n\x0f\n\x07\x04K\x03\0\x02\x03\x04\x12\x04\xf6\x0b\x10\x18\n\
    \x0f\n\x07\x04K\x03\0\x02\x03\x05\x12\x04\xf6\x0b\x19\x1f\n\x0f\n\x07\
    \x04K\x03\0\x02\x03\x01\x12\x04\xf6\x0b\x200\n\x0f\n\x07\x04K\x03\0\x02\
    \x03\x03\x12\x04\xf6\x0b34\n\x0e\n\x06\x04K\x03\0\x02\x04\x12\x04\xf7\
    \x0b\x101\n\x0f\n\x07\x04K\x03\0\x02\x04\x04\x12\x04\xf7\x0b\x10\x18\n\
    \x0f\n\x07\x04K\x03\0\x02\x04\x05\x12\x04\xf7\x0b\x19\x1f\n\x0f\n\x07\
    \x04K\x03\0\x02\x04\x01\x12\x04\xf7\x0b\x20,\n\x0f\n\x07\x04K\x03\0\x02\
    \x04\x03\x12\x04\xf7\x0b/0\n\x0e\n\x06\x04K\x03\0\x02\x05\x12\x04\xf8\
    \x0b\x10/\n\x0f\n\x07\x04K\x03\0\x02\x05\x04\x12\x04\xf8\x0b\x10\x18\n\
    \x0f\n\x07\x04K\x03\0\x02\x05\x05\x12\x04\xf8\x0b\x19\x1f\n\x0f\n\x07\
    \x04K\x03\0\x02\x05\x01\x12\x04\xf8\x0b\x20*\n\x0f\n\x07\x04K\x03\0\x02\
    \x05\x03\x12\x04\xf8\x0b-.\n\x0c\n\x04\x04K\x02\0\x12\x04\xfb\x0b\x08:\n\
    \r\n\x05\x04K\x02\0\x04\x12\x04\xfb\x0b\x08\x10\n\r\n\x05\x04K\x02\0\x06\
    \x12\x04\xfb\x0b\x11.\n\r\n\x05\x04K\x02\0\x01\x12\x04\xfb\x0b/5\n\r\n\
    \x05\x04K\x02\0\x03\x12\x04\xfb\x0b89\n\x0c\n\x02\x04L\x12\x06\xfe\x0b\0\
    \x88\x0c\x01\n\x0b\n\x03\x04L\x01\x12\x04\xfe\x0b\x08#\n\x0e\n\x04\x04L\
    \x03\0\x12\x06\xff\x0b\x08\x85\x0c\t\n\r\n\x05\x04L\x03\0\x01\x12\x04\
    \xff\x0b\x10\x1f\n\x0e\n\x06\x04L\x03\0\x02\0\x12\x04\x80\x0c\x10&\n\x0f\
    \n\x07\x04L\x03\0\x02\0\x04\x12\x04\x80\x0c\x10\x18\n\x0f\n\x07\x04L\x03\
    \0\x02\0\x05\x12\x04\x80\x0c\x19\x1e\n\x0f\n\x07\x04L\x03\0\x02\0\x01\
    \x12\x04\x80\x0c\x1f!\n\x0f\n\x07\x04L\x03\0\x02\0\x03\x12\x04\x80\x0c$%\
    \n\x0e\n\x06\x04L\x03\0\x02\x01\x12\x04\x81\x0c\x10)\n\x0f\n\x07\x04L\
    \x03\0\x02\x01\x04\x12\x04\x81\x0c\x10\x18\n\x0f\n\x07\x04L\x03\0\x02\
    \x01\x05\x12\x04\x81\x0c\x19\x1f\n\x0f\n\x07\x04L\x03\0\x02\x01\x01\x12\
    \x04\x81\x0c\x20$\n\x0f\n\x07\x04L\x03\0\x02\x01\x03\x12\x04\x81\x0c'(\n\
    \x0e\n\x06\x04L\x03\0\x02\x02\x12\x04\x82\x0c\x10-\n\x0f\n\x07\x04L\x03\
    \0\x02\x02\x04\x12\x04\x82\x0c\x10\x18\n\x0f\n\x07\x04L\x03\0\x02\x02\
    \x05\x12\x04\x82\x0c\x19\x1f\n\x0f\n\x07\x04L\x03\0\x02\x02\x01\x12\x04\
    \x82\x0c\x20(\n\x0f\n\x07\x04L\x03\0\x02\x02\x03\x12\x04\x82\x0c+,\n\x0e\
    \n\x06\x04L\x03\0\x02\x03\x12\x04\x83\x0c\x105\n\x0f\n\x07\x04L\x03\0\
    \x02\x03\x04\x12\x04\x83\x0c\x10\x18\n\x0f\n\x07\x04L\x03\0\x02\x03\x05\
    \x12\x04\x83\x0c\x19\x1f\n\x0f\n\x07\x04L\x03\0\x02\x03\x01\x12\x04\x83\
    \x0c\x200\n\x0f\n\x07\x04L\x03\0\x02\x03\x03\x12\x04\x83\x0c34\n\x0e\n\
    \x06\x04L\x03\0\x02\x04\x12\x04\x84\x0c\x105\n\x0f\n\x07\x04L\x03\0\x02\
    \x04\x04\x12\x04\x84\x0c\x10\x18\n\x0f\n\x07\x04L\x03\0\x02\x04\x05\x12\
    \x04\x84\x0c\x19\x1e\n\x0f\n\x07\x04L\x03\0\x02\x04\x01\x12\x04\x84\x0c\
    \x1f0\n\x0f\n\x07\x04L\x03\0\x02\x04\x03\x12\x04\x84\x0c34\n\x0c\n\x04\
    \x04L\x02\0\x12\x04\x87\x0c\x08O\n\r\n\x05\x04L\x02\0\x04\x12\x04\x87\
    \x0c\x08\x10\n\r\n\x05\x04L\x02\0\x06\x12\x04\x87\x0c\x11<\n\r\n\x05\x04\
    L\x02\0\x01\x12\x04\x87\x0c=J\n\r\n\x05\x04L\x02\0\x03\x12\x04\x87\x0cMN\
    \n\x0c\n\x02\x04M\x12\x06\x8a\x0c\0\x8c\x0c\x01\n\x0b\n\x03\x04M\x01\x12\
    \x04\x8a\x0c\x08!\n\x0c\n\x04\x04M\x02\0\x12\x04\x8b\x0c\x08.\n\r\n\x05\
    \x04M\x02\0\x04\x12\x04\x8b\x0c\x08\x10\n\r\n\x05\x04M\x02\0\x05\x12\x04\
    \x8b\x0c\x11\x15\n\r\n\x05\x04M\x02\0\x01\x12\x04\x8b\x0c\x16)\n\r\n\x05\
    \x04M\x02\0\x03\x12\x04\x8b\x0c,-\n\x0c\n\x02\x04N\x12\x06\x8e\x0c\0\x97\
    \x0c\x01\n\x0b\n\x03\x04N\x01\x12\x04\x8e\x0c\x08\x20\n\x0c\n\x04\x04N\
    \x02\0\x12\x04\x8f\x0c\x08'\n\r\n\x05\x04N\x02\0\x04\x12\x04\x8f\x0c\x08\
    \x10\n\r\n\x05\x04N\x02\0\x05\x12\x04\x8f\x0c\x11\x17\n\r\n\x05\x04N\x02\
    \0\x01\x12\x04\x8f\x0c\x18\"\n\r\n\x05\x04N\x02\0\x03\x12\x04\x8f\x0c%&\
    \n\x0c\n\x04\x04N\x02\x01\x12\x04\x90\x0c\x08-\n\r\n\x05\x04N\x02\x01\
    \x04\x12\x04\x90\x0c\x08\x10\n\r\n\x05\x04N\x02\x01\x05\x12\x04\x90\x0c\
    \x11\x18\n\r\n\x05\x04N\x02\x01\x01\x12\x04\x90\x0c\x19(\n\r\n\x05\x04N\
    \x02\x01\x03\x12\x04\x90\x0c+,\n\x0c\n\x04\x04N\x02\x02\x12\x04\x91\x0c\
    \x08!\n\r\n\x05\x04N\x02\x02\x04\x12\x04\x91\x0c\x08\x10\n\r\n\x05\x04N\
    \x02\x02\x05\x12\x04\x91\x0c\x11\x16\n\r\n\x05\x04N\x02\x02\x01\x12\x04\
    \x91\x0c\x17\x1c\n\r\n\x05\x04N\x02\x02\x03\x12\x04\x91\x0c\x1f\x20\n\
    \x0c\n\x04\x04N\x02\x03\x12\x04\x92\x0c\x08(\n\r\n\x05\x04N\x02\x03\x04\
    \x12\x04\x92\x0c\x08\x10\n\r\n\x05\x04N\x02\x03\x05\x12\x04\x92\x0c\x11\
    \x17\n\r\n\x05\x04N\x02\x03\x01\x12\x04\x92\x0c\x18#\n\r\n\x05\x04N\x02\
    \x03\x03\x12\x04\x92\x0c&'\n\x0c\n\x04\x04N\x02\x04\x12\x04\x93\x0c\x08$\
    \n\r\n\x05\x04N\x02\x04\x04\x12\x04\x93\x0c\x08\x10\n\r\n\x05\x04N\x02\
    \x04\x05\x12\x04\x93\x0c\x11\x17\n\r\n\x05\x04N\x02\x04\x01\x12\x04\x93\
    \x0c\x18\x1f\n\r\n\x05\x04N\x02\x04\x03\x12\x04\x93\x0c\"#\n\x0c\n\x04\
    \x04N\x02\x05\x12\x04\x94\x0c\x08&\n\r\n\x05\x04N\x02\x05\x04\x12\x04\
    \x94\x0c\x08\x10\n\r\n\x05\x04N\x02\x05\x05\x12\x04\x94\x0c\x11\x17\n\r\
    \n\x05\x04N\x02\x05\x01\x12\x04\x94\x0c\x18!\n\r\n\x05\x04N\x02\x05\x03\
    \x12\x04\x94\x0c$%\n\x0c\n\x04\x04N\x02\x06\x12\x04\x95\x0c\x08)\n\r\n\
    \x05\x04N\x02\x06\x04\x12\x04\x95\x0c\x08\x10\n\r\n\x05\x04N\x02\x06\x05\
    \x12\x04\x95\x0c\x11\x17\n\r\n\x05\x04N\x02\x06\x01\x12\x04\x95\x0c\x18$\
    \n\r\n\x05\x04N\x02\x06\x03\x12\x04\x95\x0c'(\n\x0c\n\x04\x04N\x02\x07\
    \x12\x04\x96\x0c\x08)\n\r\n\x05\x04N\x02\x07\x04\x12\x04\x96\x0c\x08\x10\
    \n\r\n\x05\x04N\x02\x07\x05\x12\x04\x96\x0c\x11\x17\n\r\n\x05\x04N\x02\
    \x07\x01\x12\x04\x96\x0c\x18$\n\r\n\x05\x04N\x02\x07\x03\x12\x04\x96\x0c\
    '(\n\x0c\n\x02\x04O\x12\x06\x99\x0c\0\xa2\x0c\x01\n\x0b\n\x03\x04O\x01\
    \x12\x04\x99\x0c\x08%\n\x0c\n\x04\x04O\x02\0\x12\x04\x9a\x0c\x08'\n\r\n\
    \x05\x04O\x02\0\x04\x12\x04\x9a\x0c\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\
    \x04\x9a\x0c\x11\x17\n\r\n\x05\x04O\x02\0\x01\x12\x04\x9a\x0c\x18\"\n\r\
    \n\x05\x04O\x02\0\x03\x12\x04\x9a\x0c%&\n\x0c\n\x04\x04O\x02\x01\x12\x04\
    \x9b\x0c\x08&\n\r\n\x05\x04O\x02\x01\x04\x12\x04\x9b\x0c\x08\x10\n\r\n\
    \x05\x04O\x02\x01\x05\x12\x04\x9b\x0c\x11\x17\n\r\n\x05\x04O\x02\x01\x01\
    \x12\x04\x9b\x0c\x18!\n\r\n\x05\x04O\x02\x01\x03\x12\x04\x9b\x0c$%\n\x0c\
    \n\x04\x04O\x02\x02\x12\x04\x9c\x0c\x08$\n\r\n\x05\x04O\x02\x02\x04\x12\
    \x04\x9c\x0c\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\x04\x9c\x0c\x11\x17\
    \n\r\n\x05\x04O\x02\x02\x01\x12\x04\x9c\x0c\x18\x1f\n\r\n\x05\x04O\x02\
    \x02\x03\x12\x04\x9c\x0c\"#\n\x0c\n\x04\x04O\x02\x03\x12\x04\x9d\x0c\x08\
    2\n\r\n\x05\x04O\x02\x03\x04\x12\x04\x9d\x0c\x08\x10\n\r\n\x05\x04O\x02\
    \x03\x05\x12\x04\x9d\x0c\x11\x17\n\r\n\x05\x04O\x02\x03\x01\x12\x04\x9d\
    \x0c\x18-\n\r\n\x05\x04O\x02\x03\x03\x12\x04\x9d\x0c01\n\x0c\n\x04\x04O\
    \x02\x04\x12\x04\x9e\x0c\x08-\n\r\n\x05\x04O\x02\x04\x04\x12\x04\x9e\x0c\
    \x08\x10\n\r\n\x05\x04O\x02\x04\x05\x12\x04\x9e\x0c\x11\x17\n\r\n\x05\
    \x04O\x02\x04\x01\x12\x04\x9e\x0c\x18(\n\r\n\x05\x04O\x02\x04\x03\x12\
    \x04\x9e\x0c+,\n\x0c\n\x04\x04O\x02\x05\x12\x04\x9f\x0c\x08$\n\r\n\x05\
    \x04O\x02\x05\x04\x12\x04\x9f\x0c\x08\x10\n\r\n\x05\x04O\x02\x05\x05\x12\
    \x04\x9f\x0c\x11\x17\n\r\n\x05\x04O\x02\x05\x01\x12\x04\x9f\x0c\x18\x1f\
    \n\r\n\x05\x04O\x02\x05\x03\x12\x04\x9f\x0c\"#\n\x0c\n\x04\x04O\x02\x06\
    \x12\x04\xa0\x0c\x08&\n\r\n\x05\x04O\x02\x06\x04\x12\x04\xa0\x0c\x08\x10\
    \n\r\n\x05\x04O\x02\x06\x05\x12\x04\xa0\x0c\x11\x17\n\r\n\x05\x04O\x02\
    \x06\x01\x12\x04\xa0\x0c\x18!\n\r\n\x05\x04O\x02\x06\x03\x12\x04\xa0\x0c\
    $%\n\x0c\n\x04\x04O\x02\x07\x12\x04\xa1\x0c\x08)\n\r\n\x05\x04O\x02\x07\
    \x04\x12\x04\xa1\x0c\x08\x10\n\r\n\x05\x04O\x02\x07\x05\x12\x04\xa1\x0c\
    \x11\x17\n\r\n\x05\x04O\x02\x07\x01\x12\x04\xa1\x0c\x18$\n\r\n\x05\x04O\
    \x02\x07\x03\x12\x04\xa1\x0c'(\n\x0c\n\x02\x04P\x12\x06\xa4\x0c\0\xaf\
    \x0c\x01\n\x0b\n\x03\x04P\x01\x12\x04\xa4\x0c\x08\x1e\n\x0c\n\x04\x04P\
    \x02\0\x12\x04\xa5\x0c\x08(\n\r\n\x05\x04P\x02\0\x04\x12\x04\xa5\x0c\x08\
    \x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\xa5\x0c\x11\x17\n\r\n\x05\x04P\x02\
    \0\x01\x12\x04\xa5\x0c\x18#\n\r\n\x05\x04P\x02\0\x03\x12\x04\xa5\x0c&'\n\
    \x0c\n\x04\x04P\x02\x01\x12\x04\xa6\x0c\x08(\n\r\n\x05\x04P\x02\x01\x04\
    \x12\x04\xa6\x0c\x08\x10\n\r\n\x05\x04P\x02\x01\x05\x12\x04\xa6\x0c\x11\
    \x17\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xa6\x0c\x18#\n\r\n\x05\x04P\x02\
    \x01\x03\x12\x04\xa6\x0c&'\n\x0c\n\x04\x04P\x02\x02\x12\x04\xa7\x0c\x08$\
    \n\r\n\x05\x04P\x02\x02\x04\x12\x04\xa7\x0c\x08\x10\n\r\n\x05\x04P\x02\
    \x02\x05\x12\x04\xa7\x0c\x11\x17\n\r\n\x05\x04P\x02\x02\x01\x12\x04\xa7\
    \x0c\x18\x1f\n\r\n\x05\x04P\x02\x02\x03\x12\x04\xa7\x0c\"#\n\x0c\n\x04\
    \x04P\x02\x03\x12\x04\xa8\x0c\x08&\n\r\n\x05\x04P\x02\x03\x04\x12\x04\
    \xa8\x0c\x08\x10\n\r\n\x05\x04P\x02\x03\x05\x12\x04\xa8\x0c\x11\x16\n\r\
    \n\x05\x04P\x02\x03\x01\x12\x04\xa8\x0c\x17!\n\r\n\x05\x04P\x02\x03\x03\
    \x12\x04\xa8\x0c$%\n\x0c\n\x04\x04P\x02\x04\x12\x04\xa9\x0c\x08&\n\r\n\
    \x05\x04P\x02\x04\x04\x12\x04\xa9\x0c\x08\x10\n\r\n\x05\x04P\x02\x04\x05\
    \x12\x04\xa9\x0c\x11\x16\n\r\n\x05\x04P\x02\x04\x01\x12\x04\xa9\x0c\x17!\
    \n\r\n\x05\x04P\x02\x04\x03\x12\x04\xa9\x0c$%\n\x0c\n\x04\x04P\x02\x05\
    \x12\x04\xaa\x0c\x08&\n\r\n\x05\x04P\x02\x05\x04\x12\x04\xaa\x0c\x08\x10\
    \n\r\n\x05\x04P\x02\x05\x05\x12\x04\xaa\x0c\x11\x16\n\r\n\x05\x04P\x02\
    \x05\x01\x12\x04\xaa\x0c\x17!\n\r\n\x05\x04P\x02\x05\x03\x12\x04\xaa\x0c\
    $%\n\x0c\n\x04\x04P\x02\x06\x12\x04\xab\x0c\x08$\n\r\n\x05\x04P\x02\x06\
    \x04\x12\x04\xab\x0c\x08\x10\n\r\n\x05\x04P\x02\x06\x05\x12\x04\xab\x0c\
    \x11\x16\n\r\n\x05\x04P\x02\x06\x01\x12\x04\xab\x0c\x17\x1f\n\r\n\x05\
    \x04P\x02\x06\x03\x12\x04\xab\x0c\"#\n\x0c\n\x04\x04P\x02\x07\x12\x04\
    \xac\x0c\x08!\n\r\n\x05\x04P\x02\x07\x04\x12\x04\xac\x0c\x08\x10\n\r\n\
    \x05\x04P\x02\x07\x05\x12\x04\xac\x0c\x11\x16\n\r\n\x05\x04P\x02\x07\x01\
    \x12\x04\xac\x0c\x17\x1c\n\r\n\x05\x04P\x02\x07\x03\x12\x04\xac\x0c\x1f\
    \x20\n\x0c\n\x04\x04P\x02\x08\x12\x04\xad\x0c\x08+\n\r\n\x05\x04P\x02\
    \x08\x04\x12\x04\xad\x0c\x08\x10\n\r\n\x05\x04P\x02\x08\x05\x12\x04\xad\
    \x0c\x11\x17\n\r\n\x05\x04P\x02\x08\x01\x12\x04\xad\x0c\x18&\n\r\n\x05\
    \x04P\x02\x08\x03\x12\x04\xad\x0c)*\n\x0c\n\x04\x04P\x02\t\x12\x04\xae\
    \x0c\x08(\n\r\n\x05\x04P\x02\t\x04\x12\x04\xae\x0c\x08\x10\n\r\n\x05\x04\
    P\x02\t\x05\x12\x04\xae\x0c\x11\x17\n\r\n\x05\x04P\x02\t\x01\x12\x04\xae\
    \x0c\x18\"\n\r\n\x05\x04P\x02\t\x03\x12\x04\xae\x0c%'\n\x0c\n\x02\x04Q\
    \x12\x06\xb1\x0c\0\xb7\x0c\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xb1\x0c\x08\
    \x1b\n\x0c\n\x04\x04Q\x02\0\x12\x04\xb2\x0c\x08%\n\r\n\x05\x04Q\x02\0\
    \x04\x12\x04\xb2\x0c\x08\x10\n\r\n\x05\x04Q\x02\0\x05\x12\x04\xb2\x0c\
    \x11\x17\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xb2\x0c\x18\x20\n\r\n\x05\x04Q\
    \x02\0\x03\x12\x04\xb2\x0c#$\n\x0c\n\x04\x04Q\x02\x01\x12\x04\xb3\x0c\
    \x08%\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xb3\x0c\x08\x10\n\r\n\x05\x04Q\
    \x02\x01\x06\x12\x04\xb3\x0c\x11\x17\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\
    \xb3\x0c\x18\x20\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xb3\x0c#$\n\x0c\n\
    \x04\x04Q\x02\x02\x12\x04\xb4\x0c\x08$\n\r\n\x05\x04Q\x02\x02\x04\x12\
    \x04\xb4\x0c\x08\x10\n\r\n\x05\x04Q\x02\x02\x05\x12\x04\xb4\x0c\x11\x17\
    \n\r\n\x05\x04Q\x02\x02\x01\x12\x04\xb4\x0c\x18\x1f\n\r\n\x05\x04Q\x02\
    \x02\x03\x12\x04\xb4\x0c\"#\n\x0c\n\x04\x04Q\x02\x03\x12\x04\xb5\x0c\x08\
    5\n\r\n\x05\x04Q\x02\x03\x04\x12\x04\xb5\x0c\x08\x10\n\r\n\x05\x04Q\x02\
    \x03\x06\x12\x04\xb5\x0c\x11'\n\r\n\x05\x04Q\x02\x03\x01\x12\x04\xb5\x0c\
    (0\n\r\n\x05\x04Q\x02\x03\x03\x12\x04\xb5\x0c34\n\x0c\n\x04\x04Q\x02\x04\
    \x12\x04\xb6\x0c\x084\n\r\n\x05\x04Q\x02\x04\x04\x12\x04\xb6\x0c\x08\x10\
    \n\r\n\x05\x04Q\x02\x04\x06\x12\x04\xb6\x0c\x11%\n\r\n\x05\x04Q\x02\x04\
    \x01\x12\x04\xb6\x0c&/\n\r\n\x05\x04Q\x02\x04\x03\x12\x04\xb6\x0c23\n\
    \x0c\n\x02\x04R\x12\x06\xb9\x0c\0\xbb\x0c\x01\n\x0b\n\x03\x04R\x01\x12\
    \x04\xb9\x0c\x08,\n\x0c\n\x04\x04R\x02\0\x12\x04\xba\x0c\x08)\n\r\n\x05\
    \x04R\x02\0\x04\x12\x04\xba\x0c\x08\x10\n\r\n\x05\x04R\x02\0\x05\x12\x04\
    \xba\x0c\x11\x17\n\r\n\x05\x04R\x02\0\x01\x12\x04\xba\x0c\x18$\n\r\n\x05\
    \x04R\x02\0\x03\x12\x04\xba\x0c'(\n\x0c\n\x02\x04S\x12\x06\xbd\x0c\0\xc1\
    \x0c\x01\n\x0b\n\x03\x04S\x01\x12\x04\xbd\x0c\x08\x17\n\x0c\n\x04\x04S\
    \x02\0\x12\x04\xbe\x0c\x08/\n\r\n\x05\x04S\x02\0\x04\x12\x04\xbe\x0c\x08\
    \x10\n\r\n\x05\x04S\x02\0\x06\x12\x04\xbe\x0c\x11$\n\r\n\x05\x04S\x02\0\
    \x01\x12\x04\xbe\x0c%*\n\r\n\x05\x04S\x02\0\x03\x12\x04\xbe\x0c-.\n\x0c\
    \n\x04\x04S\x02\x01\x12\x04\xbf\x0c\x08S\n\r\n\x05\x04S\x02\x01\x04\x12\
    \x04\xbf\x0c\x08\x10\n\r\n\x05\x04S\x02\x01\x06\x12\x04\xbf\x0c\x115\n\r\
    \n\x05\x04S\x02\x01\x01\x12\x04\xbf\x0c6N\n\r\n\x05\x04S\x02\x01\x03\x12\
    \x04\xbf\x0cQR\n\x0c\n\x04\x04S\x02\x02\x12\x04\xc0\x0c\x08.\n\r\n\x05\
    \x04S\x02\x02\x04\x12\x04\xc0\x0c\x08\x10\n\r\n\x05\x04S\x02\x02\x05\x12\
    \x04\xc0\x0c\x11\x17\n\r\n\x05\x04S\x02\x02\x01\x12\x04\xc0\x0c\x18)\n\r\
    \n\x05\x04S\x02\x02\x03\x12\x04\xc0\x0c,-\n\x0c\n\x02\x04T\x12\x06\xc3\
    \x0c\0\xc8\x0c\x01\n\x0b\n\x03\x04T\x01\x12\x04\xc3\x0c\x08\x17\n\x0c\n\
    \x04\x04T\x02\0\x12\x04\xc4\x0c\x08$\n\r\n\x05\x04T\x02\0\x04\x12\x04\
    \xc4\x0c\x08\x10\n\r\n\x05\x04T\x02\0\x05\x12\x04\xc4\x0c\x11\x17\n\r\n\
    \x05\x04T\x02\0\x01\x12\x04\xc4\x0c\x18\x1f\n\r\n\x05\x04T\x02\0\x03\x12\
    \x04\xc4\x0c\"#\n\x0c\n\x04\x04T\x02\x01\x12\x04\xc5\x0c\x08(\n\r\n\x05\
    \x04T\x02\x01\x04\x12\x04\xc5\x0c\x08\x10\n\r\n\x05\x04T\x02\x01\x05\x12\
    \x04\xc5\x0c\x11\x17\n\r\n\x05\x04T\x02\x01\x01\x12\x04\xc5\x0c\x18#\n\r\
    \n\x05\x04T\x02\x01\x03\x12\x04\xc5\x0c&'\n\x0c\n\x04\x04T\x02\x02\x12\
    \x04\xc6\x0c\x08$\n\r\n\x05\x04T\x02\x02\x04\x12\x04\xc6\x0c\x08\x10\n\r\
    \n\x05\x04T\x02\x02\x05\x12\x04\xc6\x0c\x11\x17\n\r\n\x05\x04T\x02\x02\
    \x01\x12\x04\xc6\x0c\x18\x1f\n\r\n\x05\x04T\x02\x02\x03\x12\x04\xc6\x0c\
    \"#\n\x0c\n\x04\x04T\x02\x03\x12\x04\xc7\x0c\x08+\n\r\n\x05\x04T\x02\x03\
    \x04\x12\x04\xc7\x0c\x08\x10\n\r\n\x05\x04T\x02\x03\x05\x12\x04\xc7\x0c\
    \x11\x17\n\r\n\x05\x04T\x02\x03\x01\x12\x04\xc7\x0c\x18&\n\r\n\x05\x04T\
    \x02\x03\x03\x12\x04\xc7\x0c)*\n\x0c\n\x02\x04U\x12\x06\xca\x0c\0\xcc\
    \x0c\x01\n\x0b\n\x03\x04U\x01\x12\x04\xca\x0c\x08\x19\n\x0c\n\x04\x04U\
    \x02\0\x12\x04\xcb\x0c\x08,\n\r\n\x05\x04U\x02\0\x04\x12\x04\xcb\x0c\x08\
    \x10\n\r\n\x05\x04U\x02\0\x06\x12\x04\xcb\x0c\x11\x20\n\r\n\x05\x04U\x02\
    \0\x01\x12\x04\xcb\x0c!'\n\r\n\x05\x04U\x02\0\x03\x12\x04\xcb\x0c*+\n\
    \x0c\n\x02\x04V\x12\x06\xce\x0c\0\xd2\x0c\x01\n\x0b\n\x03\x04V\x01\x12\
    \x04\xce\x0c\x08\x19\n\x0c\n\x04\x04V\x02\0\x12\x04\xcf\x0c\x081\n\r\n\
    \x05\x04V\x02\0\x04\x12\x04\xcf\x0c\x08\x10\n\r\n\x05\x04V\x02\0\x05\x12\
    \x04\xcf\x0c\x11\x17\n\r\n\x05\x04V\x02\0\x01\x12\x04\xcf\x0c\x18,\n\r\n\
    \x05\x04V\x02\0\x03\x12\x04\xcf\x0c/0\n\x0c\n\x04\x04V\x02\x01\x12\x04\
    \xd0\x0c\x08(\n\r\n\x05\x04V\x02\x01\x04\x12\x04\xd0\x0c\x08\x10\n\r\n\
    \x05\x04V\x02\x01\x05\x12\x04\xd0\x0c\x11\x17\n\r\n\x05\x04V\x02\x01\x01\
    \x12\x04\xd0\x0c\x18#\n\r\n\x05\x04V\x02\x01\x03\x12\x04\xd0\x0c&'\n\x0c\
    \n\x04\x04V\x02\x02\x12\x04\xd1\x0c\x08&\n\r\n\x05\x04V\x02\x02\x04\x12\
    \x04\xd1\x0c\x08\x10\n\r\n\x05\x04V\x02\x02\x05\x12\x04\xd1\x0c\x11\x17\
    \n\r\n\x05\x04V\x02\x02\x01\x12\x04\xd1\x0c\x18!\n\r\n\x05\x04V\x02\x02\
    \x03\x12\x04\xd1\x0c$%\n\x0c\n\x02\x04W\x12\x06\xd4\x0c\0\xd7\x0c\x01\n\
    \x0b\n\x03\x04W\x01\x12\x04\xd4\x0c\x08\x1d\n\x0c\n\x04\x04W\x02\0\x12\
    \x04\xd5\x0c\x08$\n\r\n\x05\x04W\x02\0\x04\x12\x04\xd5\x0c\x08\x10\n\r\n\
    \x05\x04W\x02\0\x05\x12\x04\xd5\x0c\x11\x17\n\r\n\x05\x04W\x02\0\x01\x12\
    \x04\xd5\x0c\x18\x1f\n\r\n\x05\x04W\x02\0\x03\x12\x04\xd5\x0c\"#\n\x0c\n\
    \x04\x04W\x02\x01\x12\x04\xd6\x0c\x082\n\r\n\x05\x04W\x02\x01\x04\x12\
    \x04\xd6\x0c\x08\x10\n\r\n\x05\x04W\x02\x01\x06\x12\x04\xd6\x0c\x11\"\n\
    \r\n\x05\x04W\x02\x01\x01\x12\x04\xd6\x0c#-\n\r\n\x05\x04W\x02\x01\x03\
    \x12\x04\xd6\x0c01\n\x0c\n\x02\x04X\x12\x06\xd9\x0c\0\xdc\x0c\x01\n\x0b\
    \n\x03\x04X\x01\x12\x04\xd9\x0c\x08\x1d\n\x0c\n\x04\x04X\x02\0\x12\x04\
    \xda\x0c\x08&\n\r\n\x05\x04X\x02\0\x04\x12\x04\xda\x0c\x08\x10\n\r\n\x05\
    \x04X\x02\0\x05\x12\x04\xda\x0c\x11\x17\n\r\n\x05\x04X\x02\0\x01\x12\x04\
    \xda\x0c\x18!\n\r\n\x05\x04X\x02\0\x03\x12\x04\xda\x0c$%\n\x0c\n\x04\x04\
    X\x02\x01\x12\x04\xdb\x0c\x086\n\r\n\x05\x04X\x02\x01\x04\x12\x04\xdb\
    \x0c\x08\x10\n\r\n\x05\x04X\x02\x01\x06\x12\x04\xdb\x0c\x11&\n\r\n\x05\
    \x04X\x02\x01\x01\x12\x04\xdb\x0c'1\n\r\n\x05\x04X\x02\x01\x03\x12\x04\
    \xdb\x0c45\n\x0c\n\x02\x04Y\x12\x06\xde\x0c\0\xe2\x0c\x01\n\x0b\n\x03\
    \x04Y\x01\x12\x04\xde\x0c\x08!\n\x0c\n\x04\x04Y\x02\0\x12\x04\xdf\x0c\
    \x08,\n\r\n\x05\x04Y\x02\0\x04\x12\x04\xdf\x0c\x08\x10\n\r\n\x05\x04Y\
    \x02\0\x05\x12\x04\xdf\x0c\x11\x17\n\r\n\x05\x04Y\x02\0\x01\x12\x04\xdf\
    \x0c\x18'\n\r\n\x05\x04Y\x02\0\x03\x12\x04\xdf\x0c*+\n\x0c\n\x04\x04Y\
    \x02\x01\x12\x04\xe0\x0c\x08*\n\r\n\x05\x04Y\x02\x01\x04\x12\x04\xe0\x0c\
    \x08\x10\n\r\n\x05\x04Y\x02\x01\x05\x12\x04\xe0\x0c\x11\x17\n\r\n\x05\
    \x04Y\x02\x01\x01\x12\x04\xe0\x0c\x18%\n\r\n\x05\x04Y\x02\x01\x03\x12\
    \x04\xe0\x0c()\n\x0c\n\x04\x04Y\x02\x02\x12\x04\xe1\x0c\x086\n\r\n\x05\
    \x04Y\x02\x02\x04\x12\x04\xe1\x0c\x08\x10\n\r\n\x05\x04Y\x02\x02\x06\x12\
    \x04\xe1\x0c\x11&\n\r\n\x05\x04Y\x02\x02\x01\x12\x04\xe1\x0c'1\n\r\n\x05\
    \x04Y\x02\x02\x03\x12\x04\xe1\x0c45\n\x0c\n\x02\x04Z\x12\x06\xe4\x0c\0\
    \xef\x0c\x01\n\x0b\n\x03\x04Z\x01\x12\x04\xe4\x0c\x08\x1c\n\x0c\n\x04\
    \x04Z\x02\0\x12\x04\xe5\x0c\x08&\n\r\n\x05\x04Z\x02\0\x04\x12\x04\xe5\
    \x0c\x08\x10\n\r\n\x05\x04Z\x02\0\x05\x12\x04\xe5\x0c\x11\x17\n\r\n\x05\
    \x04Z\x02\0\x01\x12\x04\xe5\x0c\x18!\n\r\n\x05\x04Z\x02\0\x03\x12\x04\
    \xe5\x0c$%\n\x0c\n\x04\x04Z\x02\x01\x12\x04\xe6\x0c\x08,\n\r\n\x05\x04Z\
    \x02\x01\x04\x12\x04\xe6\x0c\x08\x10\n\r\n\x05\x04Z\x02\x01\x05\x12\x04\
    \xe6\x0c\x11\x17\n\r\n\x05\x04Z\x02\x01\x01\x12\x04\xe6\x0c\x18'\n\r\n\
    \x05\x04Z\x02\x01\x03\x12\x04\xe6\x0c*+\n\x0c\n\x04\x04Z\x02\x02\x12\x04\
    \xe7\x0c\x080\n\r\n\x05\x04Z\x02\x02\x04\x12\x04\xe7\x0c\x08\x10\n\r\n\
    \x05\x04Z\x02\x02\x05\x12\x04\xe7\x0c\x11\x17\n\r\n\x05\x04Z\x02\x02\x01\
    \x12\x04\xe7\x0c\x18+\n\r\n\x05\x04Z\x02\x02\x03\x12\x04\xe7\x0c./\n\x0c\
    \n\x04\x04Z\x02\x03\x12\x04\xe8\x0c\x08-\n\r\n\x05\x04Z\x02\x03\x04\x12\
    \x04\xe8\x0c\x08\x10\n\r\n\x05\x04Z\x02\x03\x05\x12\x04\xe8\x0c\x11\x17\
    \n\r\n\x05\x04Z\x02\x03\x01\x12\x04\xe8\x0c\x18(\n\r\n\x05\x04Z\x02\x03\
    \x03\x12\x04\xe8\x0c+,\n\x0c\n\x04\x04Z\x02\x04\x12\x04\xe9\x0c\x08/\n\r\
    \n\x05\x04Z\x02\x04\x04\x12\x04\xe9\x0c\x08\x10\n\r\n\x05\x04Z\x02\x04\
    \x05\x12\x04\xe9\x0c\x11\x17\n\r\n\x05\x04Z\x02\x04\x01\x12\x04\xe9\x0c\
    \x18*\n\r\n\x05\x04Z\x02\x04\x03\x12\x04\xe9\x0c-.\n\x0c\n\x04\x04Z\x02\
    \x05\x12\x04\xea\x0c\x08)\n\r\n\x05\x04Z\x02\x05\x04\x12\x04\xea\x0c\x08\
    \x10\n\r\n\x05\x04Z\x02\x05\x05\x12\x04\xea\x0c\x11\x17\n\r\n\x05\x04Z\
    \x02\x05\x01\x12\x04\xea\x0c\x18$\n\r\n\x05\x04Z\x02\x05\x03\x12\x04\xea\
    \x0c'(\n\x0c\n\x04\x04Z\x02\x06\x12\x04\xeb\x0c\x08)\n\r\n\x05\x04Z\x02\
    \x06\x04\x12\x04\xeb\x0c\x08\x10\n\r\n\x05\x04Z\x02\x06\x05\x12\x04\xeb\
    \x0c\x11\x17\n\r\n\x05\x04Z\x02\x06\x01\x12\x04\xeb\x0c\x18$\n\r\n\x05\
    \x04Z\x02\x06\x03\x12\x04\xeb\x0c'(\n\x0c\n\x04\x04Z\x02\x07\x12\x04\xec\
    \x0c\x08+\n\r\n\x05\x04Z\x02\x07\x04\x12\x04\xec\x0c\x08\x10\n\r\n\x05\
    \x04Z\x02\x07\x05\x12\x04\xec\x0c\x11\x17\n\r\n\x05\x04Z\x02\x07\x01\x12\
    \x04\xec\x0c\x18&\n\r\n\x05\x04Z\x02\x07\x03\x12\x04\xec\x0c)*\n\x0c\n\
    \x04\x04Z\x02\x08\x12\x04\xed\x0c\x08.\n\r\n\x05\x04Z\x02\x08\x04\x12\
    \x04\xed\x0c\x08\x10\n\r\n\x05\x04Z\x02\x08\x05\x12\x04\xed\x0c\x11\x17\
    \n\r\n\x05\x04Z\x02\x08\x01\x12\x04\xed\x0c\x18)\n\r\n\x05\x04Z\x02\x08\
    \x03\x12\x04\xed\x0c,-\n\x0c\n\x04\x04Z\x02\t\x12\x04\xee\x0c\x081\n\r\n\
    \x05\x04Z\x02\t\x04\x12\x04\xee\x0c\x08\x10\n\r\n\x05\x04Z\x02\t\x05\x12\
    \x04\xee\x0c\x11\x17\n\r\n\x05\x04Z\x02\t\x01\x12\x04\xee\x0c\x18+\n\r\n\
    \x05\x04Z\x02\t\x03\x12\x04\xee\x0c.0\n\x0c\n\x02\x04[\x12\x06\xf1\x0c\0\
    \xf5\x0c\x01\n\x0b\n\x03\x04[\x01\x12\x04\xf1\x0c\x08\x1a\n\x0c\n\x04\
    \x04[\x02\0\x12\x04\xf2\x0c\x082\n\r\n\x05\x04[\x02\0\x04\x12\x04\xf2\
    \x0c\x08\x10\n\r\n\x05\x04[\x02\0\x06\x12\x04\xf2\x0c\x11%\n\r\n\x05\x04\
    [\x02\0\x01\x12\x04\xf2\x0c&-\n\r\n\x05\x04[\x02\0\x03\x12\x04\xf2\x0c01\
    \n\x0c\n\x04\x04[\x02\x01\x12\x04\xf3\x0c\x087\n\r\n\x05\x04[\x02\x01\
    \x04\x12\x04\xf3\x0c\x08\x10\n\r\n\x05\x04[\x02\x01\x06\x12\x04\xf3\x0c\
    \x11%\n\r\n\x05\x04[\x02\x01\x01\x12\x04\xf3\x0c&2\n\r\n\x05\x04[\x02\
    \x01\x03\x12\x04\xf3\x0c56\n\x0c\n\x04\x04[\x02\x02\x12\x04\xf4\x0c\x085\
    \n\r\n\x05\x04[\x02\x02\x04\x12\x04\xf4\x0c\x08\x10\n\r\n\x05\x04[\x02\
    \x02\x06\x12\x04\xf4\x0c\x11%\n\r\n\x05\x04[\x02\x02\x01\x12\x04\xf4\x0c\
    &0\n\r\n\x05\x04[\x02\x02\x03\x12\x04\xf4\x0c34\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::gcsdk_gcmessages::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(152);
            messages.push(CSODOTAGameAccountClient::generated_message_descriptor_data());
            messages.push(CSODOTAGameAccountPlus::generated_message_descriptor_data());
            messages.push(CMsgLobbyFeaturedGamemodeProgress::generated_message_descriptor_data());
            messages.push(CMsgBattleCupVictory::generated_message_descriptor_data());
            messages.push(CMsgLobbyBattleCupVictoryList::generated_message_descriptor_data());
            messages.push(CMsgDOTABroadcastNotification::generated_message_descriptor_data());
            messages.push(CProtoItemHeroStatue::generated_message_descriptor_data());
            messages.push(CMatchPlayerAbilityUpgrade::generated_message_descriptor_data());
            messages.push(CMatchPlayerTimedCustomStat::generated_message_descriptor_data());
            messages.push(CMatchPlayerTimedStats::generated_message_descriptor_data());
            messages.push(CMatchTeamTimedStats::generated_message_descriptor_data());
            messages.push(CMatchAdditionalUnitInventory::generated_message_descriptor_data());
            messages.push(CMatchPlayerPermanentBuff::generated_message_descriptor_data());
            messages.push(CMatchHeroSelectEvent::generated_message_descriptor_data());
            messages.push(CMatchClip::generated_message_descriptor_data());
            messages.push(CPartySearchClientParty::generated_message_descriptor_data());
            messages.push(CMsgDOTAHasItemQuery::generated_message_descriptor_data());
            messages.push(CMsgDOTAHasItemResponse::generated_message_descriptor_data());
            messages.push(CMsgGCGetPlayerCardItemInfo::generated_message_descriptor_data());
            messages.push(CMsgGCGetPlayerCardItemInfoResponse::generated_message_descriptor_data());
            messages.push(CSODOTAMapLocationState::generated_message_descriptor_data());
            messages.push(CMsgLeagueAdminList::generated_message_descriptor_data());
            messages.push(CMsgDOTAProfileCard::generated_message_descriptor_data());
            messages.push(CSODOTAPlayerChallenge::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRerollPlayerChallenge::generated_message_descriptor_data());
            messages.push(CMsgGCRerollPlayerChallengeResponse::generated_message_descriptor_data());
            messages.push(CMsgGCTopCustomGamesList::generated_message_descriptor_data());
            messages.push(CMsgDOTARealtimeGameStats::generated_message_descriptor_data());
            messages.push(CMsgDOTARealtimeGameStatsTerse::generated_message_descriptor_data());
            messages.push(CMsgDOTABroadcastTimelineEvent::generated_message_descriptor_data());
            messages.push(CMsgGCToClientMatchGroupsVersion::generated_message_descriptor_data());
            messages.push(CMsgDOTASDOHeroStatsHistory::generated_message_descriptor_data());
            messages.push(CMsgPredictionChoice::generated_message_descriptor_data());
            messages.push(CMsgInGamePrediction::generated_message_descriptor_data());
            messages.push(CMsgDOTASeasonPredictions::generated_message_descriptor_data());
            messages.push(CMsgAvailablePredictions::generated_message_descriptor_data());
            messages.push(CMsgLeagueWatchedGames::generated_message_descriptor_data());
            messages.push(CMsgDOTAMatch::generated_message_descriptor_data());
            messages.push(CMsgPlayerCard::generated_message_descriptor_data());
            messages.push(CMsgDOTAFantasyPlayerStats::generated_message_descriptor_data());
            messages.push(CMsgDOTAFantasyPlayerMatchStats::generated_message_descriptor_data());
            messages.push(CMsgDOTABotDebugInfo::generated_message_descriptor_data());
            messages.push(CMsgSuccessfulHero::generated_message_descriptor_data());
            messages.push(CMsgRecentMatchInfo::generated_message_descriptor_data());
            messages.push(CMsgMatchTips::generated_message_descriptor_data());
            messages.push(CMsgDOTAMatchMinimal::generated_message_descriptor_data());
            messages.push(CMsgConsumableUsage::generated_message_descriptor_data());
            messages.push(CMsgMatchConsumableUsage::generated_message_descriptor_data());
            messages.push(CMsgMatchEventActionGrants::generated_message_descriptor_data());
            messages.push(CMsgCustomGameWhitelist::generated_message_descriptor_data());
            messages.push(CMsgCustomGameWhitelistForEdit::generated_message_descriptor_data());
            messages.push(CMsgPlayerRecentMatchInfo::generated_message_descriptor_data());
            messages.push(CMsgPlayerMatchRecord::generated_message_descriptor_data());
            messages.push(CMsgPlayerRecentMatchOutcomes::generated_message_descriptor_data());
            messages.push(CMsgPlayerRecentCommends::generated_message_descriptor_data());
            messages.push(CMsgPlayerRecentAccomplishments::generated_message_descriptor_data());
            messages.push(CMsgPlayerHeroRecentAccomplishments::generated_message_descriptor_data());
            messages.push(CMsgRecentAccomplishments::generated_message_descriptor_data());
            messages.push(CMsgServerToGCRequestPlayerRecentAccomplishments::generated_message_descriptor_data());
            messages.push(CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::generated_message_descriptor_data());
            messages.push(CMsgArcanaVoteMatchVotes::generated_message_descriptor_data());
            messages.push(CMsgGCtoGCAssociatedExploiterAccountInfo::generated_message_descriptor_data());
            messages.push(CMsgGCtoGCAssociatedExploiterAccountInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgPullTabsData::generated_message_descriptor_data());
            messages.push(CMsgUnderDraftData::generated_message_descriptor_data());
            messages.push(CMsgPlayerTitleData::generated_message_descriptor_data());
            messages.push(CMsgDOTATriviaQuestion::generated_message_descriptor_data());
            messages.push(CMsgDOTATriviaQuestionAnswersSummary::generated_message_descriptor_data());
            messages.push(CMsgGameDataSpecialValueBonus::generated_message_descriptor_data());
            messages.push(CMsgGameDataSpecialValues::generated_message_descriptor_data());
            messages.push(CMsgGameDataAbilityOrItem::generated_message_descriptor_data());
            messages.push(CMsgGameDataHero::generated_message_descriptor_data());
            messages.push(CMsgGameDataAbilities::generated_message_descriptor_data());
            messages.push(CMsgGameDataItems::generated_message_descriptor_data());
            messages.push(CMsgGameDataHeroes::generated_message_descriptor_data());
            messages.push(CMsgGameDataHeroList::generated_message_descriptor_data());
            messages.push(CMsgGameDataItemAbilityList::generated_message_descriptor_data());
            messages.push(CMsgLobbyAbilityDraftData::generated_message_descriptor_data());
            messages.push(CSOEconItemDropRateBonus::generated_message_descriptor_data());
            messages.push(CSOEconItemTournamentPassport::generated_message_descriptor_data());
            messages.push(CMsgStickerbookSticker::generated_message_descriptor_data());
            messages.push(CMsgStickerbookPage::generated_message_descriptor_data());
            messages.push(CMsgStickerbookTeamPageOrderSequence::generated_message_descriptor_data());
            messages.push(CMsgStickerbook::generated_message_descriptor_data());
            messages.push(CMsgStickerHero::generated_message_descriptor_data());
            messages.push(CMsgStickerHeroes::generated_message_descriptor_data());
            messages.push(CMsgHeroRoleStats::generated_message_descriptor_data());
            messages.push(CMsgHeroRoleHeroStats::generated_message_descriptor_data());
            messages.push(CMsgHeroRoleRankStats::generated_message_descriptor_data());
            messages.push(CMsgHeroRoleAllRanksStats::generated_message_descriptor_data());
            messages.push(CMsgMapStatsSnapshot::generated_message_descriptor_data());
            messages.push(CMsgGlobalMapStats::generated_message_descriptor_data());
            messages.push(csodotagame_account_client::RoleHandicap::generated_message_descriptor_data());
            messages.push(cmsg_lobby_featured_gamemode_progress::AccountProgress::generated_message_descriptor_data());
            messages.push(cmsg_gcget_player_card_item_info_response::PlayerCardInfo::generated_message_descriptor_data());
            messages.push(cmsg_dotaprofile_card::Slot::generated_message_descriptor_data());
            messages.push(cmsg_dotaprofile_card::slot::Trophy::generated_message_descriptor_data());
            messages.push(cmsg_dotaprofile_card::slot::Stat::generated_message_descriptor_data());
            messages.push(cmsg_dotaprofile_card::slot::Item::generated_message_descriptor_data());
            messages.push(cmsg_dotaprofile_card::slot::Hero::generated_message_descriptor_data());
            messages.push(cmsg_dotaprofile_card::slot::Emoticon::generated_message_descriptor_data());
            messages.push(cmsg_dotaprofile_card::slot::Team::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::TeamDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::ItemDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::AbilityDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::HeroToHeroStats::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::AbilityList::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::PlayerDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::BuildingDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::KillDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::BroadcasterDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::PickBanDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::MatchDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::GraphData::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::graph_data::LocationStats::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats::graph_data::TeamLocationStats::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats_terse::TeamDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats_terse::PlayerDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats_terse::BuildingDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats_terse::PickBanDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats_terse::MatchDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotarealtime_game_stats_terse::GraphData::generated_message_descriptor_data());
            messages.push(cmsg_in_game_prediction::QueryKeyValues::generated_message_descriptor_data());
            messages.push(cmsg_dotaseason_predictions::Prediction::generated_message_descriptor_data());
            messages.push(cmsg_dotaseason_predictions::prediction::Answers::generated_message_descriptor_data());
            messages.push(cmsg_available_predictions::MatchPrediction::generated_message_descriptor_data());
            messages.push(cmsg_league_watched_games::Series::generated_message_descriptor_data());
            messages.push(cmsg_league_watched_games::League::generated_message_descriptor_data());
            messages.push(cmsg_dotamatch::Player::generated_message_descriptor_data());
            messages.push(cmsg_dotamatch::BroadcasterInfo::generated_message_descriptor_data());
            messages.push(cmsg_dotamatch::BroadcasterChannel::generated_message_descriptor_data());
            messages.push(cmsg_dotamatch::Coach::generated_message_descriptor_data());
            messages.push(cmsg_dotamatch::CustomGameData::generated_message_descriptor_data());
            messages.push(cmsg_dotamatch::player::CustomGameData::generated_message_descriptor_data());
            messages.push(cmsg_dotamatch::player::HeroDamageReceived::generated_message_descriptor_data());
            messages.push(cmsg_player_card::StatModifier::generated_message_descriptor_data());
            messages.push(cmsg_dotabot_debug_info::Bot::generated_message_descriptor_data());
            messages.push(cmsg_dotabot_debug_info::bot::Mode::generated_message_descriptor_data());
            messages.push(cmsg_dotabot_debug_info::bot::Action::generated_message_descriptor_data());
            messages.push(cmsg_match_tips::SingleTip::generated_message_descriptor_data());
            messages.push(cmsg_dotamatch_minimal::Player::generated_message_descriptor_data());
            messages.push(cmsg_dotamatch_minimal::Tourney::generated_message_descriptor_data());
            messages.push(cmsg_match_consumable_usage::PlayerUsage::generated_message_descriptor_data());
            messages.push(cmsg_match_event_action_grants::PlayerGrants::generated_message_descriptor_data());
            messages.push(cmsg_custom_game_whitelist_for_edit::WhitelistEntry::generated_message_descriptor_data());
            messages.push(cmsg_gcto_gcassociated_exploiter_account_info_response::Account::generated_message_descriptor_data());
            messages.push(cmsg_pull_tabs_data::Slot::generated_message_descriptor_data());
            messages.push(cmsg_pull_tabs_data::Jackpot::generated_message_descriptor_data());
            messages.push(cmsg_under_draft_data::BenchSlot::generated_message_descriptor_data());
            messages.push(cmsg_under_draft_data::ShopSlot::generated_message_descriptor_data());
            messages.push(cmsg_game_data_hero_list::HeroInfo::generated_message_descriptor_data());
            messages.push(cmsg_game_data_item_ability_list::ItemAbilityInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(24);
            enums.push(ESpecialPingValue::generated_enum_descriptor_data());
            enums.push(EDOTAGCSessionNeed::generated_enum_descriptor_data());
            enums.push(EDOTAMatchPlayerTimeCustomStat::generated_enum_descriptor_data());
            enums.push(DOTA_TournamentEvents::generated_enum_descriptor_data());
            enums.push(EBroadcastTimelineEvent::generated_enum_descriptor_data());
            enums.push(ECustomGameWhitelistState::generated_enum_descriptor_data());
            enums.push(EDOTATriviaQuestionCategory::generated_enum_descriptor_data());
            enums.push(EOverwatchConviction::generated_enum_descriptor_data());
            enums.push(EHeroRelicRarity::generated_enum_descriptor_data());
            enums.push(EStickerbookAuditAction::generated_enum_descriptor_data());
            enums.push(EStickerbookPageType::generated_enum_descriptor_data());
            enums.push(cmsg_dotaprofile_card::EStatID::generated_enum_descriptor_data());
            enums.push(cmsg_gcreroll_player_challenge_response::EResult::generated_enum_descriptor_data());
            enums.push(cmsg_dotarealtime_game_stats::graph_data::EStat::generated_enum_descriptor_data());
            enums.push(cmsg_dotarealtime_game_stats::graph_data::ELocation::generated_enum_descriptor_data());
            enums.push(cmsg_in_game_prediction::ERawValueType_t::generated_enum_descriptor_data());
            enums.push(cmsg_in_game_prediction::EPredictionType::generated_enum_descriptor_data());
            enums.push(cmsg_in_game_prediction::EResolutionType_t::generated_enum_descriptor_data());
            enums.push(cmsg_in_game_prediction::ERandomSelectionGroup_t::generated_enum_descriptor_data());
            enums.push(cmsg_dotaseason_predictions::prediction::EPredictionType::generated_enum_descriptor_data());
            enums.push(cmsg_dotaseason_predictions::prediction::EAnswerType::generated_enum_descriptor_data());
            enums.push(cmsg_dotamatch::ReplayState::generated_enum_descriptor_data());
            enums.push(cmsg_dotamatch::player::HeroDamageType::generated_enum_descriptor_data());
            enums.push(cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
