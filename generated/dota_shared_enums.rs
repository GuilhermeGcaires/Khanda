// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_shared_enums.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CDOTAClientHardwareSpecs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientHardwareSpecs {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAClientHardwareSpecs.logical_processors)
    pub logical_processors: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAClientHardwareSpecs.cpu_cycles_per_second)
    pub cpu_cycles_per_second: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAClientHardwareSpecs.total_physical_memory)
    pub total_physical_memory: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAClientHardwareSpecs.is_64_bit_os)
    pub is_64_bit_os: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAClientHardwareSpecs.upload_measurement)
    pub upload_measurement: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAClientHardwareSpecs.prefer_not_host)
    pub prefer_not_host: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAClientHardwareSpecs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientHardwareSpecs {
    fn default() -> &'a CDOTAClientHardwareSpecs {
        <CDOTAClientHardwareSpecs as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientHardwareSpecs {
    pub fn new() -> CDOTAClientHardwareSpecs {
        ::std::default::Default::default()
    }

    // optional uint32 logical_processors = 1;

    pub fn logical_processors(&self) -> u32 {
        self.logical_processors.unwrap_or(0)
    }

    pub fn clear_logical_processors(&mut self) {
        self.logical_processors = ::std::option::Option::None;
    }

    pub fn has_logical_processors(&self) -> bool {
        self.logical_processors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logical_processors(&mut self, v: u32) {
        self.logical_processors = ::std::option::Option::Some(v);
    }

    // optional fixed64 cpu_cycles_per_second = 2;

    pub fn cpu_cycles_per_second(&self) -> u64 {
        self.cpu_cycles_per_second.unwrap_or(0)
    }

    pub fn clear_cpu_cycles_per_second(&mut self) {
        self.cpu_cycles_per_second = ::std::option::Option::None;
    }

    pub fn has_cpu_cycles_per_second(&self) -> bool {
        self.cpu_cycles_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cycles_per_second(&mut self, v: u64) {
        self.cpu_cycles_per_second = ::std::option::Option::Some(v);
    }

    // optional fixed64 total_physical_memory = 3;

    pub fn total_physical_memory(&self) -> u64 {
        self.total_physical_memory.unwrap_or(0)
    }

    pub fn clear_total_physical_memory(&mut self) {
        self.total_physical_memory = ::std::option::Option::None;
    }

    pub fn has_total_physical_memory(&self) -> bool {
        self.total_physical_memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_physical_memory(&mut self, v: u64) {
        self.total_physical_memory = ::std::option::Option::Some(v);
    }

    // optional bool is_64_bit_os = 4;

    pub fn is_64_bit_os(&self) -> bool {
        self.is_64_bit_os.unwrap_or(false)
    }

    pub fn clear_is_64_bit_os(&mut self) {
        self.is_64_bit_os = ::std::option::Option::None;
    }

    pub fn has_is_64_bit_os(&self) -> bool {
        self.is_64_bit_os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_64_bit_os(&mut self, v: bool) {
        self.is_64_bit_os = ::std::option::Option::Some(v);
    }

    // optional uint64 upload_measurement = 5;

    pub fn upload_measurement(&self) -> u64 {
        self.upload_measurement.unwrap_or(0)
    }

    pub fn clear_upload_measurement(&mut self) {
        self.upload_measurement = ::std::option::Option::None;
    }

    pub fn has_upload_measurement(&self) -> bool {
        self.upload_measurement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_measurement(&mut self, v: u64) {
        self.upload_measurement = ::std::option::Option::Some(v);
    }

    // optional bool prefer_not_host = 6;

    pub fn prefer_not_host(&self) -> bool {
        self.prefer_not_host.unwrap_or(false)
    }

    pub fn clear_prefer_not_host(&mut self) {
        self.prefer_not_host = ::std::option::Option::None;
    }

    pub fn has_prefer_not_host(&self) -> bool {
        self.prefer_not_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefer_not_host(&mut self, v: bool) {
        self.prefer_not_host = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "logical_processors",
            |m: &CDOTAClientHardwareSpecs| { &m.logical_processors },
            |m: &mut CDOTAClientHardwareSpecs| { &mut m.logical_processors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_cycles_per_second",
            |m: &CDOTAClientHardwareSpecs| { &m.cpu_cycles_per_second },
            |m: &mut CDOTAClientHardwareSpecs| { &mut m.cpu_cycles_per_second },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_physical_memory",
            |m: &CDOTAClientHardwareSpecs| { &m.total_physical_memory },
            |m: &mut CDOTAClientHardwareSpecs| { &mut m.total_physical_memory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_64_bit_os",
            |m: &CDOTAClientHardwareSpecs| { &m.is_64_bit_os },
            |m: &mut CDOTAClientHardwareSpecs| { &mut m.is_64_bit_os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_measurement",
            |m: &CDOTAClientHardwareSpecs| { &m.upload_measurement },
            |m: &mut CDOTAClientHardwareSpecs| { &mut m.upload_measurement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prefer_not_host",
            |m: &CDOTAClientHardwareSpecs| { &m.prefer_not_host },
            |m: &mut CDOTAClientHardwareSpecs| { &mut m.prefer_not_host },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAClientHardwareSpecs>(
            "CDOTAClientHardwareSpecs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAClientHardwareSpecs {
    const NAME: &'static str = "CDOTAClientHardwareSpecs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.logical_processors = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.cpu_cycles_per_second = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.total_physical_memory = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.is_64_bit_os = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.upload_measurement = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.prefer_not_host = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.logical_processors {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cpu_cycles_per_second {
            my_size += 1 + 8;
        }
        if let Some(v) = self.total_physical_memory {
            my_size += 1 + 8;
        }
        if let Some(v) = self.is_64_bit_os {
            my_size += 1 + 1;
        }
        if let Some(v) = self.upload_measurement {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.prefer_not_host {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.logical_processors {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cpu_cycles_per_second {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.total_physical_memory {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.is_64_bit_os {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.upload_measurement {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.prefer_not_host {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientHardwareSpecs {
        CDOTAClientHardwareSpecs::new()
    }

    fn clear(&mut self) {
        self.logical_processors = ::std::option::Option::None;
        self.cpu_cycles_per_second = ::std::option::Option::None;
        self.total_physical_memory = ::std::option::Option::None;
        self.is_64_bit_os = ::std::option::Option::None;
        self.upload_measurement = ::std::option::Option::None;
        self.prefer_not_host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientHardwareSpecs {
        static instance: CDOTAClientHardwareSpecs = CDOTAClientHardwareSpecs {
            logical_processors: ::std::option::Option::None,
            cpu_cycles_per_second: ::std::option::Option::None,
            total_physical_memory: ::std::option::Option::None,
            is_64_bit_os: ::std::option::Option::None,
            upload_measurement: ::std::option::Option::None,
            prefer_not_host: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAClientHardwareSpecs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAClientHardwareSpecs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAClientHardwareSpecs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAClientHardwareSpecs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTASaveGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTASaveGame {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTASaveGame.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTASaveGame.save_time)
    pub save_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTASaveGame.players)
    pub players: ::std::vec::Vec<cdotasave_game::Player>,
    // @@protoc_insertion_point(field:dota.CDOTASaveGame.save_instances)
    pub save_instances: ::std::vec::Vec<cdotasave_game::SaveInstance>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTASaveGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTASaveGame {
    fn default() -> &'a CDOTASaveGame {
        <CDOTASaveGame as ::protobuf::Message>::default_instance()
    }
}

impl CDOTASaveGame {
    pub fn new() -> CDOTASaveGame {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 5;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 save_time = 2;

    pub fn save_time(&self) -> u32 {
        self.save_time.unwrap_or(0)
    }

    pub fn clear_save_time(&mut self) {
        self.save_time = ::std::option::Option::None;
    }

    pub fn has_save_time(&self) -> bool {
        self.save_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_time(&mut self, v: u32) {
        self.save_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CDOTASaveGame| { &m.match_id },
            |m: &mut CDOTASaveGame| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "save_time",
            |m: &CDOTASaveGame| { &m.save_time },
            |m: &mut CDOTASaveGame| { &mut m.save_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CDOTASaveGame| { &m.players },
            |m: &mut CDOTASaveGame| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "save_instances",
            |m: &CDOTASaveGame| { &m.save_instances },
            |m: &mut CDOTASaveGame| { &mut m.save_instances },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTASaveGame>(
            "CDOTASaveGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTASaveGame {
    const NAME: &'static str = "CDOTASaveGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.save_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.players.push(is.read_message()?);
                },
                34 => {
                    self.save_instances.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.save_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.save_instances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.save_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.save_instances {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTASaveGame {
        CDOTASaveGame::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.save_time = ::std::option::Option::None;
        self.players.clear();
        self.save_instances.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTASaveGame {
        static instance: CDOTASaveGame = CDOTASaveGame {
            match_id: ::std::option::Option::None,
            save_time: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            save_instances: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTASaveGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTASaveGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTASaveGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTASaveGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTASaveGame`
pub mod cdotasave_game {
    // @@protoc_insertion_point(message:dota.CDOTASaveGame.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTASaveGame.Player.team)
        pub team: ::std::option::Option<::protobuf::EnumOrUnknown<super::DOTA_GC_TEAM>>,
        // @@protoc_insertion_point(field:dota.CDOTASaveGame.Player.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CDOTASaveGame.Player.hero)
        pub hero: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTASaveGame.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional .dota.DOTA_GC_TEAM team = 1;

        pub fn team(&self) -> super::DOTA_GC_TEAM {
            match self.team {
                Some(e) => e.enum_value_or(super::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                None => super::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
            }
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: super::DOTA_GC_TEAM) {
            self.team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string hero = 3;

        pub fn hero(&self) -> &str {
            match self.hero.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hero(&mut self) {
            self.hero = ::std::option::Option::None;
        }

        pub fn has_hero(&self) -> bool {
            self.hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero(&mut self, v: ::std::string::String) {
            self.hero = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hero(&mut self) -> &mut ::std::string::String {
            if self.hero.is_none() {
                self.hero = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hero.as_mut().unwrap()
        }

        // Take field
        pub fn take_hero(&mut self) -> ::std::string::String {
            self.hero.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team",
                |m: &Player| { &m.team },
                |m: &mut Player| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Player| { &m.name },
                |m: &mut Player| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero",
                |m: &Player| { &m.hero },
                |m: &mut Player| { &mut m.hero },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CDOTASaveGame.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.hero = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.hero.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.hero.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.hero = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                team: ::std::option::Option::None,
                name: ::std::option::Option::None,
                hero: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTASaveGame.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTASaveGame.SaveInstance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SaveInstance {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTASaveGame.SaveInstance.game_time)
        pub game_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTASaveGame.SaveInstance.team1_score)
        pub team1_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTASaveGame.SaveInstance.team2_score)
        pub team2_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTASaveGame.SaveInstance.player_positions)
        pub player_positions: ::std::vec::Vec<save_instance::PlayerPositions>,
        // @@protoc_insertion_point(field:dota.CDOTASaveGame.SaveInstance.save_id)
        pub save_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTASaveGame.SaveInstance.save_time)
        pub save_time: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTASaveGame.SaveInstance.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SaveInstance {
        fn default() -> &'a SaveInstance {
            <SaveInstance as ::protobuf::Message>::default_instance()
        }
    }

    impl SaveInstance {
        pub fn new() -> SaveInstance {
            ::std::default::Default::default()
        }

        // optional uint32 game_time = 2;

        pub fn game_time(&self) -> u32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: u32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        // optional uint32 team1_score = 3;

        pub fn team1_score(&self) -> u32 {
            self.team1_score.unwrap_or(0)
        }

        pub fn clear_team1_score(&mut self) {
            self.team1_score = ::std::option::Option::None;
        }

        pub fn has_team1_score(&self) -> bool {
            self.team1_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team1_score(&mut self, v: u32) {
            self.team1_score = ::std::option::Option::Some(v);
        }

        // optional uint32 team2_score = 4;

        pub fn team2_score(&self) -> u32 {
            self.team2_score.unwrap_or(0)
        }

        pub fn clear_team2_score(&mut self) {
            self.team2_score = ::std::option::Option::None;
        }

        pub fn has_team2_score(&self) -> bool {
            self.team2_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team2_score(&mut self, v: u32) {
            self.team2_score = ::std::option::Option::Some(v);
        }

        // optional uint32 save_id = 6;

        pub fn save_id(&self) -> u32 {
            self.save_id.unwrap_or(0)
        }

        pub fn clear_save_id(&mut self) {
            self.save_id = ::std::option::Option::None;
        }

        pub fn has_save_id(&self) -> bool {
            self.save_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_save_id(&mut self, v: u32) {
            self.save_id = ::std::option::Option::Some(v);
        }

        // optional uint32 save_time = 7;

        pub fn save_time(&self) -> u32 {
            self.save_time.unwrap_or(0)
        }

        pub fn clear_save_time(&mut self) {
            self.save_time = ::std::option::Option::None;
        }

        pub fn has_save_time(&self) -> bool {
            self.save_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_save_time(&mut self, v: u32) {
            self.save_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_time",
                |m: &SaveInstance| { &m.game_time },
                |m: &mut SaveInstance| { &mut m.game_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team1_score",
                |m: &SaveInstance| { &m.team1_score },
                |m: &mut SaveInstance| { &mut m.team1_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team2_score",
                |m: &SaveInstance| { &m.team2_score },
                |m: &mut SaveInstance| { &mut m.team2_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "player_positions",
                |m: &SaveInstance| { &m.player_positions },
                |m: &mut SaveInstance| { &mut m.player_positions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "save_id",
                |m: &SaveInstance| { &m.save_id },
                |m: &mut SaveInstance| { &mut m.save_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "save_time",
                |m: &SaveInstance| { &m.save_time },
                |m: &mut SaveInstance| { &mut m.save_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SaveInstance>(
                "CDOTASaveGame.SaveInstance",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SaveInstance {
        const NAME: &'static str = "SaveInstance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    16 => {
                        self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.team1_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.team2_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.player_positions.push(is.read_message()?);
                    },
                    48 => {
                        self.save_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.save_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_time {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team1_score {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.team2_score {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.player_positions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.save_id {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.save_time {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.game_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team1_score {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.team2_score {
                os.write_uint32(4, v)?;
            }
            for v in &self.player_positions {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            };
            if let Some(v) = self.save_id {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.save_time {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SaveInstance {
            SaveInstance::new()
        }

        fn clear(&mut self) {
            self.game_time = ::std::option::Option::None;
            self.team1_score = ::std::option::Option::None;
            self.team2_score = ::std::option::Option::None;
            self.player_positions.clear();
            self.save_id = ::std::option::Option::None;
            self.save_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SaveInstance {
            static instance: SaveInstance = SaveInstance {
                game_time: ::std::option::Option::None,
                team1_score: ::std::option::Option::None,
                team2_score: ::std::option::Option::None,
                player_positions: ::std::vec::Vec::new(),
                save_id: ::std::option::Option::None,
                save_time: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SaveInstance {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTASaveGame.SaveInstance").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SaveInstance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SaveInstance {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `SaveInstance`
    pub mod save_instance {
        // @@protoc_insertion_point(message:dota.CDOTASaveGame.SaveInstance.PlayerPositions)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PlayerPositions {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTASaveGame.SaveInstance.PlayerPositions.x)
            pub x: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:dota.CDOTASaveGame.SaveInstance.PlayerPositions.y)
            pub y: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTASaveGame.SaveInstance.PlayerPositions.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PlayerPositions {
            fn default() -> &'a PlayerPositions {
                <PlayerPositions as ::protobuf::Message>::default_instance()
            }
        }

        impl PlayerPositions {
            pub fn new() -> PlayerPositions {
                ::std::default::Default::default()
            }

            // optional float x = 1;

            pub fn x(&self) -> f32 {
                self.x.unwrap_or(0.)
            }

            pub fn clear_x(&mut self) {
                self.x = ::std::option::Option::None;
            }

            pub fn has_x(&self) -> bool {
                self.x.is_some()
            }

            // Param is passed by value, moved
            pub fn set_x(&mut self, v: f32) {
                self.x = ::std::option::Option::Some(v);
            }

            // optional float y = 2;

            pub fn y(&self) -> f32 {
                self.y.unwrap_or(0.)
            }

            pub fn clear_y(&mut self) {
                self.y = ::std::option::Option::None;
            }

            pub fn has_y(&self) -> bool {
                self.y.is_some()
            }

            // Param is passed by value, moved
            pub fn set_y(&mut self, v: f32) {
                self.y = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "x",
                    |m: &PlayerPositions| { &m.x },
                    |m: &mut PlayerPositions| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "y",
                    |m: &PlayerPositions| { &m.y },
                    |m: &mut PlayerPositions| { &mut m.y },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerPositions>(
                    "CDOTASaveGame.SaveInstance.PlayerPositions",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PlayerPositions {
            const NAME: &'static str = "PlayerPositions";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        13 => {
                            self.x = ::std::option::Option::Some(is.read_float()?);
                        },
                        21 => {
                            self.y = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.x {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.y {
                    my_size += 1 + 4;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.x {
                    os.write_float(1, v)?;
                }
                if let Some(v) = self.y {
                    os.write_float(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PlayerPositions {
                PlayerPositions::new()
            }

            fn clear(&mut self) {
                self.x = ::std::option::Option::None;
                self.y = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PlayerPositions {
                static instance: PlayerPositions = PlayerPositions {
                    x: ::std::option::Option::None,
                    y: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for PlayerPositions {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTASaveGame.SaveInstance.PlayerPositions").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PlayerPositions {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PlayerPositions {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTACombatLogEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACombatLogEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<DOTA_COMBATLOG_TYPES>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.target_name)
    pub target_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.target_source_name)
    pub target_source_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.attacker_name)
    pub attacker_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.damage_source_name)
    pub damage_source_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.inflictor_name)
    pub inflictor_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_attacker_illusion)
    pub is_attacker_illusion: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_attacker_hero)
    pub is_attacker_hero: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_target_illusion)
    pub is_target_illusion: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_target_hero)
    pub is_target_hero: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_visible_radiant)
    pub is_visible_radiant: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_visible_dire)
    pub is_visible_dire: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.health)
    pub health: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.timestamp)
    pub timestamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.stun_duration)
    pub stun_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.slow_duration)
    pub slow_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_ability_toggle_on)
    pub is_ability_toggle_on: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_ability_toggle_off)
    pub is_ability_toggle_off: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.ability_level)
    pub ability_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.location_x)
    pub location_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.location_y)
    pub location_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.gold_reason)
    pub gold_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.timestamp_raw)
    pub timestamp_raw: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.modifier_duration)
    pub modifier_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.xp_reason)
    pub xp_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.attacker_team)
    pub attacker_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.target_team)
    pub target_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.obs_wards_placed)
    pub obs_wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.assist_player0)
    pub assist_player0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.assist_player1)
    pub assist_player1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.assist_player2)
    pub assist_player2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.assist_player3)
    pub assist_player3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.stack_count)
    pub stack_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.hidden_modifier)
    pub hidden_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_target_building)
    pub is_target_building: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.neutral_camp_type)
    pub neutral_camp_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.rune_type)
    pub rune_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.assist_players)
    pub assist_players: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_heal_save)
    pub is_heal_save: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.is_ultimate_ability)
    pub is_ultimate_ability: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.attacker_hero_level)
    pub attacker_hero_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.target_hero_level)
    pub target_hero_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.xpm)
    pub xpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.gpm)
    pub gpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.event_location)
    pub event_location: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.target_is_self)
    pub target_is_self: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.damage_type)
    pub damage_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.invisibility_modifier)
    pub invisibility_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.damage_category)
    pub damage_category: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.networth)
    pub networth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.building_type)
    pub building_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.modifier_elapsed_duration)
    pub modifier_elapsed_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.silence_modifier)
    pub silence_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.heal_from_lifesteal)
    pub heal_from_lifesteal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.modifier_purged)
    pub modifier_purged: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.spell_evaded)
    pub spell_evaded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.motion_controller_modifier)
    pub motion_controller_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.long_range_kill)
    pub long_range_kill: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.modifier_purge_ability)
    pub modifier_purge_ability: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.modifier_purge_npc)
    pub modifier_purge_npc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.root_modifier)
    pub root_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.total_unit_death_count)
    pub total_unit_death_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.aura_modifier)
    pub aura_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.armor_debuff_modifier)
    pub armor_debuff_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.no_physical_damage_modifier)
    pub no_physical_damage_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.modifier_ability)
    pub modifier_ability: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.modifier_hidden)
    pub modifier_hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.inflictor_is_stolen_ability)
    pub inflictor_is_stolen_ability: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.kill_eater_event)
    pub kill_eater_event: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.unit_status_label)
    pub unit_status_label: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.spell_generated_attack)
    pub spell_generated_attack: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.at_night_time)
    pub at_night_time: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.attacker_has_scepter)
    pub attacker_has_scepter: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.neutral_camp_team)
    pub neutral_camp_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.regenerated_health)
    pub regenerated_health: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.will_reincarnate)
    pub will_reincarnate: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTACombatLogEntry.uses_charges)
    pub uses_charges: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTACombatLogEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACombatLogEntry {
    fn default() -> &'a CMsgDOTACombatLogEntry {
        <CMsgDOTACombatLogEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACombatLogEntry {
    pub fn new() -> CMsgDOTACombatLogEntry {
        ::std::default::Default::default()
    }

    // optional .dota.DOTA_COMBATLOG_TYPES type = 1;

    pub fn type_(&self) -> DOTA_COMBATLOG_TYPES {
        match self.type_ {
            Some(e) => e.enum_value_or(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID),
            None => DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: DOTA_COMBATLOG_TYPES) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 target_name = 2;

    pub fn target_name(&self) -> u32 {
        self.target_name.unwrap_or(0)
    }

    pub fn clear_target_name(&mut self) {
        self.target_name = ::std::option::Option::None;
    }

    pub fn has_target_name(&self) -> bool {
        self.target_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_name(&mut self, v: u32) {
        self.target_name = ::std::option::Option::Some(v);
    }

    // optional uint32 target_source_name = 3;

    pub fn target_source_name(&self) -> u32 {
        self.target_source_name.unwrap_or(0)
    }

    pub fn clear_target_source_name(&mut self) {
        self.target_source_name = ::std::option::Option::None;
    }

    pub fn has_target_source_name(&self) -> bool {
        self.target_source_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_source_name(&mut self, v: u32) {
        self.target_source_name = ::std::option::Option::Some(v);
    }

    // optional uint32 attacker_name = 4;

    pub fn attacker_name(&self) -> u32 {
        self.attacker_name.unwrap_or(0)
    }

    pub fn clear_attacker_name(&mut self) {
        self.attacker_name = ::std::option::Option::None;
    }

    pub fn has_attacker_name(&self) -> bool {
        self.attacker_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_name(&mut self, v: u32) {
        self.attacker_name = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_source_name = 5;

    pub fn damage_source_name(&self) -> u32 {
        self.damage_source_name.unwrap_or(0)
    }

    pub fn clear_damage_source_name(&mut self) {
        self.damage_source_name = ::std::option::Option::None;
    }

    pub fn has_damage_source_name(&self) -> bool {
        self.damage_source_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_source_name(&mut self, v: u32) {
        self.damage_source_name = ::std::option::Option::Some(v);
    }

    // optional uint32 inflictor_name = 6;

    pub fn inflictor_name(&self) -> u32 {
        self.inflictor_name.unwrap_or(0)
    }

    pub fn clear_inflictor_name(&mut self) {
        self.inflictor_name = ::std::option::Option::None;
    }

    pub fn has_inflictor_name(&self) -> bool {
        self.inflictor_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inflictor_name(&mut self, v: u32) {
        self.inflictor_name = ::std::option::Option::Some(v);
    }

    // optional bool is_attacker_illusion = 7;

    pub fn is_attacker_illusion(&self) -> bool {
        self.is_attacker_illusion.unwrap_or(false)
    }

    pub fn clear_is_attacker_illusion(&mut self) {
        self.is_attacker_illusion = ::std::option::Option::None;
    }

    pub fn has_is_attacker_illusion(&self) -> bool {
        self.is_attacker_illusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attacker_illusion(&mut self, v: bool) {
        self.is_attacker_illusion = ::std::option::Option::Some(v);
    }

    // optional bool is_attacker_hero = 8;

    pub fn is_attacker_hero(&self) -> bool {
        self.is_attacker_hero.unwrap_or(false)
    }

    pub fn clear_is_attacker_hero(&mut self) {
        self.is_attacker_hero = ::std::option::Option::None;
    }

    pub fn has_is_attacker_hero(&self) -> bool {
        self.is_attacker_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attacker_hero(&mut self, v: bool) {
        self.is_attacker_hero = ::std::option::Option::Some(v);
    }

    // optional bool is_target_illusion = 9;

    pub fn is_target_illusion(&self) -> bool {
        self.is_target_illusion.unwrap_or(false)
    }

    pub fn clear_is_target_illusion(&mut self) {
        self.is_target_illusion = ::std::option::Option::None;
    }

    pub fn has_is_target_illusion(&self) -> bool {
        self.is_target_illusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_target_illusion(&mut self, v: bool) {
        self.is_target_illusion = ::std::option::Option::Some(v);
    }

    // optional bool is_target_hero = 10;

    pub fn is_target_hero(&self) -> bool {
        self.is_target_hero.unwrap_or(false)
    }

    pub fn clear_is_target_hero(&mut self) {
        self.is_target_hero = ::std::option::Option::None;
    }

    pub fn has_is_target_hero(&self) -> bool {
        self.is_target_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_target_hero(&mut self, v: bool) {
        self.is_target_hero = ::std::option::Option::Some(v);
    }

    // optional bool is_visible_radiant = 11;

    pub fn is_visible_radiant(&self) -> bool {
        self.is_visible_radiant.unwrap_or(false)
    }

    pub fn clear_is_visible_radiant(&mut self) {
        self.is_visible_radiant = ::std::option::Option::None;
    }

    pub fn has_is_visible_radiant(&self) -> bool {
        self.is_visible_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_visible_radiant(&mut self, v: bool) {
        self.is_visible_radiant = ::std::option::Option::Some(v);
    }

    // optional bool is_visible_dire = 12;

    pub fn is_visible_dire(&self) -> bool {
        self.is_visible_dire.unwrap_or(false)
    }

    pub fn clear_is_visible_dire(&mut self) {
        self.is_visible_dire = ::std::option::Option::None;
    }

    pub fn has_is_visible_dire(&self) -> bool {
        self.is_visible_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_visible_dire(&mut self, v: bool) {
        self.is_visible_dire = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 13;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional int32 health = 14;

    pub fn health(&self) -> i32 {
        self.health.unwrap_or(0)
    }

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional float timestamp = 15;

    pub fn timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional float stun_duration = 16;

    pub fn stun_duration(&self) -> f32 {
        self.stun_duration.unwrap_or(0.)
    }

    pub fn clear_stun_duration(&mut self) {
        self.stun_duration = ::std::option::Option::None;
    }

    pub fn has_stun_duration(&self) -> bool {
        self.stun_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stun_duration(&mut self, v: f32) {
        self.stun_duration = ::std::option::Option::Some(v);
    }

    // optional float slow_duration = 17;

    pub fn slow_duration(&self) -> f32 {
        self.slow_duration.unwrap_or(0.)
    }

    pub fn clear_slow_duration(&mut self) {
        self.slow_duration = ::std::option::Option::None;
    }

    pub fn has_slow_duration(&self) -> bool {
        self.slow_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slow_duration(&mut self, v: f32) {
        self.slow_duration = ::std::option::Option::Some(v);
    }

    // optional bool is_ability_toggle_on = 18;

    pub fn is_ability_toggle_on(&self) -> bool {
        self.is_ability_toggle_on.unwrap_or(false)
    }

    pub fn clear_is_ability_toggle_on(&mut self) {
        self.is_ability_toggle_on = ::std::option::Option::None;
    }

    pub fn has_is_ability_toggle_on(&self) -> bool {
        self.is_ability_toggle_on.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ability_toggle_on(&mut self, v: bool) {
        self.is_ability_toggle_on = ::std::option::Option::Some(v);
    }

    // optional bool is_ability_toggle_off = 19;

    pub fn is_ability_toggle_off(&self) -> bool {
        self.is_ability_toggle_off.unwrap_or(false)
    }

    pub fn clear_is_ability_toggle_off(&mut self) {
        self.is_ability_toggle_off = ::std::option::Option::None;
    }

    pub fn has_is_ability_toggle_off(&self) -> bool {
        self.is_ability_toggle_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ability_toggle_off(&mut self, v: bool) {
        self.is_ability_toggle_off = ::std::option::Option::Some(v);
    }

    // optional uint32 ability_level = 20;

    pub fn ability_level(&self) -> u32 {
        self.ability_level.unwrap_or(0)
    }

    pub fn clear_ability_level(&mut self) {
        self.ability_level = ::std::option::Option::None;
    }

    pub fn has_ability_level(&self) -> bool {
        self.ability_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_level(&mut self, v: u32) {
        self.ability_level = ::std::option::Option::Some(v);
    }

    // optional float location_x = 21;

    pub fn location_x(&self) -> f32 {
        self.location_x.unwrap_or(0.)
    }

    pub fn clear_location_x(&mut self) {
        self.location_x = ::std::option::Option::None;
    }

    pub fn has_location_x(&self) -> bool {
        self.location_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_x(&mut self, v: f32) {
        self.location_x = ::std::option::Option::Some(v);
    }

    // optional float location_y = 22;

    pub fn location_y(&self) -> f32 {
        self.location_y.unwrap_or(0.)
    }

    pub fn clear_location_y(&mut self) {
        self.location_y = ::std::option::Option::None;
    }

    pub fn has_location_y(&self) -> bool {
        self.location_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_y(&mut self, v: f32) {
        self.location_y = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_reason = 23;

    pub fn gold_reason(&self) -> u32 {
        self.gold_reason.unwrap_or(0)
    }

    pub fn clear_gold_reason(&mut self) {
        self.gold_reason = ::std::option::Option::None;
    }

    pub fn has_gold_reason(&self) -> bool {
        self.gold_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_reason(&mut self, v: u32) {
        self.gold_reason = ::std::option::Option::Some(v);
    }

    // optional float timestamp_raw = 24;

    pub fn timestamp_raw(&self) -> f32 {
        self.timestamp_raw.unwrap_or(0.)
    }

    pub fn clear_timestamp_raw(&mut self) {
        self.timestamp_raw = ::std::option::Option::None;
    }

    pub fn has_timestamp_raw(&self) -> bool {
        self.timestamp_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_raw(&mut self, v: f32) {
        self.timestamp_raw = ::std::option::Option::Some(v);
    }

    // optional float modifier_duration = 25;

    pub fn modifier_duration(&self) -> f32 {
        self.modifier_duration.unwrap_or(0.)
    }

    pub fn clear_modifier_duration(&mut self) {
        self.modifier_duration = ::std::option::Option::None;
    }

    pub fn has_modifier_duration(&self) -> bool {
        self.modifier_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_duration(&mut self, v: f32) {
        self.modifier_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 xp_reason = 26;

    pub fn xp_reason(&self) -> u32 {
        self.xp_reason.unwrap_or(0)
    }

    pub fn clear_xp_reason(&mut self) {
        self.xp_reason = ::std::option::Option::None;
    }

    pub fn has_xp_reason(&self) -> bool {
        self.xp_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_reason(&mut self, v: u32) {
        self.xp_reason = ::std::option::Option::Some(v);
    }

    // optional uint32 last_hits = 27;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 attacker_team = 28;

    pub fn attacker_team(&self) -> u32 {
        self.attacker_team.unwrap_or(0)
    }

    pub fn clear_attacker_team(&mut self) {
        self.attacker_team = ::std::option::Option::None;
    }

    pub fn has_attacker_team(&self) -> bool {
        self.attacker_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_team(&mut self, v: u32) {
        self.attacker_team = ::std::option::Option::Some(v);
    }

    // optional uint32 target_team = 29;

    pub fn target_team(&self) -> u32 {
        self.target_team.unwrap_or(0)
    }

    pub fn clear_target_team(&mut self) {
        self.target_team = ::std::option::Option::None;
    }

    pub fn has_target_team(&self) -> bool {
        self.target_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_team(&mut self, v: u32) {
        self.target_team = ::std::option::Option::Some(v);
    }

    // optional uint32 obs_wards_placed = 30;

    pub fn obs_wards_placed(&self) -> u32 {
        self.obs_wards_placed.unwrap_or(0)
    }

    pub fn clear_obs_wards_placed(&mut self) {
        self.obs_wards_placed = ::std::option::Option::None;
    }

    pub fn has_obs_wards_placed(&self) -> bool {
        self.obs_wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_obs_wards_placed(&mut self, v: u32) {
        self.obs_wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 assist_player0 = 31;

    pub fn assist_player0(&self) -> u32 {
        self.assist_player0.unwrap_or(0)
    }

    pub fn clear_assist_player0(&mut self) {
        self.assist_player0 = ::std::option::Option::None;
    }

    pub fn has_assist_player0(&self) -> bool {
        self.assist_player0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player0(&mut self, v: u32) {
        self.assist_player0 = ::std::option::Option::Some(v);
    }

    // optional uint32 assist_player1 = 32;

    pub fn assist_player1(&self) -> u32 {
        self.assist_player1.unwrap_or(0)
    }

    pub fn clear_assist_player1(&mut self) {
        self.assist_player1 = ::std::option::Option::None;
    }

    pub fn has_assist_player1(&self) -> bool {
        self.assist_player1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player1(&mut self, v: u32) {
        self.assist_player1 = ::std::option::Option::Some(v);
    }

    // optional uint32 assist_player2 = 33;

    pub fn assist_player2(&self) -> u32 {
        self.assist_player2.unwrap_or(0)
    }

    pub fn clear_assist_player2(&mut self) {
        self.assist_player2 = ::std::option::Option::None;
    }

    pub fn has_assist_player2(&self) -> bool {
        self.assist_player2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player2(&mut self, v: u32) {
        self.assist_player2 = ::std::option::Option::Some(v);
    }

    // optional uint32 assist_player3 = 34;

    pub fn assist_player3(&self) -> u32 {
        self.assist_player3.unwrap_or(0)
    }

    pub fn clear_assist_player3(&mut self) {
        self.assist_player3 = ::std::option::Option::None;
    }

    pub fn has_assist_player3(&self) -> bool {
        self.assist_player3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player3(&mut self, v: u32) {
        self.assist_player3 = ::std::option::Option::Some(v);
    }

    // optional uint32 stack_count = 35;

    pub fn stack_count(&self) -> u32 {
        self.stack_count.unwrap_or(0)
    }

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: u32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    // optional bool hidden_modifier = 36;

    pub fn hidden_modifier(&self) -> bool {
        self.hidden_modifier.unwrap_or(false)
    }

    pub fn clear_hidden_modifier(&mut self) {
        self.hidden_modifier = ::std::option::Option::None;
    }

    pub fn has_hidden_modifier(&self) -> bool {
        self.hidden_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden_modifier(&mut self, v: bool) {
        self.hidden_modifier = ::std::option::Option::Some(v);
    }

    // optional bool is_target_building = 37;

    pub fn is_target_building(&self) -> bool {
        self.is_target_building.unwrap_or(false)
    }

    pub fn clear_is_target_building(&mut self) {
        self.is_target_building = ::std::option::Option::None;
    }

    pub fn has_is_target_building(&self) -> bool {
        self.is_target_building.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_target_building(&mut self, v: bool) {
        self.is_target_building = ::std::option::Option::Some(v);
    }

    // optional uint32 neutral_camp_type = 38;

    pub fn neutral_camp_type(&self) -> u32 {
        self.neutral_camp_type.unwrap_or(0)
    }

    pub fn clear_neutral_camp_type(&mut self) {
        self.neutral_camp_type = ::std::option::Option::None;
    }

    pub fn has_neutral_camp_type(&self) -> bool {
        self.neutral_camp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_camp_type(&mut self, v: u32) {
        self.neutral_camp_type = ::std::option::Option::Some(v);
    }

    // optional uint32 rune_type = 39;

    pub fn rune_type(&self) -> u32 {
        self.rune_type.unwrap_or(0)
    }

    pub fn clear_rune_type(&mut self) {
        self.rune_type = ::std::option::Option::None;
    }

    pub fn has_rune_type(&self) -> bool {
        self.rune_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rune_type(&mut self, v: u32) {
        self.rune_type = ::std::option::Option::Some(v);
    }

    // optional bool is_heal_save = 41;

    pub fn is_heal_save(&self) -> bool {
        self.is_heal_save.unwrap_or(false)
    }

    pub fn clear_is_heal_save(&mut self) {
        self.is_heal_save = ::std::option::Option::None;
    }

    pub fn has_is_heal_save(&self) -> bool {
        self.is_heal_save.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_heal_save(&mut self, v: bool) {
        self.is_heal_save = ::std::option::Option::Some(v);
    }

    // optional bool is_ultimate_ability = 42;

    pub fn is_ultimate_ability(&self) -> bool {
        self.is_ultimate_ability.unwrap_or(false)
    }

    pub fn clear_is_ultimate_ability(&mut self) {
        self.is_ultimate_ability = ::std::option::Option::None;
    }

    pub fn has_is_ultimate_ability(&self) -> bool {
        self.is_ultimate_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ultimate_ability(&mut self, v: bool) {
        self.is_ultimate_ability = ::std::option::Option::Some(v);
    }

    // optional uint32 attacker_hero_level = 43;

    pub fn attacker_hero_level(&self) -> u32 {
        self.attacker_hero_level.unwrap_or(0)
    }

    pub fn clear_attacker_hero_level(&mut self) {
        self.attacker_hero_level = ::std::option::Option::None;
    }

    pub fn has_attacker_hero_level(&self) -> bool {
        self.attacker_hero_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_hero_level(&mut self, v: u32) {
        self.attacker_hero_level = ::std::option::Option::Some(v);
    }

    // optional uint32 target_hero_level = 44;

    pub fn target_hero_level(&self) -> u32 {
        self.target_hero_level.unwrap_or(0)
    }

    pub fn clear_target_hero_level(&mut self) {
        self.target_hero_level = ::std::option::Option::None;
    }

    pub fn has_target_hero_level(&self) -> bool {
        self.target_hero_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_level(&mut self, v: u32) {
        self.target_hero_level = ::std::option::Option::Some(v);
    }

    // optional uint32 xpm = 45;

    pub fn xpm(&self) -> u32 {
        self.xpm.unwrap_or(0)
    }

    pub fn clear_xpm(&mut self) {
        self.xpm = ::std::option::Option::None;
    }

    pub fn has_xpm(&self) -> bool {
        self.xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpm(&mut self, v: u32) {
        self.xpm = ::std::option::Option::Some(v);
    }

    // optional uint32 gpm = 46;

    pub fn gpm(&self) -> u32 {
        self.gpm.unwrap_or(0)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: u32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional uint32 event_location = 47;

    pub fn event_location(&self) -> u32 {
        self.event_location.unwrap_or(0)
    }

    pub fn clear_event_location(&mut self) {
        self.event_location = ::std::option::Option::None;
    }

    pub fn has_event_location(&self) -> bool {
        self.event_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_location(&mut self, v: u32) {
        self.event_location = ::std::option::Option::Some(v);
    }

    // optional bool target_is_self = 48;

    pub fn target_is_self(&self) -> bool {
        self.target_is_self.unwrap_or(false)
    }

    pub fn clear_target_is_self(&mut self) {
        self.target_is_self = ::std::option::Option::None;
    }

    pub fn has_target_is_self(&self) -> bool {
        self.target_is_self.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_is_self(&mut self, v: bool) {
        self.target_is_self = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_type = 49;

    pub fn damage_type(&self) -> u32 {
        self.damage_type.unwrap_or(0)
    }

    pub fn clear_damage_type(&mut self) {
        self.damage_type = ::std::option::Option::None;
    }

    pub fn has_damage_type(&self) -> bool {
        self.damage_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_type(&mut self, v: u32) {
        self.damage_type = ::std::option::Option::Some(v);
    }

    // optional bool invisibility_modifier = 50;

    pub fn invisibility_modifier(&self) -> bool {
        self.invisibility_modifier.unwrap_or(false)
    }

    pub fn clear_invisibility_modifier(&mut self) {
        self.invisibility_modifier = ::std::option::Option::None;
    }

    pub fn has_invisibility_modifier(&self) -> bool {
        self.invisibility_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invisibility_modifier(&mut self, v: bool) {
        self.invisibility_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_category = 51;

    pub fn damage_category(&self) -> u32 {
        self.damage_category.unwrap_or(0)
    }

    pub fn clear_damage_category(&mut self) {
        self.damage_category = ::std::option::Option::None;
    }

    pub fn has_damage_category(&self) -> bool {
        self.damage_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_category(&mut self, v: u32) {
        self.damage_category = ::std::option::Option::Some(v);
    }

    // optional uint32 networth = 52;

    pub fn networth(&self) -> u32 {
        self.networth.unwrap_or(0)
    }

    pub fn clear_networth(&mut self) {
        self.networth = ::std::option::Option::None;
    }

    pub fn has_networth(&self) -> bool {
        self.networth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networth(&mut self, v: u32) {
        self.networth = ::std::option::Option::Some(v);
    }

    // optional uint32 building_type = 53;

    pub fn building_type(&self) -> u32 {
        self.building_type.unwrap_or(0)
    }

    pub fn clear_building_type(&mut self) {
        self.building_type = ::std::option::Option::None;
    }

    pub fn has_building_type(&self) -> bool {
        self.building_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_type(&mut self, v: u32) {
        self.building_type = ::std::option::Option::Some(v);
    }

    // optional float modifier_elapsed_duration = 54;

    pub fn modifier_elapsed_duration(&self) -> f32 {
        self.modifier_elapsed_duration.unwrap_or(0.)
    }

    pub fn clear_modifier_elapsed_duration(&mut self) {
        self.modifier_elapsed_duration = ::std::option::Option::None;
    }

    pub fn has_modifier_elapsed_duration(&self) -> bool {
        self.modifier_elapsed_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_elapsed_duration(&mut self, v: f32) {
        self.modifier_elapsed_duration = ::std::option::Option::Some(v);
    }

    // optional bool silence_modifier = 55;

    pub fn silence_modifier(&self) -> bool {
        self.silence_modifier.unwrap_or(false)
    }

    pub fn clear_silence_modifier(&mut self) {
        self.silence_modifier = ::std::option::Option::None;
    }

    pub fn has_silence_modifier(&self) -> bool {
        self.silence_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_silence_modifier(&mut self, v: bool) {
        self.silence_modifier = ::std::option::Option::Some(v);
    }

    // optional bool heal_from_lifesteal = 56;

    pub fn heal_from_lifesteal(&self) -> bool {
        self.heal_from_lifesteal.unwrap_or(false)
    }

    pub fn clear_heal_from_lifesteal(&mut self) {
        self.heal_from_lifesteal = ::std::option::Option::None;
    }

    pub fn has_heal_from_lifesteal(&self) -> bool {
        self.heal_from_lifesteal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heal_from_lifesteal(&mut self, v: bool) {
        self.heal_from_lifesteal = ::std::option::Option::Some(v);
    }

    // optional bool modifier_purged = 57;

    pub fn modifier_purged(&self) -> bool {
        self.modifier_purged.unwrap_or(false)
    }

    pub fn clear_modifier_purged(&mut self) {
        self.modifier_purged = ::std::option::Option::None;
    }

    pub fn has_modifier_purged(&self) -> bool {
        self.modifier_purged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_purged(&mut self, v: bool) {
        self.modifier_purged = ::std::option::Option::Some(v);
    }

    // optional bool spell_evaded = 58;

    pub fn spell_evaded(&self) -> bool {
        self.spell_evaded.unwrap_or(false)
    }

    pub fn clear_spell_evaded(&mut self) {
        self.spell_evaded = ::std::option::Option::None;
    }

    pub fn has_spell_evaded(&self) -> bool {
        self.spell_evaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spell_evaded(&mut self, v: bool) {
        self.spell_evaded = ::std::option::Option::Some(v);
    }

    // optional bool motion_controller_modifier = 59;

    pub fn motion_controller_modifier(&self) -> bool {
        self.motion_controller_modifier.unwrap_or(false)
    }

    pub fn clear_motion_controller_modifier(&mut self) {
        self.motion_controller_modifier = ::std::option::Option::None;
    }

    pub fn has_motion_controller_modifier(&self) -> bool {
        self.motion_controller_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motion_controller_modifier(&mut self, v: bool) {
        self.motion_controller_modifier = ::std::option::Option::Some(v);
    }

    // optional bool long_range_kill = 60;

    pub fn long_range_kill(&self) -> bool {
        self.long_range_kill.unwrap_or(false)
    }

    pub fn clear_long_range_kill(&mut self) {
        self.long_range_kill = ::std::option::Option::None;
    }

    pub fn has_long_range_kill(&self) -> bool {
        self.long_range_kill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_long_range_kill(&mut self, v: bool) {
        self.long_range_kill = ::std::option::Option::Some(v);
    }

    // optional uint32 modifier_purge_ability = 61;

    pub fn modifier_purge_ability(&self) -> u32 {
        self.modifier_purge_ability.unwrap_or(0)
    }

    pub fn clear_modifier_purge_ability(&mut self) {
        self.modifier_purge_ability = ::std::option::Option::None;
    }

    pub fn has_modifier_purge_ability(&self) -> bool {
        self.modifier_purge_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_purge_ability(&mut self, v: u32) {
        self.modifier_purge_ability = ::std::option::Option::Some(v);
    }

    // optional uint32 modifier_purge_npc = 62;

    pub fn modifier_purge_npc(&self) -> u32 {
        self.modifier_purge_npc.unwrap_or(0)
    }

    pub fn clear_modifier_purge_npc(&mut self) {
        self.modifier_purge_npc = ::std::option::Option::None;
    }

    pub fn has_modifier_purge_npc(&self) -> bool {
        self.modifier_purge_npc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_purge_npc(&mut self, v: u32) {
        self.modifier_purge_npc = ::std::option::Option::Some(v);
    }

    // optional bool root_modifier = 63;

    pub fn root_modifier(&self) -> bool {
        self.root_modifier.unwrap_or(false)
    }

    pub fn clear_root_modifier(&mut self) {
        self.root_modifier = ::std::option::Option::None;
    }

    pub fn has_root_modifier(&self) -> bool {
        self.root_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root_modifier(&mut self, v: bool) {
        self.root_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 total_unit_death_count = 64;

    pub fn total_unit_death_count(&self) -> u32 {
        self.total_unit_death_count.unwrap_or(0)
    }

    pub fn clear_total_unit_death_count(&mut self) {
        self.total_unit_death_count = ::std::option::Option::None;
    }

    pub fn has_total_unit_death_count(&self) -> bool {
        self.total_unit_death_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_unit_death_count(&mut self, v: u32) {
        self.total_unit_death_count = ::std::option::Option::Some(v);
    }

    // optional bool aura_modifier = 65;

    pub fn aura_modifier(&self) -> bool {
        self.aura_modifier.unwrap_or(false)
    }

    pub fn clear_aura_modifier(&mut self) {
        self.aura_modifier = ::std::option::Option::None;
    }

    pub fn has_aura_modifier(&self) -> bool {
        self.aura_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aura_modifier(&mut self, v: bool) {
        self.aura_modifier = ::std::option::Option::Some(v);
    }

    // optional bool armor_debuff_modifier = 66;

    pub fn armor_debuff_modifier(&self) -> bool {
        self.armor_debuff_modifier.unwrap_or(false)
    }

    pub fn clear_armor_debuff_modifier(&mut self) {
        self.armor_debuff_modifier = ::std::option::Option::None;
    }

    pub fn has_armor_debuff_modifier(&self) -> bool {
        self.armor_debuff_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor_debuff_modifier(&mut self, v: bool) {
        self.armor_debuff_modifier = ::std::option::Option::Some(v);
    }

    // optional bool no_physical_damage_modifier = 67;

    pub fn no_physical_damage_modifier(&self) -> bool {
        self.no_physical_damage_modifier.unwrap_or(false)
    }

    pub fn clear_no_physical_damage_modifier(&mut self) {
        self.no_physical_damage_modifier = ::std::option::Option::None;
    }

    pub fn has_no_physical_damage_modifier(&self) -> bool {
        self.no_physical_damage_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_physical_damage_modifier(&mut self, v: bool) {
        self.no_physical_damage_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 modifier_ability = 68;

    pub fn modifier_ability(&self) -> u32 {
        self.modifier_ability.unwrap_or(0)
    }

    pub fn clear_modifier_ability(&mut self) {
        self.modifier_ability = ::std::option::Option::None;
    }

    pub fn has_modifier_ability(&self) -> bool {
        self.modifier_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_ability(&mut self, v: u32) {
        self.modifier_ability = ::std::option::Option::Some(v);
    }

    // optional bool modifier_hidden = 69;

    pub fn modifier_hidden(&self) -> bool {
        self.modifier_hidden.unwrap_or(false)
    }

    pub fn clear_modifier_hidden(&mut self) {
        self.modifier_hidden = ::std::option::Option::None;
    }

    pub fn has_modifier_hidden(&self) -> bool {
        self.modifier_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_hidden(&mut self, v: bool) {
        self.modifier_hidden = ::std::option::Option::Some(v);
    }

    // optional bool inflictor_is_stolen_ability = 70;

    pub fn inflictor_is_stolen_ability(&self) -> bool {
        self.inflictor_is_stolen_ability.unwrap_or(false)
    }

    pub fn clear_inflictor_is_stolen_ability(&mut self) {
        self.inflictor_is_stolen_ability = ::std::option::Option::None;
    }

    pub fn has_inflictor_is_stolen_ability(&self) -> bool {
        self.inflictor_is_stolen_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inflictor_is_stolen_ability(&mut self, v: bool) {
        self.inflictor_is_stolen_ability = ::std::option::Option::Some(v);
    }

    // optional uint32 kill_eater_event = 71;

    pub fn kill_eater_event(&self) -> u32 {
        self.kill_eater_event.unwrap_or(0)
    }

    pub fn clear_kill_eater_event(&mut self) {
        self.kill_eater_event = ::std::option::Option::None;
    }

    pub fn has_kill_eater_event(&self) -> bool {
        self.kill_eater_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_eater_event(&mut self, v: u32) {
        self.kill_eater_event = ::std::option::Option::Some(v);
    }

    // optional uint32 unit_status_label = 72;

    pub fn unit_status_label(&self) -> u32 {
        self.unit_status_label.unwrap_or(0)
    }

    pub fn clear_unit_status_label(&mut self) {
        self.unit_status_label = ::std::option::Option::None;
    }

    pub fn has_unit_status_label(&self) -> bool {
        self.unit_status_label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_status_label(&mut self, v: u32) {
        self.unit_status_label = ::std::option::Option::Some(v);
    }

    // optional bool spell_generated_attack = 73;

    pub fn spell_generated_attack(&self) -> bool {
        self.spell_generated_attack.unwrap_or(false)
    }

    pub fn clear_spell_generated_attack(&mut self) {
        self.spell_generated_attack = ::std::option::Option::None;
    }

    pub fn has_spell_generated_attack(&self) -> bool {
        self.spell_generated_attack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spell_generated_attack(&mut self, v: bool) {
        self.spell_generated_attack = ::std::option::Option::Some(v);
    }

    // optional bool at_night_time = 74;

    pub fn at_night_time(&self) -> bool {
        self.at_night_time.unwrap_or(false)
    }

    pub fn clear_at_night_time(&mut self) {
        self.at_night_time = ::std::option::Option::None;
    }

    pub fn has_at_night_time(&self) -> bool {
        self.at_night_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_at_night_time(&mut self, v: bool) {
        self.at_night_time = ::std::option::Option::Some(v);
    }

    // optional bool attacker_has_scepter = 75;

    pub fn attacker_has_scepter(&self) -> bool {
        self.attacker_has_scepter.unwrap_or(false)
    }

    pub fn clear_attacker_has_scepter(&mut self) {
        self.attacker_has_scepter = ::std::option::Option::None;
    }

    pub fn has_attacker_has_scepter(&self) -> bool {
        self.attacker_has_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_has_scepter(&mut self, v: bool) {
        self.attacker_has_scepter = ::std::option::Option::Some(v);
    }

    // optional uint32 neutral_camp_team = 76;

    pub fn neutral_camp_team(&self) -> u32 {
        self.neutral_camp_team.unwrap_or(0)
    }

    pub fn clear_neutral_camp_team(&mut self) {
        self.neutral_camp_team = ::std::option::Option::None;
    }

    pub fn has_neutral_camp_team(&self) -> bool {
        self.neutral_camp_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_camp_team(&mut self, v: u32) {
        self.neutral_camp_team = ::std::option::Option::Some(v);
    }

    // optional float regenerated_health = 77;

    pub fn regenerated_health(&self) -> f32 {
        self.regenerated_health.unwrap_or(0.)
    }

    pub fn clear_regenerated_health(&mut self) {
        self.regenerated_health = ::std::option::Option::None;
    }

    pub fn has_regenerated_health(&self) -> bool {
        self.regenerated_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_regenerated_health(&mut self, v: f32) {
        self.regenerated_health = ::std::option::Option::Some(v);
    }

    // optional bool will_reincarnate = 78;

    pub fn will_reincarnate(&self) -> bool {
        self.will_reincarnate.unwrap_or(false)
    }

    pub fn clear_will_reincarnate(&mut self) {
        self.will_reincarnate = ::std::option::Option::None;
    }

    pub fn has_will_reincarnate(&self) -> bool {
        self.will_reincarnate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_will_reincarnate(&mut self, v: bool) {
        self.will_reincarnate = ::std::option::Option::Some(v);
    }

    // optional bool uses_charges = 79;

    pub fn uses_charges(&self) -> bool {
        self.uses_charges.unwrap_or(false)
    }

    pub fn clear_uses_charges(&mut self) {
        self.uses_charges = ::std::option::Option::None;
    }

    pub fn has_uses_charges(&self) -> bool {
        self.uses_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uses_charges(&mut self, v: bool) {
        self.uses_charges = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(79);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgDOTACombatLogEntry| { &m.type_ },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_name",
            |m: &CMsgDOTACombatLogEntry| { &m.target_name },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.target_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_source_name",
            |m: &CMsgDOTACombatLogEntry| { &m.target_source_name },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.target_source_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attacker_name",
            |m: &CMsgDOTACombatLogEntry| { &m.attacker_name },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.attacker_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_source_name",
            |m: &CMsgDOTACombatLogEntry| { &m.damage_source_name },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.damage_source_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inflictor_name",
            |m: &CMsgDOTACombatLogEntry| { &m.inflictor_name },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.inflictor_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_attacker_illusion",
            |m: &CMsgDOTACombatLogEntry| { &m.is_attacker_illusion },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_attacker_illusion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_attacker_hero",
            |m: &CMsgDOTACombatLogEntry| { &m.is_attacker_hero },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_attacker_hero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_target_illusion",
            |m: &CMsgDOTACombatLogEntry| { &m.is_target_illusion },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_target_illusion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_target_hero",
            |m: &CMsgDOTACombatLogEntry| { &m.is_target_hero },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_target_hero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_visible_radiant",
            |m: &CMsgDOTACombatLogEntry| { &m.is_visible_radiant },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_visible_radiant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_visible_dire",
            |m: &CMsgDOTACombatLogEntry| { &m.is_visible_dire },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_visible_dire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgDOTACombatLogEntry| { &m.value },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health",
            |m: &CMsgDOTACombatLogEntry| { &m.health },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgDOTACombatLogEntry| { &m.timestamp },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stun_duration",
            |m: &CMsgDOTACombatLogEntry| { &m.stun_duration },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.stun_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slow_duration",
            |m: &CMsgDOTACombatLogEntry| { &m.slow_duration },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.slow_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_ability_toggle_on",
            |m: &CMsgDOTACombatLogEntry| { &m.is_ability_toggle_on },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_ability_toggle_on },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_ability_toggle_off",
            |m: &CMsgDOTACombatLogEntry| { &m.is_ability_toggle_off },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_ability_toggle_off },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_level",
            |m: &CMsgDOTACombatLogEntry| { &m.ability_level },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.ability_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location_x",
            |m: &CMsgDOTACombatLogEntry| { &m.location_x },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.location_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location_y",
            |m: &CMsgDOTACombatLogEntry| { &m.location_y },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.location_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gold_reason",
            |m: &CMsgDOTACombatLogEntry| { &m.gold_reason },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.gold_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_raw",
            |m: &CMsgDOTACombatLogEntry| { &m.timestamp_raw },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.timestamp_raw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifier_duration",
            |m: &CMsgDOTACombatLogEntry| { &m.modifier_duration },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.modifier_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xp_reason",
            |m: &CMsgDOTACombatLogEntry| { &m.xp_reason },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.xp_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_hits",
            |m: &CMsgDOTACombatLogEntry| { &m.last_hits },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.last_hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attacker_team",
            |m: &CMsgDOTACombatLogEntry| { &m.attacker_team },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.attacker_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_team",
            |m: &CMsgDOTACombatLogEntry| { &m.target_team },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.target_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "obs_wards_placed",
            |m: &CMsgDOTACombatLogEntry| { &m.obs_wards_placed },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.obs_wards_placed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assist_player0",
            |m: &CMsgDOTACombatLogEntry| { &m.assist_player0 },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.assist_player0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assist_player1",
            |m: &CMsgDOTACombatLogEntry| { &m.assist_player1 },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.assist_player1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assist_player2",
            |m: &CMsgDOTACombatLogEntry| { &m.assist_player2 },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.assist_player2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assist_player3",
            |m: &CMsgDOTACombatLogEntry| { &m.assist_player3 },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.assist_player3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_count",
            |m: &CMsgDOTACombatLogEntry| { &m.stack_count },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.stack_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden_modifier",
            |m: &CMsgDOTACombatLogEntry| { &m.hidden_modifier },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.hidden_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_target_building",
            |m: &CMsgDOTACombatLogEntry| { &m.is_target_building },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_target_building },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "neutral_camp_type",
            |m: &CMsgDOTACombatLogEntry| { &m.neutral_camp_type },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.neutral_camp_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rune_type",
            |m: &CMsgDOTACombatLogEntry| { &m.rune_type },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.rune_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "assist_players",
            |m: &CMsgDOTACombatLogEntry| { &m.assist_players },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.assist_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_heal_save",
            |m: &CMsgDOTACombatLogEntry| { &m.is_heal_save },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_heal_save },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_ultimate_ability",
            |m: &CMsgDOTACombatLogEntry| { &m.is_ultimate_ability },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.is_ultimate_ability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attacker_hero_level",
            |m: &CMsgDOTACombatLogEntry| { &m.attacker_hero_level },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.attacker_hero_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_hero_level",
            |m: &CMsgDOTACombatLogEntry| { &m.target_hero_level },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.target_hero_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xpm",
            |m: &CMsgDOTACombatLogEntry| { &m.xpm },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.xpm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpm",
            |m: &CMsgDOTACombatLogEntry| { &m.gpm },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.gpm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_location",
            |m: &CMsgDOTACombatLogEntry| { &m.event_location },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.event_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_is_self",
            |m: &CMsgDOTACombatLogEntry| { &m.target_is_self },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.target_is_self },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_type",
            |m: &CMsgDOTACombatLogEntry| { &m.damage_type },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.damage_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invisibility_modifier",
            |m: &CMsgDOTACombatLogEntry| { &m.invisibility_modifier },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.invisibility_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_category",
            |m: &CMsgDOTACombatLogEntry| { &m.damage_category },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.damage_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "networth",
            |m: &CMsgDOTACombatLogEntry| { &m.networth },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.networth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "building_type",
            |m: &CMsgDOTACombatLogEntry| { &m.building_type },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.building_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifier_elapsed_duration",
            |m: &CMsgDOTACombatLogEntry| { &m.modifier_elapsed_duration },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.modifier_elapsed_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "silence_modifier",
            |m: &CMsgDOTACombatLogEntry| { &m.silence_modifier },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.silence_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "heal_from_lifesteal",
            |m: &CMsgDOTACombatLogEntry| { &m.heal_from_lifesteal },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.heal_from_lifesteal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifier_purged",
            |m: &CMsgDOTACombatLogEntry| { &m.modifier_purged },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.modifier_purged },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spell_evaded",
            |m: &CMsgDOTACombatLogEntry| { &m.spell_evaded },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.spell_evaded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "motion_controller_modifier",
            |m: &CMsgDOTACombatLogEntry| { &m.motion_controller_modifier },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.motion_controller_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "long_range_kill",
            |m: &CMsgDOTACombatLogEntry| { &m.long_range_kill },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.long_range_kill },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifier_purge_ability",
            |m: &CMsgDOTACombatLogEntry| { &m.modifier_purge_ability },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.modifier_purge_ability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifier_purge_npc",
            |m: &CMsgDOTACombatLogEntry| { &m.modifier_purge_npc },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.modifier_purge_npc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "root_modifier",
            |m: &CMsgDOTACombatLogEntry| { &m.root_modifier },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.root_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_unit_death_count",
            |m: &CMsgDOTACombatLogEntry| { &m.total_unit_death_count },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.total_unit_death_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "aura_modifier",
            |m: &CMsgDOTACombatLogEntry| { &m.aura_modifier },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.aura_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "armor_debuff_modifier",
            |m: &CMsgDOTACombatLogEntry| { &m.armor_debuff_modifier },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.armor_debuff_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_physical_damage_modifier",
            |m: &CMsgDOTACombatLogEntry| { &m.no_physical_damage_modifier },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.no_physical_damage_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifier_ability",
            |m: &CMsgDOTACombatLogEntry| { &m.modifier_ability },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.modifier_ability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifier_hidden",
            |m: &CMsgDOTACombatLogEntry| { &m.modifier_hidden },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.modifier_hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inflictor_is_stolen_ability",
            |m: &CMsgDOTACombatLogEntry| { &m.inflictor_is_stolen_ability },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.inflictor_is_stolen_ability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kill_eater_event",
            |m: &CMsgDOTACombatLogEntry| { &m.kill_eater_event },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.kill_eater_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_status_label",
            |m: &CMsgDOTACombatLogEntry| { &m.unit_status_label },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.unit_status_label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spell_generated_attack",
            |m: &CMsgDOTACombatLogEntry| { &m.spell_generated_attack },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.spell_generated_attack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "at_night_time",
            |m: &CMsgDOTACombatLogEntry| { &m.at_night_time },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.at_night_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attacker_has_scepter",
            |m: &CMsgDOTACombatLogEntry| { &m.attacker_has_scepter },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.attacker_has_scepter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "neutral_camp_team",
            |m: &CMsgDOTACombatLogEntry| { &m.neutral_camp_team },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.neutral_camp_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "regenerated_health",
            |m: &CMsgDOTACombatLogEntry| { &m.regenerated_health },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.regenerated_health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "will_reincarnate",
            |m: &CMsgDOTACombatLogEntry| { &m.will_reincarnate },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.will_reincarnate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uses_charges",
            |m: &CMsgDOTACombatLogEntry| { &m.uses_charges },
            |m: &mut CMsgDOTACombatLogEntry| { &mut m.uses_charges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTACombatLogEntry>(
            "CMsgDOTACombatLogEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTACombatLogEntry {
    const NAME: &'static str = "CMsgDOTACombatLogEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.target_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.target_source_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.attacker_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.damage_source_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.inflictor_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.is_attacker_illusion = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.is_attacker_hero = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.is_target_illusion = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.is_target_hero = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.is_visible_radiant = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.is_visible_dire = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.health = ::std::option::Option::Some(is.read_int32()?);
                },
                125 => {
                    self.timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                133 => {
                    self.stun_duration = ::std::option::Option::Some(is.read_float()?);
                },
                141 => {
                    self.slow_duration = ::std::option::Option::Some(is.read_float()?);
                },
                144 => {
                    self.is_ability_toggle_on = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.is_ability_toggle_off = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.ability_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                173 => {
                    self.location_x = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.location_y = ::std::option::Option::Some(is.read_float()?);
                },
                184 => {
                    self.gold_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                197 => {
                    self.timestamp_raw = ::std::option::Option::Some(is.read_float()?);
                },
                205 => {
                    self.modifier_duration = ::std::option::Option::Some(is.read_float()?);
                },
                208 => {
                    self.xp_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.attacker_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.target_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.obs_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.assist_player0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.assist_player1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.assist_player2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.assist_player3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                280 => {
                    self.stack_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.hidden_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                296 => {
                    self.is_target_building = ::std::option::Option::Some(is.read_bool()?);
                },
                304 => {
                    self.neutral_camp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.rune_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                322 => {
                    is.read_repeated_packed_int32_into(&mut self.assist_players)?;
                },
                320 => {
                    self.assist_players.push(is.read_int32()?);
                },
                328 => {
                    self.is_heal_save = ::std::option::Option::Some(is.read_bool()?);
                },
                336 => {
                    self.is_ultimate_ability = ::std::option::Option::Some(is.read_bool()?);
                },
                344 => {
                    self.attacker_hero_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                352 => {
                    self.target_hero_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                360 => {
                    self.xpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.gpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.event_location = ::std::option::Option::Some(is.read_uint32()?);
                },
                384 => {
                    self.target_is_self = ::std::option::Option::Some(is.read_bool()?);
                },
                392 => {
                    self.damage_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                400 => {
                    self.invisibility_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                408 => {
                    self.damage_category = ::std::option::Option::Some(is.read_uint32()?);
                },
                416 => {
                    self.networth = ::std::option::Option::Some(is.read_uint32()?);
                },
                424 => {
                    self.building_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                437 => {
                    self.modifier_elapsed_duration = ::std::option::Option::Some(is.read_float()?);
                },
                440 => {
                    self.silence_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                448 => {
                    self.heal_from_lifesteal = ::std::option::Option::Some(is.read_bool()?);
                },
                456 => {
                    self.modifier_purged = ::std::option::Option::Some(is.read_bool()?);
                },
                464 => {
                    self.spell_evaded = ::std::option::Option::Some(is.read_bool()?);
                },
                472 => {
                    self.motion_controller_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                480 => {
                    self.long_range_kill = ::std::option::Option::Some(is.read_bool()?);
                },
                488 => {
                    self.modifier_purge_ability = ::std::option::Option::Some(is.read_uint32()?);
                },
                496 => {
                    self.modifier_purge_npc = ::std::option::Option::Some(is.read_uint32()?);
                },
                504 => {
                    self.root_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                512 => {
                    self.total_unit_death_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                520 => {
                    self.aura_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                528 => {
                    self.armor_debuff_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                536 => {
                    self.no_physical_damage_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                544 => {
                    self.modifier_ability = ::std::option::Option::Some(is.read_uint32()?);
                },
                552 => {
                    self.modifier_hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                560 => {
                    self.inflictor_is_stolen_ability = ::std::option::Option::Some(is.read_bool()?);
                },
                568 => {
                    self.kill_eater_event = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.unit_status_label = ::std::option::Option::Some(is.read_uint32()?);
                },
                584 => {
                    self.spell_generated_attack = ::std::option::Option::Some(is.read_bool()?);
                },
                592 => {
                    self.at_night_time = ::std::option::Option::Some(is.read_bool()?);
                },
                600 => {
                    self.attacker_has_scepter = ::std::option::Option::Some(is.read_bool()?);
                },
                608 => {
                    self.neutral_camp_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                621 => {
                    self.regenerated_health = ::std::option::Option::Some(is.read_float()?);
                },
                624 => {
                    self.will_reincarnate = ::std::option::Option::Some(is.read_bool()?);
                },
                632 => {
                    self.uses_charges = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.target_name {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.target_source_name {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.attacker_name {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.damage_source_name {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.inflictor_name {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.is_attacker_illusion {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_attacker_hero {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_target_illusion {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_target_hero {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_visible_radiant {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_visible_dire {
            my_size += 1 + 1;
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.health {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.stun_duration {
            my_size += 2 + 4;
        }
        if let Some(v) = self.slow_duration {
            my_size += 2 + 4;
        }
        if let Some(v) = self.is_ability_toggle_on {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_ability_toggle_off {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_level {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.location_x {
            my_size += 2 + 4;
        }
        if let Some(v) = self.location_y {
            my_size += 2 + 4;
        }
        if let Some(v) = self.gold_reason {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.timestamp_raw {
            my_size += 2 + 4;
        }
        if let Some(v) = self.modifier_duration {
            my_size += 2 + 4;
        }
        if let Some(v) = self.xp_reason {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.attacker_team {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.target_team {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.obs_wards_placed {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.assist_player0 {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.assist_player1 {
            my_size += ::protobuf::rt::uint32_size(32, v);
        }
        if let Some(v) = self.assist_player2 {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.assist_player3 {
            my_size += ::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.stack_count {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.hidden_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_target_building {
            my_size += 2 + 1;
        }
        if let Some(v) = self.neutral_camp_type {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.rune_type {
            my_size += ::protobuf::rt::uint32_size(39, v);
        }
        for value in &self.assist_players {
            my_size += ::protobuf::rt::int32_size(40, *value);
        };
        if let Some(v) = self.is_heal_save {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_ultimate_ability {
            my_size += 2 + 1;
        }
        if let Some(v) = self.attacker_hero_level {
            my_size += ::protobuf::rt::uint32_size(43, v);
        }
        if let Some(v) = self.target_hero_level {
            my_size += ::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.xpm {
            my_size += ::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.gpm {
            my_size += ::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.event_location {
            my_size += ::protobuf::rt::uint32_size(47, v);
        }
        if let Some(v) = self.target_is_self {
            my_size += 2 + 1;
        }
        if let Some(v) = self.damage_type {
            my_size += ::protobuf::rt::uint32_size(49, v);
        }
        if let Some(v) = self.invisibility_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.damage_category {
            my_size += ::protobuf::rt::uint32_size(51, v);
        }
        if let Some(v) = self.networth {
            my_size += ::protobuf::rt::uint32_size(52, v);
        }
        if let Some(v) = self.building_type {
            my_size += ::protobuf::rt::uint32_size(53, v);
        }
        if let Some(v) = self.modifier_elapsed_duration {
            my_size += 2 + 4;
        }
        if let Some(v) = self.silence_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.heal_from_lifesteal {
            my_size += 2 + 1;
        }
        if let Some(v) = self.modifier_purged {
            my_size += 2 + 1;
        }
        if let Some(v) = self.spell_evaded {
            my_size += 2 + 1;
        }
        if let Some(v) = self.motion_controller_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.long_range_kill {
            my_size += 2 + 1;
        }
        if let Some(v) = self.modifier_purge_ability {
            my_size += ::protobuf::rt::uint32_size(61, v);
        }
        if let Some(v) = self.modifier_purge_npc {
            my_size += ::protobuf::rt::uint32_size(62, v);
        }
        if let Some(v) = self.root_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.total_unit_death_count {
            my_size += ::protobuf::rt::uint32_size(64, v);
        }
        if let Some(v) = self.aura_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.armor_debuff_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.no_physical_damage_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.modifier_ability {
            my_size += ::protobuf::rt::uint32_size(68, v);
        }
        if let Some(v) = self.modifier_hidden {
            my_size += 2 + 1;
        }
        if let Some(v) = self.inflictor_is_stolen_ability {
            my_size += 2 + 1;
        }
        if let Some(v) = self.kill_eater_event {
            my_size += ::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.unit_status_label {
            my_size += ::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.spell_generated_attack {
            my_size += 2 + 1;
        }
        if let Some(v) = self.at_night_time {
            my_size += 2 + 1;
        }
        if let Some(v) = self.attacker_has_scepter {
            my_size += 2 + 1;
        }
        if let Some(v) = self.neutral_camp_team {
            my_size += ::protobuf::rt::uint32_size(76, v);
        }
        if let Some(v) = self.regenerated_health {
            my_size += 2 + 4;
        }
        if let Some(v) = self.will_reincarnate {
            my_size += 2 + 1;
        }
        if let Some(v) = self.uses_charges {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.target_name {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.target_source_name {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.attacker_name {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.damage_source_name {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.inflictor_name {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_attacker_illusion {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.is_attacker_hero {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_target_illusion {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.is_target_hero {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.is_visible_radiant {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_visible_dire {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.health {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.stun_duration {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.slow_duration {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.is_ability_toggle_on {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.is_ability_toggle_off {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.ability_level {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.location_x {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.location_y {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.gold_reason {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.timestamp_raw {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.modifier_duration {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.xp_reason {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.attacker_team {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.target_team {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.obs_wards_placed {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.assist_player0 {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.assist_player1 {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.assist_player2 {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.assist_player3 {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.hidden_modifier {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.is_target_building {
            os.write_bool(37, v)?;
        }
        if let Some(v) = self.neutral_camp_type {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.rune_type {
            os.write_uint32(39, v)?;
        }
        for v in &self.assist_players {
            os.write_int32(40, *v)?;
        };
        if let Some(v) = self.is_heal_save {
            os.write_bool(41, v)?;
        }
        if let Some(v) = self.is_ultimate_ability {
            os.write_bool(42, v)?;
        }
        if let Some(v) = self.attacker_hero_level {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.target_hero_level {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.xpm {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.event_location {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.target_is_self {
            os.write_bool(48, v)?;
        }
        if let Some(v) = self.damage_type {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.invisibility_modifier {
            os.write_bool(50, v)?;
        }
        if let Some(v) = self.damage_category {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.networth {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.building_type {
            os.write_uint32(53, v)?;
        }
        if let Some(v) = self.modifier_elapsed_duration {
            os.write_float(54, v)?;
        }
        if let Some(v) = self.silence_modifier {
            os.write_bool(55, v)?;
        }
        if let Some(v) = self.heal_from_lifesteal {
            os.write_bool(56, v)?;
        }
        if let Some(v) = self.modifier_purged {
            os.write_bool(57, v)?;
        }
        if let Some(v) = self.spell_evaded {
            os.write_bool(58, v)?;
        }
        if let Some(v) = self.motion_controller_modifier {
            os.write_bool(59, v)?;
        }
        if let Some(v) = self.long_range_kill {
            os.write_bool(60, v)?;
        }
        if let Some(v) = self.modifier_purge_ability {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.modifier_purge_npc {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.root_modifier {
            os.write_bool(63, v)?;
        }
        if let Some(v) = self.total_unit_death_count {
            os.write_uint32(64, v)?;
        }
        if let Some(v) = self.aura_modifier {
            os.write_bool(65, v)?;
        }
        if let Some(v) = self.armor_debuff_modifier {
            os.write_bool(66, v)?;
        }
        if let Some(v) = self.no_physical_damage_modifier {
            os.write_bool(67, v)?;
        }
        if let Some(v) = self.modifier_ability {
            os.write_uint32(68, v)?;
        }
        if let Some(v) = self.modifier_hidden {
            os.write_bool(69, v)?;
        }
        if let Some(v) = self.inflictor_is_stolen_ability {
            os.write_bool(70, v)?;
        }
        if let Some(v) = self.kill_eater_event {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.unit_status_label {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.spell_generated_attack {
            os.write_bool(73, v)?;
        }
        if let Some(v) = self.at_night_time {
            os.write_bool(74, v)?;
        }
        if let Some(v) = self.attacker_has_scepter {
            os.write_bool(75, v)?;
        }
        if let Some(v) = self.neutral_camp_team {
            os.write_uint32(76, v)?;
        }
        if let Some(v) = self.regenerated_health {
            os.write_float(77, v)?;
        }
        if let Some(v) = self.will_reincarnate {
            os.write_bool(78, v)?;
        }
        if let Some(v) = self.uses_charges {
            os.write_bool(79, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACombatLogEntry {
        CMsgDOTACombatLogEntry::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.target_name = ::std::option::Option::None;
        self.target_source_name = ::std::option::Option::None;
        self.attacker_name = ::std::option::Option::None;
        self.damage_source_name = ::std::option::Option::None;
        self.inflictor_name = ::std::option::Option::None;
        self.is_attacker_illusion = ::std::option::Option::None;
        self.is_attacker_hero = ::std::option::Option::None;
        self.is_target_illusion = ::std::option::Option::None;
        self.is_target_hero = ::std::option::Option::None;
        self.is_visible_radiant = ::std::option::Option::None;
        self.is_visible_dire = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.health = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.stun_duration = ::std::option::Option::None;
        self.slow_duration = ::std::option::Option::None;
        self.is_ability_toggle_on = ::std::option::Option::None;
        self.is_ability_toggle_off = ::std::option::Option::None;
        self.ability_level = ::std::option::Option::None;
        self.location_x = ::std::option::Option::None;
        self.location_y = ::std::option::Option::None;
        self.gold_reason = ::std::option::Option::None;
        self.timestamp_raw = ::std::option::Option::None;
        self.modifier_duration = ::std::option::Option::None;
        self.xp_reason = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.attacker_team = ::std::option::Option::None;
        self.target_team = ::std::option::Option::None;
        self.obs_wards_placed = ::std::option::Option::None;
        self.assist_player0 = ::std::option::Option::None;
        self.assist_player1 = ::std::option::Option::None;
        self.assist_player2 = ::std::option::Option::None;
        self.assist_player3 = ::std::option::Option::None;
        self.stack_count = ::std::option::Option::None;
        self.hidden_modifier = ::std::option::Option::None;
        self.is_target_building = ::std::option::Option::None;
        self.neutral_camp_type = ::std::option::Option::None;
        self.rune_type = ::std::option::Option::None;
        self.assist_players.clear();
        self.is_heal_save = ::std::option::Option::None;
        self.is_ultimate_ability = ::std::option::Option::None;
        self.attacker_hero_level = ::std::option::Option::None;
        self.target_hero_level = ::std::option::Option::None;
        self.xpm = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.event_location = ::std::option::Option::None;
        self.target_is_self = ::std::option::Option::None;
        self.damage_type = ::std::option::Option::None;
        self.invisibility_modifier = ::std::option::Option::None;
        self.damage_category = ::std::option::Option::None;
        self.networth = ::std::option::Option::None;
        self.building_type = ::std::option::Option::None;
        self.modifier_elapsed_duration = ::std::option::Option::None;
        self.silence_modifier = ::std::option::Option::None;
        self.heal_from_lifesteal = ::std::option::Option::None;
        self.modifier_purged = ::std::option::Option::None;
        self.spell_evaded = ::std::option::Option::None;
        self.motion_controller_modifier = ::std::option::Option::None;
        self.long_range_kill = ::std::option::Option::None;
        self.modifier_purge_ability = ::std::option::Option::None;
        self.modifier_purge_npc = ::std::option::Option::None;
        self.root_modifier = ::std::option::Option::None;
        self.total_unit_death_count = ::std::option::Option::None;
        self.aura_modifier = ::std::option::Option::None;
        self.armor_debuff_modifier = ::std::option::Option::None;
        self.no_physical_damage_modifier = ::std::option::Option::None;
        self.modifier_ability = ::std::option::Option::None;
        self.modifier_hidden = ::std::option::Option::None;
        self.inflictor_is_stolen_ability = ::std::option::Option::None;
        self.kill_eater_event = ::std::option::Option::None;
        self.unit_status_label = ::std::option::Option::None;
        self.spell_generated_attack = ::std::option::Option::None;
        self.at_night_time = ::std::option::Option::None;
        self.attacker_has_scepter = ::std::option::Option::None;
        self.neutral_camp_team = ::std::option::Option::None;
        self.regenerated_health = ::std::option::Option::None;
        self.will_reincarnate = ::std::option::Option::None;
        self.uses_charges = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACombatLogEntry {
        static instance: CMsgDOTACombatLogEntry = CMsgDOTACombatLogEntry {
            type_: ::std::option::Option::None,
            target_name: ::std::option::Option::None,
            target_source_name: ::std::option::Option::None,
            attacker_name: ::std::option::Option::None,
            damage_source_name: ::std::option::Option::None,
            inflictor_name: ::std::option::Option::None,
            is_attacker_illusion: ::std::option::Option::None,
            is_attacker_hero: ::std::option::Option::None,
            is_target_illusion: ::std::option::Option::None,
            is_target_hero: ::std::option::Option::None,
            is_visible_radiant: ::std::option::Option::None,
            is_visible_dire: ::std::option::Option::None,
            value: ::std::option::Option::None,
            health: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            stun_duration: ::std::option::Option::None,
            slow_duration: ::std::option::Option::None,
            is_ability_toggle_on: ::std::option::Option::None,
            is_ability_toggle_off: ::std::option::Option::None,
            ability_level: ::std::option::Option::None,
            location_x: ::std::option::Option::None,
            location_y: ::std::option::Option::None,
            gold_reason: ::std::option::Option::None,
            timestamp_raw: ::std::option::Option::None,
            modifier_duration: ::std::option::Option::None,
            xp_reason: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            attacker_team: ::std::option::Option::None,
            target_team: ::std::option::Option::None,
            obs_wards_placed: ::std::option::Option::None,
            assist_player0: ::std::option::Option::None,
            assist_player1: ::std::option::Option::None,
            assist_player2: ::std::option::Option::None,
            assist_player3: ::std::option::Option::None,
            stack_count: ::std::option::Option::None,
            hidden_modifier: ::std::option::Option::None,
            is_target_building: ::std::option::Option::None,
            neutral_camp_type: ::std::option::Option::None,
            rune_type: ::std::option::Option::None,
            assist_players: ::std::vec::Vec::new(),
            is_heal_save: ::std::option::Option::None,
            is_ultimate_ability: ::std::option::Option::None,
            attacker_hero_level: ::std::option::Option::None,
            target_hero_level: ::std::option::Option::None,
            xpm: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            event_location: ::std::option::Option::None,
            target_is_self: ::std::option::Option::None,
            damage_type: ::std::option::Option::None,
            invisibility_modifier: ::std::option::Option::None,
            damage_category: ::std::option::Option::None,
            networth: ::std::option::Option::None,
            building_type: ::std::option::Option::None,
            modifier_elapsed_duration: ::std::option::Option::None,
            silence_modifier: ::std::option::Option::None,
            heal_from_lifesteal: ::std::option::Option::None,
            modifier_purged: ::std::option::Option::None,
            spell_evaded: ::std::option::Option::None,
            motion_controller_modifier: ::std::option::Option::None,
            long_range_kill: ::std::option::Option::None,
            modifier_purge_ability: ::std::option::Option::None,
            modifier_purge_npc: ::std::option::Option::None,
            root_modifier: ::std::option::Option::None,
            total_unit_death_count: ::std::option::Option::None,
            aura_modifier: ::std::option::Option::None,
            armor_debuff_modifier: ::std::option::Option::None,
            no_physical_damage_modifier: ::std::option::Option::None,
            modifier_ability: ::std::option::Option::None,
            modifier_hidden: ::std::option::Option::None,
            inflictor_is_stolen_ability: ::std::option::Option::None,
            kill_eater_event: ::std::option::Option::None,
            unit_status_label: ::std::option::Option::None,
            spell_generated_attack: ::std::option::Option::None,
            at_night_time: ::std::option::Option::None,
            attacker_has_scepter: ::std::option::Option::None,
            neutral_camp_team: ::std::option::Option::None,
            regenerated_health: ::std::option::Option::None,
            will_reincarnate: ::std::option::Option::None,
            uses_charges: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTACombatLogEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTACombatLogEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTACombatLogEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACombatLogEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgPendingEventAward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPendingEventAward {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgPendingEventAward.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgPendingEventAward.action_id)
    pub action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPendingEventAward.num_to_grant)
    pub num_to_grant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPendingEventAward.score_mode)
    pub score_mode: ::std::option::Option<::protobuf::EnumOrUnknown<EEventActionScoreMode>>,
    // @@protoc_insertion_point(field:dota.CMsgPendingEventAward.audit_action)
    pub audit_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgPendingEventAward.audit_data)
    pub audit_data: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgPendingEventAward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPendingEventAward {
    fn default() -> &'a CMsgPendingEventAward {
        <CMsgPendingEventAward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPendingEventAward {
    pub fn new() -> CMsgPendingEventAward {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 1;

    pub fn event_id(&self) -> EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(EEvent::EVENT_ID_NONE),
            None => EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 action_id = 2;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    // optional uint32 num_to_grant = 3;

    pub fn num_to_grant(&self) -> u32 {
        self.num_to_grant.unwrap_or(0)
    }

    pub fn clear_num_to_grant(&mut self) {
        self.num_to_grant = ::std::option::Option::None;
    }

    pub fn has_num_to_grant(&self) -> bool {
        self.num_to_grant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_to_grant(&mut self, v: u32) {
        self.num_to_grant = ::std::option::Option::Some(v);
    }

    // optional .dota.EEventActionScoreMode score_mode = 4;

    pub fn score_mode(&self) -> EEventActionScoreMode {
        match self.score_mode {
            Some(e) => e.enum_value_or(EEventActionScoreMode::k_eEventActionScoreMode_Add),
            None => EEventActionScoreMode::k_eEventActionScoreMode_Add,
        }
    }

    pub fn clear_score_mode(&mut self) {
        self.score_mode = ::std::option::Option::None;
    }

    pub fn has_score_mode(&self) -> bool {
        self.score_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_mode(&mut self, v: EEventActionScoreMode) {
        self.score_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 audit_action = 5;

    pub fn audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    // optional uint64 audit_data = 6;

    pub fn audit_data(&self) -> u64 {
        self.audit_data.unwrap_or(0)
    }

    pub fn clear_audit_data(&mut self) {
        self.audit_data = ::std::option::Option::None;
    }

    pub fn has_audit_data(&self) -> bool {
        self.audit_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_data(&mut self, v: u64) {
        self.audit_data = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgPendingEventAward| { &m.event_id },
            |m: &mut CMsgPendingEventAward| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action_id",
            |m: &CMsgPendingEventAward| { &m.action_id },
            |m: &mut CMsgPendingEventAward| { &mut m.action_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_to_grant",
            |m: &CMsgPendingEventAward| { &m.num_to_grant },
            |m: &mut CMsgPendingEventAward| { &mut m.num_to_grant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_mode",
            |m: &CMsgPendingEventAward| { &m.score_mode },
            |m: &mut CMsgPendingEventAward| { &mut m.score_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audit_action",
            |m: &CMsgPendingEventAward| { &m.audit_action },
            |m: &mut CMsgPendingEventAward| { &mut m.audit_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audit_data",
            |m: &CMsgPendingEventAward| { &m.audit_data },
            |m: &mut CMsgPendingEventAward| { &mut m.audit_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPendingEventAward>(
            "CMsgPendingEventAward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPendingEventAward {
    const NAME: &'static str = "CMsgPendingEventAward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_to_grant = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.score_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.action_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_to_grant {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.score_mode {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.audit_action {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.audit_data {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_to_grant {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.score_mode {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.audit_action {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.audit_data {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPendingEventAward {
        CMsgPendingEventAward::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.action_id = ::std::option::Option::None;
        self.num_to_grant = ::std::option::Option::None;
        self.score_mode = ::std::option::Option::None;
        self.audit_action = ::std::option::Option::None;
        self.audit_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPendingEventAward {
        static instance: CMsgPendingEventAward = CMsgPendingEventAward {
            event_id: ::std::option::Option::None,
            action_id: ::std::option::Option::None,
            num_to_grant: ::std::option::Option::None,
            score_mode: ::std::option::Option::None,
            audit_action: ::std::option::Option::None,
            audit_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPendingEventAward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPendingEventAward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPendingEventAward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPendingEventAward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_GameMode)
pub enum DOTA_GameMode {
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_NONE)
    DOTA_GAMEMODE_NONE = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_AP)
    DOTA_GAMEMODE_AP = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_CM)
    DOTA_GAMEMODE_CM = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_RD)
    DOTA_GAMEMODE_RD = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_SD)
    DOTA_GAMEMODE_SD = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_AR)
    DOTA_GAMEMODE_AR = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_INTRO)
    DOTA_GAMEMODE_INTRO = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_HW)
    DOTA_GAMEMODE_HW = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_REVERSE_CM)
    DOTA_GAMEMODE_REVERSE_CM = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_XMAS)
    DOTA_GAMEMODE_XMAS = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_TUTORIAL)
    DOTA_GAMEMODE_TUTORIAL = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_MO)
    DOTA_GAMEMODE_MO = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_LP)
    DOTA_GAMEMODE_LP = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_POOL1)
    DOTA_GAMEMODE_POOL1 = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_FH)
    DOTA_GAMEMODE_FH = 14,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_CUSTOM)
    DOTA_GAMEMODE_CUSTOM = 15,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_CD)
    DOTA_GAMEMODE_CD = 16,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_BD)
    DOTA_GAMEMODE_BD = 17,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_ABILITY_DRAFT)
    DOTA_GAMEMODE_ABILITY_DRAFT = 18,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_EVENT)
    DOTA_GAMEMODE_EVENT = 19,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_ARDM)
    DOTA_GAMEMODE_ARDM = 20,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_1V1MID)
    DOTA_GAMEMODE_1V1MID = 21,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_ALL_DRAFT)
    DOTA_GAMEMODE_ALL_DRAFT = 22,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_TURBO)
    DOTA_GAMEMODE_TURBO = 23,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_MUTATION)
    DOTA_GAMEMODE_MUTATION = 24,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameMode.DOTA_GAMEMODE_COACHES_CHALLENGE)
    DOTA_GAMEMODE_COACHES_CHALLENGE = 25,
}

impl ::protobuf::Enum for DOTA_GameMode {
    const NAME: &'static str = "DOTA_GameMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_GameMode> {
        match value {
            0 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_NONE),
            1 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_AP),
            2 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CM),
            3 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_RD),
            4 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_SD),
            5 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_AR),
            6 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_INTRO),
            7 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_HW),
            8 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_REVERSE_CM),
            9 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_XMAS),
            10 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_TUTORIAL),
            11 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_MO),
            12 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_LP),
            13 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_POOL1),
            14 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_FH),
            15 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CUSTOM),
            16 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CD),
            17 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_BD),
            18 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ABILITY_DRAFT),
            19 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_EVENT),
            20 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ARDM),
            21 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_1V1MID),
            22 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ALL_DRAFT),
            23 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_TURBO),
            24 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_MUTATION),
            25 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_COACHES_CHALLENGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_GameMode> {
        match str {
            "DOTA_GAMEMODE_NONE" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_NONE),
            "DOTA_GAMEMODE_AP" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_AP),
            "DOTA_GAMEMODE_CM" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CM),
            "DOTA_GAMEMODE_RD" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_RD),
            "DOTA_GAMEMODE_SD" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_SD),
            "DOTA_GAMEMODE_AR" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_AR),
            "DOTA_GAMEMODE_INTRO" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_INTRO),
            "DOTA_GAMEMODE_HW" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_HW),
            "DOTA_GAMEMODE_REVERSE_CM" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_REVERSE_CM),
            "DOTA_GAMEMODE_XMAS" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_XMAS),
            "DOTA_GAMEMODE_TUTORIAL" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_TUTORIAL),
            "DOTA_GAMEMODE_MO" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_MO),
            "DOTA_GAMEMODE_LP" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_LP),
            "DOTA_GAMEMODE_POOL1" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_POOL1),
            "DOTA_GAMEMODE_FH" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_FH),
            "DOTA_GAMEMODE_CUSTOM" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CUSTOM),
            "DOTA_GAMEMODE_CD" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CD),
            "DOTA_GAMEMODE_BD" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_BD),
            "DOTA_GAMEMODE_ABILITY_DRAFT" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ABILITY_DRAFT),
            "DOTA_GAMEMODE_EVENT" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_EVENT),
            "DOTA_GAMEMODE_ARDM" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ARDM),
            "DOTA_GAMEMODE_1V1MID" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_1V1MID),
            "DOTA_GAMEMODE_ALL_DRAFT" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ALL_DRAFT),
            "DOTA_GAMEMODE_TURBO" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_TURBO),
            "DOTA_GAMEMODE_MUTATION" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_MUTATION),
            "DOTA_GAMEMODE_COACHES_CHALLENGE" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_COACHES_CHALLENGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_GameMode] = &[
        DOTA_GameMode::DOTA_GAMEMODE_NONE,
        DOTA_GameMode::DOTA_GAMEMODE_AP,
        DOTA_GameMode::DOTA_GAMEMODE_CM,
        DOTA_GameMode::DOTA_GAMEMODE_RD,
        DOTA_GameMode::DOTA_GAMEMODE_SD,
        DOTA_GameMode::DOTA_GAMEMODE_AR,
        DOTA_GameMode::DOTA_GAMEMODE_INTRO,
        DOTA_GameMode::DOTA_GAMEMODE_HW,
        DOTA_GameMode::DOTA_GAMEMODE_REVERSE_CM,
        DOTA_GameMode::DOTA_GAMEMODE_XMAS,
        DOTA_GameMode::DOTA_GAMEMODE_TUTORIAL,
        DOTA_GameMode::DOTA_GAMEMODE_MO,
        DOTA_GameMode::DOTA_GAMEMODE_LP,
        DOTA_GameMode::DOTA_GAMEMODE_POOL1,
        DOTA_GameMode::DOTA_GAMEMODE_FH,
        DOTA_GameMode::DOTA_GAMEMODE_CUSTOM,
        DOTA_GameMode::DOTA_GAMEMODE_CD,
        DOTA_GameMode::DOTA_GAMEMODE_BD,
        DOTA_GameMode::DOTA_GAMEMODE_ABILITY_DRAFT,
        DOTA_GameMode::DOTA_GAMEMODE_EVENT,
        DOTA_GameMode::DOTA_GAMEMODE_ARDM,
        DOTA_GameMode::DOTA_GAMEMODE_1V1MID,
        DOTA_GameMode::DOTA_GAMEMODE_ALL_DRAFT,
        DOTA_GameMode::DOTA_GAMEMODE_TURBO,
        DOTA_GameMode::DOTA_GAMEMODE_MUTATION,
        DOTA_GameMode::DOTA_GAMEMODE_COACHES_CHALLENGE,
    ];
}

impl ::protobuf::EnumFull for DOTA_GameMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_GameMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_GameMode {
    fn default() -> Self {
        DOTA_GameMode::DOTA_GAMEMODE_NONE
    }
}

impl DOTA_GameMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_GameMode>("DOTA_GameMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_GameState)
pub enum DOTA_GameState {
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_INIT)
    DOTA_GAMERULES_STATE_INIT = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD)
    DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_HERO_SELECTION)
    DOTA_GAMERULES_STATE_HERO_SELECTION = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_STRATEGY_TIME)
    DOTA_GAMERULES_STATE_STRATEGY_TIME = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_PRE_GAME)
    DOTA_GAMERULES_STATE_PRE_GAME = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_GAME_IN_PROGRESS)
    DOTA_GAMERULES_STATE_GAME_IN_PROGRESS = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_POST_GAME)
    DOTA_GAMERULES_STATE_POST_GAME = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_DISCONNECT)
    DOTA_GAMERULES_STATE_DISCONNECT = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_TEAM_SHOWCASE)
    DOTA_GAMERULES_STATE_TEAM_SHOWCASE = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP)
    DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD)
    DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_SCENARIO_SETUP)
    DOTA_GAMERULES_STATE_SCENARIO_SETUP = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_PLAYER_DRAFT)
    DOTA_GAMERULES_STATE_PLAYER_DRAFT = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GameState.DOTA_GAMERULES_STATE_LAST)
    DOTA_GAMERULES_STATE_LAST = 13,
}

impl ::protobuf::Enum for DOTA_GameState {
    const NAME: &'static str = "DOTA_GameState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_GameState> {
        match value {
            0 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            1 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD),
            2 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_HERO_SELECTION),
            3 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_STRATEGY_TIME),
            4 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_PRE_GAME),
            5 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_GAME_IN_PROGRESS),
            6 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_POST_GAME),
            7 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_DISCONNECT),
            8 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_TEAM_SHOWCASE),
            9 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP),
            10 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD),
            11 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_SCENARIO_SETUP),
            12 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_PLAYER_DRAFT),
            13 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_LAST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_GameState> {
        match str {
            "DOTA_GAMERULES_STATE_INIT" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            "DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD),
            "DOTA_GAMERULES_STATE_HERO_SELECTION" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_HERO_SELECTION),
            "DOTA_GAMERULES_STATE_STRATEGY_TIME" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_STRATEGY_TIME),
            "DOTA_GAMERULES_STATE_PRE_GAME" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_PRE_GAME),
            "DOTA_GAMERULES_STATE_GAME_IN_PROGRESS" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_GAME_IN_PROGRESS),
            "DOTA_GAMERULES_STATE_POST_GAME" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_POST_GAME),
            "DOTA_GAMERULES_STATE_DISCONNECT" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_DISCONNECT),
            "DOTA_GAMERULES_STATE_TEAM_SHOWCASE" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_TEAM_SHOWCASE),
            "DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP),
            "DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD),
            "DOTA_GAMERULES_STATE_SCENARIO_SETUP" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_SCENARIO_SETUP),
            "DOTA_GAMERULES_STATE_PLAYER_DRAFT" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_PLAYER_DRAFT),
            "DOTA_GAMERULES_STATE_LAST" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_LAST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_GameState] = &[
        DOTA_GameState::DOTA_GAMERULES_STATE_INIT,
        DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD,
        DOTA_GameState::DOTA_GAMERULES_STATE_HERO_SELECTION,
        DOTA_GameState::DOTA_GAMERULES_STATE_STRATEGY_TIME,
        DOTA_GameState::DOTA_GAMERULES_STATE_PRE_GAME,
        DOTA_GameState::DOTA_GAMERULES_STATE_GAME_IN_PROGRESS,
        DOTA_GameState::DOTA_GAMERULES_STATE_POST_GAME,
        DOTA_GameState::DOTA_GAMERULES_STATE_DISCONNECT,
        DOTA_GameState::DOTA_GAMERULES_STATE_TEAM_SHOWCASE,
        DOTA_GameState::DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP,
        DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD,
        DOTA_GameState::DOTA_GAMERULES_STATE_SCENARIO_SETUP,
        DOTA_GameState::DOTA_GAMERULES_STATE_PLAYER_DRAFT,
        DOTA_GameState::DOTA_GAMERULES_STATE_LAST,
    ];
}

impl ::protobuf::EnumFull for DOTA_GameState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_GameState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_GameState {
    fn default() -> Self {
        DOTA_GameState::DOTA_GAMERULES_STATE_INIT
    }
}

impl DOTA_GameState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_GameState>("DOTA_GameState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_GC_TEAM)
pub enum DOTA_GC_TEAM {
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_GOOD_GUYS)
    DOTA_GC_TEAM_GOOD_GUYS = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_BAD_GUYS)
    DOTA_GC_TEAM_BAD_GUYS = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_BROADCASTER)
    DOTA_GC_TEAM_BROADCASTER = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_SPECTATOR)
    DOTA_GC_TEAM_SPECTATOR = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_PLAYER_POOL)
    DOTA_GC_TEAM_PLAYER_POOL = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_NOTEAM)
    DOTA_GC_TEAM_NOTEAM = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_1)
    DOTA_GC_TEAM_CUSTOM_1 = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_2)
    DOTA_GC_TEAM_CUSTOM_2 = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_3)
    DOTA_GC_TEAM_CUSTOM_3 = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_4)
    DOTA_GC_TEAM_CUSTOM_4 = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_5)
    DOTA_GC_TEAM_CUSTOM_5 = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_6)
    DOTA_GC_TEAM_CUSTOM_6 = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_7)
    DOTA_GC_TEAM_CUSTOM_7 = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_8)
    DOTA_GC_TEAM_CUSTOM_8 = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTA_GC_TEAM.DOTA_GC_TEAM_NEUTRALS)
    DOTA_GC_TEAM_NEUTRALS = 14,
}

impl ::protobuf::Enum for DOTA_GC_TEAM {
    const NAME: &'static str = "DOTA_GC_TEAM";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_GC_TEAM> {
        match value {
            0 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            1 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_BAD_GUYS),
            2 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_BROADCASTER),
            3 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_SPECTATOR),
            4 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_PLAYER_POOL),
            5 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM),
            6 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_1),
            7 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_2),
            8 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_3),
            9 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_4),
            10 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_5),
            11 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_6),
            12 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_7),
            13 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_8),
            14 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_NEUTRALS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_GC_TEAM> {
        match str {
            "DOTA_GC_TEAM_GOOD_GUYS" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            "DOTA_GC_TEAM_BAD_GUYS" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_BAD_GUYS),
            "DOTA_GC_TEAM_BROADCASTER" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_BROADCASTER),
            "DOTA_GC_TEAM_SPECTATOR" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_SPECTATOR),
            "DOTA_GC_TEAM_PLAYER_POOL" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_PLAYER_POOL),
            "DOTA_GC_TEAM_NOTEAM" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM),
            "DOTA_GC_TEAM_CUSTOM_1" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_1),
            "DOTA_GC_TEAM_CUSTOM_2" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_2),
            "DOTA_GC_TEAM_CUSTOM_3" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_3),
            "DOTA_GC_TEAM_CUSTOM_4" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_4),
            "DOTA_GC_TEAM_CUSTOM_5" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_5),
            "DOTA_GC_TEAM_CUSTOM_6" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_6),
            "DOTA_GC_TEAM_CUSTOM_7" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_7),
            "DOTA_GC_TEAM_CUSTOM_8" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_8),
            "DOTA_GC_TEAM_NEUTRALS" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_NEUTRALS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_GC_TEAM] = &[
        DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        DOTA_GC_TEAM::DOTA_GC_TEAM_BAD_GUYS,
        DOTA_GC_TEAM::DOTA_GC_TEAM_BROADCASTER,
        DOTA_GC_TEAM::DOTA_GC_TEAM_SPECTATOR,
        DOTA_GC_TEAM::DOTA_GC_TEAM_PLAYER_POOL,
        DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_1,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_2,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_3,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_4,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_5,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_6,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_7,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_8,
        DOTA_GC_TEAM::DOTA_GC_TEAM_NEUTRALS,
    ];
}

impl ::protobuf::EnumFull for DOTA_GC_TEAM {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_GC_TEAM").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_GC_TEAM {
    fn default() -> Self {
        DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS
    }
}

impl DOTA_GC_TEAM {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_GC_TEAM>("DOTA_GC_TEAM")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EEvent)
pub enum EEvent {
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_NONE)
    EVENT_ID_NONE = 0,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_DIRETIDE)
    EVENT_ID_DIRETIDE = 1,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_SPRING_FESTIVAL)
    EVENT_ID_SPRING_FESTIVAL = 2,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_FROSTIVUS_2013)
    EVENT_ID_FROSTIVUS_2013 = 3,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_COMPENDIUM_2014)
    EVENT_ID_COMPENDIUM_2014 = 4,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_NEXON_PC_BANG)
    EVENT_ID_NEXON_PC_BANG = 5,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_PWRD_DAC_2015)
    EVENT_ID_PWRD_DAC_2015 = 6,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_NEW_BLOOM_2015)
    EVENT_ID_NEW_BLOOM_2015 = 7,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_INTERNATIONAL_2015)
    EVENT_ID_INTERNATIONAL_2015 = 8,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_FALL_MAJOR_2015)
    EVENT_ID_FALL_MAJOR_2015 = 9,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_ORACLE_PA)
    EVENT_ID_ORACLE_PA = 10,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_NEW_BLOOM_2015_PREBEAST)
    EVENT_ID_NEW_BLOOM_2015_PREBEAST = 11,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_FROSTIVUS)
    EVENT_ID_FROSTIVUS = 12,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_WINTER_MAJOR_2016)
    EVENT_ID_WINTER_MAJOR_2016 = 13,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_INTERNATIONAL_2016)
    EVENT_ID_INTERNATIONAL_2016 = 14,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_FALL_MAJOR_2016)
    EVENT_ID_FALL_MAJOR_2016 = 15,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_WINTER_MAJOR_2017)
    EVENT_ID_WINTER_MAJOR_2017 = 16,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_NEW_BLOOM_2017)
    EVENT_ID_NEW_BLOOM_2017 = 17,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_INTERNATIONAL_2017)
    EVENT_ID_INTERNATIONAL_2017 = 18,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_PLUS_SUBSCRIPTION)
    EVENT_ID_PLUS_SUBSCRIPTION = 19,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_SINGLES_DAY_2017)
    EVENT_ID_SINGLES_DAY_2017 = 20,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_FROSTIVUS_2017)
    EVENT_ID_FROSTIVUS_2017 = 21,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_INTERNATIONAL_2018)
    EVENT_ID_INTERNATIONAL_2018 = 22,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_FROSTIVUS_2018)
    EVENT_ID_FROSTIVUS_2018 = 23,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_NEW_BLOOM_2019)
    EVENT_ID_NEW_BLOOM_2019 = 24,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_INTERNATIONAL_2019)
    EVENT_ID_INTERNATIONAL_2019 = 25,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_NEW_PLAYER_EXPERIENCE)
    EVENT_ID_NEW_PLAYER_EXPERIENCE = 26,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_FROSTIVUS_2019)
    EVENT_ID_FROSTIVUS_2019 = 27,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_NEW_BLOOM_2020)
    EVENT_ID_NEW_BLOOM_2020 = 28,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_INTERNATIONAL_2020)
    EVENT_ID_INTERNATIONAL_2020 = 29,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_TEAM_FANDOM)
    EVENT_ID_TEAM_FANDOM = 30,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_DIRETIDE_2020)
    EVENT_ID_DIRETIDE_2020 = 31,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_SPRING_2021)
    EVENT_ID_SPRING_2021 = 32,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_FALL_2021)
    EVENT_ID_FALL_2021 = 33,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_TEAM_FANDOM_FALL_2021)
    EVENT_ID_TEAM_FANDOM_FALL_2021 = 34,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_TEAM_2021_2022_TOUR2)
    EVENT_ID_TEAM_2021_2022_TOUR2 = 35,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_INTERNATIONAL_2022)
    EVENT_ID_INTERNATIONAL_2022 = 36,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_TEAM_2021_2022_TOUR3)
    EVENT_ID_TEAM_2021_2022_TOUR3 = 37,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_TEAM_INTERNATIONAL_2022)
    EVENT_ID_TEAM_INTERNATIONAL_2022 = 38,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_PERMANENT_GRANTS)
    EVENT_ID_PERMANENT_GRANTS = 39,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_MUERTA_RELEASE_SPRING2023)
    EVENT_ID_MUERTA_RELEASE_SPRING2023 = 40,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_TEAM_2023_TOUR1)
    EVENT_ID_TEAM_2023_TOUR1 = 41,
    // @@protoc_insertion_point(enum_value:dota.EEvent.EVENT_ID_TEAM_2023_TOUR2)
    EVENT_ID_TEAM_2023_TOUR2 = 42,
}

impl ::protobuf::Enum for EEvent {
    const NAME: &'static str = "EEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EEvent> {
        match value {
            0 => ::std::option::Option::Some(EEvent::EVENT_ID_NONE),
            1 => ::std::option::Option::Some(EEvent::EVENT_ID_DIRETIDE),
            2 => ::std::option::Option::Some(EEvent::EVENT_ID_SPRING_FESTIVAL),
            3 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2013),
            4 => ::std::option::Option::Some(EEvent::EVENT_ID_COMPENDIUM_2014),
            5 => ::std::option::Option::Some(EEvent::EVENT_ID_NEXON_PC_BANG),
            6 => ::std::option::Option::Some(EEvent::EVENT_ID_PWRD_DAC_2015),
            7 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2015),
            8 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2015),
            9 => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_MAJOR_2015),
            10 => ::std::option::Option::Some(EEvent::EVENT_ID_ORACLE_PA),
            11 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2015_PREBEAST),
            12 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS),
            13 => ::std::option::Option::Some(EEvent::EVENT_ID_WINTER_MAJOR_2016),
            14 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2016),
            15 => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_MAJOR_2016),
            16 => ::std::option::Option::Some(EEvent::EVENT_ID_WINTER_MAJOR_2017),
            17 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2017),
            18 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2017),
            19 => ::std::option::Option::Some(EEvent::EVENT_ID_PLUS_SUBSCRIPTION),
            20 => ::std::option::Option::Some(EEvent::EVENT_ID_SINGLES_DAY_2017),
            21 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2017),
            22 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2018),
            23 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2018),
            24 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2019),
            25 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2019),
            26 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_PLAYER_EXPERIENCE),
            27 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2019),
            28 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2020),
            29 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2020),
            30 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_FANDOM),
            31 => ::std::option::Option::Some(EEvent::EVENT_ID_DIRETIDE_2020),
            32 => ::std::option::Option::Some(EEvent::EVENT_ID_SPRING_2021),
            33 => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_2021),
            34 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_FANDOM_FALL_2021),
            35 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2021_2022_TOUR2),
            36 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2022),
            37 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2021_2022_TOUR3),
            38 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_INTERNATIONAL_2022),
            39 => ::std::option::Option::Some(EEvent::EVENT_ID_PERMANENT_GRANTS),
            40 => ::std::option::Option::Some(EEvent::EVENT_ID_MUERTA_RELEASE_SPRING2023),
            41 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR1),
            42 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EEvent> {
        match str {
            "EVENT_ID_NONE" => ::std::option::Option::Some(EEvent::EVENT_ID_NONE),
            "EVENT_ID_DIRETIDE" => ::std::option::Option::Some(EEvent::EVENT_ID_DIRETIDE),
            "EVENT_ID_SPRING_FESTIVAL" => ::std::option::Option::Some(EEvent::EVENT_ID_SPRING_FESTIVAL),
            "EVENT_ID_FROSTIVUS_2013" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2013),
            "EVENT_ID_COMPENDIUM_2014" => ::std::option::Option::Some(EEvent::EVENT_ID_COMPENDIUM_2014),
            "EVENT_ID_NEXON_PC_BANG" => ::std::option::Option::Some(EEvent::EVENT_ID_NEXON_PC_BANG),
            "EVENT_ID_PWRD_DAC_2015" => ::std::option::Option::Some(EEvent::EVENT_ID_PWRD_DAC_2015),
            "EVENT_ID_NEW_BLOOM_2015" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2015),
            "EVENT_ID_INTERNATIONAL_2015" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2015),
            "EVENT_ID_FALL_MAJOR_2015" => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_MAJOR_2015),
            "EVENT_ID_ORACLE_PA" => ::std::option::Option::Some(EEvent::EVENT_ID_ORACLE_PA),
            "EVENT_ID_NEW_BLOOM_2015_PREBEAST" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2015_PREBEAST),
            "EVENT_ID_FROSTIVUS" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS),
            "EVENT_ID_WINTER_MAJOR_2016" => ::std::option::Option::Some(EEvent::EVENT_ID_WINTER_MAJOR_2016),
            "EVENT_ID_INTERNATIONAL_2016" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2016),
            "EVENT_ID_FALL_MAJOR_2016" => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_MAJOR_2016),
            "EVENT_ID_WINTER_MAJOR_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_WINTER_MAJOR_2017),
            "EVENT_ID_NEW_BLOOM_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2017),
            "EVENT_ID_INTERNATIONAL_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2017),
            "EVENT_ID_PLUS_SUBSCRIPTION" => ::std::option::Option::Some(EEvent::EVENT_ID_PLUS_SUBSCRIPTION),
            "EVENT_ID_SINGLES_DAY_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_SINGLES_DAY_2017),
            "EVENT_ID_FROSTIVUS_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2017),
            "EVENT_ID_INTERNATIONAL_2018" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2018),
            "EVENT_ID_FROSTIVUS_2018" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2018),
            "EVENT_ID_NEW_BLOOM_2019" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2019),
            "EVENT_ID_INTERNATIONAL_2019" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2019),
            "EVENT_ID_NEW_PLAYER_EXPERIENCE" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_PLAYER_EXPERIENCE),
            "EVENT_ID_FROSTIVUS_2019" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2019),
            "EVENT_ID_NEW_BLOOM_2020" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2020),
            "EVENT_ID_INTERNATIONAL_2020" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2020),
            "EVENT_ID_TEAM_FANDOM" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_FANDOM),
            "EVENT_ID_DIRETIDE_2020" => ::std::option::Option::Some(EEvent::EVENT_ID_DIRETIDE_2020),
            "EVENT_ID_SPRING_2021" => ::std::option::Option::Some(EEvent::EVENT_ID_SPRING_2021),
            "EVENT_ID_FALL_2021" => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_2021),
            "EVENT_ID_TEAM_FANDOM_FALL_2021" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_FANDOM_FALL_2021),
            "EVENT_ID_TEAM_2021_2022_TOUR2" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2021_2022_TOUR2),
            "EVENT_ID_INTERNATIONAL_2022" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2022),
            "EVENT_ID_TEAM_2021_2022_TOUR3" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2021_2022_TOUR3),
            "EVENT_ID_TEAM_INTERNATIONAL_2022" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_INTERNATIONAL_2022),
            "EVENT_ID_PERMANENT_GRANTS" => ::std::option::Option::Some(EEvent::EVENT_ID_PERMANENT_GRANTS),
            "EVENT_ID_MUERTA_RELEASE_SPRING2023" => ::std::option::Option::Some(EEvent::EVENT_ID_MUERTA_RELEASE_SPRING2023),
            "EVENT_ID_TEAM_2023_TOUR1" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR1),
            "EVENT_ID_TEAM_2023_TOUR2" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EEvent] = &[
        EEvent::EVENT_ID_NONE,
        EEvent::EVENT_ID_DIRETIDE,
        EEvent::EVENT_ID_SPRING_FESTIVAL,
        EEvent::EVENT_ID_FROSTIVUS_2013,
        EEvent::EVENT_ID_COMPENDIUM_2014,
        EEvent::EVENT_ID_NEXON_PC_BANG,
        EEvent::EVENT_ID_PWRD_DAC_2015,
        EEvent::EVENT_ID_NEW_BLOOM_2015,
        EEvent::EVENT_ID_INTERNATIONAL_2015,
        EEvent::EVENT_ID_FALL_MAJOR_2015,
        EEvent::EVENT_ID_ORACLE_PA,
        EEvent::EVENT_ID_NEW_BLOOM_2015_PREBEAST,
        EEvent::EVENT_ID_FROSTIVUS,
        EEvent::EVENT_ID_WINTER_MAJOR_2016,
        EEvent::EVENT_ID_INTERNATIONAL_2016,
        EEvent::EVENT_ID_FALL_MAJOR_2016,
        EEvent::EVENT_ID_WINTER_MAJOR_2017,
        EEvent::EVENT_ID_NEW_BLOOM_2017,
        EEvent::EVENT_ID_INTERNATIONAL_2017,
        EEvent::EVENT_ID_PLUS_SUBSCRIPTION,
        EEvent::EVENT_ID_SINGLES_DAY_2017,
        EEvent::EVENT_ID_FROSTIVUS_2017,
        EEvent::EVENT_ID_INTERNATIONAL_2018,
        EEvent::EVENT_ID_FROSTIVUS_2018,
        EEvent::EVENT_ID_NEW_BLOOM_2019,
        EEvent::EVENT_ID_INTERNATIONAL_2019,
        EEvent::EVENT_ID_NEW_PLAYER_EXPERIENCE,
        EEvent::EVENT_ID_FROSTIVUS_2019,
        EEvent::EVENT_ID_NEW_BLOOM_2020,
        EEvent::EVENT_ID_INTERNATIONAL_2020,
        EEvent::EVENT_ID_TEAM_FANDOM,
        EEvent::EVENT_ID_DIRETIDE_2020,
        EEvent::EVENT_ID_SPRING_2021,
        EEvent::EVENT_ID_FALL_2021,
        EEvent::EVENT_ID_TEAM_FANDOM_FALL_2021,
        EEvent::EVENT_ID_TEAM_2021_2022_TOUR2,
        EEvent::EVENT_ID_INTERNATIONAL_2022,
        EEvent::EVENT_ID_TEAM_2021_2022_TOUR3,
        EEvent::EVENT_ID_TEAM_INTERNATIONAL_2022,
        EEvent::EVENT_ID_PERMANENT_GRANTS,
        EEvent::EVENT_ID_MUERTA_RELEASE_SPRING2023,
        EEvent::EVENT_ID_TEAM_2023_TOUR1,
        EEvent::EVENT_ID_TEAM_2023_TOUR2,
    ];
}

impl ::protobuf::EnumFull for EEvent {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EEvent").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EEvent {
    fn default() -> Self {
        EEvent::EVENT_ID_NONE
    }
}

impl EEvent {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EEvent>("EEvent")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ERankType)
pub enum ERankType {
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_Invalid)
    k_ERankType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_Casual)
    k_ERankType_Casual = 1,
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_Ranked)
    k_ERankType_Ranked = 2,
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_CasualLegacy)
    k_ERankType_CasualLegacy = 3,
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_RankedLegacy)
    k_ERankType_RankedLegacy = 4,
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_CasualGlicko)
    k_ERankType_CasualGlicko = 5,
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_RankedGlicko)
    k_ERankType_RankedGlicko = 6,
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_CasualRemapped)
    k_ERankType_CasualRemapped = 7,
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_CasualRemappedGlicko)
    k_ERankType_CasualRemappedGlicko = 8,
    // @@protoc_insertion_point(enum_value:dota.ERankType.k_ERankType_CasualShiftedGlicko)
    k_ERankType_CasualShiftedGlicko = 9,
}

impl ::protobuf::Enum for ERankType {
    const NAME: &'static str = "ERankType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERankType> {
        match value {
            0 => ::std::option::Option::Some(ERankType::k_ERankType_Invalid),
            1 => ::std::option::Option::Some(ERankType::k_ERankType_Casual),
            2 => ::std::option::Option::Some(ERankType::k_ERankType_Ranked),
            3 => ::std::option::Option::Some(ERankType::k_ERankType_CasualLegacy),
            4 => ::std::option::Option::Some(ERankType::k_ERankType_RankedLegacy),
            5 => ::std::option::Option::Some(ERankType::k_ERankType_CasualGlicko),
            6 => ::std::option::Option::Some(ERankType::k_ERankType_RankedGlicko),
            7 => ::std::option::Option::Some(ERankType::k_ERankType_CasualRemapped),
            8 => ::std::option::Option::Some(ERankType::k_ERankType_CasualRemappedGlicko),
            9 => ::std::option::Option::Some(ERankType::k_ERankType_CasualShiftedGlicko),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERankType> {
        match str {
            "k_ERankType_Invalid" => ::std::option::Option::Some(ERankType::k_ERankType_Invalid),
            "k_ERankType_Casual" => ::std::option::Option::Some(ERankType::k_ERankType_Casual),
            "k_ERankType_Ranked" => ::std::option::Option::Some(ERankType::k_ERankType_Ranked),
            "k_ERankType_CasualLegacy" => ::std::option::Option::Some(ERankType::k_ERankType_CasualLegacy),
            "k_ERankType_RankedLegacy" => ::std::option::Option::Some(ERankType::k_ERankType_RankedLegacy),
            "k_ERankType_CasualGlicko" => ::std::option::Option::Some(ERankType::k_ERankType_CasualGlicko),
            "k_ERankType_RankedGlicko" => ::std::option::Option::Some(ERankType::k_ERankType_RankedGlicko),
            "k_ERankType_CasualRemapped" => ::std::option::Option::Some(ERankType::k_ERankType_CasualRemapped),
            "k_ERankType_CasualRemappedGlicko" => ::std::option::Option::Some(ERankType::k_ERankType_CasualRemappedGlicko),
            "k_ERankType_CasualShiftedGlicko" => ::std::option::Option::Some(ERankType::k_ERankType_CasualShiftedGlicko),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERankType] = &[
        ERankType::k_ERankType_Invalid,
        ERankType::k_ERankType_Casual,
        ERankType::k_ERankType_Ranked,
        ERankType::k_ERankType_CasualLegacy,
        ERankType::k_ERankType_RankedLegacy,
        ERankType::k_ERankType_CasualGlicko,
        ERankType::k_ERankType_RankedGlicko,
        ERankType::k_ERankType_CasualRemapped,
        ERankType::k_ERankType_CasualRemappedGlicko,
        ERankType::k_ERankType_CasualShiftedGlicko,
    ];
}

impl ::protobuf::EnumFull for ERankType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ERankType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ERankType {
    fn default() -> Self {
        ERankType::k_ERankType_Invalid
    }
}

impl ERankType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERankType>("ERankType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTALeaverStatus_t)
pub enum DOTALeaverStatus_t {
    // @@protoc_insertion_point(enum_value:dota.DOTALeaverStatus_t.DOTA_LEAVER_NONE)
    DOTA_LEAVER_NONE = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTALeaverStatus_t.DOTA_LEAVER_DISCONNECTED)
    DOTA_LEAVER_DISCONNECTED = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTALeaverStatus_t.DOTA_LEAVER_DISCONNECTED_TOO_LONG)
    DOTA_LEAVER_DISCONNECTED_TOO_LONG = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTALeaverStatus_t.DOTA_LEAVER_ABANDONED)
    DOTA_LEAVER_ABANDONED = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTALeaverStatus_t.DOTA_LEAVER_AFK)
    DOTA_LEAVER_AFK = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTALeaverStatus_t.DOTA_LEAVER_NEVER_CONNECTED)
    DOTA_LEAVER_NEVER_CONNECTED = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTALeaverStatus_t.DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG)
    DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTALeaverStatus_t.DOTA_LEAVER_FAILED_TO_READY_UP)
    DOTA_LEAVER_FAILED_TO_READY_UP = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTALeaverStatus_t.DOTA_LEAVER_DECLINED)
    DOTA_LEAVER_DECLINED = 8,
}

impl ::protobuf::Enum for DOTALeaverStatus_t {
    const NAME: &'static str = "DOTALeaverStatus_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTALeaverStatus_t> {
        match value {
            0 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NONE),
            1 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED),
            2 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED_TOO_LONG),
            3 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_ABANDONED),
            4 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_AFK),
            5 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED),
            6 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG),
            7 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_FAILED_TO_READY_UP),
            8 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DECLINED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTALeaverStatus_t> {
        match str {
            "DOTA_LEAVER_NONE" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NONE),
            "DOTA_LEAVER_DISCONNECTED" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED),
            "DOTA_LEAVER_DISCONNECTED_TOO_LONG" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED_TOO_LONG),
            "DOTA_LEAVER_ABANDONED" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_ABANDONED),
            "DOTA_LEAVER_AFK" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_AFK),
            "DOTA_LEAVER_NEVER_CONNECTED" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED),
            "DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG),
            "DOTA_LEAVER_FAILED_TO_READY_UP" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_FAILED_TO_READY_UP),
            "DOTA_LEAVER_DECLINED" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DECLINED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTALeaverStatus_t] = &[
        DOTALeaverStatus_t::DOTA_LEAVER_NONE,
        DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED,
        DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED_TOO_LONG,
        DOTALeaverStatus_t::DOTA_LEAVER_ABANDONED,
        DOTALeaverStatus_t::DOTA_LEAVER_AFK,
        DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED,
        DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG,
        DOTALeaverStatus_t::DOTA_LEAVER_FAILED_TO_READY_UP,
        DOTALeaverStatus_t::DOTA_LEAVER_DECLINED,
    ];
}

impl ::protobuf::EnumFull for DOTALeaverStatus_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTALeaverStatus_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTALeaverStatus_t {
    fn default() -> Self {
        DOTALeaverStatus_t::DOTA_LEAVER_NONE
    }
}

impl DOTALeaverStatus_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTALeaverStatus_t>("DOTALeaverStatus_t")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTAConnectionState_t)
pub enum DOTAConnectionState_t {
    // @@protoc_insertion_point(enum_value:dota.DOTAConnectionState_t.DOTA_CONNECTION_STATE_UNKNOWN)
    DOTA_CONNECTION_STATE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTAConnectionState_t.DOTA_CONNECTION_STATE_NOT_YET_CONNECTED)
    DOTA_CONNECTION_STATE_NOT_YET_CONNECTED = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTAConnectionState_t.DOTA_CONNECTION_STATE_CONNECTED)
    DOTA_CONNECTION_STATE_CONNECTED = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTAConnectionState_t.DOTA_CONNECTION_STATE_DISCONNECTED)
    DOTA_CONNECTION_STATE_DISCONNECTED = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTAConnectionState_t.DOTA_CONNECTION_STATE_ABANDONED)
    DOTA_CONNECTION_STATE_ABANDONED = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTAConnectionState_t.DOTA_CONNECTION_STATE_LOADING)
    DOTA_CONNECTION_STATE_LOADING = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTAConnectionState_t.DOTA_CONNECTION_STATE_FAILED)
    DOTA_CONNECTION_STATE_FAILED = 6,
}

impl ::protobuf::Enum for DOTAConnectionState_t {
    const NAME: &'static str = "DOTAConnectionState_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTAConnectionState_t> {
        match value {
            0 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_UNKNOWN),
            1 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_NOT_YET_CONNECTED),
            2 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_CONNECTED),
            3 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_DISCONNECTED),
            4 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_ABANDONED),
            5 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_LOADING),
            6 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTAConnectionState_t> {
        match str {
            "DOTA_CONNECTION_STATE_UNKNOWN" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_UNKNOWN),
            "DOTA_CONNECTION_STATE_NOT_YET_CONNECTED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_NOT_YET_CONNECTED),
            "DOTA_CONNECTION_STATE_CONNECTED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_CONNECTED),
            "DOTA_CONNECTION_STATE_DISCONNECTED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_DISCONNECTED),
            "DOTA_CONNECTION_STATE_ABANDONED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_ABANDONED),
            "DOTA_CONNECTION_STATE_LOADING" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_LOADING),
            "DOTA_CONNECTION_STATE_FAILED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_FAILED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTAConnectionState_t] = &[
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_UNKNOWN,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_NOT_YET_CONNECTED,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_CONNECTED,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_DISCONNECTED,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_ABANDONED,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_LOADING,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_FAILED,
    ];
}

impl ::protobuf::EnumFull for DOTAConnectionState_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTAConnectionState_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTAConnectionState_t {
    fn default() -> Self {
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_UNKNOWN
    }
}

impl DOTAConnectionState_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTAConnectionState_t>("DOTAConnectionState_t")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.Fantasy_Roles)
pub enum Fantasy_Roles {
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Roles.FANTASY_ROLE_UNDEFINED)
    FANTASY_ROLE_UNDEFINED = 0,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Roles.FANTASY_ROLE_CORE)
    FANTASY_ROLE_CORE = 1,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Roles.FANTASY_ROLE_SUPPORT)
    FANTASY_ROLE_SUPPORT = 2,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Roles.FANTASY_ROLE_OFFLANE)
    FANTASY_ROLE_OFFLANE = 3,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Roles.FANTASY_ROLE_MID)
    FANTASY_ROLE_MID = 4,
}

impl ::protobuf::Enum for Fantasy_Roles {
    const NAME: &'static str = "Fantasy_Roles";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fantasy_Roles> {
        match value {
            0 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_UNDEFINED),
            1 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_CORE),
            2 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_SUPPORT),
            3 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_OFFLANE),
            4 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_MID),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Fantasy_Roles> {
        match str {
            "FANTASY_ROLE_UNDEFINED" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_UNDEFINED),
            "FANTASY_ROLE_CORE" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_CORE),
            "FANTASY_ROLE_SUPPORT" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_SUPPORT),
            "FANTASY_ROLE_OFFLANE" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_OFFLANE),
            "FANTASY_ROLE_MID" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_MID),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Fantasy_Roles] = &[
        Fantasy_Roles::FANTASY_ROLE_UNDEFINED,
        Fantasy_Roles::FANTASY_ROLE_CORE,
        Fantasy_Roles::FANTASY_ROLE_SUPPORT,
        Fantasy_Roles::FANTASY_ROLE_OFFLANE,
        Fantasy_Roles::FANTASY_ROLE_MID,
    ];
}

impl ::protobuf::EnumFull for Fantasy_Roles {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Fantasy_Roles").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Fantasy_Roles {
    fn default() -> Self {
        Fantasy_Roles::FANTASY_ROLE_UNDEFINED
    }
}

impl Fantasy_Roles {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Fantasy_Roles>("Fantasy_Roles")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.Fantasy_Team_Slots)
pub enum Fantasy_Team_Slots {
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Team_Slots.FANTASY_SLOT_NONE)
    FANTASY_SLOT_NONE = 0,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Team_Slots.FANTASY_SLOT_CORE)
    FANTASY_SLOT_CORE = 1,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Team_Slots.FANTASY_SLOT_SUPPORT)
    FANTASY_SLOT_SUPPORT = 2,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Team_Slots.FANTASY_SLOT_ANY)
    FANTASY_SLOT_ANY = 3,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Team_Slots.FANTASY_SLOT_BENCH)
    FANTASY_SLOT_BENCH = 4,
}

impl ::protobuf::Enum for Fantasy_Team_Slots {
    const NAME: &'static str = "Fantasy_Team_Slots";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fantasy_Team_Slots> {
        match value {
            0 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_NONE),
            1 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_CORE),
            2 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_SUPPORT),
            3 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_ANY),
            4 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_BENCH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Fantasy_Team_Slots> {
        match str {
            "FANTASY_SLOT_NONE" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_NONE),
            "FANTASY_SLOT_CORE" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_CORE),
            "FANTASY_SLOT_SUPPORT" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_SUPPORT),
            "FANTASY_SLOT_ANY" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_ANY),
            "FANTASY_SLOT_BENCH" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_BENCH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Fantasy_Team_Slots] = &[
        Fantasy_Team_Slots::FANTASY_SLOT_NONE,
        Fantasy_Team_Slots::FANTASY_SLOT_CORE,
        Fantasy_Team_Slots::FANTASY_SLOT_SUPPORT,
        Fantasy_Team_Slots::FANTASY_SLOT_ANY,
        Fantasy_Team_Slots::FANTASY_SLOT_BENCH,
    ];
}

impl ::protobuf::EnumFull for Fantasy_Team_Slots {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Fantasy_Team_Slots").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Fantasy_Team_Slots {
    fn default() -> Self {
        Fantasy_Team_Slots::FANTASY_SLOT_NONE
    }
}

impl Fantasy_Team_Slots {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Fantasy_Team_Slots>("Fantasy_Team_Slots")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.Fantasy_Selection_Mode)
pub enum Fantasy_Selection_Mode {
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_INVALID)
    FANTASY_SELECTION_INVALID = 0,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_LOCKED)
    FANTASY_SELECTION_LOCKED = 1,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_SHUFFLE)
    FANTASY_SELECTION_SHUFFLE = 2,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_FREE_PICK)
    FANTASY_SELECTION_FREE_PICK = 3,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_ENDED)
    FANTASY_SELECTION_ENDED = 4,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_PRE_SEASON)
    FANTASY_SELECTION_PRE_SEASON = 5,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_PRE_DRAFT)
    FANTASY_SELECTION_PRE_DRAFT = 6,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_DRAFTING)
    FANTASY_SELECTION_DRAFTING = 7,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_REGULAR_SEASON)
    FANTASY_SELECTION_REGULAR_SEASON = 8,
    // @@protoc_insertion_point(enum_value:dota.Fantasy_Selection_Mode.FANTASY_SELECTION_CARD_BASED)
    FANTASY_SELECTION_CARD_BASED = 9,
}

impl ::protobuf::Enum for Fantasy_Selection_Mode {
    const NAME: &'static str = "Fantasy_Selection_Mode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fantasy_Selection_Mode> {
        match value {
            0 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID),
            1 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_LOCKED),
            2 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_SHUFFLE),
            3 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_FREE_PICK),
            4 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_ENDED),
            5 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_SEASON),
            6 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_DRAFT),
            7 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_DRAFTING),
            8 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_REGULAR_SEASON),
            9 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_CARD_BASED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Fantasy_Selection_Mode> {
        match str {
            "FANTASY_SELECTION_INVALID" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID),
            "FANTASY_SELECTION_LOCKED" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_LOCKED),
            "FANTASY_SELECTION_SHUFFLE" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_SHUFFLE),
            "FANTASY_SELECTION_FREE_PICK" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_FREE_PICK),
            "FANTASY_SELECTION_ENDED" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_ENDED),
            "FANTASY_SELECTION_PRE_SEASON" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_SEASON),
            "FANTASY_SELECTION_PRE_DRAFT" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_DRAFT),
            "FANTASY_SELECTION_DRAFTING" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_DRAFTING),
            "FANTASY_SELECTION_REGULAR_SEASON" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_REGULAR_SEASON),
            "FANTASY_SELECTION_CARD_BASED" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_CARD_BASED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Fantasy_Selection_Mode] = &[
        Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID,
        Fantasy_Selection_Mode::FANTASY_SELECTION_LOCKED,
        Fantasy_Selection_Mode::FANTASY_SELECTION_SHUFFLE,
        Fantasy_Selection_Mode::FANTASY_SELECTION_FREE_PICK,
        Fantasy_Selection_Mode::FANTASY_SELECTION_ENDED,
        Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_SEASON,
        Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_DRAFT,
        Fantasy_Selection_Mode::FANTASY_SELECTION_DRAFTING,
        Fantasy_Selection_Mode::FANTASY_SELECTION_REGULAR_SEASON,
        Fantasy_Selection_Mode::FANTASY_SELECTION_CARD_BASED,
    ];
}

impl ::protobuf::EnumFull for Fantasy_Selection_Mode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Fantasy_Selection_Mode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Fantasy_Selection_Mode {
    fn default() -> Self {
        Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID
    }
}

impl Fantasy_Selection_Mode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Fantasy_Selection_Mode>("Fantasy_Selection_Mode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTAChatChannelType_t)
pub enum DOTAChatChannelType_t {
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Regional)
    DOTAChannelType_Regional = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Custom)
    DOTAChannelType_Custom = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Party)
    DOTAChannelType_Party = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Lobby)
    DOTAChannelType_Lobby = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Team)
    DOTAChannelType_Team = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Guild)
    DOTAChannelType_Guild = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Fantasy)
    DOTAChannelType_Fantasy = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Whisper)
    DOTAChannelType_Whisper = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Console)
    DOTAChannelType_Console = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Tab)
    DOTAChannelType_Tab = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Invalid)
    DOTAChannelType_Invalid = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_GameAll)
    DOTAChannelType_GameAll = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_GameAllies)
    DOTAChannelType_GameAllies = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_GameSpectator)
    DOTAChannelType_GameSpectator = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_GameCoaching)
    DOTAChannelType_GameCoaching = 14,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Cafe)
    DOTAChannelType_Cafe = 15,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_CustomGame)
    DOTAChannelType_CustomGame = 16,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Private)
    DOTAChannelType_Private = 17,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_PostGame)
    DOTAChannelType_PostGame = 18,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_BattleCup)
    DOTAChannelType_BattleCup = 19,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_HLTVSpectator)
    DOTAChannelType_HLTVSpectator = 20,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_GameEvents)
    DOTAChannelType_GameEvents = 21,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_Trivia)
    DOTAChannelType_Trivia = 22,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_NewPlayer)
    DOTAChannelType_NewPlayer = 23,
    // @@protoc_insertion_point(enum_value:dota.DOTAChatChannelType_t.DOTAChannelType_PrivateCoaching)
    DOTAChannelType_PrivateCoaching = 24,
}

impl ::protobuf::Enum for DOTAChatChannelType_t {
    const NAME: &'static str = "DOTAChatChannelType_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTAChatChannelType_t> {
        match value {
            0 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Regional),
            1 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Custom),
            2 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Party),
            3 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Lobby),
            4 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Team),
            5 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Guild),
            6 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Fantasy),
            7 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Whisper),
            8 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Console),
            9 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Tab),
            10 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Invalid),
            11 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameAll),
            12 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameAllies),
            13 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameSpectator),
            14 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameCoaching),
            15 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Cafe),
            16 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_CustomGame),
            17 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Private),
            18 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_PostGame),
            19 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_BattleCup),
            20 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_HLTVSpectator),
            21 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameEvents),
            22 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Trivia),
            23 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_NewPlayer),
            24 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_PrivateCoaching),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTAChatChannelType_t> {
        match str {
            "DOTAChannelType_Regional" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Regional),
            "DOTAChannelType_Custom" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Custom),
            "DOTAChannelType_Party" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Party),
            "DOTAChannelType_Lobby" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Lobby),
            "DOTAChannelType_Team" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Team),
            "DOTAChannelType_Guild" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Guild),
            "DOTAChannelType_Fantasy" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Fantasy),
            "DOTAChannelType_Whisper" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Whisper),
            "DOTAChannelType_Console" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Console),
            "DOTAChannelType_Tab" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Tab),
            "DOTAChannelType_Invalid" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Invalid),
            "DOTAChannelType_GameAll" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameAll),
            "DOTAChannelType_GameAllies" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameAllies),
            "DOTAChannelType_GameSpectator" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameSpectator),
            "DOTAChannelType_GameCoaching" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameCoaching),
            "DOTAChannelType_Cafe" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Cafe),
            "DOTAChannelType_CustomGame" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_CustomGame),
            "DOTAChannelType_Private" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Private),
            "DOTAChannelType_PostGame" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_PostGame),
            "DOTAChannelType_BattleCup" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_BattleCup),
            "DOTAChannelType_HLTVSpectator" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_HLTVSpectator),
            "DOTAChannelType_GameEvents" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameEvents),
            "DOTAChannelType_Trivia" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Trivia),
            "DOTAChannelType_NewPlayer" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_NewPlayer),
            "DOTAChannelType_PrivateCoaching" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_PrivateCoaching),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTAChatChannelType_t] = &[
        DOTAChatChannelType_t::DOTAChannelType_Regional,
        DOTAChatChannelType_t::DOTAChannelType_Custom,
        DOTAChatChannelType_t::DOTAChannelType_Party,
        DOTAChatChannelType_t::DOTAChannelType_Lobby,
        DOTAChatChannelType_t::DOTAChannelType_Team,
        DOTAChatChannelType_t::DOTAChannelType_Guild,
        DOTAChatChannelType_t::DOTAChannelType_Fantasy,
        DOTAChatChannelType_t::DOTAChannelType_Whisper,
        DOTAChatChannelType_t::DOTAChannelType_Console,
        DOTAChatChannelType_t::DOTAChannelType_Tab,
        DOTAChatChannelType_t::DOTAChannelType_Invalid,
        DOTAChatChannelType_t::DOTAChannelType_GameAll,
        DOTAChatChannelType_t::DOTAChannelType_GameAllies,
        DOTAChatChannelType_t::DOTAChannelType_GameSpectator,
        DOTAChatChannelType_t::DOTAChannelType_GameCoaching,
        DOTAChatChannelType_t::DOTAChannelType_Cafe,
        DOTAChatChannelType_t::DOTAChannelType_CustomGame,
        DOTAChatChannelType_t::DOTAChannelType_Private,
        DOTAChatChannelType_t::DOTAChannelType_PostGame,
        DOTAChatChannelType_t::DOTAChannelType_BattleCup,
        DOTAChatChannelType_t::DOTAChannelType_HLTVSpectator,
        DOTAChatChannelType_t::DOTAChannelType_GameEvents,
        DOTAChatChannelType_t::DOTAChannelType_Trivia,
        DOTAChatChannelType_t::DOTAChannelType_NewPlayer,
        DOTAChatChannelType_t::DOTAChannelType_PrivateCoaching,
    ];
}

impl ::protobuf::EnumFull for DOTAChatChannelType_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTAChatChannelType_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTAChatChannelType_t {
    fn default() -> Self {
        DOTAChatChannelType_t::DOTAChannelType_Regional
    }
}

impl DOTAChatChannelType_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTAChatChannelType_t>("DOTAChatChannelType_t")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EChatSpecialPrivileges)
pub enum EChatSpecialPrivileges {
    // @@protoc_insertion_point(enum_value:dota.EChatSpecialPrivileges.k_EChatSpecialPrivileges_None)
    k_EChatSpecialPrivileges_None = 0,
    // @@protoc_insertion_point(enum_value:dota.EChatSpecialPrivileges.k_EChatSpecialPrivileges_Moderator)
    k_EChatSpecialPrivileges_Moderator = 1,
    // @@protoc_insertion_point(enum_value:dota.EChatSpecialPrivileges.k_EChatSpecialPrivileges_SuperModerator)
    k_EChatSpecialPrivileges_SuperModerator = 2,
}

impl ::protobuf::Enum for EChatSpecialPrivileges {
    const NAME: &'static str = "EChatSpecialPrivileges";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatSpecialPrivileges> {
        match value {
            0 => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_None),
            1 => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_Moderator),
            2 => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_SuperModerator),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatSpecialPrivileges> {
        match str {
            "k_EChatSpecialPrivileges_None" => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_None),
            "k_EChatSpecialPrivileges_Moderator" => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_Moderator),
            "k_EChatSpecialPrivileges_SuperModerator" => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_SuperModerator),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatSpecialPrivileges] = &[
        EChatSpecialPrivileges::k_EChatSpecialPrivileges_None,
        EChatSpecialPrivileges::k_EChatSpecialPrivileges_Moderator,
        EChatSpecialPrivileges::k_EChatSpecialPrivileges_SuperModerator,
    ];
}

impl ::protobuf::EnumFull for EChatSpecialPrivileges {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatSpecialPrivileges").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatSpecialPrivileges {
    fn default() -> Self {
        EChatSpecialPrivileges::k_EChatSpecialPrivileges_None
    }
}

impl EChatSpecialPrivileges {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EChatSpecialPrivileges>("EChatSpecialPrivileges")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EProfileCardSlotType)
pub enum EProfileCardSlotType {
    // @@protoc_insertion_point(enum_value:dota.EProfileCardSlotType.k_EProfileCardSlotType_Empty)
    k_EProfileCardSlotType_Empty = 0,
    // @@protoc_insertion_point(enum_value:dota.EProfileCardSlotType.k_EProfileCardSlotType_Stat)
    k_EProfileCardSlotType_Stat = 1,
    // @@protoc_insertion_point(enum_value:dota.EProfileCardSlotType.k_EProfileCardSlotType_Trophy)
    k_EProfileCardSlotType_Trophy = 2,
    // @@protoc_insertion_point(enum_value:dota.EProfileCardSlotType.k_EProfileCardSlotType_Item)
    k_EProfileCardSlotType_Item = 3,
    // @@protoc_insertion_point(enum_value:dota.EProfileCardSlotType.k_EProfileCardSlotType_Hero)
    k_EProfileCardSlotType_Hero = 4,
    // @@protoc_insertion_point(enum_value:dota.EProfileCardSlotType.k_EProfileCardSlotType_Emoticon)
    k_EProfileCardSlotType_Emoticon = 5,
    // @@protoc_insertion_point(enum_value:dota.EProfileCardSlotType.k_EProfileCardSlotType_Team)
    k_EProfileCardSlotType_Team = 6,
}

impl ::protobuf::Enum for EProfileCardSlotType {
    const NAME: &'static str = "EProfileCardSlotType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProfileCardSlotType> {
        match value {
            0 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Empty),
            1 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Stat),
            2 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Trophy),
            3 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Item),
            4 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Hero),
            5 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Emoticon),
            6 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Team),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProfileCardSlotType> {
        match str {
            "k_EProfileCardSlotType_Empty" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Empty),
            "k_EProfileCardSlotType_Stat" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Stat),
            "k_EProfileCardSlotType_Trophy" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Trophy),
            "k_EProfileCardSlotType_Item" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Item),
            "k_EProfileCardSlotType_Hero" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Hero),
            "k_EProfileCardSlotType_Emoticon" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Emoticon),
            "k_EProfileCardSlotType_Team" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Team),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProfileCardSlotType] = &[
        EProfileCardSlotType::k_EProfileCardSlotType_Empty,
        EProfileCardSlotType::k_EProfileCardSlotType_Stat,
        EProfileCardSlotType::k_EProfileCardSlotType_Trophy,
        EProfileCardSlotType::k_EProfileCardSlotType_Item,
        EProfileCardSlotType::k_EProfileCardSlotType_Hero,
        EProfileCardSlotType::k_EProfileCardSlotType_Emoticon,
        EProfileCardSlotType::k_EProfileCardSlotType_Team,
    ];
}

impl ::protobuf::EnumFull for EProfileCardSlotType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EProfileCardSlotType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EProfileCardSlotType {
    fn default() -> Self {
        EProfileCardSlotType::k_EProfileCardSlotType_Empty
    }
}

impl EProfileCardSlotType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EProfileCardSlotType>("EProfileCardSlotType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EMatchGroupServerStatus)
pub enum EMatchGroupServerStatus {
    // @@protoc_insertion_point(enum_value:dota.EMatchGroupServerStatus.k_EMatchGroupServerStatus_OK)
    k_EMatchGroupServerStatus_OK = 0,
    // @@protoc_insertion_point(enum_value:dota.EMatchGroupServerStatus.k_EMatchGroupServerStatus_LimitedAvailability)
    k_EMatchGroupServerStatus_LimitedAvailability = 1,
    // @@protoc_insertion_point(enum_value:dota.EMatchGroupServerStatus.k_EMatchGroupServerStatus_Offline)
    k_EMatchGroupServerStatus_Offline = 2,
}

impl ::protobuf::Enum for EMatchGroupServerStatus {
    const NAME: &'static str = "EMatchGroupServerStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMatchGroupServerStatus> {
        match value {
            0 => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK),
            1 => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_LimitedAvailability),
            2 => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_Offline),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMatchGroupServerStatus> {
        match str {
            "k_EMatchGroupServerStatus_OK" => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK),
            "k_EMatchGroupServerStatus_LimitedAvailability" => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_LimitedAvailability),
            "k_EMatchGroupServerStatus_Offline" => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_Offline),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMatchGroupServerStatus] = &[
        EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK,
        EMatchGroupServerStatus::k_EMatchGroupServerStatus_LimitedAvailability,
        EMatchGroupServerStatus::k_EMatchGroupServerStatus_Offline,
    ];
}

impl ::protobuf::EnumFull for EMatchGroupServerStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EMatchGroupServerStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EMatchGroupServerStatus {
    fn default() -> Self {
        EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK
    }
}

impl EMatchGroupServerStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EMatchGroupServerStatus>("EMatchGroupServerStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_CM_PICK)
pub enum DOTA_CM_PICK {
    // @@protoc_insertion_point(enum_value:dota.DOTA_CM_PICK.DOTA_CM_RANDOM)
    DOTA_CM_RANDOM = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CM_PICK.DOTA_CM_GOOD_GUYS)
    DOTA_CM_GOOD_GUYS = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CM_PICK.DOTA_CM_BAD_GUYS)
    DOTA_CM_BAD_GUYS = 2,
}

impl ::protobuf::Enum for DOTA_CM_PICK {
    const NAME: &'static str = "DOTA_CM_PICK";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_CM_PICK> {
        match value {
            0 => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_RANDOM),
            1 => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_GOOD_GUYS),
            2 => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_BAD_GUYS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_CM_PICK> {
        match str {
            "DOTA_CM_RANDOM" => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_RANDOM),
            "DOTA_CM_GOOD_GUYS" => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_GOOD_GUYS),
            "DOTA_CM_BAD_GUYS" => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_BAD_GUYS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_CM_PICK] = &[
        DOTA_CM_PICK::DOTA_CM_RANDOM,
        DOTA_CM_PICK::DOTA_CM_GOOD_GUYS,
        DOTA_CM_PICK::DOTA_CM_BAD_GUYS,
    ];
}

impl ::protobuf::EnumFull for DOTA_CM_PICK {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_CM_PICK").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_CM_PICK {
    fn default() -> Self {
        DOTA_CM_PICK::DOTA_CM_RANDOM
    }
}

impl DOTA_CM_PICK {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_CM_PICK>("DOTA_CM_PICK")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTALowPriorityBanType)
pub enum DOTALowPriorityBanType {
    // @@protoc_insertion_point(enum_value:dota.DOTALowPriorityBanType.DOTA_LOW_PRIORITY_BAN_ABANDON)
    DOTA_LOW_PRIORITY_BAN_ABANDON = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTALowPriorityBanType.DOTA_LOW_PRIORITY_BAN_REPORTS)
    DOTA_LOW_PRIORITY_BAN_REPORTS = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTALowPriorityBanType.DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON)
    DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTALowPriorityBanType.DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE)
    DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE = 3,
}

impl ::protobuf::Enum for DOTALowPriorityBanType {
    const NAME: &'static str = "DOTALowPriorityBanType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTALowPriorityBanType> {
        match value {
            0 => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_ABANDON),
            1 => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_REPORTS),
            2 => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON),
            3 => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTALowPriorityBanType> {
        match str {
            "DOTA_LOW_PRIORITY_BAN_ABANDON" => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_ABANDON),
            "DOTA_LOW_PRIORITY_BAN_REPORTS" => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_REPORTS),
            "DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON" => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON),
            "DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE" => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTALowPriorityBanType] = &[
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_ABANDON,
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_REPORTS,
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON,
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE,
    ];
}

impl ::protobuf::EnumFull for DOTALowPriorityBanType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTALowPriorityBanType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTALowPriorityBanType {
    fn default() -> Self {
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_ABANDON
    }
}

impl DOTALowPriorityBanType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTALowPriorityBanType>("DOTALowPriorityBanType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTALobbyReadyState)
pub enum DOTALobbyReadyState {
    // @@protoc_insertion_point(enum_value:dota.DOTALobbyReadyState.DOTALobbyReadyState_UNDECLARED)
    DOTALobbyReadyState_UNDECLARED = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTALobbyReadyState.DOTALobbyReadyState_ACCEPTED)
    DOTALobbyReadyState_ACCEPTED = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTALobbyReadyState.DOTALobbyReadyState_DECLINED)
    DOTALobbyReadyState_DECLINED = 2,
}

impl ::protobuf::Enum for DOTALobbyReadyState {
    const NAME: &'static str = "DOTALobbyReadyState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTALobbyReadyState> {
        match value {
            0 => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED),
            1 => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_ACCEPTED),
            2 => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_DECLINED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTALobbyReadyState> {
        match str {
            "DOTALobbyReadyState_UNDECLARED" => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED),
            "DOTALobbyReadyState_ACCEPTED" => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_ACCEPTED),
            "DOTALobbyReadyState_DECLINED" => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_DECLINED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTALobbyReadyState] = &[
        DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED,
        DOTALobbyReadyState::DOTALobbyReadyState_ACCEPTED,
        DOTALobbyReadyState::DOTALobbyReadyState_DECLINED,
    ];
}

impl ::protobuf::EnumFull for DOTALobbyReadyState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTALobbyReadyState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTALobbyReadyState {
    fn default() -> Self {
        DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED
    }
}

impl DOTALobbyReadyState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTALobbyReadyState>("DOTALobbyReadyState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTAJoinLobbyResult)
pub enum DOTAJoinLobbyResult {
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_SUCCESS)
    DOTA_JOIN_RESULT_SUCCESS = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_ALREADY_IN_GAME)
    DOTA_JOIN_RESULT_ALREADY_IN_GAME = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_INVALID_LOBBY)
    DOTA_JOIN_RESULT_INVALID_LOBBY = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_INCORRECT_PASSWORD)
    DOTA_JOIN_RESULT_INCORRECT_PASSWORD = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_ACCESS_DENIED)
    DOTA_JOIN_RESULT_ACCESS_DENIED = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_GENERIC_ERROR)
    DOTA_JOIN_RESULT_GENERIC_ERROR = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_INCORRECT_VERSION)
    DOTA_JOIN_RESULT_INCORRECT_VERSION = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_IN_TEAM_PARTY)
    DOTA_JOIN_RESULT_IN_TEAM_PARTY = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_NO_LOBBY_FOUND)
    DOTA_JOIN_RESULT_NO_LOBBY_FOUND = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_LOBBY_FULL)
    DOTA_JOIN_RESULT_LOBBY_FULL = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION)
    DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_TIMEOUT)
    DOTA_JOIN_RESULT_TIMEOUT = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN)
    DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_BUSY)
    DOTA_JOIN_RESULT_BUSY = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTAJoinLobbyResult.DOTA_JOIN_RESULT_NO_PLAYTIME)
    DOTA_JOIN_RESULT_NO_PLAYTIME = 14,
}

impl ::protobuf::Enum for DOTAJoinLobbyResult {
    const NAME: &'static str = "DOTAJoinLobbyResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTAJoinLobbyResult> {
        match value {
            0 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS),
            1 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ALREADY_IN_GAME),
            2 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INVALID_LOBBY),
            3 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_PASSWORD),
            4 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ACCESS_DENIED),
            5 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_GENERIC_ERROR),
            6 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_VERSION),
            7 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_IN_TEAM_PARTY),
            8 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_LOBBY_FOUND),
            9 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_LOBBY_FULL),
            10 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION),
            11 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_TIMEOUT),
            12 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN),
            13 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_BUSY),
            14 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_PLAYTIME),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTAJoinLobbyResult> {
        match str {
            "DOTA_JOIN_RESULT_SUCCESS" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS),
            "DOTA_JOIN_RESULT_ALREADY_IN_GAME" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ALREADY_IN_GAME),
            "DOTA_JOIN_RESULT_INVALID_LOBBY" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INVALID_LOBBY),
            "DOTA_JOIN_RESULT_INCORRECT_PASSWORD" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_PASSWORD),
            "DOTA_JOIN_RESULT_ACCESS_DENIED" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ACCESS_DENIED),
            "DOTA_JOIN_RESULT_GENERIC_ERROR" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_GENERIC_ERROR),
            "DOTA_JOIN_RESULT_INCORRECT_VERSION" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_VERSION),
            "DOTA_JOIN_RESULT_IN_TEAM_PARTY" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_IN_TEAM_PARTY),
            "DOTA_JOIN_RESULT_NO_LOBBY_FOUND" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_LOBBY_FOUND),
            "DOTA_JOIN_RESULT_LOBBY_FULL" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_LOBBY_FULL),
            "DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION),
            "DOTA_JOIN_RESULT_TIMEOUT" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_TIMEOUT),
            "DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN),
            "DOTA_JOIN_RESULT_BUSY" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_BUSY),
            "DOTA_JOIN_RESULT_NO_PLAYTIME" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_PLAYTIME),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTAJoinLobbyResult] = &[
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ALREADY_IN_GAME,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INVALID_LOBBY,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_PASSWORD,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ACCESS_DENIED,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_GENERIC_ERROR,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_VERSION,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_IN_TEAM_PARTY,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_LOBBY_FOUND,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_LOBBY_FULL,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_TIMEOUT,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_BUSY,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_PLAYTIME,
    ];
}

impl ::protobuf::EnumFull for DOTAJoinLobbyResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTAJoinLobbyResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTAJoinLobbyResult {
    fn default() -> Self {
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS
    }
}

impl DOTAJoinLobbyResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTAJoinLobbyResult>("DOTAJoinLobbyResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTASelectionPriorityRules)
pub enum DOTASelectionPriorityRules {
    // @@protoc_insertion_point(enum_value:dota.DOTASelectionPriorityRules.k_DOTASelectionPriorityRules_Manual)
    k_DOTASelectionPriorityRules_Manual = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTASelectionPriorityRules.k_DOTASelectionPriorityRules_Automatic)
    k_DOTASelectionPriorityRules_Automatic = 1,
}

impl ::protobuf::Enum for DOTASelectionPriorityRules {
    const NAME: &'static str = "DOTASelectionPriorityRules";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTASelectionPriorityRules> {
        match value {
            0 => ::std::option::Option::Some(DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual),
            1 => ::std::option::Option::Some(DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Automatic),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTASelectionPriorityRules> {
        match str {
            "k_DOTASelectionPriorityRules_Manual" => ::std::option::Option::Some(DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual),
            "k_DOTASelectionPriorityRules_Automatic" => ::std::option::Option::Some(DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Automatic),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTASelectionPriorityRules] = &[
        DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual,
        DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Automatic,
    ];
}

impl ::protobuf::EnumFull for DOTASelectionPriorityRules {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTASelectionPriorityRules").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTASelectionPriorityRules {
    fn default() -> Self {
        DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual
    }
}

impl DOTASelectionPriorityRules {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTASelectionPriorityRules>("DOTASelectionPriorityRules")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTASelectionPriorityChoice)
pub enum DOTASelectionPriorityChoice {
    // @@protoc_insertion_point(enum_value:dota.DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_Invalid)
    k_DOTASelectionPriorityChoice_Invalid = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_FirstPick)
    k_DOTASelectionPriorityChoice_FirstPick = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_SecondPick)
    k_DOTASelectionPriorityChoice_SecondPick = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_Radiant)
    k_DOTASelectionPriorityChoice_Radiant = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_Dire)
    k_DOTASelectionPriorityChoice_Dire = 4,
}

impl ::protobuf::Enum for DOTASelectionPriorityChoice {
    const NAME: &'static str = "DOTASelectionPriorityChoice";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTASelectionPriorityChoice> {
        match value {
            0 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid),
            1 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_FirstPick),
            2 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_SecondPick),
            3 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Radiant),
            4 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Dire),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTASelectionPriorityChoice> {
        match str {
            "k_DOTASelectionPriorityChoice_Invalid" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid),
            "k_DOTASelectionPriorityChoice_FirstPick" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_FirstPick),
            "k_DOTASelectionPriorityChoice_SecondPick" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_SecondPick),
            "k_DOTASelectionPriorityChoice_Radiant" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Radiant),
            "k_DOTASelectionPriorityChoice_Dire" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Dire),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTASelectionPriorityChoice] = &[
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid,
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_FirstPick,
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_SecondPick,
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Radiant,
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Dire,
    ];
}

impl ::protobuf::EnumFull for DOTASelectionPriorityChoice {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTASelectionPriorityChoice").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTASelectionPriorityChoice {
    fn default() -> Self {
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid
    }
}

impl DOTASelectionPriorityChoice {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTASelectionPriorityChoice>("DOTASelectionPriorityChoice")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTAMatchVote)
pub enum DOTAMatchVote {
    // @@protoc_insertion_point(enum_value:dota.DOTAMatchVote.DOTAMatchVote_INVALID)
    DOTAMatchVote_INVALID = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTAMatchVote.DOTAMatchVote_POSITIVE)
    DOTAMatchVote_POSITIVE = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTAMatchVote.DOTAMatchVote_NEGATIVE)
    DOTAMatchVote_NEGATIVE = 2,
}

impl ::protobuf::Enum for DOTAMatchVote {
    const NAME: &'static str = "DOTAMatchVote";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTAMatchVote> {
        match value {
            0 => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_INVALID),
            1 => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_POSITIVE),
            2 => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_NEGATIVE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTAMatchVote> {
        match str {
            "DOTAMatchVote_INVALID" => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_INVALID),
            "DOTAMatchVote_POSITIVE" => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_POSITIVE),
            "DOTAMatchVote_NEGATIVE" => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_NEGATIVE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTAMatchVote] = &[
        DOTAMatchVote::DOTAMatchVote_INVALID,
        DOTAMatchVote::DOTAMatchVote_POSITIVE,
        DOTAMatchVote::DOTAMatchVote_NEGATIVE,
    ];
}

impl ::protobuf::EnumFull for DOTAMatchVote {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTAMatchVote").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTAMatchVote {
    fn default() -> Self {
        DOTAMatchVote::DOTAMatchVote_INVALID
    }
}

impl DOTAMatchVote {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTAMatchVote>("DOTAMatchVote")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTALobbyVisibility)
pub enum DOTALobbyVisibility {
    // @@protoc_insertion_point(enum_value:dota.DOTALobbyVisibility.DOTALobbyVisibility_Public)
    DOTALobbyVisibility_Public = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTALobbyVisibility.DOTALobbyVisibility_Friends)
    DOTALobbyVisibility_Friends = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTALobbyVisibility.DOTALobbyVisibility_Unlisted)
    DOTALobbyVisibility_Unlisted = 2,
}

impl ::protobuf::Enum for DOTALobbyVisibility {
    const NAME: &'static str = "DOTALobbyVisibility";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTALobbyVisibility> {
        match value {
            0 => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Public),
            1 => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Friends),
            2 => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Unlisted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTALobbyVisibility> {
        match str {
            "DOTALobbyVisibility_Public" => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Public),
            "DOTALobbyVisibility_Friends" => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Friends),
            "DOTALobbyVisibility_Unlisted" => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Unlisted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTALobbyVisibility] = &[
        DOTALobbyVisibility::DOTALobbyVisibility_Public,
        DOTALobbyVisibility::DOTALobbyVisibility_Friends,
        DOTALobbyVisibility::DOTALobbyVisibility_Unlisted,
    ];
}

impl ::protobuf::EnumFull for DOTALobbyVisibility {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTALobbyVisibility").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTALobbyVisibility {
    fn default() -> Self {
        DOTALobbyVisibility::DOTALobbyVisibility_Public
    }
}

impl DOTALobbyVisibility {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTALobbyVisibility>("DOTALobbyVisibility")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDOTAPlayerMMRType)
pub enum EDOTAPlayerMMRType {
    // @@protoc_insertion_point(enum_value:dota.EDOTAPlayerMMRType.k_EDOTAPlayerMMRType_Invalid)
    k_EDOTAPlayerMMRType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:dota.EDOTAPlayerMMRType.k_EDOTAPlayerMMRType_GeneralHidden)
    k_EDOTAPlayerMMRType_GeneralHidden = 1,
    // @@protoc_insertion_point(enum_value:dota.EDOTAPlayerMMRType.k_EDOTAPlayerMMRType_GeneralCompetitive)
    k_EDOTAPlayerMMRType_GeneralCompetitive = 3,
}

impl ::protobuf::Enum for EDOTAPlayerMMRType {
    const NAME: &'static str = "EDOTAPlayerMMRType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAPlayerMMRType> {
        match value {
            0 => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_Invalid),
            1 => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralHidden),
            3 => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralCompetitive),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTAPlayerMMRType> {
        match str {
            "k_EDOTAPlayerMMRType_Invalid" => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_Invalid),
            "k_EDOTAPlayerMMRType_GeneralHidden" => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralHidden),
            "k_EDOTAPlayerMMRType_GeneralCompetitive" => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralCompetitive),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTAPlayerMMRType] = &[
        EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_Invalid,
        EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralHidden,
        EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralCompetitive,
    ];
}

impl ::protobuf::EnumFull for EDOTAPlayerMMRType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDOTAPlayerMMRType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_Invalid => 0,
            EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralHidden => 1,
            EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralCompetitive => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EDOTAPlayerMMRType {
    fn default() -> Self {
        EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_Invalid
    }
}

impl EDOTAPlayerMMRType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDOTAPlayerMMRType>("EDOTAPlayerMMRType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDOTAMMRBoostType)
pub enum EDOTAMMRBoostType {
    // @@protoc_insertion_point(enum_value:dota.EDOTAMMRBoostType.k_EDOTAMMRBoostType_None)
    k_EDOTAMMRBoostType_None = 0,
    // @@protoc_insertion_point(enum_value:dota.EDOTAMMRBoostType.k_EDOTAMMRBoostType_Leader)
    k_EDOTAMMRBoostType_Leader = 1,
    // @@protoc_insertion_point(enum_value:dota.EDOTAMMRBoostType.k_EDOTAMMRBoostType_Follower)
    k_EDOTAMMRBoostType_Follower = 2,
}

impl ::protobuf::Enum for EDOTAMMRBoostType {
    const NAME: &'static str = "EDOTAMMRBoostType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAMMRBoostType> {
        match value {
            0 => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_None),
            1 => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_Leader),
            2 => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_Follower),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTAMMRBoostType> {
        match str {
            "k_EDOTAMMRBoostType_None" => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_None),
            "k_EDOTAMMRBoostType_Leader" => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_Leader),
            "k_EDOTAMMRBoostType_Follower" => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_Follower),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTAMMRBoostType] = &[
        EDOTAMMRBoostType::k_EDOTAMMRBoostType_None,
        EDOTAMMRBoostType::k_EDOTAMMRBoostType_Leader,
        EDOTAMMRBoostType::k_EDOTAMMRBoostType_Follower,
    ];
}

impl ::protobuf::EnumFull for EDOTAMMRBoostType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDOTAMMRBoostType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EDOTAMMRBoostType {
    fn default() -> Self {
        EDOTAMMRBoostType::k_EDOTAMMRBoostType_None
    }
}

impl EDOTAMMRBoostType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDOTAMMRBoostType>("EDOTAMMRBoostType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.MatchType)
pub enum MatchType {
    // @@protoc_insertion_point(enum_value:dota.MatchType.MATCH_TYPE_CASUAL)
    MATCH_TYPE_CASUAL = 0,
    // @@protoc_insertion_point(enum_value:dota.MatchType.MATCH_TYPE_COOP_BOTS)
    MATCH_TYPE_COOP_BOTS = 1,
    // @@protoc_insertion_point(enum_value:dota.MatchType.MATCH_TYPE_COMPETITIVE)
    MATCH_TYPE_COMPETITIVE = 4,
    // @@protoc_insertion_point(enum_value:dota.MatchType.MATCH_TYPE_WEEKEND_TOURNEY)
    MATCH_TYPE_WEEKEND_TOURNEY = 5,
    // @@protoc_insertion_point(enum_value:dota.MatchType.MATCH_TYPE_EVENT)
    MATCH_TYPE_EVENT = 7,
    // @@protoc_insertion_point(enum_value:dota.MatchType.MATCH_TYPE_COACHES_CHALLENGE)
    MATCH_TYPE_COACHES_CHALLENGE = 12,
    // @@protoc_insertion_point(enum_value:dota.MatchType.MATCH_TYPE_NEW_PLAYER_POOL)
    MATCH_TYPE_NEW_PLAYER_POOL = 14,
}

impl ::protobuf::Enum for MatchType {
    const NAME: &'static str = "MatchType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchType> {
        match value {
            0 => ::std::option::Option::Some(MatchType::MATCH_TYPE_CASUAL),
            1 => ::std::option::Option::Some(MatchType::MATCH_TYPE_COOP_BOTS),
            4 => ::std::option::Option::Some(MatchType::MATCH_TYPE_COMPETITIVE),
            5 => ::std::option::Option::Some(MatchType::MATCH_TYPE_WEEKEND_TOURNEY),
            7 => ::std::option::Option::Some(MatchType::MATCH_TYPE_EVENT),
            12 => ::std::option::Option::Some(MatchType::MATCH_TYPE_COACHES_CHALLENGE),
            14 => ::std::option::Option::Some(MatchType::MATCH_TYPE_NEW_PLAYER_POOL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MatchType> {
        match str {
            "MATCH_TYPE_CASUAL" => ::std::option::Option::Some(MatchType::MATCH_TYPE_CASUAL),
            "MATCH_TYPE_COOP_BOTS" => ::std::option::Option::Some(MatchType::MATCH_TYPE_COOP_BOTS),
            "MATCH_TYPE_COMPETITIVE" => ::std::option::Option::Some(MatchType::MATCH_TYPE_COMPETITIVE),
            "MATCH_TYPE_WEEKEND_TOURNEY" => ::std::option::Option::Some(MatchType::MATCH_TYPE_WEEKEND_TOURNEY),
            "MATCH_TYPE_EVENT" => ::std::option::Option::Some(MatchType::MATCH_TYPE_EVENT),
            "MATCH_TYPE_COACHES_CHALLENGE" => ::std::option::Option::Some(MatchType::MATCH_TYPE_COACHES_CHALLENGE),
            "MATCH_TYPE_NEW_PLAYER_POOL" => ::std::option::Option::Some(MatchType::MATCH_TYPE_NEW_PLAYER_POOL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MatchType] = &[
        MatchType::MATCH_TYPE_CASUAL,
        MatchType::MATCH_TYPE_COOP_BOTS,
        MatchType::MATCH_TYPE_COMPETITIVE,
        MatchType::MATCH_TYPE_WEEKEND_TOURNEY,
        MatchType::MATCH_TYPE_EVENT,
        MatchType::MATCH_TYPE_COACHES_CHALLENGE,
        MatchType::MATCH_TYPE_NEW_PLAYER_POOL,
    ];
}

impl ::protobuf::EnumFull for MatchType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MatchType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MatchType::MATCH_TYPE_CASUAL => 0,
            MatchType::MATCH_TYPE_COOP_BOTS => 1,
            MatchType::MATCH_TYPE_COMPETITIVE => 2,
            MatchType::MATCH_TYPE_WEEKEND_TOURNEY => 3,
            MatchType::MATCH_TYPE_EVENT => 4,
            MatchType::MATCH_TYPE_COACHES_CHALLENGE => 5,
            MatchType::MATCH_TYPE_NEW_PLAYER_POOL => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MatchType {
    fn default() -> Self {
        MatchType::MATCH_TYPE_CASUAL
    }
}

impl MatchType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MatchType>("MatchType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTABotDifficulty)
pub enum DOTABotDifficulty {
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_PASSIVE)
    BOT_DIFFICULTY_PASSIVE = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_EASY)
    BOT_DIFFICULTY_EASY = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_MEDIUM)
    BOT_DIFFICULTY_MEDIUM = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_HARD)
    BOT_DIFFICULTY_HARD = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_UNFAIR)
    BOT_DIFFICULTY_UNFAIR = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_INVALID)
    BOT_DIFFICULTY_INVALID = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_EXTRA1)
    BOT_DIFFICULTY_EXTRA1 = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_EXTRA2)
    BOT_DIFFICULTY_EXTRA2 = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_EXTRA3)
    BOT_DIFFICULTY_EXTRA3 = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTABotDifficulty.BOT_DIFFICULTY_NPX)
    BOT_DIFFICULTY_NPX = 9,
}

impl ::protobuf::Enum for DOTABotDifficulty {
    const NAME: &'static str = "DOTABotDifficulty";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTABotDifficulty> {
        match value {
            0 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            1 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EASY),
            2 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_MEDIUM),
            3 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_HARD),
            4 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_UNFAIR),
            5 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_INVALID),
            6 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA1),
            7 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA2),
            8 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA3),
            9 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_NPX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTABotDifficulty> {
        match str {
            "BOT_DIFFICULTY_PASSIVE" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            "BOT_DIFFICULTY_EASY" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EASY),
            "BOT_DIFFICULTY_MEDIUM" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_MEDIUM),
            "BOT_DIFFICULTY_HARD" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_HARD),
            "BOT_DIFFICULTY_UNFAIR" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_UNFAIR),
            "BOT_DIFFICULTY_INVALID" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_INVALID),
            "BOT_DIFFICULTY_EXTRA1" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA1),
            "BOT_DIFFICULTY_EXTRA2" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA2),
            "BOT_DIFFICULTY_EXTRA3" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA3),
            "BOT_DIFFICULTY_NPX" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_NPX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTABotDifficulty] = &[
        DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        DOTABotDifficulty::BOT_DIFFICULTY_EASY,
        DOTABotDifficulty::BOT_DIFFICULTY_MEDIUM,
        DOTABotDifficulty::BOT_DIFFICULTY_HARD,
        DOTABotDifficulty::BOT_DIFFICULTY_UNFAIR,
        DOTABotDifficulty::BOT_DIFFICULTY_INVALID,
        DOTABotDifficulty::BOT_DIFFICULTY_EXTRA1,
        DOTABotDifficulty::BOT_DIFFICULTY_EXTRA2,
        DOTABotDifficulty::BOT_DIFFICULTY_EXTRA3,
        DOTABotDifficulty::BOT_DIFFICULTY_NPX,
    ];
}

impl ::protobuf::EnumFull for DOTABotDifficulty {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTABotDifficulty").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTABotDifficulty {
    fn default() -> Self {
        DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE
    }
}

impl DOTABotDifficulty {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTABotDifficulty>("DOTABotDifficulty")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_BOT_MODE)
pub enum DOTA_BOT_MODE {
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_NONE)
    DOTA_BOT_MODE_NONE = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_LANING)
    DOTA_BOT_MODE_LANING = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_ATTACK)
    DOTA_BOT_MODE_ATTACK = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_ROAM)
    DOTA_BOT_MODE_ROAM = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_RETREAT)
    DOTA_BOT_MODE_RETREAT = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_SECRET_SHOP)
    DOTA_BOT_MODE_SECRET_SHOP = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_SIDE_SHOP)
    DOTA_BOT_MODE_SIDE_SHOP = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_RUNE)
    DOTA_BOT_MODE_RUNE = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_PUSH_TOWER_TOP)
    DOTA_BOT_MODE_PUSH_TOWER_TOP = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_PUSH_TOWER_MID)
    DOTA_BOT_MODE_PUSH_TOWER_MID = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_PUSH_TOWER_BOT)
    DOTA_BOT_MODE_PUSH_TOWER_BOT = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_DEFEND_TOWER_TOP)
    DOTA_BOT_MODE_DEFEND_TOWER_TOP = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_DEFEND_TOWER_MID)
    DOTA_BOT_MODE_DEFEND_TOWER_MID = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_DEFEND_TOWER_BOT)
    DOTA_BOT_MODE_DEFEND_TOWER_BOT = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_ASSEMBLE)
    DOTA_BOT_MODE_ASSEMBLE = 14,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS)
    DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS = 15,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_TEAM_ROAM)
    DOTA_BOT_MODE_TEAM_ROAM = 16,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_FARM)
    DOTA_BOT_MODE_FARM = 17,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_DEFEND_ALLY)
    DOTA_BOT_MODE_DEFEND_ALLY = 18,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_EVASIVE_MANEUVERS)
    DOTA_BOT_MODE_EVASIVE_MANEUVERS = 19,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_ROSHAN)
    DOTA_BOT_MODE_ROSHAN = 20,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_ITEM)
    DOTA_BOT_MODE_ITEM = 21,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_WARD)
    DOTA_BOT_MODE_WARD = 22,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_COMPANION)
    DOTA_BOT_MODE_COMPANION = 23,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_TUTORIAL_BOSS)
    DOTA_BOT_MODE_TUTORIAL_BOSS = 24,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_MINION)
    DOTA_BOT_MODE_MINION = 25,
    // @@protoc_insertion_point(enum_value:dota.DOTA_BOT_MODE.DOTA_BOT_MODE_OUTPOST)
    DOTA_BOT_MODE_OUTPOST = 26,
}

impl ::protobuf::Enum for DOTA_BOT_MODE {
    const NAME: &'static str = "DOTA_BOT_MODE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_BOT_MODE> {
        match value {
            0 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_NONE),
            1 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_LANING),
            2 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ATTACK),
            3 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ROAM),
            4 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_RETREAT),
            5 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_SECRET_SHOP),
            6 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_SIDE_SHOP),
            7 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_RUNE),
            8 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_TOP),
            9 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_MID),
            10 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_BOT),
            11 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_TOP),
            12 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_MID),
            13 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_BOT),
            14 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE),
            15 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS),
            16 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_TEAM_ROAM),
            17 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_FARM),
            18 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_ALLY),
            19 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_EVASIVE_MANEUVERS),
            20 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ROSHAN),
            21 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ITEM),
            22 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_WARD),
            23 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_COMPANION),
            24 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_TUTORIAL_BOSS),
            25 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_MINION),
            26 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_OUTPOST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_BOT_MODE> {
        match str {
            "DOTA_BOT_MODE_NONE" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_NONE),
            "DOTA_BOT_MODE_LANING" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_LANING),
            "DOTA_BOT_MODE_ATTACK" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ATTACK),
            "DOTA_BOT_MODE_ROAM" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ROAM),
            "DOTA_BOT_MODE_RETREAT" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_RETREAT),
            "DOTA_BOT_MODE_SECRET_SHOP" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_SECRET_SHOP),
            "DOTA_BOT_MODE_SIDE_SHOP" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_SIDE_SHOP),
            "DOTA_BOT_MODE_RUNE" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_RUNE),
            "DOTA_BOT_MODE_PUSH_TOWER_TOP" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_TOP),
            "DOTA_BOT_MODE_PUSH_TOWER_MID" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_MID),
            "DOTA_BOT_MODE_PUSH_TOWER_BOT" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_BOT),
            "DOTA_BOT_MODE_DEFEND_TOWER_TOP" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_TOP),
            "DOTA_BOT_MODE_DEFEND_TOWER_MID" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_MID),
            "DOTA_BOT_MODE_DEFEND_TOWER_BOT" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_BOT),
            "DOTA_BOT_MODE_ASSEMBLE" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE),
            "DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS),
            "DOTA_BOT_MODE_TEAM_ROAM" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_TEAM_ROAM),
            "DOTA_BOT_MODE_FARM" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_FARM),
            "DOTA_BOT_MODE_DEFEND_ALLY" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_ALLY),
            "DOTA_BOT_MODE_EVASIVE_MANEUVERS" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_EVASIVE_MANEUVERS),
            "DOTA_BOT_MODE_ROSHAN" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ROSHAN),
            "DOTA_BOT_MODE_ITEM" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ITEM),
            "DOTA_BOT_MODE_WARD" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_WARD),
            "DOTA_BOT_MODE_COMPANION" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_COMPANION),
            "DOTA_BOT_MODE_TUTORIAL_BOSS" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_TUTORIAL_BOSS),
            "DOTA_BOT_MODE_MINION" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_MINION),
            "DOTA_BOT_MODE_OUTPOST" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_OUTPOST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_BOT_MODE] = &[
        DOTA_BOT_MODE::DOTA_BOT_MODE_NONE,
        DOTA_BOT_MODE::DOTA_BOT_MODE_LANING,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ATTACK,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ROAM,
        DOTA_BOT_MODE::DOTA_BOT_MODE_RETREAT,
        DOTA_BOT_MODE::DOTA_BOT_MODE_SECRET_SHOP,
        DOTA_BOT_MODE::DOTA_BOT_MODE_SIDE_SHOP,
        DOTA_BOT_MODE::DOTA_BOT_MODE_RUNE,
        DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_TOP,
        DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_MID,
        DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_BOT,
        DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_TOP,
        DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_MID,
        DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_BOT,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS,
        DOTA_BOT_MODE::DOTA_BOT_MODE_TEAM_ROAM,
        DOTA_BOT_MODE::DOTA_BOT_MODE_FARM,
        DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_ALLY,
        DOTA_BOT_MODE::DOTA_BOT_MODE_EVASIVE_MANEUVERS,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ROSHAN,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ITEM,
        DOTA_BOT_MODE::DOTA_BOT_MODE_WARD,
        DOTA_BOT_MODE::DOTA_BOT_MODE_COMPANION,
        DOTA_BOT_MODE::DOTA_BOT_MODE_TUTORIAL_BOSS,
        DOTA_BOT_MODE::DOTA_BOT_MODE_MINION,
        DOTA_BOT_MODE::DOTA_BOT_MODE_OUTPOST,
    ];
}

impl ::protobuf::EnumFull for DOTA_BOT_MODE {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_BOT_MODE").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_BOT_MODE {
    fn default() -> Self {
        DOTA_BOT_MODE::DOTA_BOT_MODE_NONE
    }
}

impl DOTA_BOT_MODE {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_BOT_MODE>("DOTA_BOT_MODE")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.MatchLanguages)
pub enum MatchLanguages {
    // @@protoc_insertion_point(enum_value:dota.MatchLanguages.MATCH_LANGUAGE_INVALID)
    MATCH_LANGUAGE_INVALID = 0,
    // @@protoc_insertion_point(enum_value:dota.MatchLanguages.MATCH_LANGUAGE_ENGLISH)
    MATCH_LANGUAGE_ENGLISH = 1,
    // @@protoc_insertion_point(enum_value:dota.MatchLanguages.MATCH_LANGUAGE_RUSSIAN)
    MATCH_LANGUAGE_RUSSIAN = 2,
    // @@protoc_insertion_point(enum_value:dota.MatchLanguages.MATCH_LANGUAGE_CHINESE)
    MATCH_LANGUAGE_CHINESE = 3,
    // @@protoc_insertion_point(enum_value:dota.MatchLanguages.MATCH_LANGUAGE_KOREAN)
    MATCH_LANGUAGE_KOREAN = 4,
    // @@protoc_insertion_point(enum_value:dota.MatchLanguages.MATCH_LANGUAGE_SPANISH)
    MATCH_LANGUAGE_SPANISH = 5,
    // @@protoc_insertion_point(enum_value:dota.MatchLanguages.MATCH_LANGUAGE_PORTUGUESE)
    MATCH_LANGUAGE_PORTUGUESE = 6,
    // @@protoc_insertion_point(enum_value:dota.MatchLanguages.MATCH_LANGUAGE_ENGLISH2)
    MATCH_LANGUAGE_ENGLISH2 = 7,
}

impl ::protobuf::Enum for MatchLanguages {
    const NAME: &'static str = "MatchLanguages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchLanguages> {
        match value {
            0 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_INVALID),
            1 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_ENGLISH),
            2 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_RUSSIAN),
            3 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_CHINESE),
            4 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_KOREAN),
            5 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_SPANISH),
            6 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_PORTUGUESE),
            7 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_ENGLISH2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MatchLanguages> {
        match str {
            "MATCH_LANGUAGE_INVALID" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_INVALID),
            "MATCH_LANGUAGE_ENGLISH" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_ENGLISH),
            "MATCH_LANGUAGE_RUSSIAN" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_RUSSIAN),
            "MATCH_LANGUAGE_CHINESE" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_CHINESE),
            "MATCH_LANGUAGE_KOREAN" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_KOREAN),
            "MATCH_LANGUAGE_SPANISH" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_SPANISH),
            "MATCH_LANGUAGE_PORTUGUESE" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_PORTUGUESE),
            "MATCH_LANGUAGE_ENGLISH2" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_ENGLISH2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MatchLanguages] = &[
        MatchLanguages::MATCH_LANGUAGE_INVALID,
        MatchLanguages::MATCH_LANGUAGE_ENGLISH,
        MatchLanguages::MATCH_LANGUAGE_RUSSIAN,
        MatchLanguages::MATCH_LANGUAGE_CHINESE,
        MatchLanguages::MATCH_LANGUAGE_KOREAN,
        MatchLanguages::MATCH_LANGUAGE_SPANISH,
        MatchLanguages::MATCH_LANGUAGE_PORTUGUESE,
        MatchLanguages::MATCH_LANGUAGE_ENGLISH2,
    ];
}

impl ::protobuf::EnumFull for MatchLanguages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MatchLanguages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MatchLanguages {
    fn default() -> Self {
        MatchLanguages::MATCH_LANGUAGE_INVALID
    }
}

impl MatchLanguages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MatchLanguages>("MatchLanguages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ETourneyQueueDeadlineState)
pub enum ETourneyQueueDeadlineState {
    // @@protoc_insertion_point(enum_value:dota.ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_Normal)
    k_ETourneyQueueDeadlineState_Normal = 0,
    // @@protoc_insertion_point(enum_value:dota.ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_Missed)
    k_ETourneyQueueDeadlineState_Missed = 1,
    // @@protoc_insertion_point(enum_value:dota.ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_ExpiredOK)
    k_ETourneyQueueDeadlineState_ExpiredOK = 2,
    // @@protoc_insertion_point(enum_value:dota.ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_SeekingBye)
    k_ETourneyQueueDeadlineState_SeekingBye = 3,
    // @@protoc_insertion_point(enum_value:dota.ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_EligibleForRefund)
    k_ETourneyQueueDeadlineState_EligibleForRefund = 4,
    // @@protoc_insertion_point(enum_value:dota.ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_NA)
    k_ETourneyQueueDeadlineState_NA = -1,
    // @@protoc_insertion_point(enum_value:dota.ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_ExpiringSoon)
    k_ETourneyQueueDeadlineState_ExpiringSoon = 101,
}

impl ::protobuf::Enum for ETourneyQueueDeadlineState {
    const NAME: &'static str = "ETourneyQueueDeadlineState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETourneyQueueDeadlineState> {
        match value {
            0 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Normal),
            1 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Missed),
            2 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiredOK),
            3 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_SeekingBye),
            4 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_EligibleForRefund),
            -1 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_NA),
            101 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiringSoon),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETourneyQueueDeadlineState> {
        match str {
            "k_ETourneyQueueDeadlineState_Normal" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Normal),
            "k_ETourneyQueueDeadlineState_Missed" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Missed),
            "k_ETourneyQueueDeadlineState_ExpiredOK" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiredOK),
            "k_ETourneyQueueDeadlineState_SeekingBye" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_SeekingBye),
            "k_ETourneyQueueDeadlineState_EligibleForRefund" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_EligibleForRefund),
            "k_ETourneyQueueDeadlineState_NA" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_NA),
            "k_ETourneyQueueDeadlineState_ExpiringSoon" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiringSoon),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETourneyQueueDeadlineState] = &[
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Normal,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Missed,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiredOK,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_SeekingBye,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_EligibleForRefund,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_NA,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiringSoon,
    ];
}

impl ::protobuf::EnumFull for ETourneyQueueDeadlineState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETourneyQueueDeadlineState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Normal => 0,
            ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Missed => 1,
            ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiredOK => 2,
            ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_SeekingBye => 3,
            ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_EligibleForRefund => 4,
            ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_NA => 5,
            ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiringSoon => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ETourneyQueueDeadlineState {
    fn default() -> Self {
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Normal
    }
}

impl ETourneyQueueDeadlineState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETourneyQueueDeadlineState>("ETourneyQueueDeadlineState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EMatchOutcome)
pub enum EMatchOutcome {
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_Unknown)
    k_EMatchOutcome_Unknown = 0,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_RadVictory)
    k_EMatchOutcome_RadVictory = 2,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_DireVictory)
    k_EMatchOutcome_DireVictory = 3,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_NeutralVictory)
    k_EMatchOutcome_NeutralVictory = 4,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_NoTeamWinner)
    k_EMatchOutcome_NoTeamWinner = 5,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_Custom1Victory)
    k_EMatchOutcome_Custom1Victory = 6,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_Custom2Victory)
    k_EMatchOutcome_Custom2Victory = 7,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_Custom3Victory)
    k_EMatchOutcome_Custom3Victory = 8,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_Custom4Victory)
    k_EMatchOutcome_Custom4Victory = 9,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_Custom5Victory)
    k_EMatchOutcome_Custom5Victory = 10,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_Custom6Victory)
    k_EMatchOutcome_Custom6Victory = 11,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_Custom7Victory)
    k_EMatchOutcome_Custom7Victory = 12,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_Custom8Victory)
    k_EMatchOutcome_Custom8Victory = 13,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_NotScored_PoorNetworkConditions)
    k_EMatchOutcome_NotScored_PoorNetworkConditions = 64,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_NotScored_Leaver)
    k_EMatchOutcome_NotScored_Leaver = 65,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_NotScored_ServerCrash)
    k_EMatchOutcome_NotScored_ServerCrash = 66,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_NotScored_NeverStarted)
    k_EMatchOutcome_NotScored_NeverStarted = 67,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_NotScored_Canceled)
    k_EMatchOutcome_NotScored_Canceled = 68,
    // @@protoc_insertion_point(enum_value:dota.EMatchOutcome.k_EMatchOutcome_NotScored_Suspicious)
    k_EMatchOutcome_NotScored_Suspicious = 69,
}

impl ::protobuf::Enum for EMatchOutcome {
    const NAME: &'static str = "EMatchOutcome";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMatchOutcome> {
        match value {
            0 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Unknown),
            2 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_RadVictory),
            3 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_DireVictory),
            4 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NeutralVictory),
            5 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NoTeamWinner),
            6 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom1Victory),
            7 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom2Victory),
            8 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom3Victory),
            9 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom4Victory),
            10 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom5Victory),
            11 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom6Victory),
            12 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom7Victory),
            13 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom8Victory),
            64 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_PoorNetworkConditions),
            65 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Leaver),
            66 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_ServerCrash),
            67 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_NeverStarted),
            68 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Canceled),
            69 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Suspicious),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMatchOutcome> {
        match str {
            "k_EMatchOutcome_Unknown" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Unknown),
            "k_EMatchOutcome_RadVictory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_RadVictory),
            "k_EMatchOutcome_DireVictory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_DireVictory),
            "k_EMatchOutcome_NeutralVictory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NeutralVictory),
            "k_EMatchOutcome_NoTeamWinner" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NoTeamWinner),
            "k_EMatchOutcome_Custom1Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom1Victory),
            "k_EMatchOutcome_Custom2Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom2Victory),
            "k_EMatchOutcome_Custom3Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom3Victory),
            "k_EMatchOutcome_Custom4Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom4Victory),
            "k_EMatchOutcome_Custom5Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom5Victory),
            "k_EMatchOutcome_Custom6Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom6Victory),
            "k_EMatchOutcome_Custom7Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom7Victory),
            "k_EMatchOutcome_Custom8Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom8Victory),
            "k_EMatchOutcome_NotScored_PoorNetworkConditions" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_PoorNetworkConditions),
            "k_EMatchOutcome_NotScored_Leaver" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Leaver),
            "k_EMatchOutcome_NotScored_ServerCrash" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_ServerCrash),
            "k_EMatchOutcome_NotScored_NeverStarted" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_NeverStarted),
            "k_EMatchOutcome_NotScored_Canceled" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Canceled),
            "k_EMatchOutcome_NotScored_Suspicious" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Suspicious),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMatchOutcome] = &[
        EMatchOutcome::k_EMatchOutcome_Unknown,
        EMatchOutcome::k_EMatchOutcome_RadVictory,
        EMatchOutcome::k_EMatchOutcome_DireVictory,
        EMatchOutcome::k_EMatchOutcome_NeutralVictory,
        EMatchOutcome::k_EMatchOutcome_NoTeamWinner,
        EMatchOutcome::k_EMatchOutcome_Custom1Victory,
        EMatchOutcome::k_EMatchOutcome_Custom2Victory,
        EMatchOutcome::k_EMatchOutcome_Custom3Victory,
        EMatchOutcome::k_EMatchOutcome_Custom4Victory,
        EMatchOutcome::k_EMatchOutcome_Custom5Victory,
        EMatchOutcome::k_EMatchOutcome_Custom6Victory,
        EMatchOutcome::k_EMatchOutcome_Custom7Victory,
        EMatchOutcome::k_EMatchOutcome_Custom8Victory,
        EMatchOutcome::k_EMatchOutcome_NotScored_PoorNetworkConditions,
        EMatchOutcome::k_EMatchOutcome_NotScored_Leaver,
        EMatchOutcome::k_EMatchOutcome_NotScored_ServerCrash,
        EMatchOutcome::k_EMatchOutcome_NotScored_NeverStarted,
        EMatchOutcome::k_EMatchOutcome_NotScored_Canceled,
        EMatchOutcome::k_EMatchOutcome_NotScored_Suspicious,
    ];
}

impl ::protobuf::EnumFull for EMatchOutcome {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EMatchOutcome").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EMatchOutcome::k_EMatchOutcome_Unknown => 0,
            EMatchOutcome::k_EMatchOutcome_RadVictory => 1,
            EMatchOutcome::k_EMatchOutcome_DireVictory => 2,
            EMatchOutcome::k_EMatchOutcome_NeutralVictory => 3,
            EMatchOutcome::k_EMatchOutcome_NoTeamWinner => 4,
            EMatchOutcome::k_EMatchOutcome_Custom1Victory => 5,
            EMatchOutcome::k_EMatchOutcome_Custom2Victory => 6,
            EMatchOutcome::k_EMatchOutcome_Custom3Victory => 7,
            EMatchOutcome::k_EMatchOutcome_Custom4Victory => 8,
            EMatchOutcome::k_EMatchOutcome_Custom5Victory => 9,
            EMatchOutcome::k_EMatchOutcome_Custom6Victory => 10,
            EMatchOutcome::k_EMatchOutcome_Custom7Victory => 11,
            EMatchOutcome::k_EMatchOutcome_Custom8Victory => 12,
            EMatchOutcome::k_EMatchOutcome_NotScored_PoorNetworkConditions => 13,
            EMatchOutcome::k_EMatchOutcome_NotScored_Leaver => 14,
            EMatchOutcome::k_EMatchOutcome_NotScored_ServerCrash => 15,
            EMatchOutcome::k_EMatchOutcome_NotScored_NeverStarted => 16,
            EMatchOutcome::k_EMatchOutcome_NotScored_Canceled => 17,
            EMatchOutcome::k_EMatchOutcome_NotScored_Suspicious => 18,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EMatchOutcome {
    fn default() -> Self {
        EMatchOutcome::k_EMatchOutcome_Unknown
    }
}

impl EMatchOutcome {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EMatchOutcome>("EMatchOutcome")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELaneType)
pub enum ELaneType {
    // @@protoc_insertion_point(enum_value:dota.ELaneType.LANE_TYPE_UNKNOWN)
    LANE_TYPE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:dota.ELaneType.LANE_TYPE_SAFE)
    LANE_TYPE_SAFE = 1,
    // @@protoc_insertion_point(enum_value:dota.ELaneType.LANE_TYPE_OFF)
    LANE_TYPE_OFF = 2,
    // @@protoc_insertion_point(enum_value:dota.ELaneType.LANE_TYPE_MID)
    LANE_TYPE_MID = 3,
    // @@protoc_insertion_point(enum_value:dota.ELaneType.LANE_TYPE_JUNGLE)
    LANE_TYPE_JUNGLE = 4,
    // @@protoc_insertion_point(enum_value:dota.ELaneType.LANE_TYPE_ROAM)
    LANE_TYPE_ROAM = 5,
}

impl ::protobuf::Enum for ELaneType {
    const NAME: &'static str = "ELaneType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELaneType> {
        match value {
            0 => ::std::option::Option::Some(ELaneType::LANE_TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(ELaneType::LANE_TYPE_SAFE),
            2 => ::std::option::Option::Some(ELaneType::LANE_TYPE_OFF),
            3 => ::std::option::Option::Some(ELaneType::LANE_TYPE_MID),
            4 => ::std::option::Option::Some(ELaneType::LANE_TYPE_JUNGLE),
            5 => ::std::option::Option::Some(ELaneType::LANE_TYPE_ROAM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELaneType> {
        match str {
            "LANE_TYPE_UNKNOWN" => ::std::option::Option::Some(ELaneType::LANE_TYPE_UNKNOWN),
            "LANE_TYPE_SAFE" => ::std::option::Option::Some(ELaneType::LANE_TYPE_SAFE),
            "LANE_TYPE_OFF" => ::std::option::Option::Some(ELaneType::LANE_TYPE_OFF),
            "LANE_TYPE_MID" => ::std::option::Option::Some(ELaneType::LANE_TYPE_MID),
            "LANE_TYPE_JUNGLE" => ::std::option::Option::Some(ELaneType::LANE_TYPE_JUNGLE),
            "LANE_TYPE_ROAM" => ::std::option::Option::Some(ELaneType::LANE_TYPE_ROAM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELaneType] = &[
        ELaneType::LANE_TYPE_UNKNOWN,
        ELaneType::LANE_TYPE_SAFE,
        ELaneType::LANE_TYPE_OFF,
        ELaneType::LANE_TYPE_MID,
        ELaneType::LANE_TYPE_JUNGLE,
        ELaneType::LANE_TYPE_ROAM,
    ];
}

impl ::protobuf::EnumFull for ELaneType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELaneType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELaneType {
    fn default() -> Self {
        ELaneType::LANE_TYPE_UNKNOWN
    }
}

impl ELaneType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELaneType>("ELaneType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EBadgeType)
pub enum EBadgeType {
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI7_Midweek)
    k_EBadgeType_TI7_Midweek = 1,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI7_Finals)
    k_EBadgeType_TI7_Finals = 2,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI7_AllEvent)
    k_EBadgeType_TI7_AllEvent = 3,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI8_Midweek)
    k_EBadgeType_TI8_Midweek = 4,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI8_Finals)
    k_EBadgeType_TI8_Finals = 5,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI8_AllEvent)
    k_EBadgeType_TI8_AllEvent = 6,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI10)
    k_EBadgeType_TI10 = 7,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI11_PlayoffsDay1)
    k_EBadgeType_TI11_PlayoffsDay1 = 8,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI11_PlayoffsDay2)
    k_EBadgeType_TI11_PlayoffsDay2 = 9,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI11_PlayoffsDay3)
    k_EBadgeType_TI11_PlayoffsDay3 = 10,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI11_PlayoffsDay4)
    k_EBadgeType_TI11_PlayoffsDay4 = 11,
    // @@protoc_insertion_point(enum_value:dota.EBadgeType.k_EBadgeType_TI11_FinalsWeekend)
    k_EBadgeType_TI11_FinalsWeekend = 12,
}

impl ::protobuf::Enum for EBadgeType {
    const NAME: &'static str = "EBadgeType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBadgeType> {
        match value {
            1 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_Midweek),
            2 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_Finals),
            3 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_AllEvent),
            4 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_Midweek),
            5 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_Finals),
            6 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_AllEvent),
            7 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI10),
            8 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay1),
            9 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay2),
            10 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay3),
            11 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay4),
            12 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_FinalsWeekend),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBadgeType> {
        match str {
            "k_EBadgeType_TI7_Midweek" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_Midweek),
            "k_EBadgeType_TI7_Finals" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_Finals),
            "k_EBadgeType_TI7_AllEvent" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_AllEvent),
            "k_EBadgeType_TI8_Midweek" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_Midweek),
            "k_EBadgeType_TI8_Finals" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_Finals),
            "k_EBadgeType_TI8_AllEvent" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_AllEvent),
            "k_EBadgeType_TI10" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI10),
            "k_EBadgeType_TI11_PlayoffsDay1" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay1),
            "k_EBadgeType_TI11_PlayoffsDay2" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay2),
            "k_EBadgeType_TI11_PlayoffsDay3" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay3),
            "k_EBadgeType_TI11_PlayoffsDay4" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay4),
            "k_EBadgeType_TI11_FinalsWeekend" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_FinalsWeekend),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBadgeType] = &[
        EBadgeType::k_EBadgeType_TI7_Midweek,
        EBadgeType::k_EBadgeType_TI7_Finals,
        EBadgeType::k_EBadgeType_TI7_AllEvent,
        EBadgeType::k_EBadgeType_TI8_Midweek,
        EBadgeType::k_EBadgeType_TI8_Finals,
        EBadgeType::k_EBadgeType_TI8_AllEvent,
        EBadgeType::k_EBadgeType_TI10,
        EBadgeType::k_EBadgeType_TI11_PlayoffsDay1,
        EBadgeType::k_EBadgeType_TI11_PlayoffsDay2,
        EBadgeType::k_EBadgeType_TI11_PlayoffsDay3,
        EBadgeType::k_EBadgeType_TI11_PlayoffsDay4,
        EBadgeType::k_EBadgeType_TI11_FinalsWeekend,
    ];
}

impl ::protobuf::EnumFull for EBadgeType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBadgeType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EBadgeType::k_EBadgeType_TI7_Midweek => 0,
            EBadgeType::k_EBadgeType_TI7_Finals => 1,
            EBadgeType::k_EBadgeType_TI7_AllEvent => 2,
            EBadgeType::k_EBadgeType_TI8_Midweek => 3,
            EBadgeType::k_EBadgeType_TI8_Finals => 4,
            EBadgeType::k_EBadgeType_TI8_AllEvent => 5,
            EBadgeType::k_EBadgeType_TI10 => 6,
            EBadgeType::k_EBadgeType_TI11_PlayoffsDay1 => 7,
            EBadgeType::k_EBadgeType_TI11_PlayoffsDay2 => 8,
            EBadgeType::k_EBadgeType_TI11_PlayoffsDay3 => 9,
            EBadgeType::k_EBadgeType_TI11_PlayoffsDay4 => 10,
            EBadgeType::k_EBadgeType_TI11_FinalsWeekend => 11,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EBadgeType {
    fn default() -> Self {
        EBadgeType::k_EBadgeType_TI7_Midweek
    }
}

impl EBadgeType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EBadgeType>("EBadgeType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeagueStatus)
pub enum ELeagueStatus {
    // @@protoc_insertion_point(enum_value:dota.ELeagueStatus.LEAGUE_STATUS_UNSET)
    LEAGUE_STATUS_UNSET = 0,
    // @@protoc_insertion_point(enum_value:dota.ELeagueStatus.LEAGUE_STATUS_UNSUBMITTED)
    LEAGUE_STATUS_UNSUBMITTED = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeagueStatus.LEAGUE_STATUS_SUBMITTED)
    LEAGUE_STATUS_SUBMITTED = 2,
    // @@protoc_insertion_point(enum_value:dota.ELeagueStatus.LEAGUE_STATUS_ACCEPTED)
    LEAGUE_STATUS_ACCEPTED = 3,
    // @@protoc_insertion_point(enum_value:dota.ELeagueStatus.LEAGUE_STATUS_REJECTED)
    LEAGUE_STATUS_REJECTED = 4,
    // @@protoc_insertion_point(enum_value:dota.ELeagueStatus.LEAGUE_STATUS_CONCLUDED)
    LEAGUE_STATUS_CONCLUDED = 5,
    // @@protoc_insertion_point(enum_value:dota.ELeagueStatus.LEAGUE_STATUS_DELETED)
    LEAGUE_STATUS_DELETED = 6,
}

impl ::protobuf::Enum for ELeagueStatus {
    const NAME: &'static str = "ELeagueStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueStatus> {
        match value {
            0 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_UNSET),
            1 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_UNSUBMITTED),
            2 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_SUBMITTED),
            3 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_ACCEPTED),
            4 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_REJECTED),
            5 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_CONCLUDED),
            6 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_DELETED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueStatus> {
        match str {
            "LEAGUE_STATUS_UNSET" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_UNSET),
            "LEAGUE_STATUS_UNSUBMITTED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_UNSUBMITTED),
            "LEAGUE_STATUS_SUBMITTED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_SUBMITTED),
            "LEAGUE_STATUS_ACCEPTED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_ACCEPTED),
            "LEAGUE_STATUS_REJECTED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_REJECTED),
            "LEAGUE_STATUS_CONCLUDED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_CONCLUDED),
            "LEAGUE_STATUS_DELETED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_DELETED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueStatus] = &[
        ELeagueStatus::LEAGUE_STATUS_UNSET,
        ELeagueStatus::LEAGUE_STATUS_UNSUBMITTED,
        ELeagueStatus::LEAGUE_STATUS_SUBMITTED,
        ELeagueStatus::LEAGUE_STATUS_ACCEPTED,
        ELeagueStatus::LEAGUE_STATUS_REJECTED,
        ELeagueStatus::LEAGUE_STATUS_CONCLUDED,
        ELeagueStatus::LEAGUE_STATUS_DELETED,
    ];
}

impl ::protobuf::EnumFull for ELeagueStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeagueStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELeagueStatus {
    fn default() -> Self {
        ELeagueStatus::LEAGUE_STATUS_UNSET
    }
}

impl ELeagueStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueStatus>("ELeagueStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeagueRegion)
pub enum ELeagueRegion {
    // @@protoc_insertion_point(enum_value:dota.ELeagueRegion.LEAGUE_REGION_UNSET)
    LEAGUE_REGION_UNSET = 0,
    // @@protoc_insertion_point(enum_value:dota.ELeagueRegion.LEAGUE_REGION_NA)
    LEAGUE_REGION_NA = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeagueRegion.LEAGUE_REGION_SA)
    LEAGUE_REGION_SA = 2,
    // @@protoc_insertion_point(enum_value:dota.ELeagueRegion.LEAGUE_REGION_WEU)
    LEAGUE_REGION_WEU = 3,
    // @@protoc_insertion_point(enum_value:dota.ELeagueRegion.LEAGUE_REGION_EEU)
    LEAGUE_REGION_EEU = 4,
    // @@protoc_insertion_point(enum_value:dota.ELeagueRegion.LEAGUE_REGION_CHINA)
    LEAGUE_REGION_CHINA = 5,
    // @@protoc_insertion_point(enum_value:dota.ELeagueRegion.LEAGUE_REGION_SEA)
    LEAGUE_REGION_SEA = 6,
}

impl ::protobuf::Enum for ELeagueRegion {
    const NAME: &'static str = "ELeagueRegion";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueRegion> {
        match value {
            0 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_UNSET),
            1 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_NA),
            2 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_SA),
            3 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_WEU),
            4 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_EEU),
            5 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_CHINA),
            6 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_SEA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueRegion> {
        match str {
            "LEAGUE_REGION_UNSET" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_UNSET),
            "LEAGUE_REGION_NA" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_NA),
            "LEAGUE_REGION_SA" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_SA),
            "LEAGUE_REGION_WEU" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_WEU),
            "LEAGUE_REGION_EEU" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_EEU),
            "LEAGUE_REGION_CHINA" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_CHINA),
            "LEAGUE_REGION_SEA" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_SEA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueRegion] = &[
        ELeagueRegion::LEAGUE_REGION_UNSET,
        ELeagueRegion::LEAGUE_REGION_NA,
        ELeagueRegion::LEAGUE_REGION_SA,
        ELeagueRegion::LEAGUE_REGION_WEU,
        ELeagueRegion::LEAGUE_REGION_EEU,
        ELeagueRegion::LEAGUE_REGION_CHINA,
        ELeagueRegion::LEAGUE_REGION_SEA,
    ];
}

impl ::protobuf::EnumFull for ELeagueRegion {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeagueRegion").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELeagueRegion {
    fn default() -> Self {
        ELeagueRegion::LEAGUE_REGION_UNSET
    }
}

impl ELeagueRegion {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueRegion>("ELeagueRegion")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeagueTier)
pub enum ELeagueTier {
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_UNSET)
    LEAGUE_TIER_UNSET = 0,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_AMATEUR)
    LEAGUE_TIER_AMATEUR = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_PROFESSIONAL)
    LEAGUE_TIER_PROFESSIONAL = 2,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_MINOR)
    LEAGUE_TIER_MINOR = 3,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_MAJOR)
    LEAGUE_TIER_MAJOR = 4,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_INTERNATIONAL)
    LEAGUE_TIER_INTERNATIONAL = 5,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_DPC_QUALIFIER)
    LEAGUE_TIER_DPC_QUALIFIER = 6,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_DPC_LEAGUE_QUALIFIER)
    LEAGUE_TIER_DPC_LEAGUE_QUALIFIER = 7,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_DPC_LEAGUE)
    LEAGUE_TIER_DPC_LEAGUE = 8,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTier.LEAGUE_TIER_DPC_LEAGUE_FINALS)
    LEAGUE_TIER_DPC_LEAGUE_FINALS = 9,
}

impl ::protobuf::Enum for ELeagueTier {
    const NAME: &'static str = "ELeagueTier";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueTier> {
        match value {
            0 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_UNSET),
            1 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_AMATEUR),
            2 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_PROFESSIONAL),
            3 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_MINOR),
            4 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_MAJOR),
            5 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_INTERNATIONAL),
            6 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_QUALIFIER),
            7 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_QUALIFIER),
            8 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE),
            9 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_FINALS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueTier> {
        match str {
            "LEAGUE_TIER_UNSET" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_UNSET),
            "LEAGUE_TIER_AMATEUR" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_AMATEUR),
            "LEAGUE_TIER_PROFESSIONAL" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_PROFESSIONAL),
            "LEAGUE_TIER_MINOR" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_MINOR),
            "LEAGUE_TIER_MAJOR" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_MAJOR),
            "LEAGUE_TIER_INTERNATIONAL" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_INTERNATIONAL),
            "LEAGUE_TIER_DPC_QUALIFIER" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_QUALIFIER),
            "LEAGUE_TIER_DPC_LEAGUE_QUALIFIER" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_QUALIFIER),
            "LEAGUE_TIER_DPC_LEAGUE" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE),
            "LEAGUE_TIER_DPC_LEAGUE_FINALS" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_FINALS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueTier] = &[
        ELeagueTier::LEAGUE_TIER_UNSET,
        ELeagueTier::LEAGUE_TIER_AMATEUR,
        ELeagueTier::LEAGUE_TIER_PROFESSIONAL,
        ELeagueTier::LEAGUE_TIER_MINOR,
        ELeagueTier::LEAGUE_TIER_MAJOR,
        ELeagueTier::LEAGUE_TIER_INTERNATIONAL,
        ELeagueTier::LEAGUE_TIER_DPC_QUALIFIER,
        ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_QUALIFIER,
        ELeagueTier::LEAGUE_TIER_DPC_LEAGUE,
        ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_FINALS,
    ];
}

impl ::protobuf::EnumFull for ELeagueTier {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeagueTier").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELeagueTier {
    fn default() -> Self {
        ELeagueTier::LEAGUE_TIER_UNSET
    }
}

impl ELeagueTier {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueTier>("ELeagueTier")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeagueTierCategory)
pub enum ELeagueTierCategory {
    // @@protoc_insertion_point(enum_value:dota.ELeagueTierCategory.LEAGUE_TIER_CATEGORY_AMATEUR)
    LEAGUE_TIER_CATEGORY_AMATEUR = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTierCategory.LEAGUE_TIER_CATEGORY_PROFESSIONAL)
    LEAGUE_TIER_CATEGORY_PROFESSIONAL = 2,
    // @@protoc_insertion_point(enum_value:dota.ELeagueTierCategory.LEAGUE_TIER_CATEGORY_DPC)
    LEAGUE_TIER_CATEGORY_DPC = 3,
}

impl ::protobuf::Enum for ELeagueTierCategory {
    const NAME: &'static str = "ELeagueTierCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueTierCategory> {
        match value {
            1 => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_AMATEUR),
            2 => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_PROFESSIONAL),
            3 => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_DPC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueTierCategory> {
        match str {
            "LEAGUE_TIER_CATEGORY_AMATEUR" => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_AMATEUR),
            "LEAGUE_TIER_CATEGORY_PROFESSIONAL" => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_PROFESSIONAL),
            "LEAGUE_TIER_CATEGORY_DPC" => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_DPC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueTierCategory] = &[
        ELeagueTierCategory::LEAGUE_TIER_CATEGORY_AMATEUR,
        ELeagueTierCategory::LEAGUE_TIER_CATEGORY_PROFESSIONAL,
        ELeagueTierCategory::LEAGUE_TIER_CATEGORY_DPC,
    ];
}

impl ::protobuf::EnumFull for ELeagueTierCategory {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeagueTierCategory").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ELeagueTierCategory::LEAGUE_TIER_CATEGORY_AMATEUR => 0,
            ELeagueTierCategory::LEAGUE_TIER_CATEGORY_PROFESSIONAL => 1,
            ELeagueTierCategory::LEAGUE_TIER_CATEGORY_DPC => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ELeagueTierCategory {
    fn default() -> Self {
        ELeagueTierCategory::LEAGUE_TIER_CATEGORY_AMATEUR
    }
}

impl ELeagueTierCategory {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueTierCategory>("ELeagueTierCategory")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeagueDivision)
pub enum ELeagueDivision {
    // @@protoc_insertion_point(enum_value:dota.ELeagueDivision.LEAGUE_DIVISION_UNSET)
    LEAGUE_DIVISION_UNSET = 0,
    // @@protoc_insertion_point(enum_value:dota.ELeagueDivision.LEAGUE_DIVISION_I)
    LEAGUE_DIVISION_I = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeagueDivision.LEAGUE_DIVISION_II)
    LEAGUE_DIVISION_II = 2,
}

impl ::protobuf::Enum for ELeagueDivision {
    const NAME: &'static str = "ELeagueDivision";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueDivision> {
        match value {
            0 => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_UNSET),
            1 => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_I),
            2 => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_II),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueDivision> {
        match str {
            "LEAGUE_DIVISION_UNSET" => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_UNSET),
            "LEAGUE_DIVISION_I" => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_I),
            "LEAGUE_DIVISION_II" => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_II),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueDivision] = &[
        ELeagueDivision::LEAGUE_DIVISION_UNSET,
        ELeagueDivision::LEAGUE_DIVISION_I,
        ELeagueDivision::LEAGUE_DIVISION_II,
    ];
}

impl ::protobuf::EnumFull for ELeagueDivision {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeagueDivision").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELeagueDivision {
    fn default() -> Self {
        ELeagueDivision::LEAGUE_DIVISION_UNSET
    }
}

impl ELeagueDivision {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueDivision>("ELeagueDivision")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeagueBroadcastProvider)
pub enum ELeagueBroadcastProvider {
    // @@protoc_insertion_point(enum_value:dota.ELeagueBroadcastProvider.LEAGUE_BROADCAST_UNKNOWN)
    LEAGUE_BROADCAST_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:dota.ELeagueBroadcastProvider.LEAGUE_BROADCAST_STEAM)
    LEAGUE_BROADCAST_STEAM = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeagueBroadcastProvider.LEAGUE_BROADCAST_TWITCH)
    LEAGUE_BROADCAST_TWITCH = 2,
    // @@protoc_insertion_point(enum_value:dota.ELeagueBroadcastProvider.LEAGUE_BROADCAST_YOUTUBE)
    LEAGUE_BROADCAST_YOUTUBE = 3,
    // @@protoc_insertion_point(enum_value:dota.ELeagueBroadcastProvider.LEAGUE_BROADCAST_OTHER)
    LEAGUE_BROADCAST_OTHER = 100,
}

impl ::protobuf::Enum for ELeagueBroadcastProvider {
    const NAME: &'static str = "ELeagueBroadcastProvider";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueBroadcastProvider> {
        match value {
            0 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN),
            1 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_STEAM),
            2 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_TWITCH),
            3 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_YOUTUBE),
            100 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueBroadcastProvider> {
        match str {
            "LEAGUE_BROADCAST_UNKNOWN" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN),
            "LEAGUE_BROADCAST_STEAM" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_STEAM),
            "LEAGUE_BROADCAST_TWITCH" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_TWITCH),
            "LEAGUE_BROADCAST_YOUTUBE" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_YOUTUBE),
            "LEAGUE_BROADCAST_OTHER" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueBroadcastProvider] = &[
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN,
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_STEAM,
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_TWITCH,
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_YOUTUBE,
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_OTHER,
    ];
}

impl ::protobuf::EnumFull for ELeagueBroadcastProvider {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeagueBroadcastProvider").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN => 0,
            ELeagueBroadcastProvider::LEAGUE_BROADCAST_STEAM => 1,
            ELeagueBroadcastProvider::LEAGUE_BROADCAST_TWITCH => 2,
            ELeagueBroadcastProvider::LEAGUE_BROADCAST_YOUTUBE => 3,
            ELeagueBroadcastProvider::LEAGUE_BROADCAST_OTHER => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELeagueBroadcastProvider {
    fn default() -> Self {
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN
    }
}

impl ELeagueBroadcastProvider {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueBroadcastProvider>("ELeagueBroadcastProvider")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeaguePhase)
pub enum ELeaguePhase {
    // @@protoc_insertion_point(enum_value:dota.ELeaguePhase.LEAGUE_PHASE_UNSET)
    LEAGUE_PHASE_UNSET = 0,
    // @@protoc_insertion_point(enum_value:dota.ELeaguePhase.LEAGUE_PHASE_REGIONAL_QUALIFIER)
    LEAGUE_PHASE_REGIONAL_QUALIFIER = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeaguePhase.LEAGUE_PHASE_GROUP_STAGE)
    LEAGUE_PHASE_GROUP_STAGE = 2,
    // @@protoc_insertion_point(enum_value:dota.ELeaguePhase.LEAGUE_PHASE_MAIN_EVENT)
    LEAGUE_PHASE_MAIN_EVENT = 3,
}

impl ::protobuf::Enum for ELeaguePhase {
    const NAME: &'static str = "ELeaguePhase";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeaguePhase> {
        match value {
            0 => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_UNSET),
            1 => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_REGIONAL_QUALIFIER),
            2 => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_GROUP_STAGE),
            3 => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_MAIN_EVENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeaguePhase> {
        match str {
            "LEAGUE_PHASE_UNSET" => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_UNSET),
            "LEAGUE_PHASE_REGIONAL_QUALIFIER" => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_REGIONAL_QUALIFIER),
            "LEAGUE_PHASE_GROUP_STAGE" => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_GROUP_STAGE),
            "LEAGUE_PHASE_MAIN_EVENT" => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_MAIN_EVENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeaguePhase] = &[
        ELeaguePhase::LEAGUE_PHASE_UNSET,
        ELeaguePhase::LEAGUE_PHASE_REGIONAL_QUALIFIER,
        ELeaguePhase::LEAGUE_PHASE_GROUP_STAGE,
        ELeaguePhase::LEAGUE_PHASE_MAIN_EVENT,
    ];
}

impl ::protobuf::EnumFull for ELeaguePhase {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeaguePhase").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELeaguePhase {
    fn default() -> Self {
        ELeaguePhase::LEAGUE_PHASE_UNSET
    }
}

impl ELeaguePhase {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeaguePhase>("ELeaguePhase")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeagueAuditAction)
pub enum ELeagueAuditAction {
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_INVALID)
    LEAGUE_AUDIT_ACTION_INVALID = 0,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_CREATE)
    LEAGUE_AUDIT_ACTION_LEAGUE_CREATE = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_EDIT)
    LEAGUE_AUDIT_ACTION_LEAGUE_EDIT = 2,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_DELETE)
    LEAGUE_AUDIT_ACTION_LEAGUE_DELETE = 3,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD = 4,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE = 5,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE = 6,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD)
    LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD = 7,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE)
    LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE = 8,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED)
    LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED = 9,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED)
    LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED = 10,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED)
    LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED = 11,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL)
    LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL = 12,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM = 13,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM)
    LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM = 14,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START)
    LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START = 15,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END)
    LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END = 16,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM = 17,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM)
    LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM = 18,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED)
    LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED = 19,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT)
    LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT = 20,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP)
    LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP = 21,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE)
    LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE = 100,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY)
    LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY = 101,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM)
    LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM = 102,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM)
    LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM = 103,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING)
    LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING = 104,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT)
    LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT = 105,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE)
    LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE = 106,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED)
    LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED = 107,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING)
    LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING = 108,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING)
    LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING = 109,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_CREATE)
    LEAGUE_AUDIT_ACTION_NODE_CREATE = 200,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_DESTROY)
    LEAGUE_AUDIT_ACTION_NODE_DESTROY = 201,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE)
    LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE = 202,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_SET_TEAM)
    LEAGUE_AUDIT_ACTION_NODE_SET_TEAM = 203,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID)
    LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID = 204,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING)
    LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING = 205,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_SET_TIME)
    LEAGUE_AUDIT_ACTION_NODE_SET_TIME = 206,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED)
    LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED = 207,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_COMPLETED)
    LEAGUE_AUDIT_ACTION_NODE_COMPLETED = 208,
    // @@protoc_insertion_point(enum_value:dota.ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_EDIT)
    LEAGUE_AUDIT_ACTION_NODE_EDIT = 209,
}

impl ::protobuf::Enum for ELeagueAuditAction {
    const NAME: &'static str = "ELeagueAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueAuditAction> {
        match value {
            0 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_INVALID),
            1 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_CREATE),
            2 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_EDIT),
            3 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_DELETE),
            4 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD),
            5 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE),
            6 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE),
            7 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD),
            8 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE),
            9 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED),
            10 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED),
            11 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED),
            12 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL),
            13 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM),
            14 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM),
            15 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START),
            16 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END),
            17 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM),
            18 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM),
            19 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED),
            20 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT),
            21 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP),
            100 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE),
            101 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY),
            102 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM),
            103 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM),
            104 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING),
            105 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT),
            106 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE),
            107 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED),
            108 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING),
            109 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING),
            200 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_CREATE),
            201 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_DESTROY),
            202 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE),
            203 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TEAM),
            204 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID),
            205 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING),
            206 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TIME),
            207 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED),
            208 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_COMPLETED),
            209 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_EDIT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueAuditAction> {
        match str {
            "LEAGUE_AUDIT_ACTION_INVALID" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_INVALID),
            "LEAGUE_AUDIT_ACTION_LEAGUE_CREATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_CREATE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_EDIT" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_EDIT),
            "LEAGUE_AUDIT_ACTION_LEAGUE_DELETE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_DELETE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD),
            "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED),
            "LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED),
            "LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED),
            "LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM),
            "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM),
            "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START),
            "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM),
            "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM),
            "LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED),
            "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT),
            "LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING),
            "LEAGUE_AUDIT_ACTION_NODE_CREATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_CREATE),
            "LEAGUE_AUDIT_ACTION_NODE_DESTROY" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_DESTROY),
            "LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE),
            "LEAGUE_AUDIT_ACTION_NODE_SET_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TEAM),
            "LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID),
            "LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING),
            "LEAGUE_AUDIT_ACTION_NODE_SET_TIME" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TIME),
            "LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED),
            "LEAGUE_AUDIT_ACTION_NODE_COMPLETED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_COMPLETED),
            "LEAGUE_AUDIT_ACTION_NODE_EDIT" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_EDIT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueAuditAction] = &[
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_INVALID,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_CREATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_EDIT,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_DELETE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_CREATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_DESTROY,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TIME,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_COMPLETED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_EDIT,
    ];
}

impl ::protobuf::EnumFull for ELeagueAuditAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeagueAuditAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_INVALID => 0,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_CREATE => 1,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_EDIT => 2,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_DELETE => 3,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD => 4,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE => 5,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE => 6,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD => 7,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE => 8,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED => 9,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED => 10,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED => 11,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL => 12,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM => 13,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM => 14,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START => 15,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END => 16,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM => 17,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM => 18,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED => 19,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT => 20,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP => 21,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE => 22,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY => 23,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM => 24,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM => 25,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING => 26,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT => 27,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE => 28,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED => 29,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING => 30,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING => 31,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_CREATE => 32,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_DESTROY => 33,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE => 34,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TEAM => 35,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID => 36,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING => 37,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TIME => 38,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED => 39,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_COMPLETED => 40,
            ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_EDIT => 41,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELeagueAuditAction {
    fn default() -> Self {
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_INVALID
    }
}

impl ELeagueAuditAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueAuditAction>("ELeagueAuditAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_COMBATLOG_TYPES)
pub enum DOTA_COMBATLOG_TYPES {
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_INVALID)
    DOTA_COMBATLOG_INVALID = -1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_DAMAGE)
    DOTA_COMBATLOG_DAMAGE = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_HEAL)
    DOTA_COMBATLOG_HEAL = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MODIFIER_ADD)
    DOTA_COMBATLOG_MODIFIER_ADD = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MODIFIER_REMOVE)
    DOTA_COMBATLOG_MODIFIER_REMOVE = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_DEATH)
    DOTA_COMBATLOG_DEATH = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ABILITY)
    DOTA_COMBATLOG_ABILITY = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ITEM)
    DOTA_COMBATLOG_ITEM = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_LOCATION)
    DOTA_COMBATLOG_LOCATION = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_GOLD)
    DOTA_COMBATLOG_GOLD = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_GAME_STATE)
    DOTA_COMBATLOG_GAME_STATE = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_XP)
    DOTA_COMBATLOG_XP = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_PURCHASE)
    DOTA_COMBATLOG_PURCHASE = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_BUYBACK)
    DOTA_COMBATLOG_BUYBACK = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ABILITY_TRIGGER)
    DOTA_COMBATLOG_ABILITY_TRIGGER = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_PLAYERSTATS)
    DOTA_COMBATLOG_PLAYERSTATS = 14,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MULTIKILL)
    DOTA_COMBATLOG_MULTIKILL = 15,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_KILLSTREAK)
    DOTA_COMBATLOG_KILLSTREAK = 16,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_TEAM_BUILDING_KILL)
    DOTA_COMBATLOG_TEAM_BUILDING_KILL = 17,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_FIRST_BLOOD)
    DOTA_COMBATLOG_FIRST_BLOOD = 18,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MODIFIER_STACK_EVENT)
    DOTA_COMBATLOG_MODIFIER_STACK_EVENT = 19,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_NEUTRAL_CAMP_STACK)
    DOTA_COMBATLOG_NEUTRAL_CAMP_STACK = 20,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_PICKUP_RUNE)
    DOTA_COMBATLOG_PICKUP_RUNE = 21,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_REVEALED_INVISIBLE)
    DOTA_COMBATLOG_REVEALED_INVISIBLE = 22,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_HERO_SAVED)
    DOTA_COMBATLOG_HERO_SAVED = 23,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MANA_RESTORED)
    DOTA_COMBATLOG_MANA_RESTORED = 24,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_HERO_LEVELUP)
    DOTA_COMBATLOG_HERO_LEVELUP = 25,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_BOTTLE_HEAL_ALLY)
    DOTA_COMBATLOG_BOTTLE_HEAL_ALLY = 26,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ENDGAME_STATS)
    DOTA_COMBATLOG_ENDGAME_STATS = 27,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_INTERRUPT_CHANNEL)
    DOTA_COMBATLOG_INTERRUPT_CHANNEL = 28,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ALLIED_GOLD)
    DOTA_COMBATLOG_ALLIED_GOLD = 29,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_AEGIS_TAKEN)
    DOTA_COMBATLOG_AEGIS_TAKEN = 30,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MANA_DAMAGE)
    DOTA_COMBATLOG_MANA_DAMAGE = 31,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED)
    DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED = 32,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_UNIT_SUMMONED)
    DOTA_COMBATLOG_UNIT_SUMMONED = 33,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ATTACK_EVADE)
    DOTA_COMBATLOG_ATTACK_EVADE = 34,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_TREE_CUT)
    DOTA_COMBATLOG_TREE_CUT = 35,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_SUCCESSFUL_SCAN)
    DOTA_COMBATLOG_SUCCESSFUL_SCAN = 36,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_END_KILLSTREAK)
    DOTA_COMBATLOG_END_KILLSTREAK = 37,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_BLOODSTONE_CHARGE)
    DOTA_COMBATLOG_BLOODSTONE_CHARGE = 38,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_CRITICAL_DAMAGE)
    DOTA_COMBATLOG_CRITICAL_DAMAGE = 39,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_SPELL_ABSORB)
    DOTA_COMBATLOG_SPELL_ABSORB = 40,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_UNIT_TELEPORTED)
    DOTA_COMBATLOG_UNIT_TELEPORTED = 41,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_KILL_EATER_EVENT)
    DOTA_COMBATLOG_KILL_EATER_EVENT = 42,
    // @@protoc_insertion_point(enum_value:dota.DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED)
    DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED = 43,
}

impl ::protobuf::Enum for DOTA_COMBATLOG_TYPES {
    const NAME: &'static str = "DOTA_COMBATLOG_TYPES";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_COMBATLOG_TYPES> {
        match value {
            -1 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID),
            0 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DAMAGE),
            1 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HEAL),
            2 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_ADD),
            3 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REMOVE),
            4 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DEATH),
            5 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY),
            6 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ITEM),
            7 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_LOCATION),
            8 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GOLD),
            9 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GAME_STATE),
            10 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_XP),
            11 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PURCHASE),
            12 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BUYBACK),
            13 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY_TRIGGER),
            14 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PLAYERSTATS),
            15 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MULTIKILL),
            16 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILLSTREAK),
            17 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TEAM_BUILDING_KILL),
            18 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_FIRST_BLOOD),
            19 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_STACK_EVENT),
            20 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_CAMP_STACK),
            21 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PICKUP_RUNE),
            22 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_REVEALED_INVISIBLE),
            23 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_SAVED),
            24 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_RESTORED),
            25 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_LEVELUP),
            26 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BOTTLE_HEAL_ALLY),
            27 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ENDGAME_STATS),
            28 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INTERRUPT_CHANNEL),
            29 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ALLIED_GOLD),
            30 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_AEGIS_TAKEN),
            31 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_DAMAGE),
            32 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED),
            33 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_SUMMONED),
            34 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ATTACK_EVADE),
            35 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TREE_CUT),
            36 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SUCCESSFUL_SCAN),
            37 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_END_KILLSTREAK),
            38 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BLOODSTONE_CHARGE),
            39 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_CRITICAL_DAMAGE),
            40 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SPELL_ABSORB),
            41 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_TELEPORTED),
            42 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILL_EATER_EVENT),
            43 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_COMBATLOG_TYPES> {
        match str {
            "DOTA_COMBATLOG_INVALID" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID),
            "DOTA_COMBATLOG_DAMAGE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DAMAGE),
            "DOTA_COMBATLOG_HEAL" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HEAL),
            "DOTA_COMBATLOG_MODIFIER_ADD" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_ADD),
            "DOTA_COMBATLOG_MODIFIER_REMOVE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REMOVE),
            "DOTA_COMBATLOG_DEATH" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DEATH),
            "DOTA_COMBATLOG_ABILITY" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY),
            "DOTA_COMBATLOG_ITEM" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ITEM),
            "DOTA_COMBATLOG_LOCATION" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_LOCATION),
            "DOTA_COMBATLOG_GOLD" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GOLD),
            "DOTA_COMBATLOG_GAME_STATE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GAME_STATE),
            "DOTA_COMBATLOG_XP" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_XP),
            "DOTA_COMBATLOG_PURCHASE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PURCHASE),
            "DOTA_COMBATLOG_BUYBACK" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BUYBACK),
            "DOTA_COMBATLOG_ABILITY_TRIGGER" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY_TRIGGER),
            "DOTA_COMBATLOG_PLAYERSTATS" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PLAYERSTATS),
            "DOTA_COMBATLOG_MULTIKILL" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MULTIKILL),
            "DOTA_COMBATLOG_KILLSTREAK" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILLSTREAK),
            "DOTA_COMBATLOG_TEAM_BUILDING_KILL" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TEAM_BUILDING_KILL),
            "DOTA_COMBATLOG_FIRST_BLOOD" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_FIRST_BLOOD),
            "DOTA_COMBATLOG_MODIFIER_STACK_EVENT" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_STACK_EVENT),
            "DOTA_COMBATLOG_NEUTRAL_CAMP_STACK" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_CAMP_STACK),
            "DOTA_COMBATLOG_PICKUP_RUNE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PICKUP_RUNE),
            "DOTA_COMBATLOG_REVEALED_INVISIBLE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_REVEALED_INVISIBLE),
            "DOTA_COMBATLOG_HERO_SAVED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_SAVED),
            "DOTA_COMBATLOG_MANA_RESTORED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_RESTORED),
            "DOTA_COMBATLOG_HERO_LEVELUP" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_LEVELUP),
            "DOTA_COMBATLOG_BOTTLE_HEAL_ALLY" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BOTTLE_HEAL_ALLY),
            "DOTA_COMBATLOG_ENDGAME_STATS" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ENDGAME_STATS),
            "DOTA_COMBATLOG_INTERRUPT_CHANNEL" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INTERRUPT_CHANNEL),
            "DOTA_COMBATLOG_ALLIED_GOLD" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ALLIED_GOLD),
            "DOTA_COMBATLOG_AEGIS_TAKEN" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_AEGIS_TAKEN),
            "DOTA_COMBATLOG_MANA_DAMAGE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_DAMAGE),
            "DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED),
            "DOTA_COMBATLOG_UNIT_SUMMONED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_SUMMONED),
            "DOTA_COMBATLOG_ATTACK_EVADE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ATTACK_EVADE),
            "DOTA_COMBATLOG_TREE_CUT" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TREE_CUT),
            "DOTA_COMBATLOG_SUCCESSFUL_SCAN" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SUCCESSFUL_SCAN),
            "DOTA_COMBATLOG_END_KILLSTREAK" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_END_KILLSTREAK),
            "DOTA_COMBATLOG_BLOODSTONE_CHARGE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BLOODSTONE_CHARGE),
            "DOTA_COMBATLOG_CRITICAL_DAMAGE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_CRITICAL_DAMAGE),
            "DOTA_COMBATLOG_SPELL_ABSORB" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SPELL_ABSORB),
            "DOTA_COMBATLOG_UNIT_TELEPORTED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_TELEPORTED),
            "DOTA_COMBATLOG_KILL_EATER_EVENT" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILL_EATER_EVENT),
            "DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_COMBATLOG_TYPES] = &[
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DAMAGE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HEAL,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_ADD,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REMOVE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DEATH,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ITEM,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_LOCATION,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GOLD,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GAME_STATE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_XP,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PURCHASE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BUYBACK,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY_TRIGGER,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PLAYERSTATS,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MULTIKILL,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILLSTREAK,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TEAM_BUILDING_KILL,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_FIRST_BLOOD,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_STACK_EVENT,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_CAMP_STACK,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PICKUP_RUNE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_REVEALED_INVISIBLE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_SAVED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_RESTORED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_LEVELUP,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BOTTLE_HEAL_ALLY,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ENDGAME_STATS,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INTERRUPT_CHANNEL,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ALLIED_GOLD,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_AEGIS_TAKEN,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_DAMAGE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_SUMMONED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ATTACK_EVADE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TREE_CUT,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SUCCESSFUL_SCAN,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_END_KILLSTREAK,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BLOODSTONE_CHARGE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_CRITICAL_DAMAGE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SPELL_ABSORB,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_TELEPORTED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILL_EATER_EVENT,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED,
    ];
}

impl ::protobuf::EnumFull for DOTA_COMBATLOG_TYPES {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_COMBATLOG_TYPES").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID => 0,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DAMAGE => 1,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HEAL => 2,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_ADD => 3,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REMOVE => 4,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DEATH => 5,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY => 6,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ITEM => 7,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_LOCATION => 8,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GOLD => 9,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GAME_STATE => 10,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_XP => 11,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PURCHASE => 12,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BUYBACK => 13,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY_TRIGGER => 14,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PLAYERSTATS => 15,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MULTIKILL => 16,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILLSTREAK => 17,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TEAM_BUILDING_KILL => 18,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_FIRST_BLOOD => 19,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_STACK_EVENT => 20,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_CAMP_STACK => 21,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PICKUP_RUNE => 22,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_REVEALED_INVISIBLE => 23,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_SAVED => 24,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_RESTORED => 25,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_LEVELUP => 26,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BOTTLE_HEAL_ALLY => 27,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ENDGAME_STATS => 28,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INTERRUPT_CHANNEL => 29,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ALLIED_GOLD => 30,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_AEGIS_TAKEN => 31,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_DAMAGE => 32,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED => 33,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_SUMMONED => 34,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ATTACK_EVADE => 35,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TREE_CUT => 36,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SUCCESSFUL_SCAN => 37,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_END_KILLSTREAK => 38,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BLOODSTONE_CHARGE => 39,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_CRITICAL_DAMAGE => 40,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SPELL_ABSORB => 41,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_TELEPORTED => 42,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILL_EATER_EVENT => 43,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED => 44,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_COMBATLOG_TYPES {
    fn default() -> Self {
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID
    }
}

impl DOTA_COMBATLOG_TYPES {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_COMBATLOG_TYPES>("DOTA_COMBATLOG_TYPES")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDPCFavoriteType)
pub enum EDPCFavoriteType {
    // @@protoc_insertion_point(enum_value:dota.EDPCFavoriteType.FAVORITE_TYPE_ALL)
    FAVORITE_TYPE_ALL = 0,
    // @@protoc_insertion_point(enum_value:dota.EDPCFavoriteType.FAVORITE_TYPE_PLAYER)
    FAVORITE_TYPE_PLAYER = 1,
    // @@protoc_insertion_point(enum_value:dota.EDPCFavoriteType.FAVORITE_TYPE_TEAM)
    FAVORITE_TYPE_TEAM = 2,
    // @@protoc_insertion_point(enum_value:dota.EDPCFavoriteType.FAVORITE_TYPE_LEAGUE)
    FAVORITE_TYPE_LEAGUE = 3,
}

impl ::protobuf::Enum for EDPCFavoriteType {
    const NAME: &'static str = "EDPCFavoriteType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDPCFavoriteType> {
        match value {
            0 => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_ALL),
            1 => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_PLAYER),
            2 => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_TEAM),
            3 => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_LEAGUE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDPCFavoriteType> {
        match str {
            "FAVORITE_TYPE_ALL" => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_ALL),
            "FAVORITE_TYPE_PLAYER" => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_PLAYER),
            "FAVORITE_TYPE_TEAM" => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_TEAM),
            "FAVORITE_TYPE_LEAGUE" => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_LEAGUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDPCFavoriteType] = &[
        EDPCFavoriteType::FAVORITE_TYPE_ALL,
        EDPCFavoriteType::FAVORITE_TYPE_PLAYER,
        EDPCFavoriteType::FAVORITE_TYPE_TEAM,
        EDPCFavoriteType::FAVORITE_TYPE_LEAGUE,
    ];
}

impl ::protobuf::EnumFull for EDPCFavoriteType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDPCFavoriteType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EDPCFavoriteType {
    fn default() -> Self {
        EDPCFavoriteType::FAVORITE_TYPE_ALL
    }
}

impl EDPCFavoriteType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDPCFavoriteType>("EDPCFavoriteType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDPCPushNotification)
pub enum EDPCPushNotification {
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_MATCH_STARTING)
    DPC_PUSH_NOTIFICATION_MATCH_STARTING = 1,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM)
    DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM = 10,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM)
    DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM = 11,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH)
    DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH = 12,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH)
    DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH = 13,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_LEAGUE_RESULT)
    DPC_PUSH_NOTIFICATION_LEAGUE_RESULT = 20,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE)
    DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE = 30,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_PREDICTION_RESULT)
    DPC_PUSH_NOTIFICATION_PREDICTION_RESULT = 31,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED)
    DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED = 40,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY)
    DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY = 41,
    // @@protoc_insertion_point(enum_value:dota.EDPCPushNotification.DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS)
    DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS = 42,
}

impl ::protobuf::Enum for EDPCPushNotification {
    const NAME: &'static str = "EDPCPushNotification";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDPCPushNotification> {
        match value {
            1 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_MATCH_STARTING),
            10 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM),
            11 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM),
            12 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH),
            13 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH),
            20 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_LEAGUE_RESULT),
            30 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE),
            31 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_RESULT),
            40 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED),
            41 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY),
            42 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDPCPushNotification> {
        match str {
            "DPC_PUSH_NOTIFICATION_MATCH_STARTING" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_MATCH_STARTING),
            "DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM),
            "DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM),
            "DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH),
            "DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH),
            "DPC_PUSH_NOTIFICATION_LEAGUE_RESULT" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_LEAGUE_RESULT),
            "DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE),
            "DPC_PUSH_NOTIFICATION_PREDICTION_RESULT" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_RESULT),
            "DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED),
            "DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY),
            "DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDPCPushNotification] = &[
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_MATCH_STARTING,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_LEAGUE_RESULT,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_RESULT,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS,
    ];
}

impl ::protobuf::EnumFull for EDPCPushNotification {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDPCPushNotification").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_MATCH_STARTING => 0,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM => 1,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM => 2,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH => 3,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH => 4,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_LEAGUE_RESULT => 5,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE => 6,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_RESULT => 7,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED => 8,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY => 9,
            EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EDPCPushNotification {
    fn default() -> Self {
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_MATCH_STARTING
    }
}

impl EDPCPushNotification {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDPCPushNotification>("EDPCPushNotification")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EEventActionScoreMode)
pub enum EEventActionScoreMode {
    // @@protoc_insertion_point(enum_value:dota.EEventActionScoreMode.k_eEventActionScoreMode_Add)
    k_eEventActionScoreMode_Add = 0,
    // @@protoc_insertion_point(enum_value:dota.EEventActionScoreMode.k_eEventActionScoreMode_Min)
    k_eEventActionScoreMode_Min = 1,
}

impl ::protobuf::Enum for EEventActionScoreMode {
    const NAME: &'static str = "EEventActionScoreMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EEventActionScoreMode> {
        match value {
            0 => ::std::option::Option::Some(EEventActionScoreMode::k_eEventActionScoreMode_Add),
            1 => ::std::option::Option::Some(EEventActionScoreMode::k_eEventActionScoreMode_Min),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EEventActionScoreMode> {
        match str {
            "k_eEventActionScoreMode_Add" => ::std::option::Option::Some(EEventActionScoreMode::k_eEventActionScoreMode_Add),
            "k_eEventActionScoreMode_Min" => ::std::option::Option::Some(EEventActionScoreMode::k_eEventActionScoreMode_Min),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EEventActionScoreMode] = &[
        EEventActionScoreMode::k_eEventActionScoreMode_Add,
        EEventActionScoreMode::k_eEventActionScoreMode_Min,
    ];
}

impl ::protobuf::EnumFull for EEventActionScoreMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EEventActionScoreMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EEventActionScoreMode {
    fn default() -> Self {
        EEventActionScoreMode::k_eEventActionScoreMode_Add
    }
}

impl EEventActionScoreMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EEventActionScoreMode>("EEventActionScoreMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EPlayerChallengeHistoryType)
pub enum EPlayerChallengeHistoryType {
    // @@protoc_insertion_point(enum_value:dota.EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_Invalid)
    k_EPlayerChallengeHistoryType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:dota.EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_KillEater)
    k_EPlayerChallengeHistoryType_KillEater = 1,
    // @@protoc_insertion_point(enum_value:dota.EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_DotaPlusRelic)
    k_EPlayerChallengeHistoryType_DotaPlusRelic = 2,
    // @@protoc_insertion_point(enum_value:dota.EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge)
    k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge = 3,
    // @@protoc_insertion_point(enum_value:dota.EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_InGameEventChallenge)
    k_EPlayerChallengeHistoryType_InGameEventChallenge = 4,
    // @@protoc_insertion_point(enum_value:dota.EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_GuildContract)
    k_EPlayerChallengeHistoryType_GuildContract = 5,
}

impl ::protobuf::Enum for EPlayerChallengeHistoryType {
    const NAME: &'static str = "EPlayerChallengeHistoryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPlayerChallengeHistoryType> {
        match value {
            0 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid),
            1 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_KillEater),
            2 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusRelic),
            3 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge),
            4 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_InGameEventChallenge),
            5 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_GuildContract),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPlayerChallengeHistoryType> {
        match str {
            "k_EPlayerChallengeHistoryType_Invalid" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid),
            "k_EPlayerChallengeHistoryType_KillEater" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_KillEater),
            "k_EPlayerChallengeHistoryType_DotaPlusRelic" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusRelic),
            "k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge),
            "k_EPlayerChallengeHistoryType_InGameEventChallenge" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_InGameEventChallenge),
            "k_EPlayerChallengeHistoryType_GuildContract" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_GuildContract),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPlayerChallengeHistoryType] = &[
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_KillEater,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusRelic,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_InGameEventChallenge,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_GuildContract,
    ];
}

impl ::protobuf::EnumFull for EPlayerChallengeHistoryType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPlayerChallengeHistoryType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPlayerChallengeHistoryType {
    fn default() -> Self {
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid
    }
}

impl EPlayerChallengeHistoryType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPlayerChallengeHistoryType>("EPlayerChallengeHistoryType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EOverwatchReportReason)
pub enum EOverwatchReportReason {
    // @@protoc_insertion_point(enum_value:dota.EOverwatchReportReason.k_EOverwatchReportReason_Unknown)
    k_EOverwatchReportReason_Unknown = 0,
    // @@protoc_insertion_point(enum_value:dota.EOverwatchReportReason.k_EOverwatchReportReason_Cheating)
    k_EOverwatchReportReason_Cheating = 1,
    // @@protoc_insertion_point(enum_value:dota.EOverwatchReportReason.k_EOverwatchReportReason_Feeding)
    k_EOverwatchReportReason_Feeding = 2,
    // @@protoc_insertion_point(enum_value:dota.EOverwatchReportReason.k_EOverwatchReportReason_Griefing)
    k_EOverwatchReportReason_Griefing = 3,
    // @@protoc_insertion_point(enum_value:dota.EOverwatchReportReason.k_EOverwatchReportReason_Suspicious)
    k_EOverwatchReportReason_Suspicious = 4,
    // @@protoc_insertion_point(enum_value:dota.EOverwatchReportReason.k_EOverwatchReportReason_AbilityAbuse)
    k_EOverwatchReportReason_AbilityAbuse = 5,
}

impl ::protobuf::Enum for EOverwatchReportReason {
    const NAME: &'static str = "EOverwatchReportReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOverwatchReportReason> {
        match value {
            0 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Unknown),
            1 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Cheating),
            2 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Feeding),
            3 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Griefing),
            4 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Suspicious),
            5 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_AbilityAbuse),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOverwatchReportReason> {
        match str {
            "k_EOverwatchReportReason_Unknown" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Unknown),
            "k_EOverwatchReportReason_Cheating" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Cheating),
            "k_EOverwatchReportReason_Feeding" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Feeding),
            "k_EOverwatchReportReason_Griefing" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Griefing),
            "k_EOverwatchReportReason_Suspicious" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Suspicious),
            "k_EOverwatchReportReason_AbilityAbuse" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_AbilityAbuse),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOverwatchReportReason] = &[
        EOverwatchReportReason::k_EOverwatchReportReason_Unknown,
        EOverwatchReportReason::k_EOverwatchReportReason_Cheating,
        EOverwatchReportReason::k_EOverwatchReportReason_Feeding,
        EOverwatchReportReason::k_EOverwatchReportReason_Griefing,
        EOverwatchReportReason::k_EOverwatchReportReason_Suspicious,
        EOverwatchReportReason::k_EOverwatchReportReason_AbilityAbuse,
    ];
}

impl ::protobuf::EnumFull for EOverwatchReportReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EOverwatchReportReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EOverwatchReportReason {
    fn default() -> Self {
        EOverwatchReportReason::k_EOverwatchReportReason_Unknown
    }
}

impl EOverwatchReportReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EOverwatchReportReason>("EOverwatchReportReason")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17dota_shared_enums.proto\x12\x04dota\"\xa8\x02\n\x18CDOTAClientHard\
    wareSpecs\x12-\n\x12logical_processors\x18\x01\x20\x01(\rR\x11logicalPro\
    cessors\x121\n\x15cpu_cycles_per_second\x18\x02\x20\x01(\x06R\x12cpuCycl\
    esPerSecond\x122\n\x15total_physical_memory\x18\x03\x20\x01(\x06R\x13tot\
    alPhysicalMemory\x12\x1f\n\x0cis_64_bit_os\x18\x04\x20\x01(\x08R\tis64Bi\
    tOs\x12-\n\x12upload_measurement\x18\x05\x20\x01(\x04R\x11uploadMeasurem\
    ent\x12&\n\x0fprefer_not_host\x18\x06\x20\x01(\x08R\rpreferNotHost\"\xd2\
    \x04\n\rCDOTASaveGame\x12\x19\n\x08match_id\x18\x05\x20\x01(\x04R\x07mat\
    chId\x12\x1b\n\tsave_time\x18\x02\x20\x01(\rR\x08saveTime\x124\n\x07play\
    ers\x18\x03\x20\x03(\x0b2\x1a.dota.CDOTASaveGame.PlayerR\x07players\x12G\
    \n\x0esave_instances\x18\x04\x20\x03(\x0b2\x20.dota.CDOTASaveGame.SaveIn\
    stanceR\rsaveInstances\x1aX\n\x06Player\x12&\n\x04team\x18\x01\x20\x01(\
    \x0e2\x12.dota.DOTA_GC_TEAMR\x04team\x12\x12\n\x04name\x18\x02\x20\x01(\
    \tR\x04name\x12\x12\n\x04hero\x18\x03\x20\x01(\tR\x04hero\x1a\xaf\x02\n\
    \x0cSaveInstance\x12\x1b\n\tgame_time\x18\x02\x20\x01(\rR\x08gameTime\
    \x12\x1f\n\x0bteam1_score\x18\x03\x20\x01(\rR\nteam1Score\x12\x1f\n\x0bt\
    eam2_score\x18\x04\x20\x01(\rR\nteam2Score\x12[\n\x10player_positions\
    \x18\x05\x20\x03(\x0b20.dota.CDOTASaveGame.SaveInstance.PlayerPositionsR\
    \x0fplayerPositions\x12\x17\n\x07save_id\x18\x06\x20\x01(\rR\x06saveId\
    \x12\x1b\n\tsave_time\x18\x07\x20\x01(\rR\x08saveTime\x1a-\n\x0fPlayerPo\
    sitions\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x02\
    \x20\x01(\x02R\x01y\"\xb1\x19\n\x16CMsgDOTACombatLogEntry\x12.\n\x04type\
    \x18\x01\x20\x01(\x0e2\x1a.dota.DOTA_COMBATLOG_TYPESR\x04type\x12\x1f\n\
    \x0btarget_name\x18\x02\x20\x01(\rR\ntargetName\x12,\n\x12target_source_\
    name\x18\x03\x20\x01(\rR\x10targetSourceName\x12#\n\rattacker_name\x18\
    \x04\x20\x01(\rR\x0cattackerName\x12,\n\x12damage_source_name\x18\x05\
    \x20\x01(\rR\x10damageSourceName\x12%\n\x0einflictor_name\x18\x06\x20\
    \x01(\rR\rinflictorName\x120\n\x14is_attacker_illusion\x18\x07\x20\x01(\
    \x08R\x12isAttackerIllusion\x12(\n\x10is_attacker_hero\x18\x08\x20\x01(\
    \x08R\x0eisAttackerHero\x12,\n\x12is_target_illusion\x18\t\x20\x01(\x08R\
    \x10isTargetIllusion\x12$\n\x0eis_target_hero\x18\n\x20\x01(\x08R\x0cisT\
    argetHero\x12,\n\x12is_visible_radiant\x18\x0b\x20\x01(\x08R\x10isVisibl\
    eRadiant\x12&\n\x0fis_visible_dire\x18\x0c\x20\x01(\x08R\risVisibleDire\
    \x12\x14\n\x05value\x18\r\x20\x01(\rR\x05value\x12\x16\n\x06health\x18\
    \x0e\x20\x01(\x05R\x06health\x12\x1c\n\ttimestamp\x18\x0f\x20\x01(\x02R\
    \ttimestamp\x12#\n\rstun_duration\x18\x10\x20\x01(\x02R\x0cstunDuration\
    \x12#\n\rslow_duration\x18\x11\x20\x01(\x02R\x0cslowDuration\x12/\n\x14i\
    s_ability_toggle_on\x18\x12\x20\x01(\x08R\x11isAbilityToggleOn\x121\n\
    \x15is_ability_toggle_off\x18\x13\x20\x01(\x08R\x12isAbilityToggleOff\
    \x12#\n\rability_level\x18\x14\x20\x01(\rR\x0cabilityLevel\x12\x1d\n\nlo\
    cation_x\x18\x15\x20\x01(\x02R\tlocationX\x12\x1d\n\nlocation_y\x18\x16\
    \x20\x01(\x02R\tlocationY\x12\x1f\n\x0bgold_reason\x18\x17\x20\x01(\rR\n\
    goldReason\x12#\n\rtimestamp_raw\x18\x18\x20\x01(\x02R\x0ctimestampRaw\
    \x12+\n\x11modifier_duration\x18\x19\x20\x01(\x02R\x10modifierDuration\
    \x12\x1b\n\txp_reason\x18\x1a\x20\x01(\rR\x08xpReason\x12\x1b\n\tlast_hi\
    ts\x18\x1b\x20\x01(\rR\x08lastHits\x12#\n\rattacker_team\x18\x1c\x20\x01\
    (\rR\x0cattackerTeam\x12\x1f\n\x0btarget_team\x18\x1d\x20\x01(\rR\ntarge\
    tTeam\x12(\n\x10obs_wards_placed\x18\x1e\x20\x01(\rR\x0eobsWardsPlaced\
    \x12%\n\x0eassist_player0\x18\x1f\x20\x01(\rR\rassistPlayer0\x12%\n\x0ea\
    ssist_player1\x18\x20\x20\x01(\rR\rassistPlayer1\x12%\n\x0eassist_player\
    2\x18!\x20\x01(\rR\rassistPlayer2\x12%\n\x0eassist_player3\x18\"\x20\x01\
    (\rR\rassistPlayer3\x12\x1f\n\x0bstack_count\x18#\x20\x01(\rR\nstackCoun\
    t\x12'\n\x0fhidden_modifier\x18$\x20\x01(\x08R\x0ehiddenModifier\x12,\n\
    \x12is_target_building\x18%\x20\x01(\x08R\x10isTargetBuilding\x12*\n\x11\
    neutral_camp_type\x18&\x20\x01(\rR\x0fneutralCampType\x12\x1b\n\trune_ty\
    pe\x18'\x20\x01(\rR\x08runeType\x12%\n\x0eassist_players\x18(\x20\x03(\
    \x05R\rassistPlayers\x12\x20\n\x0cis_heal_save\x18)\x20\x01(\x08R\nisHea\
    lSave\x12.\n\x13is_ultimate_ability\x18*\x20\x01(\x08R\x11isUltimateAbil\
    ity\x12.\n\x13attacker_hero_level\x18+\x20\x01(\rR\x11attackerHeroLevel\
    \x12*\n\x11target_hero_level\x18,\x20\x01(\rR\x0ftargetHeroLevel\x12\x10\
    \n\x03xpm\x18-\x20\x01(\rR\x03xpm\x12\x10\n\x03gpm\x18.\x20\x01(\rR\x03g\
    pm\x12%\n\x0eevent_location\x18/\x20\x01(\rR\reventLocation\x12$\n\x0eta\
    rget_is_self\x180\x20\x01(\x08R\x0ctargetIsSelf\x12\x1f\n\x0bdamage_type\
    \x181\x20\x01(\rR\ndamageType\x123\n\x15invisibility_modifier\x182\x20\
    \x01(\x08R\x14invisibilityModifier\x12'\n\x0fdamage_category\x183\x20\
    \x01(\rR\x0edamageCategory\x12\x1a\n\x08networth\x184\x20\x01(\rR\x08net\
    worth\x12#\n\rbuilding_type\x185\x20\x01(\rR\x0cbuildingType\x12:\n\x19m\
    odifier_elapsed_duration\x186\x20\x01(\x02R\x17modifierElapsedDuration\
    \x12)\n\x10silence_modifier\x187\x20\x01(\x08R\x0fsilenceModifier\x12.\n\
    \x13heal_from_lifesteal\x188\x20\x01(\x08R\x11healFromLifesteal\x12'\n\
    \x0fmodifier_purged\x189\x20\x01(\x08R\x0emodifierPurged\x12!\n\x0cspell\
    _evaded\x18:\x20\x01(\x08R\x0bspellEvaded\x12<\n\x1amotion_controller_mo\
    difier\x18;\x20\x01(\x08R\x18motionControllerModifier\x12&\n\x0flong_ran\
    ge_kill\x18<\x20\x01(\x08R\rlongRangeKill\x124\n\x16modifier_purge_abili\
    ty\x18=\x20\x01(\rR\x14modifierPurgeAbility\x12,\n\x12modifier_purge_npc\
    \x18>\x20\x01(\rR\x10modifierPurgeNpc\x12#\n\rroot_modifier\x18?\x20\x01\
    (\x08R\x0crootModifier\x123\n\x16total_unit_death_count\x18@\x20\x01(\rR\
    \x13totalUnitDeathCount\x12#\n\raura_modifier\x18A\x20\x01(\x08R\x0caura\
    Modifier\x122\n\x15armor_debuff_modifier\x18B\x20\x01(\x08R\x13armorDebu\
    ffModifier\x12=\n\x1bno_physical_damage_modifier\x18C\x20\x01(\x08R\x18n\
    oPhysicalDamageModifier\x12)\n\x10modifier_ability\x18D\x20\x01(\rR\x0fm\
    odifierAbility\x12'\n\x0fmodifier_hidden\x18E\x20\x01(\x08R\x0emodifierH\
    idden\x12=\n\x1binflictor_is_stolen_ability\x18F\x20\x01(\x08R\x18inflic\
    torIsStolenAbility\x12(\n\x10kill_eater_event\x18G\x20\x01(\rR\x0ekillEa\
    terEvent\x12*\n\x11unit_status_label\x18H\x20\x01(\rR\x0funitStatusLabel\
    \x124\n\x16spell_generated_attack\x18I\x20\x01(\x08R\x14spellGeneratedAt\
    tack\x12\"\n\rat_night_time\x18J\x20\x01(\x08R\x0batNightTime\x120\n\x14\
    attacker_has_scepter\x18K\x20\x01(\x08R\x12attackerHasScepter\x12*\n\x11\
    neutral_camp_team\x18L\x20\x01(\rR\x0fneutralCampTeam\x12-\n\x12regenera\
    ted_health\x18M\x20\x01(\x02R\x11regeneratedHealth\x12)\n\x10will_reinca\
    rnate\x18N\x20\x01(\x08R\x0fwillReincarnate\x12!\n\x0cuses_charges\x18O\
    \x20\x01(\x08R\x0busesCharges\"\xfd\x01\n\x15CMsgPendingEventAward\x12'\
    \n\x08event_id\x18\x01\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x12\x1b\
    \n\taction_id\x18\x02\x20\x01(\rR\x08actionId\x12\x20\n\x0cnum_to_grant\
    \x18\x03\x20\x01(\rR\nnumToGrant\x12:\n\nscore_mode\x18\x04\x20\x01(\x0e\
    2\x1b.dota.EEventActionScoreModeR\tscoreMode\x12!\n\x0caudit_action\x18\
    \x05\x20\x01(\rR\x0bauditAction\x12\x1d\n\naudit_data\x18\x06\x20\x01(\
    \x04R\tauditData*\x9a\x05\n\rDOTA_GameMode\x12\x16\n\x12DOTA_GAMEMODE_NO\
    NE\x10\0\x12\x14\n\x10DOTA_GAMEMODE_AP\x10\x01\x12\x14\n\x10DOTA_GAMEMOD\
    E_CM\x10\x02\x12\x14\n\x10DOTA_GAMEMODE_RD\x10\x03\x12\x14\n\x10DOTA_GAM\
    EMODE_SD\x10\x04\x12\x14\n\x10DOTA_GAMEMODE_AR\x10\x05\x12\x17\n\x13DOTA\
    _GAMEMODE_INTRO\x10\x06\x12\x14\n\x10DOTA_GAMEMODE_HW\x10\x07\x12\x1c\n\
    \x18DOTA_GAMEMODE_REVERSE_CM\x10\x08\x12\x16\n\x12DOTA_GAMEMODE_XMAS\x10\
    \t\x12\x1a\n\x16DOTA_GAMEMODE_TUTORIAL\x10\n\x12\x14\n\x10DOTA_GAMEMODE_\
    MO\x10\x0b\x12\x14\n\x10DOTA_GAMEMODE_LP\x10\x0c\x12\x17\n\x13DOTA_GAMEM\
    ODE_POOL1\x10\r\x12\x14\n\x10DOTA_GAMEMODE_FH\x10\x0e\x12\x18\n\x14DOTA_\
    GAMEMODE_CUSTOM\x10\x0f\x12\x14\n\x10DOTA_GAMEMODE_CD\x10\x10\x12\x14\n\
    \x10DOTA_GAMEMODE_BD\x10\x11\x12\x1f\n\x1bDOTA_GAMEMODE_ABILITY_DRAFT\
    \x10\x12\x12\x17\n\x13DOTA_GAMEMODE_EVENT\x10\x13\x12\x16\n\x12DOTA_GAME\
    MODE_ARDM\x10\x14\x12\x18\n\x14DOTA_GAMEMODE_1V1MID\x10\x15\x12\x1b\n\
    \x17DOTA_GAMEMODE_ALL_DRAFT\x10\x16\x12\x17\n\x13DOTA_GAMEMODE_TURBO\x10\
    \x17\x12\x1a\n\x16DOTA_GAMEMODE_MUTATION\x10\x18\x12#\n\x1fDOTA_GAMEMODE\
    _COACHES_CHALLENGE\x10\x19*\xbc\x04\n\x0eDOTA_GameState\x12\x1d\n\x19DOT\
    A_GAMERULES_STATE_INIT\x10\0\x121\n-DOTA_GAMERULES_STATE_WAIT_FOR_PLAYER\
    S_TO_LOAD\x10\x01\x12'\n#DOTA_GAMERULES_STATE_HERO_SELECTION\x10\x02\x12\
    &\n\"DOTA_GAMERULES_STATE_STRATEGY_TIME\x10\x03\x12!\n\x1dDOTA_GAMERULES\
    _STATE_PRE_GAME\x10\x04\x12)\n%DOTA_GAMERULES_STATE_GAME_IN_PROGRESS\x10\
    \x05\x12\"\n\x1eDOTA_GAMERULES_STATE_POST_GAME\x10\x06\x12#\n\x1fDOTA_GA\
    MERULES_STATE_DISCONNECT\x10\x07\x12&\n\"DOTA_GAMERULES_STATE_TEAM_SHOWC\
    ASE\x10\x08\x12*\n&DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP\x10\t\x12-\n)D\
    OTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD\x10\n\x12'\n#DOTA_GAMERULES_STA\
    TE_SCENARIO_SETUP\x10\x0b\x12%\n!DOTA_GAMERULES_STATE_PLAYER_DRAFT\x10\
    \x0c\x12\x1d\n\x19DOTA_GAMERULES_STATE_LAST\x10\r*\xa9\x03\n\x0cDOTA_GC_\
    TEAM\x12\x1a\n\x16DOTA_GC_TEAM_GOOD_GUYS\x10\0\x12\x19\n\x15DOTA_GC_TEAM\
    _BAD_GUYS\x10\x01\x12\x1c\n\x18DOTA_GC_TEAM_BROADCASTER\x10\x02\x12\x1a\
    \n\x16DOTA_GC_TEAM_SPECTATOR\x10\x03\x12\x1c\n\x18DOTA_GC_TEAM_PLAYER_PO\
    OL\x10\x04\x12\x17\n\x13DOTA_GC_TEAM_NOTEAM\x10\x05\x12\x19\n\x15DOTA_GC\
    _TEAM_CUSTOM_1\x10\x06\x12\x19\n\x15DOTA_GC_TEAM_CUSTOM_2\x10\x07\x12\
    \x19\n\x15DOTA_GC_TEAM_CUSTOM_3\x10\x08\x12\x19\n\x15DOTA_GC_TEAM_CUSTOM\
    _4\x10\t\x12\x19\n\x15DOTA_GC_TEAM_CUSTOM_5\x10\n\x12\x19\n\x15DOTA_GC_T\
    EAM_CUSTOM_6\x10\x0b\x12\x19\n\x15DOTA_GC_TEAM_CUSTOM_7\x10\x0c\x12\x19\
    \n\x15DOTA_GC_TEAM_CUSTOM_8\x10\r\x12\x19\n\x15DOTA_GC_TEAM_NEUTRALS\x10\
    \x0e*\xa5\n\n\x06EEvent\x12\x11\n\rEVENT_ID_NONE\x10\0\x12\x15\n\x11EVEN\
    T_ID_DIRETIDE\x10\x01\x12\x1c\n\x18EVENT_ID_SPRING_FESTIVAL\x10\x02\x12\
    \x1b\n\x17EVENT_ID_FROSTIVUS_2013\x10\x03\x12\x1c\n\x18EVENT_ID_COMPENDI\
    UM_2014\x10\x04\x12\x1a\n\x16EVENT_ID_NEXON_PC_BANG\x10\x05\x12\x1a\n\
    \x16EVENT_ID_PWRD_DAC_2015\x10\x06\x12\x1b\n\x17EVENT_ID_NEW_BLOOM_2015\
    \x10\x07\x12\x1f\n\x1bEVENT_ID_INTERNATIONAL_2015\x10\x08\x12\x1c\n\x18E\
    VENT_ID_FALL_MAJOR_2015\x10\t\x12\x16\n\x12EVENT_ID_ORACLE_PA\x10\n\x12$\
    \n\x20EVENT_ID_NEW_BLOOM_2015_PREBEAST\x10\x0b\x12\x16\n\x12EVENT_ID_FRO\
    STIVUS\x10\x0c\x12\x1e\n\x1aEVENT_ID_WINTER_MAJOR_2016\x10\r\x12\x1f\n\
    \x1bEVENT_ID_INTERNATIONAL_2016\x10\x0e\x12\x1c\n\x18EVENT_ID_FALL_MAJOR\
    _2016\x10\x0f\x12\x1e\n\x1aEVENT_ID_WINTER_MAJOR_2017\x10\x10\x12\x1b\n\
    \x17EVENT_ID_NEW_BLOOM_2017\x10\x11\x12\x1f\n\x1bEVENT_ID_INTERNATIONAL_\
    2017\x10\x12\x12\x1e\n\x1aEVENT_ID_PLUS_SUBSCRIPTION\x10\x13\x12\x1d\n\
    \x19EVENT_ID_SINGLES_DAY_2017\x10\x14\x12\x1b\n\x17EVENT_ID_FROSTIVUS_20\
    17\x10\x15\x12\x1f\n\x1bEVENT_ID_INTERNATIONAL_2018\x10\x16\x12\x1b\n\
    \x17EVENT_ID_FROSTIVUS_2018\x10\x17\x12\x1b\n\x17EVENT_ID_NEW_BLOOM_2019\
    \x10\x18\x12\x1f\n\x1bEVENT_ID_INTERNATIONAL_2019\x10\x19\x12\"\n\x1eEVE\
    NT_ID_NEW_PLAYER_EXPERIENCE\x10\x1a\x12\x1b\n\x17EVENT_ID_FROSTIVUS_2019\
    \x10\x1b\x12\x1b\n\x17EVENT_ID_NEW_BLOOM_2020\x10\x1c\x12\x1f\n\x1bEVENT\
    _ID_INTERNATIONAL_2020\x10\x1d\x12\x18\n\x14EVENT_ID_TEAM_FANDOM\x10\x1e\
    \x12\x1a\n\x16EVENT_ID_DIRETIDE_2020\x10\x1f\x12\x18\n\x14EVENT_ID_SPRIN\
    G_2021\x10\x20\x12\x16\n\x12EVENT_ID_FALL_2021\x10!\x12\"\n\x1eEVENT_ID_\
    TEAM_FANDOM_FALL_2021\x10\"\x12!\n\x1dEVENT_ID_TEAM_2021_2022_TOUR2\x10#\
    \x12\x1f\n\x1bEVENT_ID_INTERNATIONAL_2022\x10$\x12!\n\x1dEVENT_ID_TEAM_2\
    021_2022_TOUR3\x10%\x12$\n\x20EVENT_ID_TEAM_INTERNATIONAL_2022\x10&\x12\
    \x1d\n\x19EVENT_ID_PERMANENT_GRANTS\x10'\x12&\n\"EVENT_ID_MUERTA_RELEASE\
    _SPRING2023\x10(\x12\x1c\n\x18EVENT_ID_TEAM_2023_TOUR1\x10)\x12\x1c\n\
    \x18EVENT_ID_TEAM_2023_TOUR2\x10**\xb7\x02\n\tERankType\x12\x17\n\x13k_E\
    RankType_Invalid\x10\0\x12\x16\n\x12k_ERankType_Casual\x10\x01\x12\x16\n\
    \x12k_ERankType_Ranked\x10\x02\x12\x1c\n\x18k_ERankType_CasualLegacy\x10\
    \x03\x12\x1c\n\x18k_ERankType_RankedLegacy\x10\x04\x12\x1c\n\x18k_ERankT\
    ype_CasualGlicko\x10\x05\x12\x1c\n\x18k_ERankType_RankedGlicko\x10\x06\
    \x12\x1e\n\x1ak_ERankType_CasualRemapped\x10\x07\x12$\n\x20k_ERankType_C\
    asualRemappedGlicko\x10\x08\x12#\n\x1fk_ERankType_CasualShiftedGlicko\
    \x10\t*\xa8\x02\n\x12DOTALeaverStatus_t\x12\x14\n\x10DOTA_LEAVER_NONE\
    \x10\0\x12\x1c\n\x18DOTA_LEAVER_DISCONNECTED\x10\x01\x12%\n!DOTA_LEAVER_\
    DISCONNECTED_TOO_LONG\x10\x02\x12\x19\n\x15DOTA_LEAVER_ABANDONED\x10\x03\
    \x12\x13\n\x0fDOTA_LEAVER_AFK\x10\x04\x12\x1f\n\x1bDOTA_LEAVER_NEVER_CON\
    NECTED\x10\x05\x12(\n$DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG\x10\x06\x12\"\
    \n\x1eDOTA_LEAVER_FAILED_TO_READY_UP\x10\x07\x12\x18\n\x14DOTA_LEAVER_DE\
    CLINED\x10\x08*\x9e\x02\n\x15DOTAConnectionState_t\x12!\n\x1dDOTA_CONNEC\
    TION_STATE_UNKNOWN\x10\0\x12+\n'DOTA_CONNECTION_STATE_NOT_YET_CONNECTED\
    \x10\x01\x12#\n\x1fDOTA_CONNECTION_STATE_CONNECTED\x10\x02\x12&\n\"DOTA_\
    CONNECTION_STATE_DISCONNECTED\x10\x03\x12#\n\x1fDOTA_CONNECTION_STATE_AB\
    ANDONED\x10\x04\x12!\n\x1dDOTA_CONNECTION_STATE_LOADING\x10\x05\x12\x20\
    \n\x1cDOTA_CONNECTION_STATE_FAILED\x10\x06*\x8c\x01\n\rFantasy_Roles\x12\
    \x1a\n\x16FANTASY_ROLE_UNDEFINED\x10\0\x12\x15\n\x11FANTASY_ROLE_CORE\
    \x10\x01\x12\x18\n\x14FANTASY_ROLE_SUPPORT\x10\x02\x12\x18\n\x14FANTASY_\
    ROLE_OFFLANE\x10\x03\x12\x14\n\x10FANTASY_ROLE_MID\x10\x04*\x8a\x01\n\
    \x12Fantasy_Team_Slots\x12\x15\n\x11FANTASY_SLOT_NONE\x10\0\x12\x15\n\
    \x11FANTASY_SLOT_CORE\x10\x01\x12\x18\n\x14FANTASY_SLOT_SUPPORT\x10\x02\
    \x12\x14\n\x10FANTASY_SLOT_ANY\x10\x03\x12\x16\n\x12FANTASY_SLOT_BENCH\
    \x10\x04*\xdd\x02\n\x16Fantasy_Selection_Mode\x12\x1d\n\x19FANTASY_SELEC\
    TION_INVALID\x10\0\x12\x1c\n\x18FANTASY_SELECTION_LOCKED\x10\x01\x12\x1d\
    \n\x19FANTASY_SELECTION_SHUFFLE\x10\x02\x12\x1f\n\x1bFANTASY_SELECTION_F\
    REE_PICK\x10\x03\x12\x1b\n\x17FANTASY_SELECTION_ENDED\x10\x04\x12\x20\n\
    \x1cFANTASY_SELECTION_PRE_SEASON\x10\x05\x12\x1f\n\x1bFANTASY_SELECTION_\
    PRE_DRAFT\x10\x06\x12\x1e\n\x1aFANTASY_SELECTION_DRAFTING\x10\x07\x12$\n\
    \x20FANTASY_SELECTION_REGULAR_SEASON\x10\x08\x12\x20\n\x1cFANTASY_SELECT\
    ION_CARD_BASED\x10\t*\x82\x06\n\x15DOTAChatChannelType_t\x12\x1c\n\x18DO\
    TAChannelType_Regional\x10\0\x12\x1a\n\x16DOTAChannelType_Custom\x10\x01\
    \x12\x19\n\x15DOTAChannelType_Party\x10\x02\x12\x19\n\x15DOTAChannelType\
    _Lobby\x10\x03\x12\x18\n\x14DOTAChannelType_Team\x10\x04\x12\x19\n\x15DO\
    TAChannelType_Guild\x10\x05\x12\x1b\n\x17DOTAChannelType_Fantasy\x10\x06\
    \x12\x1b\n\x17DOTAChannelType_Whisper\x10\x07\x12\x1b\n\x17DOTAChannelTy\
    pe_Console\x10\x08\x12\x17\n\x13DOTAChannelType_Tab\x10\t\x12\x1b\n\x17D\
    OTAChannelType_Invalid\x10\n\x12\x1b\n\x17DOTAChannelType_GameAll\x10\
    \x0b\x12\x1e\n\x1aDOTAChannelType_GameAllies\x10\x0c\x12!\n\x1dDOTAChann\
    elType_GameSpectator\x10\r\x12\x20\n\x1cDOTAChannelType_GameCoaching\x10\
    \x0e\x12\x18\n\x14DOTAChannelType_Cafe\x10\x0f\x12\x1e\n\x1aDOTAChannelT\
    ype_CustomGame\x10\x10\x12\x1b\n\x17DOTAChannelType_Private\x10\x11\x12\
    \x1c\n\x18DOTAChannelType_PostGame\x10\x12\x12\x1d\n\x19DOTAChannelType_\
    BattleCup\x10\x13\x12!\n\x1dDOTAChannelType_HLTVSpectator\x10\x14\x12\
    \x1e\n\x1aDOTAChannelType_GameEvents\x10\x15\x12\x1a\n\x16DOTAChannelTyp\
    e_Trivia\x10\x16\x12\x1d\n\x19DOTAChannelType_NewPlayer\x10\x17\x12#\n\
    \x1fDOTAChannelType_PrivateCoaching\x10\x18*\x90\x01\n\x16EChatSpecialPr\
    ivileges\x12!\n\x1dk_EChatSpecialPrivileges_None\x10\0\x12&\n\"k_EChatSp\
    ecialPrivileges_Moderator\x10\x01\x12+\n'k_EChatSpecialPrivileges_SuperM\
    oderator\x10\x02*\x84\x02\n\x14EProfileCardSlotType\x12\x20\n\x1ck_EProf\
    ileCardSlotType_Empty\x10\0\x12\x1f\n\x1bk_EProfileCardSlotType_Stat\x10\
    \x01\x12!\n\x1dk_EProfileCardSlotType_Trophy\x10\x02\x12\x1f\n\x1bk_EPro\
    fileCardSlotType_Item\x10\x03\x12\x1f\n\x1bk_EProfileCardSlotType_Hero\
    \x10\x04\x12#\n\x1fk_EProfileCardSlotType_Emoticon\x10\x05\x12\x1f\n\x1b\
    k_EProfileCardSlotType_Team\x10\x06*\x95\x01\n\x17EMatchGroupServerStatu\
    s\x12\x20\n\x1ck_EMatchGroupServerStatus_OK\x10\0\x121\n-k_EMatchGroupSe\
    rverStatus_LimitedAvailability\x10\x01\x12%\n!k_EMatchGroupServerStatus_\
    Offline\x10\x02*O\n\x0cDOTA_CM_PICK\x12\x12\n\x0eDOTA_CM_RANDOM\x10\0\
    \x12\x15\n\x11DOTA_CM_GOOD_GUYS\x10\x01\x12\x14\n\x10DOTA_CM_BAD_GUYS\
    \x10\x02*\xb4\x01\n\x16DOTALowPriorityBanType\x12!\n\x1dDOTA_LOW_PRIORIT\
    Y_BAN_ABANDON\x10\0\x12!\n\x1dDOTA_LOW_PRIORITY_BAN_REPORTS\x10\x01\x12+\
    \n'DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON\x10\x02\x12'\n#DOTA_LOW_PRIOR\
    ITY_BAN_PRE_GAME_ROLE\x10\x03*}\n\x13DOTALobbyReadyState\x12\"\n\x1eDOTA\
    LobbyReadyState_UNDECLARED\x10\0\x12\x20\n\x1cDOTALobbyReadyState_ACCEPT\
    ED\x10\x01\x12\x20\n\x1cDOTALobbyReadyState_DECLINED\x10\x02*\xba\x04\n\
    \x13DOTAJoinLobbyResult\x12\x1c\n\x18DOTA_JOIN_RESULT_SUCCESS\x10\0\x12$\
    \n\x20DOTA_JOIN_RESULT_ALREADY_IN_GAME\x10\x01\x12\"\n\x1eDOTA_JOIN_RESU\
    LT_INVALID_LOBBY\x10\x02\x12'\n#DOTA_JOIN_RESULT_INCORRECT_PASSWORD\x10\
    \x03\x12\"\n\x1eDOTA_JOIN_RESULT_ACCESS_DENIED\x10\x04\x12\"\n\x1eDOTA_J\
    OIN_RESULT_GENERIC_ERROR\x10\x05\x12&\n\"DOTA_JOIN_RESULT_INCORRECT_VERS\
    ION\x10\x06\x12\"\n\x1eDOTA_JOIN_RESULT_IN_TEAM_PARTY\x10\x07\x12#\n\x1f\
    DOTA_JOIN_RESULT_NO_LOBBY_FOUND\x10\x08\x12\x1f\n\x1bDOTA_JOIN_RESULT_LO\
    BBY_FULL\x10\t\x122\n.DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION\x10\
    \n\x12\x1c\n\x18DOTA_JOIN_RESULT_TIMEOUT\x10\x0b\x12)\n%DOTA_JOIN_RESULT\
    _CUSTOM_GAME_COOLDOWN\x10\x0c\x12\x19\n\x15DOTA_JOIN_RESULT_BUSY\x10\r\
    \x12\x20\n\x1cDOTA_JOIN_RESULT_NO_PLAYTIME\x10\x0e*q\n\x1aDOTASelectionP\
    riorityRules\x12'\n#k_DOTASelectionPriorityRules_Manual\x10\0\x12*\n&k_D\
    OTASelectionPriorityRules_Automatic\x10\x01*\xf6\x01\n\x1bDOTASelectionP\
    riorityChoice\x12)\n%k_DOTASelectionPriorityChoice_Invalid\x10\0\x12+\n'\
    k_DOTASelectionPriorityChoice_FirstPick\x10\x01\x12,\n(k_DOTASelectionPr\
    iorityChoice_SecondPick\x10\x02\x12)\n%k_DOTASelectionPriorityChoice_Rad\
    iant\x10\x03\x12&\n\"k_DOTASelectionPriorityChoice_Dire\x10\x04*b\n\rDOT\
    AMatchVote\x12\x19\n\x15DOTAMatchVote_INVALID\x10\0\x12\x1a\n\x16DOTAMat\
    chVote_POSITIVE\x10\x01\x12\x1a\n\x16DOTAMatchVote_NEGATIVE\x10\x02*x\n\
    \x13DOTALobbyVisibility\x12\x1e\n\x1aDOTALobbyVisibility_Public\x10\0\
    \x12\x1f\n\x1bDOTALobbyVisibility_Friends\x10\x01\x12\x20\n\x1cDOTALobby\
    Visibility_Unlisted\x10\x02*\x8b\x01\n\x12EDOTAPlayerMMRType\x12\x20\n\
    \x1ck_EDOTAPlayerMMRType_Invalid\x10\0\x12&\n\"k_EDOTAPlayerMMRType_Gene\
    ralHidden\x10\x01\x12+\n'k_EDOTAPlayerMMRType_GeneralCompetitive\x10\x03\
    *s\n\x11EDOTAMMRBoostType\x12\x1c\n\x18k_EDOTAMMRBoostType_None\x10\0\
    \x12\x1e\n\x1ak_EDOTAMMRBoostType_Leader\x10\x01\x12\x20\n\x1ck_EDOTAMMR\
    BoostType_Follower\x10\x02*\xd0\x01\n\tMatchType\x12\x15\n\x11MATCH_TYPE\
    _CASUAL\x10\0\x12\x18\n\x14MATCH_TYPE_COOP_BOTS\x10\x01\x12\x1a\n\x16MAT\
    CH_TYPE_COMPETITIVE\x10\x04\x12\x1e\n\x1aMATCH_TYPE_WEEKEND_TOURNEY\x10\
    \x05\x12\x14\n\x10MATCH_TYPE_EVENT\x10\x07\x12\x20\n\x1cMATCH_TYPE_COACH\
    ES_CHALLENGE\x10\x0c\x12\x1e\n\x1aMATCH_TYPE_NEW_PLAYER_POOL\x10\x0e*\
    \x9c\x02\n\x11DOTABotDifficulty\x12\x1a\n\x16BOT_DIFFICULTY_PASSIVE\x10\
    \0\x12\x17\n\x13BOT_DIFFICULTY_EASY\x10\x01\x12\x19\n\x15BOT_DIFFICULTY_\
    MEDIUM\x10\x02\x12\x17\n\x13BOT_DIFFICULTY_HARD\x10\x03\x12\x19\n\x15BOT\
    _DIFFICULTY_UNFAIR\x10\x04\x12\x1a\n\x16BOT_DIFFICULTY_INVALID\x10\x05\
    \x12\x19\n\x15BOT_DIFFICULTY_EXTRA1\x10\x06\x12\x19\n\x15BOT_DIFFICULTY_\
    EXTRA2\x10\x07\x12\x19\n\x15BOT_DIFFICULTY_EXTRA3\x10\x08\x12\x16\n\x12B\
    OT_DIFFICULTY_NPX\x10\t*\xae\x06\n\rDOTA_BOT_MODE\x12\x16\n\x12DOTA_BOT_\
    MODE_NONE\x10\0\x12\x18\n\x14DOTA_BOT_MODE_LANING\x10\x01\x12\x18\n\x14D\
    OTA_BOT_MODE_ATTACK\x10\x02\x12\x16\n\x12DOTA_BOT_MODE_ROAM\x10\x03\x12\
    \x19\n\x15DOTA_BOT_MODE_RETREAT\x10\x04\x12\x1d\n\x19DOTA_BOT_MODE_SECRE\
    T_SHOP\x10\x05\x12\x1b\n\x17DOTA_BOT_MODE_SIDE_SHOP\x10\x06\x12\x16\n\
    \x12DOTA_BOT_MODE_RUNE\x10\x07\x12\x20\n\x1cDOTA_BOT_MODE_PUSH_TOWER_TOP\
    \x10\x08\x12\x20\n\x1cDOTA_BOT_MODE_PUSH_TOWER_MID\x10\t\x12\x20\n\x1cDO\
    TA_BOT_MODE_PUSH_TOWER_BOT\x10\n\x12\"\n\x1eDOTA_BOT_MODE_DEFEND_TOWER_T\
    OP\x10\x0b\x12\"\n\x1eDOTA_BOT_MODE_DEFEND_TOWER_MID\x10\x0c\x12\"\n\x1e\
    DOTA_BOT_MODE_DEFEND_TOWER_BOT\x10\r\x12\x1a\n\x16DOTA_BOT_MODE_ASSEMBLE\
    \x10\x0e\x12&\n\"DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS\x10\x0f\x12\x1b\n\
    \x17DOTA_BOT_MODE_TEAM_ROAM\x10\x10\x12\x16\n\x12DOTA_BOT_MODE_FARM\x10\
    \x11\x12\x1d\n\x19DOTA_BOT_MODE_DEFEND_ALLY\x10\x12\x12#\n\x1fDOTA_BOT_M\
    ODE_EVASIVE_MANEUVERS\x10\x13\x12\x18\n\x14DOTA_BOT_MODE_ROSHAN\x10\x14\
    \x12\x16\n\x12DOTA_BOT_MODE_ITEM\x10\x15\x12\x16\n\x12DOTA_BOT_MODE_WARD\
    \x10\x16\x12\x1b\n\x17DOTA_BOT_MODE_COMPANION\x10\x17\x12\x1f\n\x1bDOTA_\
    BOT_MODE_TUTORIAL_BOSS\x10\x18\x12\x18\n\x14DOTA_BOT_MODE_MINION\x10\x19\
    \x12\x19\n\x15DOTA_BOT_MODE_OUTPOST\x10\x1a*\xf3\x01\n\x0eMatchLanguages\
    \x12\x1a\n\x16MATCH_LANGUAGE_INVALID\x10\0\x12\x1a\n\x16MATCH_LANGUAGE_E\
    NGLISH\x10\x01\x12\x1a\n\x16MATCH_LANGUAGE_RUSSIAN\x10\x02\x12\x1a\n\x16\
    MATCH_LANGUAGE_CHINESE\x10\x03\x12\x19\n\x15MATCH_LANGUAGE_KOREAN\x10\
    \x04\x12\x1a\n\x16MATCH_LANGUAGE_SPANISH\x10\x05\x12\x1d\n\x19MATCH_LANG\
    UAGE_PORTUGUESE\x10\x06\x12\x1b\n\x17MATCH_LANGUAGE_ENGLISH2\x10\x07*\
    \xd8\x02\n\x1aETourneyQueueDeadlineState\x12'\n#k_ETourneyQueueDeadlineS\
    tate_Normal\x10\0\x12'\n#k_ETourneyQueueDeadlineState_Missed\x10\x01\x12\
    *\n&k_ETourneyQueueDeadlineState_ExpiredOK\x10\x02\x12+\n'k_ETourneyQueu\
    eDeadlineState_SeekingBye\x10\x03\x122\n.k_ETourneyQueueDeadlineState_El\
    igibleForRefund\x10\x04\x12,\n\x1fk_ETourneyQueueDeadlineState_NA\x10\
    \xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12-\n)k_ETourneyQueueDeadlineS\
    tate_ExpiringSoon\x10e*\xd7\x05\n\rEMatchOutcome\x12\x1b\n\x17k_EMatchOu\
    tcome_Unknown\x10\0\x12\x1e\n\x1ak_EMatchOutcome_RadVictory\x10\x02\x12\
    \x1f\n\x1bk_EMatchOutcome_DireVictory\x10\x03\x12\"\n\x1ek_EMatchOutcome\
    _NeutralVictory\x10\x04\x12\x20\n\x1ck_EMatchOutcome_NoTeamWinner\x10\
    \x05\x12\"\n\x1ek_EMatchOutcome_Custom1Victory\x10\x06\x12\"\n\x1ek_EMat\
    chOutcome_Custom2Victory\x10\x07\x12\"\n\x1ek_EMatchOutcome_Custom3Victo\
    ry\x10\x08\x12\"\n\x1ek_EMatchOutcome_Custom4Victory\x10\t\x12\"\n\x1ek_\
    EMatchOutcome_Custom5Victory\x10\n\x12\"\n\x1ek_EMatchOutcome_Custom6Vic\
    tory\x10\x0b\x12\"\n\x1ek_EMatchOutcome_Custom7Victory\x10\x0c\x12\"\n\
    \x1ek_EMatchOutcome_Custom8Victory\x10\r\x123\n/k_EMatchOutcome_NotScore\
    d_PoorNetworkConditions\x10@\x12$\n\x20k_EMatchOutcome_NotScored_Leaver\
    \x10A\x12)\n%k_EMatchOutcome_NotScored_ServerCrash\x10B\x12*\n&k_EMatchO\
    utcome_NotScored_NeverStarted\x10C\x12&\n\"k_EMatchOutcome_NotScored_Can\
    celed\x10D\x12(\n$k_EMatchOutcome_NotScored_Suspicious\x10E*\x86\x01\n\t\
    ELaneType\x12\x15\n\x11LANE_TYPE_UNKNOWN\x10\0\x12\x12\n\x0eLANE_TYPE_SA\
    FE\x10\x01\x12\x11\n\rLANE_TYPE_OFF\x10\x02\x12\x11\n\rLANE_TYPE_MID\x10\
    \x03\x12\x14\n\x10LANE_TYPE_JUNGLE\x10\x04\x12\x12\n\x0eLANE_TYPE_ROAM\
    \x10\x05*\x8c\x03\n\nEBadgeType\x12\x1c\n\x18k_EBadgeType_TI7_Midweek\
    \x10\x01\x12\x1b\n\x17k_EBadgeType_TI7_Finals\x10\x02\x12\x1d\n\x19k_EBa\
    dgeType_TI7_AllEvent\x10\x03\x12\x1c\n\x18k_EBadgeType_TI8_Midweek\x10\
    \x04\x12\x1b\n\x17k_EBadgeType_TI8_Finals\x10\x05\x12\x1d\n\x19k_EBadgeT\
    ype_TI8_AllEvent\x10\x06\x12\x15\n\x11k_EBadgeType_TI10\x10\x07\x12\"\n\
    \x1ek_EBadgeType_TI11_PlayoffsDay1\x10\x08\x12\"\n\x1ek_EBadgeType_TI11_\
    PlayoffsDay2\x10\t\x12\"\n\x1ek_EBadgeType_TI11_PlayoffsDay3\x10\n\x12\"\
    \n\x1ek_EBadgeType_TI11_PlayoffsDay4\x10\x0b\x12#\n\x1fk_EBadgeType_TI11\
    _FinalsWeekend\x10\x0c*\xd4\x01\n\rELeagueStatus\x12\x17\n\x13LEAGUE_STA\
    TUS_UNSET\x10\0\x12\x1d\n\x19LEAGUE_STATUS_UNSUBMITTED\x10\x01\x12\x1b\n\
    \x17LEAGUE_STATUS_SUBMITTED\x10\x02\x12\x1a\n\x16LEAGUE_STATUS_ACCEPTED\
    \x10\x03\x12\x1a\n\x16LEAGUE_STATUS_REJECTED\x10\x04\x12\x1b\n\x17LEAGUE\
    _STATUS_CONCLUDED\x10\x05\x12\x19\n\x15LEAGUE_STATUS_DELETED\x10\x06*\
    \xb2\x01\n\rELeagueRegion\x12\x17\n\x13LEAGUE_REGION_UNSET\x10\0\x12\x14\
    \n\x10LEAGUE_REGION_NA\x10\x01\x12\x14\n\x10LEAGUE_REGION_SA\x10\x02\x12\
    \x15\n\x11LEAGUE_REGION_WEU\x10\x03\x12\x15\n\x11LEAGUE_REGION_EEU\x10\
    \x04\x12\x17\n\x13LEAGUE_REGION_CHINA\x10\x05\x12\x15\n\x11LEAGUE_REGION\
    _SEA\x10\x06*\xac\x02\n\x0bELeagueTier\x12\x15\n\x11LEAGUE_TIER_UNSET\
    \x10\0\x12\x17\n\x13LEAGUE_TIER_AMATEUR\x10\x01\x12\x1c\n\x18LEAGUE_TIER\
    _PROFESSIONAL\x10\x02\x12\x15\n\x11LEAGUE_TIER_MINOR\x10\x03\x12\x15\n\
    \x11LEAGUE_TIER_MAJOR\x10\x04\x12\x1d\n\x19LEAGUE_TIER_INTERNATIONAL\x10\
    \x05\x12\x1d\n\x19LEAGUE_TIER_DPC_QUALIFIER\x10\x06\x12$\n\x20LEAGUE_TIE\
    R_DPC_LEAGUE_QUALIFIER\x10\x07\x12\x1a\n\x16LEAGUE_TIER_DPC_LEAGUE\x10\
    \x08\x12!\n\x1dLEAGUE_TIER_DPC_LEAGUE_FINALS\x10\t*|\n\x13ELeagueTierCat\
    egory\x12\x20\n\x1cLEAGUE_TIER_CATEGORY_AMATEUR\x10\x01\x12%\n!LEAGUE_TI\
    ER_CATEGORY_PROFESSIONAL\x10\x02\x12\x1c\n\x18LEAGUE_TIER_CATEGORY_DPC\
    \x10\x03*[\n\x0fELeagueDivision\x12\x19\n\x15LEAGUE_DIVISION_UNSET\x10\0\
    \x12\x15\n\x11LEAGUE_DIVISION_I\x10\x01\x12\x16\n\x12LEAGUE_DIVISION_II\
    \x10\x02*\xab\x01\n\x18ELeagueBroadcastProvider\x12\x1c\n\x18LEAGUE_BROA\
    DCAST_UNKNOWN\x10\0\x12\x1a\n\x16LEAGUE_BROADCAST_STEAM\x10\x01\x12\x1b\
    \n\x17LEAGUE_BROADCAST_TWITCH\x10\x02\x12\x1c\n\x18LEAGUE_BROADCAST_YOUT\
    UBE\x10\x03\x12\x1a\n\x16LEAGUE_BROADCAST_OTHER\x10d*\x86\x01\n\x0cELeag\
    uePhase\x12\x16\n\x12LEAGUE_PHASE_UNSET\x10\0\x12#\n\x1fLEAGUE_PHASE_REG\
    IONAL_QUALIFIER\x10\x01\x12\x1c\n\x18LEAGUE_PHASE_GROUP_STAGE\x10\x02\
    \x12\x1b\n\x17LEAGUE_PHASE_MAIN_EVENT\x10\x03*\xda\x0e\n\x12ELeagueAudit\
    Action\x12\x1f\n\x1bLEAGUE_AUDIT_ACTION_INVALID\x10\0\x12%\n!LEAGUE_AUDI\
    T_ACTION_LEAGUE_CREATE\x10\x01\x12#\n\x1fLEAGUE_AUDIT_ACTION_LEAGUE_EDIT\
    \x10\x02\x12%\n!LEAGUE_AUDIT_ACTION_LEAGUE_DELETE\x10\x03\x12(\n$LEAGUE_\
    AUDIT_ACTION_LEAGUE_ADMIN_ADD\x10\x04\x12+\n'LEAGUE_AUDIT_ACTION_LEAGUE_\
    ADMIN_REVOKE\x10\x05\x12,\n(LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE\x10\
    \x06\x12)\n%LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD\x10\x07\x12,\n(LEAGUE_\
    AUDIT_ACTION_LEAGUE_STREAM_REMOVE\x10\x08\x12,\n(LEAGUE_AUDIT_ACTION_LEA\
    GUE_IMAGE_UPDATED\x10\t\x12,\n(LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED\
    \x10\n\x12(\n$LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED\x10\x0b\x12-\n)LEAGUE\
    _AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL\x10\x0c\x122\n.LEAGUE_AUDIT_ACTION_L\
    EAGUE_ADD_PRIZE_POOL_ITEM\x10\r\x125\n1LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE\
    _PRIZE_POOL_ITEM\x10\x0e\x12*\n&LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START\
    \x10\x0f\x12(\n$LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END\x10\x10\x12/\n+LEAG\
    UE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM\x10\x11\x122\n.LEAGUE_AUDIT_ACTI\
    ON_LEAGUE_REMOVE_INVITED_TEAM\x10\x12\x12-\n)LEAGUE_AUDIT_ACTION_LEAGUE_\
    STATUS_CHANGED\x10\x13\x12*\n&LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT\x10\
    \x14\x12(\n$LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP\x10\x15\x12(\n$LEAGUE_A\
    UDIT_ACTION_NODEGROUP_CREATE\x10d\x12)\n%LEAGUE_AUDIT_ACTION_NODEGROUP_D\
    ESTROY\x10e\x12*\n&LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM\x10f\x12-\n)LE\
    AGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM\x10g\x12/\n+LEAGUE_AUDIT_ACTION_\
    NODEGROUP_SET_ADVANCING\x10h\x12&\n\"LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT\
    \x10i\x12*\n&LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE\x10j\x12+\n'LEAGUE_A\
    UDIT_ACTION_NODEGROUP_COMPLETED\x10k\x129\n5LEAGUE_AUDIT_ACTION_NODEGROU\
    P_SET_SECONDARY_ADVANCING\x10l\x128\n4LEAGUE_AUDIT_ACTION_NODEGROUP_SET_\
    TERTIARY_ADVANCING\x10m\x12$\n\x1fLEAGUE_AUDIT_ACTION_NODE_CREATE\x10\
    \xc8\x01\x12%\n\x20LEAGUE_AUDIT_ACTION_NODE_DESTROY\x10\xc9\x01\x12(\n#L\
    EAGUE_AUDIT_ACTION_NODE_AUTOCREATE\x10\xca\x01\x12&\n!LEAGUE_AUDIT_ACTIO\
    N_NODE_SET_TEAM\x10\xcb\x01\x12+\n&LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_I\
    D\x10\xcc\x01\x12+\n&LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING\x10\xcd\x01\
    \x12&\n!LEAGUE_AUDIT_ACTION_NODE_SET_TIME\x10\xce\x01\x12-\n(LEAGUE_AUDI\
    T_ACTION_NODE_MATCH_COMPLETED\x10\xcf\x01\x12'\n\"LEAGUE_AUDIT_ACTION_NO\
    DE_COMPLETED\x10\xd0\x01\x12\"\n\x1dLEAGUE_AUDIT_ACTION_NODE_EDIT\x10\
    \xd1\x01*\xe7\x0b\n\x14DOTA_COMBATLOG_TYPES\x12#\n\x16DOTA_COMBATLOG_INV\
    ALID\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x19\n\x15DOTA_COMBA\
    TLOG_DAMAGE\x10\0\x12\x17\n\x13DOTA_COMBATLOG_HEAL\x10\x01\x12\x1f\n\x1b\
    DOTA_COMBATLOG_MODIFIER_ADD\x10\x02\x12\"\n\x1eDOTA_COMBATLOG_MODIFIER_R\
    EMOVE\x10\x03\x12\x18\n\x14DOTA_COMBATLOG_DEATH\x10\x04\x12\x1a\n\x16DOT\
    A_COMBATLOG_ABILITY\x10\x05\x12\x17\n\x13DOTA_COMBATLOG_ITEM\x10\x06\x12\
    \x1b\n\x17DOTA_COMBATLOG_LOCATION\x10\x07\x12\x17\n\x13DOTA_COMBATLOG_GO\
    LD\x10\x08\x12\x1d\n\x19DOTA_COMBATLOG_GAME_STATE\x10\t\x12\x15\n\x11DOT\
    A_COMBATLOG_XP\x10\n\x12\x1b\n\x17DOTA_COMBATLOG_PURCHASE\x10\x0b\x12\
    \x1a\n\x16DOTA_COMBATLOG_BUYBACK\x10\x0c\x12\"\n\x1eDOTA_COMBATLOG_ABILI\
    TY_TRIGGER\x10\r\x12\x1e\n\x1aDOTA_COMBATLOG_PLAYERSTATS\x10\x0e\x12\x1c\
    \n\x18DOTA_COMBATLOG_MULTIKILL\x10\x0f\x12\x1d\n\x19DOTA_COMBATLOG_KILLS\
    TREAK\x10\x10\x12%\n!DOTA_COMBATLOG_TEAM_BUILDING_KILL\x10\x11\x12\x1e\n\
    \x1aDOTA_COMBATLOG_FIRST_BLOOD\x10\x12\x12'\n#DOTA_COMBATLOG_MODIFIER_ST\
    ACK_EVENT\x10\x13\x12%\n!DOTA_COMBATLOG_NEUTRAL_CAMP_STACK\x10\x14\x12\
    \x1e\n\x1aDOTA_COMBATLOG_PICKUP_RUNE\x10\x15\x12%\n!DOTA_COMBATLOG_REVEA\
    LED_INVISIBLE\x10\x16\x12\x1d\n\x19DOTA_COMBATLOG_HERO_SAVED\x10\x17\x12\
    \x20\n\x1cDOTA_COMBATLOG_MANA_RESTORED\x10\x18\x12\x1f\n\x1bDOTA_COMBATL\
    OG_HERO_LEVELUP\x10\x19\x12#\n\x1fDOTA_COMBATLOG_BOTTLE_HEAL_ALLY\x10\
    \x1a\x12\x20\n\x1cDOTA_COMBATLOG_ENDGAME_STATS\x10\x1b\x12$\n\x20DOTA_CO\
    MBATLOG_INTERRUPT_CHANNEL\x10\x1c\x12\x1e\n\x1aDOTA_COMBATLOG_ALLIED_GOL\
    D\x10\x1d\x12\x1e\n\x1aDOTA_COMBATLOG_AEGIS_TAKEN\x10\x1e\x12\x1e\n\x1aD\
    OTA_COMBATLOG_MANA_DAMAGE\x10\x1f\x12,\n(DOTA_COMBATLOG_PHYSICAL_DAMAGE_\
    PREVENTED\x10\x20\x12\x20\n\x1cDOTA_COMBATLOG_UNIT_SUMMONED\x10!\x12\x1f\
    \n\x1bDOTA_COMBATLOG_ATTACK_EVADE\x10\"\x12\x1b\n\x17DOTA_COMBATLOG_TREE\
    _CUT\x10#\x12\"\n\x1eDOTA_COMBATLOG_SUCCESSFUL_SCAN\x10$\x12!\n\x1dDOTA_\
    COMBATLOG_END_KILLSTREAK\x10%\x12$\n\x20DOTA_COMBATLOG_BLOODSTONE_CHARGE\
    \x10&\x12\"\n\x1eDOTA_COMBATLOG_CRITICAL_DAMAGE\x10'\x12\x1f\n\x1bDOTA_C\
    OMBATLOG_SPELL_ABSORB\x10(\x12\"\n\x1eDOTA_COMBATLOG_UNIT_TELEPORTED\x10\
    )\x12#\n\x1fDOTA_COMBATLOG_KILL_EATER_EVENT\x10*\x12&\n\"DOTA_COMBATLOG_\
    NEUTRAL_ITEM_EARNED\x10+*u\n\x10EDPCFavoriteType\x12\x15\n\x11FAVORITE_T\
    YPE_ALL\x10\0\x12\x18\n\x14FAVORITE_TYPE_PLAYER\x10\x01\x12\x16\n\x12FAV\
    ORITE_TYPE_TEAM\x10\x02\x12\x18\n\x14FAVORITE_TYPE_LEAGUE\x10\x03*\xa8\
    \x04\n\x14EDPCPushNotification\x12(\n$DPC_PUSH_NOTIFICATION_MATCH_STARTI\
    NG\x10\x01\x12*\n&DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM\x10\n\x12,\n(DP\
    C_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM\x10\x0b\x125\n1DPC_PUSH_NOTIFICAT\
    ION_PLAYER_JOINED_TEAM_AS_COACH\x10\x0c\x123\n/DPC_PUSH_NOTIFICATION_PLA\
    YER_LEFT_TEAM_AS_COACH\x10\r\x12'\n#DPC_PUSH_NOTIFICATION_LEAGUE_RESULT\
    \x10\x14\x126\n2DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE\x10\
    \x1e\x12+\n'DPC_PUSH_NOTIFICATION_PREDICTION_RESULT\x10\x1f\x120\n,DPC_P\
    USH_NOTIFICATION_FANTASY_PLAYER_CLEARED\x10(\x12/\n+DPC_PUSH_NOTIFICATIO\
    N_FANTASY_DAILY_SUMMARY\x10)\x12/\n+DPC_PUSH_NOTIFICATION_FANTASY_FINAL_\
    RESULTS\x10**Y\n\x15EEventActionScoreMode\x12\x1f\n\x1bk_eEventActionSco\
    reMode_Add\x10\0\x12\x1f\n\x1bk_eEventActionScoreMode_Min\x10\x01*\xce\
    \x02\n\x1bEPlayerChallengeHistoryType\x12)\n%k_EPlayerChallengeHistoryTy\
    pe_Invalid\x10\0\x12+\n'k_EPlayerChallengeHistoryType_KillEater\x10\x01\
    \x12/\n+k_EPlayerChallengeHistoryType_DotaPlusRelic\x10\x02\x12=\n9k_EPl\
    ayerChallengeHistoryType_DotaPlusHeroPlayerChallenge\x10\x03\x126\n2k_EP\
    layerChallengeHistoryType_InGameEventChallenge\x10\x04\x12/\n+k_EPlayerC\
    hallengeHistoryType_GuildContract\x10\x05*\x86\x02\n\x16EOverwatchReport\
    Reason\x12$\n\x20k_EOverwatchReportReason_Unknown\x10\0\x12%\n!k_EOverwa\
    tchReportReason_Cheating\x10\x01\x12$\n\x20k_EOverwatchReportReason_Feed\
    ing\x10\x02\x12%\n!k_EOverwatchReportReason_Griefing\x10\x03\x12'\n#k_EO\
    verwatchReportReason_Suspicious\x10\x04\x12)\n%k_EOverwatchReportReason_\
    AbilityAbuse\x10\x05B%Z#github.com/dotabuff/manta/dota;dotaJ\xa8\xeb\x01\
    \n\x07\x12\x05\0\0\xe9\x05\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\
    \x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\
    \x08\x0b\x12\x03\x03\0:\n\n\n\x02\x05\0\x12\x04\x05\0\x20\x01\n\n\n\x03\
    \x05\0\x01\x12\x03\x05\x05\x12\n\x0b\n\x04\x05\0\x02\0\x12\x03\x06\x08\
    \x1f\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\x08\x1a\n\x0c\n\x05\x05\0\
    \x02\0\x02\x12\x03\x06\x1d\x1e\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\x08\
    \x1d\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x08\x18\n\x0c\n\x05\x05\0\
    \x02\x01\x02\x12\x03\x07\x1b\x1c\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\
    \x08\x1d\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x08\x08\x18\n\x0c\n\x05\
    \x05\0\x02\x02\x02\x12\x03\x08\x1b\x1c\n\x0b\n\x04\x05\0\x02\x03\x12\x03\
    \t\x08\x1d\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\t\x08\x18\n\x0c\n\x05\
    \x05\0\x02\x03\x02\x12\x03\t\x1b\x1c\n\x0b\n\x04\x05\0\x02\x04\x12\x03\n\
    \x08\x1d\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\n\x08\x18\n\x0c\n\x05\x05\
    \0\x02\x04\x02\x12\x03\n\x1b\x1c\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x0b\
    \x08\x1d\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0b\x08\x18\n\x0c\n\x05\
    \x05\0\x02\x05\x02\x12\x03\x0b\x1b\x1c\n\x0b\n\x04\x05\0\x02\x06\x12\x03\
    \x0c\x08\x20\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x0c\x08\x1b\n\x0c\n\
    \x05\x05\0\x02\x06\x02\x12\x03\x0c\x1e\x1f\n\x0b\n\x04\x05\0\x02\x07\x12\
    \x03\r\x08\x1d\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\r\x08\x18\n\x0c\n\
    \x05\x05\0\x02\x07\x02\x12\x03\r\x1b\x1c\n\x0b\n\x04\x05\0\x02\x08\x12\
    \x03\x0e\x08%\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x0e\x08\x20\n\x0c\n\
    \x05\x05\0\x02\x08\x02\x12\x03\x0e#$\n\x0b\n\x04\x05\0\x02\t\x12\x03\x0f\
    \x08\x1f\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x0f\x08\x1a\n\x0c\n\x05\x05\
    \0\x02\t\x02\x12\x03\x0f\x1d\x1e\n\x0b\n\x04\x05\0\x02\n\x12\x03\x10\x08\
    $\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\x10\x08\x1e\n\x0c\n\x05\x05\0\x02\
    \n\x02\x12\x03\x10!#\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x11\x08\x1e\n\x0c\
    \n\x05\x05\0\x02\x0b\x01\x12\x03\x11\x08\x18\n\x0c\n\x05\x05\0\x02\x0b\
    \x02\x12\x03\x11\x1b\x1d\n\x0b\n\x04\x05\0\x02\x0c\x12\x03\x12\x08\x1e\n\
    \x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x12\x08\x18\n\x0c\n\x05\x05\0\x02\
    \x0c\x02\x12\x03\x12\x1b\x1d\n\x0b\n\x04\x05\0\x02\r\x12\x03\x13\x08!\n\
    \x0c\n\x05\x05\0\x02\r\x01\x12\x03\x13\x08\x1b\n\x0c\n\x05\x05\0\x02\r\
    \x02\x12\x03\x13\x1e\x20\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x14\x08\x1e\n\
    \x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x14\x08\x18\n\x0c\n\x05\x05\0\x02\
    \x0e\x02\x12\x03\x14\x1b\x1d\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x15\x08\"\
    \n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\x15\x08\x1c\n\x0c\n\x05\x05\0\x02\
    \x0f\x02\x12\x03\x15\x1f!\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x16\x08\x1e\
    \n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\x16\x08\x18\n\x0c\n\x05\x05\0\x02\
    \x10\x02\x12\x03\x16\x1b\x1d\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x17\x08\
    \x1e\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x17\x08\x18\n\x0c\n\x05\x05\0\
    \x02\x11\x02\x12\x03\x17\x1b\x1d\n\x0b\n\x04\x05\0\x02\x12\x12\x03\x18\
    \x08)\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03\x18\x08#\n\x0c\n\x05\x05\0\
    \x02\x12\x02\x12\x03\x18&(\n\x0b\n\x04\x05\0\x02\x13\x12\x03\x19\x08!\n\
    \x0c\n\x05\x05\0\x02\x13\x01\x12\x03\x19\x08\x1b\n\x0c\n\x05\x05\0\x02\
    \x13\x02\x12\x03\x19\x1e\x20\n\x0b\n\x04\x05\0\x02\x14\x12\x03\x1a\x08\
    \x20\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1a\x08\x1a\n\x0c\n\x05\x05\0\
    \x02\x14\x02\x12\x03\x1a\x1d\x1f\n\x0b\n\x04\x05\0\x02\x15\x12\x03\x1b\
    \x08\"\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\x1b\x08\x1c\n\x0c\n\x05\x05\
    \0\x02\x15\x02\x12\x03\x1b\x1f!\n\x0b\n\x04\x05\0\x02\x16\x12\x03\x1c\
    \x08%\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03\x1c\x08\x1f\n\x0c\n\x05\x05\
    \0\x02\x16\x02\x12\x03\x1c\"$\n\x0b\n\x04\x05\0\x02\x17\x12\x03\x1d\x08!\
    \n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03\x1d\x08\x1b\n\x0c\n\x05\x05\0\x02\
    \x17\x02\x12\x03\x1d\x1e\x20\n\x0b\n\x04\x05\0\x02\x18\x12\x03\x1e\x08$\
    \n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03\x1e\x08\x1e\n\x0c\n\x05\x05\0\x02\
    \x18\x02\x12\x03\x1e!#\n\x0b\n\x04\x05\0\x02\x19\x12\x03\x1f\x08-\n\x0c\
    \n\x05\x05\0\x02\x19\x01\x12\x03\x1f\x08'\n\x0c\n\x05\x05\0\x02\x19\x02\
    \x12\x03\x1f*,\n\n\n\x02\x05\x01\x12\x04\"\01\x01\n\n\n\x03\x05\x01\x01\
    \x12\x03\"\x05\x13\n\x0b\n\x04\x05\x01\x02\0\x12\x03#\x08&\n\x0c\n\x05\
    \x05\x01\x02\0\x01\x12\x03#\x08!\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03#$\
    %\n\x0b\n\x04\x05\x01\x02\x01\x12\x03$\x08:\n\x0c\n\x05\x05\x01\x02\x01\
    \x01\x12\x03$\x085\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03$89\n\x0b\n\
    \x04\x05\x01\x02\x02\x12\x03%\x080\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\
    \x03%\x08+\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03%./\n\x0b\n\x04\x05\
    \x01\x02\x03\x12\x03&\x08/\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03&\x08*\
    \n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03&-.\n\x0b\n\x04\x05\x01\x02\x04\
    \x12\x03'\x08*\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03'\x08%\n\x0c\n\x05\
    \x05\x01\x02\x04\x02\x12\x03'()\n\x0b\n\x04\x05\x01\x02\x05\x12\x03(\x08\
    2\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03(\x08-\n\x0c\n\x05\x05\x01\x02\
    \x05\x02\x12\x03(01\n\x0b\n\x04\x05\x01\x02\x06\x12\x03)\x08+\n\x0c\n\
    \x05\x05\x01\x02\x06\x01\x12\x03)\x08&\n\x0c\n\x05\x05\x01\x02\x06\x02\
    \x12\x03))*\n\x0b\n\x04\x05\x01\x02\x07\x12\x03*\x08,\n\x0c\n\x05\x05\
    \x01\x02\x07\x01\x12\x03*\x08'\n\x0c\n\x05\x05\x01\x02\x07\x02\x12\x03**\
    +\n\x0b\n\x04\x05\x01\x02\x08\x12\x03+\x08/\n\x0c\n\x05\x05\x01\x02\x08\
    \x01\x12\x03+\x08*\n\x0c\n\x05\x05\x01\x02\x08\x02\x12\x03+-.\n\x0b\n\
    \x04\x05\x01\x02\t\x12\x03,\x083\n\x0c\n\x05\x05\x01\x02\t\x01\x12\x03,\
    \x08.\n\x0c\n\x05\x05\x01\x02\t\x02\x12\x03,12\n\x0b\n\x04\x05\x01\x02\n\
    \x12\x03-\x087\n\x0c\n\x05\x05\x01\x02\n\x01\x12\x03-\x081\n\x0c\n\x05\
    \x05\x01\x02\n\x02\x12\x03-46\n\x0b\n\x04\x05\x01\x02\x0b\x12\x03.\x081\
    \n\x0c\n\x05\x05\x01\x02\x0b\x01\x12\x03.\x08+\n\x0c\n\x05\x05\x01\x02\
    \x0b\x02\x12\x03..0\n\x0b\n\x04\x05\x01\x02\x0c\x12\x03/\x08/\n\x0c\n\
    \x05\x05\x01\x02\x0c\x01\x12\x03/\x08)\n\x0c\n\x05\x05\x01\x02\x0c\x02\
    \x12\x03/,.\n\x0b\n\x04\x05\x01\x02\r\x12\x030\x08'\n\x0c\n\x05\x05\x01\
    \x02\r\x01\x12\x030\x08!\n\x0c\n\x05\x05\x01\x02\r\x02\x12\x030$&\n\n\n\
    \x02\x05\x02\x12\x043\0C\x01\n\n\n\x03\x05\x02\x01\x12\x033\x05\x11\n\
    \x0b\n\x04\x05\x02\x02\0\x12\x034\x08#\n\x0c\n\x05\x05\x02\x02\0\x01\x12\
    \x034\x08\x1e\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x034!\"\n\x0b\n\x04\x05\
    \x02\x02\x01\x12\x035\x08\"\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x035\x08\
    \x1d\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x035\x20!\n\x0b\n\x04\x05\x02\
    \x02\x02\x12\x036\x08%\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x036\x08\x20\
    \n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x036#$\n\x0b\n\x04\x05\x02\x02\x03\
    \x12\x037\x08#\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x037\x08\x1e\n\x0c\n\
    \x05\x05\x02\x02\x03\x02\x12\x037!\"\n\x0b\n\x04\x05\x02\x02\x04\x12\x03\
    8\x08%\n\x0c\n\x05\x05\x02\x02\x04\x01\x12\x038\x08\x20\n\x0c\n\x05\x05\
    \x02\x02\x04\x02\x12\x038#$\n\x0b\n\x04\x05\x02\x02\x05\x12\x039\x08\x20\
    \n\x0c\n\x05\x05\x02\x02\x05\x01\x12\x039\x08\x1b\n\x0c\n\x05\x05\x02\
    \x02\x05\x02\x12\x039\x1e\x1f\n\x0b\n\x04\x05\x02\x02\x06\x12\x03:\x08\"\
    \n\x0c\n\x05\x05\x02\x02\x06\x01\x12\x03:\x08\x1d\n\x0c\n\x05\x05\x02\
    \x02\x06\x02\x12\x03:\x20!\n\x0b\n\x04\x05\x02\x02\x07\x12\x03;\x08\"\n\
    \x0c\n\x05\x05\x02\x02\x07\x01\x12\x03;\x08\x1d\n\x0c\n\x05\x05\x02\x02\
    \x07\x02\x12\x03;\x20!\n\x0b\n\x04\x05\x02\x02\x08\x12\x03<\x08\"\n\x0c\
    \n\x05\x05\x02\x02\x08\x01\x12\x03<\x08\x1d\n\x0c\n\x05\x05\x02\x02\x08\
    \x02\x12\x03<\x20!\n\x0b\n\x04\x05\x02\x02\t\x12\x03=\x08\"\n\x0c\n\x05\
    \x05\x02\x02\t\x01\x12\x03=\x08\x1d\n\x0c\n\x05\x05\x02\x02\t\x02\x12\
    \x03=\x20!\n\x0b\n\x04\x05\x02\x02\n\x12\x03>\x08#\n\x0c\n\x05\x05\x02\
    \x02\n\x01\x12\x03>\x08\x1d\n\x0c\n\x05\x05\x02\x02\n\x02\x12\x03>\x20\"\
    \n\x0b\n\x04\x05\x02\x02\x0b\x12\x03?\x08#\n\x0c\n\x05\x05\x02\x02\x0b\
    \x01\x12\x03?\x08\x1d\n\x0c\n\x05\x05\x02\x02\x0b\x02\x12\x03?\x20\"\n\
    \x0b\n\x04\x05\x02\x02\x0c\x12\x03@\x08#\n\x0c\n\x05\x05\x02\x02\x0c\x01\
    \x12\x03@\x08\x1d\n\x0c\n\x05\x05\x02\x02\x0c\x02\x12\x03@\x20\"\n\x0b\n\
    \x04\x05\x02\x02\r\x12\x03A\x08#\n\x0c\n\x05\x05\x02\x02\r\x01\x12\x03A\
    \x08\x1d\n\x0c\n\x05\x05\x02\x02\r\x02\x12\x03A\x20\"\n\x0b\n\x04\x05\
    \x02\x02\x0e\x12\x03B\x08#\n\x0c\n\x05\x05\x02\x02\x0e\x01\x12\x03B\x08\
    \x1d\n\x0c\n\x05\x05\x02\x02\x0e\x02\x12\x03B\x20\"\n\n\n\x02\x05\x03\
    \x12\x04E\0q\x01\n\n\n\x03\x05\x03\x01\x12\x03E\x05\x0b\n\x0b\n\x04\x05\
    \x03\x02\0\x12\x03F\x08\x1a\n\x0c\n\x05\x05\x03\x02\0\x01\x12\x03F\x08\
    \x15\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03F\x18\x19\n\x0b\n\x04\x05\x03\
    \x02\x01\x12\x03G\x08\x1e\n\x0c\n\x05\x05\x03\x02\x01\x01\x12\x03G\x08\
    \x19\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03G\x1c\x1d\n\x0b\n\x04\x05\
    \x03\x02\x02\x12\x03H\x08%\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\x03H\x08\
    \x20\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\x03H#$\n\x0b\n\x04\x05\x03\x02\
    \x03\x12\x03I\x08$\n\x0c\n\x05\x05\x03\x02\x03\x01\x12\x03I\x08\x1f\n\
    \x0c\n\x05\x05\x03\x02\x03\x02\x12\x03I\"#\n\x0b\n\x04\x05\x03\x02\x04\
    \x12\x03J\x08%\n\x0c\n\x05\x05\x03\x02\x04\x01\x12\x03J\x08\x20\n\x0c\n\
    \x05\x05\x03\x02\x04\x02\x12\x03J#$\n\x0b\n\x04\x05\x03\x02\x05\x12\x03K\
    \x08#\n\x0c\n\x05\x05\x03\x02\x05\x01\x12\x03K\x08\x1e\n\x0c\n\x05\x05\
    \x03\x02\x05\x02\x12\x03K!\"\n\x0b\n\x04\x05\x03\x02\x06\x12\x03L\x08#\n\
    \x0c\n\x05\x05\x03\x02\x06\x01\x12\x03L\x08\x1e\n\x0c\n\x05\x05\x03\x02\
    \x06\x02\x12\x03L!\"\n\x0b\n\x04\x05\x03\x02\x07\x12\x03M\x08$\n\x0c\n\
    \x05\x05\x03\x02\x07\x01\x12\x03M\x08\x1f\n\x0c\n\x05\x05\x03\x02\x07\
    \x02\x12\x03M\"#\n\x0b\n\x04\x05\x03\x02\x08\x12\x03N\x08(\n\x0c\n\x05\
    \x05\x03\x02\x08\x01\x12\x03N\x08#\n\x0c\n\x05\x05\x03\x02\x08\x02\x12\
    \x03N&'\n\x0b\n\x04\x05\x03\x02\t\x12\x03O\x08%\n\x0c\n\x05\x05\x03\x02\
    \t\x01\x12\x03O\x08\x20\n\x0c\n\x05\x05\x03\x02\t\x02\x12\x03O#$\n\x0b\n\
    \x04\x05\x03\x02\n\x12\x03P\x08\x20\n\x0c\n\x05\x05\x03\x02\n\x01\x12\
    \x03P\x08\x1a\n\x0c\n\x05\x05\x03\x02\n\x02\x12\x03P\x1d\x1f\n\x0b\n\x04\
    \x05\x03\x02\x0b\x12\x03Q\x08.\n\x0c\n\x05\x05\x03\x02\x0b\x01\x12\x03Q\
    \x08(\n\x0c\n\x05\x05\x03\x02\x0b\x02\x12\x03Q+-\n\x0b\n\x04\x05\x03\x02\
    \x0c\x12\x03R\x08\x20\n\x0c\n\x05\x05\x03\x02\x0c\x01\x12\x03R\x08\x1a\n\
    \x0c\n\x05\x05\x03\x02\x0c\x02\x12\x03R\x1d\x1f\n\x0b\n\x04\x05\x03\x02\
    \r\x12\x03S\x08(\n\x0c\n\x05\x05\x03\x02\r\x01\x12\x03S\x08\"\n\x0c\n\
    \x05\x05\x03\x02\r\x02\x12\x03S%'\n\x0b\n\x04\x05\x03\x02\x0e\x12\x03T\
    \x08)\n\x0c\n\x05\x05\x03\x02\x0e\x01\x12\x03T\x08#\n\x0c\n\x05\x05\x03\
    \x02\x0e\x02\x12\x03T&(\n\x0b\n\x04\x05\x03\x02\x0f\x12\x03U\x08&\n\x0c\
    \n\x05\x05\x03\x02\x0f\x01\x12\x03U\x08\x20\n\x0c\n\x05\x05\x03\x02\x0f\
    \x02\x12\x03U#%\n\x0b\n\x04\x05\x03\x02\x10\x12\x03V\x08(\n\x0c\n\x05\
    \x05\x03\x02\x10\x01\x12\x03V\x08\"\n\x0c\n\x05\x05\x03\x02\x10\x02\x12\
    \x03V%'\n\x0b\n\x04\x05\x03\x02\x11\x12\x03W\x08%\n\x0c\n\x05\x05\x03\
    \x02\x11\x01\x12\x03W\x08\x1f\n\x0c\n\x05\x05\x03\x02\x11\x02\x12\x03W\"\
    $\n\x0b\n\x04\x05\x03\x02\x12\x12\x03X\x08)\n\x0c\n\x05\x05\x03\x02\x12\
    \x01\x12\x03X\x08#\n\x0c\n\x05\x05\x03\x02\x12\x02\x12\x03X&(\n\x0b\n\
    \x04\x05\x03\x02\x13\x12\x03Y\x08(\n\x0c\n\x05\x05\x03\x02\x13\x01\x12\
    \x03Y\x08\"\n\x0c\n\x05\x05\x03\x02\x13\x02\x12\x03Y%'\n\x0b\n\x04\x05\
    \x03\x02\x14\x12\x03Z\x08'\n\x0c\n\x05\x05\x03\x02\x14\x01\x12\x03Z\x08!\
    \n\x0c\n\x05\x05\x03\x02\x14\x02\x12\x03Z$&\n\x0b\n\x04\x05\x03\x02\x15\
    \x12\x03[\x08%\n\x0c\n\x05\x05\x03\x02\x15\x01\x12\x03[\x08\x1f\n\x0c\n\
    \x05\x05\x03\x02\x15\x02\x12\x03[\"$\n\x0b\n\x04\x05\x03\x02\x16\x12\x03\
    \\\x08)\n\x0c\n\x05\x05\x03\x02\x16\x01\x12\x03\\\x08#\n\x0c\n\x05\x05\
    \x03\x02\x16\x02\x12\x03\\&(\n\x0b\n\x04\x05\x03\x02\x17\x12\x03]\x08%\n\
    \x0c\n\x05\x05\x03\x02\x17\x01\x12\x03]\x08\x1f\n\x0c\n\x05\x05\x03\x02\
    \x17\x02\x12\x03]\"$\n\x0b\n\x04\x05\x03\x02\x18\x12\x03^\x08%\n\x0c\n\
    \x05\x05\x03\x02\x18\x01\x12\x03^\x08\x1f\n\x0c\n\x05\x05\x03\x02\x18\
    \x02\x12\x03^\"$\n\x0b\n\x04\x05\x03\x02\x19\x12\x03_\x08)\n\x0c\n\x05\
    \x05\x03\x02\x19\x01\x12\x03_\x08#\n\x0c\n\x05\x05\x03\x02\x19\x02\x12\
    \x03_&(\n\x0b\n\x04\x05\x03\x02\x1a\x12\x03`\x08,\n\x0c\n\x05\x05\x03\
    \x02\x1a\x01\x12\x03`\x08&\n\x0c\n\x05\x05\x03\x02\x1a\x02\x12\x03`)+\n\
    \x0b\n\x04\x05\x03\x02\x1b\x12\x03a\x08%\n\x0c\n\x05\x05\x03\x02\x1b\x01\
    \x12\x03a\x08\x1f\n\x0c\n\x05\x05\x03\x02\x1b\x02\x12\x03a\"$\n\x0b\n\
    \x04\x05\x03\x02\x1c\x12\x03b\x08%\n\x0c\n\x05\x05\x03\x02\x1c\x01\x12\
    \x03b\x08\x1f\n\x0c\n\x05\x05\x03\x02\x1c\x02\x12\x03b\"$\n\x0b\n\x04\
    \x05\x03\x02\x1d\x12\x03c\x08)\n\x0c\n\x05\x05\x03\x02\x1d\x01\x12\x03c\
    \x08#\n\x0c\n\x05\x05\x03\x02\x1d\x02\x12\x03c&(\n\x0b\n\x04\x05\x03\x02\
    \x1e\x12\x03d\x08\"\n\x0c\n\x05\x05\x03\x02\x1e\x01\x12\x03d\x08\x1c\n\
    \x0c\n\x05\x05\x03\x02\x1e\x02\x12\x03d\x1f!\n\x0b\n\x04\x05\x03\x02\x1f\
    \x12\x03e\x08$\n\x0c\n\x05\x05\x03\x02\x1f\x01\x12\x03e\x08\x1e\n\x0c\n\
    \x05\x05\x03\x02\x1f\x02\x12\x03e!#\n\x0b\n\x04\x05\x03\x02\x20\x12\x03f\
    \x08\"\n\x0c\n\x05\x05\x03\x02\x20\x01\x12\x03f\x08\x1c\n\x0c\n\x05\x05\
    \x03\x02\x20\x02\x12\x03f\x1f!\n\x0b\n\x04\x05\x03\x02!\x12\x03g\x08\x20\
    \n\x0c\n\x05\x05\x03\x02!\x01\x12\x03g\x08\x1a\n\x0c\n\x05\x05\x03\x02!\
    \x02\x12\x03g\x1d\x1f\n\x0b\n\x04\x05\x03\x02\"\x12\x03h\x08,\n\x0c\n\
    \x05\x05\x03\x02\"\x01\x12\x03h\x08&\n\x0c\n\x05\x05\x03\x02\"\x02\x12\
    \x03h)+\n\x0b\n\x04\x05\x03\x02#\x12\x03i\x08+\n\x0c\n\x05\x05\x03\x02#\
    \x01\x12\x03i\x08%\n\x0c\n\x05\x05\x03\x02#\x02\x12\x03i(*\n\x0b\n\x04\
    \x05\x03\x02$\x12\x03j\x08)\n\x0c\n\x05\x05\x03\x02$\x01\x12\x03j\x08#\n\
    \x0c\n\x05\x05\x03\x02$\x02\x12\x03j&(\n\x0b\n\x04\x05\x03\x02%\x12\x03k\
    \x08+\n\x0c\n\x05\x05\x03\x02%\x01\x12\x03k\x08%\n\x0c\n\x05\x05\x03\x02\
    %\x02\x12\x03k(*\n\x0b\n\x04\x05\x03\x02&\x12\x03l\x08.\n\x0c\n\x05\x05\
    \x03\x02&\x01\x12\x03l\x08(\n\x0c\n\x05\x05\x03\x02&\x02\x12\x03l+-\n\
    \x0b\n\x04\x05\x03\x02'\x12\x03m\x08'\n\x0c\n\x05\x05\x03\x02'\x01\x12\
    \x03m\x08!\n\x0c\n\x05\x05\x03\x02'\x02\x12\x03m$&\n\x0b\n\x04\x05\x03\
    \x02(\x12\x03n\x080\n\x0c\n\x05\x05\x03\x02(\x01\x12\x03n\x08*\n\x0c\n\
    \x05\x05\x03\x02(\x02\x12\x03n-/\n\x0b\n\x04\x05\x03\x02)\x12\x03o\x08&\
    \n\x0c\n\x05\x05\x03\x02)\x01\x12\x03o\x08\x20\n\x0c\n\x05\x05\x03\x02)\
    \x02\x12\x03o#%\n\x0b\n\x04\x05\x03\x02*\x12\x03p\x08&\n\x0c\n\x05\x05\
    \x03\x02*\x01\x12\x03p\x08\x20\n\x0c\n\x05\x05\x03\x02*\x02\x12\x03p#%\n\
    \n\n\x02\x05\x04\x12\x04s\0~\x01\n\n\n\x03\x05\x04\x01\x12\x03s\x05\x0e\
    \n\x0b\n\x04\x05\x04\x02\0\x12\x03t\x08\x20\n\x0c\n\x05\x05\x04\x02\0\
    \x01\x12\x03t\x08\x1b\n\x0c\n\x05\x05\x04\x02\0\x02\x12\x03t\x1e\x1f\n\
    \x0b\n\x04\x05\x04\x02\x01\x12\x03u\x08\x1f\n\x0c\n\x05\x05\x04\x02\x01\
    \x01\x12\x03u\x08\x1a\n\x0c\n\x05\x05\x04\x02\x01\x02\x12\x03u\x1d\x1e\n\
    \x0b\n\x04\x05\x04\x02\x02\x12\x03v\x08\x1f\n\x0c\n\x05\x05\x04\x02\x02\
    \x01\x12\x03v\x08\x1a\n\x0c\n\x05\x05\x04\x02\x02\x02\x12\x03v\x1d\x1e\n\
    \x0b\n\x04\x05\x04\x02\x03\x12\x03w\x08%\n\x0c\n\x05\x05\x04\x02\x03\x01\
    \x12\x03w\x08\x20\n\x0c\n\x05\x05\x04\x02\x03\x02\x12\x03w#$\n\x0b\n\x04\
    \x05\x04\x02\x04\x12\x03x\x08%\n\x0c\n\x05\x05\x04\x02\x04\x01\x12\x03x\
    \x08\x20\n\x0c\n\x05\x05\x04\x02\x04\x02\x12\x03x#$\n\x0b\n\x04\x05\x04\
    \x02\x05\x12\x03y\x08%\n\x0c\n\x05\x05\x04\x02\x05\x01\x12\x03y\x08\x20\
    \n\x0c\n\x05\x05\x04\x02\x05\x02\x12\x03y#$\n\x0b\n\x04\x05\x04\x02\x06\
    \x12\x03z\x08%\n\x0c\n\x05\x05\x04\x02\x06\x01\x12\x03z\x08\x20\n\x0c\n\
    \x05\x05\x04\x02\x06\x02\x12\x03z#$\n\x0b\n\x04\x05\x04\x02\x07\x12\x03{\
    \x08'\n\x0c\n\x05\x05\x04\x02\x07\x01\x12\x03{\x08\"\n\x0c\n\x05\x05\x04\
    \x02\x07\x02\x12\x03{%&\n\x0b\n\x04\x05\x04\x02\x08\x12\x03|\x08-\n\x0c\
    \n\x05\x05\x04\x02\x08\x01\x12\x03|\x08(\n\x0c\n\x05\x05\x04\x02\x08\x02\
    \x12\x03|+,\n\x0b\n\x04\x05\x04\x02\t\x12\x03}\x08,\n\x0c\n\x05\x05\x04\
    \x02\t\x01\x12\x03}\x08'\n\x0c\n\x05\x05\x04\x02\t\x02\x12\x03}*+\n\x0c\
    \n\x02\x05\x05\x12\x06\x80\x01\0\x8a\x01\x01\n\x0b\n\x03\x05\x05\x01\x12\
    \x04\x80\x01\x05\x17\n\x0c\n\x04\x05\x05\x02\0\x12\x04\x81\x01\x08\x1d\n\
    \r\n\x05\x05\x05\x02\0\x01\x12\x04\x81\x01\x08\x18\n\r\n\x05\x05\x05\x02\
    \0\x02\x12\x04\x81\x01\x1b\x1c\n\x0c\n\x04\x05\x05\x02\x01\x12\x04\x82\
    \x01\x08%\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\x82\x01\x08\x20\n\r\n\
    \x05\x05\x05\x02\x01\x02\x12\x04\x82\x01#$\n\x0c\n\x04\x05\x05\x02\x02\
    \x12\x04\x83\x01\x08.\n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\x83\x01\x08)\
    \n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\x83\x01,-\n\x0c\n\x04\x05\x05\x02\
    \x03\x12\x04\x84\x01\x08\"\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\x84\x01\
    \x08\x1d\n\r\n\x05\x05\x05\x02\x03\x02\x12\x04\x84\x01\x20!\n\x0c\n\x04\
    \x05\x05\x02\x04\x12\x04\x85\x01\x08\x1c\n\r\n\x05\x05\x05\x02\x04\x01\
    \x12\x04\x85\x01\x08\x17\n\r\n\x05\x05\x05\x02\x04\x02\x12\x04\x85\x01\
    \x1a\x1b\n\x0c\n\x04\x05\x05\x02\x05\x12\x04\x86\x01\x08(\n\r\n\x05\x05\
    \x05\x02\x05\x01\x12\x04\x86\x01\x08#\n\r\n\x05\x05\x05\x02\x05\x02\x12\
    \x04\x86\x01&'\n\x0c\n\x04\x05\x05\x02\x06\x12\x04\x87\x01\x081\n\r\n\
    \x05\x05\x05\x02\x06\x01\x12\x04\x87\x01\x08,\n\r\n\x05\x05\x05\x02\x06\
    \x02\x12\x04\x87\x01/0\n\x0c\n\x04\x05\x05\x02\x07\x12\x04\x88\x01\x08+\
    \n\r\n\x05\x05\x05\x02\x07\x01\x12\x04\x88\x01\x08&\n\r\n\x05\x05\x05\
    \x02\x07\x02\x12\x04\x88\x01)*\n\x0c\n\x04\x05\x05\x02\x08\x12\x04\x89\
    \x01\x08!\n\r\n\x05\x05\x05\x02\x08\x01\x12\x04\x89\x01\x08\x1c\n\r\n\
    \x05\x05\x05\x02\x08\x02\x12\x04\x89\x01\x1f\x20\n\x0c\n\x02\x05\x06\x12\
    \x06\x8c\x01\0\x94\x01\x01\n\x0b\n\x03\x05\x06\x01\x12\x04\x8c\x01\x05\
    \x1a\n\x0c\n\x04\x05\x06\x02\0\x12\x04\x8d\x01\x08*\n\r\n\x05\x05\x06\
    \x02\0\x01\x12\x04\x8d\x01\x08%\n\r\n\x05\x05\x06\x02\0\x02\x12\x04\x8d\
    \x01()\n\x0c\n\x04\x05\x06\x02\x01\x12\x04\x8e\x01\x084\n\r\n\x05\x05\
    \x06\x02\x01\x01\x12\x04\x8e\x01\x08/\n\r\n\x05\x05\x06\x02\x01\x02\x12\
    \x04\x8e\x0123\n\x0c\n\x04\x05\x06\x02\x02\x12\x04\x8f\x01\x08,\n\r\n\
    \x05\x05\x06\x02\x02\x01\x12\x04\x8f\x01\x08'\n\r\n\x05\x05\x06\x02\x02\
    \x02\x12\x04\x8f\x01*+\n\x0c\n\x04\x05\x06\x02\x03\x12\x04\x90\x01\x08/\
    \n\r\n\x05\x05\x06\x02\x03\x01\x12\x04\x90\x01\x08*\n\r\n\x05\x05\x06\
    \x02\x03\x02\x12\x04\x90\x01-.\n\x0c\n\x04\x05\x06\x02\x04\x12\x04\x91\
    \x01\x08,\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\x91\x01\x08'\n\r\n\x05\
    \x05\x06\x02\x04\x02\x12\x04\x91\x01*+\n\x0c\n\x04\x05\x06\x02\x05\x12\
    \x04\x92\x01\x08*\n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\x92\x01\x08%\n\r\
    \n\x05\x05\x06\x02\x05\x02\x12\x04\x92\x01()\n\x0c\n\x04\x05\x06\x02\x06\
    \x12\x04\x93\x01\x08)\n\r\n\x05\x05\x06\x02\x06\x01\x12\x04\x93\x01\x08$\
    \n\r\n\x05\x05\x06\x02\x06\x02\x12\x04\x93\x01'(\n\x0c\n\x02\x05\x07\x12\
    \x06\x96\x01\0\x9c\x01\x01\n\x0b\n\x03\x05\x07\x01\x12\x04\x96\x01\x05\
    \x12\n\x0c\n\x04\x05\x07\x02\0\x12\x04\x97\x01\x08#\n\r\n\x05\x05\x07\
    \x02\0\x01\x12\x04\x97\x01\x08\x1e\n\r\n\x05\x05\x07\x02\0\x02\x12\x04\
    \x97\x01!\"\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\x98\x01\x08\x1e\n\r\n\
    \x05\x05\x07\x02\x01\x01\x12\x04\x98\x01\x08\x19\n\r\n\x05\x05\x07\x02\
    \x01\x02\x12\x04\x98\x01\x1c\x1d\n\x0c\n\x04\x05\x07\x02\x02\x12\x04\x99\
    \x01\x08!\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\x99\x01\x08\x1c\n\r\n\
    \x05\x05\x07\x02\x02\x02\x12\x04\x99\x01\x1f\x20\n\x0c\n\x04\x05\x07\x02\
    \x03\x12\x04\x9a\x01\x08!\n\r\n\x05\x05\x07\x02\x03\x01\x12\x04\x9a\x01\
    \x08\x1c\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\x9a\x01\x1f\x20\n\x0c\n\
    \x04\x05\x07\x02\x04\x12\x04\x9b\x01\x08\x1d\n\r\n\x05\x05\x07\x02\x04\
    \x01\x12\x04\x9b\x01\x08\x18\n\r\n\x05\x05\x07\x02\x04\x02\x12\x04\x9b\
    \x01\x1b\x1c\n\x0c\n\x02\x05\x08\x12\x06\x9e\x01\0\xa4\x01\x01\n\x0b\n\
    \x03\x05\x08\x01\x12\x04\x9e\x01\x05\x17\n\x0c\n\x04\x05\x08\x02\0\x12\
    \x04\x9f\x01\x08\x1e\n\r\n\x05\x05\x08\x02\0\x01\x12\x04\x9f\x01\x08\x19\
    \n\r\n\x05\x05\x08\x02\0\x02\x12\x04\x9f\x01\x1c\x1d\n\x0c\n\x04\x05\x08\
    \x02\x01\x12\x04\xa0\x01\x08\x1e\n\r\n\x05\x05\x08\x02\x01\x01\x12\x04\
    \xa0\x01\x08\x19\n\r\n\x05\x05\x08\x02\x01\x02\x12\x04\xa0\x01\x1c\x1d\n\
    \x0c\n\x04\x05\x08\x02\x02\x12\x04\xa1\x01\x08!\n\r\n\x05\x05\x08\x02\
    \x02\x01\x12\x04\xa1\x01\x08\x1c\n\r\n\x05\x05\x08\x02\x02\x02\x12\x04\
    \xa1\x01\x1f\x20\n\x0c\n\x04\x05\x08\x02\x03\x12\x04\xa2\x01\x08\x1d\n\r\
    \n\x05\x05\x08\x02\x03\x01\x12\x04\xa2\x01\x08\x18\n\r\n\x05\x05\x08\x02\
    \x03\x02\x12\x04\xa2\x01\x1b\x1c\n\x0c\n\x04\x05\x08\x02\x04\x12\x04\xa3\
    \x01\x08\x1f\n\r\n\x05\x05\x08\x02\x04\x01\x12\x04\xa3\x01\x08\x1a\n\r\n\
    \x05\x05\x08\x02\x04\x02\x12\x04\xa3\x01\x1d\x1e\n\x0c\n\x02\x05\t\x12\
    \x06\xa6\x01\0\xb1\x01\x01\n\x0b\n\x03\x05\t\x01\x12\x04\xa6\x01\x05\x1b\
    \n\x0c\n\x04\x05\t\x02\0\x12\x04\xa7\x01\x08&\n\r\n\x05\x05\t\x02\0\x01\
    \x12\x04\xa7\x01\x08!\n\r\n\x05\x05\t\x02\0\x02\x12\x04\xa7\x01$%\n\x0c\
    \n\x04\x05\t\x02\x01\x12\x04\xa8\x01\x08%\n\r\n\x05\x05\t\x02\x01\x01\
    \x12\x04\xa8\x01\x08\x20\n\r\n\x05\x05\t\x02\x01\x02\x12\x04\xa8\x01#$\n\
    \x0c\n\x04\x05\t\x02\x02\x12\x04\xa9\x01\x08&\n\r\n\x05\x05\t\x02\x02\
    \x01\x12\x04\xa9\x01\x08!\n\r\n\x05\x05\t\x02\x02\x02\x12\x04\xa9\x01$%\
    \n\x0c\n\x04\x05\t\x02\x03\x12\x04\xaa\x01\x08(\n\r\n\x05\x05\t\x02\x03\
    \x01\x12\x04\xaa\x01\x08#\n\r\n\x05\x05\t\x02\x03\x02\x12\x04\xaa\x01&'\
    \n\x0c\n\x04\x05\t\x02\x04\x12\x04\xab\x01\x08$\n\r\n\x05\x05\t\x02\x04\
    \x01\x12\x04\xab\x01\x08\x1f\n\r\n\x05\x05\t\x02\x04\x02\x12\x04\xab\x01\
    \"#\n\x0c\n\x04\x05\t\x02\x05\x12\x04\xac\x01\x08)\n\r\n\x05\x05\t\x02\
    \x05\x01\x12\x04\xac\x01\x08$\n\r\n\x05\x05\t\x02\x05\x02\x12\x04\xac\
    \x01'(\n\x0c\n\x04\x05\t\x02\x06\x12\x04\xad\x01\x08(\n\r\n\x05\x05\t\
    \x02\x06\x01\x12\x04\xad\x01\x08#\n\r\n\x05\x05\t\x02\x06\x02\x12\x04\
    \xad\x01&'\n\x0c\n\x04\x05\t\x02\x07\x12\x04\xae\x01\x08'\n\r\n\x05\x05\
    \t\x02\x07\x01\x12\x04\xae\x01\x08\"\n\r\n\x05\x05\t\x02\x07\x02\x12\x04\
    \xae\x01%&\n\x0c\n\x04\x05\t\x02\x08\x12\x04\xaf\x01\x08-\n\r\n\x05\x05\
    \t\x02\x08\x01\x12\x04\xaf\x01\x08(\n\r\n\x05\x05\t\x02\x08\x02\x12\x04\
    \xaf\x01+,\n\x0c\n\x04\x05\t\x02\t\x12\x04\xb0\x01\x08)\n\r\n\x05\x05\t\
    \x02\t\x01\x12\x04\xb0\x01\x08$\n\r\n\x05\x05\t\x02\t\x02\x12\x04\xb0\
    \x01'(\n\x0c\n\x02\x05\n\x12\x06\xb3\x01\0\xcd\x01\x01\n\x0b\n\x03\x05\n\
    \x01\x12\x04\xb3\x01\x05\x1a\n\x0c\n\x04\x05\n\x02\0\x12\x04\xb4\x01\x08\
    %\n\r\n\x05\x05\n\x02\0\x01\x12\x04\xb4\x01\x08\x20\n\r\n\x05\x05\n\x02\
    \0\x02\x12\x04\xb4\x01#$\n\x0c\n\x04\x05\n\x02\x01\x12\x04\xb5\x01\x08#\
    \n\r\n\x05\x05\n\x02\x01\x01\x12\x04\xb5\x01\x08\x1e\n\r\n\x05\x05\n\x02\
    \x01\x02\x12\x04\xb5\x01!\"\n\x0c\n\x04\x05\n\x02\x02\x12\x04\xb6\x01\
    \x08\"\n\r\n\x05\x05\n\x02\x02\x01\x12\x04\xb6\x01\x08\x1d\n\r\n\x05\x05\
    \n\x02\x02\x02\x12\x04\xb6\x01\x20!\n\x0c\n\x04\x05\n\x02\x03\x12\x04\
    \xb7\x01\x08\"\n\r\n\x05\x05\n\x02\x03\x01\x12\x04\xb7\x01\x08\x1d\n\r\n\
    \x05\x05\n\x02\x03\x02\x12\x04\xb7\x01\x20!\n\x0c\n\x04\x05\n\x02\x04\
    \x12\x04\xb8\x01\x08!\n\r\n\x05\x05\n\x02\x04\x01\x12\x04\xb8\x01\x08\
    \x1c\n\r\n\x05\x05\n\x02\x04\x02\x12\x04\xb8\x01\x1f\x20\n\x0c\n\x04\x05\
    \n\x02\x05\x12\x04\xb9\x01\x08\"\n\r\n\x05\x05\n\x02\x05\x01\x12\x04\xb9\
    \x01\x08\x1d\n\r\n\x05\x05\n\x02\x05\x02\x12\x04\xb9\x01\x20!\n\x0c\n\
    \x04\x05\n\x02\x06\x12\x04\xba\x01\x08$\n\r\n\x05\x05\n\x02\x06\x01\x12\
    \x04\xba\x01\x08\x1f\n\r\n\x05\x05\n\x02\x06\x02\x12\x04\xba\x01\"#\n\
    \x0c\n\x04\x05\n\x02\x07\x12\x04\xbb\x01\x08$\n\r\n\x05\x05\n\x02\x07\
    \x01\x12\x04\xbb\x01\x08\x1f\n\r\n\x05\x05\n\x02\x07\x02\x12\x04\xbb\x01\
    \"#\n\x0c\n\x04\x05\n\x02\x08\x12\x04\xbc\x01\x08$\n\r\n\x05\x05\n\x02\
    \x08\x01\x12\x04\xbc\x01\x08\x1f\n\r\n\x05\x05\n\x02\x08\x02\x12\x04\xbc\
    \x01\"#\n\x0c\n\x04\x05\n\x02\t\x12\x04\xbd\x01\x08\x20\n\r\n\x05\x05\n\
    \x02\t\x01\x12\x04\xbd\x01\x08\x1b\n\r\n\x05\x05\n\x02\t\x02\x12\x04\xbd\
    \x01\x1e\x1f\n\x0c\n\x04\x05\n\x02\n\x12\x04\xbe\x01\x08%\n\r\n\x05\x05\
    \n\x02\n\x01\x12\x04\xbe\x01\x08\x1f\n\r\n\x05\x05\n\x02\n\x02\x12\x04\
    \xbe\x01\"$\n\x0c\n\x04\x05\n\x02\x0b\x12\x04\xbf\x01\x08%\n\r\n\x05\x05\
    \n\x02\x0b\x01\x12\x04\xbf\x01\x08\x1f\n\r\n\x05\x05\n\x02\x0b\x02\x12\
    \x04\xbf\x01\"$\n\x0c\n\x04\x05\n\x02\x0c\x12\x04\xc0\x01\x08(\n\r\n\x05\
    \x05\n\x02\x0c\x01\x12\x04\xc0\x01\x08\"\n\r\n\x05\x05\n\x02\x0c\x02\x12\
    \x04\xc0\x01%'\n\x0c\n\x04\x05\n\x02\r\x12\x04\xc1\x01\x08+\n\r\n\x05\
    \x05\n\x02\r\x01\x12\x04\xc1\x01\x08%\n\r\n\x05\x05\n\x02\r\x02\x12\x04\
    \xc1\x01(*\n\x0c\n\x04\x05\n\x02\x0e\x12\x04\xc2\x01\x08*\n\r\n\x05\x05\
    \n\x02\x0e\x01\x12\x04\xc2\x01\x08$\n\r\n\x05\x05\n\x02\x0e\x02\x12\x04\
    \xc2\x01')\n\x0c\n\x04\x05\n\x02\x0f\x12\x04\xc3\x01\x08\"\n\r\n\x05\x05\
    \n\x02\x0f\x01\x12\x04\xc3\x01\x08\x1c\n\r\n\x05\x05\n\x02\x0f\x02\x12\
    \x04\xc3\x01\x1f!\n\x0c\n\x04\x05\n\x02\x10\x12\x04\xc4\x01\x08(\n\r\n\
    \x05\x05\n\x02\x10\x01\x12\x04\xc4\x01\x08\"\n\r\n\x05\x05\n\x02\x10\x02\
    \x12\x04\xc4\x01%'\n\x0c\n\x04\x05\n\x02\x11\x12\x04\xc5\x01\x08%\n\r\n\
    \x05\x05\n\x02\x11\x01\x12\x04\xc5\x01\x08\x1f\n\r\n\x05\x05\n\x02\x11\
    \x02\x12\x04\xc5\x01\"$\n\x0c\n\x04\x05\n\x02\x12\x12\x04\xc6\x01\x08&\n\
    \r\n\x05\x05\n\x02\x12\x01\x12\x04\xc6\x01\x08\x20\n\r\n\x05\x05\n\x02\
    \x12\x02\x12\x04\xc6\x01#%\n\x0c\n\x04\x05\n\x02\x13\x12\x04\xc7\x01\x08\
    '\n\r\n\x05\x05\n\x02\x13\x01\x12\x04\xc7\x01\x08!\n\r\n\x05\x05\n\x02\
    \x13\x02\x12\x04\xc7\x01$&\n\x0c\n\x04\x05\n\x02\x14\x12\x04\xc8\x01\x08\
    +\n\r\n\x05\x05\n\x02\x14\x01\x12\x04\xc8\x01\x08%\n\r\n\x05\x05\n\x02\
    \x14\x02\x12\x04\xc8\x01(*\n\x0c\n\x04\x05\n\x02\x15\x12\x04\xc9\x01\x08\
    (\n\r\n\x05\x05\n\x02\x15\x01\x12\x04\xc9\x01\x08\"\n\r\n\x05\x05\n\x02\
    \x15\x02\x12\x04\xc9\x01%'\n\x0c\n\x04\x05\n\x02\x16\x12\x04\xca\x01\x08\
    $\n\r\n\x05\x05\n\x02\x16\x01\x12\x04\xca\x01\x08\x1e\n\r\n\x05\x05\n\
    \x02\x16\x02\x12\x04\xca\x01!#\n\x0c\n\x04\x05\n\x02\x17\x12\x04\xcb\x01\
    \x08'\n\r\n\x05\x05\n\x02\x17\x01\x12\x04\xcb\x01\x08!\n\r\n\x05\x05\n\
    \x02\x17\x02\x12\x04\xcb\x01$&\n\x0c\n\x04\x05\n\x02\x18\x12\x04\xcc\x01\
    \x08-\n\r\n\x05\x05\n\x02\x18\x01\x12\x04\xcc\x01\x08'\n\r\n\x05\x05\n\
    \x02\x18\x02\x12\x04\xcc\x01*,\n\x0c\n\x02\x05\x0b\x12\x06\xcf\x01\0\xd3\
    \x01\x01\n\x0b\n\x03\x05\x0b\x01\x12\x04\xcf\x01\x05\x1b\n\x0c\n\x04\x05\
    \x0b\x02\0\x12\x04\xd0\x01\x08*\n\r\n\x05\x05\x0b\x02\0\x01\x12\x04\xd0\
    \x01\x08%\n\r\n\x05\x05\x0b\x02\0\x02\x12\x04\xd0\x01()\n\x0c\n\x04\x05\
    \x0b\x02\x01\x12\x04\xd1\x01\x08/\n\r\n\x05\x05\x0b\x02\x01\x01\x12\x04\
    \xd1\x01\x08*\n\r\n\x05\x05\x0b\x02\x01\x02\x12\x04\xd1\x01-.\n\x0c\n\
    \x04\x05\x0b\x02\x02\x12\x04\xd2\x01\x084\n\r\n\x05\x05\x0b\x02\x02\x01\
    \x12\x04\xd2\x01\x08/\n\r\n\x05\x05\x0b\x02\x02\x02\x12\x04\xd2\x0123\n\
    \x0c\n\x02\x05\x0c\x12\x06\xd5\x01\0\xdd\x01\x01\n\x0b\n\x03\x05\x0c\x01\
    \x12\x04\xd5\x01\x05\x19\n\x0c\n\x04\x05\x0c\x02\0\x12\x04\xd6\x01\x08)\
    \n\r\n\x05\x05\x0c\x02\0\x01\x12\x04\xd6\x01\x08$\n\r\n\x05\x05\x0c\x02\
    \0\x02\x12\x04\xd6\x01'(\n\x0c\n\x04\x05\x0c\x02\x01\x12\x04\xd7\x01\x08\
    (\n\r\n\x05\x05\x0c\x02\x01\x01\x12\x04\xd7\x01\x08#\n\r\n\x05\x05\x0c\
    \x02\x01\x02\x12\x04\xd7\x01&'\n\x0c\n\x04\x05\x0c\x02\x02\x12\x04\xd8\
    \x01\x08*\n\r\n\x05\x05\x0c\x02\x02\x01\x12\x04\xd8\x01\x08%\n\r\n\x05\
    \x05\x0c\x02\x02\x02\x12\x04\xd8\x01()\n\x0c\n\x04\x05\x0c\x02\x03\x12\
    \x04\xd9\x01\x08(\n\r\n\x05\x05\x0c\x02\x03\x01\x12\x04\xd9\x01\x08#\n\r\
    \n\x05\x05\x0c\x02\x03\x02\x12\x04\xd9\x01&'\n\x0c\n\x04\x05\x0c\x02\x04\
    \x12\x04\xda\x01\x08(\n\r\n\x05\x05\x0c\x02\x04\x01\x12\x04\xda\x01\x08#\
    \n\r\n\x05\x05\x0c\x02\x04\x02\x12\x04\xda\x01&'\n\x0c\n\x04\x05\x0c\x02\
    \x05\x12\x04\xdb\x01\x08,\n\r\n\x05\x05\x0c\x02\x05\x01\x12\x04\xdb\x01\
    \x08'\n\r\n\x05\x05\x0c\x02\x05\x02\x12\x04\xdb\x01*+\n\x0c\n\x04\x05\
    \x0c\x02\x06\x12\x04\xdc\x01\x08(\n\r\n\x05\x05\x0c\x02\x06\x01\x12\x04\
    \xdc\x01\x08#\n\r\n\x05\x05\x0c\x02\x06\x02\x12\x04\xdc\x01&'\n\x0c\n\
    \x02\x05\r\x12\x06\xdf\x01\0\xe3\x01\x01\n\x0b\n\x03\x05\r\x01\x12\x04\
    \xdf\x01\x05\x1c\n\x0c\n\x04\x05\r\x02\0\x12\x04\xe0\x01\x08)\n\r\n\x05\
    \x05\r\x02\0\x01\x12\x04\xe0\x01\x08$\n\r\n\x05\x05\r\x02\0\x02\x12\x04\
    \xe0\x01'(\n\x0c\n\x04\x05\r\x02\x01\x12\x04\xe1\x01\x08:\n\r\n\x05\x05\
    \r\x02\x01\x01\x12\x04\xe1\x01\x085\n\r\n\x05\x05\r\x02\x01\x02\x12\x04\
    \xe1\x0189\n\x0c\n\x04\x05\r\x02\x02\x12\x04\xe2\x01\x08.\n\r\n\x05\x05\
    \r\x02\x02\x01\x12\x04\xe2\x01\x08)\n\r\n\x05\x05\r\x02\x02\x02\x12\x04\
    \xe2\x01,-\n\x0c\n\x02\x05\x0e\x12\x06\xe5\x01\0\xe9\x01\x01\n\x0b\n\x03\
    \x05\x0e\x01\x12\x04\xe5\x01\x05\x11\n\x0c\n\x04\x05\x0e\x02\0\x12\x04\
    \xe6\x01\x08\x1b\n\r\n\x05\x05\x0e\x02\0\x01\x12\x04\xe6\x01\x08\x16\n\r\
    \n\x05\x05\x0e\x02\0\x02\x12\x04\xe6\x01\x19\x1a\n\x0c\n\x04\x05\x0e\x02\
    \x01\x12\x04\xe7\x01\x08\x1e\n\r\n\x05\x05\x0e\x02\x01\x01\x12\x04\xe7\
    \x01\x08\x19\n\r\n\x05\x05\x0e\x02\x01\x02\x12\x04\xe7\x01\x1c\x1d\n\x0c\
    \n\x04\x05\x0e\x02\x02\x12\x04\xe8\x01\x08\x1d\n\r\n\x05\x05\x0e\x02\x02\
    \x01\x12\x04\xe8\x01\x08\x18\n\r\n\x05\x05\x0e\x02\x02\x02\x12\x04\xe8\
    \x01\x1b\x1c\n\x0c\n\x02\x05\x0f\x12\x06\xeb\x01\0\xf0\x01\x01\n\x0b\n\
    \x03\x05\x0f\x01\x12\x04\xeb\x01\x05\x1b\n\x0c\n\x04\x05\x0f\x02\0\x12\
    \x04\xec\x01\x08*\n\r\n\x05\x05\x0f\x02\0\x01\x12\x04\xec\x01\x08%\n\r\n\
    \x05\x05\x0f\x02\0\x02\x12\x04\xec\x01()\n\x0c\n\x04\x05\x0f\x02\x01\x12\
    \x04\xed\x01\x08*\n\r\n\x05\x05\x0f\x02\x01\x01\x12\x04\xed\x01\x08%\n\r\
    \n\x05\x05\x0f\x02\x01\x02\x12\x04\xed\x01()\n\x0c\n\x04\x05\x0f\x02\x02\
    \x12\x04\xee\x01\x084\n\r\n\x05\x05\x0f\x02\x02\x01\x12\x04\xee\x01\x08/\
    \n\r\n\x05\x05\x0f\x02\x02\x02\x12\x04\xee\x0123\n\x0c\n\x04\x05\x0f\x02\
    \x03\x12\x04\xef\x01\x080\n\r\n\x05\x05\x0f\x02\x03\x01\x12\x04\xef\x01\
    \x08+\n\r\n\x05\x05\x0f\x02\x03\x02\x12\x04\xef\x01./\n\x0c\n\x02\x05\
    \x10\x12\x06\xf2\x01\0\xf6\x01\x01\n\x0b\n\x03\x05\x10\x01\x12\x04\xf2\
    \x01\x05\x18\n\x0c\n\x04\x05\x10\x02\0\x12\x04\xf3\x01\x08+\n\r\n\x05\
    \x05\x10\x02\0\x01\x12\x04\xf3\x01\x08&\n\r\n\x05\x05\x10\x02\0\x02\x12\
    \x04\xf3\x01)*\n\x0c\n\x04\x05\x10\x02\x01\x12\x04\xf4\x01\x08)\n\r\n\
    \x05\x05\x10\x02\x01\x01\x12\x04\xf4\x01\x08$\n\r\n\x05\x05\x10\x02\x01\
    \x02\x12\x04\xf4\x01'(\n\x0c\n\x04\x05\x10\x02\x02\x12\x04\xf5\x01\x08)\
    \n\r\n\x05\x05\x10\x02\x02\x01\x12\x04\xf5\x01\x08$\n\r\n\x05\x05\x10\
    \x02\x02\x02\x12\x04\xf5\x01'(\n\x0c\n\x02\x05\x11\x12\x06\xf8\x01\0\x88\
    \x02\x01\n\x0b\n\x03\x05\x11\x01\x12\x04\xf8\x01\x05\x18\n\x0c\n\x04\x05\
    \x11\x02\0\x12\x04\xf9\x01\x08%\n\r\n\x05\x05\x11\x02\0\x01\x12\x04\xf9\
    \x01\x08\x20\n\r\n\x05\x05\x11\x02\0\x02\x12\x04\xf9\x01#$\n\x0c\n\x04\
    \x05\x11\x02\x01\x12\x04\xfa\x01\x08-\n\r\n\x05\x05\x11\x02\x01\x01\x12\
    \x04\xfa\x01\x08(\n\r\n\x05\x05\x11\x02\x01\x02\x12\x04\xfa\x01+,\n\x0c\
    \n\x04\x05\x11\x02\x02\x12\x04\xfb\x01\x08+\n\r\n\x05\x05\x11\x02\x02\
    \x01\x12\x04\xfb\x01\x08&\n\r\n\x05\x05\x11\x02\x02\x02\x12\x04\xfb\x01)\
    *\n\x0c\n\x04\x05\x11\x02\x03\x12\x04\xfc\x01\x080\n\r\n\x05\x05\x11\x02\
    \x03\x01\x12\x04\xfc\x01\x08+\n\r\n\x05\x05\x11\x02\x03\x02\x12\x04\xfc\
    \x01./\n\x0c\n\x04\x05\x11\x02\x04\x12\x04\xfd\x01\x08+\n\r\n\x05\x05\
    \x11\x02\x04\x01\x12\x04\xfd\x01\x08&\n\r\n\x05\x05\x11\x02\x04\x02\x12\
    \x04\xfd\x01)*\n\x0c\n\x04\x05\x11\x02\x05\x12\x04\xfe\x01\x08+\n\r\n\
    \x05\x05\x11\x02\x05\x01\x12\x04\xfe\x01\x08&\n\r\n\x05\x05\x11\x02\x05\
    \x02\x12\x04\xfe\x01)*\n\x0c\n\x04\x05\x11\x02\x06\x12\x04\xff\x01\x08/\
    \n\r\n\x05\x05\x11\x02\x06\x01\x12\x04\xff\x01\x08*\n\r\n\x05\x05\x11\
    \x02\x06\x02\x12\x04\xff\x01-.\n\x0c\n\x04\x05\x11\x02\x07\x12\x04\x80\
    \x02\x08+\n\r\n\x05\x05\x11\x02\x07\x01\x12\x04\x80\x02\x08&\n\r\n\x05\
    \x05\x11\x02\x07\x02\x12\x04\x80\x02)*\n\x0c\n\x04\x05\x11\x02\x08\x12\
    \x04\x81\x02\x08,\n\r\n\x05\x05\x11\x02\x08\x01\x12\x04\x81\x02\x08'\n\r\
    \n\x05\x05\x11\x02\x08\x02\x12\x04\x81\x02*+\n\x0c\n\x04\x05\x11\x02\t\
    \x12\x04\x82\x02\x08(\n\r\n\x05\x05\x11\x02\t\x01\x12\x04\x82\x02\x08#\n\
    \r\n\x05\x05\x11\x02\t\x02\x12\x04\x82\x02&'\n\x0c\n\x04\x05\x11\x02\n\
    \x12\x04\x83\x02\x08<\n\r\n\x05\x05\x11\x02\n\x01\x12\x04\x83\x02\x086\n\
    \r\n\x05\x05\x11\x02\n\x02\x12\x04\x83\x029;\n\x0c\n\x04\x05\x11\x02\x0b\
    \x12\x04\x84\x02\x08&\n\r\n\x05\x05\x11\x02\x0b\x01\x12\x04\x84\x02\x08\
    \x20\n\r\n\x05\x05\x11\x02\x0b\x02\x12\x04\x84\x02#%\n\x0c\n\x04\x05\x11\
    \x02\x0c\x12\x04\x85\x02\x083\n\r\n\x05\x05\x11\x02\x0c\x01\x12\x04\x85\
    \x02\x08-\n\r\n\x05\x05\x11\x02\x0c\x02\x12\x04\x85\x0202\n\x0c\n\x04\
    \x05\x11\x02\r\x12\x04\x86\x02\x08#\n\r\n\x05\x05\x11\x02\r\x01\x12\x04\
    \x86\x02\x08\x1d\n\r\n\x05\x05\x11\x02\r\x02\x12\x04\x86\x02\x20\"\n\x0c\
    \n\x04\x05\x11\x02\x0e\x12\x04\x87\x02\x08*\n\r\n\x05\x05\x11\x02\x0e\
    \x01\x12\x04\x87\x02\x08$\n\r\n\x05\x05\x11\x02\x0e\x02\x12\x04\x87\x02'\
    )\n\x0c\n\x02\x05\x12\x12\x06\x8a\x02\0\x8d\x02\x01\n\x0b\n\x03\x05\x12\
    \x01\x12\x04\x8a\x02\x05\x1f\n\x0c\n\x04\x05\x12\x02\0\x12\x04\x8b\x02\
    \x080\n\r\n\x05\x05\x12\x02\0\x01\x12\x04\x8b\x02\x08+\n\r\n\x05\x05\x12\
    \x02\0\x02\x12\x04\x8b\x02./\n\x0c\n\x04\x05\x12\x02\x01\x12\x04\x8c\x02\
    \x083\n\r\n\x05\x05\x12\x02\x01\x01\x12\x04\x8c\x02\x08.\n\r\n\x05\x05\
    \x12\x02\x01\x02\x12\x04\x8c\x0212\n\x0c\n\x02\x05\x13\x12\x06\x8f\x02\0\
    \x95\x02\x01\n\x0b\n\x03\x05\x13\x01\x12\x04\x8f\x02\x05\x20\n\x0c\n\x04\
    \x05\x13\x02\0\x12\x04\x90\x02\x082\n\r\n\x05\x05\x13\x02\0\x01\x12\x04\
    \x90\x02\x08-\n\r\n\x05\x05\x13\x02\0\x02\x12\x04\x90\x0201\n\x0c\n\x04\
    \x05\x13\x02\x01\x12\x04\x91\x02\x084\n\r\n\x05\x05\x13\x02\x01\x01\x12\
    \x04\x91\x02\x08/\n\r\n\x05\x05\x13\x02\x01\x02\x12\x04\x91\x0223\n\x0c\
    \n\x04\x05\x13\x02\x02\x12\x04\x92\x02\x085\n\r\n\x05\x05\x13\x02\x02\
    \x01\x12\x04\x92\x02\x080\n\r\n\x05\x05\x13\x02\x02\x02\x12\x04\x92\x023\
    4\n\x0c\n\x04\x05\x13\x02\x03\x12\x04\x93\x02\x082\n\r\n\x05\x05\x13\x02\
    \x03\x01\x12\x04\x93\x02\x08-\n\r\n\x05\x05\x13\x02\x03\x02\x12\x04\x93\
    \x0201\n\x0c\n\x04\x05\x13\x02\x04\x12\x04\x94\x02\x08/\n\r\n\x05\x05\
    \x13\x02\x04\x01\x12\x04\x94\x02\x08*\n\r\n\x05\x05\x13\x02\x04\x02\x12\
    \x04\x94\x02-.\n\x0c\n\x02\x05\x14\x12\x06\x97\x02\0\x9b\x02\x01\n\x0b\n\
    \x03\x05\x14\x01\x12\x04\x97\x02\x05\x12\n\x0c\n\x04\x05\x14\x02\0\x12\
    \x04\x98\x02\x08\"\n\r\n\x05\x05\x14\x02\0\x01\x12\x04\x98\x02\x08\x1d\n\
    \r\n\x05\x05\x14\x02\0\x02\x12\x04\x98\x02\x20!\n\x0c\n\x04\x05\x14\x02\
    \x01\x12\x04\x99\x02\x08#\n\r\n\x05\x05\x14\x02\x01\x01\x12\x04\x99\x02\
    \x08\x1e\n\r\n\x05\x05\x14\x02\x01\x02\x12\x04\x99\x02!\"\n\x0c\n\x04\
    \x05\x14\x02\x02\x12\x04\x9a\x02\x08#\n\r\n\x05\x05\x14\x02\x02\x01\x12\
    \x04\x9a\x02\x08\x1e\n\r\n\x05\x05\x14\x02\x02\x02\x12\x04\x9a\x02!\"\n\
    \x0c\n\x02\x05\x15\x12\x06\x9d\x02\0\xa1\x02\x01\n\x0b\n\x03\x05\x15\x01\
    \x12\x04\x9d\x02\x05\x18\n\x0c\n\x04\x05\x15\x02\0\x12\x04\x9e\x02\x08'\
    \n\r\n\x05\x05\x15\x02\0\x01\x12\x04\x9e\x02\x08\"\n\r\n\x05\x05\x15\x02\
    \0\x02\x12\x04\x9e\x02%&\n\x0c\n\x04\x05\x15\x02\x01\x12\x04\x9f\x02\x08\
    (\n\r\n\x05\x05\x15\x02\x01\x01\x12\x04\x9f\x02\x08#\n\r\n\x05\x05\x15\
    \x02\x01\x02\x12\x04\x9f\x02&'\n\x0c\n\x04\x05\x15\x02\x02\x12\x04\xa0\
    \x02\x08)\n\r\n\x05\x05\x15\x02\x02\x01\x12\x04\xa0\x02\x08$\n\r\n\x05\
    \x05\x15\x02\x02\x02\x12\x04\xa0\x02'(\n\x0c\n\x02\x05\x16\x12\x06\xa3\
    \x02\0\xa7\x02\x01\n\x0b\n\x03\x05\x16\x01\x12\x04\xa3\x02\x05\x17\n\x0c\
    \n\x04\x05\x16\x02\0\x12\x04\xa4\x02\x08)\n\r\n\x05\x05\x16\x02\0\x01\
    \x12\x04\xa4\x02\x08$\n\r\n\x05\x05\x16\x02\0\x02\x12\x04\xa4\x02'(\n\
    \x0c\n\x04\x05\x16\x02\x01\x12\x04\xa5\x02\x08/\n\r\n\x05\x05\x16\x02\
    \x01\x01\x12\x04\xa5\x02\x08*\n\r\n\x05\x05\x16\x02\x01\x02\x12\x04\xa5\
    \x02-.\n\x0c\n\x04\x05\x16\x02\x02\x12\x04\xa6\x02\x084\n\r\n\x05\x05\
    \x16\x02\x02\x01\x12\x04\xa6\x02\x08/\n\r\n\x05\x05\x16\x02\x02\x02\x12\
    \x04\xa6\x0223\n\x0c\n\x02\x05\x17\x12\x06\xa9\x02\0\xad\x02\x01\n\x0b\n\
    \x03\x05\x17\x01\x12\x04\xa9\x02\x05\x16\n\x0c\n\x04\x05\x17\x02\0\x12\
    \x04\xaa\x02\x08%\n\r\n\x05\x05\x17\x02\0\x01\x12\x04\xaa\x02\x08\x20\n\
    \r\n\x05\x05\x17\x02\0\x02\x12\x04\xaa\x02#$\n\x0c\n\x04\x05\x17\x02\x01\
    \x12\x04\xab\x02\x08'\n\r\n\x05\x05\x17\x02\x01\x01\x12\x04\xab\x02\x08\
    \"\n\r\n\x05\x05\x17\x02\x01\x02\x12\x04\xab\x02%&\n\x0c\n\x04\x05\x17\
    \x02\x02\x12\x04\xac\x02\x08)\n\r\n\x05\x05\x17\x02\x02\x01\x12\x04\xac\
    \x02\x08$\n\r\n\x05\x05\x17\x02\x02\x02\x12\x04\xac\x02'(\n\x0c\n\x02\
    \x05\x18\x12\x06\xaf\x02\0\xb7\x02\x01\n\x0b\n\x03\x05\x18\x01\x12\x04\
    \xaf\x02\x05\x0e\n\x0c\n\x04\x05\x18\x02\0\x12\x04\xb0\x02\x08\x1e\n\r\n\
    \x05\x05\x18\x02\0\x01\x12\x04\xb0\x02\x08\x19\n\r\n\x05\x05\x18\x02\0\
    \x02\x12\x04\xb0\x02\x1c\x1d\n\x0c\n\x04\x05\x18\x02\x01\x12\x04\xb1\x02\
    \x08!\n\r\n\x05\x05\x18\x02\x01\x01\x12\x04\xb1\x02\x08\x1c\n\r\n\x05\
    \x05\x18\x02\x01\x02\x12\x04\xb1\x02\x1f\x20\n\x0c\n\x04\x05\x18\x02\x02\
    \x12\x04\xb2\x02\x08#\n\r\n\x05\x05\x18\x02\x02\x01\x12\x04\xb2\x02\x08\
    \x1e\n\r\n\x05\x05\x18\x02\x02\x02\x12\x04\xb2\x02!\"\n\x0c\n\x04\x05\
    \x18\x02\x03\x12\x04\xb3\x02\x08'\n\r\n\x05\x05\x18\x02\x03\x01\x12\x04\
    \xb3\x02\x08\"\n\r\n\x05\x05\x18\x02\x03\x02\x12\x04\xb3\x02%&\n\x0c\n\
    \x04\x05\x18\x02\x04\x12\x04\xb4\x02\x08\x1d\n\r\n\x05\x05\x18\x02\x04\
    \x01\x12\x04\xb4\x02\x08\x18\n\r\n\x05\x05\x18\x02\x04\x02\x12\x04\xb4\
    \x02\x1b\x1c\n\x0c\n\x04\x05\x18\x02\x05\x12\x04\xb5\x02\x08*\n\r\n\x05\
    \x05\x18\x02\x05\x01\x12\x04\xb5\x02\x08$\n\r\n\x05\x05\x18\x02\x05\x02\
    \x12\x04\xb5\x02')\n\x0c\n\x04\x05\x18\x02\x06\x12\x04\xb6\x02\x08(\n\r\
    \n\x05\x05\x18\x02\x06\x01\x12\x04\xb6\x02\x08\"\n\r\n\x05\x05\x18\x02\
    \x06\x02\x12\x04\xb6\x02%'\n\x0c\n\x02\x05\x19\x12\x06\xb9\x02\0\xc4\x02\
    \x01\n\x0b\n\x03\x05\x19\x01\x12\x04\xb9\x02\x05\x16\n\x0c\n\x04\x05\x19\
    \x02\0\x12\x04\xba\x02\x08#\n\r\n\x05\x05\x19\x02\0\x01\x12\x04\xba\x02\
    \x08\x1e\n\r\n\x05\x05\x19\x02\0\x02\x12\x04\xba\x02!\"\n\x0c\n\x04\x05\
    \x19\x02\x01\x12\x04\xbb\x02\x08\x20\n\r\n\x05\x05\x19\x02\x01\x01\x12\
    \x04\xbb\x02\x08\x1b\n\r\n\x05\x05\x19\x02\x01\x02\x12\x04\xbb\x02\x1e\
    \x1f\n\x0c\n\x04\x05\x19\x02\x02\x12\x04\xbc\x02\x08\"\n\r\n\x05\x05\x19\
    \x02\x02\x01\x12\x04\xbc\x02\x08\x1d\n\r\n\x05\x05\x19\x02\x02\x02\x12\
    \x04\xbc\x02\x20!\n\x0c\n\x04\x05\x19\x02\x03\x12\x04\xbd\x02\x08\x20\n\
    \r\n\x05\x05\x19\x02\x03\x01\x12\x04\xbd\x02\x08\x1b\n\r\n\x05\x05\x19\
    \x02\x03\x02\x12\x04\xbd\x02\x1e\x1f\n\x0c\n\x04\x05\x19\x02\x04\x12\x04\
    \xbe\x02\x08\"\n\r\n\x05\x05\x19\x02\x04\x01\x12\x04\xbe\x02\x08\x1d\n\r\
    \n\x05\x05\x19\x02\x04\x02\x12\x04\xbe\x02\x20!\n\x0c\n\x04\x05\x19\x02\
    \x05\x12\x04\xbf\x02\x08#\n\r\n\x05\x05\x19\x02\x05\x01\x12\x04\xbf\x02\
    \x08\x1e\n\r\n\x05\x05\x19\x02\x05\x02\x12\x04\xbf\x02!\"\n\x0c\n\x04\
    \x05\x19\x02\x06\x12\x04\xc0\x02\x08\"\n\r\n\x05\x05\x19\x02\x06\x01\x12\
    \x04\xc0\x02\x08\x1d\n\r\n\x05\x05\x19\x02\x06\x02\x12\x04\xc0\x02\x20!\
    \n\x0c\n\x04\x05\x19\x02\x07\x12\x04\xc1\x02\x08\"\n\r\n\x05\x05\x19\x02\
    \x07\x01\x12\x04\xc1\x02\x08\x1d\n\r\n\x05\x05\x19\x02\x07\x02\x12\x04\
    \xc1\x02\x20!\n\x0c\n\x04\x05\x19\x02\x08\x12\x04\xc2\x02\x08\"\n\r\n\
    \x05\x05\x19\x02\x08\x01\x12\x04\xc2\x02\x08\x1d\n\r\n\x05\x05\x19\x02\
    \x08\x02\x12\x04\xc2\x02\x20!\n\x0c\n\x04\x05\x19\x02\t\x12\x04\xc3\x02\
    \x08\x1f\n\r\n\x05\x05\x19\x02\t\x01\x12\x04\xc3\x02\x08\x1a\n\r\n\x05\
    \x05\x19\x02\t\x02\x12\x04\xc3\x02\x1d\x1e\n\x0c\n\x02\x05\x1a\x12\x06\
    \xc6\x02\0\xe2\x02\x01\n\x0b\n\x03\x05\x1a\x01\x12\x04\xc6\x02\x05\x12\n\
    \x0c\n\x04\x05\x1a\x02\0\x12\x04\xc7\x02\x08\x1f\n\r\n\x05\x05\x1a\x02\0\
    \x01\x12\x04\xc7\x02\x08\x1a\n\r\n\x05\x05\x1a\x02\0\x02\x12\x04\xc7\x02\
    \x1d\x1e\n\x0c\n\x04\x05\x1a\x02\x01\x12\x04\xc8\x02\x08!\n\r\n\x05\x05\
    \x1a\x02\x01\x01\x12\x04\xc8\x02\x08\x1c\n\r\n\x05\x05\x1a\x02\x01\x02\
    \x12\x04\xc8\x02\x1f\x20\n\x0c\n\x04\x05\x1a\x02\x02\x12\x04\xc9\x02\x08\
    !\n\r\n\x05\x05\x1a\x02\x02\x01\x12\x04\xc9\x02\x08\x1c\n\r\n\x05\x05\
    \x1a\x02\x02\x02\x12\x04\xc9\x02\x1f\x20\n\x0c\n\x04\x05\x1a\x02\x03\x12\
    \x04\xca\x02\x08\x1f\n\r\n\x05\x05\x1a\x02\x03\x01\x12\x04\xca\x02\x08\
    \x1a\n\r\n\x05\x05\x1a\x02\x03\x02\x12\x04\xca\x02\x1d\x1e\n\x0c\n\x04\
    \x05\x1a\x02\x04\x12\x04\xcb\x02\x08\"\n\r\n\x05\x05\x1a\x02\x04\x01\x12\
    \x04\xcb\x02\x08\x1d\n\r\n\x05\x05\x1a\x02\x04\x02\x12\x04\xcb\x02\x20!\
    \n\x0c\n\x04\x05\x1a\x02\x05\x12\x04\xcc\x02\x08&\n\r\n\x05\x05\x1a\x02\
    \x05\x01\x12\x04\xcc\x02\x08!\n\r\n\x05\x05\x1a\x02\x05\x02\x12\x04\xcc\
    \x02$%\n\x0c\n\x04\x05\x1a\x02\x06\x12\x04\xcd\x02\x08$\n\r\n\x05\x05\
    \x1a\x02\x06\x01\x12\x04\xcd\x02\x08\x1f\n\r\n\x05\x05\x1a\x02\x06\x02\
    \x12\x04\xcd\x02\"#\n\x0c\n\x04\x05\x1a\x02\x07\x12\x04\xce\x02\x08\x1f\
    \n\r\n\x05\x05\x1a\x02\x07\x01\x12\x04\xce\x02\x08\x1a\n\r\n\x05\x05\x1a\
    \x02\x07\x02\x12\x04\xce\x02\x1d\x1e\n\x0c\n\x04\x05\x1a\x02\x08\x12\x04\
    \xcf\x02\x08)\n\r\n\x05\x05\x1a\x02\x08\x01\x12\x04\xcf\x02\x08$\n\r\n\
    \x05\x05\x1a\x02\x08\x02\x12\x04\xcf\x02'(\n\x0c\n\x04\x05\x1a\x02\t\x12\
    \x04\xd0\x02\x08)\n\r\n\x05\x05\x1a\x02\t\x01\x12\x04\xd0\x02\x08$\n\r\n\
    \x05\x05\x1a\x02\t\x02\x12\x04\xd0\x02'(\n\x0c\n\x04\x05\x1a\x02\n\x12\
    \x04\xd1\x02\x08*\n\r\n\x05\x05\x1a\x02\n\x01\x12\x04\xd1\x02\x08$\n\r\n\
    \x05\x05\x1a\x02\n\x02\x12\x04\xd1\x02')\n\x0c\n\x04\x05\x1a\x02\x0b\x12\
    \x04\xd2\x02\x08,\n\r\n\x05\x05\x1a\x02\x0b\x01\x12\x04\xd2\x02\x08&\n\r\
    \n\x05\x05\x1a\x02\x0b\x02\x12\x04\xd2\x02)+\n\x0c\n\x04\x05\x1a\x02\x0c\
    \x12\x04\xd3\x02\x08,\n\r\n\x05\x05\x1a\x02\x0c\x01\x12\x04\xd3\x02\x08&\
    \n\r\n\x05\x05\x1a\x02\x0c\x02\x12\x04\xd3\x02)+\n\x0c\n\x04\x05\x1a\x02\
    \r\x12\x04\xd4\x02\x08,\n\r\n\x05\x05\x1a\x02\r\x01\x12\x04\xd4\x02\x08&\
    \n\r\n\x05\x05\x1a\x02\r\x02\x12\x04\xd4\x02)+\n\x0c\n\x04\x05\x1a\x02\
    \x0e\x12\x04\xd5\x02\x08$\n\r\n\x05\x05\x1a\x02\x0e\x01\x12\x04\xd5\x02\
    \x08\x1e\n\r\n\x05\x05\x1a\x02\x0e\x02\x12\x04\xd5\x02!#\n\x0c\n\x04\x05\
    \x1a\x02\x0f\x12\x04\xd6\x02\x080\n\r\n\x05\x05\x1a\x02\x0f\x01\x12\x04\
    \xd6\x02\x08*\n\r\n\x05\x05\x1a\x02\x0f\x02\x12\x04\xd6\x02-/\n\x0c\n\
    \x04\x05\x1a\x02\x10\x12\x04\xd7\x02\x08%\n\r\n\x05\x05\x1a\x02\x10\x01\
    \x12\x04\xd7\x02\x08\x1f\n\r\n\x05\x05\x1a\x02\x10\x02\x12\x04\xd7\x02\"\
    $\n\x0c\n\x04\x05\x1a\x02\x11\x12\x04\xd8\x02\x08\x20\n\r\n\x05\x05\x1a\
    \x02\x11\x01\x12\x04\xd8\x02\x08\x1a\n\r\n\x05\x05\x1a\x02\x11\x02\x12\
    \x04\xd8\x02\x1d\x1f\n\x0c\n\x04\x05\x1a\x02\x12\x12\x04\xd9\x02\x08'\n\
    \r\n\x05\x05\x1a\x02\x12\x01\x12\x04\xd9\x02\x08!\n\r\n\x05\x05\x1a\x02\
    \x12\x02\x12\x04\xd9\x02$&\n\x0c\n\x04\x05\x1a\x02\x13\x12\x04\xda\x02\
    \x08-\n\r\n\x05\x05\x1a\x02\x13\x01\x12\x04\xda\x02\x08'\n\r\n\x05\x05\
    \x1a\x02\x13\x02\x12\x04\xda\x02*,\n\x0c\n\x04\x05\x1a\x02\x14\x12\x04\
    \xdb\x02\x08\"\n\r\n\x05\x05\x1a\x02\x14\x01\x12\x04\xdb\x02\x08\x1c\n\r\
    \n\x05\x05\x1a\x02\x14\x02\x12\x04\xdb\x02\x1f!\n\x0c\n\x04\x05\x1a\x02\
    \x15\x12\x04\xdc\x02\x08\x20\n\r\n\x05\x05\x1a\x02\x15\x01\x12\x04\xdc\
    \x02\x08\x1a\n\r\n\x05\x05\x1a\x02\x15\x02\x12\x04\xdc\x02\x1d\x1f\n\x0c\
    \n\x04\x05\x1a\x02\x16\x12\x04\xdd\x02\x08\x20\n\r\n\x05\x05\x1a\x02\x16\
    \x01\x12\x04\xdd\x02\x08\x1a\n\r\n\x05\x05\x1a\x02\x16\x02\x12\x04\xdd\
    \x02\x1d\x1f\n\x0c\n\x04\x05\x1a\x02\x17\x12\x04\xde\x02\x08%\n\r\n\x05\
    \x05\x1a\x02\x17\x01\x12\x04\xde\x02\x08\x1f\n\r\n\x05\x05\x1a\x02\x17\
    \x02\x12\x04\xde\x02\"$\n\x0c\n\x04\x05\x1a\x02\x18\x12\x04\xdf\x02\x08)\
    \n\r\n\x05\x05\x1a\x02\x18\x01\x12\x04\xdf\x02\x08#\n\r\n\x05\x05\x1a\
    \x02\x18\x02\x12\x04\xdf\x02&(\n\x0c\n\x04\x05\x1a\x02\x19\x12\x04\xe0\
    \x02\x08\"\n\r\n\x05\x05\x1a\x02\x19\x01\x12\x04\xe0\x02\x08\x1c\n\r\n\
    \x05\x05\x1a\x02\x19\x02\x12\x04\xe0\x02\x1f!\n\x0c\n\x04\x05\x1a\x02\
    \x1a\x12\x04\xe1\x02\x08#\n\r\n\x05\x05\x1a\x02\x1a\x01\x12\x04\xe1\x02\
    \x08\x1d\n\r\n\x05\x05\x1a\x02\x1a\x02\x12\x04\xe1\x02\x20\"\n\x0c\n\x02\
    \x05\x1b\x12\x06\xe4\x02\0\xed\x02\x01\n\x0b\n\x03\x05\x1b\x01\x12\x04\
    \xe4\x02\x05\x13\n\x0c\n\x04\x05\x1b\x02\0\x12\x04\xe5\x02\x08#\n\r\n\
    \x05\x05\x1b\x02\0\x01\x12\x04\xe5\x02\x08\x1e\n\r\n\x05\x05\x1b\x02\0\
    \x02\x12\x04\xe5\x02!\"\n\x0c\n\x04\x05\x1b\x02\x01\x12\x04\xe6\x02\x08#\
    \n\r\n\x05\x05\x1b\x02\x01\x01\x12\x04\xe6\x02\x08\x1e\n\r\n\x05\x05\x1b\
    \x02\x01\x02\x12\x04\xe6\x02!\"\n\x0c\n\x04\x05\x1b\x02\x02\x12\x04\xe7\
    \x02\x08#\n\r\n\x05\x05\x1b\x02\x02\x01\x12\x04\xe7\x02\x08\x1e\n\r\n\
    \x05\x05\x1b\x02\x02\x02\x12\x04\xe7\x02!\"\n\x0c\n\x04\x05\x1b\x02\x03\
    \x12\x04\xe8\x02\x08#\n\r\n\x05\x05\x1b\x02\x03\x01\x12\x04\xe8\x02\x08\
    \x1e\n\r\n\x05\x05\x1b\x02\x03\x02\x12\x04\xe8\x02!\"\n\x0c\n\x04\x05\
    \x1b\x02\x04\x12\x04\xe9\x02\x08\"\n\r\n\x05\x05\x1b\x02\x04\x01\x12\x04\
    \xe9\x02\x08\x1d\n\r\n\x05\x05\x1b\x02\x04\x02\x12\x04\xe9\x02\x20!\n\
    \x0c\n\x04\x05\x1b\x02\x05\x12\x04\xea\x02\x08#\n\r\n\x05\x05\x1b\x02\
    \x05\x01\x12\x04\xea\x02\x08\x1e\n\r\n\x05\x05\x1b\x02\x05\x02\x12\x04\
    \xea\x02!\"\n\x0c\n\x04\x05\x1b\x02\x06\x12\x04\xeb\x02\x08&\n\r\n\x05\
    \x05\x1b\x02\x06\x01\x12\x04\xeb\x02\x08!\n\r\n\x05\x05\x1b\x02\x06\x02\
    \x12\x04\xeb\x02$%\n\x0c\n\x04\x05\x1b\x02\x07\x12\x04\xec\x02\x08$\n\r\
    \n\x05\x05\x1b\x02\x07\x01\x12\x04\xec\x02\x08\x1f\n\r\n\x05\x05\x1b\x02\
    \x07\x02\x12\x04\xec\x02\"#\n\x0c\n\x02\x05\x1c\x12\x06\xef\x02\0\xf7\
    \x02\x01\n\x0b\n\x03\x05\x1c\x01\x12\x04\xef\x02\x05\x1f\n\x0c\n\x04\x05\
    \x1c\x02\0\x12\x04\xf0\x02\x080\n\r\n\x05\x05\x1c\x02\0\x01\x12\x04\xf0\
    \x02\x08+\n\r\n\x05\x05\x1c\x02\0\x02\x12\x04\xf0\x02./\n\x0c\n\x04\x05\
    \x1c\x02\x01\x12\x04\xf1\x02\x080\n\r\n\x05\x05\x1c\x02\x01\x01\x12\x04\
    \xf1\x02\x08+\n\r\n\x05\x05\x1c\x02\x01\x02\x12\x04\xf1\x02./\n\x0c\n\
    \x04\x05\x1c\x02\x02\x12\x04\xf2\x02\x083\n\r\n\x05\x05\x1c\x02\x02\x01\
    \x12\x04\xf2\x02\x08.\n\r\n\x05\x05\x1c\x02\x02\x02\x12\x04\xf2\x0212\n\
    \x0c\n\x04\x05\x1c\x02\x03\x12\x04\xf3\x02\x084\n\r\n\x05\x05\x1c\x02\
    \x03\x01\x12\x04\xf3\x02\x08/\n\r\n\x05\x05\x1c\x02\x03\x02\x12\x04\xf3\
    \x0223\n\x0c\n\x04\x05\x1c\x02\x04\x12\x04\xf4\x02\x08;\n\r\n\x05\x05\
    \x1c\x02\x04\x01\x12\x04\xf4\x02\x086\n\r\n\x05\x05\x1c\x02\x04\x02\x12\
    \x04\xf4\x029:\n\x0c\n\x04\x05\x1c\x02\x05\x12\x04\xf5\x02\x08-\n\r\n\
    \x05\x05\x1c\x02\x05\x01\x12\x04\xf5\x02\x08'\n\r\n\x05\x05\x1c\x02\x05\
    \x02\x12\x04\xf5\x02*,\n\x0c\n\x04\x05\x1c\x02\x06\x12\x04\xf6\x02\x088\
    \n\r\n\x05\x05\x1c\x02\x06\x01\x12\x04\xf6\x02\x081\n\r\n\x05\x05\x1c\
    \x02\x06\x02\x12\x04\xf6\x0247\n\x0c\n\x02\x05\x1d\x12\x06\xf9\x02\0\x8d\
    \x03\x01\n\x0b\n\x03\x05\x1d\x01\x12\x04\xf9\x02\x05\x12\n\x0c\n\x04\x05\
    \x1d\x02\0\x12\x04\xfa\x02\x08$\n\r\n\x05\x05\x1d\x02\0\x01\x12\x04\xfa\
    \x02\x08\x1f\n\r\n\x05\x05\x1d\x02\0\x02\x12\x04\xfa\x02\"#\n\x0c\n\x04\
    \x05\x1d\x02\x01\x12\x04\xfb\x02\x08'\n\r\n\x05\x05\x1d\x02\x01\x01\x12\
    \x04\xfb\x02\x08\"\n\r\n\x05\x05\x1d\x02\x01\x02\x12\x04\xfb\x02%&\n\x0c\
    \n\x04\x05\x1d\x02\x02\x12\x04\xfc\x02\x08(\n\r\n\x05\x05\x1d\x02\x02\
    \x01\x12\x04\xfc\x02\x08#\n\r\n\x05\x05\x1d\x02\x02\x02\x12\x04\xfc\x02&\
    '\n\x0c\n\x04\x05\x1d\x02\x03\x12\x04\xfd\x02\x08+\n\r\n\x05\x05\x1d\x02\
    \x03\x01\x12\x04\xfd\x02\x08&\n\r\n\x05\x05\x1d\x02\x03\x02\x12\x04\xfd\
    \x02)*\n\x0c\n\x04\x05\x1d\x02\x04\x12\x04\xfe\x02\x08)\n\r\n\x05\x05\
    \x1d\x02\x04\x01\x12\x04\xfe\x02\x08$\n\r\n\x05\x05\x1d\x02\x04\x02\x12\
    \x04\xfe\x02'(\n\x0c\n\x04\x05\x1d\x02\x05\x12\x04\xff\x02\x08+\n\r\n\
    \x05\x05\x1d\x02\x05\x01\x12\x04\xff\x02\x08&\n\r\n\x05\x05\x1d\x02\x05\
    \x02\x12\x04\xff\x02)*\n\x0c\n\x04\x05\x1d\x02\x06\x12\x04\x80\x03\x08+\
    \n\r\n\x05\x05\x1d\x02\x06\x01\x12\x04\x80\x03\x08&\n\r\n\x05\x05\x1d\
    \x02\x06\x02\x12\x04\x80\x03)*\n\x0c\n\x04\x05\x1d\x02\x07\x12\x04\x81\
    \x03\x08+\n\r\n\x05\x05\x1d\x02\x07\x01\x12\x04\x81\x03\x08&\n\r\n\x05\
    \x05\x1d\x02\x07\x02\x12\x04\x81\x03)*\n\x0c\n\x04\x05\x1d\x02\x08\x12\
    \x04\x82\x03\x08+\n\r\n\x05\x05\x1d\x02\x08\x01\x12\x04\x82\x03\x08&\n\r\
    \n\x05\x05\x1d\x02\x08\x02\x12\x04\x82\x03)*\n\x0c\n\x04\x05\x1d\x02\t\
    \x12\x04\x83\x03\x08,\n\r\n\x05\x05\x1d\x02\t\x01\x12\x04\x83\x03\x08&\n\
    \r\n\x05\x05\x1d\x02\t\x02\x12\x04\x83\x03)+\n\x0c\n\x04\x05\x1d\x02\n\
    \x12\x04\x84\x03\x08,\n\r\n\x05\x05\x1d\x02\n\x01\x12\x04\x84\x03\x08&\n\
    \r\n\x05\x05\x1d\x02\n\x02\x12\x04\x84\x03)+\n\x0c\n\x04\x05\x1d\x02\x0b\
    \x12\x04\x85\x03\x08,\n\r\n\x05\x05\x1d\x02\x0b\x01\x12\x04\x85\x03\x08&\
    \n\r\n\x05\x05\x1d\x02\x0b\x02\x12\x04\x85\x03)+\n\x0c\n\x04\x05\x1d\x02\
    \x0c\x12\x04\x86\x03\x08,\n\r\n\x05\x05\x1d\x02\x0c\x01\x12\x04\x86\x03\
    \x08&\n\r\n\x05\x05\x1d\x02\x0c\x02\x12\x04\x86\x03)+\n\x0c\n\x04\x05\
    \x1d\x02\r\x12\x04\x87\x03\x08=\n\r\n\x05\x05\x1d\x02\r\x01\x12\x04\x87\
    \x03\x087\n\r\n\x05\x05\x1d\x02\r\x02\x12\x04\x87\x03:<\n\x0c\n\x04\x05\
    \x1d\x02\x0e\x12\x04\x88\x03\x08.\n\r\n\x05\x05\x1d\x02\x0e\x01\x12\x04\
    \x88\x03\x08(\n\r\n\x05\x05\x1d\x02\x0e\x02\x12\x04\x88\x03+-\n\x0c\n\
    \x04\x05\x1d\x02\x0f\x12\x04\x89\x03\x083\n\r\n\x05\x05\x1d\x02\x0f\x01\
    \x12\x04\x89\x03\x08-\n\r\n\x05\x05\x1d\x02\x0f\x02\x12\x04\x89\x0302\n\
    \x0c\n\x04\x05\x1d\x02\x10\x12\x04\x8a\x03\x084\n\r\n\x05\x05\x1d\x02\
    \x10\x01\x12\x04\x8a\x03\x08.\n\r\n\x05\x05\x1d\x02\x10\x02\x12\x04\x8a\
    \x0313\n\x0c\n\x04\x05\x1d\x02\x11\x12\x04\x8b\x03\x080\n\r\n\x05\x05\
    \x1d\x02\x11\x01\x12\x04\x8b\x03\x08*\n\r\n\x05\x05\x1d\x02\x11\x02\x12\
    \x04\x8b\x03-/\n\x0c\n\x04\x05\x1d\x02\x12\x12\x04\x8c\x03\x082\n\r\n\
    \x05\x05\x1d\x02\x12\x01\x12\x04\x8c\x03\x08,\n\r\n\x05\x05\x1d\x02\x12\
    \x02\x12\x04\x8c\x03/1\n\x0c\n\x02\x05\x1e\x12\x06\x8f\x03\0\x96\x03\x01\
    \n\x0b\n\x03\x05\x1e\x01\x12\x04\x8f\x03\x05\x0e\n\x0c\n\x04\x05\x1e\x02\
    \0\x12\x04\x90\x03\x08\x1e\n\r\n\x05\x05\x1e\x02\0\x01\x12\x04\x90\x03\
    \x08\x19\n\r\n\x05\x05\x1e\x02\0\x02\x12\x04\x90\x03\x1c\x1d\n\x0c\n\x04\
    \x05\x1e\x02\x01\x12\x04\x91\x03\x08\x1b\n\r\n\x05\x05\x1e\x02\x01\x01\
    \x12\x04\x91\x03\x08\x16\n\r\n\x05\x05\x1e\x02\x01\x02\x12\x04\x91\x03\
    \x19\x1a\n\x0c\n\x04\x05\x1e\x02\x02\x12\x04\x92\x03\x08\x1a\n\r\n\x05\
    \x05\x1e\x02\x02\x01\x12\x04\x92\x03\x08\x15\n\r\n\x05\x05\x1e\x02\x02\
    \x02\x12\x04\x92\x03\x18\x19\n\x0c\n\x04\x05\x1e\x02\x03\x12\x04\x93\x03\
    \x08\x1a\n\r\n\x05\x05\x1e\x02\x03\x01\x12\x04\x93\x03\x08\x15\n\r\n\x05\
    \x05\x1e\x02\x03\x02\x12\x04\x93\x03\x18\x19\n\x0c\n\x04\x05\x1e\x02\x04\
    \x12\x04\x94\x03\x08\x1d\n\r\n\x05\x05\x1e\x02\x04\x01\x12\x04\x94\x03\
    \x08\x18\n\r\n\x05\x05\x1e\x02\x04\x02\x12\x04\x94\x03\x1b\x1c\n\x0c\n\
    \x04\x05\x1e\x02\x05\x12\x04\x95\x03\x08\x1b\n\r\n\x05\x05\x1e\x02\x05\
    \x01\x12\x04\x95\x03\x08\x16\n\r\n\x05\x05\x1e\x02\x05\x02\x12\x04\x95\
    \x03\x19\x1a\n\x0c\n\x02\x05\x1f\x12\x06\x98\x03\0\xa5\x03\x01\n\x0b\n\
    \x03\x05\x1f\x01\x12\x04\x98\x03\x05\x0f\n\x0c\n\x04\x05\x1f\x02\0\x12\
    \x04\x99\x03\x08%\n\r\n\x05\x05\x1f\x02\0\x01\x12\x04\x99\x03\x08\x20\n\
    \r\n\x05\x05\x1f\x02\0\x02\x12\x04\x99\x03#$\n\x0c\n\x04\x05\x1f\x02\x01\
    \x12\x04\x9a\x03\x08$\n\r\n\x05\x05\x1f\x02\x01\x01\x12\x04\x9a\x03\x08\
    \x1f\n\r\n\x05\x05\x1f\x02\x01\x02\x12\x04\x9a\x03\"#\n\x0c\n\x04\x05\
    \x1f\x02\x02\x12\x04\x9b\x03\x08&\n\r\n\x05\x05\x1f\x02\x02\x01\x12\x04\
    \x9b\x03\x08!\n\r\n\x05\x05\x1f\x02\x02\x02\x12\x04\x9b\x03$%\n\x0c\n\
    \x04\x05\x1f\x02\x03\x12\x04\x9c\x03\x08%\n\r\n\x05\x05\x1f\x02\x03\x01\
    \x12\x04\x9c\x03\x08\x20\n\r\n\x05\x05\x1f\x02\x03\x02\x12\x04\x9c\x03#$\
    \n\x0c\n\x04\x05\x1f\x02\x04\x12\x04\x9d\x03\x08$\n\r\n\x05\x05\x1f\x02\
    \x04\x01\x12\x04\x9d\x03\x08\x1f\n\r\n\x05\x05\x1f\x02\x04\x02\x12\x04\
    \x9d\x03\"#\n\x0c\n\x04\x05\x1f\x02\x05\x12\x04\x9e\x03\x08&\n\r\n\x05\
    \x05\x1f\x02\x05\x01\x12\x04\x9e\x03\x08!\n\r\n\x05\x05\x1f\x02\x05\x02\
    \x12\x04\x9e\x03$%\n\x0c\n\x04\x05\x1f\x02\x06\x12\x04\x9f\x03\x08\x1e\n\
    \r\n\x05\x05\x1f\x02\x06\x01\x12\x04\x9f\x03\x08\x19\n\r\n\x05\x05\x1f\
    \x02\x06\x02\x12\x04\x9f\x03\x1c\x1d\n\x0c\n\x04\x05\x1f\x02\x07\x12\x04\
    \xa0\x03\x08+\n\r\n\x05\x05\x1f\x02\x07\x01\x12\x04\xa0\x03\x08&\n\r\n\
    \x05\x05\x1f\x02\x07\x02\x12\x04\xa0\x03)*\n\x0c\n\x04\x05\x1f\x02\x08\
    \x12\x04\xa1\x03\x08+\n\r\n\x05\x05\x1f\x02\x08\x01\x12\x04\xa1\x03\x08&\
    \n\r\n\x05\x05\x1f\x02\x08\x02\x12\x04\xa1\x03)*\n\x0c\n\x04\x05\x1f\x02\
    \t\x12\x04\xa2\x03\x08,\n\r\n\x05\x05\x1f\x02\t\x01\x12\x04\xa2\x03\x08&\
    \n\r\n\x05\x05\x1f\x02\t\x02\x12\x04\xa2\x03)+\n\x0c\n\x04\x05\x1f\x02\n\
    \x12\x04\xa3\x03\x08,\n\r\n\x05\x05\x1f\x02\n\x01\x12\x04\xa3\x03\x08&\n\
    \r\n\x05\x05\x1f\x02\n\x02\x12\x04\xa3\x03)+\n\x0c\n\x04\x05\x1f\x02\x0b\
    \x12\x04\xa4\x03\x08-\n\r\n\x05\x05\x1f\x02\x0b\x01\x12\x04\xa4\x03\x08'\
    \n\r\n\x05\x05\x1f\x02\x0b\x02\x12\x04\xa4\x03*,\n\x0c\n\x02\x05\x20\x12\
    \x06\xa7\x03\0\xaf\x03\x01\n\x0b\n\x03\x05\x20\x01\x12\x04\xa7\x03\x05\
    \x12\n\x0c\n\x04\x05\x20\x02\0\x12\x04\xa8\x03\x08\x20\n\r\n\x05\x05\x20\
    \x02\0\x01\x12\x04\xa8\x03\x08\x1b\n\r\n\x05\x05\x20\x02\0\x02\x12\x04\
    \xa8\x03\x1e\x1f\n\x0c\n\x04\x05\x20\x02\x01\x12\x04\xa9\x03\x08&\n\r\n\
    \x05\x05\x20\x02\x01\x01\x12\x04\xa9\x03\x08!\n\r\n\x05\x05\x20\x02\x01\
    \x02\x12\x04\xa9\x03$%\n\x0c\n\x04\x05\x20\x02\x02\x12\x04\xaa\x03\x08$\
    \n\r\n\x05\x05\x20\x02\x02\x01\x12\x04\xaa\x03\x08\x1f\n\r\n\x05\x05\x20\
    \x02\x02\x02\x12\x04\xaa\x03\"#\n\x0c\n\x04\x05\x20\x02\x03\x12\x04\xab\
    \x03\x08#\n\r\n\x05\x05\x20\x02\x03\x01\x12\x04\xab\x03\x08\x1e\n\r\n\
    \x05\x05\x20\x02\x03\x02\x12\x04\xab\x03!\"\n\x0c\n\x04\x05\x20\x02\x04\
    \x12\x04\xac\x03\x08#\n\r\n\x05\x05\x20\x02\x04\x01\x12\x04\xac\x03\x08\
    \x1e\n\r\n\x05\x05\x20\x02\x04\x02\x12\x04\xac\x03!\"\n\x0c\n\x04\x05\
    \x20\x02\x05\x12\x04\xad\x03\x08$\n\r\n\x05\x05\x20\x02\x05\x01\x12\x04\
    \xad\x03\x08\x1f\n\r\n\x05\x05\x20\x02\x05\x02\x12\x04\xad\x03\"#\n\x0c\
    \n\x04\x05\x20\x02\x06\x12\x04\xae\x03\x08\"\n\r\n\x05\x05\x20\x02\x06\
    \x01\x12\x04\xae\x03\x08\x1d\n\r\n\x05\x05\x20\x02\x06\x02\x12\x04\xae\
    \x03\x20!\n\x0c\n\x02\x05!\x12\x06\xb1\x03\0\xb9\x03\x01\n\x0b\n\x03\x05\
    !\x01\x12\x04\xb1\x03\x05\x12\n\x0c\n\x04\x05!\x02\0\x12\x04\xb2\x03\x08\
    \x20\n\r\n\x05\x05!\x02\0\x01\x12\x04\xb2\x03\x08\x1b\n\r\n\x05\x05!\x02\
    \0\x02\x12\x04\xb2\x03\x1e\x1f\n\x0c\n\x04\x05!\x02\x01\x12\x04\xb3\x03\
    \x08\x1d\n\r\n\x05\x05!\x02\x01\x01\x12\x04\xb3\x03\x08\x18\n\r\n\x05\
    \x05!\x02\x01\x02\x12\x04\xb3\x03\x1b\x1c\n\x0c\n\x04\x05!\x02\x02\x12\
    \x04\xb4\x03\x08\x1d\n\r\n\x05\x05!\x02\x02\x01\x12\x04\xb4\x03\x08\x18\
    \n\r\n\x05\x05!\x02\x02\x02\x12\x04\xb4\x03\x1b\x1c\n\x0c\n\x04\x05!\x02\
    \x03\x12\x04\xb5\x03\x08\x1e\n\r\n\x05\x05!\x02\x03\x01\x12\x04\xb5\x03\
    \x08\x19\n\r\n\x05\x05!\x02\x03\x02\x12\x04\xb5\x03\x1c\x1d\n\x0c\n\x04\
    \x05!\x02\x04\x12\x04\xb6\x03\x08\x1e\n\r\n\x05\x05!\x02\x04\x01\x12\x04\
    \xb6\x03\x08\x19\n\r\n\x05\x05!\x02\x04\x02\x12\x04\xb6\x03\x1c\x1d\n\
    \x0c\n\x04\x05!\x02\x05\x12\x04\xb7\x03\x08\x20\n\r\n\x05\x05!\x02\x05\
    \x01\x12\x04\xb7\x03\x08\x1b\n\r\n\x05\x05!\x02\x05\x02\x12\x04\xb7\x03\
    \x1e\x1f\n\x0c\n\x04\x05!\x02\x06\x12\x04\xb8\x03\x08\x1e\n\r\n\x05\x05!\
    \x02\x06\x01\x12\x04\xb8\x03\x08\x19\n\r\n\x05\x05!\x02\x06\x02\x12\x04\
    \xb8\x03\x1c\x1d\n\x0c\n\x02\x05\"\x12\x06\xbb\x03\0\xc6\x03\x01\n\x0b\n\
    \x03\x05\"\x01\x12\x04\xbb\x03\x05\x10\n\x0c\n\x04\x05\"\x02\0\x12\x04\
    \xbc\x03\x08\x1e\n\r\n\x05\x05\"\x02\0\x01\x12\x04\xbc\x03\x08\x19\n\r\n\
    \x05\x05\"\x02\0\x02\x12\x04\xbc\x03\x1c\x1d\n\x0c\n\x04\x05\"\x02\x01\
    \x12\x04\xbd\x03\x08\x20\n\r\n\x05\x05\"\x02\x01\x01\x12\x04\xbd\x03\x08\
    \x1b\n\r\n\x05\x05\"\x02\x01\x02\x12\x04\xbd\x03\x1e\x1f\n\x0c\n\x04\x05\
    \"\x02\x02\x12\x04\xbe\x03\x08%\n\r\n\x05\x05\"\x02\x02\x01\x12\x04\xbe\
    \x03\x08\x20\n\r\n\x05\x05\"\x02\x02\x02\x12\x04\xbe\x03#$\n\x0c\n\x04\
    \x05\"\x02\x03\x12\x04\xbf\x03\x08\x1e\n\r\n\x05\x05\"\x02\x03\x01\x12\
    \x04\xbf\x03\x08\x19\n\r\n\x05\x05\"\x02\x03\x02\x12\x04\xbf\x03\x1c\x1d\
    \n\x0c\n\x04\x05\"\x02\x04\x12\x04\xc0\x03\x08\x1e\n\r\n\x05\x05\"\x02\
    \x04\x01\x12\x04\xc0\x03\x08\x19\n\r\n\x05\x05\"\x02\x04\x02\x12\x04\xc0\
    \x03\x1c\x1d\n\x0c\n\x04\x05\"\x02\x05\x12\x04\xc1\x03\x08&\n\r\n\x05\
    \x05\"\x02\x05\x01\x12\x04\xc1\x03\x08!\n\r\n\x05\x05\"\x02\x05\x02\x12\
    \x04\xc1\x03$%\n\x0c\n\x04\x05\"\x02\x06\x12\x04\xc2\x03\x08&\n\r\n\x05\
    \x05\"\x02\x06\x01\x12\x04\xc2\x03\x08!\n\r\n\x05\x05\"\x02\x06\x02\x12\
    \x04\xc2\x03$%\n\x0c\n\x04\x05\"\x02\x07\x12\x04\xc3\x03\x08-\n\r\n\x05\
    \x05\"\x02\x07\x01\x12\x04\xc3\x03\x08(\n\r\n\x05\x05\"\x02\x07\x02\x12\
    \x04\xc3\x03+,\n\x0c\n\x04\x05\"\x02\x08\x12\x04\xc4\x03\x08#\n\r\n\x05\
    \x05\"\x02\x08\x01\x12\x04\xc4\x03\x08\x1e\n\r\n\x05\x05\"\x02\x08\x02\
    \x12\x04\xc4\x03!\"\n\x0c\n\x04\x05\"\x02\t\x12\x04\xc5\x03\x08*\n\r\n\
    \x05\x05\"\x02\t\x01\x12\x04\xc5\x03\x08%\n\r\n\x05\x05\"\x02\t\x02\x12\
    \x04\xc5\x03()\n\x0c\n\x02\x05#\x12\x06\xc8\x03\0\xcc\x03\x01\n\x0b\n\
    \x03\x05#\x01\x12\x04\xc8\x03\x05\x18\n\x0c\n\x04\x05#\x02\0\x12\x04\xc9\
    \x03\x08)\n\r\n\x05\x05#\x02\0\x01\x12\x04\xc9\x03\x08$\n\r\n\x05\x05#\
    \x02\0\x02\x12\x04\xc9\x03'(\n\x0c\n\x04\x05#\x02\x01\x12\x04\xca\x03\
    \x08.\n\r\n\x05\x05#\x02\x01\x01\x12\x04\xca\x03\x08)\n\r\n\x05\x05#\x02\
    \x01\x02\x12\x04\xca\x03,-\n\x0c\n\x04\x05#\x02\x02\x12\x04\xcb\x03\x08%\
    \n\r\n\x05\x05#\x02\x02\x01\x12\x04\xcb\x03\x08\x20\n\r\n\x05\x05#\x02\
    \x02\x02\x12\x04\xcb\x03#$\n\x0c\n\x02\x05$\x12\x06\xce\x03\0\xd2\x03\
    \x01\n\x0b\n\x03\x05$\x01\x12\x04\xce\x03\x05\x14\n\x0c\n\x04\x05$\x02\0\
    \x12\x04\xcf\x03\x08\"\n\r\n\x05\x05$\x02\0\x01\x12\x04\xcf\x03\x08\x1d\
    \n\r\n\x05\x05$\x02\0\x02\x12\x04\xcf\x03\x20!\n\x0c\n\x04\x05$\x02\x01\
    \x12\x04\xd0\x03\x08\x1e\n\r\n\x05\x05$\x02\x01\x01\x12\x04\xd0\x03\x08\
    \x19\n\r\n\x05\x05$\x02\x01\x02\x12\x04\xd0\x03\x1c\x1d\n\x0c\n\x04\x05$\
    \x02\x02\x12\x04\xd1\x03\x08\x1f\n\r\n\x05\x05$\x02\x02\x01\x12\x04\xd1\
    \x03\x08\x1a\n\r\n\x05\x05$\x02\x02\x02\x12\x04\xd1\x03\x1d\x1e\n\x0c\n\
    \x02\x05%\x12\x06\xd4\x03\0\xda\x03\x01\n\x0b\n\x03\x05%\x01\x12\x04\xd4\
    \x03\x05\x1d\n\x0c\n\x04\x05%\x02\0\x12\x04\xd5\x03\x08%\n\r\n\x05\x05%\
    \x02\0\x01\x12\x04\xd5\x03\x08\x20\n\r\n\x05\x05%\x02\0\x02\x12\x04\xd5\
    \x03#$\n\x0c\n\x04\x05%\x02\x01\x12\x04\xd6\x03\x08#\n\r\n\x05\x05%\x02\
    \x01\x01\x12\x04\xd6\x03\x08\x1e\n\r\n\x05\x05%\x02\x01\x02\x12\x04\xd6\
    \x03!\"\n\x0c\n\x04\x05%\x02\x02\x12\x04\xd7\x03\x08$\n\r\n\x05\x05%\x02\
    \x02\x01\x12\x04\xd7\x03\x08\x1f\n\r\n\x05\x05%\x02\x02\x02\x12\x04\xd7\
    \x03\"#\n\x0c\n\x04\x05%\x02\x03\x12\x04\xd8\x03\x08%\n\r\n\x05\x05%\x02\
    \x03\x01\x12\x04\xd8\x03\x08\x20\n\r\n\x05\x05%\x02\x03\x02\x12\x04\xd8\
    \x03#$\n\x0c\n\x04\x05%\x02\x04\x12\x04\xd9\x03\x08%\n\r\n\x05\x05%\x02\
    \x04\x01\x12\x04\xd9\x03\x08\x1e\n\r\n\x05\x05%\x02\x04\x02\x12\x04\xd9\
    \x03!$\n\x0c\n\x02\x05&\x12\x06\xdc\x03\0\xe1\x03\x01\n\x0b\n\x03\x05&\
    \x01\x12\x04\xdc\x03\x05\x11\n\x0c\n\x04\x05&\x02\0\x12\x04\xdd\x03\x08\
    \x1f\n\r\n\x05\x05&\x02\0\x01\x12\x04\xdd\x03\x08\x1a\n\r\n\x05\x05&\x02\
    \0\x02\x12\x04\xdd\x03\x1d\x1e\n\x0c\n\x04\x05&\x02\x01\x12\x04\xde\x03\
    \x08,\n\r\n\x05\x05&\x02\x01\x01\x12\x04\xde\x03\x08'\n\r\n\x05\x05&\x02\
    \x01\x02\x12\x04\xde\x03*+\n\x0c\n\x04\x05&\x02\x02\x12\x04\xdf\x03\x08%\
    \n\r\n\x05\x05&\x02\x02\x01\x12\x04\xdf\x03\x08\x20\n\r\n\x05\x05&\x02\
    \x02\x02\x12\x04\xdf\x03#$\n\x0c\n\x04\x05&\x02\x03\x12\x04\xe0\x03\x08$\
    \n\r\n\x05\x05&\x02\x03\x01\x12\x04\xe0\x03\x08\x1f\n\r\n\x05\x05&\x02\
    \x03\x02\x12\x04\xe0\x03\"#\n\x0c\n\x02\x05'\x12\x06\xe3\x03\0\x8e\x04\
    \x01\n\x0b\n\x03\x05'\x01\x12\x04\xe3\x03\x05\x17\n\x0c\n\x04\x05'\x02\0\
    \x12\x04\xe4\x03\x08(\n\r\n\x05\x05'\x02\0\x01\x12\x04\xe4\x03\x08#\n\r\
    \n\x05\x05'\x02\0\x02\x12\x04\xe4\x03&'\n\x0c\n\x04\x05'\x02\x01\x12\x04\
    \xe5\x03\x08.\n\r\n\x05\x05'\x02\x01\x01\x12\x04\xe5\x03\x08)\n\r\n\x05\
    \x05'\x02\x01\x02\x12\x04\xe5\x03,-\n\x0c\n\x04\x05'\x02\x02\x12\x04\xe6\
    \x03\x08,\n\r\n\x05\x05'\x02\x02\x01\x12\x04\xe6\x03\x08'\n\r\n\x05\x05'\
    \x02\x02\x02\x12\x04\xe6\x03*+\n\x0c\n\x04\x05'\x02\x03\x12\x04\xe7\x03\
    \x08.\n\r\n\x05\x05'\x02\x03\x01\x12\x04\xe7\x03\x08)\n\r\n\x05\x05'\x02\
    \x03\x02\x12\x04\xe7\x03,-\n\x0c\n\x04\x05'\x02\x04\x12\x04\xe8\x03\x081\
    \n\r\n\x05\x05'\x02\x04\x01\x12\x04\xe8\x03\x08,\n\r\n\x05\x05'\x02\x04\
    \x02\x12\x04\xe8\x03/0\n\x0c\n\x04\x05'\x02\x05\x12\x04\xe9\x03\x084\n\r\
    \n\x05\x05'\x02\x05\x01\x12\x04\xe9\x03\x08/\n\r\n\x05\x05'\x02\x05\x02\
    \x12\x04\xe9\x0323\n\x0c\n\x04\x05'\x02\x06\x12\x04\xea\x03\x085\n\r\n\
    \x05\x05'\x02\x06\x01\x12\x04\xea\x03\x080\n\r\n\x05\x05'\x02\x06\x02\
    \x12\x04\xea\x0334\n\x0c\n\x04\x05'\x02\x07\x12\x04\xeb\x03\x082\n\r\n\
    \x05\x05'\x02\x07\x01\x12\x04\xeb\x03\x08-\n\r\n\x05\x05'\x02\x07\x02\
    \x12\x04\xeb\x0301\n\x0c\n\x04\x05'\x02\x08\x12\x04\xec\x03\x085\n\r\n\
    \x05\x05'\x02\x08\x01\x12\x04\xec\x03\x080\n\r\n\x05\x05'\x02\x08\x02\
    \x12\x04\xec\x0334\n\x0c\n\x04\x05'\x02\t\x12\x04\xed\x03\x085\n\r\n\x05\
    \x05'\x02\t\x01\x12\x04\xed\x03\x080\n\r\n\x05\x05'\x02\t\x02\x12\x04\
    \xed\x0334\n\x0c\n\x04\x05'\x02\n\x12\x04\xee\x03\x086\n\r\n\x05\x05'\
    \x02\n\x01\x12\x04\xee\x03\x080\n\r\n\x05\x05'\x02\n\x02\x12\x04\xee\x03\
    35\n\x0c\n\x04\x05'\x02\x0b\x12\x04\xef\x03\x082\n\r\n\x05\x05'\x02\x0b\
    \x01\x12\x04\xef\x03\x08,\n\r\n\x05\x05'\x02\x0b\x02\x12\x04\xef\x03/1\n\
    \x0c\n\x04\x05'\x02\x0c\x12\x04\xf0\x03\x087\n\r\n\x05\x05'\x02\x0c\x01\
    \x12\x04\xf0\x03\x081\n\r\n\x05\x05'\x02\x0c\x02\x12\x04\xf0\x0346\n\x0c\
    \n\x04\x05'\x02\r\x12\x04\xf1\x03\x08<\n\r\n\x05\x05'\x02\r\x01\x12\x04\
    \xf1\x03\x086\n\r\n\x05\x05'\x02\r\x02\x12\x04\xf1\x039;\n\x0c\n\x04\x05\
    '\x02\x0e\x12\x04\xf2\x03\x08?\n\r\n\x05\x05'\x02\x0e\x01\x12\x04\xf2\
    \x03\x089\n\r\n\x05\x05'\x02\x0e\x02\x12\x04\xf2\x03<>\n\x0c\n\x04\x05'\
    \x02\x0f\x12\x04\xf3\x03\x084\n\r\n\x05\x05'\x02\x0f\x01\x12\x04\xf3\x03\
    \x08.\n\r\n\x05\x05'\x02\x0f\x02\x12\x04\xf3\x0313\n\x0c\n\x04\x05'\x02\
    \x10\x12\x04\xf4\x03\x082\n\r\n\x05\x05'\x02\x10\x01\x12\x04\xf4\x03\x08\
    ,\n\r\n\x05\x05'\x02\x10\x02\x12\x04\xf4\x03/1\n\x0c\n\x04\x05'\x02\x11\
    \x12\x04\xf5\x03\x089\n\r\n\x05\x05'\x02\x11\x01\x12\x04\xf5\x03\x083\n\
    \r\n\x05\x05'\x02\x11\x02\x12\x04\xf5\x0368\n\x0c\n\x04\x05'\x02\x12\x12\
    \x04\xf6\x03\x08<\n\r\n\x05\x05'\x02\x12\x01\x12\x04\xf6\x03\x086\n\r\n\
    \x05\x05'\x02\x12\x02\x12\x04\xf6\x039;\n\x0c\n\x04\x05'\x02\x13\x12\x04\
    \xf7\x03\x087\n\r\n\x05\x05'\x02\x13\x01\x12\x04\xf7\x03\x081\n\r\n\x05\
    \x05'\x02\x13\x02\x12\x04\xf7\x0346\n\x0c\n\x04\x05'\x02\x14\x12\x04\xf8\
    \x03\x084\n\r\n\x05\x05'\x02\x14\x01\x12\x04\xf8\x03\x08.\n\r\n\x05\x05'\
    \x02\x14\x02\x12\x04\xf8\x0313\n\x0c\n\x04\x05'\x02\x15\x12\x04\xf9\x03\
    \x082\n\r\n\x05\x05'\x02\x15\x01\x12\x04\xf9\x03\x08,\n\r\n\x05\x05'\x02\
    \x15\x02\x12\x04\xf9\x03/1\n\x0c\n\x04\x05'\x02\x16\x12\x04\xfa\x03\x083\
    \n\r\n\x05\x05'\x02\x16\x01\x12\x04\xfa\x03\x08,\n\r\n\x05\x05'\x02\x16\
    \x02\x12\x04\xfa\x03/2\n\x0c\n\x04\x05'\x02\x17\x12\x04\xfb\x03\x084\n\r\
    \n\x05\x05'\x02\x17\x01\x12\x04\xfb\x03\x08-\n\r\n\x05\x05'\x02\x17\x02\
    \x12\x04\xfb\x0303\n\x0c\n\x04\x05'\x02\x18\x12\x04\xfc\x03\x085\n\r\n\
    \x05\x05'\x02\x18\x01\x12\x04\xfc\x03\x08.\n\r\n\x05\x05'\x02\x18\x02\
    \x12\x04\xfc\x0314\n\x0c\n\x04\x05'\x02\x19\x12\x04\xfd\x03\x088\n\r\n\
    \x05\x05'\x02\x19\x01\x12\x04\xfd\x03\x081\n\r\n\x05\x05'\x02\x19\x02\
    \x12\x04\xfd\x0347\n\x0c\n\x04\x05'\x02\x1a\x12\x04\xfe\x03\x08:\n\r\n\
    \x05\x05'\x02\x1a\x01\x12\x04\xfe\x03\x083\n\r\n\x05\x05'\x02\x1a\x02\
    \x12\x04\xfe\x0369\n\x0c\n\x04\x05'\x02\x1b\x12\x04\xff\x03\x081\n\r\n\
    \x05\x05'\x02\x1b\x01\x12\x04\xff\x03\x08*\n\r\n\x05\x05'\x02\x1b\x02\
    \x12\x04\xff\x03-0\n\x0c\n\x04\x05'\x02\x1c\x12\x04\x80\x04\x085\n\r\n\
    \x05\x05'\x02\x1c\x01\x12\x04\x80\x04\x08.\n\r\n\x05\x05'\x02\x1c\x02\
    \x12\x04\x80\x0414\n\x0c\n\x04\x05'\x02\x1d\x12\x04\x81\x04\x086\n\r\n\
    \x05\x05'\x02\x1d\x01\x12\x04\x81\x04\x08/\n\r\n\x05\x05'\x02\x1d\x02\
    \x12\x04\x81\x0425\n\x0c\n\x04\x05'\x02\x1e\x12\x04\x82\x04\x08D\n\r\n\
    \x05\x05'\x02\x1e\x01\x12\x04\x82\x04\x08=\n\r\n\x05\x05'\x02\x1e\x02\
    \x12\x04\x82\x04@C\n\x0c\n\x04\x05'\x02\x1f\x12\x04\x83\x04\x08C\n\r\n\
    \x05\x05'\x02\x1f\x01\x12\x04\x83\x04\x08<\n\r\n\x05\x05'\x02\x1f\x02\
    \x12\x04\x83\x04?B\n\x0c\n\x04\x05'\x02\x20\x12\x04\x84\x04\x08.\n\r\n\
    \x05\x05'\x02\x20\x01\x12\x04\x84\x04\x08'\n\r\n\x05\x05'\x02\x20\x02\
    \x12\x04\x84\x04*-\n\x0c\n\x04\x05'\x02!\x12\x04\x85\x04\x08/\n\r\n\x05\
    \x05'\x02!\x01\x12\x04\x85\x04\x08(\n\r\n\x05\x05'\x02!\x02\x12\x04\x85\
    \x04+.\n\x0c\n\x04\x05'\x02\"\x12\x04\x86\x04\x082\n\r\n\x05\x05'\x02\"\
    \x01\x12\x04\x86\x04\x08+\n\r\n\x05\x05'\x02\"\x02\x12\x04\x86\x04.1\n\
    \x0c\n\x04\x05'\x02#\x12\x04\x87\x04\x080\n\r\n\x05\x05'\x02#\x01\x12\
    \x04\x87\x04\x08)\n\r\n\x05\x05'\x02#\x02\x12\x04\x87\x04,/\n\x0c\n\x04\
    \x05'\x02$\x12\x04\x88\x04\x085\n\r\n\x05\x05'\x02$\x01\x12\x04\x88\x04\
    \x08.\n\r\n\x05\x05'\x02$\x02\x12\x04\x88\x0414\n\x0c\n\x04\x05'\x02%\
    \x12\x04\x89\x04\x085\n\r\n\x05\x05'\x02%\x01\x12\x04\x89\x04\x08.\n\r\n\
    \x05\x05'\x02%\x02\x12\x04\x89\x0414\n\x0c\n\x04\x05'\x02&\x12\x04\x8a\
    \x04\x080\n\r\n\x05\x05'\x02&\x01\x12\x04\x8a\x04\x08)\n\r\n\x05\x05'\
    \x02&\x02\x12\x04\x8a\x04,/\n\x0c\n\x04\x05'\x02'\x12\x04\x8b\x04\x087\n\
    \r\n\x05\x05'\x02'\x01\x12\x04\x8b\x04\x080\n\r\n\x05\x05'\x02'\x02\x12\
    \x04\x8b\x0436\n\x0c\n\x04\x05'\x02(\x12\x04\x8c\x04\x081\n\r\n\x05\x05'\
    \x02(\x01\x12\x04\x8c\x04\x08*\n\r\n\x05\x05'\x02(\x02\x12\x04\x8c\x04-0\
    \n\x0c\n\x04\x05'\x02)\x12\x04\x8d\x04\x08,\n\r\n\x05\x05'\x02)\x01\x12\
    \x04\x8d\x04\x08%\n\r\n\x05\x05'\x02)\x02\x12\x04\x8d\x04(+\n\x0c\n\x02\
    \x05(\x12\x06\x90\x04\0\xbe\x04\x01\n\x0b\n\x03\x05(\x01\x12\x04\x90\x04\
    \x05\x19\n\x0c\n\x04\x05(\x02\0\x12\x04\x91\x04\x08$\n\r\n\x05\x05(\x02\
    \0\x01\x12\x04\x91\x04\x08\x1e\n\r\n\x05\x05(\x02\0\x02\x12\x04\x91\x04!\
    #\n\x0c\n\x04\x05(\x02\x01\x12\x04\x92\x04\x08\"\n\r\n\x05\x05(\x02\x01\
    \x01\x12\x04\x92\x04\x08\x1d\n\r\n\x05\x05(\x02\x01\x02\x12\x04\x92\x04\
    \x20!\n\x0c\n\x04\x05(\x02\x02\x12\x04\x93\x04\x08\x20\n\r\n\x05\x05(\
    \x02\x02\x01\x12\x04\x93\x04\x08\x1b\n\r\n\x05\x05(\x02\x02\x02\x12\x04\
    \x93\x04\x1e\x1f\n\x0c\n\x04\x05(\x02\x03\x12\x04\x94\x04\x08(\n\r\n\x05\
    \x05(\x02\x03\x01\x12\x04\x94\x04\x08#\n\r\n\x05\x05(\x02\x03\x02\x12\
    \x04\x94\x04&'\n\x0c\n\x04\x05(\x02\x04\x12\x04\x95\x04\x08+\n\r\n\x05\
    \x05(\x02\x04\x01\x12\x04\x95\x04\x08&\n\r\n\x05\x05(\x02\x04\x02\x12\
    \x04\x95\x04)*\n\x0c\n\x04\x05(\x02\x05\x12\x04\x96\x04\x08!\n\r\n\x05\
    \x05(\x02\x05\x01\x12\x04\x96\x04\x08\x1c\n\r\n\x05\x05(\x02\x05\x02\x12\
    \x04\x96\x04\x1f\x20\n\x0c\n\x04\x05(\x02\x06\x12\x04\x97\x04\x08#\n\r\n\
    \x05\x05(\x02\x06\x01\x12\x04\x97\x04\x08\x1e\n\r\n\x05\x05(\x02\x06\x02\
    \x12\x04\x97\x04!\"\n\x0c\n\x04\x05(\x02\x07\x12\x04\x98\x04\x08\x20\n\r\
    \n\x05\x05(\x02\x07\x01\x12\x04\x98\x04\x08\x1b\n\r\n\x05\x05(\x02\x07\
    \x02\x12\x04\x98\x04\x1e\x1f\n\x0c\n\x04\x05(\x02\x08\x12\x04\x99\x04\
    \x08$\n\r\n\x05\x05(\x02\x08\x01\x12\x04\x99\x04\x08\x1f\n\r\n\x05\x05(\
    \x02\x08\x02\x12\x04\x99\x04\"#\n\x0c\n\x04\x05(\x02\t\x12\x04\x9a\x04\
    \x08\x20\n\r\n\x05\x05(\x02\t\x01\x12\x04\x9a\x04\x08\x1b\n\r\n\x05\x05(\
    \x02\t\x02\x12\x04\x9a\x04\x1e\x1f\n\x0c\n\x04\x05(\x02\n\x12\x04\x9b\
    \x04\x08&\n\r\n\x05\x05(\x02\n\x01\x12\x04\x9b\x04\x08!\n\r\n\x05\x05(\
    \x02\n\x02\x12\x04\x9b\x04$%\n\x0c\n\x04\x05(\x02\x0b\x12\x04\x9c\x04\
    \x08\x1f\n\r\n\x05\x05(\x02\x0b\x01\x12\x04\x9c\x04\x08\x19\n\r\n\x05\
    \x05(\x02\x0b\x02\x12\x04\x9c\x04\x1c\x1e\n\x0c\n\x04\x05(\x02\x0c\x12\
    \x04\x9d\x04\x08%\n\r\n\x05\x05(\x02\x0c\x01\x12\x04\x9d\x04\x08\x1f\n\r\
    \n\x05\x05(\x02\x0c\x02\x12\x04\x9d\x04\"$\n\x0c\n\x04\x05(\x02\r\x12\
    \x04\x9e\x04\x08$\n\r\n\x05\x05(\x02\r\x01\x12\x04\x9e\x04\x08\x1e\n\r\n\
    \x05\x05(\x02\r\x02\x12\x04\x9e\x04!#\n\x0c\n\x04\x05(\x02\x0e\x12\x04\
    \x9f\x04\x08,\n\r\n\x05\x05(\x02\x0e\x01\x12\x04\x9f\x04\x08&\n\r\n\x05\
    \x05(\x02\x0e\x02\x12\x04\x9f\x04)+\n\x0c\n\x04\x05(\x02\x0f\x12\x04\xa0\
    \x04\x08(\n\r\n\x05\x05(\x02\x0f\x01\x12\x04\xa0\x04\x08\"\n\r\n\x05\x05\
    (\x02\x0f\x02\x12\x04\xa0\x04%'\n\x0c\n\x04\x05(\x02\x10\x12\x04\xa1\x04\
    \x08&\n\r\n\x05\x05(\x02\x10\x01\x12\x04\xa1\x04\x08\x20\n\r\n\x05\x05(\
    \x02\x10\x02\x12\x04\xa1\x04#%\n\x0c\n\x04\x05(\x02\x11\x12\x04\xa2\x04\
    \x08'\n\r\n\x05\x05(\x02\x11\x01\x12\x04\xa2\x04\x08!\n\r\n\x05\x05(\x02\
    \x11\x02\x12\x04\xa2\x04$&\n\x0c\n\x04\x05(\x02\x12\x12\x04\xa3\x04\x08/\
    \n\r\n\x05\x05(\x02\x12\x01\x12\x04\xa3\x04\x08)\n\r\n\x05\x05(\x02\x12\
    \x02\x12\x04\xa3\x04,.\n\x0c\n\x04\x05(\x02\x13\x12\x04\xa4\x04\x08(\n\r\
    \n\x05\x05(\x02\x13\x01\x12\x04\xa4\x04\x08\"\n\r\n\x05\x05(\x02\x13\x02\
    \x12\x04\xa4\x04%'\n\x0c\n\x04\x05(\x02\x14\x12\x04\xa5\x04\x081\n\r\n\
    \x05\x05(\x02\x14\x01\x12\x04\xa5\x04\x08+\n\r\n\x05\x05(\x02\x14\x02\
    \x12\x04\xa5\x04.0\n\x0c\n\x04\x05(\x02\x15\x12\x04\xa6\x04\x08/\n\r\n\
    \x05\x05(\x02\x15\x01\x12\x04\xa6\x04\x08)\n\r\n\x05\x05(\x02\x15\x02\
    \x12\x04\xa6\x04,.\n\x0c\n\x04\x05(\x02\x16\x12\x04\xa7\x04\x08(\n\r\n\
    \x05\x05(\x02\x16\x01\x12\x04\xa7\x04\x08\"\n\r\n\x05\x05(\x02\x16\x02\
    \x12\x04\xa7\x04%'\n\x0c\n\x04\x05(\x02\x17\x12\x04\xa8\x04\x08/\n\r\n\
    \x05\x05(\x02\x17\x01\x12\x04\xa8\x04\x08)\n\r\n\x05\x05(\x02\x17\x02\
    \x12\x04\xa8\x04,.\n\x0c\n\x04\x05(\x02\x18\x12\x04\xa9\x04\x08'\n\r\n\
    \x05\x05(\x02\x18\x01\x12\x04\xa9\x04\x08!\n\r\n\x05\x05(\x02\x18\x02\
    \x12\x04\xa9\x04$&\n\x0c\n\x04\x05(\x02\x19\x12\x04\xaa\x04\x08*\n\r\n\
    \x05\x05(\x02\x19\x01\x12\x04\xaa\x04\x08$\n\r\n\x05\x05(\x02\x19\x02\
    \x12\x04\xaa\x04')\n\x0c\n\x04\x05(\x02\x1a\x12\x04\xab\x04\x08)\n\r\n\
    \x05\x05(\x02\x1a\x01\x12\x04\xab\x04\x08#\n\r\n\x05\x05(\x02\x1a\x02\
    \x12\x04\xab\x04&(\n\x0c\n\x04\x05(\x02\x1b\x12\x04\xac\x04\x08-\n\r\n\
    \x05\x05(\x02\x1b\x01\x12\x04\xac\x04\x08'\n\r\n\x05\x05(\x02\x1b\x02\
    \x12\x04\xac\x04*,\n\x0c\n\x04\x05(\x02\x1c\x12\x04\xad\x04\x08*\n\r\n\
    \x05\x05(\x02\x1c\x01\x12\x04\xad\x04\x08$\n\r\n\x05\x05(\x02\x1c\x02\
    \x12\x04\xad\x04')\n\x0c\n\x04\x05(\x02\x1d\x12\x04\xae\x04\x08.\n\r\n\
    \x05\x05(\x02\x1d\x01\x12\x04\xae\x04\x08(\n\r\n\x05\x05(\x02\x1d\x02\
    \x12\x04\xae\x04+-\n\x0c\n\x04\x05(\x02\x1e\x12\x04\xaf\x04\x08(\n\r\n\
    \x05\x05(\x02\x1e\x01\x12\x04\xaf\x04\x08\"\n\r\n\x05\x05(\x02\x1e\x02\
    \x12\x04\xaf\x04%'\n\x0c\n\x04\x05(\x02\x1f\x12\x04\xb0\x04\x08(\n\r\n\
    \x05\x05(\x02\x1f\x01\x12\x04\xb0\x04\x08\"\n\r\n\x05\x05(\x02\x1f\x02\
    \x12\x04\xb0\x04%'\n\x0c\n\x04\x05(\x02\x20\x12\x04\xb1\x04\x08(\n\r\n\
    \x05\x05(\x02\x20\x01\x12\x04\xb1\x04\x08\"\n\r\n\x05\x05(\x02\x20\x02\
    \x12\x04\xb1\x04%'\n\x0c\n\x04\x05(\x02!\x12\x04\xb2\x04\x086\n\r\n\x05\
    \x05(\x02!\x01\x12\x04\xb2\x04\x080\n\r\n\x05\x05(\x02!\x02\x12\x04\xb2\
    \x0435\n\x0c\n\x04\x05(\x02\"\x12\x04\xb3\x04\x08*\n\r\n\x05\x05(\x02\"\
    \x01\x12\x04\xb3\x04\x08$\n\r\n\x05\x05(\x02\"\x02\x12\x04\xb3\x04')\n\
    \x0c\n\x04\x05(\x02#\x12\x04\xb4\x04\x08)\n\r\n\x05\x05(\x02#\x01\x12\
    \x04\xb4\x04\x08#\n\r\n\x05\x05(\x02#\x02\x12\x04\xb4\x04&(\n\x0c\n\x04\
    \x05(\x02$\x12\x04\xb5\x04\x08%\n\r\n\x05\x05(\x02$\x01\x12\x04\xb5\x04\
    \x08\x1f\n\r\n\x05\x05(\x02$\x02\x12\x04\xb5\x04\"$\n\x0c\n\x04\x05(\x02\
    %\x12\x04\xb6\x04\x08,\n\r\n\x05\x05(\x02%\x01\x12\x04\xb6\x04\x08&\n\r\
    \n\x05\x05(\x02%\x02\x12\x04\xb6\x04)+\n\x0c\n\x04\x05(\x02&\x12\x04\xb7\
    \x04\x08+\n\r\n\x05\x05(\x02&\x01\x12\x04\xb7\x04\x08%\n\r\n\x05\x05(\
    \x02&\x02\x12\x04\xb7\x04(*\n\x0c\n\x04\x05(\x02'\x12\x04\xb8\x04\x08.\n\
    \r\n\x05\x05(\x02'\x01\x12\x04\xb8\x04\x08(\n\r\n\x05\x05(\x02'\x02\x12\
    \x04\xb8\x04+-\n\x0c\n\x04\x05(\x02(\x12\x04\xb9\x04\x08,\n\r\n\x05\x05(\
    \x02(\x01\x12\x04\xb9\x04\x08&\n\r\n\x05\x05(\x02(\x02\x12\x04\xb9\x04)+\
    \n\x0c\n\x04\x05(\x02)\x12\x04\xba\x04\x08)\n\r\n\x05\x05(\x02)\x01\x12\
    \x04\xba\x04\x08#\n\r\n\x05\x05(\x02)\x02\x12\x04\xba\x04&(\n\x0c\n\x04\
    \x05(\x02*\x12\x04\xbb\x04\x08,\n\r\n\x05\x05(\x02*\x01\x12\x04\xbb\x04\
    \x08&\n\r\n\x05\x05(\x02*\x02\x12\x04\xbb\x04)+\n\x0c\n\x04\x05(\x02+\
    \x12\x04\xbc\x04\x08-\n\r\n\x05\x05(\x02+\x01\x12\x04\xbc\x04\x08'\n\r\n\
    \x05\x05(\x02+\x02\x12\x04\xbc\x04*,\n\x0c\n\x04\x05(\x02,\x12\x04\xbd\
    \x04\x080\n\r\n\x05\x05(\x02,\x01\x12\x04\xbd\x04\x08*\n\r\n\x05\x05(\
    \x02,\x02\x12\x04\xbd\x04-/\n\x0c\n\x02\x05)\x12\x06\xc0\x04\0\xc5\x04\
    \x01\n\x0b\n\x03\x05)\x01\x12\x04\xc0\x04\x05\x15\n\x0c\n\x04\x05)\x02\0\
    \x12\x04\xc1\x04\x08\x1e\n\r\n\x05\x05)\x02\0\x01\x12\x04\xc1\x04\x08\
    \x19\n\r\n\x05\x05)\x02\0\x02\x12\x04\xc1\x04\x1c\x1d\n\x0c\n\x04\x05)\
    \x02\x01\x12\x04\xc2\x04\x08!\n\r\n\x05\x05)\x02\x01\x01\x12\x04\xc2\x04\
    \x08\x1c\n\r\n\x05\x05)\x02\x01\x02\x12\x04\xc2\x04\x1f\x20\n\x0c\n\x04\
    \x05)\x02\x02\x12\x04\xc3\x04\x08\x1f\n\r\n\x05\x05)\x02\x02\x01\x12\x04\
    \xc3\x04\x08\x1a\n\r\n\x05\x05)\x02\x02\x02\x12\x04\xc3\x04\x1d\x1e\n\
    \x0c\n\x04\x05)\x02\x03\x12\x04\xc4\x04\x08!\n\r\n\x05\x05)\x02\x03\x01\
    \x12\x04\xc4\x04\x08\x1c\n\r\n\x05\x05)\x02\x03\x02\x12\x04\xc4\x04\x1f\
    \x20\n\x0c\n\x02\x05*\x12\x06\xc7\x04\0\xd3\x04\x01\n\x0b\n\x03\x05*\x01\
    \x12\x04\xc7\x04\x05\x19\n\x0c\n\x04\x05*\x02\0\x12\x04\xc8\x04\x081\n\r\
    \n\x05\x05*\x02\0\x01\x12\x04\xc8\x04\x08,\n\r\n\x05\x05*\x02\0\x02\x12\
    \x04\xc8\x04/0\n\x0c\n\x04\x05*\x02\x01\x12\x04\xc9\x04\x084\n\r\n\x05\
    \x05*\x02\x01\x01\x12\x04\xc9\x04\x08.\n\r\n\x05\x05*\x02\x01\x02\x12\
    \x04\xc9\x0413\n\x0c\n\x04\x05*\x02\x02\x12\x04\xca\x04\x086\n\r\n\x05\
    \x05*\x02\x02\x01\x12\x04\xca\x04\x080\n\r\n\x05\x05*\x02\x02\x02\x12\
    \x04\xca\x0435\n\x0c\n\x04\x05*\x02\x03\x12\x04\xcb\x04\x08?\n\r\n\x05\
    \x05*\x02\x03\x01\x12\x04\xcb\x04\x089\n\r\n\x05\x05*\x02\x03\x02\x12\
    \x04\xcb\x04<>\n\x0c\n\x04\x05*\x02\x04\x12\x04\xcc\x04\x08=\n\r\n\x05\
    \x05*\x02\x04\x01\x12\x04\xcc\x04\x087\n\r\n\x05\x05*\x02\x04\x02\x12\
    \x04\xcc\x04:<\n\x0c\n\x04\x05*\x02\x05\x12\x04\xcd\x04\x081\n\r\n\x05\
    \x05*\x02\x05\x01\x12\x04\xcd\x04\x08+\n\r\n\x05\x05*\x02\x05\x02\x12\
    \x04\xcd\x04.0\n\x0c\n\x04\x05*\x02\x06\x12\x04\xce\x04\x08@\n\r\n\x05\
    \x05*\x02\x06\x01\x12\x04\xce\x04\x08:\n\r\n\x05\x05*\x02\x06\x02\x12\
    \x04\xce\x04=?\n\x0c\n\x04\x05*\x02\x07\x12\x04\xcf\x04\x085\n\r\n\x05\
    \x05*\x02\x07\x01\x12\x04\xcf\x04\x08/\n\r\n\x05\x05*\x02\x07\x02\x12\
    \x04\xcf\x0424\n\x0c\n\x04\x05*\x02\x08\x12\x04\xd0\x04\x08:\n\r\n\x05\
    \x05*\x02\x08\x01\x12\x04\xd0\x04\x084\n\r\n\x05\x05*\x02\x08\x02\x12\
    \x04\xd0\x0479\n\x0c\n\x04\x05*\x02\t\x12\x04\xd1\x04\x089\n\r\n\x05\x05\
    *\x02\t\x01\x12\x04\xd1\x04\x083\n\r\n\x05\x05*\x02\t\x02\x12\x04\xd1\
    \x0468\n\x0c\n\x04\x05*\x02\n\x12\x04\xd2\x04\x089\n\r\n\x05\x05*\x02\n\
    \x01\x12\x04\xd2\x04\x083\n\r\n\x05\x05*\x02\n\x02\x12\x04\xd2\x0468\n\
    \x0c\n\x02\x05+\x12\x06\xd5\x04\0\xd8\x04\x01\n\x0b\n\x03\x05+\x01\x12\
    \x04\xd5\x04\x05\x1a\n\x0c\n\x04\x05+\x02\0\x12\x04\xd6\x04\x08(\n\r\n\
    \x05\x05+\x02\0\x01\x12\x04\xd6\x04\x08#\n\r\n\x05\x05+\x02\0\x02\x12\
    \x04\xd6\x04&'\n\x0c\n\x04\x05+\x02\x01\x12\x04\xd7\x04\x08(\n\r\n\x05\
    \x05+\x02\x01\x01\x12\x04\xd7\x04\x08#\n\r\n\x05\x05+\x02\x01\x02\x12\
    \x04\xd7\x04&'\n\x0c\n\x02\x05,\x12\x06\xda\x04\0\xe1\x04\x01\n\x0b\n\
    \x03\x05,\x01\x12\x04\xda\x04\x05\x20\n\x0c\n\x04\x05,\x02\0\x12\x04\xdb\
    \x04\x082\n\r\n\x05\x05,\x02\0\x01\x12\x04\xdb\x04\x08-\n\r\n\x05\x05,\
    \x02\0\x02\x12\x04\xdb\x0401\n\x0c\n\x04\x05,\x02\x01\x12\x04\xdc\x04\
    \x084\n\r\n\x05\x05,\x02\x01\x01\x12\x04\xdc\x04\x08/\n\r\n\x05\x05,\x02\
    \x01\x02\x12\x04\xdc\x0423\n\x0c\n\x04\x05,\x02\x02\x12\x04\xdd\x04\x088\
    \n\r\n\x05\x05,\x02\x02\x01\x12\x04\xdd\x04\x083\n\r\n\x05\x05,\x02\x02\
    \x02\x12\x04\xdd\x0467\n\x0c\n\x04\x05,\x02\x03\x12\x04\xde\x04\x08F\n\r\
    \n\x05\x05,\x02\x03\x01\x12\x04\xde\x04\x08A\n\r\n\x05\x05,\x02\x03\x02\
    \x12\x04\xde\x04DE\n\x0c\n\x04\x05,\x02\x04\x12\x04\xdf\x04\x08?\n\r\n\
    \x05\x05,\x02\x04\x01\x12\x04\xdf\x04\x08:\n\r\n\x05\x05,\x02\x04\x02\
    \x12\x04\xdf\x04=>\n\x0c\n\x04\x05,\x02\x05\x12\x04\xe0\x04\x088\n\r\n\
    \x05\x05,\x02\x05\x01\x12\x04\xe0\x04\x083\n\r\n\x05\x05,\x02\x05\x02\
    \x12\x04\xe0\x0467\n\x0c\n\x02\x05-\x12\x06\xe3\x04\0\xea\x04\x01\n\x0b\
    \n\x03\x05-\x01\x12\x04\xe3\x04\x05\x1b\n\x0c\n\x04\x05-\x02\0\x12\x04\
    \xe4\x04\x08-\n\r\n\x05\x05-\x02\0\x01\x12\x04\xe4\x04\x08(\n\r\n\x05\
    \x05-\x02\0\x02\x12\x04\xe4\x04+,\n\x0c\n\x04\x05-\x02\x01\x12\x04\xe5\
    \x04\x08.\n\r\n\x05\x05-\x02\x01\x01\x12\x04\xe5\x04\x08)\n\r\n\x05\x05-\
    \x02\x01\x02\x12\x04\xe5\x04,-\n\x0c\n\x04\x05-\x02\x02\x12\x04\xe6\x04\
    \x08-\n\r\n\x05\x05-\x02\x02\x01\x12\x04\xe6\x04\x08(\n\r\n\x05\x05-\x02\
    \x02\x02\x12\x04\xe6\x04+,\n\x0c\n\x04\x05-\x02\x03\x12\x04\xe7\x04\x08.\
    \n\r\n\x05\x05-\x02\x03\x01\x12\x04\xe7\x04\x08)\n\r\n\x05\x05-\x02\x03\
    \x02\x12\x04\xe7\x04,-\n\x0c\n\x04\x05-\x02\x04\x12\x04\xe8\x04\x080\n\r\
    \n\x05\x05-\x02\x04\x01\x12\x04\xe8\x04\x08+\n\r\n\x05\x05-\x02\x04\x02\
    \x12\x04\xe8\x04./\n\x0c\n\x04\x05-\x02\x05\x12\x04\xe9\x04\x082\n\r\n\
    \x05\x05-\x02\x05\x01\x12\x04\xe9\x04\x08-\n\r\n\x05\x05-\x02\x05\x02\
    \x12\x04\xe9\x0401\n\x0c\n\x02\x04\0\x12\x06\xec\x04\0\xf3\x04\x01\n\x0b\
    \n\x03\x04\0\x01\x12\x04\xec\x04\x08\x20\n\x0c\n\x04\x04\0\x02\0\x12\x04\
    \xed\x04\x08/\n\r\n\x05\x04\0\x02\0\x04\x12\x04\xed\x04\x08\x10\n\r\n\
    \x05\x04\0\x02\0\x05\x12\x04\xed\x04\x11\x17\n\r\n\x05\x04\0\x02\0\x01\
    \x12\x04\xed\x04\x18*\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xed\x04-.\n\x0c\
    \n\x04\x04\0\x02\x01\x12\x04\xee\x04\x083\n\r\n\x05\x04\0\x02\x01\x04\
    \x12\x04\xee\x04\x08\x10\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\xee\x04\x11\
    \x18\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xee\x04\x19.\n\r\n\x05\x04\0\
    \x02\x01\x03\x12\x04\xee\x0412\n\x0c\n\x04\x04\0\x02\x02\x12\x04\xef\x04\
    \x083\n\r\n\x05\x04\0\x02\x02\x04\x12\x04\xef\x04\x08\x10\n\r\n\x05\x04\
    \0\x02\x02\x05\x12\x04\xef\x04\x11\x18\n\r\n\x05\x04\0\x02\x02\x01\x12\
    \x04\xef\x04\x19.\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xef\x0412\n\x0c\n\
    \x04\x04\0\x02\x03\x12\x04\xf0\x04\x08'\n\r\n\x05\x04\0\x02\x03\x04\x12\
    \x04\xf0\x04\x08\x10\n\r\n\x05\x04\0\x02\x03\x05\x12\x04\xf0\x04\x11\x15\
    \n\r\n\x05\x04\0\x02\x03\x01\x12\x04\xf0\x04\x16\"\n\r\n\x05\x04\0\x02\
    \x03\x03\x12\x04\xf0\x04%&\n\x0c\n\x04\x04\0\x02\x04\x12\x04\xf1\x04\x08\
    /\n\r\n\x05\x04\0\x02\x04\x04\x12\x04\xf1\x04\x08\x10\n\r\n\x05\x04\0\
    \x02\x04\x05\x12\x04\xf1\x04\x11\x17\n\r\n\x05\x04\0\x02\x04\x01\x12\x04\
    \xf1\x04\x18*\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\xf1\x04-.\n\x0c\n\x04\
    \x04\0\x02\x05\x12\x04\xf2\x04\x08*\n\r\n\x05\x04\0\x02\x05\x04\x12\x04\
    \xf2\x04\x08\x10\n\r\n\x05\x04\0\x02\x05\x05\x12\x04\xf2\x04\x11\x15\n\r\
    \n\x05\x04\0\x02\x05\x01\x12\x04\xf2\x04\x16%\n\r\n\x05\x04\0\x02\x05\
    \x03\x12\x04\xf2\x04()\n\x0c\n\x02\x04\x01\x12\x06\xf5\x04\0\x8e\x05\x01\
    \n\x0b\n\x03\x04\x01\x01\x12\x04\xf5\x04\x08\x15\n\x0e\n\x04\x04\x01\x03\
    \0\x12\x06\xf6\x04\x08\xfa\x04\t\n\r\n\x05\x04\x01\x03\0\x01\x12\x04\xf6\
    \x04\x10\x16\n\x0e\n\x06\x04\x01\x03\0\x02\0\x12\x04\xf7\x04\x10/\n\x0f\
    \n\x07\x04\x01\x03\0\x02\0\x04\x12\x04\xf7\x04\x10\x18\n\x0f\n\x07\x04\
    \x01\x03\0\x02\0\x06\x12\x04\xf7\x04\x19%\n\x0f\n\x07\x04\x01\x03\0\x02\
    \0\x01\x12\x04\xf7\x04&*\n\x0f\n\x07\x04\x01\x03\0\x02\0\x03\x12\x04\xf7\
    \x04-.\n\x0e\n\x06\x04\x01\x03\0\x02\x01\x12\x04\xf8\x04\x10)\n\x0f\n\
    \x07\x04\x01\x03\0\x02\x01\x04\x12\x04\xf8\x04\x10\x18\n\x0f\n\x07\x04\
    \x01\x03\0\x02\x01\x05\x12\x04\xf8\x04\x19\x1f\n\x0f\n\x07\x04\x01\x03\0\
    \x02\x01\x01\x12\x04\xf8\x04\x20$\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x03\
    \x12\x04\xf8\x04'(\n\x0e\n\x06\x04\x01\x03\0\x02\x02\x12\x04\xf9\x04\x10\
    )\n\x0f\n\x07\x04\x01\x03\0\x02\x02\x04\x12\x04\xf9\x04\x10\x18\n\x0f\n\
    \x07\x04\x01\x03\0\x02\x02\x05\x12\x04\xf9\x04\x19\x1f\n\x0f\n\x07\x04\
    \x01\x03\0\x02\x02\x01\x12\x04\xf9\x04\x20$\n\x0f\n\x07\x04\x01\x03\0\
    \x02\x02\x03\x12\x04\xf9\x04'(\n\x0e\n\x04\x04\x01\x03\x01\x12\x06\xfc\
    \x04\x08\x88\x05\t\n\r\n\x05\x04\x01\x03\x01\x01\x12\x04\xfc\x04\x10\x1c\
    \n\x10\n\x06\x04\x01\x03\x01\x03\0\x12\x06\xfd\x04\x10\x80\x05\x11\n\x0f\
    \n\x07\x04\x01\x03\x01\x03\0\x01\x12\x04\xfd\x04\x18'\n\x10\n\x08\x04\
    \x01\x03\x01\x03\0\x02\0\x12\x04\xfe\x04\x18-\n\x11\n\t\x04\x01\x03\x01\
    \x03\0\x02\0\x04\x12\x04\xfe\x04\x18\x20\n\x11\n\t\x04\x01\x03\x01\x03\0\
    \x02\0\x05\x12\x04\xfe\x04!&\n\x11\n\t\x04\x01\x03\x01\x03\0\x02\0\x01\
    \x12\x04\xfe\x04'(\n\x11\n\t\x04\x01\x03\x01\x03\0\x02\0\x03\x12\x04\xfe\
    \x04+,\n\x10\n\x08\x04\x01\x03\x01\x03\0\x02\x01\x12\x04\xff\x04\x18-\n\
    \x11\n\t\x04\x01\x03\x01\x03\0\x02\x01\x04\x12\x04\xff\x04\x18\x20\n\x11\
    \n\t\x04\x01\x03\x01\x03\0\x02\x01\x05\x12\x04\xff\x04!&\n\x11\n\t\x04\
    \x01\x03\x01\x03\0\x02\x01\x01\x12\x04\xff\x04'(\n\x11\n\t\x04\x01\x03\
    \x01\x03\0\x02\x01\x03\x12\x04\xff\x04+,\n\x0e\n\x06\x04\x01\x03\x01\x02\
    \0\x12\x04\x82\x05\x10.\n\x0f\n\x07\x04\x01\x03\x01\x02\0\x04\x12\x04\
    \x82\x05\x10\x18\n\x0f\n\x07\x04\x01\x03\x01\x02\0\x05\x12\x04\x82\x05\
    \x19\x1f\n\x0f\n\x07\x04\x01\x03\x01\x02\0\x01\x12\x04\x82\x05\x20)\n\
    \x0f\n\x07\x04\x01\x03\x01\x02\0\x03\x12\x04\x82\x05,-\n\x0e\n\x06\x04\
    \x01\x03\x01\x02\x01\x12\x04\x83\x05\x100\n\x0f\n\x07\x04\x01\x03\x01\
    \x02\x01\x04\x12\x04\x83\x05\x10\x18\n\x0f\n\x07\x04\x01\x03\x01\x02\x01\
    \x05\x12\x04\x83\x05\x19\x1f\n\x0f\n\x07\x04\x01\x03\x01\x02\x01\x01\x12\
    \x04\x83\x05\x20+\n\x0f\n\x07\x04\x01\x03\x01\x02\x01\x03\x12\x04\x83\
    \x05./\n\x0e\n\x06\x04\x01\x03\x01\x02\x02\x12\x04\x84\x05\x100\n\x0f\n\
    \x07\x04\x01\x03\x01\x02\x02\x04\x12\x04\x84\x05\x10\x18\n\x0f\n\x07\x04\
    \x01\x03\x01\x02\x02\x05\x12\x04\x84\x05\x19\x1f\n\x0f\n\x07\x04\x01\x03\
    \x01\x02\x02\x01\x12\x04\x84\x05\x20+\n\x0f\n\x07\x04\x01\x03\x01\x02\
    \x02\x03\x12\x04\x84\x05./\n\x0e\n\x06\x04\x01\x03\x01\x02\x03\x12\x04\
    \x85\x05\x10Y\n\x0f\n\x07\x04\x01\x03\x01\x02\x03\x04\x12\x04\x85\x05\
    \x10\x18\n\x0f\n\x07\x04\x01\x03\x01\x02\x03\x06\x12\x04\x85\x05\x19C\n\
    \x0f\n\x07\x04\x01\x03\x01\x02\x03\x01\x12\x04\x85\x05DT\n\x0f\n\x07\x04\
    \x01\x03\x01\x02\x03\x03\x12\x04\x85\x05WX\n\x0e\n\x06\x04\x01\x03\x01\
    \x02\x04\x12\x04\x86\x05\x10,\n\x0f\n\x07\x04\x01\x03\x01\x02\x04\x04\
    \x12\x04\x86\x05\x10\x18\n\x0f\n\x07\x04\x01\x03\x01\x02\x04\x05\x12\x04\
    \x86\x05\x19\x1f\n\x0f\n\x07\x04\x01\x03\x01\x02\x04\x01\x12\x04\x86\x05\
    \x20'\n\x0f\n\x07\x04\x01\x03\x01\x02\x04\x03\x12\x04\x86\x05*+\n\x0e\n\
    \x06\x04\x01\x03\x01\x02\x05\x12\x04\x87\x05\x10.\n\x0f\n\x07\x04\x01\
    \x03\x01\x02\x05\x04\x12\x04\x87\x05\x10\x18\n\x0f\n\x07\x04\x01\x03\x01\
    \x02\x05\x05\x12\x04\x87\x05\x19\x1f\n\x0f\n\x07\x04\x01\x03\x01\x02\x05\
    \x01\x12\x04\x87\x05\x20)\n\x0f\n\x07\x04\x01\x03\x01\x02\x05\x03\x12\
    \x04\x87\x05,-\n\x0c\n\x04\x04\x01\x02\0\x12\x04\x8a\x05\x08%\n\r\n\x05\
    \x04\x01\x02\0\x04\x12\x04\x8a\x05\x08\x10\n\r\n\x05\x04\x01\x02\0\x05\
    \x12\x04\x8a\x05\x11\x17\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x8a\x05\x18\
    \x20\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x8a\x05#$\n\x0c\n\x04\x04\x01\
    \x02\x01\x12\x04\x8b\x05\x08&\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\x8b\
    \x05\x08\x10\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\x8b\x05\x11\x17\n\r\n\
    \x05\x04\x01\x02\x01\x01\x12\x04\x8b\x05\x18!\n\r\n\x05\x04\x01\x02\x01\
    \x03\x12\x04\x8b\x05$%\n\x0c\n\x04\x04\x01\x02\x02\x12\x04\x8c\x05\x082\
    \n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\x8c\x05\x08\x10\n\r\n\x05\x04\x01\
    \x02\x02\x06\x12\x04\x8c\x05\x11%\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\
    \x8c\x05&-\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\x8c\x0501\n\x0c\n\x04\
    \x04\x01\x02\x03\x12\x04\x8d\x05\x08?\n\r\n\x05\x04\x01\x02\x03\x04\x12\
    \x04\x8d\x05\x08\x10\n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\x8d\x05\x11+\
    \n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\x8d\x05,:\n\r\n\x05\x04\x01\x02\
    \x03\x03\x12\x04\x8d\x05=>\n\x0c\n\x02\x04\x02\x12\x06\x90\x05\0\xe0\x05\
    \x01\n\x0b\n\x03\x04\x02\x01\x12\x04\x90\x05\x08\x1e\n\x0c\n\x04\x04\x02\
    \x02\0\x12\x04\x91\x05\x08/\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\x91\x05\
    \x08\x10\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\x91\x05\x11%\n\r\n\x05\x04\
    \x02\x02\0\x01\x12\x04\x91\x05&*\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x91\
    \x05-.\n\x0c\n\x04\x04\x02\x02\x01\x12\x04\x92\x05\x08(\n\r\n\x05\x04\
    \x02\x02\x01\x04\x12\x04\x92\x05\x08\x10\n\r\n\x05\x04\x02\x02\x01\x05\
    \x12\x04\x92\x05\x11\x17\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x92\x05\
    \x18#\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\x92\x05&'\n\x0c\n\x04\x04\
    \x02\x02\x02\x12\x04\x93\x05\x08/\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\
    \x93\x05\x08\x10\n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\x93\x05\x11\x17\n\
    \r\n\x05\x04\x02\x02\x02\x01\x12\x04\x93\x05\x18*\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\x93\x05-.\n\x0c\n\x04\x04\x02\x02\x03\x12\x04\x94\x05\
    \x08*\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04\x94\x05\x08\x10\n\r\n\x05\
    \x04\x02\x02\x03\x05\x12\x04\x94\x05\x11\x17\n\r\n\x05\x04\x02\x02\x03\
    \x01\x12\x04\x94\x05\x18%\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\x94\x05(\
    )\n\x0c\n\x04\x04\x02\x02\x04\x12\x04\x95\x05\x08/\n\r\n\x05\x04\x02\x02\
    \x04\x04\x12\x04\x95\x05\x08\x10\n\r\n\x05\x04\x02\x02\x04\x05\x12\x04\
    \x95\x05\x11\x17\n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\x95\x05\x18*\n\r\
    \n\x05\x04\x02\x02\x04\x03\x12\x04\x95\x05-.\n\x0c\n\x04\x04\x02\x02\x05\
    \x12\x04\x96\x05\x08+\n\r\n\x05\x04\x02\x02\x05\x04\x12\x04\x96\x05\x08\
    \x10\n\r\n\x05\x04\x02\x02\x05\x05\x12\x04\x96\x05\x11\x17\n\r\n\x05\x04\
    \x02\x02\x05\x01\x12\x04\x96\x05\x18&\n\r\n\x05\x04\x02\x02\x05\x03\x12\
    \x04\x96\x05)*\n\x0c\n\x04\x04\x02\x02\x06\x12\x04\x97\x05\x08/\n\r\n\
    \x05\x04\x02\x02\x06\x04\x12\x04\x97\x05\x08\x10\n\r\n\x05\x04\x02\x02\
    \x06\x05\x12\x04\x97\x05\x11\x15\n\r\n\x05\x04\x02\x02\x06\x01\x12\x04\
    \x97\x05\x16*\n\r\n\x05\x04\x02\x02\x06\x03\x12\x04\x97\x05-.\n\x0c\n\
    \x04\x04\x02\x02\x07\x12\x04\x98\x05\x08+\n\r\n\x05\x04\x02\x02\x07\x04\
    \x12\x04\x98\x05\x08\x10\n\r\n\x05\x04\x02\x02\x07\x05\x12\x04\x98\x05\
    \x11\x15\n\r\n\x05\x04\x02\x02\x07\x01\x12\x04\x98\x05\x16&\n\r\n\x05\
    \x04\x02\x02\x07\x03\x12\x04\x98\x05)*\n\x0c\n\x04\x04\x02\x02\x08\x12\
    \x04\x99\x05\x08-\n\r\n\x05\x04\x02\x02\x08\x04\x12\x04\x99\x05\x08\x10\
    \n\r\n\x05\x04\x02\x02\x08\x05\x12\x04\x99\x05\x11\x15\n\r\n\x05\x04\x02\
    \x02\x08\x01\x12\x04\x99\x05\x16(\n\r\n\x05\x04\x02\x02\x08\x03\x12\x04\
    \x99\x05+,\n\x0c\n\x04\x04\x02\x02\t\x12\x04\x9a\x05\x08*\n\r\n\x05\x04\
    \x02\x02\t\x04\x12\x04\x9a\x05\x08\x10\n\r\n\x05\x04\x02\x02\t\x05\x12\
    \x04\x9a\x05\x11\x15\n\r\n\x05\x04\x02\x02\t\x01\x12\x04\x9a\x05\x16$\n\
    \r\n\x05\x04\x02\x02\t\x03\x12\x04\x9a\x05')\n\x0c\n\x04\x04\x02\x02\n\
    \x12\x04\x9b\x05\x08.\n\r\n\x05\x04\x02\x02\n\x04\x12\x04\x9b\x05\x08\
    \x10\n\r\n\x05\x04\x02\x02\n\x05\x12\x04\x9b\x05\x11\x15\n\r\n\x05\x04\
    \x02\x02\n\x01\x12\x04\x9b\x05\x16(\n\r\n\x05\x04\x02\x02\n\x03\x12\x04\
    \x9b\x05+-\n\x0c\n\x04\x04\x02\x02\x0b\x12\x04\x9c\x05\x08+\n\r\n\x05\
    \x04\x02\x02\x0b\x04\x12\x04\x9c\x05\x08\x10\n\r\n\x05\x04\x02\x02\x0b\
    \x05\x12\x04\x9c\x05\x11\x15\n\r\n\x05\x04\x02\x02\x0b\x01\x12\x04\x9c\
    \x05\x16%\n\r\n\x05\x04\x02\x02\x0b\x03\x12\x04\x9c\x05(*\n\x0c\n\x04\
    \x04\x02\x02\x0c\x12\x04\x9d\x05\x08#\n\r\n\x05\x04\x02\x02\x0c\x04\x12\
    \x04\x9d\x05\x08\x10\n\r\n\x05\x04\x02\x02\x0c\x05\x12\x04\x9d\x05\x11\
    \x17\n\r\n\x05\x04\x02\x02\x0c\x01\x12\x04\x9d\x05\x18\x1d\n\r\n\x05\x04\
    \x02\x02\x0c\x03\x12\x04\x9d\x05\x20\"\n\x0c\n\x04\x04\x02\x02\r\x12\x04\
    \x9e\x05\x08#\n\r\n\x05\x04\x02\x02\r\x04\x12\x04\x9e\x05\x08\x10\n\r\n\
    \x05\x04\x02\x02\r\x05\x12\x04\x9e\x05\x11\x16\n\r\n\x05\x04\x02\x02\r\
    \x01\x12\x04\x9e\x05\x17\x1d\n\r\n\x05\x04\x02\x02\r\x03\x12\x04\x9e\x05\
    \x20\"\n\x0c\n\x04\x04\x02\x02\x0e\x12\x04\x9f\x05\x08&\n\r\n\x05\x04\
    \x02\x02\x0e\x04\x12\x04\x9f\x05\x08\x10\n\r\n\x05\x04\x02\x02\x0e\x05\
    \x12\x04\x9f\x05\x11\x16\n\r\n\x05\x04\x02\x02\x0e\x01\x12\x04\x9f\x05\
    \x17\x20\n\r\n\x05\x04\x02\x02\x0e\x03\x12\x04\x9f\x05#%\n\x0c\n\x04\x04\
    \x02\x02\x0f\x12\x04\xa0\x05\x08*\n\r\n\x05\x04\x02\x02\x0f\x04\x12\x04\
    \xa0\x05\x08\x10\n\r\n\x05\x04\x02\x02\x0f\x05\x12\x04\xa0\x05\x11\x16\n\
    \r\n\x05\x04\x02\x02\x0f\x01\x12\x04\xa0\x05\x17$\n\r\n\x05\x04\x02\x02\
    \x0f\x03\x12\x04\xa0\x05')\n\x0c\n\x04\x04\x02\x02\x10\x12\x04\xa1\x05\
    \x08*\n\r\n\x05\x04\x02\x02\x10\x04\x12\x04\xa1\x05\x08\x10\n\r\n\x05\
    \x04\x02\x02\x10\x05\x12\x04\xa1\x05\x11\x16\n\r\n\x05\x04\x02\x02\x10\
    \x01\x12\x04\xa1\x05\x17$\n\r\n\x05\x04\x02\x02\x10\x03\x12\x04\xa1\x05'\
    )\n\x0c\n\x04\x04\x02\x02\x11\x12\x04\xa2\x05\x080\n\r\n\x05\x04\x02\x02\
    \x11\x04\x12\x04\xa2\x05\x08\x10\n\r\n\x05\x04\x02\x02\x11\x05\x12\x04\
    \xa2\x05\x11\x15\n\r\n\x05\x04\x02\x02\x11\x01\x12\x04\xa2\x05\x16*\n\r\
    \n\x05\x04\x02\x02\x11\x03\x12\x04\xa2\x05-/\n\x0c\n\x04\x04\x02\x02\x12\
    \x12\x04\xa3\x05\x081\n\r\n\x05\x04\x02\x02\x12\x04\x12\x04\xa3\x05\x08\
    \x10\n\r\n\x05\x04\x02\x02\x12\x05\x12\x04\xa3\x05\x11\x15\n\r\n\x05\x04\
    \x02\x02\x12\x01\x12\x04\xa3\x05\x16+\n\r\n\x05\x04\x02\x02\x12\x03\x12\
    \x04\xa3\x05.0\n\x0c\n\x04\x04\x02\x02\x13\x12\x04\xa4\x05\x08+\n\r\n\
    \x05\x04\x02\x02\x13\x04\x12\x04\xa4\x05\x08\x10\n\r\n\x05\x04\x02\x02\
    \x13\x05\x12\x04\xa4\x05\x11\x17\n\r\n\x05\x04\x02\x02\x13\x01\x12\x04\
    \xa4\x05\x18%\n\r\n\x05\x04\x02\x02\x13\x03\x12\x04\xa4\x05(*\n\x0c\n\
    \x04\x04\x02\x02\x14\x12\x04\xa5\x05\x08'\n\r\n\x05\x04\x02\x02\x14\x04\
    \x12\x04\xa5\x05\x08\x10\n\r\n\x05\x04\x02\x02\x14\x05\x12\x04\xa5\x05\
    \x11\x16\n\r\n\x05\x04\x02\x02\x14\x01\x12\x04\xa5\x05\x17!\n\r\n\x05\
    \x04\x02\x02\x14\x03\x12\x04\xa5\x05$&\n\x0c\n\x04\x04\x02\x02\x15\x12\
    \x04\xa6\x05\x08'\n\r\n\x05\x04\x02\x02\x15\x04\x12\x04\xa6\x05\x08\x10\
    \n\r\n\x05\x04\x02\x02\x15\x05\x12\x04\xa6\x05\x11\x16\n\r\n\x05\x04\x02\
    \x02\x15\x01\x12\x04\xa6\x05\x17!\n\r\n\x05\x04\x02\x02\x15\x03\x12\x04\
    \xa6\x05$&\n\x0c\n\x04\x04\x02\x02\x16\x12\x04\xa7\x05\x08)\n\r\n\x05\
    \x04\x02\x02\x16\x04\x12\x04\xa7\x05\x08\x10\n\r\n\x05\x04\x02\x02\x16\
    \x05\x12\x04\xa7\x05\x11\x17\n\r\n\x05\x04\x02\x02\x16\x01\x12\x04\xa7\
    \x05\x18#\n\r\n\x05\x04\x02\x02\x16\x03\x12\x04\xa7\x05&(\n\x0c\n\x04\
    \x04\x02\x02\x17\x12\x04\xa8\x05\x08*\n\r\n\x05\x04\x02\x02\x17\x04\x12\
    \x04\xa8\x05\x08\x10\n\r\n\x05\x04\x02\x02\x17\x05\x12\x04\xa8\x05\x11\
    \x16\n\r\n\x05\x04\x02\x02\x17\x01\x12\x04\xa8\x05\x17$\n\r\n\x05\x04\
    \x02\x02\x17\x03\x12\x04\xa8\x05')\n\x0c\n\x04\x04\x02\x02\x18\x12\x04\
    \xa9\x05\x08.\n\r\n\x05\x04\x02\x02\x18\x04\x12\x04\xa9\x05\x08\x10\n\r\
    \n\x05\x04\x02\x02\x18\x05\x12\x04\xa9\x05\x11\x16\n\r\n\x05\x04\x02\x02\
    \x18\x01\x12\x04\xa9\x05\x17(\n\r\n\x05\x04\x02\x02\x18\x03\x12\x04\xa9\
    \x05+-\n\x0c\n\x04\x04\x02\x02\x19\x12\x04\xaa\x05\x08'\n\r\n\x05\x04\
    \x02\x02\x19\x04\x12\x04\xaa\x05\x08\x10\n\r\n\x05\x04\x02\x02\x19\x05\
    \x12\x04\xaa\x05\x11\x17\n\r\n\x05\x04\x02\x02\x19\x01\x12\x04\xaa\x05\
    \x18!\n\r\n\x05\x04\x02\x02\x19\x03\x12\x04\xaa\x05$&\n\x0c\n\x04\x04\
    \x02\x02\x1a\x12\x04\xab\x05\x08'\n\r\n\x05\x04\x02\x02\x1a\x04\x12\x04\
    \xab\x05\x08\x10\n\r\n\x05\x04\x02\x02\x1a\x05\x12\x04\xab\x05\x11\x17\n\
    \r\n\x05\x04\x02\x02\x1a\x01\x12\x04\xab\x05\x18!\n\r\n\x05\x04\x02\x02\
    \x1a\x03\x12\x04\xab\x05$&\n\x0c\n\x04\x04\x02\x02\x1b\x12\x04\xac\x05\
    \x08+\n\r\n\x05\x04\x02\x02\x1b\x04\x12\x04\xac\x05\x08\x10\n\r\n\x05\
    \x04\x02\x02\x1b\x05\x12\x04\xac\x05\x11\x17\n\r\n\x05\x04\x02\x02\x1b\
    \x01\x12\x04\xac\x05\x18%\n\r\n\x05\x04\x02\x02\x1b\x03\x12\x04\xac\x05(\
    *\n\x0c\n\x04\x04\x02\x02\x1c\x12\x04\xad\x05\x08)\n\r\n\x05\x04\x02\x02\
    \x1c\x04\x12\x04\xad\x05\x08\x10\n\r\n\x05\x04\x02\x02\x1c\x05\x12\x04\
    \xad\x05\x11\x17\n\r\n\x05\x04\x02\x02\x1c\x01\x12\x04\xad\x05\x18#\n\r\
    \n\x05\x04\x02\x02\x1c\x03\x12\x04\xad\x05&(\n\x0c\n\x04\x04\x02\x02\x1d\
    \x12\x04\xae\x05\x08.\n\r\n\x05\x04\x02\x02\x1d\x04\x12\x04\xae\x05\x08\
    \x10\n\r\n\x05\x04\x02\x02\x1d\x05\x12\x04\xae\x05\x11\x17\n\r\n\x05\x04\
    \x02\x02\x1d\x01\x12\x04\xae\x05\x18(\n\r\n\x05\x04\x02\x02\x1d\x03\x12\
    \x04\xae\x05+-\n\x0c\n\x04\x04\x02\x02\x1e\x12\x04\xaf\x05\x08,\n\r\n\
    \x05\x04\x02\x02\x1e\x04\x12\x04\xaf\x05\x08\x10\n\r\n\x05\x04\x02\x02\
    \x1e\x05\x12\x04\xaf\x05\x11\x17\n\r\n\x05\x04\x02\x02\x1e\x01\x12\x04\
    \xaf\x05\x18&\n\r\n\x05\x04\x02\x02\x1e\x03\x12\x04\xaf\x05)+\n\x0c\n\
    \x04\x04\x02\x02\x1f\x12\x04\xb0\x05\x08,\n\r\n\x05\x04\x02\x02\x1f\x04\
    \x12\x04\xb0\x05\x08\x10\n\r\n\x05\x04\x02\x02\x1f\x05\x12\x04\xb0\x05\
    \x11\x17\n\r\n\x05\x04\x02\x02\x1f\x01\x12\x04\xb0\x05\x18&\n\r\n\x05\
    \x04\x02\x02\x1f\x03\x12\x04\xb0\x05)+\n\x0c\n\x04\x04\x02\x02\x20\x12\
    \x04\xb1\x05\x08,\n\r\n\x05\x04\x02\x02\x20\x04\x12\x04\xb1\x05\x08\x10\
    \n\r\n\x05\x04\x02\x02\x20\x05\x12\x04\xb1\x05\x11\x17\n\r\n\x05\x04\x02\
    \x02\x20\x01\x12\x04\xb1\x05\x18&\n\r\n\x05\x04\x02\x02\x20\x03\x12\x04\
    \xb1\x05)+\n\x0c\n\x04\x04\x02\x02!\x12\x04\xb2\x05\x08,\n\r\n\x05\x04\
    \x02\x02!\x04\x12\x04\xb2\x05\x08\x10\n\r\n\x05\x04\x02\x02!\x05\x12\x04\
    \xb2\x05\x11\x17\n\r\n\x05\x04\x02\x02!\x01\x12\x04\xb2\x05\x18&\n\r\n\
    \x05\x04\x02\x02!\x03\x12\x04\xb2\x05)+\n\x0c\n\x04\x04\x02\x02\"\x12\
    \x04\xb3\x05\x08)\n\r\n\x05\x04\x02\x02\"\x04\x12\x04\xb3\x05\x08\x10\n\
    \r\n\x05\x04\x02\x02\"\x05\x12\x04\xb3\x05\x11\x17\n\r\n\x05\x04\x02\x02\
    \"\x01\x12\x04\xb3\x05\x18#\n\r\n\x05\x04\x02\x02\"\x03\x12\x04\xb3\x05&\
    (\n\x0c\n\x04\x04\x02\x02#\x12\x04\xb4\x05\x08+\n\r\n\x05\x04\x02\x02#\
    \x04\x12\x04\xb4\x05\x08\x10\n\r\n\x05\x04\x02\x02#\x05\x12\x04\xb4\x05\
    \x11\x15\n\r\n\x05\x04\x02\x02#\x01\x12\x04\xb4\x05\x16%\n\r\n\x05\x04\
    \x02\x02#\x03\x12\x04\xb4\x05(*\n\x0c\n\x04\x04\x02\x02$\x12\x04\xb5\x05\
    \x08.\n\r\n\x05\x04\x02\x02$\x04\x12\x04\xb5\x05\x08\x10\n\r\n\x05\x04\
    \x02\x02$\x05\x12\x04\xb5\x05\x11\x15\n\r\n\x05\x04\x02\x02$\x01\x12\x04\
    \xb5\x05\x16(\n\r\n\x05\x04\x02\x02$\x03\x12\x04\xb5\x05+-\n\x0c\n\x04\
    \x04\x02\x02%\x12\x04\xb6\x05\x08/\n\r\n\x05\x04\x02\x02%\x04\x12\x04\
    \xb6\x05\x08\x10\n\r\n\x05\x04\x02\x02%\x05\x12\x04\xb6\x05\x11\x17\n\r\
    \n\x05\x04\x02\x02%\x01\x12\x04\xb6\x05\x18)\n\r\n\x05\x04\x02\x02%\x03\
    \x12\x04\xb6\x05,.\n\x0c\n\x04\x04\x02\x02&\x12\x04\xb7\x05\x08'\n\r\n\
    \x05\x04\x02\x02&\x04\x12\x04\xb7\x05\x08\x10\n\r\n\x05\x04\x02\x02&\x05\
    \x12\x04\xb7\x05\x11\x17\n\r\n\x05\x04\x02\x02&\x01\x12\x04\xb7\x05\x18!\
    \n\r\n\x05\x04\x02\x02&\x03\x12\x04\xb7\x05$&\n\x0c\n\x04\x04\x02\x02'\
    \x12\x04\xb8\x05\x08+\n\r\n\x05\x04\x02\x02'\x04\x12\x04\xb8\x05\x08\x10\
    \n\r\n\x05\x04\x02\x02'\x05\x12\x04\xb8\x05\x11\x16\n\r\n\x05\x04\x02\
    \x02'\x01\x12\x04\xb8\x05\x17%\n\r\n\x05\x04\x02\x02'\x03\x12\x04\xb8\
    \x05(*\n\x0c\n\x04\x04\x02\x02(\x12\x04\xb9\x05\x08(\n\r\n\x05\x04\x02\
    \x02(\x04\x12\x04\xb9\x05\x08\x10\n\r\n\x05\x04\x02\x02(\x05\x12\x04\xb9\
    \x05\x11\x15\n\r\n\x05\x04\x02\x02(\x01\x12\x04\xb9\x05\x16\"\n\r\n\x05\
    \x04\x02\x02(\x03\x12\x04\xb9\x05%'\n\x0c\n\x04\x04\x02\x02)\x12\x04\xba\
    \x05\x08/\n\r\n\x05\x04\x02\x02)\x04\x12\x04\xba\x05\x08\x10\n\r\n\x05\
    \x04\x02\x02)\x05\x12\x04\xba\x05\x11\x15\n\r\n\x05\x04\x02\x02)\x01\x12\
    \x04\xba\x05\x16)\n\r\n\x05\x04\x02\x02)\x03\x12\x04\xba\x05,.\n\x0c\n\
    \x04\x04\x02\x02*\x12\x04\xbb\x05\x081\n\r\n\x05\x04\x02\x02*\x04\x12\
    \x04\xbb\x05\x08\x10\n\r\n\x05\x04\x02\x02*\x05\x12\x04\xbb\x05\x11\x17\
    \n\r\n\x05\x04\x02\x02*\x01\x12\x04\xbb\x05\x18+\n\r\n\x05\x04\x02\x02*\
    \x03\x12\x04\xbb\x05.0\n\x0c\n\x04\x04\x02\x02+\x12\x04\xbc\x05\x08/\n\r\
    \n\x05\x04\x02\x02+\x04\x12\x04\xbc\x05\x08\x10\n\r\n\x05\x04\x02\x02+\
    \x05\x12\x04\xbc\x05\x11\x17\n\r\n\x05\x04\x02\x02+\x01\x12\x04\xbc\x05\
    \x18)\n\r\n\x05\x04\x02\x02+\x03\x12\x04\xbc\x05,.\n\x0c\n\x04\x04\x02\
    \x02,\x12\x04\xbd\x05\x08!\n\r\n\x05\x04\x02\x02,\x04\x12\x04\xbd\x05\
    \x08\x10\n\r\n\x05\x04\x02\x02,\x05\x12\x04\xbd\x05\x11\x17\n\r\n\x05\
    \x04\x02\x02,\x01\x12\x04\xbd\x05\x18\x1b\n\r\n\x05\x04\x02\x02,\x03\x12\
    \x04\xbd\x05\x1e\x20\n\x0c\n\x04\x04\x02\x02-\x12\x04\xbe\x05\x08!\n\r\n\
    \x05\x04\x02\x02-\x04\x12\x04\xbe\x05\x08\x10\n\r\n\x05\x04\x02\x02-\x05\
    \x12\x04\xbe\x05\x11\x17\n\r\n\x05\x04\x02\x02-\x01\x12\x04\xbe\x05\x18\
    \x1b\n\r\n\x05\x04\x02\x02-\x03\x12\x04\xbe\x05\x1e\x20\n\x0c\n\x04\x04\
    \x02\x02.\x12\x04\xbf\x05\x08,\n\r\n\x05\x04\x02\x02.\x04\x12\x04\xbf\
    \x05\x08\x10\n\r\n\x05\x04\x02\x02.\x05\x12\x04\xbf\x05\x11\x17\n\r\n\
    \x05\x04\x02\x02.\x01\x12\x04\xbf\x05\x18&\n\r\n\x05\x04\x02\x02.\x03\
    \x12\x04\xbf\x05)+\n\x0c\n\x04\x04\x02\x02/\x12\x04\xc0\x05\x08*\n\r\n\
    \x05\x04\x02\x02/\x04\x12\x04\xc0\x05\x08\x10\n\r\n\x05\x04\x02\x02/\x05\
    \x12\x04\xc0\x05\x11\x15\n\r\n\x05\x04\x02\x02/\x01\x12\x04\xc0\x05\x16$\
    \n\r\n\x05\x04\x02\x02/\x03\x12\x04\xc0\x05')\n\x0c\n\x04\x04\x02\x020\
    \x12\x04\xc1\x05\x08)\n\r\n\x05\x04\x02\x020\x04\x12\x04\xc1\x05\x08\x10\
    \n\r\n\x05\x04\x02\x020\x05\x12\x04\xc1\x05\x11\x17\n\r\n\x05\x04\x02\
    \x020\x01\x12\x04\xc1\x05\x18#\n\r\n\x05\x04\x02\x020\x03\x12\x04\xc1\
    \x05&(\n\x0c\n\x04\x04\x02\x021\x12\x04\xc2\x05\x081\n\r\n\x05\x04\x02\
    \x021\x04\x12\x04\xc2\x05\x08\x10\n\r\n\x05\x04\x02\x021\x05\x12\x04\xc2\
    \x05\x11\x15\n\r\n\x05\x04\x02\x021\x01\x12\x04\xc2\x05\x16+\n\r\n\x05\
    \x04\x02\x021\x03\x12\x04\xc2\x05.0\n\x0c\n\x04\x04\x02\x022\x12\x04\xc3\
    \x05\x08-\n\r\n\x05\x04\x02\x022\x04\x12\x04\xc3\x05\x08\x10\n\r\n\x05\
    \x04\x02\x022\x05\x12\x04\xc3\x05\x11\x17\n\r\n\x05\x04\x02\x022\x01\x12\
    \x04\xc3\x05\x18'\n\r\n\x05\x04\x02\x022\x03\x12\x04\xc3\x05*,\n\x0c\n\
    \x04\x04\x02\x023\x12\x04\xc4\x05\x08&\n\r\n\x05\x04\x02\x023\x04\x12\
    \x04\xc4\x05\x08\x10\n\r\n\x05\x04\x02\x023\x05\x12\x04\xc4\x05\x11\x17\
    \n\r\n\x05\x04\x02\x023\x01\x12\x04\xc4\x05\x18\x20\n\r\n\x05\x04\x02\
    \x023\x03\x12\x04\xc4\x05#%\n\x0c\n\x04\x04\x02\x024\x12\x04\xc5\x05\x08\
    +\n\r\n\x05\x04\x02\x024\x04\x12\x04\xc5\x05\x08\x10\n\r\n\x05\x04\x02\
    \x024\x05\x12\x04\xc5\x05\x11\x17\n\r\n\x05\x04\x02\x024\x01\x12\x04\xc5\
    \x05\x18%\n\r\n\x05\x04\x02\x024\x03\x12\x04\xc5\x05(*\n\x0c\n\x04\x04\
    \x02\x025\x12\x04\xc6\x05\x086\n\r\n\x05\x04\x02\x025\x04\x12\x04\xc6\
    \x05\x08\x10\n\r\n\x05\x04\x02\x025\x05\x12\x04\xc6\x05\x11\x16\n\r\n\
    \x05\x04\x02\x025\x01\x12\x04\xc6\x05\x170\n\r\n\x05\x04\x02\x025\x03\
    \x12\x04\xc6\x0535\n\x0c\n\x04\x04\x02\x026\x12\x04\xc7\x05\x08,\n\r\n\
    \x05\x04\x02\x026\x04\x12\x04\xc7\x05\x08\x10\n\r\n\x05\x04\x02\x026\x05\
    \x12\x04\xc7\x05\x11\x15\n\r\n\x05\x04\x02\x026\x01\x12\x04\xc7\x05\x16&\
    \n\r\n\x05\x04\x02\x026\x03\x12\x04\xc7\x05)+\n\x0c\n\x04\x04\x02\x027\
    \x12\x04\xc8\x05\x08/\n\r\n\x05\x04\x02\x027\x04\x12\x04\xc8\x05\x08\x10\
    \n\r\n\x05\x04\x02\x027\x05\x12\x04\xc8\x05\x11\x15\n\r\n\x05\x04\x02\
    \x027\x01\x12\x04\xc8\x05\x16)\n\r\n\x05\x04\x02\x027\x03\x12\x04\xc8\
    \x05,.\n\x0c\n\x04\x04\x02\x028\x12\x04\xc9\x05\x08+\n\r\n\x05\x04\x02\
    \x028\x04\x12\x04\xc9\x05\x08\x10\n\r\n\x05\x04\x02\x028\x05\x12\x04\xc9\
    \x05\x11\x15\n\r\n\x05\x04\x02\x028\x01\x12\x04\xc9\x05\x16%\n\r\n\x05\
    \x04\x02\x028\x03\x12\x04\xc9\x05(*\n\x0c\n\x04\x04\x02\x029\x12\x04\xca\
    \x05\x08(\n\r\n\x05\x04\x02\x029\x04\x12\x04\xca\x05\x08\x10\n\r\n\x05\
    \x04\x02\x029\x05\x12\x04\xca\x05\x11\x15\n\r\n\x05\x04\x02\x029\x01\x12\
    \x04\xca\x05\x16\"\n\r\n\x05\x04\x02\x029\x03\x12\x04\xca\x05%'\n\x0c\n\
    \x04\x04\x02\x02:\x12\x04\xcb\x05\x086\n\r\n\x05\x04\x02\x02:\x04\x12\
    \x04\xcb\x05\x08\x10\n\r\n\x05\x04\x02\x02:\x05\x12\x04\xcb\x05\x11\x15\
    \n\r\n\x05\x04\x02\x02:\x01\x12\x04\xcb\x05\x160\n\r\n\x05\x04\x02\x02:\
    \x03\x12\x04\xcb\x0535\n\x0c\n\x04\x04\x02\x02;\x12\x04\xcc\x05\x08+\n\r\
    \n\x05\x04\x02\x02;\x04\x12\x04\xcc\x05\x08\x10\n\r\n\x05\x04\x02\x02;\
    \x05\x12\x04\xcc\x05\x11\x15\n\r\n\x05\x04\x02\x02;\x01\x12\x04\xcc\x05\
    \x16%\n\r\n\x05\x04\x02\x02;\x03\x12\x04\xcc\x05(*\n\x0c\n\x04\x04\x02\
    \x02<\x12\x04\xcd\x05\x084\n\r\n\x05\x04\x02\x02<\x04\x12\x04\xcd\x05\
    \x08\x10\n\r\n\x05\x04\x02\x02<\x05\x12\x04\xcd\x05\x11\x17\n\r\n\x05\
    \x04\x02\x02<\x01\x12\x04\xcd\x05\x18.\n\r\n\x05\x04\x02\x02<\x03\x12\
    \x04\xcd\x0513\n\x0c\n\x04\x04\x02\x02=\x12\x04\xce\x05\x080\n\r\n\x05\
    \x04\x02\x02=\x04\x12\x04\xce\x05\x08\x10\n\r\n\x05\x04\x02\x02=\x05\x12\
    \x04\xce\x05\x11\x17\n\r\n\x05\x04\x02\x02=\x01\x12\x04\xce\x05\x18*\n\r\
    \n\x05\x04\x02\x02=\x03\x12\x04\xce\x05-/\n\x0c\n\x04\x04\x02\x02>\x12\
    \x04\xcf\x05\x08)\n\r\n\x05\x04\x02\x02>\x04\x12\x04\xcf\x05\x08\x10\n\r\
    \n\x05\x04\x02\x02>\x05\x12\x04\xcf\x05\x11\x15\n\r\n\x05\x04\x02\x02>\
    \x01\x12\x04\xcf\x05\x16#\n\r\n\x05\x04\x02\x02>\x03\x12\x04\xcf\x05&(\n\
    \x0c\n\x04\x04\x02\x02?\x12\x04\xd0\x05\x084\n\r\n\x05\x04\x02\x02?\x04\
    \x12\x04\xd0\x05\x08\x10\n\r\n\x05\x04\x02\x02?\x05\x12\x04\xd0\x05\x11\
    \x17\n\r\n\x05\x04\x02\x02?\x01\x12\x04\xd0\x05\x18.\n\r\n\x05\x04\x02\
    \x02?\x03\x12\x04\xd0\x0513\n\x0c\n\x04\x04\x02\x02@\x12\x04\xd1\x05\x08\
    )\n\r\n\x05\x04\x02\x02@\x04\x12\x04\xd1\x05\x08\x10\n\r\n\x05\x04\x02\
    \x02@\x05\x12\x04\xd1\x05\x11\x15\n\r\n\x05\x04\x02\x02@\x01\x12\x04\xd1\
    \x05\x16#\n\r\n\x05\x04\x02\x02@\x03\x12\x04\xd1\x05&(\n\x0c\n\x04\x04\
    \x02\x02A\x12\x04\xd2\x05\x081\n\r\n\x05\x04\x02\x02A\x04\x12\x04\xd2\
    \x05\x08\x10\n\r\n\x05\x04\x02\x02A\x05\x12\x04\xd2\x05\x11\x15\n\r\n\
    \x05\x04\x02\x02A\x01\x12\x04\xd2\x05\x16+\n\r\n\x05\x04\x02\x02A\x03\
    \x12\x04\xd2\x05.0\n\x0c\n\x04\x04\x02\x02B\x12\x04\xd3\x05\x087\n\r\n\
    \x05\x04\x02\x02B\x04\x12\x04\xd3\x05\x08\x10\n\r\n\x05\x04\x02\x02B\x05\
    \x12\x04\xd3\x05\x11\x15\n\r\n\x05\x04\x02\x02B\x01\x12\x04\xd3\x05\x161\
    \n\r\n\x05\x04\x02\x02B\x03\x12\x04\xd3\x0546\n\x0c\n\x04\x04\x02\x02C\
    \x12\x04\xd4\x05\x08.\n\r\n\x05\x04\x02\x02C\x04\x12\x04\xd4\x05\x08\x10\
    \n\r\n\x05\x04\x02\x02C\x05\x12\x04\xd4\x05\x11\x17\n\r\n\x05\x04\x02\
    \x02C\x01\x12\x04\xd4\x05\x18(\n\r\n\x05\x04\x02\x02C\x03\x12\x04\xd4\
    \x05+-\n\x0c\n\x04\x04\x02\x02D\x12\x04\xd5\x05\x08+\n\r\n\x05\x04\x02\
    \x02D\x04\x12\x04\xd5\x05\x08\x10\n\r\n\x05\x04\x02\x02D\x05\x12\x04\xd5\
    \x05\x11\x15\n\r\n\x05\x04\x02\x02D\x01\x12\x04\xd5\x05\x16%\n\r\n\x05\
    \x04\x02\x02D\x03\x12\x04\xd5\x05(*\n\x0c\n\x04\x04\x02\x02E\x12\x04\xd6\
    \x05\x087\n\r\n\x05\x04\x02\x02E\x04\x12\x04\xd6\x05\x08\x10\n\r\n\x05\
    \x04\x02\x02E\x05\x12\x04\xd6\x05\x11\x15\n\r\n\x05\x04\x02\x02E\x01\x12\
    \x04\xd6\x05\x161\n\r\n\x05\x04\x02\x02E\x03\x12\x04\xd6\x0546\n\x0c\n\
    \x04\x04\x02\x02F\x12\x04\xd7\x05\x08.\n\r\n\x05\x04\x02\x02F\x04\x12\
    \x04\xd7\x05\x08\x10\n\r\n\x05\x04\x02\x02F\x05\x12\x04\xd7\x05\x11\x17\
    \n\r\n\x05\x04\x02\x02F\x01\x12\x04\xd7\x05\x18(\n\r\n\x05\x04\x02\x02F\
    \x03\x12\x04\xd7\x05+-\n\x0c\n\x04\x04\x02\x02G\x12\x04\xd8\x05\x08/\n\r\
    \n\x05\x04\x02\x02G\x04\x12\x04\xd8\x05\x08\x10\n\r\n\x05\x04\x02\x02G\
    \x05\x12\x04\xd8\x05\x11\x17\n\r\n\x05\x04\x02\x02G\x01\x12\x04\xd8\x05\
    \x18)\n\r\n\x05\x04\x02\x02G\x03\x12\x04\xd8\x05,.\n\x0c\n\x04\x04\x02\
    \x02H\x12\x04\xd9\x05\x082\n\r\n\x05\x04\x02\x02H\x04\x12\x04\xd9\x05\
    \x08\x10\n\r\n\x05\x04\x02\x02H\x05\x12\x04\xd9\x05\x11\x15\n\r\n\x05\
    \x04\x02\x02H\x01\x12\x04\xd9\x05\x16,\n\r\n\x05\x04\x02\x02H\x03\x12\
    \x04\xd9\x05/1\n\x0c\n\x04\x04\x02\x02I\x12\x04\xda\x05\x08)\n\r\n\x05\
    \x04\x02\x02I\x04\x12\x04\xda\x05\x08\x10\n\r\n\x05\x04\x02\x02I\x05\x12\
    \x04\xda\x05\x11\x15\n\r\n\x05\x04\x02\x02I\x01\x12\x04\xda\x05\x16#\n\r\
    \n\x05\x04\x02\x02I\x03\x12\x04\xda\x05&(\n\x0c\n\x04\x04\x02\x02J\x12\
    \x04\xdb\x05\x080\n\r\n\x05\x04\x02\x02J\x04\x12\x04\xdb\x05\x08\x10\n\r\
    \n\x05\x04\x02\x02J\x05\x12\x04\xdb\x05\x11\x15\n\r\n\x05\x04\x02\x02J\
    \x01\x12\x04\xdb\x05\x16*\n\r\n\x05\x04\x02\x02J\x03\x12\x04\xdb\x05-/\n\
    \x0c\n\x04\x04\x02\x02K\x12\x04\xdc\x05\x08/\n\r\n\x05\x04\x02\x02K\x04\
    \x12\x04\xdc\x05\x08\x10\n\r\n\x05\x04\x02\x02K\x05\x12\x04\xdc\x05\x11\
    \x17\n\r\n\x05\x04\x02\x02K\x01\x12\x04\xdc\x05\x18)\n\r\n\x05\x04\x02\
    \x02K\x03\x12\x04\xdc\x05,.\n\x0c\n\x04\x04\x02\x02L\x12\x04\xdd\x05\x08\
    /\n\r\n\x05\x04\x02\x02L\x04\x12\x04\xdd\x05\x08\x10\n\r\n\x05\x04\x02\
    \x02L\x05\x12\x04\xdd\x05\x11\x16\n\r\n\x05\x04\x02\x02L\x01\x12\x04\xdd\
    \x05\x17)\n\r\n\x05\x04\x02\x02L\x03\x12\x04\xdd\x05,.\n\x0c\n\x04\x04\
    \x02\x02M\x12\x04\xde\x05\x08,\n\r\n\x05\x04\x02\x02M\x04\x12\x04\xde\
    \x05\x08\x10\n\r\n\x05\x04\x02\x02M\x05\x12\x04\xde\x05\x11\x15\n\r\n\
    \x05\x04\x02\x02M\x01\x12\x04\xde\x05\x16&\n\r\n\x05\x04\x02\x02M\x03\
    \x12\x04\xde\x05)+\n\x0c\n\x04\x04\x02\x02N\x12\x04\xdf\x05\x08(\n\r\n\
    \x05\x04\x02\x02N\x04\x12\x04\xdf\x05\x08\x10\n\r\n\x05\x04\x02\x02N\x05\
    \x12\x04\xdf\x05\x11\x15\n\r\n\x05\x04\x02\x02N\x01\x12\x04\xdf\x05\x16\
    \"\n\r\n\x05\x04\x02\x02N\x03\x12\x04\xdf\x05%'\n\x0c\n\x02\x04\x03\x12\
    \x06\xe2\x05\0\xe9\x05\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xe2\x05\x08\
    \x1d\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xe3\x05\x08%\n\r\n\x05\x04\x03\
    \x02\0\x04\x12\x04\xe3\x05\x08\x10\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\
    \xe3\x05\x11\x17\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xe3\x05\x18\x20\n\r\
    \n\x05\x04\x03\x02\0\x03\x12\x04\xe3\x05#$\n\x0c\n\x04\x04\x03\x02\x01\
    \x12\x04\xe4\x05\x08&\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04\xe4\x05\x08\
    \x10\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\xe4\x05\x11\x17\n\r\n\x05\x04\
    \x03\x02\x01\x01\x12\x04\xe4\x05\x18!\n\r\n\x05\x04\x03\x02\x01\x03\x12\
    \x04\xe4\x05$%\n\x0c\n\x04\x04\x03\x02\x02\x12\x04\xe5\x05\x08)\n\r\n\
    \x05\x04\x03\x02\x02\x04\x12\x04\xe5\x05\x08\x10\n\r\n\x05\x04\x03\x02\
    \x02\x05\x12\x04\xe5\x05\x11\x17\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\
    \xe5\x05\x18$\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\xe5\x05'(\n\x0c\n\
    \x04\x04\x03\x02\x03\x12\x04\xe6\x05\x086\n\r\n\x05\x04\x03\x02\x03\x04\
    \x12\x04\xe6\x05\x08\x10\n\r\n\x05\x04\x03\x02\x03\x06\x12\x04\xe6\x05\
    \x11&\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xe6\x05'1\n\r\n\x05\x04\x03\
    \x02\x03\x03\x12\x04\xe6\x0545\n\x0c\n\x04\x04\x03\x02\x04\x12\x04\xe7\
    \x05\x08)\n\r\n\x05\x04\x03\x02\x04\x04\x12\x04\xe7\x05\x08\x10\n\r\n\
    \x05\x04\x03\x02\x04\x05\x12\x04\xe7\x05\x11\x17\n\r\n\x05\x04\x03\x02\
    \x04\x01\x12\x04\xe7\x05\x18$\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\xe7\
    \x05'(\n\x0c\n\x04\x04\x03\x02\x05\x12\x04\xe8\x05\x08'\n\r\n\x05\x04\
    \x03\x02\x05\x04\x12\x04\xe8\x05\x08\x10\n\r\n\x05\x04\x03\x02\x05\x05\
    \x12\x04\xe8\x05\x11\x17\n\r\n\x05\x04\x03\x02\x05\x01\x12\x04\xe8\x05\
    \x18\"\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\xe8\x05%&\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(7);
            messages.push(CDOTAClientHardwareSpecs::generated_message_descriptor_data());
            messages.push(CDOTASaveGame::generated_message_descriptor_data());
            messages.push(CMsgDOTACombatLogEntry::generated_message_descriptor_data());
            messages.push(CMsgPendingEventAward::generated_message_descriptor_data());
            messages.push(cdotasave_game::Player::generated_message_descriptor_data());
            messages.push(cdotasave_game::SaveInstance::generated_message_descriptor_data());
            messages.push(cdotasave_game::save_instance::PlayerPositions::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(46);
            enums.push(DOTA_GameMode::generated_enum_descriptor_data());
            enums.push(DOTA_GameState::generated_enum_descriptor_data());
            enums.push(DOTA_GC_TEAM::generated_enum_descriptor_data());
            enums.push(EEvent::generated_enum_descriptor_data());
            enums.push(ERankType::generated_enum_descriptor_data());
            enums.push(DOTALeaverStatus_t::generated_enum_descriptor_data());
            enums.push(DOTAConnectionState_t::generated_enum_descriptor_data());
            enums.push(Fantasy_Roles::generated_enum_descriptor_data());
            enums.push(Fantasy_Team_Slots::generated_enum_descriptor_data());
            enums.push(Fantasy_Selection_Mode::generated_enum_descriptor_data());
            enums.push(DOTAChatChannelType_t::generated_enum_descriptor_data());
            enums.push(EChatSpecialPrivileges::generated_enum_descriptor_data());
            enums.push(EProfileCardSlotType::generated_enum_descriptor_data());
            enums.push(EMatchGroupServerStatus::generated_enum_descriptor_data());
            enums.push(DOTA_CM_PICK::generated_enum_descriptor_data());
            enums.push(DOTALowPriorityBanType::generated_enum_descriptor_data());
            enums.push(DOTALobbyReadyState::generated_enum_descriptor_data());
            enums.push(DOTAJoinLobbyResult::generated_enum_descriptor_data());
            enums.push(DOTASelectionPriorityRules::generated_enum_descriptor_data());
            enums.push(DOTASelectionPriorityChoice::generated_enum_descriptor_data());
            enums.push(DOTAMatchVote::generated_enum_descriptor_data());
            enums.push(DOTALobbyVisibility::generated_enum_descriptor_data());
            enums.push(EDOTAPlayerMMRType::generated_enum_descriptor_data());
            enums.push(EDOTAMMRBoostType::generated_enum_descriptor_data());
            enums.push(MatchType::generated_enum_descriptor_data());
            enums.push(DOTABotDifficulty::generated_enum_descriptor_data());
            enums.push(DOTA_BOT_MODE::generated_enum_descriptor_data());
            enums.push(MatchLanguages::generated_enum_descriptor_data());
            enums.push(ETourneyQueueDeadlineState::generated_enum_descriptor_data());
            enums.push(EMatchOutcome::generated_enum_descriptor_data());
            enums.push(ELaneType::generated_enum_descriptor_data());
            enums.push(EBadgeType::generated_enum_descriptor_data());
            enums.push(ELeagueStatus::generated_enum_descriptor_data());
            enums.push(ELeagueRegion::generated_enum_descriptor_data());
            enums.push(ELeagueTier::generated_enum_descriptor_data());
            enums.push(ELeagueTierCategory::generated_enum_descriptor_data());
            enums.push(ELeagueDivision::generated_enum_descriptor_data());
            enums.push(ELeagueBroadcastProvider::generated_enum_descriptor_data());
            enums.push(ELeaguePhase::generated_enum_descriptor_data());
            enums.push(ELeagueAuditAction::generated_enum_descriptor_data());
            enums.push(DOTA_COMBATLOG_TYPES::generated_enum_descriptor_data());
            enums.push(EDPCFavoriteType::generated_enum_descriptor_data());
            enums.push(EDPCPushNotification::generated_enum_descriptor_data());
            enums.push(EEventActionScoreMode::generated_enum_descriptor_data());
            enums.push(EPlayerChallengeHistoryType::generated_enum_descriptor_data());
            enums.push(EOverwatchReportReason::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
