// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_candy_shop.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgCandyShopCandyCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCandyShopCandyCount {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCandyShopCandyCount.candy_type)
    pub candy_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopCandyCount.candy_count)
    pub candy_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCandyShopCandyCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCandyShopCandyCount {
    fn default() -> &'a CMsgCandyShopCandyCount {
        <CMsgCandyShopCandyCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCandyShopCandyCount {
    pub fn new() -> CMsgCandyShopCandyCount {
        ::std::default::Default::default()
    }

    // optional uint32 candy_type = 1;

    pub fn candy_type(&self) -> u32 {
        self.candy_type.unwrap_or(0)
    }

    pub fn clear_candy_type(&mut self) {
        self.candy_type = ::std::option::Option::None;
    }

    pub fn has_candy_type(&self) -> bool {
        self.candy_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_type(&mut self, v: u32) {
        self.candy_type = ::std::option::Option::Some(v);
    }

    // optional uint32 candy_count = 2;

    pub fn candy_count(&self) -> u32 {
        self.candy_count.unwrap_or(0)
    }

    pub fn clear_candy_count(&mut self) {
        self.candy_count = ::std::option::Option::None;
    }

    pub fn has_candy_count(&self) -> bool {
        self.candy_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_count(&mut self, v: u32) {
        self.candy_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_type",
            |m: &CMsgCandyShopCandyCount| { &m.candy_type },
            |m: &mut CMsgCandyShopCandyCount| { &mut m.candy_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_count",
            |m: &CMsgCandyShopCandyCount| { &m.candy_count },
            |m: &mut CMsgCandyShopCandyCount| { &mut m.candy_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCandyShopCandyCount>(
            "CMsgCandyShopCandyCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCandyShopCandyCount {
    const NAME: &'static str = "CMsgCandyShopCandyCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.candy_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.candy_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.candy_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCandyShopCandyCount {
        CMsgCandyShopCandyCount::new()
    }

    fn clear(&mut self) {
        self.candy_type = ::std::option::Option::None;
        self.candy_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCandyShopCandyCount {
        static instance: CMsgCandyShopCandyCount = CMsgCandyShopCandyCount {
            candy_type: ::std::option::Option::None,
            candy_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCandyShopCandyCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCandyShopCandyCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCandyShopCandyCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCandyShopCandyCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCandyShopCandyQuantity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCandyShopCandyQuantity {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCandyShopCandyQuantity.candy_counts)
    pub candy_counts: ::std::vec::Vec<CMsgCandyShopCandyCount>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCandyShopCandyQuantity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCandyShopCandyQuantity {
    fn default() -> &'a CMsgCandyShopCandyQuantity {
        <CMsgCandyShopCandyQuantity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCandyShopCandyQuantity {
    pub fn new() -> CMsgCandyShopCandyQuantity {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "candy_counts",
            |m: &CMsgCandyShopCandyQuantity| { &m.candy_counts },
            |m: &mut CMsgCandyShopCandyQuantity| { &mut m.candy_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCandyShopCandyQuantity>(
            "CMsgCandyShopCandyQuantity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCandyShopCandyQuantity {
    const NAME: &'static str = "CMsgCandyShopCandyQuantity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.candy_counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.candy_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.candy_counts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCandyShopCandyQuantity {
        CMsgCandyShopCandyQuantity::new()
    }

    fn clear(&mut self) {
        self.candy_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCandyShopCandyQuantity {
        static instance: CMsgCandyShopCandyQuantity = CMsgCandyShopCandyQuantity {
            candy_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCandyShopCandyQuantity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCandyShopCandyQuantity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCandyShopCandyQuantity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCandyShopCandyQuantity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCandyShopExchangeRecipe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCandyShopExchangeRecipe {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCandyShopExchangeRecipe.recipe_id)
    pub recipe_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopExchangeRecipe.input)
    pub input: ::protobuf::MessageField<CMsgCandyShopCandyQuantity>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopExchangeRecipe.output)
    pub output: ::protobuf::MessageField<CMsgCandyShopCandyQuantity>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCandyShopExchangeRecipe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCandyShopExchangeRecipe {
    fn default() -> &'a CMsgCandyShopExchangeRecipe {
        <CMsgCandyShopExchangeRecipe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCandyShopExchangeRecipe {
    pub fn new() -> CMsgCandyShopExchangeRecipe {
        ::std::default::Default::default()
    }

    // optional uint32 recipe_id = 1;

    pub fn recipe_id(&self) -> u32 {
        self.recipe_id.unwrap_or(0)
    }

    pub fn clear_recipe_id(&mut self) {
        self.recipe_id = ::std::option::Option::None;
    }

    pub fn has_recipe_id(&self) -> bool {
        self.recipe_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipe_id(&mut self, v: u32) {
        self.recipe_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipe_id",
            |m: &CMsgCandyShopExchangeRecipe| { &m.recipe_id },
            |m: &mut CMsgCandyShopExchangeRecipe| { &mut m.recipe_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopCandyQuantity>(
            "input",
            |m: &CMsgCandyShopExchangeRecipe| { &m.input },
            |m: &mut CMsgCandyShopExchangeRecipe| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopCandyQuantity>(
            "output",
            |m: &CMsgCandyShopExchangeRecipe| { &m.output },
            |m: &mut CMsgCandyShopExchangeRecipe| { &mut m.output },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCandyShopExchangeRecipe>(
            "CMsgCandyShopExchangeRecipe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCandyShopExchangeRecipe {
    const NAME: &'static str = "CMsgCandyShopExchangeRecipe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.recipe_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recipe_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.output.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.recipe_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.output.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCandyShopExchangeRecipe {
        CMsgCandyShopExchangeRecipe::new()
    }

    fn clear(&mut self) {
        self.recipe_id = ::std::option::Option::None;
        self.input.clear();
        self.output.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCandyShopExchangeRecipe {
        static instance: CMsgCandyShopExchangeRecipe = CMsgCandyShopExchangeRecipe {
            recipe_id: ::std::option::Option::None,
            input: ::protobuf::MessageField::none(),
            output: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCandyShopExchangeRecipe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCandyShopExchangeRecipe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCandyShopExchangeRecipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCandyShopExchangeRecipe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCandyShopRewardData_Item)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCandyShopRewardData_Item {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCandyShopRewardData_Item.item_def)
    pub item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCandyShopRewardData_Item.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCandyShopRewardData_Item {
    fn default() -> &'a CMsgCandyShopRewardData_Item {
        <CMsgCandyShopRewardData_Item as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCandyShopRewardData_Item {
    pub fn new() -> CMsgCandyShopRewardData_Item {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def",
            |m: &CMsgCandyShopRewardData_Item| { &m.item_def },
            |m: &mut CMsgCandyShopRewardData_Item| { &mut m.item_def },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCandyShopRewardData_Item>(
            "CMsgCandyShopRewardData_Item",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCandyShopRewardData_Item {
    const NAME: &'static str = "CMsgCandyShopRewardData_Item";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCandyShopRewardData_Item {
        CMsgCandyShopRewardData_Item::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCandyShopRewardData_Item {
        static instance: CMsgCandyShopRewardData_Item = CMsgCandyShopRewardData_Item {
            item_def: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCandyShopRewardData_Item {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCandyShopRewardData_Item").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCandyShopRewardData_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCandyShopRewardData_Item {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCandyShopRewardData_EventAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCandyShopRewardData_EventAction {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCandyShopRewardData_EventAction.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopRewardData_EventAction.action_id)
    pub action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopRewardData_EventAction.quantity)
    pub quantity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCandyShopRewardData_EventAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCandyShopRewardData_EventAction {
    fn default() -> &'a CMsgCandyShopRewardData_EventAction {
        <CMsgCandyShopRewardData_EventAction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCandyShopRewardData_EventAction {
    pub fn new() -> CMsgCandyShopRewardData_EventAction {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 action_id = 2;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 3;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgCandyShopRewardData_EventAction| { &m.event_id },
            |m: &mut CMsgCandyShopRewardData_EventAction| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action_id",
            |m: &CMsgCandyShopRewardData_EventAction| { &m.action_id },
            |m: &mut CMsgCandyShopRewardData_EventAction| { &mut m.action_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CMsgCandyShopRewardData_EventAction| { &m.quantity },
            |m: &mut CMsgCandyShopRewardData_EventAction| { &mut m.quantity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCandyShopRewardData_EventAction>(
            "CMsgCandyShopRewardData_EventAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCandyShopRewardData_EventAction {
    const NAME: &'static str = "CMsgCandyShopRewardData_EventAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.action_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCandyShopRewardData_EventAction {
        CMsgCandyShopRewardData_EventAction::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.action_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCandyShopRewardData_EventAction {
        static instance: CMsgCandyShopRewardData_EventAction = CMsgCandyShopRewardData_EventAction {
            event_id: ::std::option::Option::None,
            action_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCandyShopRewardData_EventAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCandyShopRewardData_EventAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCandyShopRewardData_EventAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCandyShopRewardData_EventAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCandyShopRewardData_EventPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCandyShopRewardData_EventPoints {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCandyShopRewardData_EventPoints.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopRewardData_EventPoints.points)
    pub points: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCandyShopRewardData_EventPoints.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCandyShopRewardData_EventPoints {
    fn default() -> &'a CMsgCandyShopRewardData_EventPoints {
        <CMsgCandyShopRewardData_EventPoints as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCandyShopRewardData_EventPoints {
    pub fn new() -> CMsgCandyShopRewardData_EventPoints {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 points = 2;

    pub fn points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgCandyShopRewardData_EventPoints| { &m.event_id },
            |m: &mut CMsgCandyShopRewardData_EventPoints| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points",
            |m: &CMsgCandyShopRewardData_EventPoints| { &m.points },
            |m: &mut CMsgCandyShopRewardData_EventPoints| { &mut m.points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCandyShopRewardData_EventPoints>(
            "CMsgCandyShopRewardData_EventPoints",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCandyShopRewardData_EventPoints {
    const NAME: &'static str = "CMsgCandyShopRewardData_EventPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.points = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.points {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCandyShopRewardData_EventPoints {
        CMsgCandyShopRewardData_EventPoints::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.points = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCandyShopRewardData_EventPoints {
        static instance: CMsgCandyShopRewardData_EventPoints = CMsgCandyShopRewardData_EventPoints {
            event_id: ::std::option::Option::None,
            points: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCandyShopRewardData_EventPoints {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCandyShopRewardData_EventPoints").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCandyShopRewardData_EventPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCandyShopRewardData_EventPoints {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCandyShopReward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCandyShopReward {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCandyShopReward.reward_id)
    pub reward_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopReward.reward_option_id)
    pub reward_option_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopReward.price)
    pub price: ::protobuf::MessageField<CMsgCandyShopCandyQuantity>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopReward.reward_type)
    pub reward_type: ::std::option::Option<::protobuf::EnumOrUnknown<ECandyShopRewardType>>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopReward.item_data)
    pub item_data: ::protobuf::MessageField<CMsgCandyShopRewardData_Item>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopReward.event_action_data)
    pub event_action_data: ::protobuf::MessageField<CMsgCandyShopRewardData_EventAction>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopReward.event_points_data)
    pub event_points_data: ::protobuf::MessageField<CMsgCandyShopRewardData_EventPoints>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCandyShopReward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCandyShopReward {
    fn default() -> &'a CMsgCandyShopReward {
        <CMsgCandyShopReward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCandyShopReward {
    pub fn new() -> CMsgCandyShopReward {
        ::std::default::Default::default()
    }

    // optional uint32 reward_id = 1;

    pub fn reward_id(&self) -> u32 {
        self.reward_id.unwrap_or(0)
    }

    pub fn clear_reward_id(&mut self) {
        self.reward_id = ::std::option::Option::None;
    }

    pub fn has_reward_id(&self) -> bool {
        self.reward_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_id(&mut self, v: u32) {
        self.reward_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_option_id = 2;

    pub fn reward_option_id(&self) -> u32 {
        self.reward_option_id.unwrap_or(0)
    }

    pub fn clear_reward_option_id(&mut self) {
        self.reward_option_id = ::std::option::Option::None;
    }

    pub fn has_reward_option_id(&self) -> bool {
        self.reward_option_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_option_id(&mut self, v: u32) {
        self.reward_option_id = ::std::option::Option::Some(v);
    }

    // optional .dota.ECandyShopRewardType reward_type = 4;

    pub fn reward_type(&self) -> ECandyShopRewardType {
        match self.reward_type {
            Some(e) => e.enum_value_or(ECandyShopRewardType::k_eCandyShopRewardType_None),
            None => ECandyShopRewardType::k_eCandyShopRewardType_None,
        }
    }

    pub fn clear_reward_type(&mut self) {
        self.reward_type = ::std::option::Option::None;
    }

    pub fn has_reward_type(&self) -> bool {
        self.reward_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_type(&mut self, v: ECandyShopRewardType) {
        self.reward_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_id",
            |m: &CMsgCandyShopReward| { &m.reward_id },
            |m: &mut CMsgCandyShopReward| { &mut m.reward_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_option_id",
            |m: &CMsgCandyShopReward| { &m.reward_option_id },
            |m: &mut CMsgCandyShopReward| { &mut m.reward_option_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopCandyQuantity>(
            "price",
            |m: &CMsgCandyShopReward| { &m.price },
            |m: &mut CMsgCandyShopReward| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_type",
            |m: &CMsgCandyShopReward| { &m.reward_type },
            |m: &mut CMsgCandyShopReward| { &mut m.reward_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopRewardData_Item>(
            "item_data",
            |m: &CMsgCandyShopReward| { &m.item_data },
            |m: &mut CMsgCandyShopReward| { &mut m.item_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopRewardData_EventAction>(
            "event_action_data",
            |m: &CMsgCandyShopReward| { &m.event_action_data },
            |m: &mut CMsgCandyShopReward| { &mut m.event_action_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopRewardData_EventPoints>(
            "event_points_data",
            |m: &CMsgCandyShopReward| { &m.event_points_data },
            |m: &mut CMsgCandyShopReward| { &mut m.event_points_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCandyShopReward>(
            "CMsgCandyShopReward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCandyShopReward {
    const NAME: &'static str = "CMsgCandyShopReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reward_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reward_option_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price)?;
                },
                32 => {
                    self.reward_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item_data)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.event_action_data)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.event_points_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reward_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reward_option_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reward_type {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.item_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event_action_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event_points_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reward_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reward_option_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.price.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reward_type {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.event_action_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.event_points_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCandyShopReward {
        CMsgCandyShopReward::new()
    }

    fn clear(&mut self) {
        self.reward_id = ::std::option::Option::None;
        self.reward_option_id = ::std::option::Option::None;
        self.price.clear();
        self.reward_type = ::std::option::Option::None;
        self.item_data.clear();
        self.event_action_data.clear();
        self.event_points_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCandyShopReward {
        static instance: CMsgCandyShopReward = CMsgCandyShopReward {
            reward_id: ::std::option::Option::None,
            reward_option_id: ::std::option::Option::None,
            price: ::protobuf::MessageField::none(),
            reward_type: ::std::option::Option::None,
            item_data: ::protobuf::MessageField::none(),
            event_action_data: ::protobuf::MessageField::none(),
            event_points_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCandyShopReward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCandyShopReward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCandyShopReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCandyShopReward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCandyShopUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCandyShopUserData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCandyShopUserData.inventory_size)
    pub inventory_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopUserData.inventory)
    pub inventory: ::protobuf::MessageField<CMsgCandyShopCandyQuantity>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopUserData.exchange_reset_timestamp)
    pub exchange_reset_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopUserData.exchange_recipes)
    pub exchange_recipes: ::std::vec::Vec<CMsgCandyShopExchangeRecipe>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopUserData.active_rewards)
    pub active_rewards: ::std::vec::Vec<CMsgCandyShopReward>,
    // @@protoc_insertion_point(field:dota.CMsgCandyShopUserData.reroll_charges)
    pub reroll_charges: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCandyShopUserData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCandyShopUserData {
    fn default() -> &'a CMsgCandyShopUserData {
        <CMsgCandyShopUserData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCandyShopUserData {
    pub fn new() -> CMsgCandyShopUserData {
        ::std::default::Default::default()
    }

    // optional uint32 inventory_size = 1;

    pub fn inventory_size(&self) -> u32 {
        self.inventory_size.unwrap_or(0)
    }

    pub fn clear_inventory_size(&mut self) {
        self.inventory_size = ::std::option::Option::None;
    }

    pub fn has_inventory_size(&self) -> bool {
        self.inventory_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory_size(&mut self, v: u32) {
        self.inventory_size = ::std::option::Option::Some(v);
    }

    // optional fixed32 exchange_reset_timestamp = 3;

    pub fn exchange_reset_timestamp(&self) -> u32 {
        self.exchange_reset_timestamp.unwrap_or(0)
    }

    pub fn clear_exchange_reset_timestamp(&mut self) {
        self.exchange_reset_timestamp = ::std::option::Option::None;
    }

    pub fn has_exchange_reset_timestamp(&self) -> bool {
        self.exchange_reset_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exchange_reset_timestamp(&mut self, v: u32) {
        self.exchange_reset_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 reroll_charges = 6;

    pub fn reroll_charges(&self) -> u32 {
        self.reroll_charges.unwrap_or(0)
    }

    pub fn clear_reroll_charges(&mut self) {
        self.reroll_charges = ::std::option::Option::None;
    }

    pub fn has_reroll_charges(&self) -> bool {
        self.reroll_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reroll_charges(&mut self, v: u32) {
        self.reroll_charges = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory_size",
            |m: &CMsgCandyShopUserData| { &m.inventory_size },
            |m: &mut CMsgCandyShopUserData| { &mut m.inventory_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopCandyQuantity>(
            "inventory",
            |m: &CMsgCandyShopUserData| { &m.inventory },
            |m: &mut CMsgCandyShopUserData| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exchange_reset_timestamp",
            |m: &CMsgCandyShopUserData| { &m.exchange_reset_timestamp },
            |m: &mut CMsgCandyShopUserData| { &mut m.exchange_reset_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exchange_recipes",
            |m: &CMsgCandyShopUserData| { &m.exchange_recipes },
            |m: &mut CMsgCandyShopUserData| { &mut m.exchange_recipes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "active_rewards",
            |m: &CMsgCandyShopUserData| { &m.active_rewards },
            |m: &mut CMsgCandyShopUserData| { &mut m.active_rewards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reroll_charges",
            |m: &CMsgCandyShopUserData| { &m.reroll_charges },
            |m: &mut CMsgCandyShopUserData| { &mut m.reroll_charges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCandyShopUserData>(
            "CMsgCandyShopUserData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCandyShopUserData {
    const NAME: &'static str = "CMsgCandyShopUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.inventory_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inventory)?;
                },
                29 => {
                    self.exchange_reset_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                34 => {
                    self.exchange_recipes.push(is.read_message()?);
                },
                42 => {
                    self.active_rewards.push(is.read_message()?);
                },
                48 => {
                    self.reroll_charges = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inventory_size {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.inventory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.exchange_reset_timestamp {
            my_size += 1 + 4;
        }
        for value in &self.exchange_recipes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.active_rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.reroll_charges {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.inventory_size {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inventory.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.exchange_reset_timestamp {
            os.write_fixed32(3, v)?;
        }
        for v in &self.exchange_recipes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.active_rewards {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.reroll_charges {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCandyShopUserData {
        CMsgCandyShopUserData::new()
    }

    fn clear(&mut self) {
        self.inventory_size = ::std::option::Option::None;
        self.inventory.clear();
        self.exchange_reset_timestamp = ::std::option::Option::None;
        self.exchange_recipes.clear();
        self.active_rewards.clear();
        self.reroll_charges = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCandyShopUserData {
        static instance: CMsgCandyShopUserData = CMsgCandyShopUserData {
            inventory_size: ::std::option::Option::None,
            inventory: ::protobuf::MessageField::none(),
            exchange_reset_timestamp: ::std::option::Option::None,
            exchange_recipes: ::std::vec::Vec::new(),
            active_rewards: ::std::vec::Vec::new(),
            reroll_charges: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCandyShopUserData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCandyShopUserData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCandyShopUserData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCandyShopUserData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopGetUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopGetUserData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopGetUserData.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopGetUserData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopGetUserData {
    fn default() -> &'a CMsgClientToGCCandyShopGetUserData {
        <CMsgClientToGCCandyShopGetUserData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopGetUserData {
    pub fn new() -> CMsgClientToGCCandyShopGetUserData {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopGetUserData| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopGetUserData| { &mut m.candy_shop_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopGetUserData>(
            "CMsgClientToGCCandyShopGetUserData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopGetUserData {
    const NAME: &'static str = "CMsgClientToGCCandyShopGetUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopGetUserData {
        CMsgClientToGCCandyShopGetUserData::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopGetUserData {
        static instance: CMsgClientToGCCandyShopGetUserData = CMsgClientToGCCandyShopGetUserData {
            candy_shop_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopGetUserData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopGetUserData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopGetUserData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopGetUserData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopGetUserDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopGetUserDataResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopGetUserDataResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_get_user_data_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopGetUserDataResponse.user_data)
    pub user_data: ::protobuf::MessageField<CMsgCandyShopUserData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopGetUserDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopGetUserDataResponse {
    fn default() -> &'a CMsgClientToGCCandyShopGetUserDataResponse {
        <CMsgClientToGCCandyShopGetUserDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopGetUserDataResponse {
    pub fn new() -> CMsgClientToGCCandyShopGetUserDataResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopGetUserDataResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_get_user_data_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_get_user_data_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_get_user_data_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_get_user_data_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopGetUserDataResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopGetUserDataResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopUserData>(
            "user_data",
            |m: &CMsgClientToGCCandyShopGetUserDataResponse| { &m.user_data },
            |m: &mut CMsgClientToGCCandyShopGetUserDataResponse| { &mut m.user_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopGetUserDataResponse>(
            "CMsgClientToGCCandyShopGetUserDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopGetUserDataResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopGetUserDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.user_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.user_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopGetUserDataResponse {
        CMsgClientToGCCandyShopGetUserDataResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.user_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopGetUserDataResponse {
        static instance: CMsgClientToGCCandyShopGetUserDataResponse = CMsgClientToGCCandyShopGetUserDataResponse {
            response: ::std::option::Option::None,
            user_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopGetUserDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopGetUserDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopGetUserDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopGetUserDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopGetUserDataResponse`
pub mod cmsg_client_to_gccandy_shop_get_user_data_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopGetUserDataResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopGetUserDataResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopGetUserDataResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopGetUserDataResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopGetUserDataResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopGetUserDataResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopGetUserDataResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopGetUserDataResponse.EResponse.k_eExpiredShop)
        k_eExpiredShop = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                6 => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                "k_eExpiredShop" => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidShop,
            EResponse::k_eExpiredShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopGetUserDataResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopGetUserDataResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientCandyShopUserDataUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientCandyShopUserDataUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientCandyShopUserDataUpdated.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientCandyShopUserDataUpdated.user_data)
    pub user_data: ::protobuf::MessageField<CMsgCandyShopUserData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientCandyShopUserDataUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientCandyShopUserDataUpdated {
    fn default() -> &'a CMsgGCToClientCandyShopUserDataUpdated {
        <CMsgGCToClientCandyShopUserDataUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientCandyShopUserDataUpdated {
    pub fn new() -> CMsgGCToClientCandyShopUserDataUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgGCToClientCandyShopUserDataUpdated| { &m.candy_shop_id },
            |m: &mut CMsgGCToClientCandyShopUserDataUpdated| { &mut m.candy_shop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopUserData>(
            "user_data",
            |m: &CMsgGCToClientCandyShopUserDataUpdated| { &m.user_data },
            |m: &mut CMsgGCToClientCandyShopUserDataUpdated| { &mut m.user_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientCandyShopUserDataUpdated>(
            "CMsgGCToClientCandyShopUserDataUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientCandyShopUserDataUpdated {
    const NAME: &'static str = "CMsgGCToClientCandyShopUserDataUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.user_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.user_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientCandyShopUserDataUpdated {
        CMsgGCToClientCandyShopUserDataUpdated::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.user_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientCandyShopUserDataUpdated {
        static instance: CMsgGCToClientCandyShopUserDataUpdated = CMsgGCToClientCandyShopUserDataUpdated {
            candy_shop_id: ::std::option::Option::None,
            user_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientCandyShopUserDataUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientCandyShopUserDataUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientCandyShopUserDataUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientCandyShopUserDataUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopPurchaseReward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopPurchaseReward {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopPurchaseReward.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopPurchaseReward.reward_id)
    pub reward_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopPurchaseReward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopPurchaseReward {
    fn default() -> &'a CMsgClientToGCCandyShopPurchaseReward {
        <CMsgClientToGCCandyShopPurchaseReward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopPurchaseReward {
    pub fn new() -> CMsgClientToGCCandyShopPurchaseReward {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    // optional uint64 reward_id = 2;

    pub fn reward_id(&self) -> u64 {
        self.reward_id.unwrap_or(0)
    }

    pub fn clear_reward_id(&mut self) {
        self.reward_id = ::std::option::Option::None;
    }

    pub fn has_reward_id(&self) -> bool {
        self.reward_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_id(&mut self, v: u64) {
        self.reward_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopPurchaseReward| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopPurchaseReward| { &mut m.candy_shop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_id",
            |m: &CMsgClientToGCCandyShopPurchaseReward| { &m.reward_id },
            |m: &mut CMsgClientToGCCandyShopPurchaseReward| { &mut m.reward_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopPurchaseReward>(
            "CMsgClientToGCCandyShopPurchaseReward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopPurchaseReward {
    const NAME: &'static str = "CMsgClientToGCCandyShopPurchaseReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reward_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reward_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reward_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopPurchaseReward {
        CMsgClientToGCCandyShopPurchaseReward::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.reward_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopPurchaseReward {
        static instance: CMsgClientToGCCandyShopPurchaseReward = CMsgClientToGCCandyShopPurchaseReward {
            candy_shop_id: ::std::option::Option::None,
            reward_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopPurchaseReward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopPurchaseReward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopPurchaseReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopPurchaseReward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopPurchaseRewardResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopPurchaseRewardResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_purchase_reward_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopPurchaseRewardResponse {
    fn default() -> &'a CMsgClientToGCCandyShopPurchaseRewardResponse {
        <CMsgClientToGCCandyShopPurchaseRewardResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopPurchaseRewardResponse {
    pub fn new() -> CMsgClientToGCCandyShopPurchaseRewardResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_purchase_reward_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_purchase_reward_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_purchase_reward_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_purchase_reward_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopPurchaseRewardResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopPurchaseRewardResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopPurchaseRewardResponse>(
            "CMsgClientToGCCandyShopPurchaseRewardResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopPurchaseRewardResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopPurchaseRewardResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopPurchaseRewardResponse {
        CMsgClientToGCCandyShopPurchaseRewardResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopPurchaseRewardResponse {
        static instance: CMsgClientToGCCandyShopPurchaseRewardResponse = CMsgClientToGCCandyShopPurchaseRewardResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopPurchaseRewardResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopPurchaseRewardResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopPurchaseRewardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopPurchaseRewardResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopPurchaseRewardResponse`
pub mod cmsg_client_to_gccandy_shop_purchase_reward_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse.k_eInvalidReward)
        k_eInvalidReward = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse.k_eNotEnoughCandy)
        k_eNotEnoughCandy = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse.k_eExpiredShop)
        k_eExpiredShop = 8,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidReward),
                7 => ::std::option::Option::Some(EResponse::k_eNotEnoughCandy),
                8 => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                "k_eInvalidReward" => ::std::option::Option::Some(EResponse::k_eInvalidReward),
                "k_eNotEnoughCandy" => ::std::option::Option::Some(EResponse::k_eNotEnoughCandy),
                "k_eExpiredShop" => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidShop,
            EResponse::k_eInvalidReward,
            EResponse::k_eNotEnoughCandy,
            EResponse::k_eExpiredShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopPurchaseRewardResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopOpenBags)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopOpenBags {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopOpenBags.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopOpenBags.bag_count)
    pub bag_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopOpenBags.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopOpenBags {
    fn default() -> &'a CMsgClientToGCCandyShopOpenBags {
        <CMsgClientToGCCandyShopOpenBags as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopOpenBags {
    pub fn new() -> CMsgClientToGCCandyShopOpenBags {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 bag_count = 2;

    pub fn bag_count(&self) -> u32 {
        self.bag_count.unwrap_or(0)
    }

    pub fn clear_bag_count(&mut self) {
        self.bag_count = ::std::option::Option::None;
    }

    pub fn has_bag_count(&self) -> bool {
        self.bag_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bag_count(&mut self, v: u32) {
        self.bag_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopOpenBags| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopOpenBags| { &mut m.candy_shop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bag_count",
            |m: &CMsgClientToGCCandyShopOpenBags| { &m.bag_count },
            |m: &mut CMsgClientToGCCandyShopOpenBags| { &mut m.bag_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopOpenBags>(
            "CMsgClientToGCCandyShopOpenBags",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopOpenBags {
    const NAME: &'static str = "CMsgClientToGCCandyShopOpenBags";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bag_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bag_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bag_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopOpenBags {
        CMsgClientToGCCandyShopOpenBags::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.bag_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopOpenBags {
        static instance: CMsgClientToGCCandyShopOpenBags = CMsgClientToGCCandyShopOpenBags {
            candy_shop_id: ::std::option::Option::None,
            bag_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopOpenBags {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopOpenBags").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopOpenBags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopOpenBags {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopOpenBagsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopOpenBagsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopOpenBagsResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_open_bags_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopOpenBagsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopOpenBagsResponse {
    fn default() -> &'a CMsgClientToGCCandyShopOpenBagsResponse {
        <CMsgClientToGCCandyShopOpenBagsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopOpenBagsResponse {
    pub fn new() -> CMsgClientToGCCandyShopOpenBagsResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_open_bags_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_open_bags_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_open_bags_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_open_bags_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopOpenBagsResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopOpenBagsResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopOpenBagsResponse>(
            "CMsgClientToGCCandyShopOpenBagsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopOpenBagsResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopOpenBagsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopOpenBagsResponse {
        CMsgClientToGCCandyShopOpenBagsResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopOpenBagsResponse {
        static instance: CMsgClientToGCCandyShopOpenBagsResponse = CMsgClientToGCCandyShopOpenBagsResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopOpenBagsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopOpenBagsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopOpenBagsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopOpenBagsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopOpenBagsResponse`
pub mod cmsg_client_to_gccandy_shop_open_bags_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eInvalidItem)
        k_eInvalidItem = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eNotEnoughBags)
        k_eNotEnoughBags = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eNotEnoughSpace)
        k_eNotEnoughSpace = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponse.k_eExpiredShop)
        k_eExpiredShop = 9,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidItem),
                7 => ::std::option::Option::Some(EResponse::k_eNotEnoughBags),
                8 => ::std::option::Option::Some(EResponse::k_eNotEnoughSpace),
                9 => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                "k_eInvalidItem" => ::std::option::Option::Some(EResponse::k_eInvalidItem),
                "k_eNotEnoughBags" => ::std::option::Option::Some(EResponse::k_eNotEnoughBags),
                "k_eNotEnoughSpace" => ::std::option::Option::Some(EResponse::k_eNotEnoughSpace),
                "k_eExpiredShop" => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidShop,
            EResponse::k_eInvalidItem,
            EResponse::k_eNotEnoughBags,
            EResponse::k_eNotEnoughSpace,
            EResponse::k_eExpiredShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopOpenBagsResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopOpenBagsResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDoExchange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDoExchange {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDoExchange.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDoExchange.recipe_id)
    pub recipe_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDoExchange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDoExchange {
    fn default() -> &'a CMsgClientToGCCandyShopDoExchange {
        <CMsgClientToGCCandyShopDoExchange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDoExchange {
    pub fn new() -> CMsgClientToGCCandyShopDoExchange {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 recipe_id = 2;

    pub fn recipe_id(&self) -> u32 {
        self.recipe_id.unwrap_or(0)
    }

    pub fn clear_recipe_id(&mut self) {
        self.recipe_id = ::std::option::Option::None;
    }

    pub fn has_recipe_id(&self) -> bool {
        self.recipe_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipe_id(&mut self, v: u32) {
        self.recipe_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopDoExchange| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopDoExchange| { &mut m.candy_shop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipe_id",
            |m: &CMsgClientToGCCandyShopDoExchange| { &m.recipe_id },
            |m: &mut CMsgClientToGCCandyShopDoExchange| { &mut m.recipe_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDoExchange>(
            "CMsgClientToGCCandyShopDoExchange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDoExchange {
    const NAME: &'static str = "CMsgClientToGCCandyShopDoExchange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.recipe_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.recipe_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.recipe_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDoExchange {
        CMsgClientToGCCandyShopDoExchange::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.recipe_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDoExchange {
        static instance: CMsgClientToGCCandyShopDoExchange = CMsgClientToGCCandyShopDoExchange {
            candy_shop_id: ::std::option::Option::None,
            recipe_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDoExchange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDoExchange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDoExchange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDoExchange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDoExchangeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDoExchangeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDoExchangeResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_do_exchange_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDoExchangeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDoExchangeResponse {
    fn default() -> &'a CMsgClientToGCCandyShopDoExchangeResponse {
        <CMsgClientToGCCandyShopDoExchangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDoExchangeResponse {
    pub fn new() -> CMsgClientToGCCandyShopDoExchangeResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_do_exchange_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_do_exchange_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_do_exchange_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_do_exchange_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopDoExchangeResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopDoExchangeResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDoExchangeResponse>(
            "CMsgClientToGCCandyShopDoExchangeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDoExchangeResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopDoExchangeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDoExchangeResponse {
        CMsgClientToGCCandyShopDoExchangeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDoExchangeResponse {
        static instance: CMsgClientToGCCandyShopDoExchangeResponse = CMsgClientToGCCandyShopDoExchangeResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDoExchangeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDoExchangeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDoExchangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDoExchangeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopDoExchangeResponse`
pub mod cmsg_client_to_gccandy_shop_do_exchange_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eNotEnoughCandy)
        k_eNotEnoughCandy = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eInvalidRecipe)
        k_eInvalidRecipe = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eNotEnoughSpace)
        k_eNotEnoughSpace = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoExchangeResponse.EResponse.k_eExpiredShop)
        k_eExpiredShop = 9,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                6 => ::std::option::Option::Some(EResponse::k_eNotEnoughCandy),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidRecipe),
                8 => ::std::option::Option::Some(EResponse::k_eNotEnoughSpace),
                9 => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                "k_eNotEnoughCandy" => ::std::option::Option::Some(EResponse::k_eNotEnoughCandy),
                "k_eInvalidRecipe" => ::std::option::Option::Some(EResponse::k_eInvalidRecipe),
                "k_eNotEnoughSpace" => ::std::option::Option::Some(EResponse::k_eNotEnoughSpace),
                "k_eExpiredShop" => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidShop,
            EResponse::k_eNotEnoughCandy,
            EResponse::k_eInvalidRecipe,
            EResponse::k_eNotEnoughSpace,
            EResponse::k_eExpiredShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopDoExchangeResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopDoExchangeResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDoVariableExchange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDoVariableExchange {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDoVariableExchange.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDoVariableExchange.input)
    pub input: ::protobuf::MessageField<CMsgCandyShopCandyQuantity>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDoVariableExchange.output)
    pub output: ::protobuf::MessageField<CMsgCandyShopCandyQuantity>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDoVariableExchange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDoVariableExchange {
    fn default() -> &'a CMsgClientToGCCandyShopDoVariableExchange {
        <CMsgClientToGCCandyShopDoVariableExchange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDoVariableExchange {
    pub fn new() -> CMsgClientToGCCandyShopDoVariableExchange {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopDoVariableExchange| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopDoVariableExchange| { &mut m.candy_shop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopCandyQuantity>(
            "input",
            |m: &CMsgClientToGCCandyShopDoVariableExchange| { &m.input },
            |m: &mut CMsgClientToGCCandyShopDoVariableExchange| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopCandyQuantity>(
            "output",
            |m: &CMsgClientToGCCandyShopDoVariableExchange| { &m.output },
            |m: &mut CMsgClientToGCCandyShopDoVariableExchange| { &mut m.output },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDoVariableExchange>(
            "CMsgClientToGCCandyShopDoVariableExchange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDoVariableExchange {
    const NAME: &'static str = "CMsgClientToGCCandyShopDoVariableExchange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.output.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.output.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDoVariableExchange {
        CMsgClientToGCCandyShopDoVariableExchange::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.input.clear();
        self.output.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDoVariableExchange {
        static instance: CMsgClientToGCCandyShopDoVariableExchange = CMsgClientToGCCandyShopDoVariableExchange {
            candy_shop_id: ::std::option::Option::None,
            input: ::protobuf::MessageField::none(),
            output: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDoVariableExchange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDoVariableExchange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDoVariableExchange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDoVariableExchange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDoVariableExchangeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_do_variable_exchange_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDoVariableExchangeResponse {
    fn default() -> &'a CMsgClientToGCCandyShopDoVariableExchangeResponse {
        <CMsgClientToGCCandyShopDoVariableExchangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDoVariableExchangeResponse {
    pub fn new() -> CMsgClientToGCCandyShopDoVariableExchangeResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_do_variable_exchange_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_do_variable_exchange_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_do_variable_exchange_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_do_variable_exchange_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopDoVariableExchangeResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopDoVariableExchangeResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDoVariableExchangeResponse>(
            "CMsgClientToGCCandyShopDoVariableExchangeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDoVariableExchangeResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopDoVariableExchangeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDoVariableExchangeResponse {
        CMsgClientToGCCandyShopDoVariableExchangeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDoVariableExchangeResponse {
        static instance: CMsgClientToGCCandyShopDoVariableExchangeResponse = CMsgClientToGCCandyShopDoVariableExchangeResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDoVariableExchangeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDoVariableExchangeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDoVariableExchangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDoVariableExchangeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopDoVariableExchangeResponse`
pub mod cmsg_client_to_gccandy_shop_do_variable_exchange_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eNotEnoughCandy)
        k_eNotEnoughCandy = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eInvalidRecipe)
        k_eInvalidRecipe = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eNotEnoughSpace)
        k_eNotEnoughSpace = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse.k_eExpiredShop)
        k_eExpiredShop = 9,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                6 => ::std::option::Option::Some(EResponse::k_eNotEnoughCandy),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidRecipe),
                8 => ::std::option::Option::Some(EResponse::k_eNotEnoughSpace),
                9 => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                "k_eNotEnoughCandy" => ::std::option::Option::Some(EResponse::k_eNotEnoughCandy),
                "k_eInvalidRecipe" => ::std::option::Option::Some(EResponse::k_eInvalidRecipe),
                "k_eNotEnoughSpace" => ::std::option::Option::Some(EResponse::k_eNotEnoughSpace),
                "k_eExpiredShop" => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidShop,
            EResponse::k_eNotEnoughCandy,
            EResponse::k_eInvalidRecipe,
            EResponse::k_eNotEnoughSpace,
            EResponse::k_eExpiredShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopRerollRewards)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopRerollRewards {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopRerollRewards.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopRerollRewards.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopRerollRewards {
    fn default() -> &'a CMsgClientToGCCandyShopRerollRewards {
        <CMsgClientToGCCandyShopRerollRewards as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopRerollRewards {
    pub fn new() -> CMsgClientToGCCandyShopRerollRewards {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopRerollRewards| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopRerollRewards| { &mut m.candy_shop_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopRerollRewards>(
            "CMsgClientToGCCandyShopRerollRewards",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopRerollRewards {
    const NAME: &'static str = "CMsgClientToGCCandyShopRerollRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopRerollRewards {
        CMsgClientToGCCandyShopRerollRewards::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopRerollRewards {
        static instance: CMsgClientToGCCandyShopRerollRewards = CMsgClientToGCCandyShopRerollRewards {
            candy_shop_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopRerollRewards {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopRerollRewards").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopRerollRewards {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopRerollRewards {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopRerollRewardsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopRerollRewardsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopRerollRewardsResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_reroll_rewards_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopRerollRewardsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopRerollRewardsResponse {
    fn default() -> &'a CMsgClientToGCCandyShopRerollRewardsResponse {
        <CMsgClientToGCCandyShopRerollRewardsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopRerollRewardsResponse {
    pub fn new() -> CMsgClientToGCCandyShopRerollRewardsResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_reroll_rewards_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_reroll_rewards_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_reroll_rewards_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_reroll_rewards_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopRerollRewardsResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopRerollRewardsResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopRerollRewardsResponse>(
            "CMsgClientToGCCandyShopRerollRewardsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopRerollRewardsResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopRerollRewardsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopRerollRewardsResponse {
        CMsgClientToGCCandyShopRerollRewardsResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopRerollRewardsResponse {
        static instance: CMsgClientToGCCandyShopRerollRewardsResponse = CMsgClientToGCCandyShopRerollRewardsResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopRerollRewardsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopRerollRewardsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopRerollRewardsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopRerollRewardsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopRerollRewardsResponse`
pub mod cmsg_client_to_gccandy_shop_reroll_rewards_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse.k_eNoRerollCharges)
        k_eNoRerollCharges = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponse.k_eExpiredShop)
        k_eExpiredShop = 7,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                6 => ::std::option::Option::Some(EResponse::k_eNoRerollCharges),
                7 => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                "k_eNoRerollCharges" => ::std::option::Option::Some(EResponse::k_eNoRerollCharges),
                "k_eExpiredShop" => ::std::option::Option::Some(EResponse::k_eExpiredShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidShop,
            EResponse::k_eNoRerollCharges,
            EResponse::k_eExpiredShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopRerollRewardsResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopRerollRewardsResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevGrantCandy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevGrantCandy {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevGrantCandy.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevGrantCandy.candy_quantity)
    pub candy_quantity: ::protobuf::MessageField<CMsgCandyShopCandyQuantity>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevGrantCandy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevGrantCandy {
    fn default() -> &'a CMsgClientToGCCandyShopDevGrantCandy {
        <CMsgClientToGCCandyShopDevGrantCandy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevGrantCandy {
    pub fn new() -> CMsgClientToGCCandyShopDevGrantCandy {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopDevGrantCandy| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopDevGrantCandy| { &mut m.candy_shop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgCandyShopCandyQuantity>(
            "candy_quantity",
            |m: &CMsgClientToGCCandyShopDevGrantCandy| { &m.candy_quantity },
            |m: &mut CMsgClientToGCCandyShopDevGrantCandy| { &mut m.candy_quantity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevGrantCandy>(
            "CMsgClientToGCCandyShopDevGrantCandy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevGrantCandy {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevGrantCandy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.candy_quantity)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.candy_quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.candy_quantity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevGrantCandy {
        CMsgClientToGCCandyShopDevGrantCandy::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.candy_quantity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevGrantCandy {
        static instance: CMsgClientToGCCandyShopDevGrantCandy = CMsgClientToGCCandyShopDevGrantCandy {
            candy_shop_id: ::std::option::Option::None,
            candy_quantity: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevGrantCandy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevGrantCandy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevGrantCandy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevGrantCandy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevGrantCandyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevGrantCandyResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_dev_grant_candy_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevGrantCandyResponse {
    fn default() -> &'a CMsgClientToGCCandyShopDevGrantCandyResponse {
        <CMsgClientToGCCandyShopDevGrantCandyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevGrantCandyResponse {
    pub fn new() -> CMsgClientToGCCandyShopDevGrantCandyResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_dev_grant_candy_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_dev_grant_candy_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_dev_grant_candy_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_dev_grant_candy_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopDevGrantCandyResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopDevGrantCandyResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevGrantCandyResponse>(
            "CMsgClientToGCCandyShopDevGrantCandyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevGrantCandyResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevGrantCandyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevGrantCandyResponse {
        CMsgClientToGCCandyShopDevGrantCandyResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevGrantCandyResponse {
        static instance: CMsgClientToGCCandyShopDevGrantCandyResponse = CMsgClientToGCCandyShopDevGrantCandyResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevGrantCandyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevGrantCandyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevGrantCandyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevGrantCandyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopDevGrantCandyResponse`
pub mod cmsg_client_to_gccandy_shop_dev_grant_candy_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse.k_eNotEnoughSpace)
        k_eNotEnoughSpace = 7,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                7 => ::std::option::Option::Some(EResponse::k_eNotEnoughSpace),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                "k_eNotEnoughSpace" => ::std::option::Option::Some(EResponse::k_eNotEnoughSpace),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidShop,
            EResponse::k_eNotEnoughSpace,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopDevGrantCandyResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevClearInventory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevClearInventory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevClearInventory.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevClearInventory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevClearInventory {
    fn default() -> &'a CMsgClientToGCCandyShopDevClearInventory {
        <CMsgClientToGCCandyShopDevClearInventory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevClearInventory {
    pub fn new() -> CMsgClientToGCCandyShopDevClearInventory {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopDevClearInventory| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopDevClearInventory| { &mut m.candy_shop_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevClearInventory>(
            "CMsgClientToGCCandyShopDevClearInventory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevClearInventory {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevClearInventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevClearInventory {
        CMsgClientToGCCandyShopDevClearInventory::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevClearInventory {
        static instance: CMsgClientToGCCandyShopDevClearInventory = CMsgClientToGCCandyShopDevClearInventory {
            candy_shop_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevClearInventory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevClearInventory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevClearInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevClearInventory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevClearInventoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevClearInventoryResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_dev_clear_inventory_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevClearInventoryResponse {
    fn default() -> &'a CMsgClientToGCCandyShopDevClearInventoryResponse {
        <CMsgClientToGCCandyShopDevClearInventoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevClearInventoryResponse {
    pub fn new() -> CMsgClientToGCCandyShopDevClearInventoryResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_dev_clear_inventory_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_dev_clear_inventory_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_dev_clear_inventory_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_dev_clear_inventory_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopDevClearInventoryResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopDevClearInventoryResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevClearInventoryResponse>(
            "CMsgClientToGCCandyShopDevClearInventoryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevClearInventoryResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevClearInventoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevClearInventoryResponse {
        CMsgClientToGCCandyShopDevClearInventoryResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevClearInventoryResponse {
        static instance: CMsgClientToGCCandyShopDevClearInventoryResponse = CMsgClientToGCCandyShopDevClearInventoryResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevClearInventoryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevClearInventoryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevClearInventoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevClearInventoryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopDevClearInventoryResponse`
pub mod cmsg_client_to_gccandy_shop_dev_clear_inventory_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopDevClearInventoryResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevGrantCandyBags)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevGrantCandyBags {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevGrantCandyBags.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevGrantCandyBags.quantity)
    pub quantity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevGrantCandyBags.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevGrantCandyBags {
    fn default() -> &'a CMsgClientToGCCandyShopDevGrantCandyBags {
        <CMsgClientToGCCandyShopDevGrantCandyBags as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevGrantCandyBags {
    pub fn new() -> CMsgClientToGCCandyShopDevGrantCandyBags {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopDevGrantCandyBags| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopDevGrantCandyBags| { &mut m.candy_shop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CMsgClientToGCCandyShopDevGrantCandyBags| { &m.quantity },
            |m: &mut CMsgClientToGCCandyShopDevGrantCandyBags| { &mut m.quantity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevGrantCandyBags>(
            "CMsgClientToGCCandyShopDevGrantCandyBags",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevGrantCandyBags {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevGrantCandyBags";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevGrantCandyBags {
        CMsgClientToGCCandyShopDevGrantCandyBags::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevGrantCandyBags {
        static instance: CMsgClientToGCCandyShopDevGrantCandyBags = CMsgClientToGCCandyShopDevGrantCandyBags {
            candy_shop_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevGrantCandyBags {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevGrantCandyBags").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevGrantCandyBags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevGrantCandyBags {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_dev_grant_candy_bags_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
    fn default() -> &'a CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
        <CMsgClientToGCCandyShopDevGrantCandyBagsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
    pub fn new() -> CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_dev_grant_candy_bags_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_dev_grant_candy_bags_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_dev_grant_candy_bags_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_dev_grant_candy_bags_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopDevGrantCandyBagsResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopDevGrantCandyBagsResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevGrantCandyBagsResponse>(
            "CMsgClientToGCCandyShopDevGrantCandyBagsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevGrantCandyBagsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
        CMsgClientToGCCandyShopDevGrantCandyBagsResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
        static instance: CMsgClientToGCCandyShopDevGrantCandyBagsResponse = CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevGrantCandyBagsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevGrantCandyBagsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopDevGrantCandyBagsResponse`
pub mod cmsg_client_to_gccandy_shop_dev_grant_candy_bags_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopDevGrantCandyBagsResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevShuffleExchange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevShuffleExchange {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevShuffleExchange.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevShuffleExchange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevShuffleExchange {
    fn default() -> &'a CMsgClientToGCCandyShopDevShuffleExchange {
        <CMsgClientToGCCandyShopDevShuffleExchange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevShuffleExchange {
    pub fn new() -> CMsgClientToGCCandyShopDevShuffleExchange {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopDevShuffleExchange| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopDevShuffleExchange| { &mut m.candy_shop_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevShuffleExchange>(
            "CMsgClientToGCCandyShopDevShuffleExchange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevShuffleExchange {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevShuffleExchange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevShuffleExchange {
        CMsgClientToGCCandyShopDevShuffleExchange::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevShuffleExchange {
        static instance: CMsgClientToGCCandyShopDevShuffleExchange = CMsgClientToGCCandyShopDevShuffleExchange {
            candy_shop_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevShuffleExchange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevShuffleExchange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevShuffleExchange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevShuffleExchange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevShuffleExchangeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_dev_shuffle_exchange_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevShuffleExchangeResponse {
    fn default() -> &'a CMsgClientToGCCandyShopDevShuffleExchangeResponse {
        <CMsgClientToGCCandyShopDevShuffleExchangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevShuffleExchangeResponse {
    pub fn new() -> CMsgClientToGCCandyShopDevShuffleExchangeResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_dev_shuffle_exchange_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_dev_shuffle_exchange_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_dev_shuffle_exchange_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_dev_shuffle_exchange_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopDevShuffleExchangeResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopDevShuffleExchangeResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevShuffleExchangeResponse>(
            "CMsgClientToGCCandyShopDevShuffleExchangeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevShuffleExchangeResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevShuffleExchangeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevShuffleExchangeResponse {
        CMsgClientToGCCandyShopDevShuffleExchangeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevShuffleExchangeResponse {
        static instance: CMsgClientToGCCandyShopDevShuffleExchangeResponse = CMsgClientToGCCandyShopDevShuffleExchangeResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevShuffleExchangeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevShuffleExchangeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevShuffleExchangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevShuffleExchangeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopDevShuffleExchangeResponse`
pub mod cmsg_client_to_gccandy_shop_dev_shuffle_exchange_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopDevShuffleExchangeResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevGrantRerollCharges)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevGrantRerollCharges {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevGrantRerollCharges.candy_shop_id)
    pub candy_shop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevGrantRerollCharges.reroll_charges)
    pub reroll_charges: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevGrantRerollCharges.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevGrantRerollCharges {
    fn default() -> &'a CMsgClientToGCCandyShopDevGrantRerollCharges {
        <CMsgClientToGCCandyShopDevGrantRerollCharges as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevGrantRerollCharges {
    pub fn new() -> CMsgClientToGCCandyShopDevGrantRerollCharges {
        ::std::default::Default::default()
    }

    // optional uint32 candy_shop_id = 1;

    pub fn candy_shop_id(&self) -> u32 {
        self.candy_shop_id.unwrap_or(0)
    }

    pub fn clear_candy_shop_id(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
    }

    pub fn has_candy_shop_id(&self) -> bool {
        self.candy_shop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candy_shop_id(&mut self, v: u32) {
        self.candy_shop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reroll_charges = 2;

    pub fn reroll_charges(&self) -> u32 {
        self.reroll_charges.unwrap_or(0)
    }

    pub fn clear_reroll_charges(&mut self) {
        self.reroll_charges = ::std::option::Option::None;
    }

    pub fn has_reroll_charges(&self) -> bool {
        self.reroll_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reroll_charges(&mut self, v: u32) {
        self.reroll_charges = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candy_shop_id",
            |m: &CMsgClientToGCCandyShopDevGrantRerollCharges| { &m.candy_shop_id },
            |m: &mut CMsgClientToGCCandyShopDevGrantRerollCharges| { &mut m.candy_shop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reroll_charges",
            |m: &CMsgClientToGCCandyShopDevGrantRerollCharges| { &m.reroll_charges },
            |m: &mut CMsgClientToGCCandyShopDevGrantRerollCharges| { &mut m.reroll_charges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevGrantRerollCharges>(
            "CMsgClientToGCCandyShopDevGrantRerollCharges",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevGrantRerollCharges {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevGrantRerollCharges";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candy_shop_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reroll_charges = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candy_shop_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reroll_charges {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candy_shop_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reroll_charges {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevGrantRerollCharges {
        CMsgClientToGCCandyShopDevGrantRerollCharges::new()
    }

    fn clear(&mut self) {
        self.candy_shop_id = ::std::option::Option::None;
        self.reroll_charges = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevGrantRerollCharges {
        static instance: CMsgClientToGCCandyShopDevGrantRerollCharges = CMsgClientToGCCandyShopDevGrantRerollCharges {
            candy_shop_id: ::std::option::Option::None,
            reroll_charges: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevGrantRerollCharges {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevGrantRerollCharges").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevGrantRerollCharges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevGrantRerollCharges {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gccandy_shop_dev_grant_reroll_charges_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
    fn default() -> &'a CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
        <CMsgClientToGCCandyShopDevGrantRerollChargesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
    pub fn new() -> CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccandy_shop_dev_grant_reroll_charges_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccandy_shop_dev_grant_reroll_charges_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccandy_shop_dev_grant_reroll_charges_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccandy_shop_dev_grant_reroll_charges_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCCandyShopDevGrantRerollChargesResponse| { &m.response },
            |m: &mut CMsgClientToGCCandyShopDevGrantRerollChargesResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCCandyShopDevGrantRerollChargesResponse>(
            "CMsgClientToGCCandyShopDevGrantRerollChargesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
    const NAME: &'static str = "CMsgClientToGCCandyShopDevGrantRerollChargesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
        CMsgClientToGCCandyShopDevGrantRerollChargesResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
        static instance: CMsgClientToGCCandyShopDevGrantRerollChargesResponse = CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCCandyShopDevGrantRerollChargesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCandyShopDevGrantRerollChargesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCCandyShopDevGrantRerollChargesResponse`
pub mod cmsg_client_to_gccandy_shop_dev_grant_reroll_charges_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse.k_eInvalidShop)
        k_eInvalidShop = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidShop" => ::std::option::Option::Some(EResponse::k_eInvalidShop),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidShop,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCCandyShopDevGrantRerollChargesResponse.EResponse")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ECandyShopAuditAction)
pub enum ECandyShopAuditAction {
    // @@protoc_insertion_point(enum_value:dota.ECandyShopAuditAction.k_ECandyShopAuditAction_Invalid)
    k_ECandyShopAuditAction_Invalid = 0,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopAuditAction.k_ECandyShopAuditAction_SupportModify)
    k_ECandyShopAuditAction_SupportModify = 1,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopAuditAction.k_ECandyShopAuditAction_PurchaseReward)
    k_ECandyShopAuditAction_PurchaseReward = 2,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopAuditAction.k_ECandyShopAuditAction_OpenBags)
    k_ECandyShopAuditAction_OpenBags = 3,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopAuditAction.k_ECandyShopAuditAction_RerollRewards)
    k_ECandyShopAuditAction_RerollRewards = 4,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopAuditAction.k_ECandyShopAuditAction_DoVariableExchange)
    k_ECandyShopAuditAction_DoVariableExchange = 5,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopAuditAction.k_ECandyShopAuditAction_DoExchange)
    k_ECandyShopAuditAction_DoExchange = 6,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopAuditAction.k_ECandyShopAuditAction_EventActionGrantInventorySizeIncrease)
    k_ECandyShopAuditAction_EventActionGrantInventorySizeIncrease = 7,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopAuditAction.k_ECandyShopAuditAction_EventActionGrantRerollChargesIncrease)
    k_ECandyShopAuditAction_EventActionGrantRerollChargesIncrease = 8,
}

impl ::protobuf::Enum for ECandyShopAuditAction {
    const NAME: &'static str = "ECandyShopAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECandyShopAuditAction> {
        match value {
            0 => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_Invalid),
            1 => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_SupportModify),
            2 => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_PurchaseReward),
            3 => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_OpenBags),
            4 => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_RerollRewards),
            5 => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_DoVariableExchange),
            6 => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_DoExchange),
            7 => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_EventActionGrantInventorySizeIncrease),
            8 => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_EventActionGrantRerollChargesIncrease),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECandyShopAuditAction> {
        match str {
            "k_ECandyShopAuditAction_Invalid" => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_Invalid),
            "k_ECandyShopAuditAction_SupportModify" => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_SupportModify),
            "k_ECandyShopAuditAction_PurchaseReward" => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_PurchaseReward),
            "k_ECandyShopAuditAction_OpenBags" => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_OpenBags),
            "k_ECandyShopAuditAction_RerollRewards" => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_RerollRewards),
            "k_ECandyShopAuditAction_DoVariableExchange" => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_DoVariableExchange),
            "k_ECandyShopAuditAction_DoExchange" => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_DoExchange),
            "k_ECandyShopAuditAction_EventActionGrantInventorySizeIncrease" => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_EventActionGrantInventorySizeIncrease),
            "k_ECandyShopAuditAction_EventActionGrantRerollChargesIncrease" => ::std::option::Option::Some(ECandyShopAuditAction::k_ECandyShopAuditAction_EventActionGrantRerollChargesIncrease),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECandyShopAuditAction] = &[
        ECandyShopAuditAction::k_ECandyShopAuditAction_Invalid,
        ECandyShopAuditAction::k_ECandyShopAuditAction_SupportModify,
        ECandyShopAuditAction::k_ECandyShopAuditAction_PurchaseReward,
        ECandyShopAuditAction::k_ECandyShopAuditAction_OpenBags,
        ECandyShopAuditAction::k_ECandyShopAuditAction_RerollRewards,
        ECandyShopAuditAction::k_ECandyShopAuditAction_DoVariableExchange,
        ECandyShopAuditAction::k_ECandyShopAuditAction_DoExchange,
        ECandyShopAuditAction::k_ECandyShopAuditAction_EventActionGrantInventorySizeIncrease,
        ECandyShopAuditAction::k_ECandyShopAuditAction_EventActionGrantRerollChargesIncrease,
    ];
}

impl ::protobuf::EnumFull for ECandyShopAuditAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECandyShopAuditAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECandyShopAuditAction {
    fn default() -> Self {
        ECandyShopAuditAction::k_ECandyShopAuditAction_Invalid
    }
}

impl ECandyShopAuditAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECandyShopAuditAction>("ECandyShopAuditAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ECandyShopRewardType)
pub enum ECandyShopRewardType {
    // @@protoc_insertion_point(enum_value:dota.ECandyShopRewardType.k_eCandyShopRewardType_None)
    k_eCandyShopRewardType_None = 0,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopRewardType.k_eCandyShopRewardType_Item)
    k_eCandyShopRewardType_Item = 1,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopRewardType.k_eCandyShopRewardType_EventAction)
    k_eCandyShopRewardType_EventAction = 2,
    // @@protoc_insertion_point(enum_value:dota.ECandyShopRewardType.k_eCandyShopRewardType_EventPoints)
    k_eCandyShopRewardType_EventPoints = 3,
}

impl ::protobuf::Enum for ECandyShopRewardType {
    const NAME: &'static str = "ECandyShopRewardType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECandyShopRewardType> {
        match value {
            0 => ::std::option::Option::Some(ECandyShopRewardType::k_eCandyShopRewardType_None),
            1 => ::std::option::Option::Some(ECandyShopRewardType::k_eCandyShopRewardType_Item),
            2 => ::std::option::Option::Some(ECandyShopRewardType::k_eCandyShopRewardType_EventAction),
            3 => ::std::option::Option::Some(ECandyShopRewardType::k_eCandyShopRewardType_EventPoints),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECandyShopRewardType> {
        match str {
            "k_eCandyShopRewardType_None" => ::std::option::Option::Some(ECandyShopRewardType::k_eCandyShopRewardType_None),
            "k_eCandyShopRewardType_Item" => ::std::option::Option::Some(ECandyShopRewardType::k_eCandyShopRewardType_Item),
            "k_eCandyShopRewardType_EventAction" => ::std::option::Option::Some(ECandyShopRewardType::k_eCandyShopRewardType_EventAction),
            "k_eCandyShopRewardType_EventPoints" => ::std::option::Option::Some(ECandyShopRewardType::k_eCandyShopRewardType_EventPoints),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECandyShopRewardType] = &[
        ECandyShopRewardType::k_eCandyShopRewardType_None,
        ECandyShopRewardType::k_eCandyShopRewardType_Item,
        ECandyShopRewardType::k_eCandyShopRewardType_EventAction,
        ECandyShopRewardType::k_eCandyShopRewardType_EventPoints,
    ];
}

impl ::protobuf::EnumFull for ECandyShopRewardType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECandyShopRewardType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECandyShopRewardType {
    fn default() -> Self {
        ECandyShopRewardType::k_eCandyShopRewardType_None
    }
}

impl ECandyShopRewardType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECandyShopRewardType>("ECandyShopRewardType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'dota_gcmessages_client_candy_shop.proto\x12\x04dota\x1a\x13steammessa\
    ges.proto\x1a\x17dota_shared_enums.proto\x1a\x1cdota_gcmessages_common.p\
    roto\x1a\x1cdota_gcmessages_webapi.proto\x1a\x16gcsdk_gcmessages.proto\
    \x1a\x15base_gcmessages.proto\x1a\x15econ_gcmessages.proto\x1a\x1cdota_g\
    cmessages_client.proto\x1a\x15valveextensions.proto\"Y\n\x17CMsgCandySho\
    pCandyCount\x12\x1d\n\ncandy_type\x18\x01\x20\x01(\rR\tcandyType\x12\x1f\
    \n\x0bcandy_count\x18\x02\x20\x01(\rR\ncandyCount\"^\n\x1aCMsgCandyShopC\
    andyQuantity\x12@\n\x0ccandy_counts\x18\x01\x20\x03(\x0b2\x1d.dota.CMsgC\
    andyShopCandyCountR\x0bcandyCounts\"\xac\x01\n\x1bCMsgCandyShopExchangeR\
    ecipe\x12\x1b\n\trecipe_id\x18\x01\x20\x01(\rR\x08recipeId\x126\n\x05inp\
    ut\x18\x02\x20\x01(\x0b2\x20.dota.CMsgCandyShopCandyQuantityR\x05input\
    \x128\n\x06output\x18\x03\x20\x01(\x0b2\x20.dota.CMsgCandyShopCandyQuant\
    ityR\x06output\"9\n\x1cCMsgCandyShopRewardData_Item\x12\x19\n\x08item_de\
    f\x18\x01\x20\x01(\rR\x07itemDef\"\x87\x01\n#CMsgCandyShopRewardData_Eve\
    ntAction\x12'\n\x08event_id\x18\x01\x20\x01(\x0e2\x0c.dota.EEventR\x07ev\
    entId\x12\x1b\n\taction_id\x18\x02\x20\x01(\rR\x08actionId\x12\x1a\n\x08\
    quantity\x18\x03\x20\x01(\rR\x08quantity\"f\n#CMsgCandyShopRewardData_Ev\
    entPoints\x12'\n\x08event_id\x18\x01\x20\x01(\x0e2\x0c.dota.EEventR\x07e\
    ventId\x12\x16\n\x06points\x18\x02\x20\x01(\rR\x06points\"\xc0\x03\n\x13\
    CMsgCandyShopReward\x12\x1b\n\treward_id\x18\x01\x20\x01(\rR\x08rewardId\
    \x12(\n\x10reward_option_id\x18\x02\x20\x01(\rR\x0erewardOptionId\x126\n\
    \x05price\x18\x03\x20\x01(\x0b2\x20.dota.CMsgCandyShopCandyQuantityR\x05\
    price\x12;\n\x0breward_type\x18\x04\x20\x01(\x0e2\x1a.dota.ECandyShopRew\
    ardTypeR\nrewardType\x12?\n\titem_data\x18\x05\x20\x01(\x0b2\".dota.CMsg\
    CandyShopRewardData_ItemR\x08itemData\x12U\n\x11event_action_data\x18\
    \x06\x20\x01(\x0b2).dota.CMsgCandyShopRewardData_EventActionR\x0feventAc\
    tionData\x12U\n\x11event_points_data\x18\x07\x20\x01(\x0b2).dota.CMsgCan\
    dyShopRewardData_EventPointsR\x0feventPointsData\"\xef\x02\n\x15CMsgCand\
    yShopUserData\x12%\n\x0einventory_size\x18\x01\x20\x01(\rR\rinventorySiz\
    e\x12>\n\tinventory\x18\x02\x20\x01(\x0b2\x20.dota.CMsgCandyShopCandyQua\
    ntityR\tinventory\x128\n\x18exchange_reset_timestamp\x18\x03\x20\x01(\
    \x07R\x16exchangeResetTimestamp\x12L\n\x10exchange_recipes\x18\x04\x20\
    \x03(\x0b2!.dota.CMsgCandyShopExchangeRecipeR\x0fexchangeRecipes\x12@\n\
    \x0eactive_rewards\x18\x05\x20\x03(\x0b2\x19.dota.CMsgCandyShopRewardR\r\
    activeRewards\x12%\n\x0ereroll_charges\x18\x06\x20\x01(\rR\rrerollCharge\
    s\"H\n\"CMsgClientToGCCandyShopGetUserData\x12\"\n\rcandy_shop_id\x18\
    \x01\x20\x01(\rR\x0bcandyShopId\"\xcb\x02\n*CMsgClientToGCCandyShopGetUs\
    erDataResponse\x12V\n\x08response\x18\x01\x20\x01(\x0e2:.dota.CMsgClient\
    ToGCCandyShopGetUserDataResponse.EResponseR\x08response\x128\n\tuser_dat\
    a\x18\x02\x20\x01(\x0b2\x1b.dota.CMsgCandyShopUserDataR\x08userData\"\
    \x8a\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_e\
    Success\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\
    \x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x12\n\x0ek_eInvalidShop\x10\
    \x05\x12\x12\n\x0ek_eExpiredShop\x10\x06\"\x86\x01\n&CMsgGCToClientCandy\
    ShopUserDataUpdated\x12\"\n\rcandy_shop_id\x18\x01\x20\x01(\rR\x0bcandyS\
    hopId\x128\n\tuser_data\x18\x02\x20\x01(\x0b2\x1b.dota.CMsgCandyShopUser\
    DataR\x08userData\"h\n%CMsgClientToGCCandyShopPurchaseReward\x12\"\n\rca\
    ndy_shop_id\x18\x01\x20\x01(\rR\x0bcandyShopId\x12\x1b\n\treward_id\x18\
    \x02\x20\x01(\x04R\x08rewardId\"\xc4\x02\n-CMsgClientToGCCandyShopPurcha\
    seRewardResponse\x12Y\n\x08response\x18\x01\x20\x01(\x0e2=.dota.CMsgClie\
    ntToGCCandyShopPurchaseRewardResponse.EResponseR\x08response\"\xb7\x01\n\
    \tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\
    \x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\
    \x12\x0e\n\nk_eTimeout\x10\x04\x12\x12\n\x0ek_eInvalidShop\x10\x05\x12\
    \x14\n\x10k_eInvalidReward\x10\x06\x12\x15\n\x11k_eNotEnoughCandy\x10\
    \x07\x12\x12\n\x0ek_eExpiredShop\x10\x08\"b\n\x1fCMsgClientToGCCandyShop\
    OpenBags\x12\"\n\rcandy_shop_id\x18\x01\x20\x01(\rR\x0bcandyShopId\x12\
    \x1b\n\tbag_count\x18\x02\x20\x01(\rR\x08bagCount\"\xcc\x02\n'CMsgClient\
    ToGCCandyShopOpenBagsResponse\x12S\n\x08response\x18\x01\x20\x01(\x0e27.\
    dota.CMsgClientToGCCandyShopOpenBagsResponse.EResponseR\x08response\"\
    \xcb\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_e\
    Success\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\
    \x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x12\n\x0ek_eInvalidShop\x10\
    \x05\x12\x12\n\x0ek_eInvalidItem\x10\x06\x12\x14\n\x10k_eNotEnoughBags\
    \x10\x07\x12\x15\n\x11k_eNotEnoughSpace\x10\x08\x12\x12\n\x0ek_eExpiredS\
    hop\x10\t\"d\n!CMsgClientToGCCandyShopDoExchange\x12\"\n\rcandy_shop_id\
    \x18\x01\x20\x01(\rR\x0bcandyShopId\x12\x1b\n\trecipe_id\x18\x02\x20\x01\
    (\rR\x08recipeId\"\xd3\x02\n)CMsgClientToGCCandyShopDoExchangeResponse\
    \x12U\n\x08response\x18\x01\x20\x01(\x0e29.dota.CMsgClientToGCCandyShopD\
    oExchangeResponse.EResponseR\x08response\"\xce\x01\n\tEResponse\x12\x14\
    \n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_\
    eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\
    \x10\x04\x12\x12\n\x0ek_eInvalidShop\x10\x05\x12\x15\n\x11k_eNotEnoughCa\
    ndy\x10\x06\x12\x14\n\x10k_eInvalidRecipe\x10\x07\x12\x15\n\x11k_eNotEno\
    ughSpace\x10\x08\x12\x12\n\x0ek_eExpiredShop\x10\t\"\xc1\x01\n)CMsgClien\
    tToGCCandyShopDoVariableExchange\x12\"\n\rcandy_shop_id\x18\x01\x20\x01(\
    \rR\x0bcandyShopId\x126\n\x05input\x18\x02\x20\x01(\x0b2\x20.dota.CMsgCa\
    ndyShopCandyQuantityR\x05input\x128\n\x06output\x18\x03\x20\x01(\x0b2\
    \x20.dota.CMsgCandyShopCandyQuantityR\x06output\"\xe3\x02\n1CMsgClientTo\
    GCCandyShopDoVariableExchangeResponse\x12]\n\x08response\x18\x01\x20\x01\
    (\x0e2A.dota.CMsgClientToGCCandyShopDoVariableExchangeResponse.EResponse\
    R\x08response\"\xce\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\
    \x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\
    \x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x12\n\x0ek_eIn\
    validShop\x10\x05\x12\x15\n\x11k_eNotEnoughCandy\x10\x06\x12\x14\n\x10k_\
    eInvalidRecipe\x10\x07\x12\x15\n\x11k_eNotEnoughSpace\x10\x08\x12\x12\n\
    \x0ek_eExpiredShop\x10\t\"J\n$CMsgClientToGCCandyShopRerollRewards\x12\"\
    \n\rcandy_shop_id\x18\x01\x20\x01(\rR\x0bcandyShopId\"\xad\x02\n,CMsgCli\
    entToGCCandyShopRerollRewardsResponse\x12X\n\x08response\x18\x01\x20\x01\
    (\x0e2<.dota.CMsgClientToGCCandyShopRerollRewardsResponse.EResponseR\x08\
    response\"\xa2\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\
    \x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_\
    eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x12\n\x0ek_eInvalidS\
    hop\x10\x05\x12\x16\n\x12k_eNoRerollCharges\x10\x06\x12\x12\n\x0ek_eExpi\
    redShop\x10\x07\"\x93\x01\n$CMsgClientToGCCandyShopDevGrantCandy\x12\"\n\
    \rcandy_shop_id\x18\x01\x20\x01(\rR\x0bcandyShopId\x12G\n\x0ecandy_quant\
    ity\x18\x02\x20\x01(\x0b2\x20.dota.CMsgCandyShopCandyQuantityR\rcandyQua\
    ntity\"\xab\x02\n,CMsgClientToGCCandyShopDevGrantCandyResponse\x12X\n\
    \x08response\x18\x01\x20\x01(\x0e2<.dota.CMsgClientToGCCandyShopDevGrant\
    CandyResponse.EResponseR\x08response\"\xa0\x01\n\tEResponse\x12\x14\n\
    \x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eT\
    ooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\
    \x10\x04\x12\x11\n\rk_eNotAllowed\x10\x05\x12\x12\n\x0ek_eInvalidShop\
    \x10\x06\x12\x15\n\x11k_eNotEnoughSpace\x10\x07\"N\n(CMsgClientToGCCandy\
    ShopDevClearInventory\x12\"\n\rcandy_shop_id\x18\x01\x20\x01(\rR\x0bcand\
    yShopId\"\x9c\x02\n0CMsgClientToGCCandyShopDevClearInventoryResponse\x12\
    \\\n\x08response\x18\x01\x20\x01(\x0e2@.dota.CMsgClientToGCCandyShopDevC\
    learInventoryResponse.EResponseR\x08response\"\x89\x01\n\tEResponse\x12\
    \x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\
    \nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTime\
    out\x10\x04\x12\x11\n\rk_eNotAllowed\x10\x05\x12\x12\n\x0ek_eInvalidShop\
    \x10\x06\"j\n(CMsgClientToGCCandyShopDevGrantCandyBags\x12\"\n\rcandy_sh\
    op_id\x18\x01\x20\x01(\rR\x0bcandyShopId\x12\x1a\n\x08quantity\x18\x02\
    \x20\x01(\rR\x08quantity\"\x9c\x02\n0CMsgClientToGCCandyShopDevGrantCand\
    yBagsResponse\x12\\\n\x08response\x18\x01\x20\x01(\x0e2@.dota.CMsgClient\
    ToGCCandyShopDevGrantCandyBagsResponse.EResponseR\x08response\"\x89\x01\
    \n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\
    \x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\
    \x12\x0e\n\nk_eTimeout\x10\x04\x12\x11\n\rk_eNotAllowed\x10\x05\x12\x12\
    \n\x0ek_eInvalidShop\x10\x06\"O\n)CMsgClientToGCCandyShopDevShuffleExcha\
    nge\x12\"\n\rcandy_shop_id\x18\x01\x20\x01(\rR\x0bcandyShopId\"\x9e\x02\
    \n1CMsgClientToGCCandyShopDevShuffleExchangeResponse\x12]\n\x08response\
    \x18\x01\x20\x01(\x0e2A.dota.CMsgClientToGCCandyShopDevShuffleExchangeRe\
    sponse.EResponseR\x08response\"\x89\x01\n\tEResponse\x12\x14\n\x10k_eInt\
    ernalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\
    \x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\
    \x11\n\rk_eNotAllowed\x10\x05\x12\x12\n\x0ek_eInvalidShop\x10\x06\"y\n,C\
    MsgClientToGCCandyShopDevGrantRerollCharges\x12\"\n\rcandy_shop_id\x18\
    \x01\x20\x01(\rR\x0bcandyShopId\x12%\n\x0ereroll_charges\x18\x02\x20\x01\
    (\rR\rrerollCharges\"\xa4\x02\n4CMsgClientToGCCandyShopDevGrantRerollCha\
    rgesResponse\x12`\n\x08response\x18\x01\x20\x01(\x0e2D.dota.CMsgClientTo\
    GCCandyShopDevGrantRerollChargesResponse.EResponseR\x08response\"\x89\
    \x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSucc\
    ess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\
    \x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x11\n\rk_eNotAllowed\x10\x05\x12\
    \x12\n\x0ek_eInvalidShop\x10\x06*\xc2\x03\n\x15ECandyShopAuditAction\x12\
    #\n\x1fk_ECandyShopAuditAction_Invalid\x10\0\x12)\n%k_ECandyShopAuditAct\
    ion_SupportModify\x10\x01\x12*\n&k_ECandyShopAuditAction_PurchaseReward\
    \x10\x02\x12$\n\x20k_ECandyShopAuditAction_OpenBags\x10\x03\x12)\n%k_ECa\
    ndyShopAuditAction_RerollRewards\x10\x04\x12.\n*k_ECandyShopAuditAction_\
    DoVariableExchange\x10\x05\x12&\n\"k_ECandyShopAuditAction_DoExchange\
    \x10\x06\x12A\n=k_ECandyShopAuditAction_EventActionGrantInventorySizeInc\
    rease\x10\x07\x12A\n=k_ECandyShopAuditAction_EventActionGrantRerollCharg\
    esIncrease\x10\x08*\xa8\x01\n\x14ECandyShopRewardType\x12\x1f\n\x1bk_eCa\
    ndyShopRewardType_None\x10\0\x12\x1f\n\x1bk_eCandyShopRewardType_Item\
    \x10\x01\x12&\n\"k_eCandyShopRewardType_EventAction\x10\x02\x12&\n\"k_eC\
    andyShopRewardType_EventPoints\x10\x03B%Z#github.com/dotabuff/manta/dota\
    ;dotaJ\xcaQ\n\x07\x12\x05\0\0\xb2\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\
    \n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1c\n\
    \t\n\x02\x03\x01\x12\x03\x06\x07\x20\n\t\n\x02\x03\x02\x12\x03\x07\x07%\
    \n\t\n\x02\x03\x03\x12\x03\x08\x07%\n\t\n\x02\x03\x04\x12\x03\t\x07\x1f\
    \n\t\n\x02\x03\x05\x12\x03\n\x07\x1e\n\t\n\x02\x03\x06\x12\x03\x0b\x07\
    \x1e\n\t\n\x02\x03\x07\x12\x03\x0c\x07%\n\t\n\x02\x03\x08\x12\x03\r\x07\
    \x1e\n\n\n\x02\x05\0\x12\x04\x0f\0\x19\x01\n\n\n\x03\x05\0\x01\x12\x03\
    \x0f\x05\x1a\n\x0b\n\x04\x05\0\x02\0\x12\x03\x10\x08,\n\x0c\n\x05\x05\0\
    \x02\0\x01\x12\x03\x10\x08'\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x10*+\n\
    \x0b\n\x04\x05\0\x02\x01\x12\x03\x11\x082\n\x0c\n\x05\x05\0\x02\x01\x01\
    \x12\x03\x11\x08-\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x1101\n\x0b\n\
    \x04\x05\0\x02\x02\x12\x03\x12\x083\n\x0c\n\x05\x05\0\x02\x02\x01\x12\
    \x03\x12\x08.\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x1212\n\x0b\n\x04\
    \x05\0\x02\x03\x12\x03\x13\x08-\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\
    \x13\x08(\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x13+,\n\x0b\n\x04\x05\0\
    \x02\x04\x12\x03\x14\x082\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x14\x08-\
    \n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x1401\n\x0b\n\x04\x05\0\x02\x05\
    \x12\x03\x15\x087\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x15\x082\n\x0c\n\
    \x05\x05\0\x02\x05\x02\x12\x03\x1556\n\x0b\n\x04\x05\0\x02\x06\x12\x03\
    \x16\x08/\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x16\x08*\n\x0c\n\x05\x05\
    \0\x02\x06\x02\x12\x03\x16-.\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x17\x08J\
    \n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x17\x08E\n\x0c\n\x05\x05\0\x02\
    \x07\x02\x12\x03\x17HI\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x18\x08J\n\x0c\
    \n\x05\x05\0\x02\x08\x01\x12\x03\x18\x08E\n\x0c\n\x05\x05\0\x02\x08\x02\
    \x12\x03\x18HI\n\n\n\x02\x05\x01\x12\x04\x1b\0\x20\x01\n\n\n\x03\x05\x01\
    \x01\x12\x03\x1b\x05\x19\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x1c\x08(\n\
    \x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x1c\x08#\n\x0c\n\x05\x05\x01\x02\0\
    \x02\x12\x03\x1c&'\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x1d\x08(\n\x0c\n\
    \x05\x05\x01\x02\x01\x01\x12\x03\x1d\x08#\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03\x1d&'\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\x1e\x08/\n\x0c\n\
    \x05\x05\x01\x02\x02\x01\x12\x03\x1e\x08*\n\x0c\n\x05\x05\x01\x02\x02\
    \x02\x12\x03\x1e-.\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\x1f\x08/\n\x0c\n\
    \x05\x05\x01\x02\x03\x01\x12\x03\x1f\x08*\n\x0c\n\x05\x05\x01\x02\x03\
    \x02\x12\x03\x1f-.\n\n\n\x02\x04\0\x12\x04\"\0%\x01\n\n\n\x03\x04\0\x01\
    \x12\x03\"\x08\x1f\n\x0b\n\x04\x04\0\x02\0\x12\x03#\x08'\n\x0c\n\x05\x04\
    \0\x02\0\x04\x12\x03#\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03#\x11\
    \x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03#\x18\"\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03#%&\n\x0b\n\x04\x04\0\x02\x01\x12\x03$\x08(\n\x0c\n\x05\x04\
    \0\x02\x01\x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03$\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03$\x18#\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x03$&'\n\n\n\x02\x04\x01\x12\x04'\0)\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03'\x08\"\n\x0b\n\x04\x04\x01\x02\0\x12\x03(\x08:\n\x0c\n\
    \x05\x04\x01\x02\0\x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x06\
    \x12\x03(\x11(\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03()5\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03(89\n\n\n\x02\x04\x02\x12\x04+\0/\x01\n\n\n\x03\
    \x04\x02\x01\x12\x03+\x08#\n\x0b\n\x04\x04\x02\x02\0\x12\x03,\x08&\n\x0c\
    \n\x05\x04\x02\x02\0\x04\x12\x03,\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x03,\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03,\x18!\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03,$%\n\x0b\n\x04\x04\x02\x02\x01\x12\x03-\
    \x086\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03-\x08\x10\n\x0c\n\x05\x04\
    \x02\x02\x01\x06\x12\x03-\x11+\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03-,\
    1\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03-45\n\x0b\n\x04\x04\x02\x02\x02\
    \x12\x03.\x087\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03.\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x02\x06\x12\x03.\x11+\n\x0c\n\x05\x04\x02\x02\x02\x01\
    \x12\x03.,2\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03.56\n\n\n\x02\x04\x03\
    \x12\x041\03\x01\n\n\n\x03\x04\x03\x01\x12\x031\x08$\n\x0b\n\x04\x04\x03\
    \x02\0\x12\x032\x08%\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x032\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x032\x11\x17\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x032\x18\x20\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x032#$\n\n\n\x02\
    \x04\x04\x12\x045\09\x01\n\n\n\x03\x04\x04\x01\x12\x035\x08+\n\x0b\n\x04\
    \x04\x04\x02\0\x12\x036\x08%\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x036\x08\
    \x10\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x036\x11\x17\n\x0c\n\x05\x04\x04\
    \x02\0\x01\x12\x036\x18\x20\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x036#$\n\
    \x0b\n\x04\x04\x04\x02\x01\x12\x037\x08&\n\x0c\n\x05\x04\x04\x02\x01\x04\
    \x12\x037\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x037\x11\x17\n\x0c\
    \n\x05\x04\x04\x02\x01\x01\x12\x037\x18!\n\x0c\n\x05\x04\x04\x02\x01\x03\
    \x12\x037$%\n\x0b\n\x04\x04\x04\x02\x02\x12\x038\x08%\n\x0c\n\x05\x04\
    \x04\x02\x02\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\
    \x038\x11\x17\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x038\x18\x20\n\x0c\n\
    \x05\x04\x04\x02\x02\x03\x12\x038#$\n\n\n\x02\x04\x05\x12\x04;\0>\x01\n\
    \n\n\x03\x04\x05\x01\x12\x03;\x08+\n\x0b\n\x04\x04\x05\x02\0\x12\x03<\
    \x08%\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03<\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\0\x06\x12\x03<\x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03<\x18\
    \x20\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03<#$\n\x0b\n\x04\x04\x05\x02\
    \x01\x12\x03=\x08#\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03=\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\x01\x05\x12\x03=\x11\x17\n\x0c\n\x05\x04\x05\x02\
    \x01\x01\x12\x03=\x18\x1e\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03=!\"\n\
    \n\n\x02\x04\x06\x12\x04@\0H\x01\n\n\n\x03\x04\x06\x01\x12\x03@\x08\x1b\
    \n\x0b\n\x04\x04\x06\x02\0\x12\x03A\x08&\n\x0c\n\x05\x04\x06\x02\0\x04\
    \x12\x03A\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03A\x11\x17\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x03A\x18!\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03A$%\n\x0b\n\x04\x04\x06\x02\x01\x12\x03B\x08-\n\x0c\n\x05\x04\x06\
    \x02\x01\x04\x12\x03B\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03B\
    \x11\x17\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03B\x18(\n\x0c\n\x05\x04\
    \x06\x02\x01\x03\x12\x03B+,\n\x0b\n\x04\x04\x06\x02\x02\x12\x03C\x086\n\
    \x0c\n\x05\x04\x06\x02\x02\x04\x12\x03C\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \x02\x06\x12\x03C\x11+\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03C,1\n\x0c\
    \n\x05\x04\x06\x02\x02\x03\x12\x03C45\n\x0b\n\x04\x04\x06\x02\x03\x12\
    \x03D\x086\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03D\x08\x10\n\x0c\n\x05\
    \x04\x06\x02\x03\x06\x12\x03D\x11%\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\
    \x03D&1\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03D45\n\x0b\n\x04\x04\x06\
    \x02\x04\x12\x03E\x08<\n\x0c\n\x05\x04\x06\x02\x04\x04\x12\x03E\x08\x10\
    \n\x0c\n\x05\x04\x06\x02\x04\x06\x12\x03E\x11-\n\x0c\n\x05\x04\x06\x02\
    \x04\x01\x12\x03E.7\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03E:;\n\x0b\n\
    \x04\x04\x06\x02\x05\x12\x03F\x08K\n\x0c\n\x05\x04\x06\x02\x05\x04\x12\
    \x03F\x08\x10\n\x0c\n\x05\x04\x06\x02\x05\x06\x12\x03F\x114\n\x0c\n\x05\
    \x04\x06\x02\x05\x01\x12\x03F5F\n\x0c\n\x05\x04\x06\x02\x05\x03\x12\x03F\
    IJ\n\x0b\n\x04\x04\x06\x02\x06\x12\x03G\x08K\n\x0c\n\x05\x04\x06\x02\x06\
    \x04\x12\x03G\x08\x10\n\x0c\n\x05\x04\x06\x02\x06\x06\x12\x03G\x114\n\
    \x0c\n\x05\x04\x06\x02\x06\x01\x12\x03G5F\n\x0c\n\x05\x04\x06\x02\x06\
    \x03\x12\x03GIJ\n\n\n\x02\x04\x07\x12\x04J\0Q\x01\n\n\n\x03\x04\x07\x01\
    \x12\x03J\x08\x1d\n\x0b\n\x04\x04\x07\x02\0\x12\x03K\x08+\n\x0c\n\x05\
    \x04\x07\x02\0\x04\x12\x03K\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\
    \x03K\x11\x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03K\x18&\n\x0c\n\x05\
    \x04\x07\x02\0\x03\x12\x03K)*\n\x0b\n\x04\x04\x07\x02\x01\x12\x03L\x08:\
    \n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03L\x08\x10\n\x0c\n\x05\x04\x07\
    \x02\x01\x06\x12\x03L\x11+\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03L,5\n\
    \x0c\n\x05\x04\x07\x02\x01\x03\x12\x03L89\n\x0b\n\x04\x04\x07\x02\x02\
    \x12\x03M\x086\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03M\x08\x10\n\x0c\n\
    \x05\x04\x07\x02\x02\x05\x12\x03M\x11\x18\n\x0c\n\x05\x04\x07\x02\x02\
    \x01\x12\x03M\x191\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03M45\n\x0b\n\
    \x04\x04\x07\x02\x03\x12\x03N\x08B\n\x0c\n\x05\x04\x07\x02\x03\x04\x12\
    \x03N\x08\x10\n\x0c\n\x05\x04\x07\x02\x03\x06\x12\x03N\x11,\n\x0c\n\x05\
    \x04\x07\x02\x03\x01\x12\x03N-=\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03N\
    @A\n\x0b\n\x04\x04\x07\x02\x04\x12\x03O\x088\n\x0c\n\x05\x04\x07\x02\x04\
    \x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x07\x02\x04\x06\x12\x03O\x11$\n\
    \x0c\n\x05\x04\x07\x02\x04\x01\x12\x03O%3\n\x0c\n\x05\x04\x07\x02\x04\
    \x03\x12\x03O67\n\x0b\n\x04\x04\x07\x02\x05\x12\x03P\x08+\n\x0c\n\x05\
    \x04\x07\x02\x05\x04\x12\x03P\x08\x10\n\x0c\n\x05\x04\x07\x02\x05\x05\
    \x12\x03P\x11\x17\n\x0c\n\x05\x04\x07\x02\x05\x01\x12\x03P\x18&\n\x0c\n\
    \x05\x04\x07\x02\x05\x03\x12\x03P)*\n\n\n\x02\x04\x08\x12\x04S\0U\x01\n\
    \n\n\x03\x04\x08\x01\x12\x03S\x08*\n\x0b\n\x04\x04\x08\x02\0\x12\x03T\
    \x08*\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\x08\
    \x02\0\x05\x12\x03T\x11\x17\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03T\x18%\
    \n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03T()\n\n\n\x02\x04\t\x12\x04W\0d\
    \x01\n\n\n\x03\x04\t\x01\x12\x03W\x082\n\x0c\n\x04\x04\t\x04\0\x12\x04X\
    \x08`\t\n\x0c\n\x05\x04\t\x04\0\x01\x12\x03X\r\x16\n\r\n\x06\x04\t\x04\0\
    \x02\0\x12\x03Y\x10%\n\x0e\n\x07\x04\t\x04\0\x02\0\x01\x12\x03Y\x10\x20\
    \n\x0e\n\x07\x04\t\x04\0\x02\0\x02\x12\x03Y#$\n\r\n\x06\x04\t\x04\0\x02\
    \x01\x12\x03Z\x10\x1f\n\x0e\n\x07\x04\t\x04\0\x02\x01\x01\x12\x03Z\x10\
    \x1a\n\x0e\n\x07\x04\t\x04\0\x02\x01\x02\x12\x03Z\x1d\x1e\n\r\n\x06\x04\
    \t\x04\0\x02\x02\x12\x03[\x10\x1f\n\x0e\n\x07\x04\t\x04\0\x02\x02\x01\
    \x12\x03[\x10\x1a\n\x0e\n\x07\x04\t\x04\0\x02\x02\x02\x12\x03[\x1d\x1e\n\
    \r\n\x06\x04\t\x04\0\x02\x03\x12\x03\\\x10\x20\n\x0e\n\x07\x04\t\x04\0\
    \x02\x03\x01\x12\x03\\\x10\x1b\n\x0e\n\x07\x04\t\x04\0\x02\x03\x02\x12\
    \x03\\\x1e\x1f\n\r\n\x06\x04\t\x04\0\x02\x04\x12\x03]\x10\x1f\n\x0e\n\
    \x07\x04\t\x04\0\x02\x04\x01\x12\x03]\x10\x1a\n\x0e\n\x07\x04\t\x04\0\
    \x02\x04\x02\x12\x03]\x1d\x1e\n\r\n\x06\x04\t\x04\0\x02\x05\x12\x03^\x10\
    #\n\x0e\n\x07\x04\t\x04\0\x02\x05\x01\x12\x03^\x10\x1e\n\x0e\n\x07\x04\t\
    \x04\0\x02\x05\x02\x12\x03^!\"\n\r\n\x06\x04\t\x04\0\x02\x06\x12\x03_\
    \x10#\n\x0e\n\x07\x04\t\x04\0\x02\x06\x01\x12\x03_\x10\x1e\n\x0e\n\x07\
    \x04\t\x04\0\x02\x06\x02\x12\x03_!\"\n\x0b\n\x04\x04\t\x02\0\x12\x03b\
    \x08S\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03b\x08\x10\n\x0c\n\x05\x04\t\x02\
    \0\x06\x12\x03b\x11E\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03bFN\n\x0c\n\x05\
    \x04\t\x02\0\x03\x12\x03bQR\n\x0b\n\x04\x04\t\x02\x01\x12\x03c\x085\n\
    \x0c\n\x05\x04\t\x02\x01\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\t\x02\x01\
    \x06\x12\x03c\x11&\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03c'0\n\x0c\n\x05\
    \x04\t\x02\x01\x03\x12\x03c34\n\n\n\x02\x04\n\x12\x04f\0i\x01\n\n\n\x03\
    \x04\n\x01\x12\x03f\x08.\n\x0b\n\x04\x04\n\x02\0\x12\x03g\x08*\n\x0c\n\
    \x05\x04\n\x02\0\x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\n\x02\0\x05\x12\
    \x03g\x11\x17\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03g\x18%\n\x0c\n\x05\x04\
    \n\x02\0\x03\x12\x03g()\n\x0b\n\x04\x04\n\x02\x01\x12\x03h\x085\n\x0c\n\
    \x05\x04\n\x02\x01\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\n\x02\x01\x06\
    \x12\x03h\x11&\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03h'0\n\x0c\n\x05\x04\
    \n\x02\x01\x03\x12\x03h34\n\n\n\x02\x04\x0b\x12\x04k\0n\x01\n\n\n\x03\
    \x04\x0b\x01\x12\x03k\x08-\n\x0b\n\x04\x04\x0b\x02\0\x12\x03l\x08*\n\x0c\
    \n\x05\x04\x0b\x02\0\x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\x0b\x02\0\x05\
    \x12\x03l\x11\x17\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03l\x18%\n\x0c\n\
    \x05\x04\x0b\x02\0\x03\x12\x03l()\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03m\
    \x08&\n\x0c\n\x05\x04\x0b\x02\x01\x04\x12\x03m\x08\x10\n\x0c\n\x05\x04\
    \x0b\x02\x01\x05\x12\x03m\x11\x17\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\
    \x03m\x18!\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03m$%\n\n\n\x02\x04\x0c\
    \x12\x04p\0~\x01\n\n\n\x03\x04\x0c\x01\x12\x03p\x085\n\x0c\n\x04\x04\x0c\
    \x04\0\x12\x04q\x08{\t\n\x0c\n\x05\x04\x0c\x04\0\x01\x12\x03q\r\x16\n\r\
    \n\x06\x04\x0c\x04\0\x02\0\x12\x03r\x10%\n\x0e\n\x07\x04\x0c\x04\0\x02\0\
    \x01\x12\x03r\x10\x20\n\x0e\n\x07\x04\x0c\x04\0\x02\0\x02\x12\x03r#$\n\r\
    \n\x06\x04\x0c\x04\0\x02\x01\x12\x03s\x10\x1f\n\x0e\n\x07\x04\x0c\x04\0\
    \x02\x01\x01\x12\x03s\x10\x1a\n\x0e\n\x07\x04\x0c\x04\0\x02\x01\x02\x12\
    \x03s\x1d\x1e\n\r\n\x06\x04\x0c\x04\0\x02\x02\x12\x03t\x10\x1f\n\x0e\n\
    \x07\x04\x0c\x04\0\x02\x02\x01\x12\x03t\x10\x1a\n\x0e\n\x07\x04\x0c\x04\
    \0\x02\x02\x02\x12\x03t\x1d\x1e\n\r\n\x06\x04\x0c\x04\0\x02\x03\x12\x03u\
    \x10\x20\n\x0e\n\x07\x04\x0c\x04\0\x02\x03\x01\x12\x03u\x10\x1b\n\x0e\n\
    \x07\x04\x0c\x04\0\x02\x03\x02\x12\x03u\x1e\x1f\n\r\n\x06\x04\x0c\x04\0\
    \x02\x04\x12\x03v\x10\x1f\n\x0e\n\x07\x04\x0c\x04\0\x02\x04\x01\x12\x03v\
    \x10\x1a\n\x0e\n\x07\x04\x0c\x04\0\x02\x04\x02\x12\x03v\x1d\x1e\n\r\n\
    \x06\x04\x0c\x04\0\x02\x05\x12\x03w\x10#\n\x0e\n\x07\x04\x0c\x04\0\x02\
    \x05\x01\x12\x03w\x10\x1e\n\x0e\n\x07\x04\x0c\x04\0\x02\x05\x02\x12\x03w\
    !\"\n\r\n\x06\x04\x0c\x04\0\x02\x06\x12\x03x\x10%\n\x0e\n\x07\x04\x0c\
    \x04\0\x02\x06\x01\x12\x03x\x10\x20\n\x0e\n\x07\x04\x0c\x04\0\x02\x06\
    \x02\x12\x03x#$\n\r\n\x06\x04\x0c\x04\0\x02\x07\x12\x03y\x10&\n\x0e\n\
    \x07\x04\x0c\x04\0\x02\x07\x01\x12\x03y\x10!\n\x0e\n\x07\x04\x0c\x04\0\
    \x02\x07\x02\x12\x03y$%\n\r\n\x06\x04\x0c\x04\0\x02\x08\x12\x03z\x10#\n\
    \x0e\n\x07\x04\x0c\x04\0\x02\x08\x01\x12\x03z\x10\x1e\n\x0e\n\x07\x04\
    \x0c\x04\0\x02\x08\x02\x12\x03z!\"\n\x0b\n\x04\x04\x0c\x02\0\x12\x03}\
    \x08V\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\x0c\
    \x02\0\x06\x12\x03}\x11H\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03}IQ\n\x0c\
    \n\x05\x04\x0c\x02\0\x03\x12\x03}TU\n\x0c\n\x02\x04\r\x12\x06\x80\x01\0\
    \x83\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x80\x01\x08'\n\x0c\n\x04\x04\
    \r\x02\0\x12\x04\x81\x01\x08*\n\r\n\x05\x04\r\x02\0\x04\x12\x04\x81\x01\
    \x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x81\x01\x11\x17\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\x81\x01\x18%\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x81\
    \x01()\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x82\x01\x08&\n\r\n\x05\x04\r\
    \x02\x01\x04\x12\x04\x82\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\
    \x82\x01\x11\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x82\x01\x18!\n\r\n\
    \x05\x04\r\x02\x01\x03\x12\x04\x82\x01$%\n\x0c\n\x02\x04\x0e\x12\x06\x85\
    \x01\0\x94\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\x85\x01\x08/\n\x0e\n\
    \x04\x04\x0e\x04\0\x12\x06\x86\x01\x08\x91\x01\t\n\r\n\x05\x04\x0e\x04\0\
    \x01\x12\x04\x86\x01\r\x16\n\x0e\n\x06\x04\x0e\x04\0\x02\0\x12\x04\x87\
    \x01\x10%\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x01\x12\x04\x87\x01\x10\x20\n\
    \x0f\n\x07\x04\x0e\x04\0\x02\0\x02\x12\x04\x87\x01#$\n\x0e\n\x06\x04\x0e\
    \x04\0\x02\x01\x12\x04\x88\x01\x10\x1f\n\x0f\n\x07\x04\x0e\x04\0\x02\x01\
    \x01\x12\x04\x88\x01\x10\x1a\n\x0f\n\x07\x04\x0e\x04\0\x02\x01\x02\x12\
    \x04\x88\x01\x1d\x1e\n\x0e\n\x06\x04\x0e\x04\0\x02\x02\x12\x04\x89\x01\
    \x10\x1f\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x01\x12\x04\x89\x01\x10\x1a\n\
    \x0f\n\x07\x04\x0e\x04\0\x02\x02\x02\x12\x04\x89\x01\x1d\x1e\n\x0e\n\x06\
    \x04\x0e\x04\0\x02\x03\x12\x04\x8a\x01\x10\x20\n\x0f\n\x07\x04\x0e\x04\0\
    \x02\x03\x01\x12\x04\x8a\x01\x10\x1b\n\x0f\n\x07\x04\x0e\x04\0\x02\x03\
    \x02\x12\x04\x8a\x01\x1e\x1f\n\x0e\n\x06\x04\x0e\x04\0\x02\x04\x12\x04\
    \x8b\x01\x10\x1f\n\x0f\n\x07\x04\x0e\x04\0\x02\x04\x01\x12\x04\x8b\x01\
    \x10\x1a\n\x0f\n\x07\x04\x0e\x04\0\x02\x04\x02\x12\x04\x8b\x01\x1d\x1e\n\
    \x0e\n\x06\x04\x0e\x04\0\x02\x05\x12\x04\x8c\x01\x10#\n\x0f\n\x07\x04\
    \x0e\x04\0\x02\x05\x01\x12\x04\x8c\x01\x10\x1e\n\x0f\n\x07\x04\x0e\x04\0\
    \x02\x05\x02\x12\x04\x8c\x01!\"\n\x0e\n\x06\x04\x0e\x04\0\x02\x06\x12\
    \x04\x8d\x01\x10#\n\x0f\n\x07\x04\x0e\x04\0\x02\x06\x01\x12\x04\x8d\x01\
    \x10\x1e\n\x0f\n\x07\x04\x0e\x04\0\x02\x06\x02\x12\x04\x8d\x01!\"\n\x0e\
    \n\x06\x04\x0e\x04\0\x02\x07\x12\x04\x8e\x01\x10%\n\x0f\n\x07\x04\x0e\
    \x04\0\x02\x07\x01\x12\x04\x8e\x01\x10\x20\n\x0f\n\x07\x04\x0e\x04\0\x02\
    \x07\x02\x12\x04\x8e\x01#$\n\x0e\n\x06\x04\x0e\x04\0\x02\x08\x12\x04\x8f\
    \x01\x10&\n\x0f\n\x07\x04\x0e\x04\0\x02\x08\x01\x12\x04\x8f\x01\x10!\n\
    \x0f\n\x07\x04\x0e\x04\0\x02\x08\x02\x12\x04\x8f\x01$%\n\x0e\n\x06\x04\
    \x0e\x04\0\x02\t\x12\x04\x90\x01\x10#\n\x0f\n\x07\x04\x0e\x04\0\x02\t\
    \x01\x12\x04\x90\x01\x10\x1e\n\x0f\n\x07\x04\x0e\x04\0\x02\t\x02\x12\x04\
    \x90\x01!\"\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x93\x01\x08P\n\r\n\x05\x04\
    \x0e\x02\0\x04\x12\x04\x93\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x06\x12\
    \x04\x93\x01\x11B\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x93\x01CK\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\x93\x01NO\n\x0c\n\x02\x04\x0f\x12\x06\x96\
    \x01\0\x99\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x96\x01\x08)\n\x0c\n\
    \x04\x04\x0f\x02\0\x12\x04\x97\x01\x08*\n\r\n\x05\x04\x0f\x02\0\x04\x12\
    \x04\x97\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x97\x01\x11\x17\
    \n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x97\x01\x18%\n\r\n\x05\x04\x0f\x02\
    \0\x03\x12\x04\x97\x01()\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\x98\x01\x08\
    &\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\
    \x0f\x02\x01\x05\x12\x04\x98\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x01\x01\
    \x12\x04\x98\x01\x18!\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x98\x01$%\n\
    \x0c\n\x02\x04\x10\x12\x06\x9b\x01\0\xaa\x01\x01\n\x0b\n\x03\x04\x10\x01\
    \x12\x04\x9b\x01\x081\n\x0e\n\x04\x04\x10\x04\0\x12\x06\x9c\x01\x08\xa7\
    \x01\t\n\r\n\x05\x04\x10\x04\0\x01\x12\x04\x9c\x01\r\x16\n\x0e\n\x06\x04\
    \x10\x04\0\x02\0\x12\x04\x9d\x01\x10%\n\x0f\n\x07\x04\x10\x04\0\x02\0\
    \x01\x12\x04\x9d\x01\x10\x20\n\x0f\n\x07\x04\x10\x04\0\x02\0\x02\x12\x04\
    \x9d\x01#$\n\x0e\n\x06\x04\x10\x04\0\x02\x01\x12\x04\x9e\x01\x10\x1f\n\
    \x0f\n\x07\x04\x10\x04\0\x02\x01\x01\x12\x04\x9e\x01\x10\x1a\n\x0f\n\x07\
    \x04\x10\x04\0\x02\x01\x02\x12\x04\x9e\x01\x1d\x1e\n\x0e\n\x06\x04\x10\
    \x04\0\x02\x02\x12\x04\x9f\x01\x10\x1f\n\x0f\n\x07\x04\x10\x04\0\x02\x02\
    \x01\x12\x04\x9f\x01\x10\x1a\n\x0f\n\x07\x04\x10\x04\0\x02\x02\x02\x12\
    \x04\x9f\x01\x1d\x1e\n\x0e\n\x06\x04\x10\x04\0\x02\x03\x12\x04\xa0\x01\
    \x10\x20\n\x0f\n\x07\x04\x10\x04\0\x02\x03\x01\x12\x04\xa0\x01\x10\x1b\n\
    \x0f\n\x07\x04\x10\x04\0\x02\x03\x02\x12\x04\xa0\x01\x1e\x1f\n\x0e\n\x06\
    \x04\x10\x04\0\x02\x04\x12\x04\xa1\x01\x10\x1f\n\x0f\n\x07\x04\x10\x04\0\
    \x02\x04\x01\x12\x04\xa1\x01\x10\x1a\n\x0f\n\x07\x04\x10\x04\0\x02\x04\
    \x02\x12\x04\xa1\x01\x1d\x1e\n\x0e\n\x06\x04\x10\x04\0\x02\x05\x12\x04\
    \xa2\x01\x10#\n\x0f\n\x07\x04\x10\x04\0\x02\x05\x01\x12\x04\xa2\x01\x10\
    \x1e\n\x0f\n\x07\x04\x10\x04\0\x02\x05\x02\x12\x04\xa2\x01!\"\n\x0e\n\
    \x06\x04\x10\x04\0\x02\x06\x12\x04\xa3\x01\x10&\n\x0f\n\x07\x04\x10\x04\
    \0\x02\x06\x01\x12\x04\xa3\x01\x10!\n\x0f\n\x07\x04\x10\x04\0\x02\x06\
    \x02\x12\x04\xa3\x01$%\n\x0e\n\x06\x04\x10\x04\0\x02\x07\x12\x04\xa4\x01\
    \x10%\n\x0f\n\x07\x04\x10\x04\0\x02\x07\x01\x12\x04\xa4\x01\x10\x20\n\
    \x0f\n\x07\x04\x10\x04\0\x02\x07\x02\x12\x04\xa4\x01#$\n\x0e\n\x06\x04\
    \x10\x04\0\x02\x08\x12\x04\xa5\x01\x10&\n\x0f\n\x07\x04\x10\x04\0\x02\
    \x08\x01\x12\x04\xa5\x01\x10!\n\x0f\n\x07\x04\x10\x04\0\x02\x08\x02\x12\
    \x04\xa5\x01$%\n\x0e\n\x06\x04\x10\x04\0\x02\t\x12\x04\xa6\x01\x10#\n\
    \x0f\n\x07\x04\x10\x04\0\x02\t\x01\x12\x04\xa6\x01\x10\x1e\n\x0f\n\x07\
    \x04\x10\x04\0\x02\t\x02\x12\x04\xa6\x01!\"\n\x0c\n\x04\x04\x10\x02\0\
    \x12\x04\xa9\x01\x08R\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xa9\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xa9\x01\x11D\n\r\n\x05\x04\x10\
    \x02\0\x01\x12\x04\xa9\x01EM\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa9\x01\
    PQ\n\x0c\n\x02\x04\x11\x12\x06\xac\x01\0\xb0\x01\x01\n\x0b\n\x03\x04\x11\
    \x01\x12\x04\xac\x01\x081\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xad\x01\x08*\
    \n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x11\
    \x02\0\x05\x12\x04\xad\x01\x11\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\
    \xad\x01\x18%\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xad\x01()\n\x0c\n\x04\
    \x04\x11\x02\x01\x12\x04\xae\x01\x086\n\r\n\x05\x04\x11\x02\x01\x04\x12\
    \x04\xae\x01\x08\x10\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xae\x01\x11+\
    \n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xae\x01,1\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xae\x0145\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xaf\x01\
    \x087\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\
    \x04\x11\x02\x02\x06\x12\x04\xaf\x01\x11+\n\r\n\x05\x04\x11\x02\x02\x01\
    \x12\x04\xaf\x01,2\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xaf\x0156\n\x0c\
    \n\x02\x04\x12\x12\x06\xb2\x01\0\xc1\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xb2\x01\x089\n\x0e\n\x04\x04\x12\x04\0\x12\x06\xb3\x01\x08\xbe\x01\
    \t\n\r\n\x05\x04\x12\x04\0\x01\x12\x04\xb3\x01\r\x16\n\x0e\n\x06\x04\x12\
    \x04\0\x02\0\x12\x04\xb4\x01\x10%\n\x0f\n\x07\x04\x12\x04\0\x02\0\x01\
    \x12\x04\xb4\x01\x10\x20\n\x0f\n\x07\x04\x12\x04\0\x02\0\x02\x12\x04\xb4\
    \x01#$\n\x0e\n\x06\x04\x12\x04\0\x02\x01\x12\x04\xb5\x01\x10\x1f\n\x0f\n\
    \x07\x04\x12\x04\0\x02\x01\x01\x12\x04\xb5\x01\x10\x1a\n\x0f\n\x07\x04\
    \x12\x04\0\x02\x01\x02\x12\x04\xb5\x01\x1d\x1e\n\x0e\n\x06\x04\x12\x04\0\
    \x02\x02\x12\x04\xb6\x01\x10\x1f\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x01\
    \x12\x04\xb6\x01\x10\x1a\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x02\x12\x04\
    \xb6\x01\x1d\x1e\n\x0e\n\x06\x04\x12\x04\0\x02\x03\x12\x04\xb7\x01\x10\
    \x20\n\x0f\n\x07\x04\x12\x04\0\x02\x03\x01\x12\x04\xb7\x01\x10\x1b\n\x0f\
    \n\x07\x04\x12\x04\0\x02\x03\x02\x12\x04\xb7\x01\x1e\x1f\n\x0e\n\x06\x04\
    \x12\x04\0\x02\x04\x12\x04\xb8\x01\x10\x1f\n\x0f\n\x07\x04\x12\x04\0\x02\
    \x04\x01\x12\x04\xb8\x01\x10\x1a\n\x0f\n\x07\x04\x12\x04\0\x02\x04\x02\
    \x12\x04\xb8\x01\x1d\x1e\n\x0e\n\x06\x04\x12\x04\0\x02\x05\x12\x04\xb9\
    \x01\x10#\n\x0f\n\x07\x04\x12\x04\0\x02\x05\x01\x12\x04\xb9\x01\x10\x1e\
    \n\x0f\n\x07\x04\x12\x04\0\x02\x05\x02\x12\x04\xb9\x01!\"\n\x0e\n\x06\
    \x04\x12\x04\0\x02\x06\x12\x04\xba\x01\x10&\n\x0f\n\x07\x04\x12\x04\0\
    \x02\x06\x01\x12\x04\xba\x01\x10!\n\x0f\n\x07\x04\x12\x04\0\x02\x06\x02\
    \x12\x04\xba\x01$%\n\x0e\n\x06\x04\x12\x04\0\x02\x07\x12\x04\xbb\x01\x10\
    %\n\x0f\n\x07\x04\x12\x04\0\x02\x07\x01\x12\x04\xbb\x01\x10\x20\n\x0f\n\
    \x07\x04\x12\x04\0\x02\x07\x02\x12\x04\xbb\x01#$\n\x0e\n\x06\x04\x12\x04\
    \0\x02\x08\x12\x04\xbc\x01\x10&\n\x0f\n\x07\x04\x12\x04\0\x02\x08\x01\
    \x12\x04\xbc\x01\x10!\n\x0f\n\x07\x04\x12\x04\0\x02\x08\x02\x12\x04\xbc\
    \x01$%\n\x0e\n\x06\x04\x12\x04\0\x02\t\x12\x04\xbd\x01\x10#\n\x0f\n\x07\
    \x04\x12\x04\0\x02\t\x01\x12\x04\xbd\x01\x10\x1e\n\x0f\n\x07\x04\x12\x04\
    \0\x02\t\x02\x12\x04\xbd\x01!\"\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xc0\
    \x01\x08Z\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xc0\x01\x08\x10\n\r\n\x05\
    \x04\x12\x02\0\x06\x12\x04\xc0\x01\x11L\n\r\n\x05\x04\x12\x02\0\x01\x12\
    \x04\xc0\x01MU\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xc0\x01XY\n\x0c\n\x02\
    \x04\x13\x12\x06\xc3\x01\0\xc5\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \xc3\x01\x08,\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xc4\x01\x08*\n\r\n\x05\
    \x04\x13\x02\0\x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x05\
    \x12\x04\xc4\x01\x11\x17\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xc4\x01\x18\
    %\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xc4\x01()\n\x0c\n\x02\x04\x14\x12\
    \x06\xc7\x01\0\xd4\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xc7\x01\x084\
    \n\x0e\n\x04\x04\x14\x04\0\x12\x06\xc8\x01\x08\xd1\x01\t\n\r\n\x05\x04\
    \x14\x04\0\x01\x12\x04\xc8\x01\r\x16\n\x0e\n\x06\x04\x14\x04\0\x02\0\x12\
    \x04\xc9\x01\x10%\n\x0f\n\x07\x04\x14\x04\0\x02\0\x01\x12\x04\xc9\x01\
    \x10\x20\n\x0f\n\x07\x04\x14\x04\0\x02\0\x02\x12\x04\xc9\x01#$\n\x0e\n\
    \x06\x04\x14\x04\0\x02\x01\x12\x04\xca\x01\x10\x1f\n\x0f\n\x07\x04\x14\
    \x04\0\x02\x01\x01\x12\x04\xca\x01\x10\x1a\n\x0f\n\x07\x04\x14\x04\0\x02\
    \x01\x02\x12\x04\xca\x01\x1d\x1e\n\x0e\n\x06\x04\x14\x04\0\x02\x02\x12\
    \x04\xcb\x01\x10\x1f\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x01\x12\x04\xcb\
    \x01\x10\x1a\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x02\x12\x04\xcb\x01\x1d\
    \x1e\n\x0e\n\x06\x04\x14\x04\0\x02\x03\x12\x04\xcc\x01\x10\x20\n\x0f\n\
    \x07\x04\x14\x04\0\x02\x03\x01\x12\x04\xcc\x01\x10\x1b\n\x0f\n\x07\x04\
    \x14\x04\0\x02\x03\x02\x12\x04\xcc\x01\x1e\x1f\n\x0e\n\x06\x04\x14\x04\0\
    \x02\x04\x12\x04\xcd\x01\x10\x1f\n\x0f\n\x07\x04\x14\x04\0\x02\x04\x01\
    \x12\x04\xcd\x01\x10\x1a\n\x0f\n\x07\x04\x14\x04\0\x02\x04\x02\x12\x04\
    \xcd\x01\x1d\x1e\n\x0e\n\x06\x04\x14\x04\0\x02\x05\x12\x04\xce\x01\x10#\
    \n\x0f\n\x07\x04\x14\x04\0\x02\x05\x01\x12\x04\xce\x01\x10\x1e\n\x0f\n\
    \x07\x04\x14\x04\0\x02\x05\x02\x12\x04\xce\x01!\"\n\x0e\n\x06\x04\x14\
    \x04\0\x02\x06\x12\x04\xcf\x01\x10'\n\x0f\n\x07\x04\x14\x04\0\x02\x06\
    \x01\x12\x04\xcf\x01\x10\"\n\x0f\n\x07\x04\x14\x04\0\x02\x06\x02\x12\x04\
    \xcf\x01%&\n\x0e\n\x06\x04\x14\x04\0\x02\x07\x12\x04\xd0\x01\x10#\n\x0f\
    \n\x07\x04\x14\x04\0\x02\x07\x01\x12\x04\xd0\x01\x10\x1e\n\x0f\n\x07\x04\
    \x14\x04\0\x02\x07\x02\x12\x04\xd0\x01!\"\n\x0c\n\x04\x04\x14\x02\0\x12\
    \x04\xd3\x01\x08U\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xd3\x01\x08\x10\n\
    \r\n\x05\x04\x14\x02\0\x06\x12\x04\xd3\x01\x11G\n\r\n\x05\x04\x14\x02\0\
    \x01\x12\x04\xd3\x01HP\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xd3\x01ST\n\
    \x0c\n\x02\x04\x15\x12\x06\xd6\x01\0\xd9\x01\x01\n\x0b\n\x03\x04\x15\x01\
    \x12\x04\xd6\x01\x08,\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xd7\x01\x08*\n\r\
    \n\x05\x04\x15\x02\0\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x15\x02\0\
    \x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xd7\x01\
    \x18%\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xd7\x01()\n\x0c\n\x04\x04\x15\
    \x02\x01\x12\x04\xd8\x01\x08?\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xd8\
    \x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\xd8\x01\x11+\n\r\n\
    \x05\x04\x15\x02\x01\x01\x12\x04\xd8\x01,:\n\r\n\x05\x04\x15\x02\x01\x03\
    \x12\x04\xd8\x01=>\n\x0c\n\x02\x04\x16\x12\x06\xdb\x01\0\xe8\x01\x01\n\
    \x0b\n\x03\x04\x16\x01\x12\x04\xdb\x01\x084\n\x0e\n\x04\x04\x16\x04\0\
    \x12\x06\xdc\x01\x08\xe5\x01\t\n\r\n\x05\x04\x16\x04\0\x01\x12\x04\xdc\
    \x01\r\x16\n\x0e\n\x06\x04\x16\x04\0\x02\0\x12\x04\xdd\x01\x10%\n\x0f\n\
    \x07\x04\x16\x04\0\x02\0\x01\x12\x04\xdd\x01\x10\x20\n\x0f\n\x07\x04\x16\
    \x04\0\x02\0\x02\x12\x04\xdd\x01#$\n\x0e\n\x06\x04\x16\x04\0\x02\x01\x12\
    \x04\xde\x01\x10\x1f\n\x0f\n\x07\x04\x16\x04\0\x02\x01\x01\x12\x04\xde\
    \x01\x10\x1a\n\x0f\n\x07\x04\x16\x04\0\x02\x01\x02\x12\x04\xde\x01\x1d\
    \x1e\n\x0e\n\x06\x04\x16\x04\0\x02\x02\x12\x04\xdf\x01\x10\x1f\n\x0f\n\
    \x07\x04\x16\x04\0\x02\x02\x01\x12\x04\xdf\x01\x10\x1a\n\x0f\n\x07\x04\
    \x16\x04\0\x02\x02\x02\x12\x04\xdf\x01\x1d\x1e\n\x0e\n\x06\x04\x16\x04\0\
    \x02\x03\x12\x04\xe0\x01\x10\x20\n\x0f\n\x07\x04\x16\x04\0\x02\x03\x01\
    \x12\x04\xe0\x01\x10\x1b\n\x0f\n\x07\x04\x16\x04\0\x02\x03\x02\x12\x04\
    \xe0\x01\x1e\x1f\n\x0e\n\x06\x04\x16\x04\0\x02\x04\x12\x04\xe1\x01\x10\
    \x1f\n\x0f\n\x07\x04\x16\x04\0\x02\x04\x01\x12\x04\xe1\x01\x10\x1a\n\x0f\
    \n\x07\x04\x16\x04\0\x02\x04\x02\x12\x04\xe1\x01\x1d\x1e\n\x0e\n\x06\x04\
    \x16\x04\0\x02\x05\x12\x04\xe2\x01\x10\"\n\x0f\n\x07\x04\x16\x04\0\x02\
    \x05\x01\x12\x04\xe2\x01\x10\x1d\n\x0f\n\x07\x04\x16\x04\0\x02\x05\x02\
    \x12\x04\xe2\x01\x20!\n\x0e\n\x06\x04\x16\x04\0\x02\x06\x12\x04\xe3\x01\
    \x10#\n\x0f\n\x07\x04\x16\x04\0\x02\x06\x01\x12\x04\xe3\x01\x10\x1e\n\
    \x0f\n\x07\x04\x16\x04\0\x02\x06\x02\x12\x04\xe3\x01!\"\n\x0e\n\x06\x04\
    \x16\x04\0\x02\x07\x12\x04\xe4\x01\x10&\n\x0f\n\x07\x04\x16\x04\0\x02\
    \x07\x01\x12\x04\xe4\x01\x10!\n\x0f\n\x07\x04\x16\x04\0\x02\x07\x02\x12\
    \x04\xe4\x01$%\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xe7\x01\x08U\n\r\n\x05\
    \x04\x16\x02\0\x04\x12\x04\xe7\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\x06\
    \x12\x04\xe7\x01\x11G\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xe7\x01HP\n\r\
    \n\x05\x04\x16\x02\0\x03\x12\x04\xe7\x01ST\n\x0c\n\x02\x04\x17\x12\x06\
    \xea\x01\0\xec\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xea\x01\x080\n\
    \x0c\n\x04\x04\x17\x02\0\x12\x04\xeb\x01\x08*\n\r\n\x05\x04\x17\x02\0\
    \x04\x12\x04\xeb\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xeb\x01\
    \x11\x17\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xeb\x01\x18%\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xeb\x01()\n\x0c\n\x02\x04\x18\x12\x06\xee\x01\0\
    \xfa\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xee\x01\x088\n\x0e\n\x04\
    \x04\x18\x04\0\x12\x06\xef\x01\x08\xf7\x01\t\n\r\n\x05\x04\x18\x04\0\x01\
    \x12\x04\xef\x01\r\x16\n\x0e\n\x06\x04\x18\x04\0\x02\0\x12\x04\xf0\x01\
    \x10%\n\x0f\n\x07\x04\x18\x04\0\x02\0\x01\x12\x04\xf0\x01\x10\x20\n\x0f\
    \n\x07\x04\x18\x04\0\x02\0\x02\x12\x04\xf0\x01#$\n\x0e\n\x06\x04\x18\x04\
    \0\x02\x01\x12\x04\xf1\x01\x10\x1f\n\x0f\n\x07\x04\x18\x04\0\x02\x01\x01\
    \x12\x04\xf1\x01\x10\x1a\n\x0f\n\x07\x04\x18\x04\0\x02\x01\x02\x12\x04\
    \xf1\x01\x1d\x1e\n\x0e\n\x06\x04\x18\x04\0\x02\x02\x12\x04\xf2\x01\x10\
    \x1f\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x01\x12\x04\xf2\x01\x10\x1a\n\x0f\
    \n\x07\x04\x18\x04\0\x02\x02\x02\x12\x04\xf2\x01\x1d\x1e\n\x0e\n\x06\x04\
    \x18\x04\0\x02\x03\x12\x04\xf3\x01\x10\x20\n\x0f\n\x07\x04\x18\x04\0\x02\
    \x03\x01\x12\x04\xf3\x01\x10\x1b\n\x0f\n\x07\x04\x18\x04\0\x02\x03\x02\
    \x12\x04\xf3\x01\x1e\x1f\n\x0e\n\x06\x04\x18\x04\0\x02\x04\x12\x04\xf4\
    \x01\x10\x1f\n\x0f\n\x07\x04\x18\x04\0\x02\x04\x01\x12\x04\xf4\x01\x10\
    \x1a\n\x0f\n\x07\x04\x18\x04\0\x02\x04\x02\x12\x04\xf4\x01\x1d\x1e\n\x0e\
    \n\x06\x04\x18\x04\0\x02\x05\x12\x04\xf5\x01\x10\"\n\x0f\n\x07\x04\x18\
    \x04\0\x02\x05\x01\x12\x04\xf5\x01\x10\x1d\n\x0f\n\x07\x04\x18\x04\0\x02\
    \x05\x02\x12\x04\xf5\x01\x20!\n\x0e\n\x06\x04\x18\x04\0\x02\x06\x12\x04\
    \xf6\x01\x10#\n\x0f\n\x07\x04\x18\x04\0\x02\x06\x01\x12\x04\xf6\x01\x10\
    \x1e\n\x0f\n\x07\x04\x18\x04\0\x02\x06\x02\x12\x04\xf6\x01!\"\n\x0c\n\
    \x04\x04\x18\x02\0\x12\x04\xf9\x01\x08Y\n\r\n\x05\x04\x18\x02\0\x04\x12\
    \x04\xf9\x01\x08\x10\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\xf9\x01\x11K\n\
    \r\n\x05\x04\x18\x02\0\x01\x12\x04\xf9\x01LT\n\r\n\x05\x04\x18\x02\0\x03\
    \x12\x04\xf9\x01WX\n\x0c\n\x02\x04\x19\x12\x06\xfc\x01\0\xff\x01\x01\n\
    \x0b\n\x03\x04\x19\x01\x12\x04\xfc\x01\x080\n\x0c\n\x04\x04\x19\x02\0\
    \x12\x04\xfd\x01\x08*\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xfd\x01\x08\
    \x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xfd\x01\x11\x17\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\xfd\x01\x18%\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \xfd\x01()\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xfe\x01\x08%\n\r\n\x05\
    \x04\x19\x02\x01\x04\x12\x04\xfe\x01\x08\x10\n\r\n\x05\x04\x19\x02\x01\
    \x05\x12\x04\xfe\x01\x11\x17\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xfe\
    \x01\x18\x20\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xfe\x01#$\n\x0c\n\x02\
    \x04\x1a\x12\x06\x81\x02\0\x8d\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\
    \x81\x02\x088\n\x0e\n\x04\x04\x1a\x04\0\x12\x06\x82\x02\x08\x8a\x02\t\n\
    \r\n\x05\x04\x1a\x04\0\x01\x12\x04\x82\x02\r\x16\n\x0e\n\x06\x04\x1a\x04\
    \0\x02\0\x12\x04\x83\x02\x10%\n\x0f\n\x07\x04\x1a\x04\0\x02\0\x01\x12\
    \x04\x83\x02\x10\x20\n\x0f\n\x07\x04\x1a\x04\0\x02\0\x02\x12\x04\x83\x02\
    #$\n\x0e\n\x06\x04\x1a\x04\0\x02\x01\x12\x04\x84\x02\x10\x1f\n\x0f\n\x07\
    \x04\x1a\x04\0\x02\x01\x01\x12\x04\x84\x02\x10\x1a\n\x0f\n\x07\x04\x1a\
    \x04\0\x02\x01\x02\x12\x04\x84\x02\x1d\x1e\n\x0e\n\x06\x04\x1a\x04\0\x02\
    \x02\x12\x04\x85\x02\x10\x1f\n\x0f\n\x07\x04\x1a\x04\0\x02\x02\x01\x12\
    \x04\x85\x02\x10\x1a\n\x0f\n\x07\x04\x1a\x04\0\x02\x02\x02\x12\x04\x85\
    \x02\x1d\x1e\n\x0e\n\x06\x04\x1a\x04\0\x02\x03\x12\x04\x86\x02\x10\x20\n\
    \x0f\n\x07\x04\x1a\x04\0\x02\x03\x01\x12\x04\x86\x02\x10\x1b\n\x0f\n\x07\
    \x04\x1a\x04\0\x02\x03\x02\x12\x04\x86\x02\x1e\x1f\n\x0e\n\x06\x04\x1a\
    \x04\0\x02\x04\x12\x04\x87\x02\x10\x1f\n\x0f\n\x07\x04\x1a\x04\0\x02\x04\
    \x01\x12\x04\x87\x02\x10\x1a\n\x0f\n\x07\x04\x1a\x04\0\x02\x04\x02\x12\
    \x04\x87\x02\x1d\x1e\n\x0e\n\x06\x04\x1a\x04\0\x02\x05\x12\x04\x88\x02\
    \x10\"\n\x0f\n\x07\x04\x1a\x04\0\x02\x05\x01\x12\x04\x88\x02\x10\x1d\n\
    \x0f\n\x07\x04\x1a\x04\0\x02\x05\x02\x12\x04\x88\x02\x20!\n\x0e\n\x06\
    \x04\x1a\x04\0\x02\x06\x12\x04\x89\x02\x10#\n\x0f\n\x07\x04\x1a\x04\0\
    \x02\x06\x01\x12\x04\x89\x02\x10\x1e\n\x0f\n\x07\x04\x1a\x04\0\x02\x06\
    \x02\x12\x04\x89\x02!\"\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x8c\x02\x08Y\n\
    \r\n\x05\x04\x1a\x02\0\x04\x12\x04\x8c\x02\x08\x10\n\r\n\x05\x04\x1a\x02\
    \0\x06\x12\x04\x8c\x02\x11K\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\x8c\x02L\
    T\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x8c\x02WX\n\x0c\n\x02\x04\x1b\x12\
    \x06\x8f\x02\0\x91\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\x8f\x02\x081\
    \n\x0c\n\x04\x04\x1b\x02\0\x12\x04\x90\x02\x08*\n\r\n\x05\x04\x1b\x02\0\
    \x04\x12\x04\x90\x02\x08\x10\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\x90\x02\
    \x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x90\x02\x18%\n\r\n\x05\x04\
    \x1b\x02\0\x03\x12\x04\x90\x02()\n\x0c\n\x02\x04\x1c\x12\x06\x93\x02\0\
    \x9f\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x93\x02\x089\n\x0e\n\x04\
    \x04\x1c\x04\0\x12\x06\x94\x02\x08\x9c\x02\t\n\r\n\x05\x04\x1c\x04\0\x01\
    \x12\x04\x94\x02\r\x16\n\x0e\n\x06\x04\x1c\x04\0\x02\0\x12\x04\x95\x02\
    \x10%\n\x0f\n\x07\x04\x1c\x04\0\x02\0\x01\x12\x04\x95\x02\x10\x20\n\x0f\
    \n\x07\x04\x1c\x04\0\x02\0\x02\x12\x04\x95\x02#$\n\x0e\n\x06\x04\x1c\x04\
    \0\x02\x01\x12\x04\x96\x02\x10\x1f\n\x0f\n\x07\x04\x1c\x04\0\x02\x01\x01\
    \x12\x04\x96\x02\x10\x1a\n\x0f\n\x07\x04\x1c\x04\0\x02\x01\x02\x12\x04\
    \x96\x02\x1d\x1e\n\x0e\n\x06\x04\x1c\x04\0\x02\x02\x12\x04\x97\x02\x10\
    \x1f\n\x0f\n\x07\x04\x1c\x04\0\x02\x02\x01\x12\x04\x97\x02\x10\x1a\n\x0f\
    \n\x07\x04\x1c\x04\0\x02\x02\x02\x12\x04\x97\x02\x1d\x1e\n\x0e\n\x06\x04\
    \x1c\x04\0\x02\x03\x12\x04\x98\x02\x10\x20\n\x0f\n\x07\x04\x1c\x04\0\x02\
    \x03\x01\x12\x04\x98\x02\x10\x1b\n\x0f\n\x07\x04\x1c\x04\0\x02\x03\x02\
    \x12\x04\x98\x02\x1e\x1f\n\x0e\n\x06\x04\x1c\x04\0\x02\x04\x12\x04\x99\
    \x02\x10\x1f\n\x0f\n\x07\x04\x1c\x04\0\x02\x04\x01\x12\x04\x99\x02\x10\
    \x1a\n\x0f\n\x07\x04\x1c\x04\0\x02\x04\x02\x12\x04\x99\x02\x1d\x1e\n\x0e\
    \n\x06\x04\x1c\x04\0\x02\x05\x12\x04\x9a\x02\x10\"\n\x0f\n\x07\x04\x1c\
    \x04\0\x02\x05\x01\x12\x04\x9a\x02\x10\x1d\n\x0f\n\x07\x04\x1c\x04\0\x02\
    \x05\x02\x12\x04\x9a\x02\x20!\n\x0e\n\x06\x04\x1c\x04\0\x02\x06\x12\x04\
    \x9b\x02\x10#\n\x0f\n\x07\x04\x1c\x04\0\x02\x06\x01\x12\x04\x9b\x02\x10\
    \x1e\n\x0f\n\x07\x04\x1c\x04\0\x02\x06\x02\x12\x04\x9b\x02!\"\n\x0c\n\
    \x04\x04\x1c\x02\0\x12\x04\x9e\x02\x08Z\n\r\n\x05\x04\x1c\x02\0\x04\x12\
    \x04\x9e\x02\x08\x10\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\x9e\x02\x11L\n\
    \r\n\x05\x04\x1c\x02\0\x01\x12\x04\x9e\x02MU\n\r\n\x05\x04\x1c\x02\0\x03\
    \x12\x04\x9e\x02XY\n\x0c\n\x02\x04\x1d\x12\x06\xa1\x02\0\xa4\x02\x01\n\
    \x0b\n\x03\x04\x1d\x01\x12\x04\xa1\x02\x084\n\x0c\n\x04\x04\x1d\x02\0\
    \x12\x04\xa2\x02\x08*\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xa2\x02\x08\
    \x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xa2\x02\x11\x17\n\r\n\x05\x04\
    \x1d\x02\0\x01\x12\x04\xa2\x02\x18%\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\
    \xa2\x02()\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xa3\x02\x08+\n\r\n\x05\
    \x04\x1d\x02\x01\x04\x12\x04\xa3\x02\x08\x10\n\r\n\x05\x04\x1d\x02\x01\
    \x05\x12\x04\xa3\x02\x11\x17\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xa3\
    \x02\x18&\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xa3\x02)*\n\x0c\n\x02\
    \x04\x1e\x12\x06\xa6\x02\0\xb2\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\
    \xa6\x02\x08<\n\x0e\n\x04\x04\x1e\x04\0\x12\x06\xa7\x02\x08\xaf\x02\t\n\
    \r\n\x05\x04\x1e\x04\0\x01\x12\x04\xa7\x02\r\x16\n\x0e\n\x06\x04\x1e\x04\
    \0\x02\0\x12\x04\xa8\x02\x10%\n\x0f\n\x07\x04\x1e\x04\0\x02\0\x01\x12\
    \x04\xa8\x02\x10\x20\n\x0f\n\x07\x04\x1e\x04\0\x02\0\x02\x12\x04\xa8\x02\
    #$\n\x0e\n\x06\x04\x1e\x04\0\x02\x01\x12\x04\xa9\x02\x10\x1f\n\x0f\n\x07\
    \x04\x1e\x04\0\x02\x01\x01\x12\x04\xa9\x02\x10\x1a\n\x0f\n\x07\x04\x1e\
    \x04\0\x02\x01\x02\x12\x04\xa9\x02\x1d\x1e\n\x0e\n\x06\x04\x1e\x04\0\x02\
    \x02\x12\x04\xaa\x02\x10\x1f\n\x0f\n\x07\x04\x1e\x04\0\x02\x02\x01\x12\
    \x04\xaa\x02\x10\x1a\n\x0f\n\x07\x04\x1e\x04\0\x02\x02\x02\x12\x04\xaa\
    \x02\x1d\x1e\n\x0e\n\x06\x04\x1e\x04\0\x02\x03\x12\x04\xab\x02\x10\x20\n\
    \x0f\n\x07\x04\x1e\x04\0\x02\x03\x01\x12\x04\xab\x02\x10\x1b\n\x0f\n\x07\
    \x04\x1e\x04\0\x02\x03\x02\x12\x04\xab\x02\x1e\x1f\n\x0e\n\x06\x04\x1e\
    \x04\0\x02\x04\x12\x04\xac\x02\x10\x1f\n\x0f\n\x07\x04\x1e\x04\0\x02\x04\
    \x01\x12\x04\xac\x02\x10\x1a\n\x0f\n\x07\x04\x1e\x04\0\x02\x04\x02\x12\
    \x04\xac\x02\x1d\x1e\n\x0e\n\x06\x04\x1e\x04\0\x02\x05\x12\x04\xad\x02\
    \x10\"\n\x0f\n\x07\x04\x1e\x04\0\x02\x05\x01\x12\x04\xad\x02\x10\x1d\n\
    \x0f\n\x07\x04\x1e\x04\0\x02\x05\x02\x12\x04\xad\x02\x20!\n\x0e\n\x06\
    \x04\x1e\x04\0\x02\x06\x12\x04\xae\x02\x10#\n\x0f\n\x07\x04\x1e\x04\0\
    \x02\x06\x01\x12\x04\xae\x02\x10\x1e\n\x0f\n\x07\x04\x1e\x04\0\x02\x06\
    \x02\x12\x04\xae\x02!\"\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xb1\x02\x08]\n\
    \r\n\x05\x04\x1e\x02\0\x04\x12\x04\xb1\x02\x08\x10\n\r\n\x05\x04\x1e\x02\
    \0\x06\x12\x04\xb1\x02\x11O\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xb1\x02P\
    X\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xb1\x02[\\\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(9);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common::file_descriptor().clone());
            deps.push(super::dota_gcmessages_webapi::file_descriptor().clone());
            deps.push(super::gcsdk_gcmessages::file_descriptor().clone());
            deps.push(super::base_gcmessages::file_descriptor().clone());
            deps.push(super::econ_gcmessages::file_descriptor().clone());
            deps.push(super::dota_gcmessages_client::file_descriptor().clone());
            deps.push(super::valveextensions::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(31);
            messages.push(CMsgCandyShopCandyCount::generated_message_descriptor_data());
            messages.push(CMsgCandyShopCandyQuantity::generated_message_descriptor_data());
            messages.push(CMsgCandyShopExchangeRecipe::generated_message_descriptor_data());
            messages.push(CMsgCandyShopRewardData_Item::generated_message_descriptor_data());
            messages.push(CMsgCandyShopRewardData_EventAction::generated_message_descriptor_data());
            messages.push(CMsgCandyShopRewardData_EventPoints::generated_message_descriptor_data());
            messages.push(CMsgCandyShopReward::generated_message_descriptor_data());
            messages.push(CMsgCandyShopUserData::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopGetUserData::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopGetUserDataResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientCandyShopUserDataUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopPurchaseReward::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopPurchaseRewardResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopOpenBags::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopOpenBagsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDoExchange::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDoExchangeResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDoVariableExchange::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDoVariableExchangeResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopRerollRewards::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopRerollRewardsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevGrantCandy::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevGrantCandyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevClearInventory::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevClearInventoryResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevGrantCandyBags::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevGrantCandyBagsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevShuffleExchange::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevShuffleExchangeResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevGrantRerollCharges::generated_message_descriptor_data());
            messages.push(CMsgClientToGCCandyShopDevGrantRerollChargesResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(13);
            enums.push(ECandyShopAuditAction::generated_enum_descriptor_data());
            enums.push(ECandyShopRewardType::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_get_user_data_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_purchase_reward_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_open_bags_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_do_exchange_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_do_variable_exchange_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_reroll_rewards_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_dev_grant_candy_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_dev_clear_inventory_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_dev_grant_candy_bags_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_dev_shuffle_exchange_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gccandy_shop_dev_grant_reroll_charges_response::EResponse::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
