// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_usermessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_AIDebugLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AIDebugLine {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AIDebugLine.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_AIDebugLine.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AIDebugLine {
    fn default() -> &'a CDOTAUserMsg_AIDebugLine {
        <CDOTAUserMsg_AIDebugLine as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AIDebugLine {
    pub fn new() -> CDOTAUserMsg_AIDebugLine {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CDOTAUserMsg_AIDebugLine| { &m.message },
            |m: &mut CDOTAUserMsg_AIDebugLine| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_AIDebugLine>(
            "CDOTAUserMsg_AIDebugLine",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AIDebugLine {
    const NAME: &'static str = "CDOTAUserMsg_AIDebugLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AIDebugLine {
        CDOTAUserMsg_AIDebugLine::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AIDebugLine {
        static instance: CDOTAUserMsg_AIDebugLine = CDOTAUserMsg_AIDebugLine {
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_AIDebugLine {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_AIDebugLine").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_AIDebugLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AIDebugLine {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_Ping)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_Ping {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_Ping.ping)
    pub ping: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_Ping.loss)
    pub loss: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_Ping.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_Ping {
    fn default() -> &'a CDOTAUserMsg_Ping {
        <CDOTAUserMsg_Ping as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_Ping {
    pub fn new() -> CDOTAUserMsg_Ping {
        ::std::default::Default::default()
    }

    // optional uint32 ping = 2;

    pub fn ping(&self) -> u32 {
        self.ping.unwrap_or(0)
    }

    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: u32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional uint32 loss = 3;

    pub fn loss(&self) -> u32 {
        self.loss.unwrap_or(0)
    }

    pub fn clear_loss(&mut self) {
        self.loss = ::std::option::Option::None;
    }

    pub fn has_loss(&self) -> bool {
        self.loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loss(&mut self, v: u32) {
        self.loss = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping",
            |m: &CDOTAUserMsg_Ping| { &m.ping },
            |m: &mut CDOTAUserMsg_Ping| { &mut m.ping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loss",
            |m: &CDOTAUserMsg_Ping| { &m.loss },
            |m: &mut CDOTAUserMsg_Ping| { &mut m.loss },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_Ping>(
            "CDOTAUserMsg_Ping",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_Ping {
    const NAME: &'static str = "CDOTAUserMsg_Ping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.ping = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.loss = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.loss {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ping {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.loss {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_Ping {
        CDOTAUserMsg_Ping::new()
    }

    fn clear(&mut self) {
        self.ping = ::std::option::Option::None;
        self.loss = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_Ping {
        static instance: CDOTAUserMsg_Ping = CDOTAUserMsg_Ping {
            ping: ::std::option::Option::None,
            loss: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_Ping {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_Ping").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_Ping {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SwapVerify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SwapVerify {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SwapVerify.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SwapVerify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SwapVerify {
    fn default() -> &'a CDOTAUserMsg_SwapVerify {
        <CDOTAUserMsg_SwapVerify as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SwapVerify {
    pub fn new() -> CDOTAUserMsg_SwapVerify {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_SwapVerify| { &m.player_id },
            |m: &mut CDOTAUserMsg_SwapVerify| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SwapVerify>(
            "CDOTAUserMsg_SwapVerify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SwapVerify {
    const NAME: &'static str = "CDOTAUserMsg_SwapVerify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SwapVerify {
        CDOTAUserMsg_SwapVerify::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SwapVerify {
        static instance: CDOTAUserMsg_SwapVerify = CDOTAUserMsg_SwapVerify {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SwapVerify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SwapVerify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SwapVerify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SwapVerify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ChatEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ChatEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<DOTA_CHAT_MESSAGE>>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.playerid_1)
    pub playerid_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.playerid_2)
    pub playerid_2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.playerid_3)
    pub playerid_3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.playerid_4)
    pub playerid_4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.playerid_5)
    pub playerid_5: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.playerid_6)
    pub playerid_6: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.value2)
    pub value2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatEvent.value3)
    pub value3: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ChatEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ChatEvent {
    fn default() -> &'a CDOTAUserMsg_ChatEvent {
        <CDOTAUserMsg_ChatEvent as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ChatEvent {
    pub fn new() -> CDOTAUserMsg_ChatEvent {
        ::std::default::Default::default()
    }

    // required .dota.DOTA_CHAT_MESSAGE type = 1;

    pub fn type_(&self) -> DOTA_CHAT_MESSAGE {
        match self.type_ {
            Some(e) => e.enum_value_or(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID),
            None => DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: DOTA_CHAT_MESSAGE) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 value = 2;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_1 = 3;

    pub fn playerid_1(&self) -> i32 {
        self.playerid_1.unwrap_or(0)
    }

    pub fn clear_playerid_1(&mut self) {
        self.playerid_1 = ::std::option::Option::None;
    }

    pub fn has_playerid_1(&self) -> bool {
        self.playerid_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_1(&mut self, v: i32) {
        self.playerid_1 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_2 = 4;

    pub fn playerid_2(&self) -> i32 {
        self.playerid_2.unwrap_or(0)
    }

    pub fn clear_playerid_2(&mut self) {
        self.playerid_2 = ::std::option::Option::None;
    }

    pub fn has_playerid_2(&self) -> bool {
        self.playerid_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_2(&mut self, v: i32) {
        self.playerid_2 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_3 = 5;

    pub fn playerid_3(&self) -> i32 {
        self.playerid_3.unwrap_or(0)
    }

    pub fn clear_playerid_3(&mut self) {
        self.playerid_3 = ::std::option::Option::None;
    }

    pub fn has_playerid_3(&self) -> bool {
        self.playerid_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_3(&mut self, v: i32) {
        self.playerid_3 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_4 = 6;

    pub fn playerid_4(&self) -> i32 {
        self.playerid_4.unwrap_or(0)
    }

    pub fn clear_playerid_4(&mut self) {
        self.playerid_4 = ::std::option::Option::None;
    }

    pub fn has_playerid_4(&self) -> bool {
        self.playerid_4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_4(&mut self, v: i32) {
        self.playerid_4 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_5 = 7;

    pub fn playerid_5(&self) -> i32 {
        self.playerid_5.unwrap_or(0)
    }

    pub fn clear_playerid_5(&mut self) {
        self.playerid_5 = ::std::option::Option::None;
    }

    pub fn has_playerid_5(&self) -> bool {
        self.playerid_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_5(&mut self, v: i32) {
        self.playerid_5 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_6 = 8;

    pub fn playerid_6(&self) -> i32 {
        self.playerid_6.unwrap_or(0)
    }

    pub fn clear_playerid_6(&mut self) {
        self.playerid_6 = ::std::option::Option::None;
    }

    pub fn has_playerid_6(&self) -> bool {
        self.playerid_6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_6(&mut self, v: i32) {
        self.playerid_6 = ::std::option::Option::Some(v);
    }

    // optional uint32 value2 = 9;

    pub fn value2(&self) -> u32 {
        self.value2.unwrap_or(0)
    }

    pub fn clear_value2(&mut self) {
        self.value2 = ::std::option::Option::None;
    }

    pub fn has_value2(&self) -> bool {
        self.value2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value2(&mut self, v: u32) {
        self.value2 = ::std::option::Option::Some(v);
    }

    // optional uint32 value3 = 10;

    pub fn value3(&self) -> u32 {
        self.value3.unwrap_or(0)
    }

    pub fn clear_value3(&mut self) {
        self.value3 = ::std::option::Option::None;
    }

    pub fn has_value3(&self) -> bool {
        self.value3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value3(&mut self, v: u32) {
        self.value3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CDOTAUserMsg_ChatEvent| { &m.type_ },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CDOTAUserMsg_ChatEvent| { &m.value },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playerid_1",
            |m: &CDOTAUserMsg_ChatEvent| { &m.playerid_1 },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.playerid_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playerid_2",
            |m: &CDOTAUserMsg_ChatEvent| { &m.playerid_2 },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.playerid_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playerid_3",
            |m: &CDOTAUserMsg_ChatEvent| { &m.playerid_3 },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.playerid_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playerid_4",
            |m: &CDOTAUserMsg_ChatEvent| { &m.playerid_4 },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.playerid_4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playerid_5",
            |m: &CDOTAUserMsg_ChatEvent| { &m.playerid_5 },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.playerid_5 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playerid_6",
            |m: &CDOTAUserMsg_ChatEvent| { &m.playerid_6 },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.playerid_6 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value2",
            |m: &CDOTAUserMsg_ChatEvent| { &m.value2 },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.value2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value3",
            |m: &CDOTAUserMsg_ChatEvent| { &m.value3 },
            |m: &mut CDOTAUserMsg_ChatEvent| { &mut m.value3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ChatEvent>(
            "CDOTAUserMsg_ChatEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ChatEvent {
    const NAME: &'static str = "CDOTAUserMsg_ChatEvent";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.playerid_1 = ::std::option::Option::Some(is.read_sint32()?);
                },
                32 => {
                    self.playerid_2 = ::std::option::Option::Some(is.read_sint32()?);
                },
                40 => {
                    self.playerid_3 = ::std::option::Option::Some(is.read_sint32()?);
                },
                48 => {
                    self.playerid_4 = ::std::option::Option::Some(is.read_sint32()?);
                },
                56 => {
                    self.playerid_5 = ::std::option::Option::Some(is.read_sint32()?);
                },
                64 => {
                    self.playerid_6 = ::std::option::Option::Some(is.read_sint32()?);
                },
                72 => {
                    self.value2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.value3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.playerid_1 {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        if let Some(v) = self.playerid_2 {
            my_size += ::protobuf::rt::sint32_size(4, v);
        }
        if let Some(v) = self.playerid_3 {
            my_size += ::protobuf::rt::sint32_size(5, v);
        }
        if let Some(v) = self.playerid_4 {
            my_size += ::protobuf::rt::sint32_size(6, v);
        }
        if let Some(v) = self.playerid_5 {
            my_size += ::protobuf::rt::sint32_size(7, v);
        }
        if let Some(v) = self.playerid_6 {
            my_size += ::protobuf::rt::sint32_size(8, v);
        }
        if let Some(v) = self.value2 {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.value3 {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.playerid_1 {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.playerid_2 {
            os.write_sint32(4, v)?;
        }
        if let Some(v) = self.playerid_3 {
            os.write_sint32(5, v)?;
        }
        if let Some(v) = self.playerid_4 {
            os.write_sint32(6, v)?;
        }
        if let Some(v) = self.playerid_5 {
            os.write_sint32(7, v)?;
        }
        if let Some(v) = self.playerid_6 {
            os.write_sint32(8, v)?;
        }
        if let Some(v) = self.value2 {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.value3 {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ChatEvent {
        CDOTAUserMsg_ChatEvent::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.playerid_1 = ::std::option::Option::None;
        self.playerid_2 = ::std::option::Option::None;
        self.playerid_3 = ::std::option::Option::None;
        self.playerid_4 = ::std::option::Option::None;
        self.playerid_5 = ::std::option::Option::None;
        self.playerid_6 = ::std::option::Option::None;
        self.value2 = ::std::option::Option::None;
        self.value3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ChatEvent {
        static instance: CDOTAUserMsg_ChatEvent = CDOTAUserMsg_ChatEvent {
            type_: ::std::option::Option::None,
            value: ::std::option::Option::None,
            playerid_1: ::std::option::Option::None,
            playerid_2: ::std::option::Option::None,
            playerid_3: ::std::option::Option::None,
            playerid_4: ::std::option::Option::None,
            playerid_5: ::std::option::Option::None,
            playerid_6: ::std::option::Option::None,
            value2: ::std::option::Option::None,
            value3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ChatEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ChatEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ChatEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ChatEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_BotChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BotChat {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BotChat.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BotChat.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BotChat.target)
    pub target: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BotChat.team_only)
    pub team_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_BotChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BotChat {
    fn default() -> &'a CDOTAUserMsg_BotChat {
        <CDOTAUserMsg_BotChat as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BotChat {
    pub fn new() -> CDOTAUserMsg_BotChat {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string target = 4;

    pub fn target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool team_only = 5;

    pub fn team_only(&self) -> bool {
        self.team_only.unwrap_or(false)
    }

    pub fn clear_team_only(&mut self) {
        self.team_only = ::std::option::Option::None;
    }

    pub fn has_team_only(&self) -> bool {
        self.team_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_only(&mut self, v: bool) {
        self.team_only = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_BotChat| { &m.player_id },
            |m: &mut CDOTAUserMsg_BotChat| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CDOTAUserMsg_BotChat| { &m.message },
            |m: &mut CDOTAUserMsg_BotChat| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target",
            |m: &CDOTAUserMsg_BotChat| { &m.target },
            |m: &mut CDOTAUserMsg_BotChat| { &mut m.target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_only",
            |m: &CDOTAUserMsg_BotChat| { &m.team_only },
            |m: &mut CDOTAUserMsg_BotChat| { &mut m.team_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_BotChat>(
            "CDOTAUserMsg_BotChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BotChat {
    const NAME: &'static str = "CDOTAUserMsg_BotChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.target = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.team_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.team_only {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.target.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.team_only {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BotChat {
        CDOTAUserMsg_BotChat::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.team_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BotChat {
        static instance: CDOTAUserMsg_BotChat = CDOTAUserMsg_BotChat {
            player_id: ::std::option::Option::None,
            message: ::std::option::Option::None,
            target: ::std::option::Option::None,
            team_only: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_BotChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_BotChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_BotChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BotChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CombatHeroPositions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CombatHeroPositions {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CombatHeroPositions.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CombatHeroPositions.time)
    pub time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CombatHeroPositions.world_pos)
    pub world_pos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector2D>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CombatHeroPositions.health)
    pub health: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CombatHeroPositions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CombatHeroPositions {
    fn default() -> &'a CDOTAUserMsg_CombatHeroPositions {
        <CDOTAUserMsg_CombatHeroPositions as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CombatHeroPositions {
    pub fn new() -> CDOTAUserMsg_CombatHeroPositions {
        ::std::default::Default::default()
    }

    // optional uint32 index = 1;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 time = 2;

    pub fn time(&self) -> i32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }

    // optional int32 health = 4;

    pub fn health(&self) -> i32 {
        self.health.unwrap_or(0)
    }

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CDOTAUserMsg_CombatHeroPositions| { &m.index },
            |m: &mut CDOTAUserMsg_CombatHeroPositions| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &CDOTAUserMsg_CombatHeroPositions| { &m.time },
            |m: &mut CDOTAUserMsg_CombatHeroPositions| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector2D>(
            "world_pos",
            |m: &CDOTAUserMsg_CombatHeroPositions| { &m.world_pos },
            |m: &mut CDOTAUserMsg_CombatHeroPositions| { &mut m.world_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health",
            |m: &CDOTAUserMsg_CombatHeroPositions| { &m.health },
            |m: &mut CDOTAUserMsg_CombatHeroPositions| { &mut m.health },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CombatHeroPositions>(
            "CDOTAUserMsg_CombatHeroPositions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CombatHeroPositions {
    const NAME: &'static str = "CDOTAUserMsg_CombatHeroPositions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.time = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.world_pos)?;
                },
                32 => {
                    self.health = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.health {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.world_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.health {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CombatHeroPositions {
        CDOTAUserMsg_CombatHeroPositions::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.world_pos.clear();
        self.health = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CombatHeroPositions {
        static instance: CDOTAUserMsg_CombatHeroPositions = CDOTAUserMsg_CombatHeroPositions {
            index: ::std::option::Option::None,
            time: ::std::option::Option::None,
            world_pos: ::protobuf::MessageField::none(),
            health: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CombatHeroPositions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CombatHeroPositions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CombatHeroPositions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CombatHeroPositions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CombatLogBulkData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CombatLogBulkData {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CombatLogBulkData.combat_entries)
    pub combat_entries: ::std::vec::Vec<super::dota_shared_enums::CMsgDOTACombatLogEntry>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CombatLogBulkData.timestamp)
    pub timestamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CombatLogBulkData.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CombatLogBulkData.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CombatLogBulkData.request_time)
    pub request_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CombatLogBulkData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CombatLogBulkData {
    fn default() -> &'a CDOTAUserMsg_CombatLogBulkData {
        <CDOTAUserMsg_CombatLogBulkData as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CombatLogBulkData {
    pub fn new() -> CDOTAUserMsg_CombatLogBulkData {
        ::std::default::Default::default()
    }

    // optional float timestamp = 2;

    pub fn timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 player_id = 4;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float request_time = 5;

    pub fn request_time(&self) -> f32 {
        self.request_time.unwrap_or(0.)
    }

    pub fn clear_request_time(&mut self) {
        self.request_time = ::std::option::Option::None;
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: f32) {
        self.request_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "combat_entries",
            |m: &CDOTAUserMsg_CombatLogBulkData| { &m.combat_entries },
            |m: &mut CDOTAUserMsg_CombatLogBulkData| { &mut m.combat_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CDOTAUserMsg_CombatLogBulkData| { &m.timestamp },
            |m: &mut CDOTAUserMsg_CombatLogBulkData| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CDOTAUserMsg_CombatLogBulkData| { &m.duration },
            |m: &mut CDOTAUserMsg_CombatLogBulkData| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_CombatLogBulkData| { &m.player_id },
            |m: &mut CDOTAUserMsg_CombatLogBulkData| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_time",
            |m: &CDOTAUserMsg_CombatLogBulkData| { &m.request_time },
            |m: &mut CDOTAUserMsg_CombatLogBulkData| { &mut m.request_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CombatLogBulkData>(
            "CDOTAUserMsg_CombatLogBulkData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CombatLogBulkData {
    const NAME: &'static str = "CDOTAUserMsg_CombatLogBulkData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.combat_entries.push(is.read_message()?);
                },
                21 => {
                    self.timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                45 => {
                    self.request_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.combat_entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.request_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.combat_entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.timestamp {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.request_time {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CombatLogBulkData {
        CDOTAUserMsg_CombatLogBulkData::new()
    }

    fn clear(&mut self) {
        self.combat_entries.clear();
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.request_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CombatLogBulkData {
        static instance: CDOTAUserMsg_CombatLogBulkData = CDOTAUserMsg_CombatLogBulkData {
            combat_entries: ::std::vec::Vec::new(),
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            request_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CombatLogBulkData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CombatLogBulkData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CombatLogBulkData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CombatLogBulkData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ProjectileParticleCPData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ProjectileParticleCPData {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectileParticleCPData.control_point)
    pub control_point: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectileParticleCPData.vector)
    pub vector: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ProjectileParticleCPData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ProjectileParticleCPData {
    fn default() -> &'a CDOTAUserMsg_ProjectileParticleCPData {
        <CDOTAUserMsg_ProjectileParticleCPData as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ProjectileParticleCPData {
    pub fn new() -> CDOTAUserMsg_ProjectileParticleCPData {
        ::std::default::Default::default()
    }

    // optional int32 control_point = 1;

    pub fn control_point(&self) -> i32 {
        self.control_point.unwrap_or(0)
    }

    pub fn clear_control_point(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "control_point",
            |m: &CDOTAUserMsg_ProjectileParticleCPData| { &m.control_point },
            |m: &mut CDOTAUserMsg_ProjectileParticleCPData| { &mut m.control_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "vector",
            |m: &CDOTAUserMsg_ProjectileParticleCPData| { &m.vector },
            |m: &mut CDOTAUserMsg_ProjectileParticleCPData| { &mut m.vector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ProjectileParticleCPData>(
            "CDOTAUserMsg_ProjectileParticleCPData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ProjectileParticleCPData {
    const NAME: &'static str = "CDOTAUserMsg_ProjectileParticleCPData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.control_point = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vector)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.control_point {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.vector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.control_point {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.vector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ProjectileParticleCPData {
        CDOTAUserMsg_ProjectileParticleCPData::new()
    }

    fn clear(&mut self) {
        self.control_point = ::std::option::Option::None;
        self.vector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ProjectileParticleCPData {
        static instance: CDOTAUserMsg_ProjectileParticleCPData = CDOTAUserMsg_ProjectileParticleCPData {
            control_point: ::std::option::Option::None,
            vector: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ProjectileParticleCPData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ProjectileParticleCPData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ProjectileParticleCPData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ProjectileParticleCPData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_MiniKillCamInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MiniKillCamInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MiniKillCamInfo.attackers)
    pub attackers: ::std::vec::Vec<cdotauser_msg_mini_kill_cam_info::Attacker>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MiniKillCamInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MiniKillCamInfo {
    fn default() -> &'a CDOTAUserMsg_MiniKillCamInfo {
        <CDOTAUserMsg_MiniKillCamInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MiniKillCamInfo {
    pub fn new() -> CDOTAUserMsg_MiniKillCamInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attackers",
            |m: &CDOTAUserMsg_MiniKillCamInfo| { &m.attackers },
            |m: &mut CDOTAUserMsg_MiniKillCamInfo| { &mut m.attackers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_MiniKillCamInfo>(
            "CDOTAUserMsg_MiniKillCamInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MiniKillCamInfo {
    const NAME: &'static str = "CDOTAUserMsg_MiniKillCamInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.attackers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.attackers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.attackers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MiniKillCamInfo {
        CDOTAUserMsg_MiniKillCamInfo::new()
    }

    fn clear(&mut self) {
        self.attackers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MiniKillCamInfo {
        static instance: CDOTAUserMsg_MiniKillCamInfo = CDOTAUserMsg_MiniKillCamInfo {
            attackers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_MiniKillCamInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MiniKillCamInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_MiniKillCamInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MiniKillCamInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_MiniKillCamInfo`
pub mod cdotauser_msg_mini_kill_cam_info {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Attacker {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker.attacker)
        pub attacker: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker.total_damage)
        pub total_damage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker.abilities)
        pub abilities: ::std::vec::Vec<attacker::Ability>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker.attacker_name)
        pub attacker_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Attacker {
        fn default() -> &'a Attacker {
            <Attacker as ::protobuf::Message>::default_instance()
        }
    }

    impl Attacker {
        pub fn new() -> Attacker {
            ::std::default::Default::default()
        }

        // optional uint32 attacker = 1;

        pub fn attacker(&self) -> u32 {
            self.attacker.unwrap_or(0)
        }

        pub fn clear_attacker(&mut self) {
            self.attacker = ::std::option::Option::None;
        }

        pub fn has_attacker(&self) -> bool {
            self.attacker.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attacker(&mut self, v: u32) {
            self.attacker = ::std::option::Option::Some(v);
        }

        // optional int32 total_damage = 2;

        pub fn total_damage(&self) -> i32 {
            self.total_damage.unwrap_or(0)
        }

        pub fn clear_total_damage(&mut self) {
            self.total_damage = ::std::option::Option::None;
        }

        pub fn has_total_damage(&self) -> bool {
            self.total_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_damage(&mut self, v: i32) {
            self.total_damage = ::std::option::Option::Some(v);
        }

        // optional string attacker_name = 4;

        pub fn attacker_name(&self) -> &str {
            match self.attacker_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_attacker_name(&mut self) {
            self.attacker_name = ::std::option::Option::None;
        }

        pub fn has_attacker_name(&self) -> bool {
            self.attacker_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attacker_name(&mut self, v: ::std::string::String) {
            self.attacker_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_attacker_name(&mut self) -> &mut ::std::string::String {
            if self.attacker_name.is_none() {
                self.attacker_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.attacker_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_attacker_name(&mut self) -> ::std::string::String {
            self.attacker_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "attacker",
                |m: &Attacker| { &m.attacker },
                |m: &mut Attacker| { &mut m.attacker },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_damage",
                |m: &Attacker| { &m.total_damage },
                |m: &mut Attacker| { &mut m.total_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "abilities",
                |m: &Attacker| { &m.abilities },
                |m: &mut Attacker| { &mut m.abilities },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "attacker_name",
                |m: &Attacker| { &m.attacker_name },
                |m: &mut Attacker| { &mut m.attacker_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Attacker>(
                "CDOTAUserMsg_MiniKillCamInfo.Attacker",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Attacker {
        const NAME: &'static str = "Attacker";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.attacker = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_damage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.abilities.push(is.read_message()?);
                    },
                    34 => {
                        self.attacker_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.attacker {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_damage {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            for value in &self.abilities {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.attacker_name.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.attacker {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_damage {
                os.write_int32(2, v)?;
            }
            for v in &self.abilities {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.attacker_name.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Attacker {
            Attacker::new()
        }

        fn clear(&mut self) {
            self.attacker = ::std::option::Option::None;
            self.total_damage = ::std::option::Option::None;
            self.abilities.clear();
            self.attacker_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Attacker {
            static instance: Attacker = Attacker {
                attacker: ::std::option::Option::None,
                total_damage: ::std::option::Option::None,
                abilities: ::std::vec::Vec::new(),
                attacker_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Attacker {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MiniKillCamInfo.Attacker").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Attacker {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Attacker {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Attacker`
    pub mod attacker {
        // @@protoc_insertion_point(message:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Ability {
            // message fields
            // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.ability_id)
            pub ability_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.damage)
            pub damage: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Ability {
            fn default() -> &'a Ability {
                <Ability as ::protobuf::Message>::default_instance()
            }
        }

        impl Ability {
            pub fn new() -> Ability {
                ::std::default::Default::default()
            }

            // optional int32 ability_id = 1;

            pub fn ability_id(&self) -> i32 {
                self.ability_id.unwrap_or(0)
            }

            pub fn clear_ability_id(&mut self) {
                self.ability_id = ::std::option::Option::None;
            }

            pub fn has_ability_id(&self) -> bool {
                self.ability_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ability_id(&mut self, v: i32) {
                self.ability_id = ::std::option::Option::Some(v);
            }

            // optional int32 damage = 2;

            pub fn damage(&self) -> i32 {
                self.damage.unwrap_or(0)
            }

            pub fn clear_damage(&mut self) {
                self.damage = ::std::option::Option::None;
            }

            pub fn has_damage(&self) -> bool {
                self.damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_damage(&mut self, v: i32) {
                self.damage = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "ability_id",
                    |m: &Ability| { &m.ability_id },
                    |m: &mut Ability| { &mut m.ability_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "damage",
                    |m: &Ability| { &m.damage },
                    |m: &mut Ability| { &mut m.damage },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ability>(
                    "CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Ability {
            const NAME: &'static str = "Ability";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.damage = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.ability_id {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.damage {
                    my_size += ::protobuf::rt::int32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.ability_id {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.damage {
                    os.write_int32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Ability {
                Ability::new()
            }

            fn clear(&mut self) {
                self.ability_id = ::std::option::Option::None;
                self.damage = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Ability {
                static instance: Ability = Ability {
                    ability_id: ::std::option::Option::None,
                    damage: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Ability {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Ability {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Ability {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_GlobalLightColor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GlobalLightColor {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GlobalLightColor.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GlobalLightColor.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_GlobalLightColor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GlobalLightColor {
    fn default() -> &'a CDOTAUserMsg_GlobalLightColor {
        <CDOTAUserMsg_GlobalLightColor as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GlobalLightColor {
    pub fn new() -> CDOTAUserMsg_GlobalLightColor {
        ::std::default::Default::default()
    }

    // optional uint32 color = 1;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CDOTAUserMsg_GlobalLightColor| { &m.color },
            |m: &mut CDOTAUserMsg_GlobalLightColor| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CDOTAUserMsg_GlobalLightColor| { &m.duration },
            |m: &mut CDOTAUserMsg_GlobalLightColor| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_GlobalLightColor>(
            "CDOTAUserMsg_GlobalLightColor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GlobalLightColor {
    const NAME: &'static str = "CDOTAUserMsg_GlobalLightColor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.color {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GlobalLightColor {
        CDOTAUserMsg_GlobalLightColor::new()
    }

    fn clear(&mut self) {
        self.color = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GlobalLightColor {
        static instance: CDOTAUserMsg_GlobalLightColor = CDOTAUserMsg_GlobalLightColor {
            color: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_GlobalLightColor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_GlobalLightColor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_GlobalLightColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_GlobalLightColor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_GlobalLightDirection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GlobalLightDirection {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GlobalLightDirection.direction)
    pub direction: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GlobalLightDirection.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_GlobalLightDirection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GlobalLightDirection {
    fn default() -> &'a CDOTAUserMsg_GlobalLightDirection {
        <CDOTAUserMsg_GlobalLightDirection as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GlobalLightDirection {
    pub fn new() -> CDOTAUserMsg_GlobalLightDirection {
        ::std::default::Default::default()
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "direction",
            |m: &CDOTAUserMsg_GlobalLightDirection| { &m.direction },
            |m: &mut CDOTAUserMsg_GlobalLightDirection| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CDOTAUserMsg_GlobalLightDirection| { &m.duration },
            |m: &mut CDOTAUserMsg_GlobalLightDirection| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_GlobalLightDirection>(
            "CDOTAUserMsg_GlobalLightDirection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GlobalLightDirection {
    const NAME: &'static str = "CDOTAUserMsg_GlobalLightDirection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.direction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GlobalLightDirection {
        CDOTAUserMsg_GlobalLightDirection::new()
    }

    fn clear(&mut self) {
        self.direction.clear();
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GlobalLightDirection {
        static instance: CDOTAUserMsg_GlobalLightDirection = CDOTAUserMsg_GlobalLightDirection {
            direction: ::protobuf::MessageField::none(),
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_GlobalLightDirection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_GlobalLightDirection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_GlobalLightDirection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_GlobalLightDirection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_LocationPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_LocationPing {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_LocationPing.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_LocationPing.location_ping)
    pub location_ping: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_LocationPing>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_LocationPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_LocationPing {
    fn default() -> &'a CDOTAUserMsg_LocationPing {
        <CDOTAUserMsg_LocationPing as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_LocationPing {
    pub fn new() -> CDOTAUserMsg_LocationPing {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_LocationPing| { &m.player_id },
            |m: &mut CDOTAUserMsg_LocationPing| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_LocationPing>(
            "location_ping",
            |m: &CDOTAUserMsg_LocationPing| { &m.location_ping },
            |m: &mut CDOTAUserMsg_LocationPing| { &mut m.location_ping },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_LocationPing>(
            "CDOTAUserMsg_LocationPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_LocationPing {
    const NAME: &'static str = "CDOTAUserMsg_LocationPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location_ping)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.location_ping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.location_ping.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_LocationPing {
        CDOTAUserMsg_LocationPing::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.location_ping.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_LocationPing {
        static instance: CDOTAUserMsg_LocationPing = CDOTAUserMsg_LocationPing {
            player_id: ::std::option::Option::None,
            location_ping: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_LocationPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_LocationPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_LocationPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_LocationPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_PingConfirmation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PingConfirmation {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PingConfirmation.player_id_of_original_pinger)
    pub player_id_of_original_pinger: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PingConfirmation.entity_index)
    pub entity_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PingConfirmation.icon_type)
    pub icon_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PingConfirmation.location)
    pub location: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_PingConfirmation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PingConfirmation {
    fn default() -> &'a CDOTAUserMsg_PingConfirmation {
        <CDOTAUserMsg_PingConfirmation as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PingConfirmation {
    pub fn new() -> CDOTAUserMsg_PingConfirmation {
        ::std::default::Default::default()
    }

    // optional int32 player_id_of_original_pinger = 1;

    pub fn player_id_of_original_pinger(&self) -> i32 {
        self.player_id_of_original_pinger.unwrap_or(0)
    }

    pub fn clear_player_id_of_original_pinger(&mut self) {
        self.player_id_of_original_pinger = ::std::option::Option::None;
    }

    pub fn has_player_id_of_original_pinger(&self) -> bool {
        self.player_id_of_original_pinger.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_of_original_pinger(&mut self, v: i32) {
        self.player_id_of_original_pinger = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_index = 2;

    pub fn entity_index(&self) -> u32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: u32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional uint32 icon_type = 3;

    pub fn icon_type(&self) -> u32 {
        self.icon_type.unwrap_or(0)
    }

    pub fn clear_icon_type(&mut self) {
        self.icon_type = ::std::option::Option::None;
    }

    pub fn has_icon_type(&self) -> bool {
        self.icon_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_type(&mut self, v: u32) {
        self.icon_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_of_original_pinger",
            |m: &CDOTAUserMsg_PingConfirmation| { &m.player_id_of_original_pinger },
            |m: &mut CDOTAUserMsg_PingConfirmation| { &mut m.player_id_of_original_pinger },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CDOTAUserMsg_PingConfirmation| { &m.entity_index },
            |m: &mut CDOTAUserMsg_PingConfirmation| { &mut m.entity_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon_type",
            |m: &CDOTAUserMsg_PingConfirmation| { &m.icon_type },
            |m: &mut CDOTAUserMsg_PingConfirmation| { &mut m.icon_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "location",
            |m: &CDOTAUserMsg_PingConfirmation| { &m.location },
            |m: &mut CDOTAUserMsg_PingConfirmation| { &mut m.location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_PingConfirmation>(
            "CDOTAUserMsg_PingConfirmation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_PingConfirmation {
    const NAME: &'static str = "CDOTAUserMsg_PingConfirmation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_of_original_pinger = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.entity_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.icon_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_of_original_pinger {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.icon_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_of_original_pinger {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entity_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.icon_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.location.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PingConfirmation {
        CDOTAUserMsg_PingConfirmation::new()
    }

    fn clear(&mut self) {
        self.player_id_of_original_pinger = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.icon_type = ::std::option::Option::None;
        self.location.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PingConfirmation {
        static instance: CDOTAUserMsg_PingConfirmation = CDOTAUserMsg_PingConfirmation {
            player_id_of_original_pinger: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            icon_type: ::std::option::Option::None,
            location: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_PingConfirmation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_PingConfirmation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_PingConfirmation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PingConfirmation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ItemAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ItemAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ItemAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ItemAlert.item_alert)
    pub item_alert: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_ItemAlert>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ItemAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ItemAlert {
    fn default() -> &'a CDOTAUserMsg_ItemAlert {
        <CDOTAUserMsg_ItemAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ItemAlert {
    pub fn new() -> CDOTAUserMsg_ItemAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_ItemAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_ItemAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_ItemAlert>(
            "item_alert",
            |m: &CDOTAUserMsg_ItemAlert| { &m.item_alert },
            |m: &mut CDOTAUserMsg_ItemAlert| { &mut m.item_alert },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ItemAlert>(
            "CDOTAUserMsg_ItemAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ItemAlert {
    const NAME: &'static str = "CDOTAUserMsg_ItemAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item_alert)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_alert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_alert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ItemAlert {
        CDOTAUserMsg_ItemAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.item_alert.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ItemAlert {
        static instance: CDOTAUserMsg_ItemAlert = CDOTAUserMsg_ItemAlert {
            player_id: ::std::option::Option::None,
            item_alert: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ItemAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ItemAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ItemAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ItemAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_EnemyItemAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_EnemyItemAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EnemyItemAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EnemyItemAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EnemyItemAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EnemyItemAlert.rune_type)
    pub rune_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EnemyItemAlert.entity_id)
    pub entity_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EnemyItemAlert.item_level)
    pub item_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EnemyItemAlert.primary_charges)
    pub primary_charges: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EnemyItemAlert.secondary_charges)
    pub secondary_charges: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_EnemyItemAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_EnemyItemAlert {
    fn default() -> &'a CDOTAUserMsg_EnemyItemAlert {
        <CDOTAUserMsg_EnemyItemAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_EnemyItemAlert {
    pub fn new() -> CDOTAUserMsg_EnemyItemAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 3;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 rune_type = 4;

    pub fn rune_type(&self) -> i32 {
        self.rune_type.unwrap_or(0)
    }

    pub fn clear_rune_type(&mut self) {
        self.rune_type = ::std::option::Option::None;
    }

    pub fn has_rune_type(&self) -> bool {
        self.rune_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rune_type(&mut self, v: i32) {
        self.rune_type = ::std::option::Option::Some(v);
    }

    // optional int32 entity_id = 5;

    pub fn entity_id(&self) -> i32 {
        self.entity_id.unwrap_or(0)
    }

    pub fn clear_entity_id(&mut self) {
        self.entity_id = ::std::option::Option::None;
    }

    pub fn has_entity_id(&self) -> bool {
        self.entity_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: i32) {
        self.entity_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_level = 6;

    pub fn item_level(&self) -> i32 {
        self.item_level.unwrap_or(0)
    }

    pub fn clear_item_level(&mut self) {
        self.item_level = ::std::option::Option::None;
    }

    pub fn has_item_level(&self) -> bool {
        self.item_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level(&mut self, v: i32) {
        self.item_level = ::std::option::Option::Some(v);
    }

    // optional int32 primary_charges = 7;

    pub fn primary_charges(&self) -> i32 {
        self.primary_charges.unwrap_or(0)
    }

    pub fn clear_primary_charges(&mut self) {
        self.primary_charges = ::std::option::Option::None;
    }

    pub fn has_primary_charges(&self) -> bool {
        self.primary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_charges(&mut self, v: i32) {
        self.primary_charges = ::std::option::Option::Some(v);
    }

    // optional int32 secondary_charges = 8;

    pub fn secondary_charges(&self) -> i32 {
        self.secondary_charges.unwrap_or(0)
    }

    pub fn clear_secondary_charges(&mut self) {
        self.secondary_charges = ::std::option::Option::None;
    }

    pub fn has_secondary_charges(&self) -> bool {
        self.secondary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_charges(&mut self, v: i32) {
        self.secondary_charges = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_EnemyItemAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_EnemyItemAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAUserMsg_EnemyItemAlert| { &m.target_player_id },
            |m: &mut CDOTAUserMsg_EnemyItemAlert| { &mut m.target_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAUserMsg_EnemyItemAlert| { &m.item_ability_id },
            |m: &mut CDOTAUserMsg_EnemyItemAlert| { &mut m.item_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rune_type",
            |m: &CDOTAUserMsg_EnemyItemAlert| { &m.rune_type },
            |m: &mut CDOTAUserMsg_EnemyItemAlert| { &mut m.rune_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_id",
            |m: &CDOTAUserMsg_EnemyItemAlert| { &m.entity_id },
            |m: &mut CDOTAUserMsg_EnemyItemAlert| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_level",
            |m: &CDOTAUserMsg_EnemyItemAlert| { &m.item_level },
            |m: &mut CDOTAUserMsg_EnemyItemAlert| { &mut m.item_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_charges",
            |m: &CDOTAUserMsg_EnemyItemAlert| { &m.primary_charges },
            |m: &mut CDOTAUserMsg_EnemyItemAlert| { &mut m.primary_charges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secondary_charges",
            |m: &CDOTAUserMsg_EnemyItemAlert| { &m.secondary_charges },
            |m: &mut CDOTAUserMsg_EnemyItemAlert| { &mut m.secondary_charges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_EnemyItemAlert>(
            "CDOTAUserMsg_EnemyItemAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_EnemyItemAlert {
    const NAME: &'static str = "CDOTAUserMsg_EnemyItemAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.rune_type = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.entity_id = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.item_level = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.primary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.secondary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.rune_type {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.entity_id {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.item_level {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.primary_charges {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.secondary_charges {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.rune_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.entity_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.item_level {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.primary_charges {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.secondary_charges {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_EnemyItemAlert {
        CDOTAUserMsg_EnemyItemAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.rune_type = ::std::option::Option::None;
        self.entity_id = ::std::option::Option::None;
        self.item_level = ::std::option::Option::None;
        self.primary_charges = ::std::option::Option::None;
        self.secondary_charges = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_EnemyItemAlert {
        static instance: CDOTAUserMsg_EnemyItemAlert = CDOTAUserMsg_EnemyItemAlert {
            player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            rune_type: ::std::option::Option::None,
            entity_id: ::std::option::Option::None,
            item_level: ::std::option::Option::None,
            primary_charges: ::std::option::Option::None,
            secondary_charges: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_EnemyItemAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_EnemyItemAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_EnemyItemAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_EnemyItemAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ModifierAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ModifierAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ModifierAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ModifierAlert.class_name)
    pub class_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ModifierAlert.stack_count)
    pub stack_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ModifierAlert.is_debuff)
    pub is_debuff: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ModifierAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ModifierAlert.seconds_remaining)
    pub seconds_remaining: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ModifierAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ModifierAlert {
    fn default() -> &'a CDOTAUserMsg_ModifierAlert {
        <CDOTAUserMsg_ModifierAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ModifierAlert {
    pub fn new() -> CDOTAUserMsg_ModifierAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string class_name = 2;

    pub fn class_name(&self) -> &str {
        match self.class_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_class_name(&mut self) {
        self.class_name = ::std::option::Option::None;
    }

    pub fn has_class_name(&self) -> bool {
        self.class_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_name(&mut self, v: ::std::string::String) {
        self.class_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
        if self.class_name.is_none() {
            self.class_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.class_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_class_name(&mut self) -> ::std::string::String {
        self.class_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 stack_count = 3;

    pub fn stack_count(&self) -> u32 {
        self.stack_count.unwrap_or(0)
    }

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: u32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    // optional bool is_debuff = 4;

    pub fn is_debuff(&self) -> bool {
        self.is_debuff.unwrap_or(false)
    }

    pub fn clear_is_debuff(&mut self) {
        self.is_debuff = ::std::option::Option::None;
    }

    pub fn has_is_debuff(&self) -> bool {
        self.is_debuff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_debuff(&mut self, v: bool) {
        self.is_debuff = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 5;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional float seconds_remaining = 6;

    pub fn seconds_remaining(&self) -> f32 {
        self.seconds_remaining.unwrap_or(0.)
    }

    pub fn clear_seconds_remaining(&mut self) {
        self.seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_seconds_remaining(&self) -> bool {
        self.seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_remaining(&mut self, v: f32) {
        self.seconds_remaining = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_ModifierAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_ModifierAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_name",
            |m: &CDOTAUserMsg_ModifierAlert| { &m.class_name },
            |m: &mut CDOTAUserMsg_ModifierAlert| { &mut m.class_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_count",
            |m: &CDOTAUserMsg_ModifierAlert| { &m.stack_count },
            |m: &mut CDOTAUserMsg_ModifierAlert| { &mut m.stack_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_debuff",
            |m: &CDOTAUserMsg_ModifierAlert| { &m.is_debuff },
            |m: &mut CDOTAUserMsg_ModifierAlert| { &mut m.is_debuff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAUserMsg_ModifierAlert| { &m.target_entindex },
            |m: &mut CDOTAUserMsg_ModifierAlert| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_remaining",
            |m: &CDOTAUserMsg_ModifierAlert| { &m.seconds_remaining },
            |m: &mut CDOTAUserMsg_ModifierAlert| { &mut m.seconds_remaining },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ModifierAlert>(
            "CDOTAUserMsg_ModifierAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ModifierAlert {
    const NAME: &'static str = "CDOTAUserMsg_ModifierAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.class_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.stack_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_debuff = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                53 => {
                    self.seconds_remaining = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.class_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.stack_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_debuff {
            my_size += 1 + 1;
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.seconds_remaining {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.class_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_debuff {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.seconds_remaining {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ModifierAlert {
        CDOTAUserMsg_ModifierAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.class_name = ::std::option::Option::None;
        self.stack_count = ::std::option::Option::None;
        self.is_debuff = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ModifierAlert {
        static instance: CDOTAUserMsg_ModifierAlert = CDOTAUserMsg_ModifierAlert {
            player_id: ::std::option::Option::None,
            class_name: ::std::option::Option::None,
            stack_count: ::std::option::Option::None,
            is_debuff: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            seconds_remaining: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ModifierAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ModifierAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ModifierAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ModifierAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_HPManaAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HPManaAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HPManaAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HPManaAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HPManaAlert.show_raw_values)
    pub show_raw_values: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_HPManaAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HPManaAlert {
    fn default() -> &'a CDOTAUserMsg_HPManaAlert {
        <CDOTAUserMsg_HPManaAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HPManaAlert {
    pub fn new() -> CDOTAUserMsg_HPManaAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional bool show_raw_values = 3;

    pub fn show_raw_values(&self) -> bool {
        self.show_raw_values.unwrap_or(false)
    }

    pub fn clear_show_raw_values(&mut self) {
        self.show_raw_values = ::std::option::Option::None;
    }

    pub fn has_show_raw_values(&self) -> bool {
        self.show_raw_values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_raw_values(&mut self, v: bool) {
        self.show_raw_values = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_HPManaAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_HPManaAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAUserMsg_HPManaAlert| { &m.target_entindex },
            |m: &mut CDOTAUserMsg_HPManaAlert| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_raw_values",
            |m: &CDOTAUserMsg_HPManaAlert| { &m.show_raw_values },
            |m: &mut CDOTAUserMsg_HPManaAlert| { &mut m.show_raw_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_HPManaAlert>(
            "CDOTAUserMsg_HPManaAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HPManaAlert {
    const NAME: &'static str = "CDOTAUserMsg_HPManaAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.show_raw_values = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.show_raw_values {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.show_raw_values {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HPManaAlert {
        CDOTAUserMsg_HPManaAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.show_raw_values = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HPManaAlert {
        static instance: CDOTAUserMsg_HPManaAlert = CDOTAUserMsg_HPManaAlert {
            player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            show_raw_values: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_HPManaAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_HPManaAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_HPManaAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HPManaAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_NeutralCampAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_NeutralCampAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NeutralCampAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NeutralCampAlert.spawner_entindex)
    pub spawner_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NeutralCampAlert.unit_entindex)
    pub unit_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NeutralCampAlert.stack_count)
    pub stack_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NeutralCampAlert.camp_type)
    pub camp_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NeutralCampAlert.stack_request)
    pub stack_request: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NeutralCampAlert.stack_intention)
    pub stack_intention: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_NeutralCampAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_NeutralCampAlert {
    fn default() -> &'a CDOTAUserMsg_NeutralCampAlert {
        <CDOTAUserMsg_NeutralCampAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_NeutralCampAlert {
    pub fn new() -> CDOTAUserMsg_NeutralCampAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 spawner_entindex = 2;

    pub fn spawner_entindex(&self) -> i32 {
        self.spawner_entindex.unwrap_or(0)
    }

    pub fn clear_spawner_entindex(&mut self) {
        self.spawner_entindex = ::std::option::Option::None;
    }

    pub fn has_spawner_entindex(&self) -> bool {
        self.spawner_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawner_entindex(&mut self, v: i32) {
        self.spawner_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 unit_entindex = 3;

    pub fn unit_entindex(&self) -> i32 {
        self.unit_entindex.unwrap_or(0)
    }

    pub fn clear_unit_entindex(&mut self) {
        self.unit_entindex = ::std::option::Option::None;
    }

    pub fn has_unit_entindex(&self) -> bool {
        self.unit_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_entindex(&mut self, v: i32) {
        self.unit_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 stack_count = 4;

    pub fn stack_count(&self) -> i32 {
        self.stack_count.unwrap_or(0)
    }

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: i32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    // optional int32 camp_type = 5;

    pub fn camp_type(&self) -> i32 {
        self.camp_type.unwrap_or(0)
    }

    pub fn clear_camp_type(&mut self) {
        self.camp_type = ::std::option::Option::None;
    }

    pub fn has_camp_type(&self) -> bool {
        self.camp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camp_type(&mut self, v: i32) {
        self.camp_type = ::std::option::Option::Some(v);
    }

    // optional bool stack_request = 6;

    pub fn stack_request(&self) -> bool {
        self.stack_request.unwrap_or(false)
    }

    pub fn clear_stack_request(&mut self) {
        self.stack_request = ::std::option::Option::None;
    }

    pub fn has_stack_request(&self) -> bool {
        self.stack_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_request(&mut self, v: bool) {
        self.stack_request = ::std::option::Option::Some(v);
    }

    // optional bool stack_intention = 7;

    pub fn stack_intention(&self) -> bool {
        self.stack_intention.unwrap_or(false)
    }

    pub fn clear_stack_intention(&mut self) {
        self.stack_intention = ::std::option::Option::None;
    }

    pub fn has_stack_intention(&self) -> bool {
        self.stack_intention.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_intention(&mut self, v: bool) {
        self.stack_intention = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_NeutralCampAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_NeutralCampAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawner_entindex",
            |m: &CDOTAUserMsg_NeutralCampAlert| { &m.spawner_entindex },
            |m: &mut CDOTAUserMsg_NeutralCampAlert| { &mut m.spawner_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_entindex",
            |m: &CDOTAUserMsg_NeutralCampAlert| { &m.unit_entindex },
            |m: &mut CDOTAUserMsg_NeutralCampAlert| { &mut m.unit_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_count",
            |m: &CDOTAUserMsg_NeutralCampAlert| { &m.stack_count },
            |m: &mut CDOTAUserMsg_NeutralCampAlert| { &mut m.stack_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "camp_type",
            |m: &CDOTAUserMsg_NeutralCampAlert| { &m.camp_type },
            |m: &mut CDOTAUserMsg_NeutralCampAlert| { &mut m.camp_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_request",
            |m: &CDOTAUserMsg_NeutralCampAlert| { &m.stack_request },
            |m: &mut CDOTAUserMsg_NeutralCampAlert| { &mut m.stack_request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_intention",
            |m: &CDOTAUserMsg_NeutralCampAlert| { &m.stack_intention },
            |m: &mut CDOTAUserMsg_NeutralCampAlert| { &mut m.stack_intention },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_NeutralCampAlert>(
            "CDOTAUserMsg_NeutralCampAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_NeutralCampAlert {
    const NAME: &'static str = "CDOTAUserMsg_NeutralCampAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.spawner_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.unit_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.stack_count = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.camp_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.stack_request = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.stack_intention = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.spawner_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.unit_entindex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.stack_count {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.camp_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.stack_request {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stack_intention {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.spawner_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.unit_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.camp_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.stack_request {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.stack_intention {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_NeutralCampAlert {
        CDOTAUserMsg_NeutralCampAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.spawner_entindex = ::std::option::Option::None;
        self.unit_entindex = ::std::option::Option::None;
        self.stack_count = ::std::option::Option::None;
        self.camp_type = ::std::option::Option::None;
        self.stack_request = ::std::option::Option::None;
        self.stack_intention = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_NeutralCampAlert {
        static instance: CDOTAUserMsg_NeutralCampAlert = CDOTAUserMsg_NeutralCampAlert {
            player_id: ::std::option::Option::None,
            spawner_entindex: ::std::option::Option::None,
            unit_entindex: ::std::option::Option::None,
            stack_count: ::std::option::Option::None,
            camp_type: ::std::option::Option::None,
            stack_request: ::std::option::Option::None,
            stack_intention: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_NeutralCampAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_NeutralCampAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_NeutralCampAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_NeutralCampAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_GlyphAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GlyphAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GlyphAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GlyphAlert.negative)
    pub negative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_GlyphAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GlyphAlert {
    fn default() -> &'a CDOTAUserMsg_GlyphAlert {
        <CDOTAUserMsg_GlyphAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GlyphAlert {
    pub fn new() -> CDOTAUserMsg_GlyphAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional bool negative = 2;

    pub fn negative(&self) -> bool {
        self.negative.unwrap_or(false)
    }

    pub fn clear_negative(&mut self) {
        self.negative = ::std::option::Option::None;
    }

    pub fn has_negative(&self) -> bool {
        self.negative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: bool) {
        self.negative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_GlyphAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_GlyphAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "negative",
            |m: &CDOTAUserMsg_GlyphAlert| { &m.negative },
            |m: &mut CDOTAUserMsg_GlyphAlert| { &mut m.negative },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_GlyphAlert>(
            "CDOTAUserMsg_GlyphAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GlyphAlert {
    const NAME: &'static str = "CDOTAUserMsg_GlyphAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.negative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.negative {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.negative {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GlyphAlert {
        CDOTAUserMsg_GlyphAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.negative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GlyphAlert {
        static instance: CDOTAUserMsg_GlyphAlert = CDOTAUserMsg_GlyphAlert {
            player_id: ::std::option::Option::None,
            negative: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_GlyphAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_GlyphAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_GlyphAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_GlyphAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_RadarAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_RadarAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RadarAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RadarAlert.negative)
    pub negative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_RadarAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_RadarAlert {
    fn default() -> &'a CDOTAUserMsg_RadarAlert {
        <CDOTAUserMsg_RadarAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_RadarAlert {
    pub fn new() -> CDOTAUserMsg_RadarAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional bool negative = 2;

    pub fn negative(&self) -> bool {
        self.negative.unwrap_or(false)
    }

    pub fn clear_negative(&mut self) {
        self.negative = ::std::option::Option::None;
    }

    pub fn has_negative(&self) -> bool {
        self.negative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: bool) {
        self.negative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_RadarAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_RadarAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "negative",
            |m: &CDOTAUserMsg_RadarAlert| { &m.negative },
            |m: &mut CDOTAUserMsg_RadarAlert| { &mut m.negative },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_RadarAlert>(
            "CDOTAUserMsg_RadarAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_RadarAlert {
    const NAME: &'static str = "CDOTAUserMsg_RadarAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.negative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.negative {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.negative {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_RadarAlert {
        CDOTAUserMsg_RadarAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.negative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_RadarAlert {
        static instance: CDOTAUserMsg_RadarAlert = CDOTAUserMsg_RadarAlert {
            player_id: ::std::option::Option::None,
            negative: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_RadarAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_RadarAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_RadarAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_RadarAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_WillPurchaseAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WillPurchaseAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WillPurchaseAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WillPurchaseAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WillPurchaseAlert.gold_remaining)
    pub gold_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WillPurchaseAlert.suggestion_player_id)
    pub suggestion_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_WillPurchaseAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WillPurchaseAlert {
    fn default() -> &'a CDOTAUserMsg_WillPurchaseAlert {
        <CDOTAUserMsg_WillPurchaseAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WillPurchaseAlert {
    pub fn new() -> CDOTAUserMsg_WillPurchaseAlert {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 player_id = 2;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_remaining = 3;

    pub fn gold_remaining(&self) -> u32 {
        self.gold_remaining.unwrap_or(0)
    }

    pub fn clear_gold_remaining(&mut self) {
        self.gold_remaining = ::std::option::Option::None;
    }

    pub fn has_gold_remaining(&self) -> bool {
        self.gold_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_remaining(&mut self, v: u32) {
        self.gold_remaining = ::std::option::Option::Some(v);
    }

    // optional int32 suggestion_player_id = 4;

    pub fn suggestion_player_id(&self) -> i32 {
        self.suggestion_player_id.unwrap_or(0)
    }

    pub fn clear_suggestion_player_id(&mut self) {
        self.suggestion_player_id = ::std::option::Option::None;
    }

    pub fn has_suggestion_player_id(&self) -> bool {
        self.suggestion_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suggestion_player_id(&mut self, v: i32) {
        self.suggestion_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAUserMsg_WillPurchaseAlert| { &m.item_ability_id },
            |m: &mut CDOTAUserMsg_WillPurchaseAlert| { &mut m.item_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_WillPurchaseAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_WillPurchaseAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gold_remaining",
            |m: &CDOTAUserMsg_WillPurchaseAlert| { &m.gold_remaining },
            |m: &mut CDOTAUserMsg_WillPurchaseAlert| { &mut m.gold_remaining },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suggestion_player_id",
            |m: &CDOTAUserMsg_WillPurchaseAlert| { &m.suggestion_player_id },
            |m: &mut CDOTAUserMsg_WillPurchaseAlert| { &mut m.suggestion_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_WillPurchaseAlert>(
            "CDOTAUserMsg_WillPurchaseAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_WillPurchaseAlert {
    const NAME: &'static str = "CDOTAUserMsg_WillPurchaseAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.gold_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.suggestion_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.gold_remaining {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.suggestion_player_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.gold_remaining {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.suggestion_player_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WillPurchaseAlert {
        CDOTAUserMsg_WillPurchaseAlert::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.gold_remaining = ::std::option::Option::None;
        self.suggestion_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WillPurchaseAlert {
        static instance: CDOTAUserMsg_WillPurchaseAlert = CDOTAUserMsg_WillPurchaseAlert {
            item_ability_id: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            gold_remaining: ::std::option::Option::None,
            suggestion_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_WillPurchaseAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_WillPurchaseAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_WillPurchaseAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_WillPurchaseAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_EmptyTeleportAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_EmptyTeleportAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EmptyTeleportAlert.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EmptyTeleportAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EmptyTeleportAlert.cooldown_seconds)
    pub cooldown_seconds: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_EmptyTeleportAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_EmptyTeleportAlert {
    fn default() -> &'a CDOTAUserMsg_EmptyTeleportAlert {
        <CDOTAUserMsg_EmptyTeleportAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_EmptyTeleportAlert {
    pub fn new() -> CDOTAUserMsg_EmptyTeleportAlert {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(0)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 cooldown_seconds = 3;

    pub fn cooldown_seconds(&self) -> i32 {
        self.cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_cooldown_seconds(&mut self) {
        self.cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds(&self) -> bool {
        self.cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds(&mut self, v: i32) {
        self.cooldown_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_player_id",
            |m: &CDOTAUserMsg_EmptyTeleportAlert| { &m.source_player_id },
            |m: &mut CDOTAUserMsg_EmptyTeleportAlert| { &mut m.source_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAUserMsg_EmptyTeleportAlert| { &m.target_player_id },
            |m: &mut CDOTAUserMsg_EmptyTeleportAlert| { &mut m.target_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cooldown_seconds",
            |m: &CDOTAUserMsg_EmptyTeleportAlert| { &m.cooldown_seconds },
            |m: &mut CDOTAUserMsg_EmptyTeleportAlert| { &mut m.cooldown_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_EmptyTeleportAlert>(
            "CDOTAUserMsg_EmptyTeleportAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_EmptyTeleportAlert {
    const NAME: &'static str = "CDOTAUserMsg_EmptyTeleportAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.cooldown_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.cooldown_seconds {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.cooldown_seconds {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_EmptyTeleportAlert {
        CDOTAUserMsg_EmptyTeleportAlert::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.cooldown_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_EmptyTeleportAlert {
        static instance: CDOTAUserMsg_EmptyTeleportAlert = CDOTAUserMsg_EmptyTeleportAlert {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            cooldown_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_EmptyTeleportAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_EmptyTeleportAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_EmptyTeleportAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_EmptyTeleportAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_MarsArenaOfBloodAttack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MarsArenaOfBloodAttack {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MarsArenaOfBloodAttack.source_ehandle)
    pub source_ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MarsArenaOfBloodAttack.target_ehandle)
    pub target_ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MarsArenaOfBloodAttack.warrior_index)
    pub warrior_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MarsArenaOfBloodAttack.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MarsArenaOfBloodAttack {
    fn default() -> &'a CDOTAUserMsg_MarsArenaOfBloodAttack {
        <CDOTAUserMsg_MarsArenaOfBloodAttack as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MarsArenaOfBloodAttack {
    pub fn new() -> CDOTAUserMsg_MarsArenaOfBloodAttack {
        ::std::default::Default::default()
    }

    // optional uint32 source_ehandle = 1;

    pub fn source_ehandle(&self) -> u32 {
        self.source_ehandle.unwrap_or(0)
    }

    pub fn clear_source_ehandle(&mut self) {
        self.source_ehandle = ::std::option::Option::None;
    }

    pub fn has_source_ehandle(&self) -> bool {
        self.source_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_ehandle(&mut self, v: u32) {
        self.source_ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_ehandle = 2;

    pub fn target_ehandle(&self) -> u32 {
        self.target_ehandle.unwrap_or(0)
    }

    pub fn clear_target_ehandle(&mut self) {
        self.target_ehandle = ::std::option::Option::None;
    }

    pub fn has_target_ehandle(&self) -> bool {
        self.target_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_ehandle(&mut self, v: u32) {
        self.target_ehandle = ::std::option::Option::Some(v);
    }

    // optional int32 warrior_index = 3;

    pub fn warrior_index(&self) -> i32 {
        self.warrior_index.unwrap_or(0)
    }

    pub fn clear_warrior_index(&mut self) {
        self.warrior_index = ::std::option::Option::None;
    }

    pub fn has_warrior_index(&self) -> bool {
        self.warrior_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warrior_index(&mut self, v: i32) {
        self.warrior_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_ehandle",
            |m: &CDOTAUserMsg_MarsArenaOfBloodAttack| { &m.source_ehandle },
            |m: &mut CDOTAUserMsg_MarsArenaOfBloodAttack| { &mut m.source_ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_ehandle",
            |m: &CDOTAUserMsg_MarsArenaOfBloodAttack| { &m.target_ehandle },
            |m: &mut CDOTAUserMsg_MarsArenaOfBloodAttack| { &mut m.target_ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "warrior_index",
            |m: &CDOTAUserMsg_MarsArenaOfBloodAttack| { &m.warrior_index },
            |m: &mut CDOTAUserMsg_MarsArenaOfBloodAttack| { &mut m.warrior_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_MarsArenaOfBloodAttack>(
            "CDOTAUserMsg_MarsArenaOfBloodAttack",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MarsArenaOfBloodAttack {
    const NAME: &'static str = "CDOTAUserMsg_MarsArenaOfBloodAttack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.warrior_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_ehandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_ehandle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.warrior_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_ehandle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.warrior_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MarsArenaOfBloodAttack {
        CDOTAUserMsg_MarsArenaOfBloodAttack::new()
    }

    fn clear(&mut self) {
        self.source_ehandle = ::std::option::Option::None;
        self.target_ehandle = ::std::option::Option::None;
        self.warrior_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MarsArenaOfBloodAttack {
        static instance: CDOTAUserMsg_MarsArenaOfBloodAttack = CDOTAUserMsg_MarsArenaOfBloodAttack {
            source_ehandle: ::std::option::Option::None,
            target_ehandle: ::std::option::Option::None,
            warrior_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_MarsArenaOfBloodAttack {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MarsArenaOfBloodAttack").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_MarsArenaOfBloodAttack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MarsArenaOfBloodAttack {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAEntityMsg_InvokerSpellCast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAEntityMsg_InvokerSpellCast {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAEntityMsg_InvokerSpellCast.entity_msg)
    pub entity_msg: ::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // @@protoc_insertion_point(field:dota.CDOTAEntityMsg_InvokerSpellCast.cast_activity)
    pub cast_activity: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAEntityMsg_InvokerSpellCast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAEntityMsg_InvokerSpellCast {
    fn default() -> &'a CDOTAEntityMsg_InvokerSpellCast {
        <CDOTAEntityMsg_InvokerSpellCast as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAEntityMsg_InvokerSpellCast {
    pub fn new() -> CDOTAEntityMsg_InvokerSpellCast {
        ::std::default::Default::default()
    }

    // optional int32 cast_activity = 2;

    pub fn cast_activity(&self) -> i32 {
        self.cast_activity.unwrap_or(0)
    }

    pub fn clear_cast_activity(&mut self) {
        self.cast_activity = ::std::option::Option::None;
    }

    pub fn has_cast_activity(&self) -> bool {
        self.cast_activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cast_activity(&mut self, v: i32) {
        self.cast_activity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CEntityMsg>(
            "entity_msg",
            |m: &CDOTAEntityMsg_InvokerSpellCast| { &m.entity_msg },
            |m: &mut CDOTAEntityMsg_InvokerSpellCast| { &mut m.entity_msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cast_activity",
            |m: &CDOTAEntityMsg_InvokerSpellCast| { &m.cast_activity },
            |m: &mut CDOTAEntityMsg_InvokerSpellCast| { &mut m.cast_activity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAEntityMsg_InvokerSpellCast>(
            "CDOTAEntityMsg_InvokerSpellCast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAEntityMsg_InvokerSpellCast {
    const NAME: &'static str = "CDOTAEntityMsg_InvokerSpellCast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                16 => {
                    self.cast_activity = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cast_activity {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.cast_activity {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAEntityMsg_InvokerSpellCast {
        CDOTAEntityMsg_InvokerSpellCast::new()
    }

    fn clear(&mut self) {
        self.entity_msg.clear();
        self.cast_activity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAEntityMsg_InvokerSpellCast {
        static instance: CDOTAEntityMsg_InvokerSpellCast = CDOTAEntityMsg_InvokerSpellCast {
            entity_msg: ::protobuf::MessageField::none(),
            cast_activity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAEntityMsg_InvokerSpellCast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAEntityMsg_InvokerSpellCast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAEntityMsg_InvokerSpellCast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAEntityMsg_InvokerSpellCast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_BuyBackStateAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BuyBackStateAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BuyBackStateAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_BuyBackStateAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BuyBackStateAlert {
    fn default() -> &'a CDOTAUserMsg_BuyBackStateAlert {
        <CDOTAUserMsg_BuyBackStateAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BuyBackStateAlert {
    pub fn new() -> CDOTAUserMsg_BuyBackStateAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_BuyBackStateAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_BuyBackStateAlert| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_BuyBackStateAlert>(
            "CDOTAUserMsg_BuyBackStateAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BuyBackStateAlert {
    const NAME: &'static str = "CDOTAUserMsg_BuyBackStateAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BuyBackStateAlert {
        CDOTAUserMsg_BuyBackStateAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BuyBackStateAlert {
        static instance: CDOTAUserMsg_BuyBackStateAlert = CDOTAUserMsg_BuyBackStateAlert {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_BuyBackStateAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_BuyBackStateAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_BuyBackStateAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BuyBackStateAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_QuickBuyAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_QuickBuyAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuickBuyAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuickBuyAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuickBuyAlert.gold_cost)
    pub gold_cost: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuickBuyAlert.item_cooldown_seconds)
    pub item_cooldown_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuickBuyAlert.show_buyback)
    pub show_buyback: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_QuickBuyAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_QuickBuyAlert {
    fn default() -> &'a CDOTAUserMsg_QuickBuyAlert {
        <CDOTAUserMsg_QuickBuyAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_QuickBuyAlert {
    pub fn new() -> CDOTAUserMsg_QuickBuyAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 2;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 gold_cost = 3;

    pub fn gold_cost(&self) -> i32 {
        self.gold_cost.unwrap_or(0)
    }

    pub fn clear_gold_cost(&mut self) {
        self.gold_cost = ::std::option::Option::None;
    }

    pub fn has_gold_cost(&self) -> bool {
        self.gold_cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_cost(&mut self, v: i32) {
        self.gold_cost = ::std::option::Option::Some(v);
    }

    // optional int32 item_cooldown_seconds = 4;

    pub fn item_cooldown_seconds(&self) -> i32 {
        self.item_cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_item_cooldown_seconds(&mut self) {
        self.item_cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_item_cooldown_seconds(&self) -> bool {
        self.item_cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_cooldown_seconds(&mut self, v: i32) {
        self.item_cooldown_seconds = ::std::option::Option::Some(v);
    }

    // optional bool show_buyback = 5;

    pub fn show_buyback(&self) -> bool {
        self.show_buyback.unwrap_or(false)
    }

    pub fn clear_show_buyback(&mut self) {
        self.show_buyback = ::std::option::Option::None;
    }

    pub fn has_show_buyback(&self) -> bool {
        self.show_buyback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_buyback(&mut self, v: bool) {
        self.show_buyback = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_QuickBuyAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_QuickBuyAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAUserMsg_QuickBuyAlert| { &m.item_ability_id },
            |m: &mut CDOTAUserMsg_QuickBuyAlert| { &mut m.item_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gold_cost",
            |m: &CDOTAUserMsg_QuickBuyAlert| { &m.gold_cost },
            |m: &mut CDOTAUserMsg_QuickBuyAlert| { &mut m.gold_cost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_cooldown_seconds",
            |m: &CDOTAUserMsg_QuickBuyAlert| { &m.item_cooldown_seconds },
            |m: &mut CDOTAUserMsg_QuickBuyAlert| { &mut m.item_cooldown_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_buyback",
            |m: &CDOTAUserMsg_QuickBuyAlert| { &m.show_buyback },
            |m: &mut CDOTAUserMsg_QuickBuyAlert| { &mut m.show_buyback },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_QuickBuyAlert>(
            "CDOTAUserMsg_QuickBuyAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_QuickBuyAlert {
    const NAME: &'static str = "CDOTAUserMsg_QuickBuyAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.gold_cost = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.item_cooldown_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.show_buyback = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.gold_cost {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.item_cooldown_seconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.show_buyback {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.gold_cost {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.item_cooldown_seconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.show_buyback {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_QuickBuyAlert {
        CDOTAUserMsg_QuickBuyAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.gold_cost = ::std::option::Option::None;
        self.item_cooldown_seconds = ::std::option::Option::None;
        self.show_buyback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_QuickBuyAlert {
        static instance: CDOTAUserMsg_QuickBuyAlert = CDOTAUserMsg_QuickBuyAlert {
            player_id: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            gold_cost: ::std::option::Option::None,
            item_cooldown_seconds: ::std::option::Option::None,
            show_buyback: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_QuickBuyAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_QuickBuyAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_QuickBuyAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_QuickBuyAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CourierKilledAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CourierKilledAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CourierKilledAlert.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CourierKilledAlert.gold_value)
    pub gold_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CourierKilledAlert.entity_handle)
    pub entity_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CourierKilledAlert.timestamp)
    pub timestamp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CourierKilledAlert.lost_items)
    pub lost_items: ::std::vec::Vec<cdotauser_msg_courier_killed_alert::LostItem>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CourierKilledAlert.killer_player_id)
    pub killer_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CourierKilledAlert.owning_player_id)
    pub owning_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CourierKilledAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CourierKilledAlert {
    fn default() -> &'a CDOTAUserMsg_CourierKilledAlert {
        <CDOTAUserMsg_CourierKilledAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CourierKilledAlert {
    pub fn new() -> CDOTAUserMsg_CourierKilledAlert {
        ::std::default::Default::default()
    }

    // optional uint32 team = 1;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_value = 2;

    pub fn gold_value(&self) -> u32 {
        self.gold_value.unwrap_or(0)
    }

    pub fn clear_gold_value(&mut self) {
        self.gold_value = ::std::option::Option::None;
    }

    pub fn has_gold_value(&self) -> bool {
        self.gold_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_value(&mut self, v: u32) {
        self.gold_value = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_handle = 3;

    pub fn entity_handle(&self) -> u32 {
        self.entity_handle.unwrap_or(0)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: u32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    // optional int32 timestamp = 4;

    pub fn timestamp(&self) -> i32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 killer_player_id = 6;

    pub fn killer_player_id(&self) -> i32 {
        self.killer_player_id.unwrap_or(0)
    }

    pub fn clear_killer_player_id(&mut self) {
        self.killer_player_id = ::std::option::Option::None;
    }

    pub fn has_killer_player_id(&self) -> bool {
        self.killer_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_player_id(&mut self, v: i32) {
        self.killer_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 owning_player_id = 7;

    pub fn owning_player_id(&self) -> i32 {
        self.owning_player_id.unwrap_or(0)
    }

    pub fn clear_owning_player_id(&mut self) {
        self.owning_player_id = ::std::option::Option::None;
    }

    pub fn has_owning_player_id(&self) -> bool {
        self.owning_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_player_id(&mut self, v: i32) {
        self.owning_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CDOTAUserMsg_CourierKilledAlert| { &m.team },
            |m: &mut CDOTAUserMsg_CourierKilledAlert| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gold_value",
            |m: &CDOTAUserMsg_CourierKilledAlert| { &m.gold_value },
            |m: &mut CDOTAUserMsg_CourierKilledAlert| { &mut m.gold_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_handle",
            |m: &CDOTAUserMsg_CourierKilledAlert| { &m.entity_handle },
            |m: &mut CDOTAUserMsg_CourierKilledAlert| { &mut m.entity_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CDOTAUserMsg_CourierKilledAlert| { &m.timestamp },
            |m: &mut CDOTAUserMsg_CourierKilledAlert| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lost_items",
            |m: &CDOTAUserMsg_CourierKilledAlert| { &m.lost_items },
            |m: &mut CDOTAUserMsg_CourierKilledAlert| { &mut m.lost_items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killer_player_id",
            |m: &CDOTAUserMsg_CourierKilledAlert| { &m.killer_player_id },
            |m: &mut CDOTAUserMsg_CourierKilledAlert| { &mut m.killer_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owning_player_id",
            |m: &CDOTAUserMsg_CourierKilledAlert| { &m.owning_player_id },
            |m: &mut CDOTAUserMsg_CourierKilledAlert| { &mut m.owning_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CourierKilledAlert>(
            "CDOTAUserMsg_CourierKilledAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CourierKilledAlert {
    const NAME: &'static str = "CDOTAUserMsg_CourierKilledAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gold_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.lost_items.push(is.read_message()?);
                },
                48 => {
                    self.killer_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.owning_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gold_value {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for value in &self.lost_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.killer_player_id {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.owning_player_id {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gold_value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int32(4, v)?;
        }
        for v in &self.lost_items {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.killer_player_id {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.owning_player_id {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CourierKilledAlert {
        CDOTAUserMsg_CourierKilledAlert::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.gold_value = ::std::option::Option::None;
        self.entity_handle = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.lost_items.clear();
        self.killer_player_id = ::std::option::Option::None;
        self.owning_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CourierKilledAlert {
        static instance: CDOTAUserMsg_CourierKilledAlert = CDOTAUserMsg_CourierKilledAlert {
            team: ::std::option::Option::None,
            gold_value: ::std::option::Option::None,
            entity_handle: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            lost_items: ::std::vec::Vec::new(),
            killer_player_id: ::std::option::Option::None,
            owning_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CourierKilledAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CourierKilledAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CourierKilledAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CourierKilledAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_CourierKilledAlert`
pub mod cdotauser_msg_courier_killed_alert {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_CourierKilledAlert.LostItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LostItem {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CourierKilledAlert.LostItem.item_ability_id)
        pub item_ability_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CourierKilledAlert.LostItem.quantity)
        pub quantity: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CourierKilledAlert.LostItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LostItem {
        fn default() -> &'a LostItem {
            <LostItem as ::protobuf::Message>::default_instance()
        }
    }

    impl LostItem {
        pub fn new() -> LostItem {
            ::std::default::Default::default()
        }

        // optional int32 item_ability_id = 1;

        pub fn item_ability_id(&self) -> i32 {
            self.item_ability_id.unwrap_or(0)
        }

        pub fn clear_item_ability_id(&mut self) {
            self.item_ability_id = ::std::option::Option::None;
        }

        pub fn has_item_ability_id(&self) -> bool {
            self.item_ability_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_ability_id(&mut self, v: i32) {
            self.item_ability_id = ::std::option::Option::Some(v);
        }

        // optional uint32 quantity = 2;

        pub fn quantity(&self) -> u32 {
            self.quantity.unwrap_or(0)
        }

        pub fn clear_quantity(&mut self) {
            self.quantity = ::std::option::Option::None;
        }

        pub fn has_quantity(&self) -> bool {
            self.quantity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quantity(&mut self, v: u32) {
            self.quantity = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_ability_id",
                |m: &LostItem| { &m.item_ability_id },
                |m: &mut LostItem| { &mut m.item_ability_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quantity",
                |m: &LostItem| { &m.quantity },
                |m: &mut LostItem| { &mut m.quantity },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LostItem>(
                "CDOTAUserMsg_CourierKilledAlert.LostItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LostItem {
        const NAME: &'static str = "LostItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_ability_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.quantity {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_ability_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.quantity {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LostItem {
            LostItem::new()
        }

        fn clear(&mut self) {
            self.item_ability_id = ::std::option::Option::None;
            self.quantity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LostItem {
            static instance: LostItem = LostItem {
                item_ability_id: ::std::option::Option::None,
                quantity: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LostItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CourierKilledAlert.LostItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LostItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LostItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_MinimapEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MinimapEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapEvent.event_type)
    pub event_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapEvent.entity_handle)
    pub entity_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapEvent.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapEvent.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapEvent.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapEvent.target_entity_handle)
    pub target_entity_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MinimapEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MinimapEvent {
    fn default() -> &'a CDOTAUserMsg_MinimapEvent {
        <CDOTAUserMsg_MinimapEvent as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MinimapEvent {
    pub fn new() -> CDOTAUserMsg_MinimapEvent {
        ::std::default::Default::default()
    }

    // optional int32 event_type = 1;

    pub fn event_type(&self) -> i32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: i32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_handle = 2;

    pub fn entity_handle(&self) -> u32 {
        self.entity_handle.unwrap_or(0)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: u32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 3;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 4;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 5;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 target_entity_handle = 6;

    pub fn target_entity_handle(&self) -> u32 {
        self.target_entity_handle.unwrap_or(0)
    }

    pub fn clear_target_entity_handle(&mut self) {
        self.target_entity_handle = ::std::option::Option::None;
    }

    pub fn has_target_entity_handle(&self) -> bool {
        self.target_entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entity_handle(&mut self, v: u32) {
        self.target_entity_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CDOTAUserMsg_MinimapEvent| { &m.event_type },
            |m: &mut CDOTAUserMsg_MinimapEvent| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_handle",
            |m: &CDOTAUserMsg_MinimapEvent| { &m.entity_handle },
            |m: &mut CDOTAUserMsg_MinimapEvent| { &mut m.entity_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CDOTAUserMsg_MinimapEvent| { &m.x },
            |m: &mut CDOTAUserMsg_MinimapEvent| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CDOTAUserMsg_MinimapEvent| { &m.y },
            |m: &mut CDOTAUserMsg_MinimapEvent| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CDOTAUserMsg_MinimapEvent| { &m.duration },
            |m: &mut CDOTAUserMsg_MinimapEvent| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entity_handle",
            |m: &CDOTAUserMsg_MinimapEvent| { &m.target_entity_handle },
            |m: &mut CDOTAUserMsg_MinimapEvent| { &mut m.target_entity_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_MinimapEvent>(
            "CDOTAUserMsg_MinimapEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MinimapEvent {
    const NAME: &'static str = "CDOTAUserMsg_MinimapEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_type = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.target_entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.target_entity_handle {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.target_entity_handle {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MinimapEvent {
        CDOTAUserMsg_MinimapEvent::new()
    }

    fn clear(&mut self) {
        self.event_type = ::std::option::Option::None;
        self.entity_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.target_entity_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MinimapEvent {
        static instance: CDOTAUserMsg_MinimapEvent = CDOTAUserMsg_MinimapEvent {
            event_type: ::std::option::Option::None,
            entity_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            target_entity_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_MinimapEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MinimapEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_MinimapEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MinimapEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_MapLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MapLine {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MapLine.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MapLine.mapline)
    pub mapline: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_MapLine>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MapLine.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MapLine {
    fn default() -> &'a CDOTAUserMsg_MapLine {
        <CDOTAUserMsg_MapLine as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MapLine {
    pub fn new() -> CDOTAUserMsg_MapLine {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_MapLine| { &m.player_id },
            |m: &mut CDOTAUserMsg_MapLine| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_MapLine>(
            "mapline",
            |m: &CDOTAUserMsg_MapLine| { &m.mapline },
            |m: &mut CDOTAUserMsg_MapLine| { &mut m.mapline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_MapLine>(
            "CDOTAUserMsg_MapLine",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MapLine {
    const NAME: &'static str = "CDOTAUserMsg_MapLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mapline)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mapline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mapline.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MapLine {
        CDOTAUserMsg_MapLine::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.mapline.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MapLine {
        static instance: CDOTAUserMsg_MapLine = CDOTAUserMsg_MapLine {
            player_id: ::std::option::Option::None,
            mapline: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_MapLine {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MapLine").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_MapLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MapLine {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_MinimapDebugPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MinimapDebugPoint {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapDebugPoint.location)
    pub location: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapDebugPoint.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapDebugPoint.size)
    pub size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapDebugPoint.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MinimapDebugPoint.index)
    pub index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MinimapDebugPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MinimapDebugPoint {
    fn default() -> &'a CDOTAUserMsg_MinimapDebugPoint {
        <CDOTAUserMsg_MinimapDebugPoint as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MinimapDebugPoint {
    pub fn new() -> CDOTAUserMsg_MinimapDebugPoint {
        ::std::default::Default::default()
    }

    // optional uint32 color = 2;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional int32 size = 3;

    pub fn size(&self) -> i32 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 index = 5;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "location",
            |m: &CDOTAUserMsg_MinimapDebugPoint| { &m.location },
            |m: &mut CDOTAUserMsg_MinimapDebugPoint| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CDOTAUserMsg_MinimapDebugPoint| { &m.color },
            |m: &mut CDOTAUserMsg_MinimapDebugPoint| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &CDOTAUserMsg_MinimapDebugPoint| { &m.size },
            |m: &mut CDOTAUserMsg_MinimapDebugPoint| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CDOTAUserMsg_MinimapDebugPoint| { &m.duration },
            |m: &mut CDOTAUserMsg_MinimapDebugPoint| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CDOTAUserMsg_MinimapDebugPoint| { &m.index },
            |m: &mut CDOTAUserMsg_MinimapDebugPoint| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_MinimapDebugPoint>(
            "CDOTAUserMsg_MinimapDebugPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MinimapDebugPoint {
    const NAME: &'static str = "CDOTAUserMsg_MinimapDebugPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                16 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.size = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.location.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MinimapDebugPoint {
        CDOTAUserMsg_MinimapDebugPoint::new()
    }

    fn clear(&mut self) {
        self.location.clear();
        self.color = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MinimapDebugPoint {
        static instance: CDOTAUserMsg_MinimapDebugPoint = CDOTAUserMsg_MinimapDebugPoint {
            location: ::protobuf::MessageField::none(),
            color: ::std::option::Option::None,
            size: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_MinimapDebugPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MinimapDebugPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_MinimapDebugPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MinimapDebugPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CreateLinearProjectile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CreateLinearProjectile {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.velocity)
    pub velocity: ::protobuf::MessageField<super::networkbasetypes::CMsgVector2D>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.particle_index)
    pub particle_index: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.handle)
    pub handle: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.acceleration)
    pub acceleration: ::protobuf::MessageField<super::networkbasetypes::CMsgVector2D>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.max_speed)
    pub max_speed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.fow_radius)
    pub fow_radius: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.sticky_fow_reveal)
    pub sticky_fow_reveal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.distance)
    pub distance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.colorgemcolor)
    pub colorgemcolor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CreateLinearProjectile.particle_cp_data)
    pub particle_cp_data: ::std::vec::Vec<CDOTAUserMsg_ProjectileParticleCPData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CreateLinearProjectile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CreateLinearProjectile {
    fn default() -> &'a CDOTAUserMsg_CreateLinearProjectile {
        <CDOTAUserMsg_CreateLinearProjectile as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CreateLinearProjectile {
    pub fn new() -> CDOTAUserMsg_CreateLinearProjectile {
        ::std::default::Default::default()
    }

    // optional int32 entindex = 4;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional uint64 particle_index = 5;

    pub fn particle_index(&self) -> u64 {
        self.particle_index.unwrap_or(0)
    }

    pub fn clear_particle_index(&mut self) {
        self.particle_index = ::std::option::Option::None;
    }

    pub fn has_particle_index(&self) -> bool {
        self.particle_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_index(&mut self, v: u64) {
        self.particle_index = ::std::option::Option::Some(v);
    }

    // optional int32 handle = 6;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    // optional float max_speed = 8;

    pub fn max_speed(&self) -> f32 {
        self.max_speed.unwrap_or(0.)
    }

    pub fn clear_max_speed(&mut self) {
        self.max_speed = ::std::option::Option::None;
    }

    pub fn has_max_speed(&self) -> bool {
        self.max_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_speed(&mut self, v: f32) {
        self.max_speed = ::std::option::Option::Some(v);
    }

    // optional float fow_radius = 9;

    pub fn fow_radius(&self) -> f32 {
        self.fow_radius.unwrap_or(0.)
    }

    pub fn clear_fow_radius(&mut self) {
        self.fow_radius = ::std::option::Option::None;
    }

    pub fn has_fow_radius(&self) -> bool {
        self.fow_radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fow_radius(&mut self, v: f32) {
        self.fow_radius = ::std::option::Option::Some(v);
    }

    // optional bool sticky_fow_reveal = 10;

    pub fn sticky_fow_reveal(&self) -> bool {
        self.sticky_fow_reveal.unwrap_or(false)
    }

    pub fn clear_sticky_fow_reveal(&mut self) {
        self.sticky_fow_reveal = ::std::option::Option::None;
    }

    pub fn has_sticky_fow_reveal(&self) -> bool {
        self.sticky_fow_reveal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticky_fow_reveal(&mut self, v: bool) {
        self.sticky_fow_reveal = ::std::option::Option::Some(v);
    }

    // optional float distance = 11;

    pub fn distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    // optional fixed32 colorgemcolor = 12;

    pub fn colorgemcolor(&self) -> u32 {
        self.colorgemcolor.unwrap_or(0)
    }

    pub fn clear_colorgemcolor(&mut self) {
        self.colorgemcolor = ::std::option::Option::None;
    }

    pub fn has_colorgemcolor(&self) -> bool {
        self.colorgemcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorgemcolor(&mut self, v: u32) {
        self.colorgemcolor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.origin },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector2D>(
            "velocity",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.velocity },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.velocity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.entindex },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_index",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.particle_index },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.particle_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.handle },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector2D>(
            "acceleration",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.acceleration },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.acceleration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_speed",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.max_speed },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.max_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fow_radius",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.fow_radius },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.fow_radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sticky_fow_reveal",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.sticky_fow_reveal },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.sticky_fow_reveal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "distance",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.distance },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.distance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "colorgemcolor",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.colorgemcolor },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.colorgemcolor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "particle_cp_data",
            |m: &CDOTAUserMsg_CreateLinearProjectile| { &m.particle_cp_data },
            |m: &mut CDOTAUserMsg_CreateLinearProjectile| { &mut m.particle_cp_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CreateLinearProjectile>(
            "CDOTAUserMsg_CreateLinearProjectile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CreateLinearProjectile {
    const NAME: &'static str = "CDOTAUserMsg_CreateLinearProjectile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.velocity)?;
                },
                32 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.particle_index = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.acceleration)?;
                },
                69 => {
                    self.max_speed = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.fow_radius = ::std::option::Option::Some(is.read_float()?);
                },
                80 => {
                    self.sticky_fow_reveal = ::std::option::Option::Some(is.read_bool()?);
                },
                93 => {
                    self.distance = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.colorgemcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                106 => {
                    self.particle_cp_data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.particle_index {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.acceleration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max_speed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fow_radius {
            my_size += 1 + 4;
        }
        if let Some(v) = self.sticky_fow_reveal {
            my_size += 1 + 1;
        }
        if let Some(v) = self.distance {
            my_size += 1 + 4;
        }
        if let Some(v) = self.colorgemcolor {
            my_size += 1 + 4;
        }
        for value in &self.particle_cp_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.velocity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.particle_index {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.handle {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.acceleration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.max_speed {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.fow_radius {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.sticky_fow_reveal {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.distance {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.colorgemcolor {
            os.write_fixed32(12, v)?;
        }
        for v in &self.particle_cp_data {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CreateLinearProjectile {
        CDOTAUserMsg_CreateLinearProjectile::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.velocity.clear();
        self.entindex = ::std::option::Option::None;
        self.particle_index = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.acceleration.clear();
        self.max_speed = ::std::option::Option::None;
        self.fow_radius = ::std::option::Option::None;
        self.sticky_fow_reveal = ::std::option::Option::None;
        self.distance = ::std::option::Option::None;
        self.colorgemcolor = ::std::option::Option::None;
        self.particle_cp_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CreateLinearProjectile {
        static instance: CDOTAUserMsg_CreateLinearProjectile = CDOTAUserMsg_CreateLinearProjectile {
            origin: ::protobuf::MessageField::none(),
            velocity: ::protobuf::MessageField::none(),
            entindex: ::std::option::Option::None,
            particle_index: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            acceleration: ::protobuf::MessageField::none(),
            max_speed: ::std::option::Option::None,
            fow_radius: ::std::option::Option::None,
            sticky_fow_reveal: ::std::option::Option::None,
            distance: ::std::option::Option::None,
            colorgemcolor: ::std::option::Option::None,
            particle_cp_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CreateLinearProjectile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CreateLinearProjectile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CreateLinearProjectile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CreateLinearProjectile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_DestroyLinearProjectile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DestroyLinearProjectile {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DestroyLinearProjectile.handle)
    pub handle: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_DestroyLinearProjectile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DestroyLinearProjectile {
    fn default() -> &'a CDOTAUserMsg_DestroyLinearProjectile {
        <CDOTAUserMsg_DestroyLinearProjectile as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DestroyLinearProjectile {
    pub fn new() -> CDOTAUserMsg_DestroyLinearProjectile {
        ::std::default::Default::default()
    }

    // optional int32 handle = 1;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &CDOTAUserMsg_DestroyLinearProjectile| { &m.handle },
            |m: &mut CDOTAUserMsg_DestroyLinearProjectile| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_DestroyLinearProjectile>(
            "CDOTAUserMsg_DestroyLinearProjectile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DestroyLinearProjectile {
    const NAME: &'static str = "CDOTAUserMsg_DestroyLinearProjectile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.handle {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DestroyLinearProjectile {
        CDOTAUserMsg_DestroyLinearProjectile::new()
    }

    fn clear(&mut self) {
        self.handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DestroyLinearProjectile {
        static instance: CDOTAUserMsg_DestroyLinearProjectile = CDOTAUserMsg_DestroyLinearProjectile {
            handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_DestroyLinearProjectile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_DestroyLinearProjectile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_DestroyLinearProjectile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DestroyLinearProjectile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_DodgeTrackingProjectiles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DodgeTrackingProjectiles {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DodgeTrackingProjectiles.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DodgeTrackingProjectiles.attacks_only)
    pub attacks_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_DodgeTrackingProjectiles.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DodgeTrackingProjectiles {
    fn default() -> &'a CDOTAUserMsg_DodgeTrackingProjectiles {
        <CDOTAUserMsg_DodgeTrackingProjectiles as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DodgeTrackingProjectiles {
    pub fn new() -> CDOTAUserMsg_DodgeTrackingProjectiles {
        ::std::default::Default::default()
    }

    // required int32 entindex = 1;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional bool attacks_only = 2;

    pub fn attacks_only(&self) -> bool {
        self.attacks_only.unwrap_or(false)
    }

    pub fn clear_attacks_only(&mut self) {
        self.attacks_only = ::std::option::Option::None;
    }

    pub fn has_attacks_only(&self) -> bool {
        self.attacks_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacks_only(&mut self, v: bool) {
        self.attacks_only = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &CDOTAUserMsg_DodgeTrackingProjectiles| { &m.entindex },
            |m: &mut CDOTAUserMsg_DodgeTrackingProjectiles| { &mut m.entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attacks_only",
            |m: &CDOTAUserMsg_DodgeTrackingProjectiles| { &m.attacks_only },
            |m: &mut CDOTAUserMsg_DodgeTrackingProjectiles| { &mut m.attacks_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_DodgeTrackingProjectiles>(
            "CDOTAUserMsg_DodgeTrackingProjectiles",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DodgeTrackingProjectiles {
    const NAME: &'static str = "CDOTAUserMsg_DodgeTrackingProjectiles";

    fn is_initialized(&self) -> bool {
        if self.entindex.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.attacks_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.attacks_only {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.attacks_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DodgeTrackingProjectiles {
        CDOTAUserMsg_DodgeTrackingProjectiles::new()
    }

    fn clear(&mut self) {
        self.entindex = ::std::option::Option::None;
        self.attacks_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DodgeTrackingProjectiles {
        static instance: CDOTAUserMsg_DodgeTrackingProjectiles = CDOTAUserMsg_DodgeTrackingProjectiles {
            entindex: ::std::option::Option::None,
            attacks_only: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_DodgeTrackingProjectiles").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DodgeTrackingProjectiles {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SpectatorPlayerClick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SpectatorPlayerClick {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerClick.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerClick.order_type)
    pub order_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerClick.target_index)
    pub target_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SpectatorPlayerClick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SpectatorPlayerClick {
    fn default() -> &'a CDOTAUserMsg_SpectatorPlayerClick {
        <CDOTAUserMsg_SpectatorPlayerClick as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SpectatorPlayerClick {
    pub fn new() -> CDOTAUserMsg_SpectatorPlayerClick {
        ::std::default::Default::default()
    }

    // required int32 entindex = 1;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional int32 order_type = 2;

    pub fn order_type(&self) -> i32 {
        self.order_type.unwrap_or(0)
    }

    pub fn clear_order_type(&mut self) {
        self.order_type = ::std::option::Option::None;
    }

    pub fn has_order_type(&self) -> bool {
        self.order_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: i32) {
        self.order_type = ::std::option::Option::Some(v);
    }

    // optional int32 target_index = 3;

    pub fn target_index(&self) -> i32 {
        self.target_index.unwrap_or(0)
    }

    pub fn clear_target_index(&mut self) {
        self.target_index = ::std::option::Option::None;
    }

    pub fn has_target_index(&self) -> bool {
        self.target_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_index(&mut self, v: i32) {
        self.target_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &CDOTAUserMsg_SpectatorPlayerClick| { &m.entindex },
            |m: &mut CDOTAUserMsg_SpectatorPlayerClick| { &mut m.entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "order_type",
            |m: &CDOTAUserMsg_SpectatorPlayerClick| { &m.order_type },
            |m: &mut CDOTAUserMsg_SpectatorPlayerClick| { &mut m.order_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_index",
            |m: &CDOTAUserMsg_SpectatorPlayerClick| { &m.target_index },
            |m: &mut CDOTAUserMsg_SpectatorPlayerClick| { &mut m.target_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SpectatorPlayerClick>(
            "CDOTAUserMsg_SpectatorPlayerClick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SpectatorPlayerClick {
    const NAME: &'static str = "CDOTAUserMsg_SpectatorPlayerClick";

    fn is_initialized(&self) -> bool {
        if self.entindex.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.order_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.order_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.order_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SpectatorPlayerClick {
        CDOTAUserMsg_SpectatorPlayerClick::new()
    }

    fn clear(&mut self) {
        self.entindex = ::std::option::Option::None;
        self.order_type = ::std::option::Option::None;
        self.target_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SpectatorPlayerClick {
        static instance: CDOTAUserMsg_SpectatorPlayerClick = CDOTAUserMsg_SpectatorPlayerClick {
            entindex: ::std::option::Option::None,
            order_type: ::std::option::Option::None,
            target_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SpectatorPlayerClick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SpectatorPlayerClick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SpectatorPlayerClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SpectatorPlayerClick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SpectatorPlayerUnitOrders {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.order_type)
    pub order_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.units)
    pub units: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.target_index)
    pub target_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.position)
    pub position: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.queue)
    pub queue: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.sequence_number)
    pub sequence_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SpectatorPlayerUnitOrders.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn default() -> &'a CDOTAUserMsg_SpectatorPlayerUnitOrders {
        <CDOTAUserMsg_SpectatorPlayerUnitOrders as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SpectatorPlayerUnitOrders {
    pub fn new() -> CDOTAUserMsg_SpectatorPlayerUnitOrders {
        ::std::default::Default::default()
    }

    // optional int32 entindex = 1;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional int32 order_type = 2;

    pub fn order_type(&self) -> i32 {
        self.order_type.unwrap_or(0)
    }

    pub fn clear_order_type(&mut self) {
        self.order_type = ::std::option::Option::None;
    }

    pub fn has_order_type(&self) -> bool {
        self.order_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: i32) {
        self.order_type = ::std::option::Option::Some(v);
    }

    // optional int32 target_index = 4;

    pub fn target_index(&self) -> i32 {
        self.target_index.unwrap_or(0)
    }

    pub fn clear_target_index(&mut self) {
        self.target_index = ::std::option::Option::None;
    }

    pub fn has_target_index(&self) -> bool {
        self.target_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_index(&mut self, v: i32) {
        self.target_index = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 5;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional bool queue = 7;

    pub fn queue(&self) -> bool {
        self.queue.unwrap_or(false)
    }

    pub fn clear_queue(&mut self) {
        self.queue = ::std::option::Option::None;
    }

    pub fn has_queue(&self) -> bool {
        self.queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue(&mut self, v: bool) {
        self.queue = ::std::option::Option::Some(v);
    }

    // optional int32 sequence_number = 8;

    pub fn sequence_number(&self) -> i32 {
        self.sequence_number.unwrap_or(0)
    }

    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = ::std::option::Option::None;
    }

    pub fn has_sequence_number(&self) -> bool {
        self.sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 9;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &CDOTAUserMsg_SpectatorPlayerUnitOrders| { &m.entindex },
            |m: &mut CDOTAUserMsg_SpectatorPlayerUnitOrders| { &mut m.entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "order_type",
            |m: &CDOTAUserMsg_SpectatorPlayerUnitOrders| { &m.order_type },
            |m: &mut CDOTAUserMsg_SpectatorPlayerUnitOrders| { &mut m.order_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "units",
            |m: &CDOTAUserMsg_SpectatorPlayerUnitOrders| { &m.units },
            |m: &mut CDOTAUserMsg_SpectatorPlayerUnitOrders| { &mut m.units },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_index",
            |m: &CDOTAUserMsg_SpectatorPlayerUnitOrders| { &m.target_index },
            |m: &mut CDOTAUserMsg_SpectatorPlayerUnitOrders| { &mut m.target_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &CDOTAUserMsg_SpectatorPlayerUnitOrders| { &m.ability_id },
            |m: &mut CDOTAUserMsg_SpectatorPlayerUnitOrders| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "position",
            |m: &CDOTAUserMsg_SpectatorPlayerUnitOrders| { &m.position },
            |m: &mut CDOTAUserMsg_SpectatorPlayerUnitOrders| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue",
            |m: &CDOTAUserMsg_SpectatorPlayerUnitOrders| { &m.queue },
            |m: &mut CDOTAUserMsg_SpectatorPlayerUnitOrders| { &mut m.queue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_number",
            |m: &CDOTAUserMsg_SpectatorPlayerUnitOrders| { &m.sequence_number },
            |m: &mut CDOTAUserMsg_SpectatorPlayerUnitOrders| { &mut m.sequence_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CDOTAUserMsg_SpectatorPlayerUnitOrders| { &m.flags },
            |m: &mut CDOTAUserMsg_SpectatorPlayerUnitOrders| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SpectatorPlayerUnitOrders>(
            "CDOTAUserMsg_SpectatorPlayerUnitOrders",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    const NAME: &'static str = "CDOTAUserMsg_SpectatorPlayerUnitOrders";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.order_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.units)?;
                },
                24 => {
                    self.units.push(is.read_int32()?);
                },
                32 => {
                    self.target_index = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                56 => {
                    self.queue = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.order_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.units {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        if let Some(v) = self.target_index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.queue {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sequence_number {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.order_type {
            os.write_int32(2, v)?;
        }
        for v in &self.units {
            os.write_int32(3, *v)?;
        };
        if let Some(v) = self.target_index {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.queue {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sequence_number {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SpectatorPlayerUnitOrders {
        CDOTAUserMsg_SpectatorPlayerUnitOrders::new()
    }

    fn clear(&mut self) {
        self.entindex = ::std::option::Option::None;
        self.order_type = ::std::option::Option::None;
        self.units.clear();
        self.target_index = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.position.clear();
        self.queue = ::std::option::Option::None;
        self.sequence_number = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SpectatorPlayerUnitOrders {
        static instance: CDOTAUserMsg_SpectatorPlayerUnitOrders = CDOTAUserMsg_SpectatorPlayerUnitOrders {
            entindex: ::std::option::Option::None,
            order_type: ::std::option::Option::None,
            units: ::std::vec::Vec::new(),
            target_index: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            position: ::protobuf::MessageField::none(),
            queue: ::std::option::Option::None,
            sequence_number: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SpectatorPlayerUnitOrders").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_NevermoreRequiem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_NevermoreRequiem {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NevermoreRequiem.entity_handle)
    pub entity_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NevermoreRequiem.lines)
    pub lines: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NevermoreRequiem.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_NevermoreRequiem.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_NevermoreRequiem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_NevermoreRequiem {
    fn default() -> &'a CDOTAUserMsg_NevermoreRequiem {
        <CDOTAUserMsg_NevermoreRequiem as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_NevermoreRequiem {
    pub fn new() -> CDOTAUserMsg_NevermoreRequiem {
        ::std::default::Default::default()
    }

    // optional uint32 entity_handle = 1;

    pub fn entity_handle(&self) -> u32 {
        self.entity_handle.unwrap_or(0)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: u32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    // optional int32 lines = 2;

    pub fn lines(&self) -> i32 {
        self.lines.unwrap_or(0)
    }

    pub fn clear_lines(&mut self) {
        self.lines = ::std::option::Option::None;
    }

    pub fn has_lines(&self) -> bool {
        self.lines.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lines(&mut self, v: i32) {
        self.lines = ::std::option::Option::Some(v);
    }

    // optional bool reverse = 4;

    pub fn reverse(&self) -> bool {
        self.reverse.unwrap_or(false)
    }

    pub fn clear_reverse(&mut self) {
        self.reverse = ::std::option::Option::None;
    }

    pub fn has_reverse(&self) -> bool {
        self.reverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_handle",
            |m: &CDOTAUserMsg_NevermoreRequiem| { &m.entity_handle },
            |m: &mut CDOTAUserMsg_NevermoreRequiem| { &mut m.entity_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lines",
            |m: &CDOTAUserMsg_NevermoreRequiem| { &m.lines },
            |m: &mut CDOTAUserMsg_NevermoreRequiem| { &mut m.lines },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CDOTAUserMsg_NevermoreRequiem| { &m.origin },
            |m: &mut CDOTAUserMsg_NevermoreRequiem| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &CDOTAUserMsg_NevermoreRequiem| { &m.reverse },
            |m: &mut CDOTAUserMsg_NevermoreRequiem| { &mut m.reverse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_NevermoreRequiem>(
            "CDOTAUserMsg_NevermoreRequiem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_NevermoreRequiem {
    const NAME: &'static str = "CDOTAUserMsg_NevermoreRequiem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lines = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                32 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lines {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lines {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_NevermoreRequiem {
        CDOTAUserMsg_NevermoreRequiem::new()
    }

    fn clear(&mut self) {
        self.entity_handle = ::std::option::Option::None;
        self.lines = ::std::option::Option::None;
        self.origin.clear();
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_NevermoreRequiem {
        static instance: CDOTAUserMsg_NevermoreRequiem = CDOTAUserMsg_NevermoreRequiem {
            entity_handle: ::std::option::Option::None,
            lines: ::std::option::Option::None,
            origin: ::protobuf::MessageField::none(),
            reverse: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_NevermoreRequiem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_NevermoreRequiem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_NevermoreRequiem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_NevermoreRequiem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_InvalidCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_InvalidCommand {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_InvalidCommand.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_InvalidCommand.sequence_number)
    pub sequence_number: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_InvalidCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_InvalidCommand {
    fn default() -> &'a CDOTAUserMsg_InvalidCommand {
        <CDOTAUserMsg_InvalidCommand as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_InvalidCommand {
    pub fn new() -> CDOTAUserMsg_InvalidCommand {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 sequence_number = 2;

    pub fn sequence_number(&self) -> i32 {
        self.sequence_number.unwrap_or(0)
    }

    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = ::std::option::Option::None;
    }

    pub fn has_sequence_number(&self) -> bool {
        self.sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CDOTAUserMsg_InvalidCommand| { &m.message },
            |m: &mut CDOTAUserMsg_InvalidCommand| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_number",
            |m: &CDOTAUserMsg_InvalidCommand| { &m.sequence_number },
            |m: &mut CDOTAUserMsg_InvalidCommand| { &mut m.sequence_number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_InvalidCommand>(
            "CDOTAUserMsg_InvalidCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_InvalidCommand {
    const NAME: &'static str = "CDOTAUserMsg_InvalidCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sequence_number {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sequence_number {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_InvalidCommand {
        CDOTAUserMsg_InvalidCommand::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.sequence_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_InvalidCommand {
        static instance: CDOTAUserMsg_InvalidCommand = CDOTAUserMsg_InvalidCommand {
            message: ::std::option::Option::None,
            sequence_number: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_InvalidCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_InvalidCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_InvalidCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_InvalidCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_HudError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HudError {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HudError.order_id)
    pub order_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HudError.sequence_number)
    pub sequence_number: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_HudError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HudError {
    fn default() -> &'a CDOTAUserMsg_HudError {
        <CDOTAUserMsg_HudError as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HudError {
    pub fn new() -> CDOTAUserMsg_HudError {
        ::std::default::Default::default()
    }

    // optional int32 order_id = 1;

    pub fn order_id(&self) -> i32 {
        self.order_id.unwrap_or(0)
    }

    pub fn clear_order_id(&mut self) {
        self.order_id = ::std::option::Option::None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: i32) {
        self.order_id = ::std::option::Option::Some(v);
    }

    // optional int32 sequence_number = 2;

    pub fn sequence_number(&self) -> i32 {
        self.sequence_number.unwrap_or(0)
    }

    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = ::std::option::Option::None;
    }

    pub fn has_sequence_number(&self) -> bool {
        self.sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "order_id",
            |m: &CDOTAUserMsg_HudError| { &m.order_id },
            |m: &mut CDOTAUserMsg_HudError| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_number",
            |m: &CDOTAUserMsg_HudError| { &m.sequence_number },
            |m: &mut CDOTAUserMsg_HudError| { &mut m.sequence_number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_HudError>(
            "CDOTAUserMsg_HudError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HudError {
    const NAME: &'static str = "CDOTAUserMsg_HudError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.sequence_number {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.order_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sequence_number {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HudError {
        CDOTAUserMsg_HudError::new()
    }

    fn clear(&mut self) {
        self.order_id = ::std::option::Option::None;
        self.sequence_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HudError {
        static instance: CDOTAUserMsg_HudError = CDOTAUserMsg_HudError {
            order_id: ::std::option::Option::None,
            sequence_number: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_HudError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_HudError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_HudError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HudError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SharedCooldown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SharedCooldown {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SharedCooldown.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SharedCooldown.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SharedCooldown.cooldown)
    pub cooldown: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SharedCooldown.name_index)
    pub name_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SharedCooldown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SharedCooldown {
    fn default() -> &'a CDOTAUserMsg_SharedCooldown {
        <CDOTAUserMsg_SharedCooldown as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SharedCooldown {
    pub fn new() -> CDOTAUserMsg_SharedCooldown {
        ::std::default::Default::default()
    }

    // optional int32 entindex = 1;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float cooldown = 3;

    pub fn cooldown(&self) -> f32 {
        self.cooldown.unwrap_or(0.)
    }

    pub fn clear_cooldown(&mut self) {
        self.cooldown = ::std::option::Option::None;
    }

    pub fn has_cooldown(&self) -> bool {
        self.cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown(&mut self, v: f32) {
        self.cooldown = ::std::option::Option::Some(v);
    }

    // optional int32 name_index = 4;

    pub fn name_index(&self) -> i32 {
        self.name_index.unwrap_or(0)
    }

    pub fn clear_name_index(&mut self) {
        self.name_index = ::std::option::Option::None;
    }

    pub fn has_name_index(&self) -> bool {
        self.name_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_index(&mut self, v: i32) {
        self.name_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &CDOTAUserMsg_SharedCooldown| { &m.entindex },
            |m: &mut CDOTAUserMsg_SharedCooldown| { &mut m.entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CDOTAUserMsg_SharedCooldown| { &m.name },
            |m: &mut CDOTAUserMsg_SharedCooldown| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cooldown",
            |m: &CDOTAUserMsg_SharedCooldown| { &m.cooldown },
            |m: &mut CDOTAUserMsg_SharedCooldown| { &mut m.cooldown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_index",
            |m: &CDOTAUserMsg_SharedCooldown| { &m.name_index },
            |m: &mut CDOTAUserMsg_SharedCooldown| { &mut m.name_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SharedCooldown>(
            "CDOTAUserMsg_SharedCooldown",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SharedCooldown {
    const NAME: &'static str = "CDOTAUserMsg_SharedCooldown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                29 => {
                    self.cooldown = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.name_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cooldown {
            my_size += 1 + 4;
        }
        if let Some(v) = self.name_index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.cooldown {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.name_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SharedCooldown {
        CDOTAUserMsg_SharedCooldown::new()
    }

    fn clear(&mut self) {
        self.entindex = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.cooldown = ::std::option::Option::None;
        self.name_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SharedCooldown {
        static instance: CDOTAUserMsg_SharedCooldown = CDOTAUserMsg_SharedCooldown {
            entindex: ::std::option::Option::None,
            name: ::std::option::Option::None,
            cooldown: ::std::option::Option::None,
            name_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SharedCooldown {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SharedCooldown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SharedCooldown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SharedCooldown {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SetNextAutobuyItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SetNextAutobuyItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SetNextAutobuyItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SetNextAutobuyItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SetNextAutobuyItem {
    fn default() -> &'a CDOTAUserMsg_SetNextAutobuyItem {
        <CDOTAUserMsg_SetNextAutobuyItem as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SetNextAutobuyItem {
    pub fn new() -> CDOTAUserMsg_SetNextAutobuyItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CDOTAUserMsg_SetNextAutobuyItem| { &m.name },
            |m: &mut CDOTAUserMsg_SetNextAutobuyItem| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SetNextAutobuyItem>(
            "CDOTAUserMsg_SetNextAutobuyItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SetNextAutobuyItem {
    const NAME: &'static str = "CDOTAUserMsg_SetNextAutobuyItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SetNextAutobuyItem {
        CDOTAUserMsg_SetNextAutobuyItem::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SetNextAutobuyItem {
        static instance: CDOTAUserMsg_SetNextAutobuyItem = CDOTAUserMsg_SetNextAutobuyItem {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SetNextAutobuyItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SetNextAutobuyItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SetNextAutobuyItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SetNextAutobuyItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_HalloweenDrops)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HalloweenDrops {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HalloweenDrops.item_defs)
    pub item_defs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HalloweenDrops.player_ids)
    pub player_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HalloweenDrops.prize_list)
    pub prize_list: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_HalloweenDrops.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HalloweenDrops {
    fn default() -> &'a CDOTAUserMsg_HalloweenDrops {
        <CDOTAUserMsg_HalloweenDrops as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HalloweenDrops {
    pub fn new() -> CDOTAUserMsg_HalloweenDrops {
        ::std::default::Default::default()
    }

    // optional uint32 prize_list = 3;

    pub fn prize_list(&self) -> u32 {
        self.prize_list.unwrap_or(0)
    }

    pub fn clear_prize_list(&mut self) {
        self.prize_list = ::std::option::Option::None;
    }

    pub fn has_prize_list(&self) -> bool {
        self.prize_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_list(&mut self, v: u32) {
        self.prize_list = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_defs",
            |m: &CDOTAUserMsg_HalloweenDrops| { &m.item_defs },
            |m: &mut CDOTAUserMsg_HalloweenDrops| { &mut m.item_defs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_ids",
            |m: &CDOTAUserMsg_HalloweenDrops| { &m.player_ids },
            |m: &mut CDOTAUserMsg_HalloweenDrops| { &mut m.player_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prize_list",
            |m: &CDOTAUserMsg_HalloweenDrops| { &m.prize_list },
            |m: &mut CDOTAUserMsg_HalloweenDrops| { &mut m.prize_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_HalloweenDrops>(
            "CDOTAUserMsg_HalloweenDrops",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HalloweenDrops {
    const NAME: &'static str = "CDOTAUserMsg_HalloweenDrops";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.item_defs)?;
                },
                8 => {
                    self.item_defs.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.player_ids)?;
                },
                16 => {
                    self.player_ids.push(is.read_int32()?);
                },
                24 => {
                    self.prize_list = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_defs {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.player_ids {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        if let Some(v) = self.prize_list {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_defs {
            os.write_uint32(1, *v)?;
        };
        for v in &self.player_ids {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.prize_list {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HalloweenDrops {
        CDOTAUserMsg_HalloweenDrops::new()
    }

    fn clear(&mut self) {
        self.item_defs.clear();
        self.player_ids.clear();
        self.prize_list = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HalloweenDrops {
        static instance: CDOTAUserMsg_HalloweenDrops = CDOTAUserMsg_HalloweenDrops {
            item_defs: ::std::vec::Vec::new(),
            player_ids: ::std::vec::Vec::new(),
            prize_list: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_HalloweenDrops {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_HalloweenDrops").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_HalloweenDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HalloweenDrops {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_PredictionResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PredictionResult {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PredictionResult.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PredictionResult.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PredictionResult.correct)
    pub correct: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PredictionResult.predictions)
    pub predictions: ::std::vec::Vec<cdotauser_msg_prediction_result::Prediction>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_PredictionResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PredictionResult {
    fn default() -> &'a CDOTAUserMsg_PredictionResult {
        <CDOTAUserMsg_PredictionResult as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PredictionResult {
    pub fn new() -> CDOTAUserMsg_PredictionResult {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool correct = 3;

    pub fn correct(&self) -> bool {
        self.correct.unwrap_or(false)
    }

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: bool) {
        self.correct = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CDOTAUserMsg_PredictionResult| { &m.account_id },
            |m: &mut CDOTAUserMsg_PredictionResult| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CDOTAUserMsg_PredictionResult| { &m.match_id },
            |m: &mut CDOTAUserMsg_PredictionResult| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "correct",
            |m: &CDOTAUserMsg_PredictionResult| { &m.correct },
            |m: &mut CDOTAUserMsg_PredictionResult| { &mut m.correct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "predictions",
            |m: &CDOTAUserMsg_PredictionResult| { &m.predictions },
            |m: &mut CDOTAUserMsg_PredictionResult| { &mut m.predictions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_PredictionResult>(
            "CDOTAUserMsg_PredictionResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_PredictionResult {
    const NAME: &'static str = "CDOTAUserMsg_PredictionResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.correct = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.predictions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.correct {
            my_size += 1 + 1;
        }
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.correct {
            os.write_bool(3, v)?;
        }
        for v in &self.predictions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PredictionResult {
        CDOTAUserMsg_PredictionResult::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.correct = ::std::option::Option::None;
        self.predictions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PredictionResult {
        static instance: CDOTAUserMsg_PredictionResult = CDOTAUserMsg_PredictionResult {
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            correct: ::std::option::Option::None,
            predictions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_PredictionResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_PredictionResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_PredictionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PredictionResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_PredictionResult`
pub mod cdotauser_msg_prediction_result {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_PredictionResult.Prediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Prediction {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PredictionResult.Prediction.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PredictionResult.Prediction.num_correct)
        pub num_correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PredictionResult.Prediction.num_fails)
        pub num_fails: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PredictionResult.Prediction.result)
        pub result: ::std::option::Option<::protobuf::EnumOrUnknown<prediction::EResult>>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PredictionResult.Prediction.granted_item_defs)
        pub granted_item_defs: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_PredictionResult.Prediction.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Prediction {
        fn default() -> &'a Prediction {
            <Prediction as ::protobuf::Message>::default_instance()
        }
    }

    impl Prediction {
        pub fn new() -> Prediction {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 num_correct = 2;

        pub fn num_correct(&self) -> u32 {
            self.num_correct.unwrap_or(0)
        }

        pub fn clear_num_correct(&mut self) {
            self.num_correct = ::std::option::Option::None;
        }

        pub fn has_num_correct(&self) -> bool {
            self.num_correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_correct(&mut self, v: u32) {
            self.num_correct = ::std::option::Option::Some(v);
        }

        // optional uint32 num_fails = 3;

        pub fn num_fails(&self) -> u32 {
            self.num_fails.unwrap_or(0)
        }

        pub fn clear_num_fails(&mut self) {
            self.num_fails = ::std::option::Option::None;
        }

        pub fn has_num_fails(&self) -> bool {
            self.num_fails.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_fails(&mut self, v: u32) {
            self.num_fails = ::std::option::Option::Some(v);
        }

        // optional .dota.CDOTAUserMsg_PredictionResult.Prediction.EResult result = 4;

        pub fn result(&self) -> prediction::EResult {
            match self.result {
                Some(e) => e.enum_value_or(prediction::EResult::k_eResult_ItemGranted),
                None => prediction::EResult::k_eResult_ItemGranted,
            }
        }

        pub fn clear_result(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_result(&self) -> bool {
            self.result.is_some()
        }

        // Param is passed by value, moved
        pub fn set_result(&mut self, v: prediction::EResult) {
            self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_def",
                |m: &Prediction| { &m.item_def },
                |m: &mut Prediction| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_correct",
                |m: &Prediction| { &m.num_correct },
                |m: &mut Prediction| { &mut m.num_correct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_fails",
                |m: &Prediction| { &m.num_fails },
                |m: &mut Prediction| { &mut m.num_fails },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "result",
                |m: &Prediction| { &m.result },
                |m: &mut Prediction| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "granted_item_defs",
                |m: &Prediction| { &m.granted_item_defs },
                |m: &mut Prediction| { &mut m.granted_item_defs },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Prediction>(
                "CDOTAUserMsg_PredictionResult.Prediction",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Prediction {
        const NAME: &'static str = "Prediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.num_correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.num_fails = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.granted_item_defs)?;
                    },
                    48 => {
                        self.granted_item_defs.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.num_correct {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.num_fails {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.result {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            for value in &self.granted_item_defs {
                my_size += ::protobuf::rt::uint32_size(6, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.num_correct {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.num_fails {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.result {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.granted_item_defs {
                os.write_uint32(6, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Prediction {
            Prediction::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.num_correct = ::std::option::Option::None;
            self.num_fails = ::std::option::Option::None;
            self.result = ::std::option::Option::None;
            self.granted_item_defs.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Prediction {
            static instance: Prediction = Prediction {
                item_def: ::std::option::Option::None,
                num_correct: ::std::option::Option::None,
                num_fails: ::std::option::Option::None,
                result: ::std::option::Option::None,
                granted_item_defs: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Prediction {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_PredictionResult.Prediction").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Prediction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Prediction {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Prediction`
    pub mod prediction {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:dota.CDOTAUserMsg_PredictionResult.Prediction.EResult)
        pub enum EResult {
            // @@protoc_insertion_point(enum_value:dota.CDOTAUserMsg_PredictionResult.Prediction.EResult.k_eResult_ItemGranted)
            k_eResult_ItemGranted = 1,
            // @@protoc_insertion_point(enum_value:dota.CDOTAUserMsg_PredictionResult.Prediction.EResult.k_eResult_Destroyed)
            k_eResult_Destroyed = 2,
        }

        impl ::protobuf::Enum for EResult {
            const NAME: &'static str = "EResult";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EResult> {
                match value {
                    1 => ::std::option::Option::Some(EResult::k_eResult_ItemGranted),
                    2 => ::std::option::Option::Some(EResult::k_eResult_Destroyed),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EResult> {
                match str {
                    "k_eResult_ItemGranted" => ::std::option::Option::Some(EResult::k_eResult_ItemGranted),
                    "k_eResult_Destroyed" => ::std::option::Option::Some(EResult::k_eResult_Destroyed),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EResult] = &[
                EResult::k_eResult_ItemGranted,
                EResult::k_eResult_Destroyed,
            ];
        }

        impl ::protobuf::EnumFull for EResult {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CDOTAUserMsg_PredictionResult.Prediction.EResult").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = match self {
                    EResult::k_eResult_ItemGranted => 0,
                    EResult::k_eResult_Destroyed => 1,
                };
                Self::enum_descriptor().value_by_index(index)
            }
        }

        // Note, `Default` is implemented although default value is not 0
        impl ::std::default::Default for EResult {
            fn default() -> Self {
                EResult::k_eResult_ItemGranted
            }
        }

        impl EResult {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResult>("CDOTAUserMsg_PredictionResult.Prediction.EResult")
            }
        }
    }
}

// @@protoc_insertion_point(message:dota.CDOTAResponseQuerySerialized)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAResponseQuerySerialized {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAResponseQuerySerialized.facts)
    pub facts: ::std::vec::Vec<cdotaresponse_query_serialized::Fact>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAResponseQuerySerialized.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAResponseQuerySerialized {
    fn default() -> &'a CDOTAResponseQuerySerialized {
        <CDOTAResponseQuerySerialized as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAResponseQuerySerialized {
    pub fn new() -> CDOTAResponseQuerySerialized {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "facts",
            |m: &CDOTAResponseQuerySerialized| { &m.facts },
            |m: &mut CDOTAResponseQuerySerialized| { &mut m.facts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAResponseQuerySerialized>(
            "CDOTAResponseQuerySerialized",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAResponseQuerySerialized {
    const NAME: &'static str = "CDOTAResponseQuerySerialized";

    fn is_initialized(&self) -> bool {
        for v in &self.facts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.facts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.facts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.facts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAResponseQuerySerialized {
        CDOTAResponseQuerySerialized::new()
    }

    fn clear(&mut self) {
        self.facts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAResponseQuerySerialized {
        static instance: CDOTAResponseQuerySerialized = CDOTAResponseQuerySerialized {
            facts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAResponseQuerySerialized {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAResponseQuerySerialized").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAResponseQuerySerialized {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAResponseQuerySerialized {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAResponseQuerySerialized`
pub mod cdotaresponse_query_serialized {
    // @@protoc_insertion_point(message:dota.CDOTAResponseQuerySerialized.Fact)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Fact {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAResponseQuerySerialized.Fact.key)
        pub key: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAResponseQuerySerialized.Fact.valtype)
        pub valtype: ::std::option::Option<::protobuf::EnumOrUnknown<fact::ValueType>>,
        // @@protoc_insertion_point(field:dota.CDOTAResponseQuerySerialized.Fact.val_numeric)
        pub val_numeric: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAResponseQuerySerialized.Fact.val_string)
        pub val_string: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CDOTAResponseQuerySerialized.Fact.val_stringtable_index)
        pub val_stringtable_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAResponseQuerySerialized.Fact.val_int_numeric)
        pub val_int_numeric: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAResponseQuerySerialized.Fact.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Fact {
        fn default() -> &'a Fact {
            <Fact as ::protobuf::Message>::default_instance()
        }
    }

    impl Fact {
        pub fn new() -> Fact {
            ::std::default::Default::default()
        }

        // required int32 key = 1;

        pub fn key(&self) -> i32 {
            self.key.unwrap_or(0)
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: i32) {
            self.key = ::std::option::Option::Some(v);
        }

        // required .dota.CDOTAResponseQuerySerialized.Fact.ValueType valtype = 2;

        pub fn valtype(&self) -> fact::ValueType {
            match self.valtype {
                Some(e) => e.enum_value_or(fact::ValueType::NUMERIC),
                None => fact::ValueType::NUMERIC,
            }
        }

        pub fn clear_valtype(&mut self) {
            self.valtype = ::std::option::Option::None;
        }

        pub fn has_valtype(&self) -> bool {
            self.valtype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_valtype(&mut self, v: fact::ValueType) {
            self.valtype = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional float val_numeric = 3;

        pub fn val_numeric(&self) -> f32 {
            self.val_numeric.unwrap_or(0.)
        }

        pub fn clear_val_numeric(&mut self) {
            self.val_numeric = ::std::option::Option::None;
        }

        pub fn has_val_numeric(&self) -> bool {
            self.val_numeric.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_numeric(&mut self, v: f32) {
            self.val_numeric = ::std::option::Option::Some(v);
        }

        // optional string val_string = 4;

        pub fn val_string(&self) -> &str {
            match self.val_string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_val_string(&mut self) {
            self.val_string = ::std::option::Option::None;
        }

        pub fn has_val_string(&self) -> bool {
            self.val_string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_string(&mut self, v: ::std::string::String) {
            self.val_string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
            if self.val_string.is_none() {
                self.val_string = ::std::option::Option::Some(::std::string::String::new());
            }
            self.val_string.as_mut().unwrap()
        }

        // Take field
        pub fn take_val_string(&mut self) -> ::std::string::String {
            self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 val_stringtable_index = 5;

        pub fn val_stringtable_index(&self) -> i32 {
            self.val_stringtable_index.unwrap_or(0)
        }

        pub fn clear_val_stringtable_index(&mut self) {
            self.val_stringtable_index = ::std::option::Option::None;
        }

        pub fn has_val_stringtable_index(&self) -> bool {
            self.val_stringtable_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_stringtable_index(&mut self, v: i32) {
            self.val_stringtable_index = ::std::option::Option::Some(v);
        }

        // optional sint32 val_int_numeric = 6;

        pub fn val_int_numeric(&self) -> i32 {
            self.val_int_numeric.unwrap_or(0)
        }

        pub fn clear_val_int_numeric(&mut self) {
            self.val_int_numeric = ::std::option::Option::None;
        }

        pub fn has_val_int_numeric(&self) -> bool {
            self.val_int_numeric.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_int_numeric(&mut self, v: i32) {
            self.val_int_numeric = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &Fact| { &m.key },
                |m: &mut Fact| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "valtype",
                |m: &Fact| { &m.valtype },
                |m: &mut Fact| { &mut m.valtype },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_numeric",
                |m: &Fact| { &m.val_numeric },
                |m: &mut Fact| { &mut m.val_numeric },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_string",
                |m: &Fact| { &m.val_string },
                |m: &mut Fact| { &mut m.val_string },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_stringtable_index",
                |m: &Fact| { &m.val_stringtable_index },
                |m: &mut Fact| { &mut m.val_stringtable_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_int_numeric",
                |m: &Fact| { &m.val_int_numeric },
                |m: &mut Fact| { &mut m.val_int_numeric },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Fact>(
                "CDOTAResponseQuerySerialized.Fact",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Fact {
        const NAME: &'static str = "Fact";

        fn is_initialized(&self) -> bool {
            if self.key.is_none() {
                return false;
            }
            if self.valtype.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.key = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.valtype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    29 => {
                        self.val_numeric = ::std::option::Option::Some(is.read_float()?);
                    },
                    34 => {
                        self.val_string = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.val_stringtable_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.val_int_numeric = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.valtype {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.val_numeric {
                my_size += 1 + 4;
            }
            if let Some(v) = self.val_string.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.val_stringtable_index {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.val_int_numeric {
                my_size += ::protobuf::rt::sint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.key {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.valtype {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.val_numeric {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.val_string.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.val_stringtable_index {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.val_int_numeric {
                os.write_sint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Fact {
            Fact::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.valtype = ::std::option::Option::None;
            self.val_numeric = ::std::option::Option::None;
            self.val_string = ::std::option::Option::None;
            self.val_stringtable_index = ::std::option::Option::None;
            self.val_int_numeric = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Fact {
            static instance: Fact = Fact {
                key: ::std::option::Option::None,
                valtype: ::std::option::Option::None,
                val_numeric: ::std::option::Option::None,
                val_string: ::std::option::Option::None,
                val_stringtable_index: ::std::option::Option::None,
                val_int_numeric: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Fact {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAResponseQuerySerialized.Fact").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Fact {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Fact {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Fact`
    pub mod fact {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:dota.CDOTAResponseQuerySerialized.Fact.ValueType)
        pub enum ValueType {
            // @@protoc_insertion_point(enum_value:dota.CDOTAResponseQuerySerialized.Fact.ValueType.NUMERIC)
            NUMERIC = 1,
            // @@protoc_insertion_point(enum_value:dota.CDOTAResponseQuerySerialized.Fact.ValueType.STRING)
            STRING = 2,
            // @@protoc_insertion_point(enum_value:dota.CDOTAResponseQuerySerialized.Fact.ValueType.STRINGTABLE_INDEX)
            STRINGTABLE_INDEX = 3,
            // @@protoc_insertion_point(enum_value:dota.CDOTAResponseQuerySerialized.Fact.ValueType.INT_NUMERIC)
            INT_NUMERIC = 4,
        }

        impl ::protobuf::Enum for ValueType {
            const NAME: &'static str = "ValueType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ValueType> {
                match value {
                    1 => ::std::option::Option::Some(ValueType::NUMERIC),
                    2 => ::std::option::Option::Some(ValueType::STRING),
                    3 => ::std::option::Option::Some(ValueType::STRINGTABLE_INDEX),
                    4 => ::std::option::Option::Some(ValueType::INT_NUMERIC),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<ValueType> {
                match str {
                    "NUMERIC" => ::std::option::Option::Some(ValueType::NUMERIC),
                    "STRING" => ::std::option::Option::Some(ValueType::STRING),
                    "STRINGTABLE_INDEX" => ::std::option::Option::Some(ValueType::STRINGTABLE_INDEX),
                    "INT_NUMERIC" => ::std::option::Option::Some(ValueType::INT_NUMERIC),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ValueType] = &[
                ValueType::NUMERIC,
                ValueType::STRING,
                ValueType::STRINGTABLE_INDEX,
                ValueType::INT_NUMERIC,
            ];
        }

        impl ::protobuf::EnumFull for ValueType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CDOTAResponseQuerySerialized.Fact.ValueType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = match self {
                    ValueType::NUMERIC => 0,
                    ValueType::STRING => 1,
                    ValueType::STRINGTABLE_INDEX => 2,
                    ValueType::INT_NUMERIC => 3,
                };
                Self::enum_descriptor().value_by_index(index)
            }
        }

        // Note, `Default` is implemented although default value is not 0
        impl ::std::default::Default for ValueType {
            fn default() -> Self {
                ValueType::NUMERIC
            }
        }

        impl ValueType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ValueType>("CDOTAResponseQuerySerialized.Fact.ValueType")
            }
        }
    }
}

// @@protoc_insertion_point(message:dota.CDOTASpeechMatchOnClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTASpeechMatchOnClient {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTASpeechMatchOnClient.speech_concept)
    pub speech_concept: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTASpeechMatchOnClient.recipient_type)
    pub recipient_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTASpeechMatchOnClient.responsequery)
    pub responsequery: ::protobuf::MessageField<CDOTAResponseQuerySerialized>,
    // @@protoc_insertion_point(field:dota.CDOTASpeechMatchOnClient.randomseed)
    pub randomseed: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTASpeechMatchOnClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTASpeechMatchOnClient {
    fn default() -> &'a CDOTASpeechMatchOnClient {
        <CDOTASpeechMatchOnClient as ::protobuf::Message>::default_instance()
    }
}

impl CDOTASpeechMatchOnClient {
    pub fn new() -> CDOTASpeechMatchOnClient {
        ::std::default::Default::default()
    }

    // optional int32 speech_concept = 1;

    pub fn speech_concept(&self) -> i32 {
        self.speech_concept.unwrap_or(0)
    }

    pub fn clear_speech_concept(&mut self) {
        self.speech_concept = ::std::option::Option::None;
    }

    pub fn has_speech_concept(&self) -> bool {
        self.speech_concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speech_concept(&mut self, v: i32) {
        self.speech_concept = ::std::option::Option::Some(v);
    }

    // optional int32 recipient_type = 2;

    pub fn recipient_type(&self) -> i32 {
        self.recipient_type.unwrap_or(0)
    }

    pub fn clear_recipient_type(&mut self) {
        self.recipient_type = ::std::option::Option::None;
    }

    pub fn has_recipient_type(&self) -> bool {
        self.recipient_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_type(&mut self, v: i32) {
        self.recipient_type = ::std::option::Option::Some(v);
    }

    // optional sfixed32 randomseed = 4;

    pub fn randomseed(&self) -> i32 {
        self.randomseed.unwrap_or(0)
    }

    pub fn clear_randomseed(&mut self) {
        self.randomseed = ::std::option::Option::None;
    }

    pub fn has_randomseed(&self) -> bool {
        self.randomseed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomseed(&mut self, v: i32) {
        self.randomseed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speech_concept",
            |m: &CDOTASpeechMatchOnClient| { &m.speech_concept },
            |m: &mut CDOTASpeechMatchOnClient| { &mut m.speech_concept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipient_type",
            |m: &CDOTASpeechMatchOnClient| { &m.recipient_type },
            |m: &mut CDOTASpeechMatchOnClient| { &mut m.recipient_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDOTAResponseQuerySerialized>(
            "responsequery",
            |m: &CDOTASpeechMatchOnClient| { &m.responsequery },
            |m: &mut CDOTASpeechMatchOnClient| { &mut m.responsequery },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "randomseed",
            |m: &CDOTASpeechMatchOnClient| { &m.randomseed },
            |m: &mut CDOTASpeechMatchOnClient| { &mut m.randomseed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTASpeechMatchOnClient>(
            "CDOTASpeechMatchOnClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTASpeechMatchOnClient {
    const NAME: &'static str = "CDOTASpeechMatchOnClient";

    fn is_initialized(&self) -> bool {
        for v in &self.responsequery {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.speech_concept = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.recipient_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.responsequery)?;
                },
                37 => {
                    self.randomseed = ::std::option::Option::Some(is.read_sfixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.speech_concept {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.recipient_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.responsequery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.randomseed {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.speech_concept {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.recipient_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.responsequery.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.randomseed {
            os.write_sfixed32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTASpeechMatchOnClient {
        CDOTASpeechMatchOnClient::new()
    }

    fn clear(&mut self) {
        self.speech_concept = ::std::option::Option::None;
        self.recipient_type = ::std::option::Option::None;
        self.responsequery.clear();
        self.randomseed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTASpeechMatchOnClient {
        static instance: CDOTASpeechMatchOnClient = CDOTASpeechMatchOnClient {
            speech_concept: ::std::option::Option::None,
            recipient_type: ::std::option::Option::None,
            responsequery: ::protobuf::MessageField::none(),
            randomseed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTASpeechMatchOnClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTASpeechMatchOnClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTASpeechMatchOnClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTASpeechMatchOnClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_UnitEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_UnitEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.msg_type)
    pub msg_type: ::std::option::Option<::protobuf::EnumOrUnknown<EDotaEntityMessages>>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.speech)
    pub speech: ::protobuf::MessageField<cdotauser_msg_unit_event::Speech>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.speech_mute)
    pub speech_mute: ::protobuf::MessageField<cdotauser_msg_unit_event::SpeechMute>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.add_gesture)
    pub add_gesture: ::protobuf::MessageField<cdotauser_msg_unit_event::AddGesture>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.remove_gesture)
    pub remove_gesture: ::protobuf::MessageField<cdotauser_msg_unit_event::RemoveGesture>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.blood_impact)
    pub blood_impact: ::protobuf::MessageField<cdotauser_msg_unit_event::BloodImpact>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.fade_gesture)
    pub fade_gesture: ::protobuf::MessageField<cdotauser_msg_unit_event::FadeGesture>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.speech_match_on_client)
    pub speech_match_on_client: ::protobuf::MessageField<CDOTASpeechMatchOnClient>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UnitEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_UnitEvent {
    fn default() -> &'a CDOTAUserMsg_UnitEvent {
        <CDOTAUserMsg_UnitEvent as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_UnitEvent {
    pub fn new() -> CDOTAUserMsg_UnitEvent {
        ::std::default::Default::default()
    }

    // required .dota.EDotaEntityMessages msg_type = 1;

    pub fn msg_type(&self) -> EDotaEntityMessages {
        match self.msg_type {
            Some(e) => e.enum_value_or(EDotaEntityMessages::DOTA_UNIT_SPEECH),
            None => EDotaEntityMessages::DOTA_UNIT_SPEECH,
        }
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: EDotaEntityMessages) {
        self.msg_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 entity_index = 2;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CDOTAUserMsg_UnitEvent| { &m.msg_type },
            |m: &mut CDOTAUserMsg_UnitEvent| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CDOTAUserMsg_UnitEvent| { &m.entity_index },
            |m: &mut CDOTAUserMsg_UnitEvent| { &mut m.entity_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cdotauser_msg_unit_event::Speech>(
            "speech",
            |m: &CDOTAUserMsg_UnitEvent| { &m.speech },
            |m: &mut CDOTAUserMsg_UnitEvent| { &mut m.speech },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cdotauser_msg_unit_event::SpeechMute>(
            "speech_mute",
            |m: &CDOTAUserMsg_UnitEvent| { &m.speech_mute },
            |m: &mut CDOTAUserMsg_UnitEvent| { &mut m.speech_mute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cdotauser_msg_unit_event::AddGesture>(
            "add_gesture",
            |m: &CDOTAUserMsg_UnitEvent| { &m.add_gesture },
            |m: &mut CDOTAUserMsg_UnitEvent| { &mut m.add_gesture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cdotauser_msg_unit_event::RemoveGesture>(
            "remove_gesture",
            |m: &CDOTAUserMsg_UnitEvent| { &m.remove_gesture },
            |m: &mut CDOTAUserMsg_UnitEvent| { &mut m.remove_gesture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cdotauser_msg_unit_event::BloodImpact>(
            "blood_impact",
            |m: &CDOTAUserMsg_UnitEvent| { &m.blood_impact },
            |m: &mut CDOTAUserMsg_UnitEvent| { &mut m.blood_impact },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cdotauser_msg_unit_event::FadeGesture>(
            "fade_gesture",
            |m: &CDOTAUserMsg_UnitEvent| { &m.fade_gesture },
            |m: &mut CDOTAUserMsg_UnitEvent| { &mut m.fade_gesture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDOTASpeechMatchOnClient>(
            "speech_match_on_client",
            |m: &CDOTAUserMsg_UnitEvent| { &m.speech_match_on_client },
            |m: &mut CDOTAUserMsg_UnitEvent| { &mut m.speech_match_on_client },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_UnitEvent>(
            "CDOTAUserMsg_UnitEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent {
    const NAME: &'static str = "CDOTAUserMsg_UnitEvent";

    fn is_initialized(&self) -> bool {
        if self.msg_type.is_none() {
            return false;
        }
        if self.entity_index.is_none() {
            return false;
        }
        for v in &self.speech {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speech_mute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_gesture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remove_gesture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blood_impact {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fade_gesture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speech_match_on_client {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.speech)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.speech_mute)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.add_gesture)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.remove_gesture)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.blood_impact)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fade_gesture)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.speech_match_on_client)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.speech.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.speech_mute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.add_gesture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.remove_gesture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.blood_impact.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fade_gesture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.speech_match_on_client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.speech.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.speech_mute.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.add_gesture.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.remove_gesture.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.blood_impact.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.fade_gesture.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.speech_match_on_client.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_UnitEvent {
        CDOTAUserMsg_UnitEvent::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.speech.clear();
        self.speech_mute.clear();
        self.add_gesture.clear();
        self.remove_gesture.clear();
        self.blood_impact.clear();
        self.fade_gesture.clear();
        self.speech_match_on_client.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_UnitEvent {
        static instance: CDOTAUserMsg_UnitEvent = CDOTAUserMsg_UnitEvent {
            msg_type: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            speech: ::protobuf::MessageField::none(),
            speech_mute: ::protobuf::MessageField::none(),
            add_gesture: ::protobuf::MessageField::none(),
            remove_gesture: ::protobuf::MessageField::none(),
            blood_impact: ::protobuf::MessageField::none(),
            fade_gesture: ::protobuf::MessageField::none(),
            speech_match_on_client: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_UnitEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UnitEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_UnitEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UnitEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_UnitEvent`
pub mod cdotauser_msg_unit_event {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_UnitEvent.Interval)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Interval {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.Interval.start)
        pub start: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.Interval.range)
        pub range: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UnitEvent.Interval.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Interval {
        fn default() -> &'a Interval {
            <Interval as ::protobuf::Message>::default_instance()
        }
    }

    impl Interval {
        pub fn new() -> Interval {
            ::std::default::Default::default()
        }

        // optional float start = 1;

        pub fn start(&self) -> f32 {
            self.start.unwrap_or(0.)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: f32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional float range = 2;

        pub fn range(&self) -> f32 {
            self.range.unwrap_or(0.)
        }

        pub fn clear_range(&mut self) {
            self.range = ::std::option::Option::None;
        }

        pub fn has_range(&self) -> bool {
            self.range.is_some()
        }

        // Param is passed by value, moved
        pub fn set_range(&mut self, v: f32) {
            self.range = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start",
                |m: &Interval| { &m.start },
                |m: &mut Interval| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "range",
                |m: &Interval| { &m.range },
                |m: &mut Interval| { &mut m.range },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Interval>(
                "CDOTAUserMsg_UnitEvent.Interval",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Interval {
        const NAME: &'static str = "Interval";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.start = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.range = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += 1 + 4;
            }
            if let Some(v) = self.range {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.start {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.range {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Interval {
            Interval::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.range = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Interval {
            static instance: Interval = Interval {
                start: ::std::option::Option::None,
                range: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Interval {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UnitEvent.Interval").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Interval {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Interval {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_UnitEvent.Speech)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Speech {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.Speech.speech_concept)
        pub speech_concept: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.Speech.response)
        pub response: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.Speech.recipient_type)
        pub recipient_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.Speech.muteable)
        pub muteable: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.Speech.predelay)
        pub predelay: ::protobuf::MessageField<Interval>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.Speech.flags)
        pub flags: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UnitEvent.Speech.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Speech {
        fn default() -> &'a Speech {
            <Speech as ::protobuf::Message>::default_instance()
        }
    }

    impl Speech {
        pub fn new() -> Speech {
            ::std::default::Default::default()
        }

        // optional int32 speech_concept = 1;

        pub fn speech_concept(&self) -> i32 {
            self.speech_concept.unwrap_or(0)
        }

        pub fn clear_speech_concept(&mut self) {
            self.speech_concept = ::std::option::Option::None;
        }

        pub fn has_speech_concept(&self) -> bool {
            self.speech_concept.is_some()
        }

        // Param is passed by value, moved
        pub fn set_speech_concept(&mut self, v: i32) {
            self.speech_concept = ::std::option::Option::Some(v);
        }

        // optional string response = 2;

        pub fn response(&self) -> &str {
            match self.response.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_response(&mut self) {
            self.response = ::std::option::Option::None;
        }

        pub fn has_response(&self) -> bool {
            self.response.is_some()
        }

        // Param is passed by value, moved
        pub fn set_response(&mut self, v: ::std::string::String) {
            self.response = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_response(&mut self) -> &mut ::std::string::String {
            if self.response.is_none() {
                self.response = ::std::option::Option::Some(::std::string::String::new());
            }
            self.response.as_mut().unwrap()
        }

        // Take field
        pub fn take_response(&mut self) -> ::std::string::String {
            self.response.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 recipient_type = 3;

        pub fn recipient_type(&self) -> i32 {
            self.recipient_type.unwrap_or(0)
        }

        pub fn clear_recipient_type(&mut self) {
            self.recipient_type = ::std::option::Option::None;
        }

        pub fn has_recipient_type(&self) -> bool {
            self.recipient_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_recipient_type(&mut self, v: i32) {
            self.recipient_type = ::std::option::Option::Some(v);
        }

        // optional bool muteable = 5;

        pub fn muteable(&self) -> bool {
            self.muteable.unwrap_or(false)
        }

        pub fn clear_muteable(&mut self) {
            self.muteable = ::std::option::Option::None;
        }

        pub fn has_muteable(&self) -> bool {
            self.muteable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_muteable(&mut self, v: bool) {
            self.muteable = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 7;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "speech_concept",
                |m: &Speech| { &m.speech_concept },
                |m: &mut Speech| { &mut m.speech_concept },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "response",
                |m: &Speech| { &m.response },
                |m: &mut Speech| { &mut m.response },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "recipient_type",
                |m: &Speech| { &m.recipient_type },
                |m: &mut Speech| { &mut m.recipient_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "muteable",
                |m: &Speech| { &m.muteable },
                |m: &mut Speech| { &mut m.muteable },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Interval>(
                "predelay",
                |m: &Speech| { &m.predelay },
                |m: &mut Speech| { &mut m.predelay },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &Speech| { &m.flags },
                |m: &mut Speech| { &mut m.flags },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Speech>(
                "CDOTAUserMsg_UnitEvent.Speech",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Speech {
        const NAME: &'static str = "Speech";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.speech_concept = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.response = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.recipient_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.muteable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.predelay)?;
                    },
                    56 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.speech_concept {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.response.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.recipient_type {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.muteable {
                my_size += 1 + 1;
            }
            if let Some(v) = self.predelay.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.speech_concept {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.response.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.recipient_type {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.muteable {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.predelay.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Speech {
            Speech::new()
        }

        fn clear(&mut self) {
            self.speech_concept = ::std::option::Option::None;
            self.response = ::std::option::Option::None;
            self.recipient_type = ::std::option::Option::None;
            self.muteable = ::std::option::Option::None;
            self.predelay.clear();
            self.flags = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Speech {
            static instance: Speech = Speech {
                speech_concept: ::std::option::Option::None,
                response: ::std::option::Option::None,
                recipient_type: ::std::option::Option::None,
                muteable: ::std::option::Option::None,
                predelay: ::protobuf::MessageField::none(),
                flags: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Speech {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UnitEvent.Speech").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Speech {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Speech {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_UnitEvent.SpeechMute)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SpeechMute {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.SpeechMute.delay)
        pub delay: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UnitEvent.SpeechMute.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SpeechMute {
        fn default() -> &'a SpeechMute {
            <SpeechMute as ::protobuf::Message>::default_instance()
        }
    }

    impl SpeechMute {
        pub fn new() -> SpeechMute {
            ::std::default::Default::default()
        }

        // optional float delay = 1;

        pub fn delay(&self) -> f32 {
            self.delay.unwrap_or(0.)
        }

        pub fn clear_delay(&mut self) {
            self.delay = ::std::option::Option::None;
        }

        pub fn has_delay(&self) -> bool {
            self.delay.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delay(&mut self, v: f32) {
            self.delay = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "delay",
                |m: &SpeechMute| { &m.delay },
                |m: &mut SpeechMute| { &mut m.delay },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpeechMute>(
                "CDOTAUserMsg_UnitEvent.SpeechMute",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SpeechMute {
        const NAME: &'static str = "SpeechMute";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.delay = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.delay {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.delay {
                os.write_float(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SpeechMute {
            SpeechMute::new()
        }

        fn clear(&mut self) {
            self.delay = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SpeechMute {
            static instance: SpeechMute = SpeechMute {
                delay: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SpeechMute {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UnitEvent.SpeechMute").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SpeechMute {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SpeechMute {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_UnitEvent.AddGesture)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AddGesture {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.AddGesture.activity)
        pub activity: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.AddGesture.slot)
        pub slot: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.AddGesture.fade_in)
        pub fade_in: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.AddGesture.fade_out)
        pub fade_out: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.AddGesture.playback_rate)
        pub playback_rate: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.AddGesture.sequence_variant)
        pub sequence_variant: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UnitEvent.AddGesture.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AddGesture {
        fn default() -> &'a AddGesture {
            <AddGesture as ::protobuf::Message>::default_instance()
        }
    }

    impl AddGesture {
        pub fn new() -> AddGesture {
            ::std::default::Default::default()
        }

        // optional int32 activity = 1;

        pub fn activity(&self) -> i32 {
            self.activity.unwrap_or(0)
        }

        pub fn clear_activity(&mut self) {
            self.activity = ::std::option::Option::None;
        }

        pub fn has_activity(&self) -> bool {
            self.activity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_activity(&mut self, v: i32) {
            self.activity = ::std::option::Option::Some(v);
        }

        // optional int32 slot = 2;

        pub fn slot(&self) -> i32 {
            self.slot.unwrap_or(0)
        }

        pub fn clear_slot(&mut self) {
            self.slot = ::std::option::Option::None;
        }

        pub fn has_slot(&self) -> bool {
            self.slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot(&mut self, v: i32) {
            self.slot = ::std::option::Option::Some(v);
        }

        // optional float fade_in = 3;

        pub fn fade_in(&self) -> f32 {
            self.fade_in.unwrap_or(0.)
        }

        pub fn clear_fade_in(&mut self) {
            self.fade_in = ::std::option::Option::None;
        }

        pub fn has_fade_in(&self) -> bool {
            self.fade_in.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fade_in(&mut self, v: f32) {
            self.fade_in = ::std::option::Option::Some(v);
        }

        // optional float fade_out = 4;

        pub fn fade_out(&self) -> f32 {
            self.fade_out.unwrap_or(0.)
        }

        pub fn clear_fade_out(&mut self) {
            self.fade_out = ::std::option::Option::None;
        }

        pub fn has_fade_out(&self) -> bool {
            self.fade_out.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fade_out(&mut self, v: f32) {
            self.fade_out = ::std::option::Option::Some(v);
        }

        // optional float playback_rate = 5;

        pub fn playback_rate(&self) -> f32 {
            self.playback_rate.unwrap_or(0.)
        }

        pub fn clear_playback_rate(&mut self) {
            self.playback_rate = ::std::option::Option::None;
        }

        pub fn has_playback_rate(&self) -> bool {
            self.playback_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playback_rate(&mut self, v: f32) {
            self.playback_rate = ::std::option::Option::Some(v);
        }

        // optional int32 sequence_variant = 6;

        pub fn sequence_variant(&self) -> i32 {
            self.sequence_variant.unwrap_or(0)
        }

        pub fn clear_sequence_variant(&mut self) {
            self.sequence_variant = ::std::option::Option::None;
        }

        pub fn has_sequence_variant(&self) -> bool {
            self.sequence_variant.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sequence_variant(&mut self, v: i32) {
            self.sequence_variant = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "activity",
                |m: &AddGesture| { &m.activity },
                |m: &mut AddGesture| { &mut m.activity },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot",
                |m: &AddGesture| { &m.slot },
                |m: &mut AddGesture| { &mut m.slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fade_in",
                |m: &AddGesture| { &m.fade_in },
                |m: &mut AddGesture| { &mut m.fade_in },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fade_out",
                |m: &AddGesture| { &m.fade_out },
                |m: &mut AddGesture| { &mut m.fade_out },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "playback_rate",
                |m: &AddGesture| { &m.playback_rate },
                |m: &mut AddGesture| { &mut m.playback_rate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sequence_variant",
                |m: &AddGesture| { &m.sequence_variant },
                |m: &mut AddGesture| { &mut m.sequence_variant },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddGesture>(
                "CDOTAUserMsg_UnitEvent.AddGesture",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AddGesture {
        const NAME: &'static str = "AddGesture";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.activity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.slot = ::std::option::Option::Some(is.read_int32()?);
                    },
                    29 => {
                        self.fade_in = ::std::option::Option::Some(is.read_float()?);
                    },
                    37 => {
                        self.fade_out = ::std::option::Option::Some(is.read_float()?);
                    },
                    45 => {
                        self.playback_rate = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.sequence_variant = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.activity {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.slot {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.fade_in {
                my_size += 1 + 4;
            }
            if let Some(v) = self.fade_out {
                my_size += 1 + 4;
            }
            if let Some(v) = self.playback_rate {
                my_size += 1 + 4;
            }
            if let Some(v) = self.sequence_variant {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.activity {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.slot {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.fade_in {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.fade_out {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.playback_rate {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.sequence_variant {
                os.write_int32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AddGesture {
            AddGesture::new()
        }

        fn clear(&mut self) {
            self.activity = ::std::option::Option::None;
            self.slot = ::std::option::Option::None;
            self.fade_in = ::std::option::Option::None;
            self.fade_out = ::std::option::Option::None;
            self.playback_rate = ::std::option::Option::None;
            self.sequence_variant = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AddGesture {
            static instance: AddGesture = AddGesture {
                activity: ::std::option::Option::None,
                slot: ::std::option::Option::None,
                fade_in: ::std::option::Option::None,
                fade_out: ::std::option::Option::None,
                playback_rate: ::std::option::Option::None,
                sequence_variant: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AddGesture {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UnitEvent.AddGesture").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AddGesture {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AddGesture {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_UnitEvent.RemoveGesture)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RemoveGesture {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.RemoveGesture.activity)
        pub activity: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UnitEvent.RemoveGesture.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RemoveGesture {
        fn default() -> &'a RemoveGesture {
            <RemoveGesture as ::protobuf::Message>::default_instance()
        }
    }

    impl RemoveGesture {
        pub fn new() -> RemoveGesture {
            ::std::default::Default::default()
        }

        // optional int32 activity = 1;

        pub fn activity(&self) -> i32 {
            self.activity.unwrap_or(0)
        }

        pub fn clear_activity(&mut self) {
            self.activity = ::std::option::Option::None;
        }

        pub fn has_activity(&self) -> bool {
            self.activity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_activity(&mut self, v: i32) {
            self.activity = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "activity",
                |m: &RemoveGesture| { &m.activity },
                |m: &mut RemoveGesture| { &mut m.activity },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveGesture>(
                "CDOTAUserMsg_UnitEvent.RemoveGesture",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RemoveGesture {
        const NAME: &'static str = "RemoveGesture";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.activity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.activity {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.activity {
                os.write_int32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RemoveGesture {
            RemoveGesture::new()
        }

        fn clear(&mut self) {
            self.activity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RemoveGesture {
            static instance: RemoveGesture = RemoveGesture {
                activity: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RemoveGesture {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UnitEvent.RemoveGesture").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RemoveGesture {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RemoveGesture {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_UnitEvent.BloodImpact)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BloodImpact {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.BloodImpact.scale)
        pub scale: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.BloodImpact.x_normal)
        pub x_normal: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.BloodImpact.y_normal)
        pub y_normal: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UnitEvent.BloodImpact.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BloodImpact {
        fn default() -> &'a BloodImpact {
            <BloodImpact as ::protobuf::Message>::default_instance()
        }
    }

    impl BloodImpact {
        pub fn new() -> BloodImpact {
            ::std::default::Default::default()
        }

        // optional int32 scale = 1;

        pub fn scale(&self) -> i32 {
            self.scale.unwrap_or(0)
        }

        pub fn clear_scale(&mut self) {
            self.scale = ::std::option::Option::None;
        }

        pub fn has_scale(&self) -> bool {
            self.scale.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scale(&mut self, v: i32) {
            self.scale = ::std::option::Option::Some(v);
        }

        // optional int32 x_normal = 2;

        pub fn x_normal(&self) -> i32 {
            self.x_normal.unwrap_or(0)
        }

        pub fn clear_x_normal(&mut self) {
            self.x_normal = ::std::option::Option::None;
        }

        pub fn has_x_normal(&self) -> bool {
            self.x_normal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x_normal(&mut self, v: i32) {
            self.x_normal = ::std::option::Option::Some(v);
        }

        // optional int32 y_normal = 3;

        pub fn y_normal(&self) -> i32 {
            self.y_normal.unwrap_or(0)
        }

        pub fn clear_y_normal(&mut self) {
            self.y_normal = ::std::option::Option::None;
        }

        pub fn has_y_normal(&self) -> bool {
            self.y_normal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y_normal(&mut self, v: i32) {
            self.y_normal = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scale",
                |m: &BloodImpact| { &m.scale },
                |m: &mut BloodImpact| { &mut m.scale },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x_normal",
                |m: &BloodImpact| { &m.x_normal },
                |m: &mut BloodImpact| { &mut m.x_normal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y_normal",
                |m: &BloodImpact| { &m.y_normal },
                |m: &mut BloodImpact| { &mut m.y_normal },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BloodImpact>(
                "CDOTAUserMsg_UnitEvent.BloodImpact",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BloodImpact {
        const NAME: &'static str = "BloodImpact";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.scale = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.x_normal = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.y_normal = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.scale {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.x_normal {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.y_normal {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.scale {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.x_normal {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.y_normal {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BloodImpact {
            BloodImpact::new()
        }

        fn clear(&mut self) {
            self.scale = ::std::option::Option::None;
            self.x_normal = ::std::option::Option::None;
            self.y_normal = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BloodImpact {
            static instance: BloodImpact = BloodImpact {
                scale: ::std::option::Option::None,
                x_normal: ::std::option::Option::None,
                y_normal: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BloodImpact {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UnitEvent.BloodImpact").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BloodImpact {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BloodImpact {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_UnitEvent.FadeGesture)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FadeGesture {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UnitEvent.FadeGesture.activity)
        pub activity: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UnitEvent.FadeGesture.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FadeGesture {
        fn default() -> &'a FadeGesture {
            <FadeGesture as ::protobuf::Message>::default_instance()
        }
    }

    impl FadeGesture {
        pub fn new() -> FadeGesture {
            ::std::default::Default::default()
        }

        // optional int32 activity = 1;

        pub fn activity(&self) -> i32 {
            self.activity.unwrap_or(0)
        }

        pub fn clear_activity(&mut self) {
            self.activity = ::std::option::Option::None;
        }

        pub fn has_activity(&self) -> bool {
            self.activity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_activity(&mut self, v: i32) {
            self.activity = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "activity",
                |m: &FadeGesture| { &m.activity },
                |m: &mut FadeGesture| { &mut m.activity },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FadeGesture>(
                "CDOTAUserMsg_UnitEvent.FadeGesture",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FadeGesture {
        const NAME: &'static str = "FadeGesture";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.activity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.activity {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.activity {
                os.write_int32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FadeGesture {
            FadeGesture::new()
        }

        fn clear(&mut self) {
            self.activity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FadeGesture {
            static instance: FadeGesture = FadeGesture {
                activity: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FadeGesture {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UnitEvent.FadeGesture").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FadeGesture {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FadeGesture {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ItemPurchased)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ItemPurchased {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ItemPurchased.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ItemPurchased.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ItemPurchased {
    fn default() -> &'a CDOTAUserMsg_ItemPurchased {
        <CDOTAUserMsg_ItemPurchased as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ItemPurchased {
    pub fn new() -> CDOTAUserMsg_ItemPurchased {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAUserMsg_ItemPurchased| { &m.item_ability_id },
            |m: &mut CDOTAUserMsg_ItemPurchased| { &mut m.item_ability_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ItemPurchased>(
            "CDOTAUserMsg_ItemPurchased",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ItemPurchased {
    const NAME: &'static str = "CDOTAUserMsg_ItemPurchased";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ItemPurchased {
        CDOTAUserMsg_ItemPurchased::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ItemPurchased {
        static instance: CDOTAUserMsg_ItemPurchased = CDOTAUserMsg_ItemPurchased {
            item_ability_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ItemPurchased {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ItemPurchased").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ItemPurchased {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ItemPurchased {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ItemSold)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ItemSold {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ItemSold.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ItemSold.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ItemSold {
    fn default() -> &'a CDOTAUserMsg_ItemSold {
        <CDOTAUserMsg_ItemSold as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ItemSold {
    pub fn new() -> CDOTAUserMsg_ItemSold {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAUserMsg_ItemSold| { &m.item_ability_id },
            |m: &mut CDOTAUserMsg_ItemSold| { &mut m.item_ability_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ItemSold>(
            "CDOTAUserMsg_ItemSold",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ItemSold {
    const NAME: &'static str = "CDOTAUserMsg_ItemSold";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ItemSold {
        CDOTAUserMsg_ItemSold::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ItemSold {
        static instance: CDOTAUserMsg_ItemSold = CDOTAUserMsg_ItemSold {
            item_ability_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ItemSold {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ItemSold").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ItemSold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ItemSold {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ItemFound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ItemFound {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ItemFound.player)
    pub player: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ItemFound.quality)
    pub quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ItemFound.rarity)
    pub rarity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ItemFound.method)
    pub method: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ItemFound.itemdef)
    pub itemdef: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ItemFound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ItemFound {
    fn default() -> &'a CDOTAUserMsg_ItemFound {
        <CDOTAUserMsg_ItemFound as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ItemFound {
    pub fn new() -> CDOTAUserMsg_ItemFound {
        ::std::default::Default::default()
    }

    // optional int32 player = 1;

    pub fn player(&self) -> i32 {
        self.player.unwrap_or(0)
    }

    pub fn clear_player(&mut self) {
        self.player = ::std::option::Option::None;
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: i32) {
        self.player = ::std::option::Option::Some(v);
    }

    // optional int32 quality = 2;

    pub fn quality(&self) -> i32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional int32 rarity = 3;

    pub fn rarity(&self) -> i32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: i32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional int32 method = 4;

    pub fn method(&self) -> i32 {
        self.method.unwrap_or(0)
    }

    pub fn clear_method(&mut self) {
        self.method = ::std::option::Option::None;
    }

    pub fn has_method(&self) -> bool {
        self.method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: i32) {
        self.method = ::std::option::Option::Some(v);
    }

    // optional uint32 itemdef = 5;

    pub fn itemdef(&self) -> u32 {
        self.itemdef.unwrap_or(0)
    }

    pub fn clear_itemdef(&mut self) {
        self.itemdef = ::std::option::Option::None;
    }

    pub fn has_itemdef(&self) -> bool {
        self.itemdef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemdef(&mut self, v: u32) {
        self.itemdef = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player",
            |m: &CDOTAUserMsg_ItemFound| { &m.player },
            |m: &mut CDOTAUserMsg_ItemFound| { &mut m.player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CDOTAUserMsg_ItemFound| { &m.quality },
            |m: &mut CDOTAUserMsg_ItemFound| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rarity",
            |m: &CDOTAUserMsg_ItemFound| { &m.rarity },
            |m: &mut CDOTAUserMsg_ItemFound| { &mut m.rarity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "method",
            |m: &CDOTAUserMsg_ItemFound| { &m.method },
            |m: &mut CDOTAUserMsg_ItemFound| { &mut m.method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemdef",
            |m: &CDOTAUserMsg_ItemFound| { &m.itemdef },
            |m: &mut CDOTAUserMsg_ItemFound| { &mut m.itemdef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ItemFound>(
            "CDOTAUserMsg_ItemFound",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ItemFound {
    const NAME: &'static str = "CDOTAUserMsg_ItemFound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.quality = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.rarity = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.method = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.itemdef = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.method {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.itemdef {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.method {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.itemdef {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ItemFound {
        CDOTAUserMsg_ItemFound::new()
    }

    fn clear(&mut self) {
        self.player = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.method = ::std::option::Option::None;
        self.itemdef = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ItemFound {
        static instance: CDOTAUserMsg_ItemFound = CDOTAUserMsg_ItemFound {
            player: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            rarity: ::std::option::Option::None,
            method: ::std::option::Option::None,
            itemdef: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ItemFound {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ItemFound").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ItemFound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ItemFound {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_OverheadEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_OverheadEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OverheadEvent.message_type)
    pub message_type: ::std::option::Option<::protobuf::EnumOrUnknown<DOTA_OVERHEAD_ALERT>>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OverheadEvent.value)
    pub value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OverheadEvent.target_player_entindex)
    pub target_player_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OverheadEvent.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OverheadEvent.source_player_entindex)
    pub source_player_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_OverheadEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_OverheadEvent {
    fn default() -> &'a CDOTAUserMsg_OverheadEvent {
        <CDOTAUserMsg_OverheadEvent as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_OverheadEvent {
    pub fn new() -> CDOTAUserMsg_OverheadEvent {
        ::std::default::Default::default()
    }

    // required .dota.DOTA_OVERHEAD_ALERT message_type = 1;

    pub fn message_type(&self) -> DOTA_OVERHEAD_ALERT {
        match self.message_type {
            Some(e) => e.enum_value_or(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD),
            None => DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD,
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: DOTA_OVERHEAD_ALERT) {
        self.message_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 value = 2;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_entindex = 3;

    pub fn target_player_entindex(&self) -> i32 {
        self.target_player_entindex.unwrap_or(0)
    }

    pub fn clear_target_player_entindex(&mut self) {
        self.target_player_entindex = ::std::option::Option::None;
    }

    pub fn has_target_player_entindex(&self) -> bool {
        self.target_player_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_entindex(&mut self, v: i32) {
        self.target_player_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 4;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 source_player_entindex = 5;

    pub fn source_player_entindex(&self) -> i32 {
        self.source_player_entindex.unwrap_or(0)
    }

    pub fn clear_source_player_entindex(&mut self) {
        self.source_player_entindex = ::std::option::Option::None;
    }

    pub fn has_source_player_entindex(&self) -> bool {
        self.source_player_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_entindex(&mut self, v: i32) {
        self.source_player_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_type",
            |m: &CDOTAUserMsg_OverheadEvent| { &m.message_type },
            |m: &mut CDOTAUserMsg_OverheadEvent| { &mut m.message_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CDOTAUserMsg_OverheadEvent| { &m.value },
            |m: &mut CDOTAUserMsg_OverheadEvent| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_entindex",
            |m: &CDOTAUserMsg_OverheadEvent| { &m.target_player_entindex },
            |m: &mut CDOTAUserMsg_OverheadEvent| { &mut m.target_player_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAUserMsg_OverheadEvent| { &m.target_entindex },
            |m: &mut CDOTAUserMsg_OverheadEvent| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_player_entindex",
            |m: &CDOTAUserMsg_OverheadEvent| { &m.source_player_entindex },
            |m: &mut CDOTAUserMsg_OverheadEvent| { &mut m.source_player_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_OverheadEvent>(
            "CDOTAUserMsg_OverheadEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_OverheadEvent {
    const NAME: &'static str = "CDOTAUserMsg_OverheadEvent";

    fn is_initialized(&self) -> bool {
        if self.message_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_player_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.source_player_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_player_entindex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.source_player_entindex {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_player_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.source_player_entindex {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_OverheadEvent {
        CDOTAUserMsg_OverheadEvent::new()
    }

    fn clear(&mut self) {
        self.message_type = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.target_player_entindex = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.source_player_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_OverheadEvent {
        static instance: CDOTAUserMsg_OverheadEvent = CDOTAUserMsg_OverheadEvent {
            message_type: ::std::option::Option::None,
            value: ::std::option::Option::None,
            target_player_entindex: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            source_player_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_OverheadEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_OverheadEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_OverheadEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_OverheadEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TutorialTipInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialTipInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialTipInfo.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialTipInfo.progress)
    pub progress: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TutorialTipInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialTipInfo {
    fn default() -> &'a CDOTAUserMsg_TutorialTipInfo {
        <CDOTAUserMsg_TutorialTipInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialTipInfo {
    pub fn new() -> CDOTAUserMsg_TutorialTipInfo {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 progress = 2;

    pub fn progress(&self) -> i32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CDOTAUserMsg_TutorialTipInfo| { &m.name },
            |m: &mut CDOTAUserMsg_TutorialTipInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &CDOTAUserMsg_TutorialTipInfo| { &m.progress },
            |m: &mut CDOTAUserMsg_TutorialTipInfo| { &mut m.progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TutorialTipInfo>(
            "CDOTAUserMsg_TutorialTipInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialTipInfo {
    const NAME: &'static str = "CDOTAUserMsg_TutorialTipInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.progress = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.progress {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialTipInfo {
        CDOTAUserMsg_TutorialTipInfo::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialTipInfo {
        static instance: CDOTAUserMsg_TutorialTipInfo = CDOTAUserMsg_TutorialTipInfo {
            name: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TutorialTipInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TutorialTipInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TutorialTipInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialTipInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TutorialFinish)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialFinish {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialFinish.heading)
    pub heading: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialFinish.emblem)
    pub emblem: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialFinish.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialFinish.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TutorialFinish.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialFinish {
    fn default() -> &'a CDOTAUserMsg_TutorialFinish {
        <CDOTAUserMsg_TutorialFinish as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialFinish {
    pub fn new() -> CDOTAUserMsg_TutorialFinish {
        ::std::default::Default::default()
    }

    // optional string heading = 1;

    pub fn heading(&self) -> &str {
        match self.heading.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_heading(&mut self) {
        self.heading = ::std::option::Option::None;
    }

    pub fn has_heading(&self) -> bool {
        self.heading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heading(&mut self, v: ::std::string::String) {
        self.heading = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_heading(&mut self) -> &mut ::std::string::String {
        if self.heading.is_none() {
            self.heading = ::std::option::Option::Some(::std::string::String::new());
        }
        self.heading.as_mut().unwrap()
    }

    // Take field
    pub fn take_heading(&mut self) -> ::std::string::String {
        self.heading.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string emblem = 2;

    pub fn emblem(&self) -> &str {
        match self.emblem.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_emblem(&mut self) {
        self.emblem = ::std::option::Option::None;
    }

    pub fn has_emblem(&self) -> bool {
        self.emblem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emblem(&mut self, v: ::std::string::String) {
        self.emblem = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emblem(&mut self) -> &mut ::std::string::String {
        if self.emblem.is_none() {
            self.emblem = ::std::option::Option::Some(::std::string::String::new());
        }
        self.emblem.as_mut().unwrap()
    }

    // Take field
    pub fn take_emblem(&mut self) -> ::std::string::String {
        self.emblem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string body = 3;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool success = 4;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "heading",
            |m: &CDOTAUserMsg_TutorialFinish| { &m.heading },
            |m: &mut CDOTAUserMsg_TutorialFinish| { &mut m.heading },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "emblem",
            |m: &CDOTAUserMsg_TutorialFinish| { &m.emblem },
            |m: &mut CDOTAUserMsg_TutorialFinish| { &mut m.emblem },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &CDOTAUserMsg_TutorialFinish| { &m.body },
            |m: &mut CDOTAUserMsg_TutorialFinish| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CDOTAUserMsg_TutorialFinish| { &m.success },
            |m: &mut CDOTAUserMsg_TutorialFinish| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TutorialFinish>(
            "CDOTAUserMsg_TutorialFinish",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialFinish {
    const NAME: &'static str = "CDOTAUserMsg_TutorialFinish";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.heading = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.emblem = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.heading.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.emblem.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.heading.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.emblem.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.success {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialFinish {
        CDOTAUserMsg_TutorialFinish::new()
    }

    fn clear(&mut self) {
        self.heading = ::std::option::Option::None;
        self.emblem = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialFinish {
        static instance: CDOTAUserMsg_TutorialFinish = CDOTAUserMsg_TutorialFinish {
            heading: ::std::option::Option::None,
            emblem: ::std::option::Option::None,
            body: ::std::option::Option::None,
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TutorialFinish {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TutorialFinish").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TutorialFinish {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialFinish {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TutorialMinimapPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialMinimapPosition {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TutorialMinimapPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialMinimapPosition {
    fn default() -> &'a CDOTAUserMsg_TutorialMinimapPosition {
        <CDOTAUserMsg_TutorialMinimapPosition as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialMinimapPosition {
    pub fn new() -> CDOTAUserMsg_TutorialMinimapPosition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TutorialMinimapPosition>(
            "CDOTAUserMsg_TutorialMinimapPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialMinimapPosition {
    const NAME: &'static str = "CDOTAUserMsg_TutorialMinimapPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialMinimapPosition {
        CDOTAUserMsg_TutorialMinimapPosition::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialMinimapPosition {
        static instance: CDOTAUserMsg_TutorialMinimapPosition = CDOTAUserMsg_TutorialMinimapPosition {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TutorialMinimapPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TutorialMinimapPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TutorialMinimapPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialMinimapPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SendGenericToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendGenericToolTip {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendGenericToolTip.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendGenericToolTip.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendGenericToolTip.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendGenericToolTip.close)
    pub close: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SendGenericToolTip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendGenericToolTip {
    fn default() -> &'a CDOTAUserMsg_SendGenericToolTip {
        <CDOTAUserMsg_SendGenericToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendGenericToolTip {
    pub fn new() -> CDOTAUserMsg_SendGenericToolTip {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 entindex = 3;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional bool close = 4;

    pub fn close(&self) -> bool {
        self.close.unwrap_or(false)
    }

    pub fn clear_close(&mut self) {
        self.close = ::std::option::Option::None;
    }

    pub fn has_close(&self) -> bool {
        self.close.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close(&mut self, v: bool) {
        self.close = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CDOTAUserMsg_SendGenericToolTip| { &m.title },
            |m: &mut CDOTAUserMsg_SendGenericToolTip| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CDOTAUserMsg_SendGenericToolTip| { &m.text },
            |m: &mut CDOTAUserMsg_SendGenericToolTip| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &CDOTAUserMsg_SendGenericToolTip| { &m.entindex },
            |m: &mut CDOTAUserMsg_SendGenericToolTip| { &mut m.entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "close",
            |m: &CDOTAUserMsg_SendGenericToolTip| { &m.close },
            |m: &mut CDOTAUserMsg_SendGenericToolTip| { &mut m.close },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SendGenericToolTip>(
            "CDOTAUserMsg_SendGenericToolTip",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendGenericToolTip {
    const NAME: &'static str = "CDOTAUserMsg_SendGenericToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.close = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.close {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.close {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendGenericToolTip {
        CDOTAUserMsg_SendGenericToolTip::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.entindex = ::std::option::Option::None;
        self.close = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendGenericToolTip {
        static instance: CDOTAUserMsg_SendGenericToolTip = CDOTAUserMsg_SendGenericToolTip {
            title: ::std::option::Option::None,
            text: ::std::option::Option::None,
            entindex: ::std::option::Option::None,
            close: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SendGenericToolTip {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SendGenericToolTip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SendGenericToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendGenericToolTip {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_WorldLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WorldLine {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WorldLine.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WorldLine.worldline)
    pub worldline: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_WorldLine>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_WorldLine.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WorldLine {
    fn default() -> &'a CDOTAUserMsg_WorldLine {
        <CDOTAUserMsg_WorldLine as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WorldLine {
    pub fn new() -> CDOTAUserMsg_WorldLine {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_WorldLine| { &m.player_id },
            |m: &mut CDOTAUserMsg_WorldLine| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_WorldLine>(
            "worldline",
            |m: &CDOTAUserMsg_WorldLine| { &m.worldline },
            |m: &mut CDOTAUserMsg_WorldLine| { &mut m.worldline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_WorldLine>(
            "CDOTAUserMsg_WorldLine",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_WorldLine {
    const NAME: &'static str = "CDOTAUserMsg_WorldLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.worldline)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.worldline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.worldline.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WorldLine {
        CDOTAUserMsg_WorldLine::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.worldline.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WorldLine {
        static instance: CDOTAUserMsg_WorldLine = CDOTAUserMsg_WorldLine {
            player_id: ::std::option::Option::None,
            worldline: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_WorldLine {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_WorldLine").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_WorldLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_WorldLine {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ChatWheel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ChatWheel {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatWheel.chat_message_id)
    pub chat_message_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatWheel.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatWheel.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatWheel.param_hero_id)
    pub param_hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatWheel.emoticon_id)
    pub emoticon_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ChatWheel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ChatWheel {
    fn default() -> &'a CDOTAUserMsg_ChatWheel {
        <CDOTAUserMsg_ChatWheel as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ChatWheel {
    pub fn new() -> CDOTAUserMsg_ChatWheel {
        ::std::default::Default::default()
    }

    // optional uint32 chat_message_id = 1;

    pub fn chat_message_id(&self) -> u32 {
        self.chat_message_id.unwrap_or(0)
    }

    pub fn clear_chat_message_id(&mut self) {
        self.chat_message_id = ::std::option::Option::None;
    }

    pub fn has_chat_message_id(&self) -> bool {
        self.chat_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_message_id(&mut self, v: u32) {
        self.chat_message_id = ::std::option::Option::Some(v);
    }

    // optional int32 player_id = 2;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 3;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 param_hero_id = 4;

    pub fn param_hero_id(&self) -> u32 {
        self.param_hero_id.unwrap_or(0)
    }

    pub fn clear_param_hero_id(&mut self) {
        self.param_hero_id = ::std::option::Option::None;
    }

    pub fn has_param_hero_id(&self) -> bool {
        self.param_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_hero_id(&mut self, v: u32) {
        self.param_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 emoticon_id = 5;

    pub fn emoticon_id(&self) -> u32 {
        self.emoticon_id.unwrap_or(0)
    }

    pub fn clear_emoticon_id(&mut self) {
        self.emoticon_id = ::std::option::Option::None;
    }

    pub fn has_emoticon_id(&self) -> bool {
        self.emoticon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoticon_id(&mut self, v: u32) {
        self.emoticon_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_message_id",
            |m: &CDOTAUserMsg_ChatWheel| { &m.chat_message_id },
            |m: &mut CDOTAUserMsg_ChatWheel| { &mut m.chat_message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_ChatWheel| { &m.player_id },
            |m: &mut CDOTAUserMsg_ChatWheel| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CDOTAUserMsg_ChatWheel| { &m.account_id },
            |m: &mut CDOTAUserMsg_ChatWheel| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_hero_id",
            |m: &CDOTAUserMsg_ChatWheel| { &m.param_hero_id },
            |m: &mut CDOTAUserMsg_ChatWheel| { &mut m.param_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "emoticon_id",
            |m: &CDOTAUserMsg_ChatWheel| { &m.emoticon_id },
            |m: &mut CDOTAUserMsg_ChatWheel| { &mut m.emoticon_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ChatWheel>(
            "CDOTAUserMsg_ChatWheel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ChatWheel {
    const NAME: &'static str = "CDOTAUserMsg_ChatWheel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.param_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.emoticon_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_message_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.param_hero_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.emoticon_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_message_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.param_hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.emoticon_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ChatWheel {
        CDOTAUserMsg_ChatWheel::new()
    }

    fn clear(&mut self) {
        self.chat_message_id = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.param_hero_id = ::std::option::Option::None;
        self.emoticon_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ChatWheel {
        static instance: CDOTAUserMsg_ChatWheel = CDOTAUserMsg_ChatWheel {
            chat_message_id: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            param_hero_id: ::std::option::Option::None,
            emoticon_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ChatWheel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ChatWheel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ChatWheel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ChatWheel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ReceivedXmasGift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ReceivedXmasGift {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ReceivedXmasGift.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ReceivedXmasGift.item_name)
    pub item_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ReceivedXmasGift.inventory_slot)
    pub inventory_slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ReceivedXmasGift.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ReceivedXmasGift {
    fn default() -> &'a CDOTAUserMsg_ReceivedXmasGift {
        <CDOTAUserMsg_ReceivedXmasGift as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ReceivedXmasGift {
    pub fn new() -> CDOTAUserMsg_ReceivedXmasGift {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string item_name = 2;

    pub fn item_name(&self) -> &str {
        match self.item_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item_name(&mut self) {
        self.item_name = ::std::option::Option::None;
    }

    pub fn has_item_name(&self) -> bool {
        self.item_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name(&mut self, v: ::std::string::String) {
        self.item_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name(&mut self) -> &mut ::std::string::String {
        if self.item_name.is_none() {
            self.item_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name(&mut self) -> ::std::string::String {
        self.item_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 inventory_slot = 3;

    pub fn inventory_slot(&self) -> i32 {
        self.inventory_slot.unwrap_or(0)
    }

    pub fn clear_inventory_slot(&mut self) {
        self.inventory_slot = ::std::option::Option::None;
    }

    pub fn has_inventory_slot(&self) -> bool {
        self.inventory_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory_slot(&mut self, v: i32) {
        self.inventory_slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_ReceivedXmasGift| { &m.player_id },
            |m: &mut CDOTAUserMsg_ReceivedXmasGift| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_name",
            |m: &CDOTAUserMsg_ReceivedXmasGift| { &m.item_name },
            |m: &mut CDOTAUserMsg_ReceivedXmasGift| { &mut m.item_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory_slot",
            |m: &CDOTAUserMsg_ReceivedXmasGift| { &m.inventory_slot },
            |m: &mut CDOTAUserMsg_ReceivedXmasGift| { &mut m.inventory_slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ReceivedXmasGift>(
            "CDOTAUserMsg_ReceivedXmasGift",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ReceivedXmasGift {
    const NAME: &'static str = "CDOTAUserMsg_ReceivedXmasGift";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.item_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.inventory_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.inventory_slot {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.inventory_slot {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ReceivedXmasGift {
        CDOTAUserMsg_ReceivedXmasGift::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.item_name = ::std::option::Option::None;
        self.inventory_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ReceivedXmasGift {
        static instance: CDOTAUserMsg_ReceivedXmasGift = CDOTAUserMsg_ReceivedXmasGift {
            player_id: ::std::option::Option::None,
            item_name: ::std::option::Option::None,
            inventory_slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ReceivedXmasGift {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ReceivedXmasGift").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ReceivedXmasGift {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ReceivedXmasGift {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ShowSurvey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ShowSurvey {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowSurvey.survey_id)
    pub survey_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowSurvey.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowSurvey.response_style)
    pub response_style: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowSurvey.teammate_hero_id)
    pub teammate_hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowSurvey.teammate_name)
    pub teammate_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowSurvey.teammate_account_id)
    pub teammate_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ShowSurvey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ShowSurvey {
    fn default() -> &'a CDOTAUserMsg_ShowSurvey {
        <CDOTAUserMsg_ShowSurvey as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ShowSurvey {
    pub fn new() -> CDOTAUserMsg_ShowSurvey {
        ::std::default::Default::default()
    }

    // optional int32 survey_id = 1;

    pub fn survey_id(&self) -> i32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: i32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional string response_style = 3;

    pub fn response_style(&self) -> &str {
        match self.response_style.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_response_style(&mut self) {
        self.response_style = ::std::option::Option::None;
    }

    pub fn has_response_style(&self) -> bool {
        self.response_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_style(&mut self, v: ::std::string::String) {
        self.response_style = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_style(&mut self) -> &mut ::std::string::String {
        if self.response_style.is_none() {
            self.response_style = ::std::option::Option::Some(::std::string::String::new());
        }
        self.response_style.as_mut().unwrap()
    }

    // Take field
    pub fn take_response_style(&mut self) -> ::std::string::String {
        self.response_style.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 teammate_hero_id = 4;

    pub fn teammate_hero_id(&self) -> u32 {
        self.teammate_hero_id.unwrap_or(0)
    }

    pub fn clear_teammate_hero_id(&mut self) {
        self.teammate_hero_id = ::std::option::Option::None;
    }

    pub fn has_teammate_hero_id(&self) -> bool {
        self.teammate_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_hero_id(&mut self, v: u32) {
        self.teammate_hero_id = ::std::option::Option::Some(v);
    }

    // optional string teammate_name = 5;

    pub fn teammate_name(&self) -> &str {
        match self.teammate_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_teammate_name(&mut self) {
        self.teammate_name = ::std::option::Option::None;
    }

    pub fn has_teammate_name(&self) -> bool {
        self.teammate_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_name(&mut self, v: ::std::string::String) {
        self.teammate_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_teammate_name(&mut self) -> &mut ::std::string::String {
        if self.teammate_name.is_none() {
            self.teammate_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.teammate_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_teammate_name(&mut self) -> ::std::string::String {
        self.teammate_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 teammate_account_id = 6;

    pub fn teammate_account_id(&self) -> u32 {
        self.teammate_account_id.unwrap_or(0)
    }

    pub fn clear_teammate_account_id(&mut self) {
        self.teammate_account_id = ::std::option::Option::None;
    }

    pub fn has_teammate_account_id(&self) -> bool {
        self.teammate_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_account_id(&mut self, v: u32) {
        self.teammate_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "survey_id",
            |m: &CDOTAUserMsg_ShowSurvey| { &m.survey_id },
            |m: &mut CDOTAUserMsg_ShowSurvey| { &mut m.survey_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CDOTAUserMsg_ShowSurvey| { &m.match_id },
            |m: &mut CDOTAUserMsg_ShowSurvey| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_style",
            |m: &CDOTAUserMsg_ShowSurvey| { &m.response_style },
            |m: &mut CDOTAUserMsg_ShowSurvey| { &mut m.response_style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "teammate_hero_id",
            |m: &CDOTAUserMsg_ShowSurvey| { &m.teammate_hero_id },
            |m: &mut CDOTAUserMsg_ShowSurvey| { &mut m.teammate_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "teammate_name",
            |m: &CDOTAUserMsg_ShowSurvey| { &m.teammate_name },
            |m: &mut CDOTAUserMsg_ShowSurvey| { &mut m.teammate_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "teammate_account_id",
            |m: &CDOTAUserMsg_ShowSurvey| { &m.teammate_account_id },
            |m: &mut CDOTAUserMsg_ShowSurvey| { &mut m.teammate_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ShowSurvey>(
            "CDOTAUserMsg_ShowSurvey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ShowSurvey {
    const NAME: &'static str = "CDOTAUserMsg_ShowSurvey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.response_style = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.teammate_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.teammate_name = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.teammate_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.response_style.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.teammate_hero_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.teammate_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.teammate_account_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.response_style.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.teammate_hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.teammate_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.teammate_account_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ShowSurvey {
        CDOTAUserMsg_ShowSurvey::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.response_style = ::std::option::Option::None;
        self.teammate_hero_id = ::std::option::Option::None;
        self.teammate_name = ::std::option::Option::None;
        self.teammate_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ShowSurvey {
        static instance: CDOTAUserMsg_ShowSurvey = CDOTAUserMsg_ShowSurvey {
            survey_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            response_style: ::std::option::Option::None,
            teammate_hero_id: ::std::option::Option::None,
            teammate_name: ::std::option::Option::None,
            teammate_account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ShowSurvey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ShowSurvey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ShowSurvey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ShowSurvey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_UpdateSharedContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_UpdateSharedContent {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_UpdateSharedContent.slot_type)
    pub slot_type: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UpdateSharedContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_UpdateSharedContent {
    fn default() -> &'a CDOTAUserMsg_UpdateSharedContent {
        <CDOTAUserMsg_UpdateSharedContent as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_UpdateSharedContent {
    pub fn new() -> CDOTAUserMsg_UpdateSharedContent {
        ::std::default::Default::default()
    }

    // optional int32 slot_type = 1;

    pub fn slot_type(&self) -> i32 {
        self.slot_type.unwrap_or(0)
    }

    pub fn clear_slot_type(&mut self) {
        self.slot_type = ::std::option::Option::None;
    }

    pub fn has_slot_type(&self) -> bool {
        self.slot_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_type(&mut self, v: i32) {
        self.slot_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_type",
            |m: &CDOTAUserMsg_UpdateSharedContent| { &m.slot_type },
            |m: &mut CDOTAUserMsg_UpdateSharedContent| { &mut m.slot_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_UpdateSharedContent>(
            "CDOTAUserMsg_UpdateSharedContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UpdateSharedContent {
    const NAME: &'static str = "CDOTAUserMsg_UpdateSharedContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot_type = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.slot_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.slot_type {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_UpdateSharedContent {
        CDOTAUserMsg_UpdateSharedContent::new()
    }

    fn clear(&mut self) {
        self.slot_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_UpdateSharedContent {
        static instance: CDOTAUserMsg_UpdateSharedContent = CDOTAUserMsg_UpdateSharedContent {
            slot_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_UpdateSharedContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UpdateSharedContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_UpdateSharedContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UpdateSharedContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TutorialRequestExp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialRequestExp {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TutorialRequestExp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialRequestExp {
    fn default() -> &'a CDOTAUserMsg_TutorialRequestExp {
        <CDOTAUserMsg_TutorialRequestExp as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialRequestExp {
    pub fn new() -> CDOTAUserMsg_TutorialRequestExp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TutorialRequestExp>(
            "CDOTAUserMsg_TutorialRequestExp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialRequestExp {
    const NAME: &'static str = "CDOTAUserMsg_TutorialRequestExp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialRequestExp {
        CDOTAUserMsg_TutorialRequestExp::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialRequestExp {
        static instance: CDOTAUserMsg_TutorialRequestExp = CDOTAUserMsg_TutorialRequestExp {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TutorialRequestExp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TutorialRequestExp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TutorialRequestExp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialRequestExp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TutorialFade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialFade {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialFade.tgt_alpha)
    pub tgt_alpha: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TutorialFade.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialFade {
    fn default() -> &'a CDOTAUserMsg_TutorialFade {
        <CDOTAUserMsg_TutorialFade as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialFade {
    pub fn new() -> CDOTAUserMsg_TutorialFade {
        ::std::default::Default::default()
    }

    // optional int32 tgt_alpha = 1;

    pub fn tgt_alpha(&self) -> i32 {
        self.tgt_alpha.unwrap_or(0)
    }

    pub fn clear_tgt_alpha(&mut self) {
        self.tgt_alpha = ::std::option::Option::None;
    }

    pub fn has_tgt_alpha(&self) -> bool {
        self.tgt_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tgt_alpha(&mut self, v: i32) {
        self.tgt_alpha = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tgt_alpha",
            |m: &CDOTAUserMsg_TutorialFade| { &m.tgt_alpha },
            |m: &mut CDOTAUserMsg_TutorialFade| { &mut m.tgt_alpha },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TutorialFade>(
            "CDOTAUserMsg_TutorialFade",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialFade {
    const NAME: &'static str = "CDOTAUserMsg_TutorialFade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tgt_alpha = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tgt_alpha {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tgt_alpha {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialFade {
        CDOTAUserMsg_TutorialFade::new()
    }

    fn clear(&mut self) {
        self.tgt_alpha = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialFade {
        static instance: CDOTAUserMsg_TutorialFade = CDOTAUserMsg_TutorialFade {
            tgt_alpha: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TutorialFade {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TutorialFade").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TutorialFade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialFade {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TutorialPingMinimap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialPingMinimap {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialPingMinimap.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialPingMinimap.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialPingMinimap.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialPingMinimap.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TutorialPingMinimap.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TutorialPingMinimap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialPingMinimap {
    fn default() -> &'a CDOTAUserMsg_TutorialPingMinimap {
        <CDOTAUserMsg_TutorialPingMinimap as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialPingMinimap {
    pub fn new() -> CDOTAUserMsg_TutorialPingMinimap {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float pos_x = 2;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 3;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 4;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional int32 entity_index = 5;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_TutorialPingMinimap| { &m.player_id },
            |m: &mut CDOTAUserMsg_TutorialPingMinimap| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &CDOTAUserMsg_TutorialPingMinimap| { &m.pos_x },
            |m: &mut CDOTAUserMsg_TutorialPingMinimap| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &CDOTAUserMsg_TutorialPingMinimap| { &m.pos_y },
            |m: &mut CDOTAUserMsg_TutorialPingMinimap| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z",
            |m: &CDOTAUserMsg_TutorialPingMinimap| { &m.pos_z },
            |m: &mut CDOTAUserMsg_TutorialPingMinimap| { &mut m.pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CDOTAUserMsg_TutorialPingMinimap| { &m.entity_index },
            |m: &mut CDOTAUserMsg_TutorialPingMinimap| { &mut m.entity_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TutorialPingMinimap>(
            "CDOTAUserMsg_TutorialPingMinimap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialPingMinimap {
    const NAME: &'static str = "CDOTAUserMsg_TutorialPingMinimap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialPingMinimap {
        CDOTAUserMsg_TutorialPingMinimap::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialPingMinimap {
        static instance: CDOTAUserMsg_TutorialPingMinimap = CDOTAUserMsg_TutorialPingMinimap {
            player_id: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TutorialPingMinimap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TutorialPingMinimap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TutorialPingMinimap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialPingMinimap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_GamerulesStateChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GamerulesStateChanged {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GamerulesStateChanged.state)
    pub state: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_GamerulesStateChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GamerulesStateChanged {
    fn default() -> &'a CDOTAUserMsg_GamerulesStateChanged {
        <CDOTAUserMsg_GamerulesStateChanged as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GamerulesStateChanged {
    pub fn new() -> CDOTAUserMsg_GamerulesStateChanged {
        ::std::default::Default::default()
    }

    // optional uint32 state = 1;

    pub fn state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CDOTAUserMsg_GamerulesStateChanged| { &m.state },
            |m: &mut CDOTAUserMsg_GamerulesStateChanged| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_GamerulesStateChanged>(
            "CDOTAUserMsg_GamerulesStateChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GamerulesStateChanged {
    const NAME: &'static str = "CDOTAUserMsg_GamerulesStateChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GamerulesStateChanged {
        CDOTAUserMsg_GamerulesStateChanged::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GamerulesStateChanged {
        static instance: CDOTAUserMsg_GamerulesStateChanged = CDOTAUserMsg_GamerulesStateChanged {
            state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_GamerulesStateChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_GamerulesStateChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_GamerulesStateChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_GamerulesStateChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_AddQuestLogEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AddQuestLogEntry {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AddQuestLogEntry.npc_name)
    pub npc_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AddQuestLogEntry.npc_dialog)
    pub npc_dialog: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_AddQuestLogEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AddQuestLogEntry {
    fn default() -> &'a CDOTAUserMsg_AddQuestLogEntry {
        <CDOTAUserMsg_AddQuestLogEntry as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AddQuestLogEntry {
    pub fn new() -> CDOTAUserMsg_AddQuestLogEntry {
        ::std::default::Default::default()
    }

    // optional string npc_name = 1;

    pub fn npc_name(&self) -> &str {
        match self.npc_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_npc_name(&mut self) {
        self.npc_name = ::std::option::Option::None;
    }

    pub fn has_npc_name(&self) -> bool {
        self.npc_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_npc_name(&mut self, v: ::std::string::String) {
        self.npc_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npc_name(&mut self) -> &mut ::std::string::String {
        if self.npc_name.is_none() {
            self.npc_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.npc_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_npc_name(&mut self) -> ::std::string::String {
        self.npc_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string npc_dialog = 2;

    pub fn npc_dialog(&self) -> &str {
        match self.npc_dialog.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_npc_dialog(&mut self) {
        self.npc_dialog = ::std::option::Option::None;
    }

    pub fn has_npc_dialog(&self) -> bool {
        self.npc_dialog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_npc_dialog(&mut self, v: ::std::string::String) {
        self.npc_dialog = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npc_dialog(&mut self) -> &mut ::std::string::String {
        if self.npc_dialog.is_none() {
            self.npc_dialog = ::std::option::Option::Some(::std::string::String::new());
        }
        self.npc_dialog.as_mut().unwrap()
    }

    // Take field
    pub fn take_npc_dialog(&mut self) -> ::std::string::String {
        self.npc_dialog.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "npc_name",
            |m: &CDOTAUserMsg_AddQuestLogEntry| { &m.npc_name },
            |m: &mut CDOTAUserMsg_AddQuestLogEntry| { &mut m.npc_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "npc_dialog",
            |m: &CDOTAUserMsg_AddQuestLogEntry| { &m.npc_dialog },
            |m: &mut CDOTAUserMsg_AddQuestLogEntry| { &mut m.npc_dialog },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_AddQuestLogEntry>(
            "CDOTAUserMsg_AddQuestLogEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AddQuestLogEntry {
    const NAME: &'static str = "CDOTAUserMsg_AddQuestLogEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.npc_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.npc_dialog = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.npc_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.npc_dialog.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.npc_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.npc_dialog.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AddQuestLogEntry {
        CDOTAUserMsg_AddQuestLogEntry::new()
    }

    fn clear(&mut self) {
        self.npc_name = ::std::option::Option::None;
        self.npc_dialog = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AddQuestLogEntry {
        static instance: CDOTAUserMsg_AddQuestLogEntry = CDOTAUserMsg_AddQuestLogEntry {
            npc_name: ::std::option::Option::None,
            npc_dialog: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_AddQuestLogEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_AddQuestLogEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_AddQuestLogEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AddQuestLogEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SendStatPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendStatPopup {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendStatPopup.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendStatPopup.statpopup)
    pub statpopup: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_SendStatPopup>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SendStatPopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendStatPopup {
    fn default() -> &'a CDOTAUserMsg_SendStatPopup {
        <CDOTAUserMsg_SendStatPopup as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendStatPopup {
    pub fn new() -> CDOTAUserMsg_SendStatPopup {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_SendStatPopup| { &m.player_id },
            |m: &mut CDOTAUserMsg_SendStatPopup| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_SendStatPopup>(
            "statpopup",
            |m: &CDOTAUserMsg_SendStatPopup| { &m.statpopup },
            |m: &mut CDOTAUserMsg_SendStatPopup| { &mut m.statpopup },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SendStatPopup>(
            "CDOTAUserMsg_SendStatPopup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendStatPopup {
    const NAME: &'static str = "CDOTAUserMsg_SendStatPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.statpopup)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.statpopup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.statpopup.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendStatPopup {
        CDOTAUserMsg_SendStatPopup::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.statpopup.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendStatPopup {
        static instance: CDOTAUserMsg_SendStatPopup = CDOTAUserMsg_SendStatPopup {
            player_id: ::std::option::Option::None,
            statpopup: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SendStatPopup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SendStatPopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SendStatPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendStatPopup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_DismissAllStatPopups)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DismissAllStatPopups {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DismissAllStatPopups.dismissallmsg)
    pub dismissallmsg: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_DismissAllStatPopups.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DismissAllStatPopups {
    fn default() -> &'a CDOTAUserMsg_DismissAllStatPopups {
        <CDOTAUserMsg_DismissAllStatPopups as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DismissAllStatPopups {
    pub fn new() -> CDOTAUserMsg_DismissAllStatPopups {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups>(
            "dismissallmsg",
            |m: &CDOTAUserMsg_DismissAllStatPopups| { &m.dismissallmsg },
            |m: &mut CDOTAUserMsg_DismissAllStatPopups| { &mut m.dismissallmsg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_DismissAllStatPopups>(
            "CDOTAUserMsg_DismissAllStatPopups",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DismissAllStatPopups {
    const NAME: &'static str = "CDOTAUserMsg_DismissAllStatPopups";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dismissallmsg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dismissallmsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dismissallmsg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DismissAllStatPopups {
        CDOTAUserMsg_DismissAllStatPopups::new()
    }

    fn clear(&mut self) {
        self.dismissallmsg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DismissAllStatPopups {
        static instance: CDOTAUserMsg_DismissAllStatPopups = CDOTAUserMsg_DismissAllStatPopups {
            dismissallmsg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_DismissAllStatPopups {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_DismissAllStatPopups").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_DismissAllStatPopups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DismissAllStatPopups {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SendRoshanSpectatorPhase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendRoshanSpectatorPhase {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendRoshanSpectatorPhase.phase)
    pub phase: ::std::option::Option<::protobuf::EnumOrUnknown<DOTA_ROSHAN_PHASE>>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendRoshanSpectatorPhase.phase_start_time)
    pub phase_start_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendRoshanSpectatorPhase.phase_length)
    pub phase_length: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SendRoshanSpectatorPhase.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn default() -> &'a CDOTAUserMsg_SendRoshanSpectatorPhase {
        <CDOTAUserMsg_SendRoshanSpectatorPhase as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendRoshanSpectatorPhase {
    pub fn new() -> CDOTAUserMsg_SendRoshanSpectatorPhase {
        ::std::default::Default::default()
    }

    // optional .dota.DOTA_ROSHAN_PHASE phase = 1;

    pub fn phase(&self) -> DOTA_ROSHAN_PHASE {
        match self.phase {
            Some(e) => e.enum_value_or(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE),
            None => DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE,
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: DOTA_ROSHAN_PHASE) {
        self.phase = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 phase_start_time = 2;

    pub fn phase_start_time(&self) -> i32 {
        self.phase_start_time.unwrap_or(0)
    }

    pub fn clear_phase_start_time(&mut self) {
        self.phase_start_time = ::std::option::Option::None;
    }

    pub fn has_phase_start_time(&self) -> bool {
        self.phase_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase_start_time(&mut self, v: i32) {
        self.phase_start_time = ::std::option::Option::Some(v);
    }

    // optional int32 phase_length = 3;

    pub fn phase_length(&self) -> i32 {
        self.phase_length.unwrap_or(0)
    }

    pub fn clear_phase_length(&mut self) {
        self.phase_length = ::std::option::Option::None;
    }

    pub fn has_phase_length(&self) -> bool {
        self.phase_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase_length(&mut self, v: i32) {
        self.phase_length = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase",
            |m: &CDOTAUserMsg_SendRoshanSpectatorPhase| { &m.phase },
            |m: &mut CDOTAUserMsg_SendRoshanSpectatorPhase| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase_start_time",
            |m: &CDOTAUserMsg_SendRoshanSpectatorPhase| { &m.phase_start_time },
            |m: &mut CDOTAUserMsg_SendRoshanSpectatorPhase| { &mut m.phase_start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase_length",
            |m: &CDOTAUserMsg_SendRoshanSpectatorPhase| { &m.phase_length },
            |m: &mut CDOTAUserMsg_SendRoshanSpectatorPhase| { &mut m.phase_length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SendRoshanSpectatorPhase>(
            "CDOTAUserMsg_SendRoshanSpectatorPhase",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendRoshanSpectatorPhase {
    const NAME: &'static str = "CDOTAUserMsg_SendRoshanSpectatorPhase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.phase = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.phase_start_time = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.phase_length = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phase {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.phase_start_time {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.phase_length {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phase {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.phase_start_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.phase_length {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendRoshanSpectatorPhase {
        CDOTAUserMsg_SendRoshanSpectatorPhase::new()
    }

    fn clear(&mut self) {
        self.phase = ::std::option::Option::None;
        self.phase_start_time = ::std::option::Option::None;
        self.phase_length = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendRoshanSpectatorPhase {
        static instance: CDOTAUserMsg_SendRoshanSpectatorPhase = CDOTAUserMsg_SendRoshanSpectatorPhase {
            phase: ::std::option::Option::None,
            phase_start_time: ::std::option::Option::None,
            phase_length: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SendRoshanSpectatorPhase").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendRoshanSpectatorPhase {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SendRoshanPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendRoshanPopup {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendRoshanPopup.reclaimed)
    pub reclaimed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendRoshanPopup.gametime)
    pub gametime: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SendRoshanPopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendRoshanPopup {
    fn default() -> &'a CDOTAUserMsg_SendRoshanPopup {
        <CDOTAUserMsg_SendRoshanPopup as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendRoshanPopup {
    pub fn new() -> CDOTAUserMsg_SendRoshanPopup {
        ::std::default::Default::default()
    }

    // optional bool reclaimed = 1;

    pub fn reclaimed(&self) -> bool {
        self.reclaimed.unwrap_or(false)
    }

    pub fn clear_reclaimed(&mut self) {
        self.reclaimed = ::std::option::Option::None;
    }

    pub fn has_reclaimed(&self) -> bool {
        self.reclaimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reclaimed(&mut self, v: bool) {
        self.reclaimed = ::std::option::Option::Some(v);
    }

    // optional int32 gametime = 2;

    pub fn gametime(&self) -> i32 {
        self.gametime.unwrap_or(0)
    }

    pub fn clear_gametime(&mut self) {
        self.gametime = ::std::option::Option::None;
    }

    pub fn has_gametime(&self) -> bool {
        self.gametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gametime(&mut self, v: i32) {
        self.gametime = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reclaimed",
            |m: &CDOTAUserMsg_SendRoshanPopup| { &m.reclaimed },
            |m: &mut CDOTAUserMsg_SendRoshanPopup| { &mut m.reclaimed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gametime",
            |m: &CDOTAUserMsg_SendRoshanPopup| { &m.gametime },
            |m: &mut CDOTAUserMsg_SendRoshanPopup| { &mut m.gametime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SendRoshanPopup>(
            "CDOTAUserMsg_SendRoshanPopup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendRoshanPopup {
    const NAME: &'static str = "CDOTAUserMsg_SendRoshanPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reclaimed = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.gametime = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reclaimed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.gametime {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reclaimed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.gametime {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendRoshanPopup {
        CDOTAUserMsg_SendRoshanPopup::new()
    }

    fn clear(&mut self) {
        self.reclaimed = ::std::option::Option::None;
        self.gametime = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendRoshanPopup {
        static instance: CDOTAUserMsg_SendRoshanPopup = CDOTAUserMsg_SendRoshanPopup {
            reclaimed: ::std::option::Option::None,
            gametime: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SendRoshanPopup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SendRoshanPopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SendRoshanPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendRoshanPopup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SendFinalGold)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendFinalGold {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendFinalGold.reliable_gold)
    pub reliable_gold: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SendFinalGold.unreliable_gold)
    pub unreliable_gold: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SendFinalGold.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendFinalGold {
    fn default() -> &'a CDOTAUserMsg_SendFinalGold {
        <CDOTAUserMsg_SendFinalGold as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendFinalGold {
    pub fn new() -> CDOTAUserMsg_SendFinalGold {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reliable_gold",
            |m: &CDOTAUserMsg_SendFinalGold| { &m.reliable_gold },
            |m: &mut CDOTAUserMsg_SendFinalGold| { &mut m.reliable_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unreliable_gold",
            |m: &CDOTAUserMsg_SendFinalGold| { &m.unreliable_gold },
            |m: &mut CDOTAUserMsg_SendFinalGold| { &mut m.unreliable_gold },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SendFinalGold>(
            "CDOTAUserMsg_SendFinalGold",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendFinalGold {
    const NAME: &'static str = "CDOTAUserMsg_SendFinalGold";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.reliable_gold)?;
                },
                8 => {
                    self.reliable_gold.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.unreliable_gold)?;
                },
                16 => {
                    self.unreliable_gold.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reliable_gold {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.unreliable_gold {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.reliable_gold {
            os.write_uint32(1, *v)?;
        };
        for v in &self.unreliable_gold {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendFinalGold {
        CDOTAUserMsg_SendFinalGold::new()
    }

    fn clear(&mut self) {
        self.reliable_gold.clear();
        self.unreliable_gold.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendFinalGold {
        static instance: CDOTAUserMsg_SendFinalGold = CDOTAUserMsg_SendFinalGold {
            reliable_gold: ::std::vec::Vec::new(),
            unreliable_gold: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SendFinalGold {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SendFinalGold").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SendFinalGold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendFinalGold {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CustomMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomMsg {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomMsg.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomMsg.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomMsg.value)
    pub value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CustomMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomMsg {
    fn default() -> &'a CDOTAUserMsg_CustomMsg {
        <CDOTAUserMsg_CustomMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomMsg {
    pub fn new() -> CDOTAUserMsg_CustomMsg {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 player_id = 2;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 value = 3;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CDOTAUserMsg_CustomMsg| { &m.message },
            |m: &mut CDOTAUserMsg_CustomMsg| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_CustomMsg| { &m.player_id },
            |m: &mut CDOTAUserMsg_CustomMsg| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CDOTAUserMsg_CustomMsg| { &m.value },
            |m: &mut CDOTAUserMsg_CustomMsg| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CustomMsg>(
            "CDOTAUserMsg_CustomMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomMsg {
    const NAME: &'static str = "CDOTAUserMsg_CustomMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomMsg {
        CDOTAUserMsg_CustomMsg::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomMsg {
        static instance: CDOTAUserMsg_CustomMsg = CDOTAUserMsg_CustomMsg {
            message: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CustomMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CustomMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CustomMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CoachHUDPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CoachHUDPing {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CoachHUDPing.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CoachHUDPing.hud_ping)
    pub hud_ping: ::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_CoachHUDPing>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CoachHUDPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CoachHUDPing {
    fn default() -> &'a CDOTAUserMsg_CoachHUDPing {
        <CDOTAUserMsg_CoachHUDPing as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CoachHUDPing {
    pub fn new() -> CDOTAUserMsg_CoachHUDPing {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_CoachHUDPing| { &m.player_id },
            |m: &mut CDOTAUserMsg_CoachHUDPing| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::CDOTAMsg_CoachHUDPing>(
            "hud_ping",
            |m: &CDOTAUserMsg_CoachHUDPing| { &m.hud_ping },
            |m: &mut CDOTAUserMsg_CoachHUDPing| { &mut m.hud_ping },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CoachHUDPing>(
            "CDOTAUserMsg_CoachHUDPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CoachHUDPing {
    const NAME: &'static str = "CDOTAUserMsg_CoachHUDPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hud_ping)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hud_ping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hud_ping.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CoachHUDPing {
        CDOTAUserMsg_CoachHUDPing::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.hud_ping.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CoachHUDPing {
        static instance: CDOTAUserMsg_CoachHUDPing = CDOTAUserMsg_CoachHUDPing {
            player_id: ::std::option::Option::None,
            hud_ping: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CoachHUDPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CoachHUDPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CoachHUDPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CoachHUDPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ClientLoadGridNav)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ClientLoadGridNav {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ClientLoadGridNav.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ClientLoadGridNav {
    fn default() -> &'a CDOTAUserMsg_ClientLoadGridNav {
        <CDOTAUserMsg_ClientLoadGridNav as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ClientLoadGridNav {
    pub fn new() -> CDOTAUserMsg_ClientLoadGridNav {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ClientLoadGridNav>(
            "CDOTAUserMsg_ClientLoadGridNav",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ClientLoadGridNav {
    const NAME: &'static str = "CDOTAUserMsg_ClientLoadGridNav";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ClientLoadGridNav {
        CDOTAUserMsg_ClientLoadGridNav::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ClientLoadGridNav {
        static instance: CDOTAUserMsg_ClientLoadGridNav = CDOTAUserMsg_ClientLoadGridNav {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ClientLoadGridNav {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ClientLoadGridNav").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ClientLoadGridNav {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ClientLoadGridNav {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TE_Projectile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_Projectile {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.source)
    pub source: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.target)
    pub target: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.move_speed)
    pub move_speed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.source_attachment)
    pub source_attachment: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.particle_system_handle)
    pub particle_system_handle: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.dodgeable)
    pub dodgeable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.is_attack)
    pub is_attack: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.expire_time)
    pub expire_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.maximpacttime)
    pub maximpacttime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.colorgemcolor)
    pub colorgemcolor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.launch_tick)
    pub launch_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.handle)
    pub handle: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.target_loc)
    pub target_loc: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.particle_cp_data)
    pub particle_cp_data: ::std::vec::Vec<CDOTAUserMsg_ProjectileParticleCPData>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_Projectile.additional_particle_system_handle)
    pub additional_particle_system_handle: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TE_Projectile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_Projectile {
    fn default() -> &'a CDOTAUserMsg_TE_Projectile {
        <CDOTAUserMsg_TE_Projectile as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_Projectile {
    pub fn new() -> CDOTAUserMsg_TE_Projectile {
        ::std::default::Default::default()
    }

    // optional uint32 source = 1;

    pub fn source(&self) -> u32 {
        self.source.unwrap_or(0)
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: u32) {
        self.source = ::std::option::Option::Some(v);
    }

    // optional uint32 target = 2;

    pub fn target(&self) -> u32 {
        self.target.unwrap_or(0)
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: u32) {
        self.target = ::std::option::Option::Some(v);
    }

    // optional int32 move_speed = 3;

    pub fn move_speed(&self) -> i32 {
        self.move_speed.unwrap_or(0)
    }

    pub fn clear_move_speed(&mut self) {
        self.move_speed = ::std::option::Option::None;
    }

    pub fn has_move_speed(&self) -> bool {
        self.move_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_speed(&mut self, v: i32) {
        self.move_speed = ::std::option::Option::Some(v);
    }

    // optional int32 source_attachment = 4;

    pub fn source_attachment(&self) -> i32 {
        self.source_attachment.unwrap_or(0)
    }

    pub fn clear_source_attachment(&mut self) {
        self.source_attachment = ::std::option::Option::None;
    }

    pub fn has_source_attachment(&self) -> bool {
        self.source_attachment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_attachment(&mut self, v: i32) {
        self.source_attachment = ::std::option::Option::Some(v);
    }

    // optional int64 particle_system_handle = 5;

    pub fn particle_system_handle(&self) -> i64 {
        self.particle_system_handle.unwrap_or(0)
    }

    pub fn clear_particle_system_handle(&mut self) {
        self.particle_system_handle = ::std::option::Option::None;
    }

    pub fn has_particle_system_handle(&self) -> bool {
        self.particle_system_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_system_handle(&mut self, v: i64) {
        self.particle_system_handle = ::std::option::Option::Some(v);
    }

    // optional bool dodgeable = 6;

    pub fn dodgeable(&self) -> bool {
        self.dodgeable.unwrap_or(false)
    }

    pub fn clear_dodgeable(&mut self) {
        self.dodgeable = ::std::option::Option::None;
    }

    pub fn has_dodgeable(&self) -> bool {
        self.dodgeable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dodgeable(&mut self, v: bool) {
        self.dodgeable = ::std::option::Option::Some(v);
    }

    // optional bool is_attack = 7;

    pub fn is_attack(&self) -> bool {
        self.is_attack.unwrap_or(false)
    }

    pub fn clear_is_attack(&mut self) {
        self.is_attack = ::std::option::Option::None;
    }

    pub fn has_is_attack(&self) -> bool {
        self.is_attack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attack(&mut self, v: bool) {
        self.is_attack = ::std::option::Option::Some(v);
    }

    // optional float expire_time = 9;

    pub fn expire_time(&self) -> f32 {
        self.expire_time.unwrap_or(0.)
    }

    pub fn clear_expire_time(&mut self) {
        self.expire_time = ::std::option::Option::None;
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: f32) {
        self.expire_time = ::std::option::Option::Some(v);
    }

    // optional float maximpacttime = 10;

    pub fn maximpacttime(&self) -> f32 {
        self.maximpacttime.unwrap_or(0.)
    }

    pub fn clear_maximpacttime(&mut self) {
        self.maximpacttime = ::std::option::Option::None;
    }

    pub fn has_maximpacttime(&self) -> bool {
        self.maximpacttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximpacttime(&mut self, v: f32) {
        self.maximpacttime = ::std::option::Option::Some(v);
    }

    // optional fixed32 colorgemcolor = 11;

    pub fn colorgemcolor(&self) -> u32 {
        self.colorgemcolor.unwrap_or(0)
    }

    pub fn clear_colorgemcolor(&mut self) {
        self.colorgemcolor = ::std::option::Option::None;
    }

    pub fn has_colorgemcolor(&self) -> bool {
        self.colorgemcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorgemcolor(&mut self, v: u32) {
        self.colorgemcolor = ::std::option::Option::Some(v);
    }

    // optional int32 launch_tick = 12;

    pub fn launch_tick(&self) -> i32 {
        self.launch_tick.unwrap_or(0)
    }

    pub fn clear_launch_tick(&mut self) {
        self.launch_tick = ::std::option::Option::None;
    }

    pub fn has_launch_tick(&self) -> bool {
        self.launch_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch_tick(&mut self, v: i32) {
        self.launch_tick = ::std::option::Option::Some(v);
    }

    // optional int32 handle = 13;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    // optional int64 additional_particle_system_handle = 16;

    pub fn additional_particle_system_handle(&self) -> i64 {
        self.additional_particle_system_handle.unwrap_or(0)
    }

    pub fn clear_additional_particle_system_handle(&mut self) {
        self.additional_particle_system_handle = ::std::option::Option::None;
    }

    pub fn has_additional_particle_system_handle(&self) -> bool {
        self.additional_particle_system_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_particle_system_handle(&mut self, v: i64) {
        self.additional_particle_system_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.source },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.target },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "move_speed",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.move_speed },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.move_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_attachment",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.source_attachment },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.source_attachment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_system_handle",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.particle_system_handle },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.particle_system_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dodgeable",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.dodgeable },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.dodgeable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_attack",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.is_attack },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.is_attack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expire_time",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.expire_time },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.expire_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximpacttime",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.maximpacttime },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.maximpacttime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "colorgemcolor",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.colorgemcolor },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.colorgemcolor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "launch_tick",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.launch_tick },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.launch_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.handle },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "target_loc",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.target_loc },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.target_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "particle_cp_data",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.particle_cp_data },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.particle_cp_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_particle_system_handle",
            |m: &CDOTAUserMsg_TE_Projectile| { &m.additional_particle_system_handle },
            |m: &mut CDOTAUserMsg_TE_Projectile| { &mut m.additional_particle_system_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TE_Projectile>(
            "CDOTAUserMsg_TE_Projectile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_Projectile {
    const NAME: &'static str = "CDOTAUserMsg_TE_Projectile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.move_speed = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.source_attachment = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.particle_system_handle = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.dodgeable = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.is_attack = ::std::option::Option::Some(is.read_bool()?);
                },
                77 => {
                    self.expire_time = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.maximpacttime = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.colorgemcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                96 => {
                    self.launch_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.target_loc)?;
                },
                122 => {
                    self.particle_cp_data.push(is.read_message()?);
                },
                128 => {
                    self.additional_particle_system_handle = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.move_speed {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.source_attachment {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.particle_system_handle {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.dodgeable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_attack {
            my_size += 1 + 1;
        }
        if let Some(v) = self.expire_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.maximpacttime {
            my_size += 1 + 4;
        }
        if let Some(v) = self.colorgemcolor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.launch_tick {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.target_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.particle_cp_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.additional_particle_system_handle {
            my_size += ::protobuf::rt::int64_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.move_speed {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.source_attachment {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.particle_system_handle {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.dodgeable {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.is_attack {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.expire_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.maximpacttime {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.colorgemcolor {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.launch_tick {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.handle {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.target_loc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.particle_cp_data {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.additional_particle_system_handle {
            os.write_int64(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_Projectile {
        CDOTAUserMsg_TE_Projectile::new()
    }

    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.move_speed = ::std::option::Option::None;
        self.source_attachment = ::std::option::Option::None;
        self.particle_system_handle = ::std::option::Option::None;
        self.dodgeable = ::std::option::Option::None;
        self.is_attack = ::std::option::Option::None;
        self.expire_time = ::std::option::Option::None;
        self.maximpacttime = ::std::option::Option::None;
        self.colorgemcolor = ::std::option::Option::None;
        self.launch_tick = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.target_loc.clear();
        self.particle_cp_data.clear();
        self.additional_particle_system_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_Projectile {
        static instance: CDOTAUserMsg_TE_Projectile = CDOTAUserMsg_TE_Projectile {
            source: ::std::option::Option::None,
            target: ::std::option::Option::None,
            move_speed: ::std::option::Option::None,
            source_attachment: ::std::option::Option::None,
            particle_system_handle: ::std::option::Option::None,
            dodgeable: ::std::option::Option::None,
            is_attack: ::std::option::Option::None,
            expire_time: ::std::option::Option::None,
            maximpacttime: ::std::option::Option::None,
            colorgemcolor: ::std::option::Option::None,
            launch_tick: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            target_loc: ::protobuf::MessageField::none(),
            particle_cp_data: ::std::vec::Vec::new(),
            additional_particle_system_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TE_Projectile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TE_Projectile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TE_Projectile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_Projectile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TE_ProjectileLoc)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_ProjectileLoc {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.source_loc)
    pub source_loc: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.target)
    pub target: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.move_speed)
    pub move_speed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.particle_system_handle)
    pub particle_system_handle: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.dodgeable)
    pub dodgeable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.is_attack)
    pub is_attack: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.expire_time)
    pub expire_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.target_loc)
    pub target_loc: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.colorgemcolor)
    pub colorgemcolor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.launch_tick)
    pub launch_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.handle)
    pub handle: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.source)
    pub source: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.source_attachment)
    pub source_attachment: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.particle_cp_data)
    pub particle_cp_data: ::std::vec::Vec<CDOTAUserMsg_ProjectileParticleCPData>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_ProjectileLoc.additional_particle_system_handle)
    pub additional_particle_system_handle: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TE_ProjectileLoc.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_ProjectileLoc {
    fn default() -> &'a CDOTAUserMsg_TE_ProjectileLoc {
        <CDOTAUserMsg_TE_ProjectileLoc as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_ProjectileLoc {
    pub fn new() -> CDOTAUserMsg_TE_ProjectileLoc {
        ::std::default::Default::default()
    }

    // optional uint32 target = 2;

    pub fn target(&self) -> u32 {
        self.target.unwrap_or(0)
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: u32) {
        self.target = ::std::option::Option::Some(v);
    }

    // optional int32 move_speed = 3;

    pub fn move_speed(&self) -> i32 {
        self.move_speed.unwrap_or(0)
    }

    pub fn clear_move_speed(&mut self) {
        self.move_speed = ::std::option::Option::None;
    }

    pub fn has_move_speed(&self) -> bool {
        self.move_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_speed(&mut self, v: i32) {
        self.move_speed = ::std::option::Option::Some(v);
    }

    // optional int64 particle_system_handle = 4;

    pub fn particle_system_handle(&self) -> i64 {
        self.particle_system_handle.unwrap_or(0)
    }

    pub fn clear_particle_system_handle(&mut self) {
        self.particle_system_handle = ::std::option::Option::None;
    }

    pub fn has_particle_system_handle(&self) -> bool {
        self.particle_system_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_system_handle(&mut self, v: i64) {
        self.particle_system_handle = ::std::option::Option::Some(v);
    }

    // optional bool dodgeable = 5;

    pub fn dodgeable(&self) -> bool {
        self.dodgeable.unwrap_or(false)
    }

    pub fn clear_dodgeable(&mut self) {
        self.dodgeable = ::std::option::Option::None;
    }

    pub fn has_dodgeable(&self) -> bool {
        self.dodgeable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dodgeable(&mut self, v: bool) {
        self.dodgeable = ::std::option::Option::Some(v);
    }

    // optional bool is_attack = 6;

    pub fn is_attack(&self) -> bool {
        self.is_attack.unwrap_or(false)
    }

    pub fn clear_is_attack(&mut self) {
        self.is_attack = ::std::option::Option::None;
    }

    pub fn has_is_attack(&self) -> bool {
        self.is_attack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attack(&mut self, v: bool) {
        self.is_attack = ::std::option::Option::Some(v);
    }

    // optional float expire_time = 9;

    pub fn expire_time(&self) -> f32 {
        self.expire_time.unwrap_or(0.)
    }

    pub fn clear_expire_time(&mut self) {
        self.expire_time = ::std::option::Option::None;
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: f32) {
        self.expire_time = ::std::option::Option::Some(v);
    }

    // optional fixed32 colorgemcolor = 11;

    pub fn colorgemcolor(&self) -> u32 {
        self.colorgemcolor.unwrap_or(0)
    }

    pub fn clear_colorgemcolor(&mut self) {
        self.colorgemcolor = ::std::option::Option::None;
    }

    pub fn has_colorgemcolor(&self) -> bool {
        self.colorgemcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorgemcolor(&mut self, v: u32) {
        self.colorgemcolor = ::std::option::Option::Some(v);
    }

    // optional int32 launch_tick = 12;

    pub fn launch_tick(&self) -> i32 {
        self.launch_tick.unwrap_or(0)
    }

    pub fn clear_launch_tick(&mut self) {
        self.launch_tick = ::std::option::Option::None;
    }

    pub fn has_launch_tick(&self) -> bool {
        self.launch_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch_tick(&mut self, v: i32) {
        self.launch_tick = ::std::option::Option::Some(v);
    }

    // optional int32 handle = 13;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    // optional uint32 source = 14;

    pub fn source(&self) -> u32 {
        self.source.unwrap_or(0)
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: u32) {
        self.source = ::std::option::Option::Some(v);
    }

    // optional int32 source_attachment = 15;

    pub fn source_attachment(&self) -> i32 {
        self.source_attachment.unwrap_or(0)
    }

    pub fn clear_source_attachment(&mut self) {
        self.source_attachment = ::std::option::Option::None;
    }

    pub fn has_source_attachment(&self) -> bool {
        self.source_attachment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_attachment(&mut self, v: i32) {
        self.source_attachment = ::std::option::Option::Some(v);
    }

    // optional int64 additional_particle_system_handle = 17;

    pub fn additional_particle_system_handle(&self) -> i64 {
        self.additional_particle_system_handle.unwrap_or(0)
    }

    pub fn clear_additional_particle_system_handle(&mut self) {
        self.additional_particle_system_handle = ::std::option::Option::None;
    }

    pub fn has_additional_particle_system_handle(&self) -> bool {
        self.additional_particle_system_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_particle_system_handle(&mut self, v: i64) {
        self.additional_particle_system_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "source_loc",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.source_loc },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.source_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.target },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "move_speed",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.move_speed },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.move_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_system_handle",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.particle_system_handle },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.particle_system_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dodgeable",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.dodgeable },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.dodgeable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_attack",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.is_attack },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.is_attack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expire_time",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.expire_time },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.expire_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "target_loc",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.target_loc },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.target_loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "colorgemcolor",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.colorgemcolor },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.colorgemcolor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "launch_tick",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.launch_tick },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.launch_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.handle },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.source },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_attachment",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.source_attachment },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.source_attachment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "particle_cp_data",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.particle_cp_data },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.particle_cp_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_particle_system_handle",
            |m: &CDOTAUserMsg_TE_ProjectileLoc| { &m.additional_particle_system_handle },
            |m: &mut CDOTAUserMsg_TE_ProjectileLoc| { &mut m.additional_particle_system_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TE_ProjectileLoc>(
            "CDOTAUserMsg_TE_ProjectileLoc",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_ProjectileLoc {
    const NAME: &'static str = "CDOTAUserMsg_TE_ProjectileLoc";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source_loc)?;
                },
                16 => {
                    self.target = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.move_speed = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.particle_system_handle = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.dodgeable = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_attack = ::std::option::Option::Some(is.read_bool()?);
                },
                77 => {
                    self.expire_time = ::std::option::Option::Some(is.read_float()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.target_loc)?;
                },
                93 => {
                    self.colorgemcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                96 => {
                    self.launch_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.source = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.source_attachment = ::std::option::Option::Some(is.read_int32()?);
                },
                130 => {
                    self.particle_cp_data.push(is.read_message()?);
                },
                136 => {
                    self.additional_particle_system_handle = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.target {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.move_speed {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.particle_system_handle {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.dodgeable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_attack {
            my_size += 1 + 1;
        }
        if let Some(v) = self.expire_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.target_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.colorgemcolor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.launch_tick {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.source {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.source_attachment {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        for value in &self.particle_cp_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.additional_particle_system_handle {
            my_size += ::protobuf::rt::int64_size(17, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_loc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.target {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.move_speed {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.particle_system_handle {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.dodgeable {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_attack {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.expire_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.target_loc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.colorgemcolor {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.launch_tick {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.handle {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.source {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.source_attachment {
            os.write_int32(15, v)?;
        }
        for v in &self.particle_cp_data {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if let Some(v) = self.additional_particle_system_handle {
            os.write_int64(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_ProjectileLoc {
        CDOTAUserMsg_TE_ProjectileLoc::new()
    }

    fn clear(&mut self) {
        self.source_loc.clear();
        self.target = ::std::option::Option::None;
        self.move_speed = ::std::option::Option::None;
        self.particle_system_handle = ::std::option::Option::None;
        self.dodgeable = ::std::option::Option::None;
        self.is_attack = ::std::option::Option::None;
        self.expire_time = ::std::option::Option::None;
        self.target_loc.clear();
        self.colorgemcolor = ::std::option::Option::None;
        self.launch_tick = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.source_attachment = ::std::option::Option::None;
        self.particle_cp_data.clear();
        self.additional_particle_system_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_ProjectileLoc {
        static instance: CDOTAUserMsg_TE_ProjectileLoc = CDOTAUserMsg_TE_ProjectileLoc {
            source_loc: ::protobuf::MessageField::none(),
            target: ::std::option::Option::None,
            move_speed: ::std::option::Option::None,
            particle_system_handle: ::std::option::Option::None,
            dodgeable: ::std::option::Option::None,
            is_attack: ::std::option::Option::None,
            expire_time: ::std::option::Option::None,
            target_loc: ::protobuf::MessageField::none(),
            colorgemcolor: ::std::option::Option::None,
            launch_tick: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            source: ::std::option::Option::None,
            source_attachment: ::std::option::Option::None,
            particle_cp_data: ::std::vec::Vec::new(),
            additional_particle_system_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TE_ProjectileLoc {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TE_ProjectileLoc").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TE_ProjectileLoc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_ProjectileLoc {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TE_DestroyProjectile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_DestroyProjectile {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_DestroyProjectile.handle)
    pub handle: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TE_DestroyProjectile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_DestroyProjectile {
    fn default() -> &'a CDOTAUserMsg_TE_DestroyProjectile {
        <CDOTAUserMsg_TE_DestroyProjectile as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_DestroyProjectile {
    pub fn new() -> CDOTAUserMsg_TE_DestroyProjectile {
        ::std::default::Default::default()
    }

    // optional int32 handle = 1;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &CDOTAUserMsg_TE_DestroyProjectile| { &m.handle },
            |m: &mut CDOTAUserMsg_TE_DestroyProjectile| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TE_DestroyProjectile>(
            "CDOTAUserMsg_TE_DestroyProjectile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_DestroyProjectile {
    const NAME: &'static str = "CDOTAUserMsg_TE_DestroyProjectile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.handle {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_DestroyProjectile {
        CDOTAUserMsg_TE_DestroyProjectile::new()
    }

    fn clear(&mut self) {
        self.handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_DestroyProjectile {
        static instance: CDOTAUserMsg_TE_DestroyProjectile = CDOTAUserMsg_TE_DestroyProjectile {
            handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TE_DestroyProjectile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TE_DestroyProjectile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TE_DestroyProjectile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_DestroyProjectile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TE_DotaBloodImpact)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_DotaBloodImpact {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_DotaBloodImpact.entity)
    pub entity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_DotaBloodImpact.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_DotaBloodImpact.xnormal)
    pub xnormal: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_DotaBloodImpact.ynormal)
    pub ynormal: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TE_DotaBloodImpact.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_DotaBloodImpact {
    fn default() -> &'a CDOTAUserMsg_TE_DotaBloodImpact {
        <CDOTAUserMsg_TE_DotaBloodImpact as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_DotaBloodImpact {
    pub fn new() -> CDOTAUserMsg_TE_DotaBloodImpact {
        ::std::default::Default::default()
    }

    // optional uint32 entity = 1;

    pub fn entity(&self) -> u32 {
        self.entity.unwrap_or(0)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: u32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float xnormal = 3;

    pub fn xnormal(&self) -> f32 {
        self.xnormal.unwrap_or(0.)
    }

    pub fn clear_xnormal(&mut self) {
        self.xnormal = ::std::option::Option::None;
    }

    pub fn has_xnormal(&self) -> bool {
        self.xnormal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xnormal(&mut self, v: f32) {
        self.xnormal = ::std::option::Option::Some(v);
    }

    // optional float ynormal = 4;

    pub fn ynormal(&self) -> f32 {
        self.ynormal.unwrap_or(0.)
    }

    pub fn clear_ynormal(&mut self) {
        self.ynormal = ::std::option::Option::None;
    }

    pub fn has_ynormal(&self) -> bool {
        self.ynormal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ynormal(&mut self, v: f32) {
        self.ynormal = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity",
            |m: &CDOTAUserMsg_TE_DotaBloodImpact| { &m.entity },
            |m: &mut CDOTAUserMsg_TE_DotaBloodImpact| { &mut m.entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CDOTAUserMsg_TE_DotaBloodImpact| { &m.scale },
            |m: &mut CDOTAUserMsg_TE_DotaBloodImpact| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xnormal",
            |m: &CDOTAUserMsg_TE_DotaBloodImpact| { &m.xnormal },
            |m: &mut CDOTAUserMsg_TE_DotaBloodImpact| { &mut m.xnormal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ynormal",
            |m: &CDOTAUserMsg_TE_DotaBloodImpact| { &m.ynormal },
            |m: &mut CDOTAUserMsg_TE_DotaBloodImpact| { &mut m.ynormal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TE_DotaBloodImpact>(
            "CDOTAUserMsg_TE_DotaBloodImpact",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_DotaBloodImpact {
    const NAME: &'static str = "CDOTAUserMsg_TE_DotaBloodImpact";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.xnormal = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.ynormal = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.xnormal {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ynormal {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.xnormal {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.ynormal {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_DotaBloodImpact {
        CDOTAUserMsg_TE_DotaBloodImpact::new()
    }

    fn clear(&mut self) {
        self.entity = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.xnormal = ::std::option::Option::None;
        self.ynormal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_DotaBloodImpact {
        static instance: CDOTAUserMsg_TE_DotaBloodImpact = CDOTAUserMsg_TE_DotaBloodImpact {
            entity: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            xnormal: ::std::option::Option::None,
            ynormal: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TE_DotaBloodImpact {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TE_DotaBloodImpact").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TE_DotaBloodImpact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_DotaBloodImpact {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_AbilityPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AbilityPing {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<DOTA_ABILITY_PING_TYPE>>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.cooldown_seconds)
    pub cooldown_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.level)
    pub level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.passive)
    pub passive: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.mana_needed)
    pub mana_needed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.entity_id)
    pub entity_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.primary_charges)
    pub primary_charges: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.secondary_charges)
    pub secondary_charges: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.ctrl_held)
    pub ctrl_held: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityPing.reclaim_time)
    pub reclaim_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_AbilityPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AbilityPing {
    fn default() -> &'a CDOTAUserMsg_AbilityPing {
        <CDOTAUserMsg_AbilityPing as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AbilityPing {
    pub fn new() -> CDOTAUserMsg_AbilityPing {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 2;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .dota.DOTA_ABILITY_PING_TYPE type = 3;

    pub fn type_(&self) -> DOTA_ABILITY_PING_TYPE {
        match self.type_ {
            Some(e) => e.enum_value_or(DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY),
            None => DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: DOTA_ABILITY_PING_TYPE) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 cooldown_seconds = 4;

    pub fn cooldown_seconds(&self) -> u32 {
        self.cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_cooldown_seconds(&mut self) {
        self.cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds(&self) -> bool {
        self.cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds(&mut self, v: u32) {
        self.cooldown_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 5;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional bool passive = 6;

    pub fn passive(&self) -> bool {
        self.passive.unwrap_or(false)
    }

    pub fn clear_passive(&mut self) {
        self.passive = ::std::option::Option::None;
    }

    pub fn has_passive(&self) -> bool {
        self.passive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passive(&mut self, v: bool) {
        self.passive = ::std::option::Option::Some(v);
    }

    // optional uint32 mana_needed = 7;

    pub fn mana_needed(&self) -> u32 {
        self.mana_needed.unwrap_or(0)
    }

    pub fn clear_mana_needed(&mut self) {
        self.mana_needed = ::std::option::Option::None;
    }

    pub fn has_mana_needed(&self) -> bool {
        self.mana_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mana_needed(&mut self, v: u32) {
        self.mana_needed = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_id = 8;

    pub fn entity_id(&self) -> u32 {
        self.entity_id.unwrap_or(0)
    }

    pub fn clear_entity_id(&mut self) {
        self.entity_id = ::std::option::Option::None;
    }

    pub fn has_entity_id(&self) -> bool {
        self.entity_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: u32) {
        self.entity_id = ::std::option::Option::Some(v);
    }

    // optional int32 primary_charges = 9;

    pub fn primary_charges(&self) -> i32 {
        self.primary_charges.unwrap_or(0)
    }

    pub fn clear_primary_charges(&mut self) {
        self.primary_charges = ::std::option::Option::None;
    }

    pub fn has_primary_charges(&self) -> bool {
        self.primary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_charges(&mut self, v: i32) {
        self.primary_charges = ::std::option::Option::Some(v);
    }

    // optional int32 secondary_charges = 10;

    pub fn secondary_charges(&self) -> i32 {
        self.secondary_charges.unwrap_or(0)
    }

    pub fn clear_secondary_charges(&mut self) {
        self.secondary_charges = ::std::option::Option::None;
    }

    pub fn has_secondary_charges(&self) -> bool {
        self.secondary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_charges(&mut self, v: i32) {
        self.secondary_charges = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_held = 12;

    pub fn ctrl_held(&self) -> bool {
        self.ctrl_held.unwrap_or(false)
    }

    pub fn clear_ctrl_held(&mut self) {
        self.ctrl_held = ::std::option::Option::None;
    }

    pub fn has_ctrl_held(&self) -> bool {
        self.ctrl_held.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_held(&mut self, v: bool) {
        self.ctrl_held = ::std::option::Option::Some(v);
    }

    // optional float reclaim_time = 13;

    pub fn reclaim_time(&self) -> f32 {
        self.reclaim_time.unwrap_or(0.)
    }

    pub fn clear_reclaim_time(&mut self) {
        self.reclaim_time = ::std::option::Option::None;
    }

    pub fn has_reclaim_time(&self) -> bool {
        self.reclaim_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reclaim_time(&mut self, v: f32) {
        self.reclaim_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_AbilityPing| { &m.player_id },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &CDOTAUserMsg_AbilityPing| { &m.ability_id },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CDOTAUserMsg_AbilityPing| { &m.type_ },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cooldown_seconds",
            |m: &CDOTAUserMsg_AbilityPing| { &m.cooldown_seconds },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.cooldown_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level",
            |m: &CDOTAUserMsg_AbilityPing| { &m.level },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passive",
            |m: &CDOTAUserMsg_AbilityPing| { &m.passive },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.passive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mana_needed",
            |m: &CDOTAUserMsg_AbilityPing| { &m.mana_needed },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.mana_needed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_id",
            |m: &CDOTAUserMsg_AbilityPing| { &m.entity_id },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_charges",
            |m: &CDOTAUserMsg_AbilityPing| { &m.primary_charges },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.primary_charges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secondary_charges",
            |m: &CDOTAUserMsg_AbilityPing| { &m.secondary_charges },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.secondary_charges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctrl_held",
            |m: &CDOTAUserMsg_AbilityPing| { &m.ctrl_held },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.ctrl_held },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reclaim_time",
            |m: &CDOTAUserMsg_AbilityPing| { &m.reclaim_time },
            |m: &mut CDOTAUserMsg_AbilityPing| { &mut m.reclaim_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_AbilityPing>(
            "CDOTAUserMsg_AbilityPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AbilityPing {
    const NAME: &'static str = "CDOTAUserMsg_AbilityPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.cooldown_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.passive = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.mana_needed = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.entity_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.primary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.secondary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.ctrl_held = ::std::option::Option::Some(is.read_bool()?);
                },
                109 => {
                    self.reclaim_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.cooldown_seconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.passive {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mana_needed {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.entity_id {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.primary_charges {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.secondary_charges {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.ctrl_held {
            my_size += 1 + 1;
        }
        if let Some(v) = self.reclaim_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cooldown_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.passive {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.mana_needed {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.entity_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.primary_charges {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.secondary_charges {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.ctrl_held {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.reclaim_time {
            os.write_float(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AbilityPing {
        CDOTAUserMsg_AbilityPing::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.cooldown_seconds = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.passive = ::std::option::Option::None;
        self.mana_needed = ::std::option::Option::None;
        self.entity_id = ::std::option::Option::None;
        self.primary_charges = ::std::option::Option::None;
        self.secondary_charges = ::std::option::Option::None;
        self.ctrl_held = ::std::option::Option::None;
        self.reclaim_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AbilityPing {
        static instance: CDOTAUserMsg_AbilityPing = CDOTAUserMsg_AbilityPing {
            player_id: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            cooldown_seconds: ::std::option::Option::None,
            level: ::std::option::Option::None,
            passive: ::std::option::Option::None,
            mana_needed: ::std::option::Option::None,
            entity_id: ::std::option::Option::None,
            primary_charges: ::std::option::Option::None,
            secondary_charges: ::std::option::Option::None,
            ctrl_held: ::std::option::Option::None,
            reclaim_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_AbilityPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_AbilityPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_AbilityPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AbilityPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TE_UnitAnimation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_UnitAnimation {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_UnitAnimation.entity)
    pub entity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_UnitAnimation.sequence_variant)
    pub sequence_variant: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_UnitAnimation.playbackrate)
    pub playbackrate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_UnitAnimation.castpoint)
    pub castpoint: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_UnitAnimation.type)
    pub type_: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_UnitAnimation.activity)
    pub activity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_UnitAnimation.lag_compensation_time)
    pub lag_compensation_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TE_UnitAnimation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_UnitAnimation {
    fn default() -> &'a CDOTAUserMsg_TE_UnitAnimation {
        <CDOTAUserMsg_TE_UnitAnimation as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_UnitAnimation {
    pub fn new() -> CDOTAUserMsg_TE_UnitAnimation {
        ::std::default::Default::default()
    }

    // optional uint32 entity = 1;

    pub fn entity(&self) -> u32 {
        self.entity.unwrap_or(0)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: u32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional int32 sequence_variant = 2;

    pub fn sequence_variant(&self) -> i32 {
        self.sequence_variant.unwrap_or(0)
    }

    pub fn clear_sequence_variant(&mut self) {
        self.sequence_variant = ::std::option::Option::None;
    }

    pub fn has_sequence_variant(&self) -> bool {
        self.sequence_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_variant(&mut self, v: i32) {
        self.sequence_variant = ::std::option::Option::Some(v);
    }

    // optional float playbackrate = 3;

    pub fn playbackrate(&self) -> f32 {
        self.playbackrate.unwrap_or(0.)
    }

    pub fn clear_playbackrate(&mut self) {
        self.playbackrate = ::std::option::Option::None;
    }

    pub fn has_playbackrate(&self) -> bool {
        self.playbackrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playbackrate(&mut self, v: f32) {
        self.playbackrate = ::std::option::Option::Some(v);
    }

    // optional float castpoint = 4;

    pub fn castpoint(&self) -> f32 {
        self.castpoint.unwrap_or(0.)
    }

    pub fn clear_castpoint(&mut self) {
        self.castpoint = ::std::option::Option::None;
    }

    pub fn has_castpoint(&self) -> bool {
        self.castpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_castpoint(&mut self, v: f32) {
        self.castpoint = ::std::option::Option::Some(v);
    }

    // optional int32 type = 5;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional int32 activity = 6;

    pub fn activity(&self) -> i32 {
        self.activity.unwrap_or(0)
    }

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: i32) {
        self.activity = ::std::option::Option::Some(v);
    }

    // optional float lag_compensation_time = 7;

    pub fn lag_compensation_time(&self) -> f32 {
        self.lag_compensation_time.unwrap_or(0.)
    }

    pub fn clear_lag_compensation_time(&mut self) {
        self.lag_compensation_time = ::std::option::Option::None;
    }

    pub fn has_lag_compensation_time(&self) -> bool {
        self.lag_compensation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lag_compensation_time(&mut self, v: f32) {
        self.lag_compensation_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity",
            |m: &CDOTAUserMsg_TE_UnitAnimation| { &m.entity },
            |m: &mut CDOTAUserMsg_TE_UnitAnimation| { &mut m.entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_variant",
            |m: &CDOTAUserMsg_TE_UnitAnimation| { &m.sequence_variant },
            |m: &mut CDOTAUserMsg_TE_UnitAnimation| { &mut m.sequence_variant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playbackrate",
            |m: &CDOTAUserMsg_TE_UnitAnimation| { &m.playbackrate },
            |m: &mut CDOTAUserMsg_TE_UnitAnimation| { &mut m.playbackrate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "castpoint",
            |m: &CDOTAUserMsg_TE_UnitAnimation| { &m.castpoint },
            |m: &mut CDOTAUserMsg_TE_UnitAnimation| { &mut m.castpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CDOTAUserMsg_TE_UnitAnimation| { &m.type_ },
            |m: &mut CDOTAUserMsg_TE_UnitAnimation| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "activity",
            |m: &CDOTAUserMsg_TE_UnitAnimation| { &m.activity },
            |m: &mut CDOTAUserMsg_TE_UnitAnimation| { &mut m.activity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lag_compensation_time",
            |m: &CDOTAUserMsg_TE_UnitAnimation| { &m.lag_compensation_time },
            |m: &mut CDOTAUserMsg_TE_UnitAnimation| { &mut m.lag_compensation_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TE_UnitAnimation>(
            "CDOTAUserMsg_TE_UnitAnimation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_UnitAnimation {
    const NAME: &'static str = "CDOTAUserMsg_TE_UnitAnimation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.sequence_variant = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.playbackrate = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.castpoint = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.activity = ::std::option::Option::Some(is.read_int32()?);
                },
                61 => {
                    self.lag_compensation_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sequence_variant {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.playbackrate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.castpoint {
            my_size += 1 + 4;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.lag_compensation_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sequence_variant {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.playbackrate {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.castpoint {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.activity {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.lag_compensation_time {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_UnitAnimation {
        CDOTAUserMsg_TE_UnitAnimation::new()
    }

    fn clear(&mut self) {
        self.entity = ::std::option::Option::None;
        self.sequence_variant = ::std::option::Option::None;
        self.playbackrate = ::std::option::Option::None;
        self.castpoint = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.activity = ::std::option::Option::None;
        self.lag_compensation_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_UnitAnimation {
        static instance: CDOTAUserMsg_TE_UnitAnimation = CDOTAUserMsg_TE_UnitAnimation {
            entity: ::std::option::Option::None,
            sequence_variant: ::std::option::Option::None,
            playbackrate: ::std::option::Option::None,
            castpoint: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            activity: ::std::option::Option::None,
            lag_compensation_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TE_UnitAnimation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TE_UnitAnimation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TE_UnitAnimation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_UnitAnimation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TE_UnitAnimationEnd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_UnitAnimationEnd {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_UnitAnimationEnd.entity)
    pub entity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TE_UnitAnimationEnd.snap)
    pub snap: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TE_UnitAnimationEnd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_UnitAnimationEnd {
    fn default() -> &'a CDOTAUserMsg_TE_UnitAnimationEnd {
        <CDOTAUserMsg_TE_UnitAnimationEnd as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_UnitAnimationEnd {
    pub fn new() -> CDOTAUserMsg_TE_UnitAnimationEnd {
        ::std::default::Default::default()
    }

    // optional uint32 entity = 1;

    pub fn entity(&self) -> u32 {
        self.entity.unwrap_or(0)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: u32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional bool snap = 2;

    pub fn snap(&self) -> bool {
        self.snap.unwrap_or(false)
    }

    pub fn clear_snap(&mut self) {
        self.snap = ::std::option::Option::None;
    }

    pub fn has_snap(&self) -> bool {
        self.snap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snap(&mut self, v: bool) {
        self.snap = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity",
            |m: &CDOTAUserMsg_TE_UnitAnimationEnd| { &m.entity },
            |m: &mut CDOTAUserMsg_TE_UnitAnimationEnd| { &mut m.entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "snap",
            |m: &CDOTAUserMsg_TE_UnitAnimationEnd| { &m.snap },
            |m: &mut CDOTAUserMsg_TE_UnitAnimationEnd| { &mut m.snap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TE_UnitAnimationEnd>(
            "CDOTAUserMsg_TE_UnitAnimationEnd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_UnitAnimationEnd {
    const NAME: &'static str = "CDOTAUserMsg_TE_UnitAnimationEnd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.snap = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.snap {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.snap {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_UnitAnimationEnd {
        CDOTAUserMsg_TE_UnitAnimationEnd::new()
    }

    fn clear(&mut self) {
        self.entity = ::std::option::Option::None;
        self.snap = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_UnitAnimationEnd {
        static instance: CDOTAUserMsg_TE_UnitAnimationEnd = CDOTAUserMsg_TE_UnitAnimationEnd {
            entity: ::std::option::Option::None,
            snap: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TE_UnitAnimationEnd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TE_UnitAnimationEnd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TE_UnitAnimationEnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_UnitAnimationEnd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ShowGenericPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ShowGenericPopup {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowGenericPopup.header)
    pub header: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowGenericPopup.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowGenericPopup.param1)
    pub param1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowGenericPopup.param2)
    pub param2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowGenericPopup.tint_screen)
    pub tint_screen: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShowGenericPopup.show_no_other_dialogs)
    pub show_no_other_dialogs: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ShowGenericPopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ShowGenericPopup {
    fn default() -> &'a CDOTAUserMsg_ShowGenericPopup {
        <CDOTAUserMsg_ShowGenericPopup as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ShowGenericPopup {
    pub fn new() -> CDOTAUserMsg_ShowGenericPopup {
        ::std::default::Default::default()
    }

    // required string header = 1;

    pub fn header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_header(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ::std::string::String) {
        self.header = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ::std::string::String {
        if self.header.is_none() {
            self.header = ::std::option::Option::Some(::std::string::String::new());
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ::std::string::String {
        self.header.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string body = 2;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param1 = 3;

    pub fn param1(&self) -> &str {
        match self.param1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param1(&mut self) {
        self.param1 = ::std::option::Option::None;
    }

    pub fn has_param1(&self) -> bool {
        self.param1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param1(&mut self, v: ::std::string::String) {
        self.param1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param1(&mut self) -> &mut ::std::string::String {
        if self.param1.is_none() {
            self.param1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param1.as_mut().unwrap()
    }

    // Take field
    pub fn take_param1(&mut self) -> ::std::string::String {
        self.param1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param2 = 4;

    pub fn param2(&self) -> &str {
        match self.param2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param2(&mut self) {
        self.param2 = ::std::option::Option::None;
    }

    pub fn has_param2(&self) -> bool {
        self.param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param2(&mut self, v: ::std::string::String) {
        self.param2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param2(&mut self) -> &mut ::std::string::String {
        if self.param2.is_none() {
            self.param2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param2.as_mut().unwrap()
    }

    // Take field
    pub fn take_param2(&mut self) -> ::std::string::String {
        self.param2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool tint_screen = 5;

    pub fn tint_screen(&self) -> bool {
        self.tint_screen.unwrap_or(false)
    }

    pub fn clear_tint_screen(&mut self) {
        self.tint_screen = ::std::option::Option::None;
    }

    pub fn has_tint_screen(&self) -> bool {
        self.tint_screen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tint_screen(&mut self, v: bool) {
        self.tint_screen = ::std::option::Option::Some(v);
    }

    // optional bool show_no_other_dialogs = 6;

    pub fn show_no_other_dialogs(&self) -> bool {
        self.show_no_other_dialogs.unwrap_or(false)
    }

    pub fn clear_show_no_other_dialogs(&mut self) {
        self.show_no_other_dialogs = ::std::option::Option::None;
    }

    pub fn has_show_no_other_dialogs(&self) -> bool {
        self.show_no_other_dialogs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_no_other_dialogs(&mut self, v: bool) {
        self.show_no_other_dialogs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "header",
            |m: &CDOTAUserMsg_ShowGenericPopup| { &m.header },
            |m: &mut CDOTAUserMsg_ShowGenericPopup| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &CDOTAUserMsg_ShowGenericPopup| { &m.body },
            |m: &mut CDOTAUserMsg_ShowGenericPopup| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param1",
            |m: &CDOTAUserMsg_ShowGenericPopup| { &m.param1 },
            |m: &mut CDOTAUserMsg_ShowGenericPopup| { &mut m.param1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param2",
            |m: &CDOTAUserMsg_ShowGenericPopup| { &m.param2 },
            |m: &mut CDOTAUserMsg_ShowGenericPopup| { &mut m.param2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tint_screen",
            |m: &CDOTAUserMsg_ShowGenericPopup| { &m.tint_screen },
            |m: &mut CDOTAUserMsg_ShowGenericPopup| { &mut m.tint_screen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_no_other_dialogs",
            |m: &CDOTAUserMsg_ShowGenericPopup| { &m.show_no_other_dialogs },
            |m: &mut CDOTAUserMsg_ShowGenericPopup| { &mut m.show_no_other_dialogs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ShowGenericPopup>(
            "CDOTAUserMsg_ShowGenericPopup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ShowGenericPopup {
    const NAME: &'static str = "CDOTAUserMsg_ShowGenericPopup";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.body.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.header = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.param1 = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.param2 = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.tint_screen = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.show_no_other_dialogs = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.param1.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.param2.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.tint_screen {
            my_size += 1 + 1;
        }
        if let Some(v) = self.show_no_other_dialogs {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.param1.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.param2.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.tint_screen {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.show_no_other_dialogs {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ShowGenericPopup {
        CDOTAUserMsg_ShowGenericPopup::new()
    }

    fn clear(&mut self) {
        self.header = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.param1 = ::std::option::Option::None;
        self.param2 = ::std::option::Option::None;
        self.tint_screen = ::std::option::Option::None;
        self.show_no_other_dialogs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ShowGenericPopup {
        static instance: CDOTAUserMsg_ShowGenericPopup = CDOTAUserMsg_ShowGenericPopup {
            header: ::std::option::Option::None,
            body: ::std::option::Option::None,
            param1: ::std::option::Option::None,
            param2: ::std::option::Option::None,
            tint_screen: ::std::option::Option::None,
            show_no_other_dialogs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ShowGenericPopup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ShowGenericPopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ShowGenericPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ShowGenericPopup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_VoteStart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_VoteStart {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VoteStart.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VoteStart.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VoteStart.choice_count)
    pub choice_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VoteStart.choices)
    pub choices: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_VoteStart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_VoteStart {
    fn default() -> &'a CDOTAUserMsg_VoteStart {
        <CDOTAUserMsg_VoteStart as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_VoteStart {
    pub fn new() -> CDOTAUserMsg_VoteStart {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 choice_count = 3;

    pub fn choice_count(&self) -> i32 {
        self.choice_count.unwrap_or(0)
    }

    pub fn clear_choice_count(&mut self) {
        self.choice_count = ::std::option::Option::None;
    }

    pub fn has_choice_count(&self) -> bool {
        self.choice_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choice_count(&mut self, v: i32) {
        self.choice_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CDOTAUserMsg_VoteStart| { &m.title },
            |m: &mut CDOTAUserMsg_VoteStart| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CDOTAUserMsg_VoteStart| { &m.duration },
            |m: &mut CDOTAUserMsg_VoteStart| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "choice_count",
            |m: &CDOTAUserMsg_VoteStart| { &m.choice_count },
            |m: &mut CDOTAUserMsg_VoteStart| { &mut m.choice_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "choices",
            |m: &CDOTAUserMsg_VoteStart| { &m.choices },
            |m: &mut CDOTAUserMsg_VoteStart| { &mut m.choices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_VoteStart>(
            "CDOTAUserMsg_VoteStart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_VoteStart {
    const NAME: &'static str = "CDOTAUserMsg_VoteStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.choice_count = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.choices.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.choice_count {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.choices {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.choice_count {
            os.write_int32(3, v)?;
        }
        for v in &self.choices {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_VoteStart {
        CDOTAUserMsg_VoteStart::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.choice_count = ::std::option::Option::None;
        self.choices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_VoteStart {
        static instance: CDOTAUserMsg_VoteStart = CDOTAUserMsg_VoteStart {
            title: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            choice_count: ::std::option::Option::None,
            choices: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_VoteStart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_VoteStart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_VoteStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_VoteStart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_VoteUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_VoteUpdate {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VoteUpdate.choice_counts)
    pub choice_counts: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_VoteUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_VoteUpdate {
    fn default() -> &'a CDOTAUserMsg_VoteUpdate {
        <CDOTAUserMsg_VoteUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_VoteUpdate {
    pub fn new() -> CDOTAUserMsg_VoteUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "choice_counts",
            |m: &CDOTAUserMsg_VoteUpdate| { &m.choice_counts },
            |m: &mut CDOTAUserMsg_VoteUpdate| { &mut m.choice_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_VoteUpdate>(
            "CDOTAUserMsg_VoteUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_VoteUpdate {
    const NAME: &'static str = "CDOTAUserMsg_VoteUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.choice_counts)?;
                },
                8 => {
                    self.choice_counts.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.choice_counts {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.choice_counts {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_VoteUpdate {
        CDOTAUserMsg_VoteUpdate::new()
    }

    fn clear(&mut self) {
        self.choice_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_VoteUpdate {
        static instance: CDOTAUserMsg_VoteUpdate = CDOTAUserMsg_VoteUpdate {
            choice_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_VoteUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_VoteUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_VoteUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_VoteUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_VoteEnd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_VoteEnd {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VoteEnd.selected_choice)
    pub selected_choice: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_VoteEnd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_VoteEnd {
    fn default() -> &'a CDOTAUserMsg_VoteEnd {
        <CDOTAUserMsg_VoteEnd as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_VoteEnd {
    pub fn new() -> CDOTAUserMsg_VoteEnd {
        ::std::default::Default::default()
    }

    // optional int32 selected_choice = 1;

    pub fn selected_choice(&self) -> i32 {
        self.selected_choice.unwrap_or(0)
    }

    pub fn clear_selected_choice(&mut self) {
        self.selected_choice = ::std::option::Option::None;
    }

    pub fn has_selected_choice(&self) -> bool {
        self.selected_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_choice(&mut self, v: i32) {
        self.selected_choice = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selected_choice",
            |m: &CDOTAUserMsg_VoteEnd| { &m.selected_choice },
            |m: &mut CDOTAUserMsg_VoteEnd| { &mut m.selected_choice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_VoteEnd>(
            "CDOTAUserMsg_VoteEnd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_VoteEnd {
    const NAME: &'static str = "CDOTAUserMsg_VoteEnd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.selected_choice = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selected_choice {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selected_choice {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_VoteEnd {
        CDOTAUserMsg_VoteEnd::new()
    }

    fn clear(&mut self) {
        self.selected_choice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_VoteEnd {
        static instance: CDOTAUserMsg_VoteEnd = CDOTAUserMsg_VoteEnd {
            selected_choice: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_VoteEnd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_VoteEnd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_VoteEnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_VoteEnd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_BoosterStatePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BoosterStatePlayer {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BoosterStatePlayer.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BoosterStatePlayer.bonus)
    pub bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BoosterStatePlayer.event_bonus)
    pub event_bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BoosterStatePlayer.bonus_item_id)
    pub bonus_item_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BoosterStatePlayer.event_bonus_item_id)
    pub event_bonus_item_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_BoosterStatePlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BoosterStatePlayer {
    fn default() -> &'a CDOTAUserMsg_BoosterStatePlayer {
        <CDOTAUserMsg_BoosterStatePlayer as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BoosterStatePlayer {
    pub fn new() -> CDOTAUserMsg_BoosterStatePlayer {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float bonus = 2;

    pub fn bonus(&self) -> f32 {
        self.bonus.unwrap_or(0.)
    }

    pub fn clear_bonus(&mut self) {
        self.bonus = ::std::option::Option::None;
    }

    pub fn has_bonus(&self) -> bool {
        self.bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus(&mut self, v: f32) {
        self.bonus = ::std::option::Option::Some(v);
    }

    // optional float event_bonus = 3;

    pub fn event_bonus(&self) -> f32 {
        self.event_bonus.unwrap_or(0.)
    }

    pub fn clear_event_bonus(&mut self) {
        self.event_bonus = ::std::option::Option::None;
    }

    pub fn has_event_bonus(&self) -> bool {
        self.event_bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_bonus(&mut self, v: f32) {
        self.event_bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_item_id = 4;

    pub fn bonus_item_id(&self) -> u32 {
        self.bonus_item_id.unwrap_or(0)
    }

    pub fn clear_bonus_item_id(&mut self) {
        self.bonus_item_id = ::std::option::Option::None;
    }

    pub fn has_bonus_item_id(&self) -> bool {
        self.bonus_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_item_id(&mut self, v: u32) {
        self.bonus_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_bonus_item_id = 5;

    pub fn event_bonus_item_id(&self) -> u32 {
        self.event_bonus_item_id.unwrap_or(0)
    }

    pub fn clear_event_bonus_item_id(&mut self) {
        self.event_bonus_item_id = ::std::option::Option::None;
    }

    pub fn has_event_bonus_item_id(&self) -> bool {
        self.event_bonus_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_bonus_item_id(&mut self, v: u32) {
        self.event_bonus_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_BoosterStatePlayer| { &m.player_id },
            |m: &mut CDOTAUserMsg_BoosterStatePlayer| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus",
            |m: &CDOTAUserMsg_BoosterStatePlayer| { &m.bonus },
            |m: &mut CDOTAUserMsg_BoosterStatePlayer| { &mut m.bonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_bonus",
            |m: &CDOTAUserMsg_BoosterStatePlayer| { &m.event_bonus },
            |m: &mut CDOTAUserMsg_BoosterStatePlayer| { &mut m.event_bonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_item_id",
            |m: &CDOTAUserMsg_BoosterStatePlayer| { &m.bonus_item_id },
            |m: &mut CDOTAUserMsg_BoosterStatePlayer| { &mut m.bonus_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_bonus_item_id",
            |m: &CDOTAUserMsg_BoosterStatePlayer| { &m.event_bonus_item_id },
            |m: &mut CDOTAUserMsg_BoosterStatePlayer| { &mut m.event_bonus_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_BoosterStatePlayer>(
            "CDOTAUserMsg_BoosterStatePlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BoosterStatePlayer {
    const NAME: &'static str = "CDOTAUserMsg_BoosterStatePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.bonus = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.event_bonus = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.bonus_item_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.event_bonus_item_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.event_bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bonus_item_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_bonus_item_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.bonus {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.event_bonus {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.bonus_item_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_bonus_item_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BoosterStatePlayer {
        CDOTAUserMsg_BoosterStatePlayer::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.bonus = ::std::option::Option::None;
        self.event_bonus = ::std::option::Option::None;
        self.bonus_item_id = ::std::option::Option::None;
        self.event_bonus_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BoosterStatePlayer {
        static instance: CDOTAUserMsg_BoosterStatePlayer = CDOTAUserMsg_BoosterStatePlayer {
            player_id: ::std::option::Option::None,
            bonus: ::std::option::Option::None,
            event_bonus: ::std::option::Option::None,
            bonus_item_id: ::std::option::Option::None,
            event_bonus_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_BoosterStatePlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_BoosterStatePlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_BoosterStatePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BoosterStatePlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_BoosterState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BoosterState {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BoosterState.boosted_players)
    pub boosted_players: ::std::vec::Vec<CDOTAUserMsg_BoosterStatePlayer>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_BoosterState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BoosterState {
    fn default() -> &'a CDOTAUserMsg_BoosterState {
        <CDOTAUserMsg_BoosterState as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BoosterState {
    pub fn new() -> CDOTAUserMsg_BoosterState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "boosted_players",
            |m: &CDOTAUserMsg_BoosterState| { &m.boosted_players },
            |m: &mut CDOTAUserMsg_BoosterState| { &mut m.boosted_players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_BoosterState>(
            "CDOTAUserMsg_BoosterState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BoosterState {
    const NAME: &'static str = "CDOTAUserMsg_BoosterState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.boosted_players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.boosted_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.boosted_players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BoosterState {
        CDOTAUserMsg_BoosterState::new()
    }

    fn clear(&mut self) {
        self.boosted_players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BoosterState {
        static instance: CDOTAUserMsg_BoosterState = CDOTAUserMsg_BoosterState {
            boosted_players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_BoosterState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_BoosterState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_BoosterState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BoosterState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_PlayerMMR)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PlayerMMR {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PlayerMMR.mmr)
    pub mmr: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_PlayerMMR.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PlayerMMR {
    fn default() -> &'a CDOTAUserMsg_PlayerMMR {
        <CDOTAUserMsg_PlayerMMR as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PlayerMMR {
    pub fn new() -> CDOTAUserMsg_PlayerMMR {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mmr",
            |m: &CDOTAUserMsg_PlayerMMR| { &m.mmr },
            |m: &mut CDOTAUserMsg_PlayerMMR| { &mut m.mmr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_PlayerMMR>(
            "CDOTAUserMsg_PlayerMMR",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_PlayerMMR {
    const NAME: &'static str = "CDOTAUserMsg_PlayerMMR";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_sint32_into(&mut self.mmr)?;
                },
                8 => {
                    self.mmr.push(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.mmr {
            my_size += ::protobuf::rt::sint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.mmr {
            os.write_sint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PlayerMMR {
        CDOTAUserMsg_PlayerMMR::new()
    }

    fn clear(&mut self) {
        self.mmr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PlayerMMR {
        static instance: CDOTAUserMsg_PlayerMMR = CDOTAUserMsg_PlayerMMR {
            mmr: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_PlayerMMR {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_PlayerMMR").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_PlayerMMR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PlayerMMR {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_AbilitySteal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AbilitySteal {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilitySteal.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilitySteal.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilitySteal.ability_level)
    pub ability_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_AbilitySteal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AbilitySteal {
    fn default() -> &'a CDOTAUserMsg_AbilitySteal {
        <CDOTAUserMsg_AbilitySteal as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AbilitySteal {
    pub fn new() -> CDOTAUserMsg_AbilitySteal {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 2;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ability_level = 3;

    pub fn ability_level(&self) -> u32 {
        self.ability_level.unwrap_or(0)
    }

    pub fn clear_ability_level(&mut self) {
        self.ability_level = ::std::option::Option::None;
    }

    pub fn has_ability_level(&self) -> bool {
        self.ability_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_level(&mut self, v: u32) {
        self.ability_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_AbilitySteal| { &m.player_id },
            |m: &mut CDOTAUserMsg_AbilitySteal| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &CDOTAUserMsg_AbilitySteal| { &m.ability_id },
            |m: &mut CDOTAUserMsg_AbilitySteal| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_level",
            |m: &CDOTAUserMsg_AbilitySteal| { &m.ability_level },
            |m: &mut CDOTAUserMsg_AbilitySteal| { &mut m.ability_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_AbilitySteal>(
            "CDOTAUserMsg_AbilitySteal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AbilitySteal {
    const NAME: &'static str = "CDOTAUserMsg_AbilitySteal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ability_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ability_level {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ability_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AbilitySteal {
        CDOTAUserMsg_AbilitySteal::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.ability_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AbilitySteal {
        static instance: CDOTAUserMsg_AbilitySteal = CDOTAUserMsg_AbilitySteal {
            player_id: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            ability_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_AbilitySteal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_AbilitySteal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_AbilitySteal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AbilitySteal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsHeroLookup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsHeroLookup {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroLookup.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroLookup.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroLookup.hero_name)
    pub hero_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroLookup.persona)
    pub persona: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsHeroLookup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsHeroLookup {
    fn default() -> &'a CDOTAUserMsg_StatsHeroLookup {
        <CDOTAUserMsg_StatsHeroLookup as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsHeroLookup {
    pub fn new() -> CDOTAUserMsg_StatsHeroLookup {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional string hero_name = 3;

    pub fn hero_name(&self) -> &str {
        match self.hero_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hero_name(&mut self) {
        self.hero_name = ::std::option::Option::None;
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: ::std::string::String) {
        self.hero_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
        if self.hero_name.is_none() {
            self.hero_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hero_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_name(&mut self) -> ::std::string::String {
        self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string persona = 4;

    pub fn persona(&self) -> &str {
        match self.persona.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona(&mut self) {
        self.persona = ::std::option::Option::None;
    }

    pub fn has_persona(&self) -> bool {
        self.persona.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona(&mut self, v: ::std::string::String) {
        self.persona = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona(&mut self) -> &mut ::std::string::String {
        if self.persona.is_none() {
            self.persona = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona(&mut self) -> ::std::string::String {
        self.persona.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_StatsHeroLookup| { &m.player_id },
            |m: &mut CDOTAUserMsg_StatsHeroLookup| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CDOTAUserMsg_StatsHeroLookup| { &m.hero_id },
            |m: &mut CDOTAUserMsg_StatsHeroLookup| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_name",
            |m: &CDOTAUserMsg_StatsHeroLookup| { &m.hero_name },
            |m: &mut CDOTAUserMsg_StatsHeroLookup| { &mut m.hero_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona",
            |m: &CDOTAUserMsg_StatsHeroLookup| { &m.persona },
            |m: &mut CDOTAUserMsg_StatsHeroLookup| { &mut m.persona },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_StatsHeroLookup>(
            "CDOTAUserMsg_StatsHeroLookup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsHeroLookup {
    const NAME: &'static str = "CDOTAUserMsg_StatsHeroLookup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.hero_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.persona = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.hero_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.persona.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.hero_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.persona.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsHeroLookup {
        CDOTAUserMsg_StatsHeroLookup::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.hero_name = ::std::option::Option::None;
        self.persona = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsHeroLookup {
        static instance: CDOTAUserMsg_StatsHeroLookup = CDOTAUserMsg_StatsHeroLookup {
            player_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            hero_name: ::std::option::Option::None,
            persona: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_StatsHeroLookup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsHeroLookup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_StatsHeroLookup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsHeroLookup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsHeroPositionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsHeroPositionInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroPositionInfo.average_position)
    pub average_position: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroPositionInfo.position_details)
    pub position_details: ::std::vec::Vec<cdotauser_msg_stats_hero_position_info::PositionPair>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsHeroPositionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsHeroPositionInfo {
    fn default() -> &'a CDOTAUserMsg_StatsHeroPositionInfo {
        <CDOTAUserMsg_StatsHeroPositionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsHeroPositionInfo {
    pub fn new() -> CDOTAUserMsg_StatsHeroPositionInfo {
        ::std::default::Default::default()
    }

    // optional float average_position = 1;

    pub fn average_position(&self) -> f32 {
        self.average_position.unwrap_or(0.)
    }

    pub fn clear_average_position(&mut self) {
        self.average_position = ::std::option::Option::None;
    }

    pub fn has_average_position(&self) -> bool {
        self.average_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_position(&mut self, v: f32) {
        self.average_position = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_position",
            |m: &CDOTAUserMsg_StatsHeroPositionInfo| { &m.average_position },
            |m: &mut CDOTAUserMsg_StatsHeroPositionInfo| { &mut m.average_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "position_details",
            |m: &CDOTAUserMsg_StatsHeroPositionInfo| { &m.position_details },
            |m: &mut CDOTAUserMsg_StatsHeroPositionInfo| { &mut m.position_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_StatsHeroPositionInfo>(
            "CDOTAUserMsg_StatsHeroPositionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsHeroPositionInfo {
    const NAME: &'static str = "CDOTAUserMsg_StatsHeroPositionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.average_position = ::std::option::Option::Some(is.read_float()?);
                },
                18 => {
                    self.position_details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.average_position {
            my_size += 1 + 4;
        }
        for value in &self.position_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.average_position {
            os.write_float(1, v)?;
        }
        for v in &self.position_details {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsHeroPositionInfo {
        CDOTAUserMsg_StatsHeroPositionInfo::new()
    }

    fn clear(&mut self) {
        self.average_position = ::std::option::Option::None;
        self.position_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsHeroPositionInfo {
        static instance: CDOTAUserMsg_StatsHeroPositionInfo = CDOTAUserMsg_StatsHeroPositionInfo {
            average_position: ::std::option::Option::None,
            position_details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_StatsHeroPositionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsHeroPositionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_StatsHeroPositionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsHeroPositionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_StatsHeroPositionInfo`
pub mod cdotauser_msg_stats_hero_position_info {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PositionPair {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.position_category)
        pub position_category: ::std::option::Option<::protobuf::EnumOrUnknown<super::DOTA_POSITION_CATEGORY>>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.position_count)
        pub position_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PositionPair {
        fn default() -> &'a PositionPair {
            <PositionPair as ::protobuf::Message>::default_instance()
        }
    }

    impl PositionPair {
        pub fn new() -> PositionPair {
            ::std::default::Default::default()
        }

        // optional .dota.DOTA_POSITION_CATEGORY position_category = 1;

        pub fn position_category(&self) -> super::DOTA_POSITION_CATEGORY {
            match self.position_category {
                Some(e) => e.enum_value_or(super::DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE),
                None => super::DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE,
            }
        }

        pub fn clear_position_category(&mut self) {
            self.position_category = ::std::option::Option::None;
        }

        pub fn has_position_category(&self) -> bool {
            self.position_category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position_category(&mut self, v: super::DOTA_POSITION_CATEGORY) {
            self.position_category = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 position_count = 2;

        pub fn position_count(&self) -> u32 {
            self.position_count.unwrap_or(0)
        }

        pub fn clear_position_count(&mut self) {
            self.position_count = ::std::option::Option::None;
        }

        pub fn has_position_count(&self) -> bool {
            self.position_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position_count(&mut self, v: u32) {
            self.position_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "position_category",
                |m: &PositionPair| { &m.position_category },
                |m: &mut PositionPair| { &mut m.position_category },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "position_count",
                |m: &PositionPair| { &m.position_count },
                |m: &mut PositionPair| { &mut m.position_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PositionPair>(
                "CDOTAUserMsg_StatsHeroPositionInfo.PositionPair",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PositionPair {
        const NAME: &'static str = "PositionPair";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.position_category = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.position_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.position_category {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.position_count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.position_category {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.position_count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PositionPair {
            PositionPair::new()
        }

        fn clear(&mut self) {
            self.position_category = ::std::option::Option::None;
            self.position_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PositionPair {
            static instance: PositionPair = PositionPair {
                position_category: ::std::option::Option::None,
                position_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PositionPair {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsHeroPositionInfo.PositionPair").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PositionPair {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PositionPair {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsHeroMinuteDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsHeroMinuteDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.hero_kills)
    pub hero_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.hero_damage)
    pub hero_damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.tower_damage)
    pub tower_damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.position_info)
    pub position_info: ::protobuf::MessageField<CDOTAUserMsg_StatsHeroPositionInfo>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.total_xp)
    pub total_xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.net_worth)
    pub net_worth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.harvested_creep_gold)
    pub harvested_creep_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.claimed_farm)
    pub claimed_farm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.wards_placed)
    pub wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.runes_collected)
    pub runes_collected: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.tps_used)
    pub tps_used: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.mana_spent)
    pub mana_spent: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.damage_absorbed)
    pub damage_absorbed: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.damage_done)
    pub damage_done: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsHeroMinuteDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsHeroMinuteDetails {
    fn default() -> &'a CDOTAUserMsg_StatsHeroMinuteDetails {
        <CDOTAUserMsg_StatsHeroMinuteDetails as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsHeroMinuteDetails {
    pub fn new() -> CDOTAUserMsg_StatsHeroMinuteDetails {
        ::std::default::Default::default()
    }

    // optional uint32 last_hits = 1;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_kills = 2;

    pub fn hero_kills(&self) -> u32 {
        self.hero_kills.unwrap_or(0)
    }

    pub fn clear_hero_kills(&mut self) {
        self.hero_kills = ::std::option::Option::None;
    }

    pub fn has_hero_kills(&self) -> bool {
        self.hero_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_kills(&mut self, v: u32) {
        self.hero_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_damage = 3;

    pub fn hero_damage(&self) -> u32 {
        self.hero_damage.unwrap_or(0)
    }

    pub fn clear_hero_damage(&mut self) {
        self.hero_damage = ::std::option::Option::None;
    }

    pub fn has_hero_damage(&self) -> bool {
        self.hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_damage(&mut self, v: u32) {
        self.hero_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 tower_damage = 4;

    pub fn tower_damage(&self) -> u32 {
        self.tower_damage.unwrap_or(0)
    }

    pub fn clear_tower_damage(&mut self) {
        self.tower_damage = ::std::option::Option::None;
    }

    pub fn has_tower_damage(&self) -> bool {
        self.tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_damage(&mut self, v: u32) {
        self.tower_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 total_xp = 6;

    pub fn total_xp(&self) -> u32 {
        self.total_xp.unwrap_or(0)
    }

    pub fn clear_total_xp(&mut self) {
        self.total_xp = ::std::option::Option::None;
    }

    pub fn has_total_xp(&self) -> bool {
        self.total_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_xp(&mut self, v: u32) {
        self.total_xp = ::std::option::Option::Some(v);
    }

    // optional uint32 net_worth = 7;

    pub fn net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional uint32 harvested_creep_gold = 8;

    pub fn harvested_creep_gold(&self) -> u32 {
        self.harvested_creep_gold.unwrap_or(0)
    }

    pub fn clear_harvested_creep_gold(&mut self) {
        self.harvested_creep_gold = ::std::option::Option::None;
    }

    pub fn has_harvested_creep_gold(&self) -> bool {
        self.harvested_creep_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_harvested_creep_gold(&mut self, v: u32) {
        self.harvested_creep_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 claimed_farm = 9;

    pub fn claimed_farm(&self) -> u32 {
        self.claimed_farm.unwrap_or(0)
    }

    pub fn clear_claimed_farm(&mut self) {
        self.claimed_farm = ::std::option::Option::None;
    }

    pub fn has_claimed_farm(&self) -> bool {
        self.claimed_farm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimed_farm(&mut self, v: u32) {
        self.claimed_farm = ::std::option::Option::Some(v);
    }

    // optional uint32 wards_placed = 10;

    pub fn wards_placed(&self) -> u32 {
        self.wards_placed.unwrap_or(0)
    }

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: u32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 runes_collected = 11;

    pub fn runes_collected(&self) -> u32 {
        self.runes_collected.unwrap_or(0)
    }

    pub fn clear_runes_collected(&mut self) {
        self.runes_collected = ::std::option::Option::None;
    }

    pub fn has_runes_collected(&self) -> bool {
        self.runes_collected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runes_collected(&mut self, v: u32) {
        self.runes_collected = ::std::option::Option::Some(v);
    }

    // optional uint32 tps_used = 12;

    pub fn tps_used(&self) -> u32 {
        self.tps_used.unwrap_or(0)
    }

    pub fn clear_tps_used(&mut self) {
        self.tps_used = ::std::option::Option::None;
    }

    pub fn has_tps_used(&self) -> bool {
        self.tps_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tps_used(&mut self, v: u32) {
        self.tps_used = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_hits",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.last_hits },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.last_hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_kills",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.hero_kills },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.hero_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_damage",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.hero_damage },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.hero_damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tower_damage",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.tower_damage },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.tower_damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDOTAUserMsg_StatsHeroPositionInfo>(
            "position_info",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.position_info },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.position_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_xp",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.total_xp },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.total_xp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_worth",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.net_worth },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.net_worth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "harvested_creep_gold",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.harvested_creep_gold },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.harvested_creep_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "claimed_farm",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.claimed_farm },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.claimed_farm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wards_placed",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.wards_placed },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.wards_placed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runes_collected",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.runes_collected },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.runes_collected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tps_used",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.tps_used },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.tps_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mana_spent",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.mana_spent },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.mana_spent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "damage_absorbed",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.damage_absorbed },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.damage_absorbed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "damage_done",
            |m: &CDOTAUserMsg_StatsHeroMinuteDetails| { &m.damage_done },
            |m: &mut CDOTAUserMsg_StatsHeroMinuteDetails| { &mut m.damage_done },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_StatsHeroMinuteDetails>(
            "CDOTAUserMsg_StatsHeroMinuteDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsHeroMinuteDetails {
    const NAME: &'static str = "CDOTAUserMsg_StatsHeroMinuteDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position_info)?;
                },
                48 => {
                    self.total_xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.harvested_creep_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.claimed_farm = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.runes_collected = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.tps_used = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    is.read_repeated_packed_uint32_into(&mut self.mana_spent)?;
                },
                104 => {
                    self.mana_spent.push(is.read_uint32()?);
                },
                114 => {
                    is.read_repeated_packed_uint32_into(&mut self.damage_absorbed)?;
                },
                112 => {
                    self.damage_absorbed.push(is.read_uint32()?);
                },
                122 => {
                    is.read_repeated_packed_uint32_into(&mut self.damage_done)?;
                },
                120 => {
                    self.damage_done.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_kills {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_damage {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tower_damage {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.position_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_xp {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.net_worth {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.harvested_creep_gold {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.claimed_farm {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.wards_placed {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.runes_collected {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.tps_used {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        for value in &self.mana_spent {
            my_size += ::protobuf::rt::uint32_size(13, *value);
        };
        for value in &self.damage_absorbed {
            my_size += ::protobuf::rt::uint32_size(14, *value);
        };
        for value in &self.damage_done {
            my_size += ::protobuf::rt::uint32_size(15, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.last_hits {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_damage {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tower_damage {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.position_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.total_xp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.harvested_creep_gold {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.claimed_farm {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.runes_collected {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.tps_used {
            os.write_uint32(12, v)?;
        }
        for v in &self.mana_spent {
            os.write_uint32(13, *v)?;
        };
        for v in &self.damage_absorbed {
            os.write_uint32(14, *v)?;
        };
        for v in &self.damage_done {
            os.write_uint32(15, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsHeroMinuteDetails {
        CDOTAUserMsg_StatsHeroMinuteDetails::new()
    }

    fn clear(&mut self) {
        self.last_hits = ::std::option::Option::None;
        self.hero_kills = ::std::option::Option::None;
        self.hero_damage = ::std::option::Option::None;
        self.tower_damage = ::std::option::Option::None;
        self.position_info.clear();
        self.total_xp = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.harvested_creep_gold = ::std::option::Option::None;
        self.claimed_farm = ::std::option::Option::None;
        self.wards_placed = ::std::option::Option::None;
        self.runes_collected = ::std::option::Option::None;
        self.tps_used = ::std::option::Option::None;
        self.mana_spent.clear();
        self.damage_absorbed.clear();
        self.damage_done.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsHeroMinuteDetails {
        static instance: CDOTAUserMsg_StatsHeroMinuteDetails = CDOTAUserMsg_StatsHeroMinuteDetails {
            last_hits: ::std::option::Option::None,
            hero_kills: ::std::option::Option::None,
            hero_damage: ::std::option::Option::None,
            tower_damage: ::std::option::Option::None,
            position_info: ::protobuf::MessageField::none(),
            total_xp: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            harvested_creep_gold: ::std::option::Option::None,
            claimed_farm: ::std::option::Option::None,
            wards_placed: ::std::option::Option::None,
            runes_collected: ::std::option::Option::None,
            tps_used: ::std::option::Option::None,
            mana_spent: ::std::vec::Vec::new(),
            damage_absorbed: ::std::vec::Vec::new(),
            damage_done: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_StatsHeroMinuteDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsHeroMinuteDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_StatsHeroMinuteDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsHeroMinuteDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsTeamMinuteDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsTeamMinuteDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.player_stats)
    pub player_stats: ::std::vec::Vec<CDOTAUserMsg_StatsHeroMinuteDetails>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.tower_kills)
    pub tower_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.barrack_kills)
    pub barrack_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.available_lane_creep_gold)
    pub available_lane_creep_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.balance_kill_value)
    pub balance_kill_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.balance_tower_value)
    pub balance_tower_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.balance_barracks_value)
    pub balance_barracks_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.balance_gold_value)
    pub balance_gold_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.balance_xp_value)
    pub balance_xp_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.lane_performance)
    pub lane_performance: ::std::vec::Vec<cdotauser_msg_stats_team_minute_details::LocationPerformance>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsTeamMinuteDetails {
    fn default() -> &'a CDOTAUserMsg_StatsTeamMinuteDetails {
        <CDOTAUserMsg_StatsTeamMinuteDetails as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsTeamMinuteDetails {
    pub fn new() -> CDOTAUserMsg_StatsTeamMinuteDetails {
        ::std::default::Default::default()
    }

    // optional uint32 tower_kills = 2;

    pub fn tower_kills(&self) -> u32 {
        self.tower_kills.unwrap_or(0)
    }

    pub fn clear_tower_kills(&mut self) {
        self.tower_kills = ::std::option::Option::None;
    }

    pub fn has_tower_kills(&self) -> bool {
        self.tower_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_kills(&mut self, v: u32) {
        self.tower_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 barrack_kills = 3;

    pub fn barrack_kills(&self) -> u32 {
        self.barrack_kills.unwrap_or(0)
    }

    pub fn clear_barrack_kills(&mut self) {
        self.barrack_kills = ::std::option::Option::None;
    }

    pub fn has_barrack_kills(&self) -> bool {
        self.barrack_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_barrack_kills(&mut self, v: u32) {
        self.barrack_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 available_lane_creep_gold = 4;

    pub fn available_lane_creep_gold(&self) -> u32 {
        self.available_lane_creep_gold.unwrap_or(0)
    }

    pub fn clear_available_lane_creep_gold(&mut self) {
        self.available_lane_creep_gold = ::std::option::Option::None;
    }

    pub fn has_available_lane_creep_gold(&self) -> bool {
        self.available_lane_creep_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_lane_creep_gold(&mut self, v: u32) {
        self.available_lane_creep_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_kill_value = 5;

    pub fn balance_kill_value(&self) -> u32 {
        self.balance_kill_value.unwrap_or(0)
    }

    pub fn clear_balance_kill_value(&mut self) {
        self.balance_kill_value = ::std::option::Option::None;
    }

    pub fn has_balance_kill_value(&self) -> bool {
        self.balance_kill_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_kill_value(&mut self, v: u32) {
        self.balance_kill_value = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_tower_value = 6;

    pub fn balance_tower_value(&self) -> u32 {
        self.balance_tower_value.unwrap_or(0)
    }

    pub fn clear_balance_tower_value(&mut self) {
        self.balance_tower_value = ::std::option::Option::None;
    }

    pub fn has_balance_tower_value(&self) -> bool {
        self.balance_tower_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_tower_value(&mut self, v: u32) {
        self.balance_tower_value = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_barracks_value = 7;

    pub fn balance_barracks_value(&self) -> u32 {
        self.balance_barracks_value.unwrap_or(0)
    }

    pub fn clear_balance_barracks_value(&mut self) {
        self.balance_barracks_value = ::std::option::Option::None;
    }

    pub fn has_balance_barracks_value(&self) -> bool {
        self.balance_barracks_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_barracks_value(&mut self, v: u32) {
        self.balance_barracks_value = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_gold_value = 8;

    pub fn balance_gold_value(&self) -> u32 {
        self.balance_gold_value.unwrap_or(0)
    }

    pub fn clear_balance_gold_value(&mut self) {
        self.balance_gold_value = ::std::option::Option::None;
    }

    pub fn has_balance_gold_value(&self) -> bool {
        self.balance_gold_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_gold_value(&mut self, v: u32) {
        self.balance_gold_value = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_xp_value = 9;

    pub fn balance_xp_value(&self) -> u32 {
        self.balance_xp_value.unwrap_or(0)
    }

    pub fn clear_balance_xp_value(&mut self) {
        self.balance_xp_value = ::std::option::Option::None;
    }

    pub fn has_balance_xp_value(&self) -> bool {
        self.balance_xp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_xp_value(&mut self, v: u32) {
        self.balance_xp_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_stats",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.player_stats },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.player_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tower_kills",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.tower_kills },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.tower_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "barrack_kills",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.barrack_kills },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.barrack_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "available_lane_creep_gold",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.available_lane_creep_gold },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.available_lane_creep_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_kill_value",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.balance_kill_value },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.balance_kill_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_tower_value",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.balance_tower_value },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.balance_tower_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_barracks_value",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.balance_barracks_value },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.balance_barracks_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_gold_value",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.balance_gold_value },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.balance_gold_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_xp_value",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.balance_xp_value },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.balance_xp_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lane_performance",
            |m: &CDOTAUserMsg_StatsTeamMinuteDetails| { &m.lane_performance },
            |m: &mut CDOTAUserMsg_StatsTeamMinuteDetails| { &mut m.lane_performance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_StatsTeamMinuteDetails>(
            "CDOTAUserMsg_StatsTeamMinuteDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsTeamMinuteDetails {
    const NAME: &'static str = "CDOTAUserMsg_StatsTeamMinuteDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_stats.push(is.read_message()?);
                },
                16 => {
                    self.tower_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.barrack_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.available_lane_creep_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.balance_kill_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.balance_tower_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.balance_barracks_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.balance_gold_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.balance_xp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.lane_performance.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tower_kills {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.barrack_kills {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.available_lane_creep_gold {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.balance_kill_value {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.balance_tower_value {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.balance_barracks_value {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.balance_gold_value {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.balance_xp_value {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.lane_performance {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_stats {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.tower_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.barrack_kills {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.available_lane_creep_gold {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.balance_kill_value {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.balance_tower_value {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.balance_barracks_value {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.balance_gold_value {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.balance_xp_value {
            os.write_uint32(9, v)?;
        }
        for v in &self.lane_performance {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsTeamMinuteDetails {
        CDOTAUserMsg_StatsTeamMinuteDetails::new()
    }

    fn clear(&mut self) {
        self.player_stats.clear();
        self.tower_kills = ::std::option::Option::None;
        self.barrack_kills = ::std::option::Option::None;
        self.available_lane_creep_gold = ::std::option::Option::None;
        self.balance_kill_value = ::std::option::Option::None;
        self.balance_tower_value = ::std::option::Option::None;
        self.balance_barracks_value = ::std::option::Option::None;
        self.balance_gold_value = ::std::option::Option::None;
        self.balance_xp_value = ::std::option::Option::None;
        self.lane_performance.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsTeamMinuteDetails {
        static instance: CDOTAUserMsg_StatsTeamMinuteDetails = CDOTAUserMsg_StatsTeamMinuteDetails {
            player_stats: ::std::vec::Vec::new(),
            tower_kills: ::std::option::Option::None,
            barrack_kills: ::std::option::Option::None,
            available_lane_creep_gold: ::std::option::Option::None,
            balance_kill_value: ::std::option::Option::None,
            balance_tower_value: ::std::option::Option::None,
            balance_barracks_value: ::std::option::Option::None,
            balance_gold_value: ::std::option::Option::None,
            balance_xp_value: ::std::option::Option::None,
            lane_performance: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_StatsTeamMinuteDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsTeamMinuteDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_StatsTeamMinuteDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsTeamMinuteDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_StatsTeamMinuteDetails`
pub mod cdotauser_msg_stats_team_minute_details {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LocationPerformance {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.location_category)
        pub location_category: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.stat_type)
        pub stat_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.value)
        pub value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LocationPerformance {
        fn default() -> &'a LocationPerformance {
            <LocationPerformance as ::protobuf::Message>::default_instance()
        }
    }

    impl LocationPerformance {
        pub fn new() -> LocationPerformance {
            ::std::default::Default::default()
        }

        // optional uint32 location_category = 1;

        pub fn location_category(&self) -> u32 {
            self.location_category.unwrap_or(0)
        }

        pub fn clear_location_category(&mut self) {
            self.location_category = ::std::option::Option::None;
        }

        pub fn has_location_category(&self) -> bool {
            self.location_category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_location_category(&mut self, v: u32) {
            self.location_category = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_type = 2;

        pub fn stat_type(&self) -> u32 {
            self.stat_type.unwrap_or(0)
        }

        pub fn clear_stat_type(&mut self) {
            self.stat_type = ::std::option::Option::None;
        }

        pub fn has_stat_type(&self) -> bool {
            self.stat_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_type(&mut self, v: u32) {
            self.stat_type = ::std::option::Option::Some(v);
        }

        // optional uint32 value = 3;

        pub fn value(&self) -> u32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u32) {
            self.value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "location_category",
                |m: &LocationPerformance| { &m.location_category },
                |m: &mut LocationPerformance| { &mut m.location_category },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_type",
                |m: &LocationPerformance| { &m.stat_type },
                |m: &mut LocationPerformance| { &mut m.stat_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &LocationPerformance| { &m.value },
                |m: &mut LocationPerformance| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocationPerformance>(
                "CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LocationPerformance {
        const NAME: &'static str = "LocationPerformance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.location_category = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stat_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.location_category {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stat_type {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.location_category {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_type {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LocationPerformance {
            LocationPerformance::new()
        }

        fn clear(&mut self) {
            self.location_category = ::std::option::Option::None;
            self.stat_type = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LocationPerformance {
            static instance: LocationPerformance = LocationPerformance {
                location_category: ::std::option::Option::None,
                stat_type: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LocationPerformance {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LocationPerformance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LocationPerformance {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsPlayerKillShare)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsPlayerKillShare {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsPlayerKillShare.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsPlayerKillShare.kill_share_percent)
    pub kill_share_percent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsPlayerKillShare.player_loc_x)
    pub player_loc_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsPlayerKillShare.player_loc_y)
    pub player_loc_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsPlayerKillShare.health_percent)
    pub health_percent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsPlayerKillShare.mana_percent)
    pub mana_percent: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsPlayerKillShare.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsPlayerKillShare {
    fn default() -> &'a CDOTAUserMsg_StatsPlayerKillShare {
        <CDOTAUserMsg_StatsPlayerKillShare as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsPlayerKillShare {
    pub fn new() -> CDOTAUserMsg_StatsPlayerKillShare {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float kill_share_percent = 2;

    pub fn kill_share_percent(&self) -> f32 {
        self.kill_share_percent.unwrap_or(0.)
    }

    pub fn clear_kill_share_percent(&mut self) {
        self.kill_share_percent = ::std::option::Option::None;
    }

    pub fn has_kill_share_percent(&self) -> bool {
        self.kill_share_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_share_percent(&mut self, v: f32) {
        self.kill_share_percent = ::std::option::Option::Some(v);
    }

    // optional float player_loc_x = 3;

    pub fn player_loc_x(&self) -> f32 {
        self.player_loc_x.unwrap_or(0.)
    }

    pub fn clear_player_loc_x(&mut self) {
        self.player_loc_x = ::std::option::Option::None;
    }

    pub fn has_player_loc_x(&self) -> bool {
        self.player_loc_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_loc_x(&mut self, v: f32) {
        self.player_loc_x = ::std::option::Option::Some(v);
    }

    // optional float player_loc_y = 4;

    pub fn player_loc_y(&self) -> f32 {
        self.player_loc_y.unwrap_or(0.)
    }

    pub fn clear_player_loc_y(&mut self) {
        self.player_loc_y = ::std::option::Option::None;
    }

    pub fn has_player_loc_y(&self) -> bool {
        self.player_loc_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_loc_y(&mut self, v: f32) {
        self.player_loc_y = ::std::option::Option::Some(v);
    }

    // optional float health_percent = 5;

    pub fn health_percent(&self) -> f32 {
        self.health_percent.unwrap_or(0.)
    }

    pub fn clear_health_percent(&mut self) {
        self.health_percent = ::std::option::Option::None;
    }

    pub fn has_health_percent(&self) -> bool {
        self.health_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_percent(&mut self, v: f32) {
        self.health_percent = ::std::option::Option::Some(v);
    }

    // optional float mana_percent = 6;

    pub fn mana_percent(&self) -> f32 {
        self.mana_percent.unwrap_or(0.)
    }

    pub fn clear_mana_percent(&mut self) {
        self.mana_percent = ::std::option::Option::None;
    }

    pub fn has_mana_percent(&self) -> bool {
        self.mana_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mana_percent(&mut self, v: f32) {
        self.mana_percent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_StatsPlayerKillShare| { &m.player_id },
            |m: &mut CDOTAUserMsg_StatsPlayerKillShare| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kill_share_percent",
            |m: &CDOTAUserMsg_StatsPlayerKillShare| { &m.kill_share_percent },
            |m: &mut CDOTAUserMsg_StatsPlayerKillShare| { &mut m.kill_share_percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_loc_x",
            |m: &CDOTAUserMsg_StatsPlayerKillShare| { &m.player_loc_x },
            |m: &mut CDOTAUserMsg_StatsPlayerKillShare| { &mut m.player_loc_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_loc_y",
            |m: &CDOTAUserMsg_StatsPlayerKillShare| { &m.player_loc_y },
            |m: &mut CDOTAUserMsg_StatsPlayerKillShare| { &mut m.player_loc_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health_percent",
            |m: &CDOTAUserMsg_StatsPlayerKillShare| { &m.health_percent },
            |m: &mut CDOTAUserMsg_StatsPlayerKillShare| { &mut m.health_percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mana_percent",
            |m: &CDOTAUserMsg_StatsPlayerKillShare| { &m.mana_percent },
            |m: &mut CDOTAUserMsg_StatsPlayerKillShare| { &mut m.mana_percent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_StatsPlayerKillShare>(
            "CDOTAUserMsg_StatsPlayerKillShare",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsPlayerKillShare {
    const NAME: &'static str = "CDOTAUserMsg_StatsPlayerKillShare";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.kill_share_percent = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.player_loc_x = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.player_loc_y = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.health_percent = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.mana_percent = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.kill_share_percent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.player_loc_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.player_loc_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.health_percent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.mana_percent {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.kill_share_percent {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.player_loc_x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.player_loc_y {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.health_percent {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.mana_percent {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsPlayerKillShare {
        CDOTAUserMsg_StatsPlayerKillShare::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.kill_share_percent = ::std::option::Option::None;
        self.player_loc_x = ::std::option::Option::None;
        self.player_loc_y = ::std::option::Option::None;
        self.health_percent = ::std::option::Option::None;
        self.mana_percent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsPlayerKillShare {
        static instance: CDOTAUserMsg_StatsPlayerKillShare = CDOTAUserMsg_StatsPlayerKillShare {
            player_id: ::std::option::Option::None,
            kill_share_percent: ::std::option::Option::None,
            player_loc_x: ::std::option::Option::None,
            player_loc_y: ::std::option::Option::None,
            health_percent: ::std::option::Option::None,
            mana_percent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_StatsPlayerKillShare {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsPlayerKillShare").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_StatsPlayerKillShare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsPlayerKillShare {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsKillDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsKillDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsKillDetails.victim_id)
    pub victim_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsKillDetails.kill_shares)
    pub kill_shares: ::std::vec::Vec<CDOTAUserMsg_StatsPlayerKillShare>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsKillDetails.damage_to_kill)
    pub damage_to_kill: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsKillDetails.effective_health)
    pub effective_health: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsKillDetails.death_time)
    pub death_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsKillDetails.killer_id)
    pub killer_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsKillDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsKillDetails {
    fn default() -> &'a CDOTAUserMsg_StatsKillDetails {
        <CDOTAUserMsg_StatsKillDetails as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsKillDetails {
    pub fn new() -> CDOTAUserMsg_StatsKillDetails {
        ::std::default::Default::default()
    }

    // optional int32 victim_id = 1;

    pub fn victim_id(&self) -> i32 {
        self.victim_id.unwrap_or(0)
    }

    pub fn clear_victim_id(&mut self) {
        self.victim_id = ::std::option::Option::None;
    }

    pub fn has_victim_id(&self) -> bool {
        self.victim_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_id(&mut self, v: i32) {
        self.victim_id = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_to_kill = 3;

    pub fn damage_to_kill(&self) -> u32 {
        self.damage_to_kill.unwrap_or(0)
    }

    pub fn clear_damage_to_kill(&mut self) {
        self.damage_to_kill = ::std::option::Option::None;
    }

    pub fn has_damage_to_kill(&self) -> bool {
        self.damage_to_kill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_to_kill(&mut self, v: u32) {
        self.damage_to_kill = ::std::option::Option::Some(v);
    }

    // optional uint32 effective_health = 4;

    pub fn effective_health(&self) -> u32 {
        self.effective_health.unwrap_or(0)
    }

    pub fn clear_effective_health(&mut self) {
        self.effective_health = ::std::option::Option::None;
    }

    pub fn has_effective_health(&self) -> bool {
        self.effective_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effective_health(&mut self, v: u32) {
        self.effective_health = ::std::option::Option::Some(v);
    }

    // optional float death_time = 5;

    pub fn death_time(&self) -> f32 {
        self.death_time.unwrap_or(0.)
    }

    pub fn clear_death_time(&mut self) {
        self.death_time = ::std::option::Option::None;
    }

    pub fn has_death_time(&self) -> bool {
        self.death_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_time(&mut self, v: f32) {
        self.death_time = ::std::option::Option::Some(v);
    }

    // optional int32 killer_id = 6;

    pub fn killer_id(&self) -> i32 {
        self.killer_id.unwrap_or(0)
    }

    pub fn clear_killer_id(&mut self) {
        self.killer_id = ::std::option::Option::None;
    }

    pub fn has_killer_id(&self) -> bool {
        self.killer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_id(&mut self, v: i32) {
        self.killer_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_id",
            |m: &CDOTAUserMsg_StatsKillDetails| { &m.victim_id },
            |m: &mut CDOTAUserMsg_StatsKillDetails| { &mut m.victim_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kill_shares",
            |m: &CDOTAUserMsg_StatsKillDetails| { &m.kill_shares },
            |m: &mut CDOTAUserMsg_StatsKillDetails| { &mut m.kill_shares },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_to_kill",
            |m: &CDOTAUserMsg_StatsKillDetails| { &m.damage_to_kill },
            |m: &mut CDOTAUserMsg_StatsKillDetails| { &mut m.damage_to_kill },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effective_health",
            |m: &CDOTAUserMsg_StatsKillDetails| { &m.effective_health },
            |m: &mut CDOTAUserMsg_StatsKillDetails| { &mut m.effective_health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "death_time",
            |m: &CDOTAUserMsg_StatsKillDetails| { &m.death_time },
            |m: &mut CDOTAUserMsg_StatsKillDetails| { &mut m.death_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killer_id",
            |m: &CDOTAUserMsg_StatsKillDetails| { &m.killer_id },
            |m: &mut CDOTAUserMsg_StatsKillDetails| { &mut m.killer_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_StatsKillDetails>(
            "CDOTAUserMsg_StatsKillDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsKillDetails {
    const NAME: &'static str = "CDOTAUserMsg_StatsKillDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.victim_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.kill_shares.push(is.read_message()?);
                },
                24 => {
                    self.damage_to_kill = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.effective_health = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.death_time = ::std::option::Option::Some(is.read_float()?);
                },
                48 => {
                    self.killer_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.victim_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.kill_shares {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.damage_to_kill {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.effective_health {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.death_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.killer_id {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.victim_id {
            os.write_int32(1, v)?;
        }
        for v in &self.kill_shares {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.damage_to_kill {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.effective_health {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.death_time {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.killer_id {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsKillDetails {
        CDOTAUserMsg_StatsKillDetails::new()
    }

    fn clear(&mut self) {
        self.victim_id = ::std::option::Option::None;
        self.kill_shares.clear();
        self.damage_to_kill = ::std::option::Option::None;
        self.effective_health = ::std::option::Option::None;
        self.death_time = ::std::option::Option::None;
        self.killer_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsKillDetails {
        static instance: CDOTAUserMsg_StatsKillDetails = CDOTAUserMsg_StatsKillDetails {
            victim_id: ::std::option::Option::None,
            kill_shares: ::std::vec::Vec::new(),
            damage_to_kill: ::std::option::Option::None,
            effective_health: ::std::option::Option::None,
            death_time: ::std::option::Option::None,
            killer_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_StatsKillDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsKillDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_StatsKillDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsKillDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsMatchDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsMatchDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.hero_lookup)
    pub hero_lookup: ::std::vec::Vec<CDOTAUserMsg_StatsHeroLookup>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.radiant_stats)
    pub radiant_stats: ::std::vec::Vec<CDOTAUserMsg_StatsTeamMinuteDetails>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.dire_stats)
    pub dire_stats: ::std::vec::Vec<CDOTAUserMsg_StatsTeamMinuteDetails>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.radiant_kills)
    pub radiant_kills: ::std::vec::Vec<CDOTAUserMsg_StatsKillDetails>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.dire_kills)
    pub dire_kills: ::std::vec::Vec<CDOTAUserMsg_StatsKillDetails>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.fight_details)
    pub fight_details: ::std::vec::Vec<cdotauser_msg_stats_match_details::CDOTAUserMsg_StatsFightDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsMatchDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsMatchDetails {
    fn default() -> &'a CDOTAUserMsg_StatsMatchDetails {
        <CDOTAUserMsg_StatsMatchDetails as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsMatchDetails {
    pub fn new() -> CDOTAUserMsg_StatsMatchDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hero_lookup",
            |m: &CDOTAUserMsg_StatsMatchDetails| { &m.hero_lookup },
            |m: &mut CDOTAUserMsg_StatsMatchDetails| { &mut m.hero_lookup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "radiant_stats",
            |m: &CDOTAUserMsg_StatsMatchDetails| { &m.radiant_stats },
            |m: &mut CDOTAUserMsg_StatsMatchDetails| { &mut m.radiant_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dire_stats",
            |m: &CDOTAUserMsg_StatsMatchDetails| { &m.dire_stats },
            |m: &mut CDOTAUserMsg_StatsMatchDetails| { &mut m.dire_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "radiant_kills",
            |m: &CDOTAUserMsg_StatsMatchDetails| { &m.radiant_kills },
            |m: &mut CDOTAUserMsg_StatsMatchDetails| { &mut m.radiant_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dire_kills",
            |m: &CDOTAUserMsg_StatsMatchDetails| { &m.dire_kills },
            |m: &mut CDOTAUserMsg_StatsMatchDetails| { &mut m.dire_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fight_details",
            |m: &CDOTAUserMsg_StatsMatchDetails| { &m.fight_details },
            |m: &mut CDOTAUserMsg_StatsMatchDetails| { &mut m.fight_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_StatsMatchDetails>(
            "CDOTAUserMsg_StatsMatchDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsMatchDetails {
    const NAME: &'static str = "CDOTAUserMsg_StatsMatchDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hero_lookup.push(is.read_message()?);
                },
                18 => {
                    self.radiant_stats.push(is.read_message()?);
                },
                26 => {
                    self.dire_stats.push(is.read_message()?);
                },
                34 => {
                    self.radiant_kills.push(is.read_message()?);
                },
                42 => {
                    self.dire_kills.push(is.read_message()?);
                },
                50 => {
                    self.fight_details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_lookup {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.radiant_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dire_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.radiant_kills {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dire_kills {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fight_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hero_lookup {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.radiant_stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.dire_stats {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.radiant_kills {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.dire_kills {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.fight_details {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsMatchDetails {
        CDOTAUserMsg_StatsMatchDetails::new()
    }

    fn clear(&mut self) {
        self.hero_lookup.clear();
        self.radiant_stats.clear();
        self.dire_stats.clear();
        self.radiant_kills.clear();
        self.dire_kills.clear();
        self.fight_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsMatchDetails {
        static instance: CDOTAUserMsg_StatsMatchDetails = CDOTAUserMsg_StatsMatchDetails {
            hero_lookup: ::std::vec::Vec::new(),
            radiant_stats: ::std::vec::Vec::new(),
            dire_stats: ::std::vec::Vec::new(),
            radiant_kills: ::std::vec::Vec::new(),
            dire_kills: ::std::vec::Vec::new(),
            fight_details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_StatsMatchDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsMatchDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_StatsMatchDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsMatchDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_StatsMatchDetails`
pub mod cdotauser_msg_stats_match_details {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CDOTAUserMsg_StatsFightTeamDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.participants)
        pub participants: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.deaths)
        pub deaths: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.gold_delta)
        pub gold_delta: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.xp_delta)
        pub xp_delta: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsFightTeamDetails {
        fn default() -> &'a CDOTAUserMsg_StatsFightTeamDetails {
            <CDOTAUserMsg_StatsFightTeamDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl CDOTAUserMsg_StatsFightTeamDetails {
        pub fn new() -> CDOTAUserMsg_StatsFightTeamDetails {
            ::std::default::Default::default()
        }

        // optional uint32 gold_delta = 3;

        pub fn gold_delta(&self) -> u32 {
            self.gold_delta.unwrap_or(0)
        }

        pub fn clear_gold_delta(&mut self) {
            self.gold_delta = ::std::option::Option::None;
        }

        pub fn has_gold_delta(&self) -> bool {
            self.gold_delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_delta(&mut self, v: u32) {
            self.gold_delta = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_delta = 4;

        pub fn xp_delta(&self) -> u32 {
            self.xp_delta.unwrap_or(0)
        }

        pub fn clear_xp_delta(&mut self) {
            self.xp_delta = ::std::option::Option::None;
        }

        pub fn has_xp_delta(&self) -> bool {
            self.xp_delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_delta(&mut self, v: u32) {
            self.xp_delta = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "participants",
                |m: &CDOTAUserMsg_StatsFightTeamDetails| { &m.participants },
                |m: &mut CDOTAUserMsg_StatsFightTeamDetails| { &mut m.participants },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "deaths",
                |m: &CDOTAUserMsg_StatsFightTeamDetails| { &m.deaths },
                |m: &mut CDOTAUserMsg_StatsFightTeamDetails| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gold_delta",
                |m: &CDOTAUserMsg_StatsFightTeamDetails| { &m.gold_delta },
                |m: &mut CDOTAUserMsg_StatsFightTeamDetails| { &mut m.gold_delta },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xp_delta",
                |m: &CDOTAUserMsg_StatsFightTeamDetails| { &m.xp_delta },
                |m: &mut CDOTAUserMsg_StatsFightTeamDetails| { &mut m.xp_delta },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_StatsFightTeamDetails>(
                "CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CDOTAUserMsg_StatsFightTeamDetails {
        const NAME: &'static str = "CDOTAUserMsg_StatsFightTeamDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.participants)?;
                    },
                    8 => {
                        self.participants.push(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_int32_into(&mut self.deaths)?;
                    },
                    16 => {
                        self.deaths.push(is.read_int32()?);
                    },
                    24 => {
                        self.gold_delta = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.xp_delta = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.participants {
                my_size += ::protobuf::rt::int32_size(1, *value);
            };
            for value in &self.deaths {
                my_size += ::protobuf::rt::int32_size(2, *value);
            };
            if let Some(v) = self.gold_delta {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.xp_delta {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.participants {
                os.write_int32(1, *v)?;
            };
            for v in &self.deaths {
                os.write_int32(2, *v)?;
            };
            if let Some(v) = self.gold_delta {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.xp_delta {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CDOTAUserMsg_StatsFightTeamDetails {
            CDOTAUserMsg_StatsFightTeamDetails::new()
        }

        fn clear(&mut self) {
            self.participants.clear();
            self.deaths.clear();
            self.gold_delta = ::std::option::Option::None;
            self.xp_delta = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CDOTAUserMsg_StatsFightTeamDetails {
            static instance: CDOTAUserMsg_StatsFightTeamDetails = CDOTAUserMsg_StatsFightTeamDetails {
                participants: ::std::vec::Vec::new(),
                deaths: ::std::vec::Vec::new(),
                gold_delta: ::std::option::Option::None,
                xp_delta: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CDOTAUserMsg_StatsFightTeamDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CDOTAUserMsg_StatsFightTeamDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsFightTeamDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CDOTAUserMsg_StatsFightDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.start_time)
        pub start_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.end_time)
        pub end_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.radiant_fight_details)
        pub radiant_fight_details: ::protobuf::MessageField<CDOTAUserMsg_StatsFightTeamDetails>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.dire_fight_details)
        pub dire_fight_details: ::protobuf::MessageField<CDOTAUserMsg_StatsFightTeamDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsFightDetails {
        fn default() -> &'a CDOTAUserMsg_StatsFightDetails {
            <CDOTAUserMsg_StatsFightDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl CDOTAUserMsg_StatsFightDetails {
        pub fn new() -> CDOTAUserMsg_StatsFightDetails {
            ::std::default::Default::default()
        }

        // optional float start_time = 1;

        pub fn start_time(&self) -> f32 {
            self.start_time.unwrap_or(0.)
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: f32) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // optional float end_time = 2;

        pub fn end_time(&self) -> f32 {
            self.end_time.unwrap_or(0.)
        }

        pub fn clear_end_time(&mut self) {
            self.end_time = ::std::option::Option::None;
        }

        pub fn has_end_time(&self) -> bool {
            self.end_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_time(&mut self, v: f32) {
            self.end_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_time",
                |m: &CDOTAUserMsg_StatsFightDetails| { &m.start_time },
                |m: &mut CDOTAUserMsg_StatsFightDetails| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "end_time",
                |m: &CDOTAUserMsg_StatsFightDetails| { &m.end_time },
                |m: &mut CDOTAUserMsg_StatsFightDetails| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDOTAUserMsg_StatsFightTeamDetails>(
                "radiant_fight_details",
                |m: &CDOTAUserMsg_StatsFightDetails| { &m.radiant_fight_details },
                |m: &mut CDOTAUserMsg_StatsFightDetails| { &mut m.radiant_fight_details },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDOTAUserMsg_StatsFightTeamDetails>(
                "dire_fight_details",
                |m: &CDOTAUserMsg_StatsFightDetails| { &m.dire_fight_details },
                |m: &mut CDOTAUserMsg_StatsFightDetails| { &mut m.dire_fight_details },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_StatsFightDetails>(
                "CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CDOTAUserMsg_StatsFightDetails {
        const NAME: &'static str = "CDOTAUserMsg_StatsFightDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.start_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.end_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.radiant_fight_details)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.dire_fight_details)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.end_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.radiant_fight_details.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.dire_fight_details.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.start_time {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.end_time {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.radiant_fight_details.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.dire_fight_details.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CDOTAUserMsg_StatsFightDetails {
            CDOTAUserMsg_StatsFightDetails::new()
        }

        fn clear(&mut self) {
            self.start_time = ::std::option::Option::None;
            self.end_time = ::std::option::Option::None;
            self.radiant_fight_details.clear();
            self.dire_fight_details.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CDOTAUserMsg_StatsFightDetails {
            static instance: CDOTAUserMsg_StatsFightDetails = CDOTAUserMsg_StatsFightDetails {
                start_time: ::std::option::Option::None,
                end_time: ::std::option::Option::None,
                radiant_fight_details: ::protobuf::MessageField::none(),
                dire_fight_details: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CDOTAUserMsg_StatsFightDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CDOTAUserMsg_StatsFightDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsFightDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_MiniTaunt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MiniTaunt {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MiniTaunt.taunting_player_id)
    pub taunting_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MiniTaunt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MiniTaunt {
    fn default() -> &'a CDOTAUserMsg_MiniTaunt {
        <CDOTAUserMsg_MiniTaunt as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MiniTaunt {
    pub fn new() -> CDOTAUserMsg_MiniTaunt {
        ::std::default::Default::default()
    }

    // optional int32 taunting_player_id = 1;

    pub fn taunting_player_id(&self) -> i32 {
        self.taunting_player_id.unwrap_or(0)
    }

    pub fn clear_taunting_player_id(&mut self) {
        self.taunting_player_id = ::std::option::Option::None;
    }

    pub fn has_taunting_player_id(&self) -> bool {
        self.taunting_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taunting_player_id(&mut self, v: i32) {
        self.taunting_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "taunting_player_id",
            |m: &CDOTAUserMsg_MiniTaunt| { &m.taunting_player_id },
            |m: &mut CDOTAUserMsg_MiniTaunt| { &mut m.taunting_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_MiniTaunt>(
            "CDOTAUserMsg_MiniTaunt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MiniTaunt {
    const NAME: &'static str = "CDOTAUserMsg_MiniTaunt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.taunting_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.taunting_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.taunting_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MiniTaunt {
        CDOTAUserMsg_MiniTaunt::new()
    }

    fn clear(&mut self) {
        self.taunting_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MiniTaunt {
        static instance: CDOTAUserMsg_MiniTaunt = CDOTAUserMsg_MiniTaunt {
            taunting_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_MiniTaunt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MiniTaunt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_MiniTaunt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MiniTaunt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SpeechBubble)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SpeechBubble {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SpeechBubble.destroy_all)
    pub destroy_all: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SpeechBubble.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SpeechBubble {
    fn default() -> &'a CDOTAUserMsg_SpeechBubble {
        <CDOTAUserMsg_SpeechBubble as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SpeechBubble {
    pub fn new() -> CDOTAUserMsg_SpeechBubble {
        ::std::default::Default::default()
    }

    // optional bool destroy_all = 1;

    pub fn destroy_all(&self) -> bool {
        self.destroy_all.unwrap_or(false)
    }

    pub fn clear_destroy_all(&mut self) {
        self.destroy_all = ::std::option::Option::None;
    }

    pub fn has_destroy_all(&self) -> bool {
        self.destroy_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_all(&mut self, v: bool) {
        self.destroy_all = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "destroy_all",
            |m: &CDOTAUserMsg_SpeechBubble| { &m.destroy_all },
            |m: &mut CDOTAUserMsg_SpeechBubble| { &mut m.destroy_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SpeechBubble>(
            "CDOTAUserMsg_SpeechBubble",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SpeechBubble {
    const NAME: &'static str = "CDOTAUserMsg_SpeechBubble";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.destroy_all = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.destroy_all {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.destroy_all {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SpeechBubble {
        CDOTAUserMsg_SpeechBubble::new()
    }

    fn clear(&mut self) {
        self.destroy_all = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SpeechBubble {
        static instance: CDOTAUserMsg_SpeechBubble = CDOTAUserMsg_SpeechBubble {
            destroy_all: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SpeechBubble {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SpeechBubble").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SpeechBubble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SpeechBubble {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CustomHeaderMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomHeaderMessage {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHeaderMessage.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHeaderMessage.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHeaderMessage.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHeaderMessage.value)
    pub value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CustomHeaderMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomHeaderMessage {
    fn default() -> &'a CDOTAUserMsg_CustomHeaderMessage {
        <CDOTAUserMsg_CustomHeaderMessage as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomHeaderMessage {
    pub fn new() -> CDOTAUserMsg_CustomHeaderMessage {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 value = 4;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_CustomHeaderMessage| { &m.player_id },
            |m: &mut CDOTAUserMsg_CustomHeaderMessage| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CDOTAUserMsg_CustomHeaderMessage| { &m.duration },
            |m: &mut CDOTAUserMsg_CustomHeaderMessage| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CDOTAUserMsg_CustomHeaderMessage| { &m.message },
            |m: &mut CDOTAUserMsg_CustomHeaderMessage| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CDOTAUserMsg_CustomHeaderMessage| { &m.value },
            |m: &mut CDOTAUserMsg_CustomHeaderMessage| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CustomHeaderMessage>(
            "CDOTAUserMsg_CustomHeaderMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomHeaderMessage {
    const NAME: &'static str = "CDOTAUserMsg_CustomHeaderMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomHeaderMessage {
        CDOTAUserMsg_CustomHeaderMessage::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomHeaderMessage {
        static instance: CDOTAUserMsg_CustomHeaderMessage = CDOTAUserMsg_CustomHeaderMessage {
            player_id: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            message: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CustomHeaderMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CustomHeaderMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CustomHeaderMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomHeaderMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgHeroAbilityStat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroAbilityStat {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgHeroAbilityStat.stat_type)
    pub stat_type: ::std::option::Option<::protobuf::EnumOrUnknown<EHeroStatType>>,
    // @@protoc_insertion_point(field:dota.CMsgHeroAbilityStat.int_value)
    pub int_value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgHeroAbilityStat.float_value)
    pub float_value: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgHeroAbilityStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroAbilityStat {
    fn default() -> &'a CMsgHeroAbilityStat {
        <CMsgHeroAbilityStat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroAbilityStat {
    pub fn new() -> CMsgHeroAbilityStat {
        ::std::default::Default::default()
    }

    // optional .dota.EHeroStatType stat_type = 1;

    pub fn stat_type(&self) -> EHeroStatType {
        match self.stat_type {
            Some(e) => e.enum_value_or(EHeroStatType::k_EHeroStatType_None),
            None => EHeroStatType::k_EHeroStatType_None,
        }
    }

    pub fn clear_stat_type(&mut self) {
        self.stat_type = ::std::option::Option::None;
    }

    pub fn has_stat_type(&self) -> bool {
        self.stat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_type(&mut self, v: EHeroStatType) {
        self.stat_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 int_value = 2;

    pub fn int_value(&self) -> i32 {
        self.int_value.unwrap_or(0)
    }

    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = ::std::option::Option::Some(v);
    }

    // optional float float_value = 3;

    pub fn float_value(&self) -> f32 {
        self.float_value.unwrap_or(0.)
    }

    pub fn clear_float_value(&mut self) {
        self.float_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        self.float_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stat_type",
            |m: &CMsgHeroAbilityStat| { &m.stat_type },
            |m: &mut CMsgHeroAbilityStat| { &mut m.stat_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_value",
            |m: &CMsgHeroAbilityStat| { &m.int_value },
            |m: &mut CMsgHeroAbilityStat| { &mut m.int_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "float_value",
            |m: &CMsgHeroAbilityStat| { &m.float_value },
            |m: &mut CMsgHeroAbilityStat| { &mut m.float_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHeroAbilityStat>(
            "CMsgHeroAbilityStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHeroAbilityStat {
    const NAME: &'static str = "CMsgHeroAbilityStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.int_value = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.float_value = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stat_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.int_value {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.float_value {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stat_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.int_value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.float_value {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroAbilityStat {
        CMsgHeroAbilityStat::new()
    }

    fn clear(&mut self) {
        self.stat_type = ::std::option::Option::None;
        self.int_value = ::std::option::Option::None;
        self.float_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroAbilityStat {
        static instance: CMsgHeroAbilityStat = CMsgHeroAbilityStat {
            stat_type: ::std::option::Option::None,
            int_value: ::std::option::Option::None,
            float_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHeroAbilityStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHeroAbilityStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHeroAbilityStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHeroAbilityStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCombatAnalyzerPlayerStat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCombatAnalyzerPlayerStat {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCombatAnalyzerPlayerStat.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgCombatAnalyzerPlayerStat.hero_ability_stats)
    pub hero_ability_stats: ::std::vec::Vec<CMsgHeroAbilityStat>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCombatAnalyzerPlayerStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCombatAnalyzerPlayerStat {
    fn default() -> &'a CMsgCombatAnalyzerPlayerStat {
        <CMsgCombatAnalyzerPlayerStat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCombatAnalyzerPlayerStat {
    pub fn new() -> CMsgCombatAnalyzerPlayerStat {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgCombatAnalyzerPlayerStat| { &m.account_id },
            |m: &mut CMsgCombatAnalyzerPlayerStat| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hero_ability_stats",
            |m: &CMsgCombatAnalyzerPlayerStat| { &m.hero_ability_stats },
            |m: &mut CMsgCombatAnalyzerPlayerStat| { &mut m.hero_ability_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCombatAnalyzerPlayerStat>(
            "CMsgCombatAnalyzerPlayerStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCombatAnalyzerPlayerStat {
    const NAME: &'static str = "CMsgCombatAnalyzerPlayerStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.hero_ability_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.hero_ability_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.hero_ability_stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCombatAnalyzerPlayerStat {
        CMsgCombatAnalyzerPlayerStat::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.hero_ability_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCombatAnalyzerPlayerStat {
        static instance: CMsgCombatAnalyzerPlayerStat = CMsgCombatAnalyzerPlayerStat {
            account_id: ::std::option::Option::None,
            hero_ability_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCombatAnalyzerPlayerStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCombatAnalyzerPlayerStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCombatAnalyzerPlayerStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCombatAnalyzerPlayerStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgCombatAnalyzerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCombatAnalyzerStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgCombatAnalyzerStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgCombatAnalyzerStats.player_stats)
    pub player_stats: ::std::vec::Vec<CMsgCombatAnalyzerPlayerStat>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgCombatAnalyzerStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCombatAnalyzerStats {
    fn default() -> &'a CMsgCombatAnalyzerStats {
        <CMsgCombatAnalyzerStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCombatAnalyzerStats {
    pub fn new() -> CMsgCombatAnalyzerStats {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgCombatAnalyzerStats| { &m.match_id },
            |m: &mut CMsgCombatAnalyzerStats| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_stats",
            |m: &CMsgCombatAnalyzerStats| { &m.player_stats },
            |m: &mut CMsgCombatAnalyzerStats| { &mut m.player_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCombatAnalyzerStats>(
            "CMsgCombatAnalyzerStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCombatAnalyzerStats {
    const NAME: &'static str = "CMsgCombatAnalyzerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.player_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.player_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.player_stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCombatAnalyzerStats {
        CMsgCombatAnalyzerStats::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.player_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCombatAnalyzerStats {
        static instance: CMsgCombatAnalyzerStats = CMsgCombatAnalyzerStats {
            match_id: ::std::option::Option::None,
            player_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCombatAnalyzerStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCombatAnalyzerStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCombatAnalyzerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCombatAnalyzerStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_BeastChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BeastChat {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BeastChat.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BeastChat.format)
    pub format: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BeastChat.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_BeastChat.target)
    pub target: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_BeastChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BeastChat {
    fn default() -> &'a CDOTAUserMsg_BeastChat {
        <CDOTAUserMsg_BeastChat as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BeastChat {
    pub fn new() -> CDOTAUserMsg_BeastChat {
        ::std::default::Default::default()
    }

    // optional uint32 team = 1;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional string format = 2;

    pub fn format(&self) -> &str {
        match self.format.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ::std::string::String) {
        self.format = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&mut self) -> &mut ::std::string::String {
        if self.format.is_none() {
            self.format = ::std::option::Option::Some(::std::string::String::new());
        }
        self.format.as_mut().unwrap()
    }

    // Take field
    pub fn take_format(&mut self) -> ::std::string::String {
        self.format.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string target = 4;

    pub fn target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CDOTAUserMsg_BeastChat| { &m.team },
            |m: &mut CDOTAUserMsg_BeastChat| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &CDOTAUserMsg_BeastChat| { &m.format },
            |m: &mut CDOTAUserMsg_BeastChat| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CDOTAUserMsg_BeastChat| { &m.message },
            |m: &mut CDOTAUserMsg_BeastChat| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target",
            |m: &CDOTAUserMsg_BeastChat| { &m.target },
            |m: &mut CDOTAUserMsg_BeastChat| { &mut m.target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_BeastChat>(
            "CDOTAUserMsg_BeastChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BeastChat {
    const NAME: &'static str = "CDOTAUserMsg_BeastChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.format = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.target = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.format.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.format.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.target.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BeastChat {
        CDOTAUserMsg_BeastChat::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BeastChat {
        static instance: CDOTAUserMsg_BeastChat = CDOTAUserMsg_BeastChat {
            team: ::std::option::Option::None,
            format: ::std::option::Option::None,
            message: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_BeastChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_BeastChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_BeastChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BeastChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CustomHudElement_Create)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomHudElement_Create {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHudElement_Create.element_id)
    pub element_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHudElement_Create.layout_filename)
    pub layout_filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHudElement_Create.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CustomHudElement_Create.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomHudElement_Create {
    fn default() -> &'a CDOTAUserMsg_CustomHudElement_Create {
        <CDOTAUserMsg_CustomHudElement_Create as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomHudElement_Create {
    pub fn new() -> CDOTAUserMsg_CustomHudElement_Create {
        ::std::default::Default::default()
    }

    // optional string element_id = 1;

    pub fn element_id(&self) -> &str {
        match self.element_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_element_id(&mut self) {
        self.element_id = ::std::option::Option::None;
    }

    pub fn has_element_id(&self) -> bool {
        self.element_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_id(&mut self, v: ::std::string::String) {
        self.element_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_id(&mut self) -> &mut ::std::string::String {
        if self.element_id.is_none() {
            self.element_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.element_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_id(&mut self) -> ::std::string::String {
        self.element_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string layout_filename = 2;

    pub fn layout_filename(&self) -> &str {
        match self.layout_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_layout_filename(&mut self) {
        self.layout_filename = ::std::option::Option::None;
    }

    pub fn has_layout_filename(&self) -> bool {
        self.layout_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout_filename(&mut self, v: ::std::string::String) {
        self.layout_filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout_filename(&mut self) -> &mut ::std::string::String {
        if self.layout_filename.is_none() {
            self.layout_filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.layout_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout_filename(&mut self) -> ::std::string::String {
        self.layout_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "element_id",
            |m: &CDOTAUserMsg_CustomHudElement_Create| { &m.element_id },
            |m: &mut CDOTAUserMsg_CustomHudElement_Create| { &mut m.element_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layout_filename",
            |m: &CDOTAUserMsg_CustomHudElement_Create| { &m.layout_filename },
            |m: &mut CDOTAUserMsg_CustomHudElement_Create| { &mut m.layout_filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDOTAUserMsg_CustomHudElement_Create| { &m.data },
            |m: &mut CDOTAUserMsg_CustomHudElement_Create| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CustomHudElement_Create>(
            "CDOTAUserMsg_CustomHudElement_Create",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomHudElement_Create {
    const NAME: &'static str = "CDOTAUserMsg_CustomHudElement_Create";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.element_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.layout_filename = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.element_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.layout_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.element_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.layout_filename.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomHudElement_Create {
        CDOTAUserMsg_CustomHudElement_Create::new()
    }

    fn clear(&mut self) {
        self.element_id = ::std::option::Option::None;
        self.layout_filename = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomHudElement_Create {
        static instance: CDOTAUserMsg_CustomHudElement_Create = CDOTAUserMsg_CustomHudElement_Create {
            element_id: ::std::option::Option::None,
            layout_filename: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CustomHudElement_Create {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CustomHudElement_Create").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CustomHudElement_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomHudElement_Create {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CustomHudElement_Modify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomHudElement_Modify {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHudElement_Modify.element_id)
    pub element_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHudElement_Modify.modify_visible)
    pub modify_visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHudElement_Modify.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CustomHudElement_Modify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomHudElement_Modify {
    fn default() -> &'a CDOTAUserMsg_CustomHudElement_Modify {
        <CDOTAUserMsg_CustomHudElement_Modify as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomHudElement_Modify {
    pub fn new() -> CDOTAUserMsg_CustomHudElement_Modify {
        ::std::default::Default::default()
    }

    // optional string element_id = 1;

    pub fn element_id(&self) -> &str {
        match self.element_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_element_id(&mut self) {
        self.element_id = ::std::option::Option::None;
    }

    pub fn has_element_id(&self) -> bool {
        self.element_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_id(&mut self, v: ::std::string::String) {
        self.element_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_id(&mut self) -> &mut ::std::string::String {
        if self.element_id.is_none() {
            self.element_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.element_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_id(&mut self) -> ::std::string::String {
        self.element_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool modify_visible = 2;

    pub fn modify_visible(&self) -> bool {
        self.modify_visible.unwrap_or(false)
    }

    pub fn clear_modify_visible(&mut self) {
        self.modify_visible = ::std::option::Option::None;
    }

    pub fn has_modify_visible(&self) -> bool {
        self.modify_visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modify_visible(&mut self, v: bool) {
        self.modify_visible = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "element_id",
            |m: &CDOTAUserMsg_CustomHudElement_Modify| { &m.element_id },
            |m: &mut CDOTAUserMsg_CustomHudElement_Modify| { &mut m.element_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modify_visible",
            |m: &CDOTAUserMsg_CustomHudElement_Modify| { &m.modify_visible },
            |m: &mut CDOTAUserMsg_CustomHudElement_Modify| { &mut m.modify_visible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDOTAUserMsg_CustomHudElement_Modify| { &m.data },
            |m: &mut CDOTAUserMsg_CustomHudElement_Modify| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CustomHudElement_Modify>(
            "CDOTAUserMsg_CustomHudElement_Modify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomHudElement_Modify {
    const NAME: &'static str = "CDOTAUserMsg_CustomHudElement_Modify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.element_id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.modify_visible = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.element_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.modify_visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.element_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.modify_visible {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomHudElement_Modify {
        CDOTAUserMsg_CustomHudElement_Modify::new()
    }

    fn clear(&mut self) {
        self.element_id = ::std::option::Option::None;
        self.modify_visible = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomHudElement_Modify {
        static instance: CDOTAUserMsg_CustomHudElement_Modify = CDOTAUserMsg_CustomHudElement_Modify {
            element_id: ::std::option::Option::None,
            modify_visible: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CustomHudElement_Modify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CustomHudElement_Modify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CustomHudElement_Modify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomHudElement_Modify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CustomHudElement_Destroy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomHudElement_Destroy {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CustomHudElement_Destroy.element_id)
    pub element_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CustomHudElement_Destroy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomHudElement_Destroy {
    fn default() -> &'a CDOTAUserMsg_CustomHudElement_Destroy {
        <CDOTAUserMsg_CustomHudElement_Destroy as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomHudElement_Destroy {
    pub fn new() -> CDOTAUserMsg_CustomHudElement_Destroy {
        ::std::default::Default::default()
    }

    // optional string element_id = 1;

    pub fn element_id(&self) -> &str {
        match self.element_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_element_id(&mut self) {
        self.element_id = ::std::option::Option::None;
    }

    pub fn has_element_id(&self) -> bool {
        self.element_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_id(&mut self, v: ::std::string::String) {
        self.element_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_id(&mut self) -> &mut ::std::string::String {
        if self.element_id.is_none() {
            self.element_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.element_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_id(&mut self) -> ::std::string::String {
        self.element_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "element_id",
            |m: &CDOTAUserMsg_CustomHudElement_Destroy| { &m.element_id },
            |m: &mut CDOTAUserMsg_CustomHudElement_Destroy| { &mut m.element_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CustomHudElement_Destroy>(
            "CDOTAUserMsg_CustomHudElement_Destroy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomHudElement_Destroy {
    const NAME: &'static str = "CDOTAUserMsg_CustomHudElement_Destroy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.element_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.element_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.element_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomHudElement_Destroy {
        CDOTAUserMsg_CustomHudElement_Destroy::new()
    }

    fn clear(&mut self) {
        self.element_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomHudElement_Destroy {
        static instance: CDOTAUserMsg_CustomHudElement_Destroy = CDOTAUserMsg_CustomHudElement_Destroy {
            element_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CustomHudElement_Destroy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CustomHudElement_Destroy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CustomHudElement_Destroy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomHudElement_Destroy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CompendiumStatePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CompendiumStatePlayer {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CompendiumStatePlayer.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CompendiumStatePlayer.level)
    pub level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CompendiumStatePlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CompendiumStatePlayer {
    fn default() -> &'a CDOTAUserMsg_CompendiumStatePlayer {
        <CDOTAUserMsg_CompendiumStatePlayer as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CompendiumStatePlayer {
    pub fn new() -> CDOTAUserMsg_CompendiumStatePlayer {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 2;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_CompendiumStatePlayer| { &m.player_id },
            |m: &mut CDOTAUserMsg_CompendiumStatePlayer| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level",
            |m: &CDOTAUserMsg_CompendiumStatePlayer| { &m.level },
            |m: &mut CDOTAUserMsg_CompendiumStatePlayer| { &mut m.level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CompendiumStatePlayer>(
            "CDOTAUserMsg_CompendiumStatePlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CompendiumStatePlayer {
    const NAME: &'static str = "CDOTAUserMsg_CompendiumStatePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CompendiumStatePlayer {
        CDOTAUserMsg_CompendiumStatePlayer::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CompendiumStatePlayer {
        static instance: CDOTAUserMsg_CompendiumStatePlayer = CDOTAUserMsg_CompendiumStatePlayer {
            player_id: ::std::option::Option::None,
            level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CompendiumStatePlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CompendiumStatePlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CompendiumStatePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CompendiumStatePlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_CompendiumState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CompendiumState {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_CompendiumState.compendium_players)
    pub compendium_players: ::std::vec::Vec<CDOTAUserMsg_CompendiumStatePlayer>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_CompendiumState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CompendiumState {
    fn default() -> &'a CDOTAUserMsg_CompendiumState {
        <CDOTAUserMsg_CompendiumState as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CompendiumState {
    pub fn new() -> CDOTAUserMsg_CompendiumState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "compendium_players",
            |m: &CDOTAUserMsg_CompendiumState| { &m.compendium_players },
            |m: &mut CDOTAUserMsg_CompendiumState| { &mut m.compendium_players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_CompendiumState>(
            "CDOTAUserMsg_CompendiumState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CompendiumState {
    const NAME: &'static str = "CDOTAUserMsg_CompendiumState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.compendium_players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.compendium_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.compendium_players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CompendiumState {
        CDOTAUserMsg_CompendiumState::new()
    }

    fn clear(&mut self) {
        self.compendium_players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CompendiumState {
        static instance: CDOTAUserMsg_CompendiumState = CDOTAUserMsg_CompendiumState {
            compendium_players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_CompendiumState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_CompendiumState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_CompendiumState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CompendiumState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ProjectionAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ProjectionAbility {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionAbility.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionAbility.caster_ent_index)
    pub caster_ent_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionAbility.caster_team)
    pub caster_team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionAbility.channel_end)
    pub channel_end: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionAbility.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionAbility.track_caster_only)
    pub track_caster_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionAbility.end_time)
    pub end_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionAbility.victim_ent_index)
    pub victim_ent_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ProjectionAbility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ProjectionAbility {
    fn default() -> &'a CDOTAUserMsg_ProjectionAbility {
        <CDOTAUserMsg_ProjectionAbility as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ProjectionAbility {
    pub fn new() -> CDOTAUserMsg_ProjectionAbility {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 caster_ent_index = 2;

    pub fn caster_ent_index(&self) -> i32 {
        self.caster_ent_index.unwrap_or(0)
    }

    pub fn clear_caster_ent_index(&mut self) {
        self.caster_ent_index = ::std::option::Option::None;
    }

    pub fn has_caster_ent_index(&self) -> bool {
        self.caster_ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caster_ent_index(&mut self, v: i32) {
        self.caster_ent_index = ::std::option::Option::Some(v);
    }

    // optional int32 caster_team = 3;

    pub fn caster_team(&self) -> i32 {
        self.caster_team.unwrap_or(0)
    }

    pub fn clear_caster_team(&mut self) {
        self.caster_team = ::std::option::Option::None;
    }

    pub fn has_caster_team(&self) -> bool {
        self.caster_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caster_team(&mut self, v: i32) {
        self.caster_team = ::std::option::Option::Some(v);
    }

    // optional bool channel_end = 4;

    pub fn channel_end(&self) -> bool {
        self.channel_end.unwrap_or(false)
    }

    pub fn clear_channel_end(&mut self) {
        self.channel_end = ::std::option::Option::None;
    }

    pub fn has_channel_end(&self) -> bool {
        self.channel_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_end(&mut self, v: bool) {
        self.channel_end = ::std::option::Option::Some(v);
    }

    // optional bool track_caster_only = 6;

    pub fn track_caster_only(&self) -> bool {
        self.track_caster_only.unwrap_or(false)
    }

    pub fn clear_track_caster_only(&mut self) {
        self.track_caster_only = ::std::option::Option::None;
    }

    pub fn has_track_caster_only(&self) -> bool {
        self.track_caster_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_track_caster_only(&mut self, v: bool) {
        self.track_caster_only = ::std::option::Option::Some(v);
    }

    // optional float end_time = 7;

    pub fn end_time(&self) -> f32 {
        self.end_time.unwrap_or(0.)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: f32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    // optional int32 victim_ent_index = 8;

    pub fn victim_ent_index(&self) -> i32 {
        self.victim_ent_index.unwrap_or(0)
    }

    pub fn clear_victim_ent_index(&mut self) {
        self.victim_ent_index = ::std::option::Option::None;
    }

    pub fn has_victim_ent_index(&self) -> bool {
        self.victim_ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_ent_index(&mut self, v: i32) {
        self.victim_ent_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &CDOTAUserMsg_ProjectionAbility| { &m.ability_id },
            |m: &mut CDOTAUserMsg_ProjectionAbility| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caster_ent_index",
            |m: &CDOTAUserMsg_ProjectionAbility| { &m.caster_ent_index },
            |m: &mut CDOTAUserMsg_ProjectionAbility| { &mut m.caster_ent_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caster_team",
            |m: &CDOTAUserMsg_ProjectionAbility| { &m.caster_team },
            |m: &mut CDOTAUserMsg_ProjectionAbility| { &mut m.caster_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_end",
            |m: &CDOTAUserMsg_ProjectionAbility| { &m.channel_end },
            |m: &mut CDOTAUserMsg_ProjectionAbility| { &mut m.channel_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CDOTAUserMsg_ProjectionAbility| { &m.origin },
            |m: &mut CDOTAUserMsg_ProjectionAbility| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "track_caster_only",
            |m: &CDOTAUserMsg_ProjectionAbility| { &m.track_caster_only },
            |m: &mut CDOTAUserMsg_ProjectionAbility| { &mut m.track_caster_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_time",
            |m: &CDOTAUserMsg_ProjectionAbility| { &m.end_time },
            |m: &mut CDOTAUserMsg_ProjectionAbility| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_ent_index",
            |m: &CDOTAUserMsg_ProjectionAbility| { &m.victim_ent_index },
            |m: &mut CDOTAUserMsg_ProjectionAbility| { &mut m.victim_ent_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ProjectionAbility>(
            "CDOTAUserMsg_ProjectionAbility",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ProjectionAbility {
    const NAME: &'static str = "CDOTAUserMsg_ProjectionAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.caster_ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.caster_team = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.channel_end = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                48 => {
                    self.track_caster_only = ::std::option::Option::Some(is.read_bool()?);
                },
                61 => {
                    self.end_time = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.victim_ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.caster_ent_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.caster_team {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.channel_end {
            my_size += 1 + 1;
        }
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.track_caster_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.end_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.victim_ent_index {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.caster_ent_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.caster_team {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.channel_end {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.track_caster_only {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.victim_ent_index {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ProjectionAbility {
        CDOTAUserMsg_ProjectionAbility::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.caster_ent_index = ::std::option::Option::None;
        self.caster_team = ::std::option::Option::None;
        self.channel_end = ::std::option::Option::None;
        self.origin.clear();
        self.track_caster_only = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.victim_ent_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ProjectionAbility {
        static instance: CDOTAUserMsg_ProjectionAbility = CDOTAUserMsg_ProjectionAbility {
            ability_id: ::std::option::Option::None,
            caster_ent_index: ::std::option::Option::None,
            caster_team: ::std::option::Option::None,
            channel_end: ::std::option::Option::None,
            origin: ::protobuf::MessageField::none(),
            track_caster_only: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            victim_ent_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ProjectionAbility {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ProjectionAbility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ProjectionAbility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ProjectionAbility {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ProjectionEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ProjectionEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionEvent.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<EProjectionEvent>>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ProjectionEvent.team)
    pub team: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ProjectionEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ProjectionEvent {
    fn default() -> &'a CDOTAUserMsg_ProjectionEvent {
        <CDOTAUserMsg_ProjectionEvent as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ProjectionEvent {
    pub fn new() -> CDOTAUserMsg_ProjectionEvent {
        ::std::default::Default::default()
    }

    // optional .dota.EProjectionEvent event_id = 1;

    pub fn event_id(&self) -> EProjectionEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(EProjectionEvent::ePE_FirstBlood),
            None => EProjectionEvent::ePE_FirstBlood,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EProjectionEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 team = 2;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDOTAUserMsg_ProjectionEvent| { &m.event_id },
            |m: &mut CDOTAUserMsg_ProjectionEvent| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CDOTAUserMsg_ProjectionEvent| { &m.team },
            |m: &mut CDOTAUserMsg_ProjectionEvent| { &mut m.team },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ProjectionEvent>(
            "CDOTAUserMsg_ProjectionEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ProjectionEvent {
    const NAME: &'static str = "CDOTAUserMsg_ProjectionEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.team {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ProjectionEvent {
        CDOTAUserMsg_ProjectionEvent::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ProjectionEvent {
        static instance: CDOTAUserMsg_ProjectionEvent = CDOTAUserMsg_ProjectionEvent {
            event_id: ::std::option::Option::None,
            team: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ProjectionEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ProjectionEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ProjectionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ProjectionEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_XPAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_XPAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_XPAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_XPAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_XPAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_XPAlert {
    fn default() -> &'a CDOTAUserMsg_XPAlert {
        <CDOTAUserMsg_XPAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_XPAlert {
    pub fn new() -> CDOTAUserMsg_XPAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_XPAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_XPAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAUserMsg_XPAlert| { &m.target_entindex },
            |m: &mut CDOTAUserMsg_XPAlert| { &mut m.target_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_XPAlert>(
            "CDOTAUserMsg_XPAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_XPAlert {
    const NAME: &'static str = "CDOTAUserMsg_XPAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_XPAlert {
        CDOTAUserMsg_XPAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_XPAlert {
        static instance: CDOTAUserMsg_XPAlert = CDOTAUserMsg_XPAlert {
            player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_XPAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_XPAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_XPAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_XPAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TalentTreeAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TalentTreeAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TalentTreeAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TalentTreeAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TalentTreeAlert.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TalentTreeAlert.slot)
    pub slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TalentTreeAlert.learned)
    pub learned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TalentTreeAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TalentTreeAlert {
    fn default() -> &'a CDOTAUserMsg_TalentTreeAlert {
        <CDOTAUserMsg_TalentTreeAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TalentTreeAlert {
    pub fn new() -> CDOTAUserMsg_TalentTreeAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 3;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 slot = 4;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional bool learned = 5;

    pub fn learned(&self) -> bool {
        self.learned.unwrap_or(false)
    }

    pub fn clear_learned(&mut self) {
        self.learned = ::std::option::Option::None;
    }

    pub fn has_learned(&self) -> bool {
        self.learned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_learned(&mut self, v: bool) {
        self.learned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_TalentTreeAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_TalentTreeAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAUserMsg_TalentTreeAlert| { &m.target_entindex },
            |m: &mut CDOTAUserMsg_TalentTreeAlert| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &CDOTAUserMsg_TalentTreeAlert| { &m.ability_id },
            |m: &mut CDOTAUserMsg_TalentTreeAlert| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CDOTAUserMsg_TalentTreeAlert| { &m.slot },
            |m: &mut CDOTAUserMsg_TalentTreeAlert| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "learned",
            |m: &CDOTAUserMsg_TalentTreeAlert| { &m.learned },
            |m: &mut CDOTAUserMsg_TalentTreeAlert| { &mut m.learned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TalentTreeAlert>(
            "CDOTAUserMsg_TalentTreeAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TalentTreeAlert {
    const NAME: &'static str = "CDOTAUserMsg_TalentTreeAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.learned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.learned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.slot {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.learned {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TalentTreeAlert {
        CDOTAUserMsg_TalentTreeAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.learned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TalentTreeAlert {
        static instance: CDOTAUserMsg_TalentTreeAlert = CDOTAUserMsg_TalentTreeAlert {
            player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            learned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TalentTreeAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TalentTreeAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TalentTreeAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TalentTreeAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_UpdateQuestProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_UpdateQuestProgress {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_UpdateQuestProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_UpdateQuestProgress {
    fn default() -> &'a CDOTAUserMsg_UpdateQuestProgress {
        <CDOTAUserMsg_UpdateQuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_UpdateQuestProgress {
    pub fn new() -> CDOTAUserMsg_UpdateQuestProgress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_UpdateQuestProgress>(
            "CDOTAUserMsg_UpdateQuestProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UpdateQuestProgress {
    const NAME: &'static str = "CDOTAUserMsg_UpdateQuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_UpdateQuestProgress {
        CDOTAUserMsg_UpdateQuestProgress::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_UpdateQuestProgress {
        static instance: CDOTAUserMsg_UpdateQuestProgress = CDOTAUserMsg_UpdateQuestProgress {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_UpdateQuestProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_UpdateQuestProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_UpdateQuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UpdateQuestProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_QuestStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_QuestStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuestStatus.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuestStatus.quest_id)
    pub quest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuestStatus.challenge_id)
    pub challenge_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuestStatus.progress)
    pub progress: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuestStatus.goal)
    pub goal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuestStatus.query)
    pub query: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuestStatus.fail_gametime)
    pub fail_gametime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QuestStatus.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_QuestStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_QuestStatus {
    fn default() -> &'a CDOTAUserMsg_QuestStatus {
        <CDOTAUserMsg_QuestStatus as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_QuestStatus {
    pub fn new() -> CDOTAUserMsg_QuestStatus {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_id = 2;

    pub fn quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_id = 3;

    pub fn challenge_id(&self) -> u32 {
        self.challenge_id.unwrap_or(0)
    }

    pub fn clear_challenge_id(&mut self) {
        self.challenge_id = ::std::option::Option::None;
    }

    pub fn has_challenge_id(&self) -> bool {
        self.challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_id(&mut self, v: u32) {
        self.challenge_id = ::std::option::Option::Some(v);
    }

    // optional uint32 progress = 4;

    pub fn progress(&self) -> u32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: u32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional uint32 goal = 5;

    pub fn goal(&self) -> u32 {
        self.goal.unwrap_or(0)
    }

    pub fn clear_goal(&mut self) {
        self.goal = ::std::option::Option::None;
    }

    pub fn has_goal(&self) -> bool {
        self.goal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goal(&mut self, v: u32) {
        self.goal = ::std::option::Option::Some(v);
    }

    // optional uint32 query = 6;

    pub fn query(&self) -> u32 {
        self.query.unwrap_or(0)
    }

    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: u32) {
        self.query = ::std::option::Option::Some(v);
    }

    // optional float fail_gametime = 7;

    pub fn fail_gametime(&self) -> f32 {
        self.fail_gametime.unwrap_or(0.)
    }

    pub fn clear_fail_gametime(&mut self) {
        self.fail_gametime = ::std::option::Option::None;
    }

    pub fn has_fail_gametime(&self) -> bool {
        self.fail_gametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fail_gametime(&mut self, v: f32) {
        self.fail_gametime = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 8;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_QuestStatus| { &m.player_id },
            |m: &mut CDOTAUserMsg_QuestStatus| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CDOTAUserMsg_QuestStatus| { &m.quest_id },
            |m: &mut CDOTAUserMsg_QuestStatus| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_id",
            |m: &CDOTAUserMsg_QuestStatus| { &m.challenge_id },
            |m: &mut CDOTAUserMsg_QuestStatus| { &mut m.challenge_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &CDOTAUserMsg_QuestStatus| { &m.progress },
            |m: &mut CDOTAUserMsg_QuestStatus| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "goal",
            |m: &CDOTAUserMsg_QuestStatus| { &m.goal },
            |m: &mut CDOTAUserMsg_QuestStatus| { &mut m.goal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "query",
            |m: &CDOTAUserMsg_QuestStatus| { &m.query },
            |m: &mut CDOTAUserMsg_QuestStatus| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fail_gametime",
            |m: &CDOTAUserMsg_QuestStatus| { &m.fail_gametime },
            |m: &mut CDOTAUserMsg_QuestStatus| { &mut m.fail_gametime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAUserMsg_QuestStatus| { &m.item_ability_id },
            |m: &mut CDOTAUserMsg_QuestStatus| { &mut m.item_ability_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_QuestStatus>(
            "CDOTAUserMsg_QuestStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_QuestStatus {
    const NAME: &'static str = "CDOTAUserMsg_QuestStatus";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.challenge_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.progress = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.goal = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.query = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.fail_gametime = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.challenge_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.goal {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.query {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.fail_gametime {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.quest_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.challenge_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.progress {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.goal {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.query {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.fail_gametime {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_QuestStatus {
        CDOTAUserMsg_QuestStatus::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.quest_id = ::std::option::Option::None;
        self.challenge_id = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.goal = ::std::option::Option::None;
        self.query = ::std::option::Option::None;
        self.fail_gametime = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_QuestStatus {
        static instance: CDOTAUserMsg_QuestStatus = CDOTAUserMsg_QuestStatus {
            player_id: ::std::option::Option::None,
            quest_id: ::std::option::Option::None,
            challenge_id: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            goal: ::std::option::Option::None,
            query: ::std::option::Option::None,
            fail_gametime: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_QuestStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_QuestStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_QuestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_QuestStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SuggestHeroPick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SuggestHeroPick {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SuggestHeroPick.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SuggestHeroPick.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SuggestHeroPick.ban)
    pub ban: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SuggestHeroPick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SuggestHeroPick {
    fn default() -> &'a CDOTAUserMsg_SuggestHeroPick {
        <CDOTAUserMsg_SuggestHeroPick as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SuggestHeroPick {
    pub fn new() -> CDOTAUserMsg_SuggestHeroPick {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 2;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional bool ban = 3;

    pub fn ban(&self) -> bool {
        self.ban.unwrap_or(false)
    }

    pub fn clear_ban(&mut self) {
        self.ban = ::std::option::Option::None;
    }

    pub fn has_ban(&self) -> bool {
        self.ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban(&mut self, v: bool) {
        self.ban = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_SuggestHeroPick| { &m.player_id },
            |m: &mut CDOTAUserMsg_SuggestHeroPick| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CDOTAUserMsg_SuggestHeroPick| { &m.hero_id },
            |m: &mut CDOTAUserMsg_SuggestHeroPick| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ban",
            |m: &CDOTAUserMsg_SuggestHeroPick| { &m.ban },
            |m: &mut CDOTAUserMsg_SuggestHeroPick| { &mut m.ban },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SuggestHeroPick>(
            "CDOTAUserMsg_SuggestHeroPick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SuggestHeroPick {
    const NAME: &'static str = "CDOTAUserMsg_SuggestHeroPick";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.ban = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ban {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ban {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SuggestHeroPick {
        CDOTAUserMsg_SuggestHeroPick::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.ban = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SuggestHeroPick {
        static instance: CDOTAUserMsg_SuggestHeroPick = CDOTAUserMsg_SuggestHeroPick {
            player_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            ban: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SuggestHeroPick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SuggestHeroPick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SuggestHeroPick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SuggestHeroPick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SuggestHeroRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SuggestHeroRole {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SuggestHeroRole.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SuggestHeroRole.hero_role)
    pub hero_role: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SuggestHeroRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SuggestHeroRole {
    fn default() -> &'a CDOTAUserMsg_SuggestHeroRole {
        <CDOTAUserMsg_SuggestHeroRole as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SuggestHeroRole {
    pub fn new() -> CDOTAUserMsg_SuggestHeroRole {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string hero_role = 2;

    pub fn hero_role(&self) -> &str {
        match self.hero_role.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hero_role(&mut self) {
        self.hero_role = ::std::option::Option::None;
    }

    pub fn has_hero_role(&self) -> bool {
        self.hero_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_role(&mut self, v: ::std::string::String) {
        self.hero_role = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_role(&mut self) -> &mut ::std::string::String {
        if self.hero_role.is_none() {
            self.hero_role = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hero_role.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_role(&mut self) -> ::std::string::String {
        self.hero_role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_SuggestHeroRole| { &m.player_id },
            |m: &mut CDOTAUserMsg_SuggestHeroRole| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_role",
            |m: &CDOTAUserMsg_SuggestHeroRole| { &m.hero_role },
            |m: &mut CDOTAUserMsg_SuggestHeroRole| { &mut m.hero_role },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SuggestHeroRole>(
            "CDOTAUserMsg_SuggestHeroRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SuggestHeroRole {
    const NAME: &'static str = "CDOTAUserMsg_SuggestHeroRole";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.hero_role = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hero_role.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hero_role.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SuggestHeroRole {
        CDOTAUserMsg_SuggestHeroRole::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.hero_role = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SuggestHeroRole {
        static instance: CDOTAUserMsg_SuggestHeroRole = CDOTAUserMsg_SuggestHeroRole {
            player_id: ::std::option::Option::None,
            hero_role: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SuggestHeroRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SuggestHeroRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SuggestHeroRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SuggestHeroRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_KillcamDamageTaken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_KillcamDamageTaken {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_KillcamDamageTaken.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_KillcamDamageTaken.damage_taken)
    pub damage_taken: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_KillcamDamageTaken.item_type)
    pub item_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_KillcamDamageTaken.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_KillcamDamageTaken.hero_name)
    pub hero_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_KillcamDamageTaken.damage_color)
    pub damage_color: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_KillcamDamageTaken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_KillcamDamageTaken {
    fn default() -> &'a CDOTAUserMsg_KillcamDamageTaken {
        <CDOTAUserMsg_KillcamDamageTaken as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_KillcamDamageTaken {
    pub fn new() -> CDOTAUserMsg_KillcamDamageTaken {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_taken = 2;

    pub fn damage_taken(&self) -> u32 {
        self.damage_taken.unwrap_or(0)
    }

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: u32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }

    // optional uint32 item_type = 3;

    pub fn item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 4;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional string hero_name = 5;

    pub fn hero_name(&self) -> &str {
        match self.hero_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hero_name(&mut self) {
        self.hero_name = ::std::option::Option::None;
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: ::std::string::String) {
        self.hero_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
        if self.hero_name.is_none() {
            self.hero_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hero_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_name(&mut self) -> ::std::string::String {
        self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string damage_color = 6;

    pub fn damage_color(&self) -> &str {
        match self.damage_color.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_damage_color(&mut self) {
        self.damage_color = ::std::option::Option::None;
    }

    pub fn has_damage_color(&self) -> bool {
        self.damage_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_color(&mut self, v: ::std::string::String) {
        self.damage_color = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_damage_color(&mut self) -> &mut ::std::string::String {
        if self.damage_color.is_none() {
            self.damage_color = ::std::option::Option::Some(::std::string::String::new());
        }
        self.damage_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_damage_color(&mut self) -> ::std::string::String {
        self.damage_color.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_KillcamDamageTaken| { &m.player_id },
            |m: &mut CDOTAUserMsg_KillcamDamageTaken| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_taken",
            |m: &CDOTAUserMsg_KillcamDamageTaken| { &m.damage_taken },
            |m: &mut CDOTAUserMsg_KillcamDamageTaken| { &mut m.damage_taken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_type",
            |m: &CDOTAUserMsg_KillcamDamageTaken| { &m.item_type },
            |m: &mut CDOTAUserMsg_KillcamDamageTaken| { &mut m.item_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAUserMsg_KillcamDamageTaken| { &m.item_ability_id },
            |m: &mut CDOTAUserMsg_KillcamDamageTaken| { &mut m.item_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_name",
            |m: &CDOTAUserMsg_KillcamDamageTaken| { &m.hero_name },
            |m: &mut CDOTAUserMsg_KillcamDamageTaken| { &mut m.hero_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_color",
            |m: &CDOTAUserMsg_KillcamDamageTaken| { &m.damage_color },
            |m: &mut CDOTAUserMsg_KillcamDamageTaken| { &mut m.damage_color },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_KillcamDamageTaken>(
            "CDOTAUserMsg_KillcamDamageTaken",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_KillcamDamageTaken {
    const NAME: &'static str = "CDOTAUserMsg_KillcamDamageTaken";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.damage_taken = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.hero_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.damage_color = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.hero_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.damage_color.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hero_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.damage_color.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_KillcamDamageTaken {
        CDOTAUserMsg_KillcamDamageTaken::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.item_type = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.hero_name = ::std::option::Option::None;
        self.damage_color = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_KillcamDamageTaken {
        static instance: CDOTAUserMsg_KillcamDamageTaken = CDOTAUserMsg_KillcamDamageTaken {
            player_id: ::std::option::Option::None,
            damage_taken: ::std::option::Option::None,
            item_type: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            hero_name: ::std::option::Option::None,
            damage_color: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_KillcamDamageTaken {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_KillcamDamageTaken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_KillcamDamageTaken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_KillcamDamageTaken {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SelectPenaltyGold)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SelectPenaltyGold {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SelectPenaltyGold.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SelectPenaltyGold.cost)
    pub cost: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SelectPenaltyGold.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SelectPenaltyGold {
    fn default() -> &'a CDOTAUserMsg_SelectPenaltyGold {
        <CDOTAUserMsg_SelectPenaltyGold as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SelectPenaltyGold {
    pub fn new() -> CDOTAUserMsg_SelectPenaltyGold {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional sint32 cost = 2;

    pub fn cost(&self) -> i32 {
        self.cost.unwrap_or(0)
    }

    pub fn clear_cost(&mut self) {
        self.cost = ::std::option::Option::None;
    }

    pub fn has_cost(&self) -> bool {
        self.cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost(&mut self, v: i32) {
        self.cost = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_SelectPenaltyGold| { &m.player_id },
            |m: &mut CDOTAUserMsg_SelectPenaltyGold| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cost",
            |m: &CDOTAUserMsg_SelectPenaltyGold| { &m.cost },
            |m: &mut CDOTAUserMsg_SelectPenaltyGold| { &mut m.cost },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SelectPenaltyGold>(
            "CDOTAUserMsg_SelectPenaltyGold",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SelectPenaltyGold {
    const NAME: &'static str = "CDOTAUserMsg_SelectPenaltyGold";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.cost = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.cost {
            my_size += ::protobuf::rt::sint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.cost {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SelectPenaltyGold {
        CDOTAUserMsg_SelectPenaltyGold::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.cost = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SelectPenaltyGold {
        static instance: CDOTAUserMsg_SelectPenaltyGold = CDOTAUserMsg_SelectPenaltyGold {
            player_id: ::std::option::Option::None,
            cost: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SelectPenaltyGold {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SelectPenaltyGold").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SelectPenaltyGold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SelectPenaltyGold {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_RollDiceResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_RollDiceResult {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RollDiceResult.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RollDiceResult.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RollDiceResult.roll_min)
    pub roll_min: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RollDiceResult.roll_max)
    pub roll_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RollDiceResult.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_RollDiceResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_RollDiceResult {
    fn default() -> &'a CDOTAUserMsg_RollDiceResult {
        <CDOTAUserMsg_RollDiceResult as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_RollDiceResult {
    pub fn new() -> CDOTAUserMsg_RollDiceResult {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_type = 2;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional uint32 roll_min = 3;

    pub fn roll_min(&self) -> u32 {
        self.roll_min.unwrap_or(0)
    }

    pub fn clear_roll_min(&mut self) {
        self.roll_min = ::std::option::Option::None;
    }

    pub fn has_roll_min(&self) -> bool {
        self.roll_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_min(&mut self, v: u32) {
        self.roll_min = ::std::option::Option::Some(v);
    }

    // optional uint32 roll_max = 4;

    pub fn roll_max(&self) -> u32 {
        self.roll_max.unwrap_or(0)
    }

    pub fn clear_roll_max(&mut self) {
        self.roll_max = ::std::option::Option::None;
    }

    pub fn has_roll_max(&self) -> bool {
        self.roll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_max(&mut self, v: u32) {
        self.roll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 result = 5;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_RollDiceResult| { &m.player_id },
            |m: &mut CDOTAUserMsg_RollDiceResult| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_type",
            |m: &CDOTAUserMsg_RollDiceResult| { &m.channel_type },
            |m: &mut CDOTAUserMsg_RollDiceResult| { &mut m.channel_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roll_min",
            |m: &CDOTAUserMsg_RollDiceResult| { &m.roll_min },
            |m: &mut CDOTAUserMsg_RollDiceResult| { &mut m.roll_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roll_max",
            |m: &CDOTAUserMsg_RollDiceResult| { &m.roll_max },
            |m: &mut CDOTAUserMsg_RollDiceResult| { &mut m.roll_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CDOTAUserMsg_RollDiceResult| { &m.result },
            |m: &mut CDOTAUserMsg_RollDiceResult| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_RollDiceResult>(
            "CDOTAUserMsg_RollDiceResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_RollDiceResult {
    const NAME: &'static str = "CDOTAUserMsg_RollDiceResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.roll_min = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.roll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.roll_min {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.roll_max {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.roll_min {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.roll_max {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_RollDiceResult {
        CDOTAUserMsg_RollDiceResult::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.channel_type = ::std::option::Option::None;
        self.roll_min = ::std::option::Option::None;
        self.roll_max = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_RollDiceResult {
        static instance: CDOTAUserMsg_RollDiceResult = CDOTAUserMsg_RollDiceResult {
            player_id: ::std::option::Option::None,
            channel_type: ::std::option::Option::None,
            roll_min: ::std::option::Option::None,
            roll_max: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_RollDiceResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_RollDiceResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_RollDiceResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_RollDiceResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_FlipCoinResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_FlipCoinResult {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_FlipCoinResult.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_FlipCoinResult.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_FlipCoinResult.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_FlipCoinResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_FlipCoinResult {
    fn default() -> &'a CDOTAUserMsg_FlipCoinResult {
        <CDOTAUserMsg_FlipCoinResult as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_FlipCoinResult {
    pub fn new() -> CDOTAUserMsg_FlipCoinResult {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_type = 2;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional bool result = 3;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_FlipCoinResult| { &m.player_id },
            |m: &mut CDOTAUserMsg_FlipCoinResult| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_type",
            |m: &CDOTAUserMsg_FlipCoinResult| { &m.channel_type },
            |m: &mut CDOTAUserMsg_FlipCoinResult| { &mut m.channel_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CDOTAUserMsg_FlipCoinResult| { &m.result },
            |m: &mut CDOTAUserMsg_FlipCoinResult| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_FlipCoinResult>(
            "CDOTAUserMsg_FlipCoinResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_FlipCoinResult {
    const NAME: &'static str = "CDOTAUserMsg_FlipCoinResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_FlipCoinResult {
        CDOTAUserMsg_FlipCoinResult::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.channel_type = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_FlipCoinResult {
        static instance: CDOTAUserMsg_FlipCoinResult = CDOTAUserMsg_FlipCoinResult {
            player_id: ::std::option::Option::None,
            channel_type: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_FlipCoinResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_FlipCoinResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_FlipCoinResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_FlipCoinResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMessage_RequestItemSuggestions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMessage_RequestItemSuggestions {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMessage_RequestItemSuggestions.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMessage_RequestItemSuggestions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMessage_RequestItemSuggestions {
    fn default() -> &'a CDOTAUserMessage_RequestItemSuggestions {
        <CDOTAUserMessage_RequestItemSuggestions as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMessage_RequestItemSuggestions {
    pub fn new() -> CDOTAUserMessage_RequestItemSuggestions {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMessage_RequestItemSuggestions| { &m.player_id },
            |m: &mut CDOTAUserMessage_RequestItemSuggestions| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMessage_RequestItemSuggestions>(
            "CDOTAUserMessage_RequestItemSuggestions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMessage_RequestItemSuggestions {
    const NAME: &'static str = "CDOTAUserMessage_RequestItemSuggestions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMessage_RequestItemSuggestions {
        CDOTAUserMessage_RequestItemSuggestions::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMessage_RequestItemSuggestions {
        static instance: CDOTAUserMessage_RequestItemSuggestions = CDOTAUserMessage_RequestItemSuggestions {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMessage_RequestItemSuggestions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMessage_RequestItemSuggestions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMessage_RequestItemSuggestions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMessage_RequestItemSuggestions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMessage_TeamCaptainChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMessage_TeamCaptainChanged {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMessage_TeamCaptainChanged.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMessage_TeamCaptainChanged.captain_player_id)
    pub captain_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMessage_TeamCaptainChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMessage_TeamCaptainChanged {
    fn default() -> &'a CDOTAUserMessage_TeamCaptainChanged {
        <CDOTAUserMessage_TeamCaptainChanged as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMessage_TeamCaptainChanged {
    pub fn new() -> CDOTAUserMessage_TeamCaptainChanged {
        ::std::default::Default::default()
    }

    // optional uint32 team = 1;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 captain_player_id = 2;

    pub fn captain_player_id(&self) -> i32 {
        self.captain_player_id.unwrap_or(0)
    }

    pub fn clear_captain_player_id(&mut self) {
        self.captain_player_id = ::std::option::Option::None;
    }

    pub fn has_captain_player_id(&self) -> bool {
        self.captain_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_captain_player_id(&mut self, v: i32) {
        self.captain_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CDOTAUserMessage_TeamCaptainChanged| { &m.team },
            |m: &mut CDOTAUserMessage_TeamCaptainChanged| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "captain_player_id",
            |m: &CDOTAUserMessage_TeamCaptainChanged| { &m.captain_player_id },
            |m: &mut CDOTAUserMessage_TeamCaptainChanged| { &mut m.captain_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMessage_TeamCaptainChanged>(
            "CDOTAUserMessage_TeamCaptainChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMessage_TeamCaptainChanged {
    const NAME: &'static str = "CDOTAUserMessage_TeamCaptainChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.captain_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.captain_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.captain_player_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMessage_TeamCaptainChanged {
        CDOTAUserMessage_TeamCaptainChanged::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.captain_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMessage_TeamCaptainChanged {
        static instance: CDOTAUserMessage_TeamCaptainChanged = CDOTAUserMessage_TeamCaptainChanged {
            team: ::std::option::Option::None,
            captain_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMessage_TeamCaptainChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMessage_TeamCaptainChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMessage_TeamCaptainChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMessage_TeamCaptainChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ChatWheelCooldown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ChatWheelCooldown {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatWheelCooldown.message_id)
    pub message_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatWheelCooldown.cooldown_remaining)
    pub cooldown_remaining: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ChatWheelCooldown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ChatWheelCooldown {
    fn default() -> &'a CDOTAUserMsg_ChatWheelCooldown {
        <CDOTAUserMsg_ChatWheelCooldown as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ChatWheelCooldown {
    pub fn new() -> CDOTAUserMsg_ChatWheelCooldown {
        ::std::default::Default::default()
    }

    // optional uint32 message_id = 1;

    pub fn message_id(&self) -> u32 {
        self.message_id.unwrap_or(0)
    }

    pub fn clear_message_id(&mut self) {
        self.message_id = ::std::option::Option::None;
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: u32) {
        self.message_id = ::std::option::Option::Some(v);
    }

    // optional float cooldown_remaining = 2;

    pub fn cooldown_remaining(&self) -> f32 {
        self.cooldown_remaining.unwrap_or(0.)
    }

    pub fn clear_cooldown_remaining(&mut self) {
        self.cooldown_remaining = ::std::option::Option::None;
    }

    pub fn has_cooldown_remaining(&self) -> bool {
        self.cooldown_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_remaining(&mut self, v: f32) {
        self.cooldown_remaining = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_id",
            |m: &CDOTAUserMsg_ChatWheelCooldown| { &m.message_id },
            |m: &mut CDOTAUserMsg_ChatWheelCooldown| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cooldown_remaining",
            |m: &CDOTAUserMsg_ChatWheelCooldown| { &m.cooldown_remaining },
            |m: &mut CDOTAUserMsg_ChatWheelCooldown| { &mut m.cooldown_remaining },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ChatWheelCooldown>(
            "CDOTAUserMsg_ChatWheelCooldown",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ChatWheelCooldown {
    const NAME: &'static str = "CDOTAUserMsg_ChatWheelCooldown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.cooldown_remaining = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cooldown_remaining {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cooldown_remaining {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ChatWheelCooldown {
        CDOTAUserMsg_ChatWheelCooldown::new()
    }

    fn clear(&mut self) {
        self.message_id = ::std::option::Option::None;
        self.cooldown_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ChatWheelCooldown {
        static instance: CDOTAUserMsg_ChatWheelCooldown = CDOTAUserMsg_ChatWheelCooldown {
            message_id: ::std::option::Option::None,
            cooldown_remaining: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ChatWheelCooldown {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ChatWheelCooldown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ChatWheelCooldown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ChatWheelCooldown {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_HeroRelicProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HeroRelicProgress {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HeroRelicProgress.hero_relic_type)
    pub hero_relic_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HeroRelicProgress.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HeroRelicProgress.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HeroRelicProgress.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HeroRelicProgress.value_display)
    pub value_display: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_HeroRelicProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HeroRelicProgress {
    fn default() -> &'a CDOTAUserMsg_HeroRelicProgress {
        <CDOTAUserMsg_HeroRelicProgress as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HeroRelicProgress {
    pub fn new() -> CDOTAUserMsg_HeroRelicProgress {
        ::std::default::Default::default()
    }

    // optional uint32 hero_relic_type = 1;

    pub fn hero_relic_type(&self) -> u32 {
        self.hero_relic_type.unwrap_or(0)
    }

    pub fn clear_hero_relic_type(&mut self) {
        self.hero_relic_type = ::std::option::Option::None;
    }

    pub fn has_hero_relic_type(&self) -> bool {
        self.hero_relic_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_relic_type(&mut self, v: u32) {
        self.hero_relic_type = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 2;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint32 ehandle = 3;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 4;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional float value_display = 5;

    pub fn value_display(&self) -> f32 {
        self.value_display.unwrap_or(0.)
    }

    pub fn clear_value_display(&mut self) {
        self.value_display = ::std::option::Option::None;
    }

    pub fn has_value_display(&self) -> bool {
        self.value_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_display(&mut self, v: f32) {
        self.value_display = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_relic_type",
            |m: &CDOTAUserMsg_HeroRelicProgress| { &m.hero_relic_type },
            |m: &mut CDOTAUserMsg_HeroRelicProgress| { &mut m.hero_relic_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CDOTAUserMsg_HeroRelicProgress| { &m.value },
            |m: &mut CDOTAUserMsg_HeroRelicProgress| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ehandle",
            |m: &CDOTAUserMsg_HeroRelicProgress| { &m.ehandle },
            |m: &mut CDOTAUserMsg_HeroRelicProgress| { &mut m.ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDOTAUserMsg_HeroRelicProgress| { &m.event_id },
            |m: &mut CDOTAUserMsg_HeroRelicProgress| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value_display",
            |m: &CDOTAUserMsg_HeroRelicProgress| { &m.value_display },
            |m: &mut CDOTAUserMsg_HeroRelicProgress| { &mut m.value_display },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_HeroRelicProgress>(
            "CDOTAUserMsg_HeroRelicProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HeroRelicProgress {
    const NAME: &'static str = "CDOTAUserMsg_HeroRelicProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_relic_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.value_display = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_relic_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ehandle {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.value_display {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hero_relic_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ehandle {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.value_display {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HeroRelicProgress {
        CDOTAUserMsg_HeroRelicProgress::new()
    }

    fn clear(&mut self) {
        self.hero_relic_type = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.ehandle = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.value_display = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HeroRelicProgress {
        static instance: CDOTAUserMsg_HeroRelicProgress = CDOTAUserMsg_HeroRelicProgress {
            hero_relic_type: ::std::option::Option::None,
            value: ::std::option::Option::None,
            ehandle: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            value_display: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_HeroRelicProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_HeroRelicProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_HeroRelicProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HeroRelicProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_AbilityDraftRequestAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AbilityDraftRequestAbility {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityDraftRequestAbility.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityDraftRequestAbility.requested_ability_id)
    pub requested_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AbilityDraftRequestAbility.ctrl_is_down)
    pub ctrl_is_down: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_AbilityDraftRequestAbility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AbilityDraftRequestAbility {
    fn default() -> &'a CDOTAUserMsg_AbilityDraftRequestAbility {
        <CDOTAUserMsg_AbilityDraftRequestAbility as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AbilityDraftRequestAbility {
    pub fn new() -> CDOTAUserMsg_AbilityDraftRequestAbility {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 requested_ability_id = 2;

    pub fn requested_ability_id(&self) -> i32 {
        self.requested_ability_id.unwrap_or(0)
    }

    pub fn clear_requested_ability_id(&mut self) {
        self.requested_ability_id = ::std::option::Option::None;
    }

    pub fn has_requested_ability_id(&self) -> bool {
        self.requested_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_ability_id(&mut self, v: i32) {
        self.requested_ability_id = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_is_down = 3;

    pub fn ctrl_is_down(&self) -> bool {
        self.ctrl_is_down.unwrap_or(false)
    }

    pub fn clear_ctrl_is_down(&mut self) {
        self.ctrl_is_down = ::std::option::Option::None;
    }

    pub fn has_ctrl_is_down(&self) -> bool {
        self.ctrl_is_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_is_down(&mut self, v: bool) {
        self.ctrl_is_down = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_AbilityDraftRequestAbility| { &m.player_id },
            |m: &mut CDOTAUserMsg_AbilityDraftRequestAbility| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requested_ability_id",
            |m: &CDOTAUserMsg_AbilityDraftRequestAbility| { &m.requested_ability_id },
            |m: &mut CDOTAUserMsg_AbilityDraftRequestAbility| { &mut m.requested_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctrl_is_down",
            |m: &CDOTAUserMsg_AbilityDraftRequestAbility| { &m.ctrl_is_down },
            |m: &mut CDOTAUserMsg_AbilityDraftRequestAbility| { &mut m.ctrl_is_down },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_AbilityDraftRequestAbility>(
            "CDOTAUserMsg_AbilityDraftRequestAbility",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AbilityDraftRequestAbility {
    const NAME: &'static str = "CDOTAUserMsg_AbilityDraftRequestAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.requested_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ctrl_is_down = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.requested_ability_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ctrl_is_down {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.requested_ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ctrl_is_down {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AbilityDraftRequestAbility {
        CDOTAUserMsg_AbilityDraftRequestAbility::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.requested_ability_id = ::std::option::Option::None;
        self.ctrl_is_down = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AbilityDraftRequestAbility {
        static instance: CDOTAUserMsg_AbilityDraftRequestAbility = CDOTAUserMsg_AbilityDraftRequestAbility {
            player_id: ::std::option::Option::None,
            requested_ability_id: ::std::option::Option::None,
            ctrl_is_down: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_AbilityDraftRequestAbility {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_AbilityDraftRequestAbility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_AbilityDraftRequestAbility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AbilityDraftRequestAbility {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_DamageReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DamageReport {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DamageReport.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DamageReport.target_hero_id)
    pub target_hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DamageReport.source_hero_id)
    pub source_hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DamageReport.damage_amount)
    pub damage_amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DamageReport.broadcast)
    pub broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_DamageReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DamageReport {
    fn default() -> &'a CDOTAUserMsg_DamageReport {
        <CDOTAUserMsg_DamageReport as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DamageReport {
    pub fn new() -> CDOTAUserMsg_DamageReport {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_hero_id = 2;

    pub fn target_hero_id(&self) -> u32 {
        self.target_hero_id.unwrap_or(0)
    }

    pub fn clear_target_hero_id(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
    }

    pub fn has_target_hero_id(&self) -> bool {
        self.target_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_id(&mut self, v: u32) {
        self.target_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 source_hero_id = 3;

    pub fn source_hero_id(&self) -> u32 {
        self.source_hero_id.unwrap_or(0)
    }

    pub fn clear_source_hero_id(&mut self) {
        self.source_hero_id = ::std::option::Option::None;
    }

    pub fn has_source_hero_id(&self) -> bool {
        self.source_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_hero_id(&mut self, v: u32) {
        self.source_hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 damage_amount = 4;

    pub fn damage_amount(&self) -> i32 {
        self.damage_amount.unwrap_or(0)
    }

    pub fn clear_damage_amount(&mut self) {
        self.damage_amount = ::std::option::Option::None;
    }

    pub fn has_damage_amount(&self) -> bool {
        self.damage_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_amount(&mut self, v: i32) {
        self.damage_amount = ::std::option::Option::Some(v);
    }

    // optional bool broadcast = 5;

    pub fn broadcast(&self) -> bool {
        self.broadcast.unwrap_or(false)
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast = ::std::option::Option::None;
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: bool) {
        self.broadcast = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_DamageReport| { &m.player_id },
            |m: &mut CDOTAUserMsg_DamageReport| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_hero_id",
            |m: &CDOTAUserMsg_DamageReport| { &m.target_hero_id },
            |m: &mut CDOTAUserMsg_DamageReport| { &mut m.target_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_hero_id",
            |m: &CDOTAUserMsg_DamageReport| { &m.source_hero_id },
            |m: &mut CDOTAUserMsg_DamageReport| { &mut m.source_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_amount",
            |m: &CDOTAUserMsg_DamageReport| { &m.damage_amount },
            |m: &mut CDOTAUserMsg_DamageReport| { &mut m.damage_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast",
            |m: &CDOTAUserMsg_DamageReport| { &m.broadcast },
            |m: &mut CDOTAUserMsg_DamageReport| { &mut m.broadcast },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_DamageReport>(
            "CDOTAUserMsg_DamageReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DamageReport {
    const NAME: &'static str = "CDOTAUserMsg_DamageReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.source_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.damage_amount = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_hero_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.source_hero_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.damage_amount {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.broadcast {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.source_hero_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.damage_amount {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.broadcast {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DamageReport {
        CDOTAUserMsg_DamageReport::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_hero_id = ::std::option::Option::None;
        self.source_hero_id = ::std::option::Option::None;
        self.damage_amount = ::std::option::Option::None;
        self.broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DamageReport {
        static instance: CDOTAUserMsg_DamageReport = CDOTAUserMsg_DamageReport {
            player_id: ::std::option::Option::None,
            target_hero_id: ::std::option::Option::None,
            source_hero_id: ::std::option::Option::None,
            damage_amount: ::std::option::Option::None,
            broadcast: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_DamageReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_DamageReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_DamageReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DamageReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_SalutePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SalutePlayer {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SalutePlayer.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SalutePlayer.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SalutePlayer.tip_amount)
    pub tip_amount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SalutePlayer.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SalutePlayer.custom_tip_style)
    pub custom_tip_style: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_SalutePlayer.num_recent_tips)
    pub num_recent_tips: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_SalutePlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SalutePlayer {
    fn default() -> &'a CDOTAUserMsg_SalutePlayer {
        <CDOTAUserMsg_SalutePlayer as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SalutePlayer {
    pub fn new() -> CDOTAUserMsg_SalutePlayer {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(0)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tip_amount = 3;

    pub fn tip_amount(&self) -> u32 {
        self.tip_amount.unwrap_or(0)
    }

    pub fn clear_tip_amount(&mut self) {
        self.tip_amount = ::std::option::Option::None;
    }

    pub fn has_tip_amount(&self) -> bool {
        self.tip_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_amount(&mut self, v: u32) {
        self.tip_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 4;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional string custom_tip_style = 5;

    pub fn custom_tip_style(&self) -> &str {
        match self.custom_tip_style.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_tip_style(&mut self) {
        self.custom_tip_style = ::std::option::Option::None;
    }

    pub fn has_custom_tip_style(&self) -> bool {
        self.custom_tip_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_tip_style(&mut self, v: ::std::string::String) {
        self.custom_tip_style = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_tip_style(&mut self) -> &mut ::std::string::String {
        if self.custom_tip_style.is_none() {
            self.custom_tip_style = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_tip_style.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_tip_style(&mut self) -> ::std::string::String {
        self.custom_tip_style.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_recent_tips = 6;

    pub fn num_recent_tips(&self) -> u32 {
        self.num_recent_tips.unwrap_or(0)
    }

    pub fn clear_num_recent_tips(&mut self) {
        self.num_recent_tips = ::std::option::Option::None;
    }

    pub fn has_num_recent_tips(&self) -> bool {
        self.num_recent_tips.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_recent_tips(&mut self, v: u32) {
        self.num_recent_tips = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_player_id",
            |m: &CDOTAUserMsg_SalutePlayer| { &m.source_player_id },
            |m: &mut CDOTAUserMsg_SalutePlayer| { &mut m.source_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAUserMsg_SalutePlayer| { &m.target_player_id },
            |m: &mut CDOTAUserMsg_SalutePlayer| { &mut m.target_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tip_amount",
            |m: &CDOTAUserMsg_SalutePlayer| { &m.tip_amount },
            |m: &mut CDOTAUserMsg_SalutePlayer| { &mut m.tip_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDOTAUserMsg_SalutePlayer| { &m.event_id },
            |m: &mut CDOTAUserMsg_SalutePlayer| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_tip_style",
            |m: &CDOTAUserMsg_SalutePlayer| { &m.custom_tip_style },
            |m: &mut CDOTAUserMsg_SalutePlayer| { &mut m.custom_tip_style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_recent_tips",
            |m: &CDOTAUserMsg_SalutePlayer| { &m.num_recent_tips },
            |m: &mut CDOTAUserMsg_SalutePlayer| { &mut m.num_recent_tips },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_SalutePlayer>(
            "CDOTAUserMsg_SalutePlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SalutePlayer {
    const NAME: &'static str = "CDOTAUserMsg_SalutePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.tip_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.custom_tip_style = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.num_recent_tips = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.tip_amount {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.custom_tip_style.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.num_recent_tips {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.tip_amount {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.custom_tip_style.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.num_recent_tips {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SalutePlayer {
        CDOTAUserMsg_SalutePlayer::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.tip_amount = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.custom_tip_style = ::std::option::Option::None;
        self.num_recent_tips = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SalutePlayer {
        static instance: CDOTAUserMsg_SalutePlayer = CDOTAUserMsg_SalutePlayer {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            tip_amount: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            custom_tip_style: ::std::option::Option::None,
            num_recent_tips: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_SalutePlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_SalutePlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_SalutePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SalutePlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_TipAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TipAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TipAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_TipAlert.tip_text)
    pub tip_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_TipAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TipAlert {
    fn default() -> &'a CDOTAUserMsg_TipAlert {
        <CDOTAUserMsg_TipAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TipAlert {
    pub fn new() -> CDOTAUserMsg_TipAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string tip_text = 2;

    pub fn tip_text(&self) -> &str {
        match self.tip_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tip_text(&mut self) {
        self.tip_text = ::std::option::Option::None;
    }

    pub fn has_tip_text(&self) -> bool {
        self.tip_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_text(&mut self, v: ::std::string::String) {
        self.tip_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_text(&mut self) -> &mut ::std::string::String {
        if self.tip_text.is_none() {
            self.tip_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tip_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_text(&mut self) -> ::std::string::String {
        self.tip_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_TipAlert| { &m.player_id },
            |m: &mut CDOTAUserMsg_TipAlert| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tip_text",
            |m: &CDOTAUserMsg_TipAlert| { &m.tip_text },
            |m: &mut CDOTAUserMsg_TipAlert| { &mut m.tip_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_TipAlert>(
            "CDOTAUserMsg_TipAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TipAlert {
    const NAME: &'static str = "CDOTAUserMsg_TipAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.tip_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.tip_text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.tip_text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TipAlert {
        CDOTAUserMsg_TipAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.tip_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TipAlert {
        static instance: CDOTAUserMsg_TipAlert = CDOTAUserMsg_TipAlert {
            player_id: ::std::option::Option::None,
            tip_text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_TipAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_TipAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_TipAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TipAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ReplaceQueryUnit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ReplaceQueryUnit {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ReplaceQueryUnit.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ReplaceQueryUnit.source_entindex)
    pub source_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ReplaceQueryUnit.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ReplaceQueryUnit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ReplaceQueryUnit {
    fn default() -> &'a CDOTAUserMsg_ReplaceQueryUnit {
        <CDOTAUserMsg_ReplaceQueryUnit as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ReplaceQueryUnit {
    pub fn new() -> CDOTAUserMsg_ReplaceQueryUnit {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 source_entindex = 2;

    pub fn source_entindex(&self) -> i32 {
        self.source_entindex.unwrap_or(0)
    }

    pub fn clear_source_entindex(&mut self) {
        self.source_entindex = ::std::option::Option::None;
    }

    pub fn has_source_entindex(&self) -> bool {
        self.source_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_entindex(&mut self, v: i32) {
        self.source_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 3;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_ReplaceQueryUnit| { &m.player_id },
            |m: &mut CDOTAUserMsg_ReplaceQueryUnit| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_entindex",
            |m: &CDOTAUserMsg_ReplaceQueryUnit| { &m.source_entindex },
            |m: &mut CDOTAUserMsg_ReplaceQueryUnit| { &mut m.source_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAUserMsg_ReplaceQueryUnit| { &m.target_entindex },
            |m: &mut CDOTAUserMsg_ReplaceQueryUnit| { &mut m.target_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ReplaceQueryUnit>(
            "CDOTAUserMsg_ReplaceQueryUnit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ReplaceQueryUnit {
    const NAME: &'static str = "CDOTAUserMsg_ReplaceQueryUnit";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.source_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.source_entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.source_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ReplaceQueryUnit {
        CDOTAUserMsg_ReplaceQueryUnit::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.source_entindex = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ReplaceQueryUnit {
        static instance: CDOTAUserMsg_ReplaceQueryUnit = CDOTAUserMsg_ReplaceQueryUnit {
            player_id: ::std::option::Option::None,
            source_entindex: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ReplaceQueryUnit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ReplaceQueryUnit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ReplaceQueryUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ReplaceQueryUnit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ESArcanaCombo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ESArcanaCombo {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ESArcanaCombo.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ESArcanaCombo.combo_count)
    pub combo_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ESArcanaCombo.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ESArcanaCombo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ESArcanaCombo {
    fn default() -> &'a CDOTAUserMsg_ESArcanaCombo {
        <CDOTAUserMsg_ESArcanaCombo as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ESArcanaCombo {
    pub fn new() -> CDOTAUserMsg_ESArcanaCombo {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 combo_count = 2;

    pub fn combo_count(&self) -> u32 {
        self.combo_count.unwrap_or(0)
    }

    pub fn clear_combo_count(&mut self) {
        self.combo_count = ::std::option::Option::None;
    }

    pub fn has_combo_count(&self) -> bool {
        self.combo_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combo_count(&mut self, v: u32) {
        self.combo_count = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 3;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ehandle",
            |m: &CDOTAUserMsg_ESArcanaCombo| { &m.ehandle },
            |m: &mut CDOTAUserMsg_ESArcanaCombo| { &mut m.ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "combo_count",
            |m: &CDOTAUserMsg_ESArcanaCombo| { &m.combo_count },
            |m: &mut CDOTAUserMsg_ESArcanaCombo| { &mut m.combo_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "arcana_level",
            |m: &CDOTAUserMsg_ESArcanaCombo| { &m.arcana_level },
            |m: &mut CDOTAUserMsg_ESArcanaCombo| { &mut m.arcana_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ESArcanaCombo>(
            "CDOTAUserMsg_ESArcanaCombo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ESArcanaCombo {
    const NAME: &'static str = "CDOTAUserMsg_ESArcanaCombo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.combo_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.combo_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.combo_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ESArcanaCombo {
        CDOTAUserMsg_ESArcanaCombo::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.combo_count = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ESArcanaCombo {
        static instance: CDOTAUserMsg_ESArcanaCombo = CDOTAUserMsg_ESArcanaCombo {
            ehandle: ::std::option::Option::None,
            combo_count: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ESArcanaCombo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ESArcanaCombo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ESArcanaCombo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ESArcanaCombo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ESArcanaComboSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ESArcanaComboSummary {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ESArcanaComboSummary.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ESArcanaComboSummary.combo_count)
    pub combo_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ESArcanaComboSummary.damage_amount)
    pub damage_amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ESArcanaComboSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ESArcanaComboSummary {
    fn default() -> &'a CDOTAUserMsg_ESArcanaComboSummary {
        <CDOTAUserMsg_ESArcanaComboSummary as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ESArcanaComboSummary {
    pub fn new() -> CDOTAUserMsg_ESArcanaComboSummary {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 combo_count = 2;

    pub fn combo_count(&self) -> u32 {
        self.combo_count.unwrap_or(0)
    }

    pub fn clear_combo_count(&mut self) {
        self.combo_count = ::std::option::Option::None;
    }

    pub fn has_combo_count(&self) -> bool {
        self.combo_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combo_count(&mut self, v: u32) {
        self.combo_count = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_amount = 3;

    pub fn damage_amount(&self) -> u32 {
        self.damage_amount.unwrap_or(0)
    }

    pub fn clear_damage_amount(&mut self) {
        self.damage_amount = ::std::option::Option::None;
    }

    pub fn has_damage_amount(&self) -> bool {
        self.damage_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_amount(&mut self, v: u32) {
        self.damage_amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ehandle",
            |m: &CDOTAUserMsg_ESArcanaComboSummary| { &m.ehandle },
            |m: &mut CDOTAUserMsg_ESArcanaComboSummary| { &mut m.ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "combo_count",
            |m: &CDOTAUserMsg_ESArcanaComboSummary| { &m.combo_count },
            |m: &mut CDOTAUserMsg_ESArcanaComboSummary| { &mut m.combo_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_amount",
            |m: &CDOTAUserMsg_ESArcanaComboSummary| { &m.damage_amount },
            |m: &mut CDOTAUserMsg_ESArcanaComboSummary| { &mut m.damage_amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ESArcanaComboSummary>(
            "CDOTAUserMsg_ESArcanaComboSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ESArcanaComboSummary {
    const NAME: &'static str = "CDOTAUserMsg_ESArcanaComboSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.combo_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.damage_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.combo_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.damage_amount {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.combo_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.damage_amount {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ESArcanaComboSummary {
        CDOTAUserMsg_ESArcanaComboSummary::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.combo_count = ::std::option::Option::None;
        self.damage_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ESArcanaComboSummary {
        static instance: CDOTAUserMsg_ESArcanaComboSummary = CDOTAUserMsg_ESArcanaComboSummary {
            ehandle: ::std::option::Option::None,
            combo_count: ::std::option::Option::None,
            damage_amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ESArcanaComboSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ESArcanaComboSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ESArcanaComboSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ESArcanaComboSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_OMArcanaCombo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_OMArcanaCombo {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OMArcanaCombo.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OMArcanaCombo.multicast_amount)
    pub multicast_amount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OMArcanaCombo.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OMArcanaCombo.multicast_chance)
    pub multicast_chance: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_OMArcanaCombo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_OMArcanaCombo {
    fn default() -> &'a CDOTAUserMsg_OMArcanaCombo {
        <CDOTAUserMsg_OMArcanaCombo as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_OMArcanaCombo {
    pub fn new() -> CDOTAUserMsg_OMArcanaCombo {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 multicast_amount = 2;

    pub fn multicast_amount(&self) -> u32 {
        self.multicast_amount.unwrap_or(0)
    }

    pub fn clear_multicast_amount(&mut self) {
        self.multicast_amount = ::std::option::Option::None;
    }

    pub fn has_multicast_amount(&self) -> bool {
        self.multicast_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multicast_amount(&mut self, v: u32) {
        self.multicast_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 3;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    // optional uint32 multicast_chance = 4;

    pub fn multicast_chance(&self) -> u32 {
        self.multicast_chance.unwrap_or(0)
    }

    pub fn clear_multicast_chance(&mut self) {
        self.multicast_chance = ::std::option::Option::None;
    }

    pub fn has_multicast_chance(&self) -> bool {
        self.multicast_chance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multicast_chance(&mut self, v: u32) {
        self.multicast_chance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ehandle",
            |m: &CDOTAUserMsg_OMArcanaCombo| { &m.ehandle },
            |m: &mut CDOTAUserMsg_OMArcanaCombo| { &mut m.ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "multicast_amount",
            |m: &CDOTAUserMsg_OMArcanaCombo| { &m.multicast_amount },
            |m: &mut CDOTAUserMsg_OMArcanaCombo| { &mut m.multicast_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "arcana_level",
            |m: &CDOTAUserMsg_OMArcanaCombo| { &m.arcana_level },
            |m: &mut CDOTAUserMsg_OMArcanaCombo| { &mut m.arcana_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "multicast_chance",
            |m: &CDOTAUserMsg_OMArcanaCombo| { &m.multicast_chance },
            |m: &mut CDOTAUserMsg_OMArcanaCombo| { &mut m.multicast_chance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_OMArcanaCombo>(
            "CDOTAUserMsg_OMArcanaCombo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_OMArcanaCombo {
    const NAME: &'static str = "CDOTAUserMsg_OMArcanaCombo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.multicast_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.multicast_chance = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.multicast_amount {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.multicast_chance {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.multicast_amount {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.multicast_chance {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_OMArcanaCombo {
        CDOTAUserMsg_OMArcanaCombo::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.multicast_amount = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.multicast_chance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_OMArcanaCombo {
        static instance: CDOTAUserMsg_OMArcanaCombo = CDOTAUserMsg_OMArcanaCombo {
            ehandle: ::std::option::Option::None,
            multicast_amount: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            multicast_chance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_OMArcanaCombo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_OMArcanaCombo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_OMArcanaCombo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_OMArcanaCombo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_HighFiveCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HighFiveCompleted {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HighFiveCompleted.player_id_1)
    pub player_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HighFiveCompleted.player_id_2)
    pub player_id_2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HighFiveCompleted.special_high_five)
    pub special_high_five: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HighFiveCompleted.special_entindex)
    pub special_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_HighFiveCompleted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HighFiveCompleted {
    fn default() -> &'a CDOTAUserMsg_HighFiveCompleted {
        <CDOTAUserMsg_HighFiveCompleted as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HighFiveCompleted {
    pub fn new() -> CDOTAUserMsg_HighFiveCompleted {
        ::std::default::Default::default()
    }

    // optional int32 player_id_1 = 1;

    pub fn player_id_1(&self) -> i32 {
        self.player_id_1.unwrap_or(0)
    }

    pub fn clear_player_id_1(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
    }

    pub fn has_player_id_1(&self) -> bool {
        self.player_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_1(&mut self, v: i32) {
        self.player_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_2 = 2;

    pub fn player_id_2(&self) -> i32 {
        self.player_id_2.unwrap_or(0)
    }

    pub fn clear_player_id_2(&mut self) {
        self.player_id_2 = ::std::option::Option::None;
    }

    pub fn has_player_id_2(&self) -> bool {
        self.player_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_2(&mut self, v: i32) {
        self.player_id_2 = ::std::option::Option::Some(v);
    }

    // optional bool special_high_five = 3;

    pub fn special_high_five(&self) -> bool {
        self.special_high_five.unwrap_or(false)
    }

    pub fn clear_special_high_five(&mut self) {
        self.special_high_five = ::std::option::Option::None;
    }

    pub fn has_special_high_five(&self) -> bool {
        self.special_high_five.is_some()
    }

    // Param is passed by value, moved
    pub fn set_special_high_five(&mut self, v: bool) {
        self.special_high_five = ::std::option::Option::Some(v);
    }

    // optional int32 special_entindex = 4;

    pub fn special_entindex(&self) -> i32 {
        self.special_entindex.unwrap_or(0)
    }

    pub fn clear_special_entindex(&mut self) {
        self.special_entindex = ::std::option::Option::None;
    }

    pub fn has_special_entindex(&self) -> bool {
        self.special_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_special_entindex(&mut self, v: i32) {
        self.special_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_1",
            |m: &CDOTAUserMsg_HighFiveCompleted| { &m.player_id_1 },
            |m: &mut CDOTAUserMsg_HighFiveCompleted| { &mut m.player_id_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_2",
            |m: &CDOTAUserMsg_HighFiveCompleted| { &m.player_id_2 },
            |m: &mut CDOTAUserMsg_HighFiveCompleted| { &mut m.player_id_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "special_high_five",
            |m: &CDOTAUserMsg_HighFiveCompleted| { &m.special_high_five },
            |m: &mut CDOTAUserMsg_HighFiveCompleted| { &mut m.special_high_five },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "special_entindex",
            |m: &CDOTAUserMsg_HighFiveCompleted| { &m.special_entindex },
            |m: &mut CDOTAUserMsg_HighFiveCompleted| { &mut m.special_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_HighFiveCompleted>(
            "CDOTAUserMsg_HighFiveCompleted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HighFiveCompleted {
    const NAME: &'static str = "CDOTAUserMsg_HighFiveCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_2 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.special_high_five = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.special_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_1 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_2 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.special_high_five {
            my_size += 1 + 1;
        }
        if let Some(v) = self.special_entindex {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_2 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.special_high_five {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.special_entindex {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HighFiveCompleted {
        CDOTAUserMsg_HighFiveCompleted::new()
    }

    fn clear(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
        self.player_id_2 = ::std::option::Option::None;
        self.special_high_five = ::std::option::Option::None;
        self.special_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HighFiveCompleted {
        static instance: CDOTAUserMsg_HighFiveCompleted = CDOTAUserMsg_HighFiveCompleted {
            player_id_1: ::std::option::Option::None,
            player_id_2: ::std::option::Option::None,
            special_high_five: ::std::option::Option::None,
            special_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_HighFiveCompleted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_HighFiveCompleted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_HighFiveCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HighFiveCompleted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_HighFiveLeftHanging)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HighFiveLeftHanging {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HighFiveLeftHanging.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_HighFiveLeftHanging.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HighFiveLeftHanging {
    fn default() -> &'a CDOTAUserMsg_HighFiveLeftHanging {
        <CDOTAUserMsg_HighFiveLeftHanging as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HighFiveLeftHanging {
    pub fn new() -> CDOTAUserMsg_HighFiveLeftHanging {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_HighFiveLeftHanging| { &m.player_id },
            |m: &mut CDOTAUserMsg_HighFiveLeftHanging| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_HighFiveLeftHanging>(
            "CDOTAUserMsg_HighFiveLeftHanging",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HighFiveLeftHanging {
    const NAME: &'static str = "CDOTAUserMsg_HighFiveLeftHanging";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HighFiveLeftHanging {
        CDOTAUserMsg_HighFiveLeftHanging::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HighFiveLeftHanging {
        static instance: CDOTAUserMsg_HighFiveLeftHanging = CDOTAUserMsg_HighFiveLeftHanging {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_HighFiveLeftHanging {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_HighFiveLeftHanging").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_HighFiveLeftHanging {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HighFiveLeftHanging {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ShovelUnearth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ShovelUnearth {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShovelUnearth.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShovelUnearth.all_chat)
    pub all_chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShovelUnearth.locstring)
    pub locstring: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ShovelUnearth.quantity)
    pub quantity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ShovelUnearth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ShovelUnearth {
    fn default() -> &'a CDOTAUserMsg_ShovelUnearth {
        <CDOTAUserMsg_ShovelUnearth as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ShovelUnearth {
    pub fn new() -> CDOTAUserMsg_ShovelUnearth {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional bool all_chat = 2;

    pub fn all_chat(&self) -> bool {
        self.all_chat.unwrap_or(false)
    }

    pub fn clear_all_chat(&mut self) {
        self.all_chat = ::std::option::Option::None;
    }

    pub fn has_all_chat(&self) -> bool {
        self.all_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_chat(&mut self, v: bool) {
        self.all_chat = ::std::option::Option::Some(v);
    }

    // optional string locstring = 3;

    pub fn locstring(&self) -> &str {
        match self.locstring.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_locstring(&mut self) {
        self.locstring = ::std::option::Option::None;
    }

    pub fn has_locstring(&self) -> bool {
        self.locstring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locstring(&mut self, v: ::std::string::String) {
        self.locstring = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locstring(&mut self) -> &mut ::std::string::String {
        if self.locstring.is_none() {
            self.locstring = ::std::option::Option::Some(::std::string::String::new());
        }
        self.locstring.as_mut().unwrap()
    }

    // Take field
    pub fn take_locstring(&mut self) -> ::std::string::String {
        self.locstring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 quantity = 4;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_ShovelUnearth| { &m.player_id },
            |m: &mut CDOTAUserMsg_ShovelUnearth| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "all_chat",
            |m: &CDOTAUserMsg_ShovelUnearth| { &m.all_chat },
            |m: &mut CDOTAUserMsg_ShovelUnearth| { &mut m.all_chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "locstring",
            |m: &CDOTAUserMsg_ShovelUnearth| { &m.locstring },
            |m: &mut CDOTAUserMsg_ShovelUnearth| { &mut m.locstring },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CDOTAUserMsg_ShovelUnearth| { &m.quantity },
            |m: &mut CDOTAUserMsg_ShovelUnearth| { &mut m.quantity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ShovelUnearth>(
            "CDOTAUserMsg_ShovelUnearth",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ShovelUnearth {
    const NAME: &'static str = "CDOTAUserMsg_ShovelUnearth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.all_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.locstring = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.all_chat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.locstring.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.all_chat {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.locstring.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ShovelUnearth {
        CDOTAUserMsg_ShovelUnearth::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.all_chat = ::std::option::Option::None;
        self.locstring = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ShovelUnearth {
        static instance: CDOTAUserMsg_ShovelUnearth = CDOTAUserMsg_ShovelUnearth {
            player_id: ::std::option::Option::None,
            all_chat: ::std::option::Option::None,
            locstring: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ShovelUnearth {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ShovelUnearth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ShovelUnearth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ShovelUnearth {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_AllStarEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AllStarEvent {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AllStarEvent.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AllStarEvent.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AllStarEvent.point_amount)
    pub point_amount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AllStarEvent.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AllStarEvent.player_scores)
    pub player_scores: ::std::vec::Vec<cdotauser_msg_all_star_event::PlayerScore>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_AllStarEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AllStarEvent {
    fn default() -> &'a CDOTAUserMsg_AllStarEvent {
        <CDOTAUserMsg_AllStarEvent as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AllStarEvent {
    pub fn new() -> CDOTAUserMsg_AllStarEvent {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(0)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 point_amount = 3;

    pub fn point_amount(&self) -> u32 {
        self.point_amount.unwrap_or(0)
    }

    pub fn clear_point_amount(&mut self) {
        self.point_amount = ::std::option::Option::None;
    }

    pub fn has_point_amount(&self) -> bool {
        self.point_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point_amount(&mut self, v: u32) {
        self.point_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 4;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_player_id",
            |m: &CDOTAUserMsg_AllStarEvent| { &m.source_player_id },
            |m: &mut CDOTAUserMsg_AllStarEvent| { &mut m.source_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAUserMsg_AllStarEvent| { &m.target_player_id },
            |m: &mut CDOTAUserMsg_AllStarEvent| { &mut m.target_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "point_amount",
            |m: &CDOTAUserMsg_AllStarEvent| { &m.point_amount },
            |m: &mut CDOTAUserMsg_AllStarEvent| { &mut m.point_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDOTAUserMsg_AllStarEvent| { &m.event_id },
            |m: &mut CDOTAUserMsg_AllStarEvent| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_scores",
            |m: &CDOTAUserMsg_AllStarEvent| { &m.player_scores },
            |m: &mut CDOTAUserMsg_AllStarEvent| { &mut m.player_scores },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_AllStarEvent>(
            "CDOTAUserMsg_AllStarEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AllStarEvent {
    const NAME: &'static str = "CDOTAUserMsg_AllStarEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.point_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.player_scores.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.point_amount {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.player_scores {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.point_amount {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(4, v)?;
        }
        for v in &self.player_scores {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AllStarEvent {
        CDOTAUserMsg_AllStarEvent::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.point_amount = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.player_scores.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AllStarEvent {
        static instance: CDOTAUserMsg_AllStarEvent = CDOTAUserMsg_AllStarEvent {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            point_amount: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            player_scores: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_AllStarEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_AllStarEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_AllStarEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AllStarEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_AllStarEvent`
pub mod cdotauser_msg_all_star_event {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_AllStarEvent.PlayerScore)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerScore {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AllStarEvent.PlayerScore.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AllStarEvent.PlayerScore.score_sans_kda)
        pub score_sans_kda: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_AllStarEvent.PlayerScore.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerScore {
        fn default() -> &'a PlayerScore {
            <PlayerScore as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerScore {
        pub fn new() -> PlayerScore {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional uint32 score_sans_kda = 2;

        pub fn score_sans_kda(&self) -> u32 {
            self.score_sans_kda.unwrap_or(0)
        }

        pub fn clear_score_sans_kda(&mut self) {
            self.score_sans_kda = ::std::option::Option::None;
        }

        pub fn has_score_sans_kda(&self) -> bool {
            self.score_sans_kda.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_sans_kda(&mut self, v: u32) {
            self.score_sans_kda = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &PlayerScore| { &m.player_id },
                |m: &mut PlayerScore| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score_sans_kda",
                |m: &PlayerScore| { &m.score_sans_kda },
                |m: &mut PlayerScore| { &mut m.score_sans_kda },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerScore>(
                "CDOTAUserMsg_AllStarEvent.PlayerScore",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerScore {
        const NAME: &'static str = "PlayerScore";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.score_sans_kda = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.score_sans_kda {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.score_sans_kda {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerScore {
            PlayerScore::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.score_sans_kda = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerScore {
            static instance: PlayerScore = PlayerScore {
                player_id: ::std::option::Option::None,
                score_sans_kda: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerScore {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_AllStarEvent.PlayerScore").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerScore {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerScore {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_QueuedOrderRemoved)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_QueuedOrderRemoved {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QueuedOrderRemoved.unit_order_sequence)
    pub unit_order_sequence: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_QueuedOrderRemoved.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_QueuedOrderRemoved {
    fn default() -> &'a CDOTAUserMsg_QueuedOrderRemoved {
        <CDOTAUserMsg_QueuedOrderRemoved as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_QueuedOrderRemoved {
    pub fn new() -> CDOTAUserMsg_QueuedOrderRemoved {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unit_order_sequence",
            |m: &CDOTAUserMsg_QueuedOrderRemoved| { &m.unit_order_sequence },
            |m: &mut CDOTAUserMsg_QueuedOrderRemoved| { &mut m.unit_order_sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_QueuedOrderRemoved>(
            "CDOTAUserMsg_QueuedOrderRemoved",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_QueuedOrderRemoved {
    const NAME: &'static str = "CDOTAUserMsg_QueuedOrderRemoved";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.unit_order_sequence)?;
                },
                8 => {
                    self.unit_order_sequence.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.unit_order_sequence {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.unit_order_sequence {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_QueuedOrderRemoved {
        CDOTAUserMsg_QueuedOrderRemoved::new()
    }

    fn clear(&mut self) {
        self.unit_order_sequence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_QueuedOrderRemoved {
        static instance: CDOTAUserMsg_QueuedOrderRemoved = CDOTAUserMsg_QueuedOrderRemoved {
            unit_order_sequence: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_QueuedOrderRemoved {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_QueuedOrderRemoved").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_QueuedOrderRemoved {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_QueuedOrderRemoved {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_DebugChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DebugChallenge {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DebugChallenge.challenge_type)
    pub challenge_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DebugChallenge.challenge_query_id)
    pub challenge_query_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DebugChallenge.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DebugChallenge.instance_id)
    pub instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DebugChallenge.challenge_var_0)
    pub challenge_var_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DebugChallenge.challenge_var_1)
    pub challenge_var_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DebugChallenge.challenge_max_rank)
    pub challenge_max_rank: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_DebugChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DebugChallenge {
    fn default() -> &'a CDOTAUserMsg_DebugChallenge {
        <CDOTAUserMsg_DebugChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DebugChallenge {
    pub fn new() -> CDOTAUserMsg_DebugChallenge {
        ::std::default::Default::default()
    }

    // required uint32 challenge_type = 1;

    pub fn challenge_type(&self) -> u32 {
        self.challenge_type.unwrap_or(0)
    }

    pub fn clear_challenge_type(&mut self) {
        self.challenge_type = ::std::option::Option::None;
    }

    pub fn has_challenge_type(&self) -> bool {
        self.challenge_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_type(&mut self, v: u32) {
        self.challenge_type = ::std::option::Option::Some(v);
    }

    // required uint32 challenge_query_id = 2;

    pub fn challenge_query_id(&self) -> u32 {
        self.challenge_query_id.unwrap_or(0)
    }

    pub fn clear_challenge_query_id(&mut self) {
        self.challenge_query_id = ::std::option::Option::None;
    }

    pub fn has_challenge_query_id(&self) -> bool {
        self.challenge_query_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_query_id(&mut self, v: u32) {
        self.challenge_query_id = ::std::option::Option::Some(v);
    }

    // required uint32 event_id = 3;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 instance_id = 4;

    pub fn instance_id(&self) -> u32 {
        self.instance_id.unwrap_or(0)
    }

    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_var_0 = 5;

    pub fn challenge_var_0(&self) -> u32 {
        self.challenge_var_0.unwrap_or(0)
    }

    pub fn clear_challenge_var_0(&mut self) {
        self.challenge_var_0 = ::std::option::Option::None;
    }

    pub fn has_challenge_var_0(&self) -> bool {
        self.challenge_var_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_var_0(&mut self, v: u32) {
        self.challenge_var_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_var_1 = 6;

    pub fn challenge_var_1(&self) -> u32 {
        self.challenge_var_1.unwrap_or(0)
    }

    pub fn clear_challenge_var_1(&mut self) {
        self.challenge_var_1 = ::std::option::Option::None;
    }

    pub fn has_challenge_var_1(&self) -> bool {
        self.challenge_var_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_var_1(&mut self, v: u32) {
        self.challenge_var_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_max_rank = 7;

    pub fn challenge_max_rank(&self) -> u32 {
        self.challenge_max_rank.unwrap_or(0)
    }

    pub fn clear_challenge_max_rank(&mut self) {
        self.challenge_max_rank = ::std::option::Option::None;
    }

    pub fn has_challenge_max_rank(&self) -> bool {
        self.challenge_max_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_max_rank(&mut self, v: u32) {
        self.challenge_max_rank = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_type",
            |m: &CDOTAUserMsg_DebugChallenge| { &m.challenge_type },
            |m: &mut CDOTAUserMsg_DebugChallenge| { &mut m.challenge_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_query_id",
            |m: &CDOTAUserMsg_DebugChallenge| { &m.challenge_query_id },
            |m: &mut CDOTAUserMsg_DebugChallenge| { &mut m.challenge_query_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDOTAUserMsg_DebugChallenge| { &m.event_id },
            |m: &mut CDOTAUserMsg_DebugChallenge| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "instance_id",
            |m: &CDOTAUserMsg_DebugChallenge| { &m.instance_id },
            |m: &mut CDOTAUserMsg_DebugChallenge| { &mut m.instance_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_var_0",
            |m: &CDOTAUserMsg_DebugChallenge| { &m.challenge_var_0 },
            |m: &mut CDOTAUserMsg_DebugChallenge| { &mut m.challenge_var_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_var_1",
            |m: &CDOTAUserMsg_DebugChallenge| { &m.challenge_var_1 },
            |m: &mut CDOTAUserMsg_DebugChallenge| { &mut m.challenge_var_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_max_rank",
            |m: &CDOTAUserMsg_DebugChallenge| { &m.challenge_max_rank },
            |m: &mut CDOTAUserMsg_DebugChallenge| { &mut m.challenge_max_rank },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_DebugChallenge>(
            "CDOTAUserMsg_DebugChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DebugChallenge {
    const NAME: &'static str = "CDOTAUserMsg_DebugChallenge";

    fn is_initialized(&self) -> bool {
        if self.challenge_type.is_none() {
            return false;
        }
        if self.challenge_query_id.is_none() {
            return false;
        }
        if self.event_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.challenge_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.challenge_query_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenge_var_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.challenge_var_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.challenge_max_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.challenge_query_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.instance_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenge_var_0 {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.challenge_var_1 {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.challenge_max_rank {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.challenge_query_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_var_0 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.challenge_var_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.challenge_max_rank {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DebugChallenge {
        CDOTAUserMsg_DebugChallenge::new()
    }

    fn clear(&mut self) {
        self.challenge_type = ::std::option::Option::None;
        self.challenge_query_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.challenge_var_0 = ::std::option::Option::None;
        self.challenge_var_1 = ::std::option::Option::None;
        self.challenge_max_rank = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DebugChallenge {
        static instance: CDOTAUserMsg_DebugChallenge = CDOTAUserMsg_DebugChallenge {
            challenge_type: ::std::option::Option::None,
            challenge_query_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            instance_id: ::std::option::Option::None,
            challenge_var_0: ::std::option::Option::None,
            challenge_var_1: ::std::option::Option::None,
            challenge_max_rank: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_DebugChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_DebugChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_DebugChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DebugChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_FoundNeutralItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_FoundNeutralItem {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_FoundNeutralItem.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_FoundNeutralItem.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_FoundNeutralItem.item_tier)
    pub item_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_FoundNeutralItem.tier_item_count)
    pub tier_item_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_FoundNeutralItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_FoundNeutralItem {
    fn default() -> &'a CDOTAUserMsg_FoundNeutralItem {
        <CDOTAUserMsg_FoundNeutralItem as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_FoundNeutralItem {
    pub fn new() -> CDOTAUserMsg_FoundNeutralItem {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 2;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(0)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_tier = 3;

    pub fn item_tier(&self) -> u32 {
        self.item_tier.unwrap_or(0)
    }

    pub fn clear_item_tier(&mut self) {
        self.item_tier = ::std::option::Option::None;
    }

    pub fn has_item_tier(&self) -> bool {
        self.item_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_tier(&mut self, v: u32) {
        self.item_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 tier_item_count = 4;

    pub fn tier_item_count(&self) -> u32 {
        self.tier_item_count.unwrap_or(0)
    }

    pub fn clear_tier_item_count(&mut self) {
        self.tier_item_count = ::std::option::Option::None;
    }

    pub fn has_tier_item_count(&self) -> bool {
        self.tier_item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier_item_count(&mut self, v: u32) {
        self.tier_item_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_FoundNeutralItem| { &m.player_id },
            |m: &mut CDOTAUserMsg_FoundNeutralItem| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_ability_id",
            |m: &CDOTAUserMsg_FoundNeutralItem| { &m.item_ability_id },
            |m: &mut CDOTAUserMsg_FoundNeutralItem| { &mut m.item_ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_tier",
            |m: &CDOTAUserMsg_FoundNeutralItem| { &m.item_tier },
            |m: &mut CDOTAUserMsg_FoundNeutralItem| { &mut m.item_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tier_item_count",
            |m: &CDOTAUserMsg_FoundNeutralItem| { &m.tier_item_count },
            |m: &mut CDOTAUserMsg_FoundNeutralItem| { &mut m.tier_item_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_FoundNeutralItem>(
            "CDOTAUserMsg_FoundNeutralItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_FoundNeutralItem {
    const NAME: &'static str = "CDOTAUserMsg_FoundNeutralItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tier_item_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_tier {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tier_item_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_tier {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tier_item_count {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_FoundNeutralItem {
        CDOTAUserMsg_FoundNeutralItem::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.item_tier = ::std::option::Option::None;
        self.tier_item_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_FoundNeutralItem {
        static instance: CDOTAUserMsg_FoundNeutralItem = CDOTAUserMsg_FoundNeutralItem {
            player_id: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            item_tier: ::std::option::Option::None,
            tier_item_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_FoundNeutralItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_FoundNeutralItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_FoundNeutralItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_FoundNeutralItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_OutpostCaptured)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_OutpostCaptured {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OutpostCaptured.outpost_entindex)
    pub outpost_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OutpostCaptured.team_id)
    pub team_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_OutpostCaptured.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_OutpostCaptured {
    fn default() -> &'a CDOTAUserMsg_OutpostCaptured {
        <CDOTAUserMsg_OutpostCaptured as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_OutpostCaptured {
    pub fn new() -> CDOTAUserMsg_OutpostCaptured {
        ::std::default::Default::default()
    }

    // optional int32 outpost_entindex = 1;

    pub fn outpost_entindex(&self) -> i32 {
        self.outpost_entindex.unwrap_or(0)
    }

    pub fn clear_outpost_entindex(&mut self) {
        self.outpost_entindex = ::std::option::Option::None;
    }

    pub fn has_outpost_entindex(&self) -> bool {
        self.outpost_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outpost_entindex(&mut self, v: i32) {
        self.outpost_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 2;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "outpost_entindex",
            |m: &CDOTAUserMsg_OutpostCaptured| { &m.outpost_entindex },
            |m: &mut CDOTAUserMsg_OutpostCaptured| { &mut m.outpost_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CDOTAUserMsg_OutpostCaptured| { &m.team_id },
            |m: &mut CDOTAUserMsg_OutpostCaptured| { &mut m.team_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_OutpostCaptured>(
            "CDOTAUserMsg_OutpostCaptured",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_OutpostCaptured {
    const NAME: &'static str = "CDOTAUserMsg_OutpostCaptured";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.outpost_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.outpost_entindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.outpost_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_OutpostCaptured {
        CDOTAUserMsg_OutpostCaptured::new()
    }

    fn clear(&mut self) {
        self.outpost_entindex = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_OutpostCaptured {
        static instance: CDOTAUserMsg_OutpostCaptured = CDOTAUserMsg_OutpostCaptured {
            outpost_entindex: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_OutpostCaptured {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_OutpostCaptured").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_OutpostCaptured {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_OutpostCaptured {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_OutpostGrantedXP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_OutpostGrantedXP {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OutpostGrantedXP.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_OutpostGrantedXP.xp_amount)
    pub xp_amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_OutpostGrantedXP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_OutpostGrantedXP {
    fn default() -> &'a CDOTAUserMsg_OutpostGrantedXP {
        <CDOTAUserMsg_OutpostGrantedXP as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_OutpostGrantedXP {
    pub fn new() -> CDOTAUserMsg_OutpostGrantedXP {
        ::std::default::Default::default()
    }

    // optional uint32 team_id = 1;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 xp_amount = 2;

    pub fn xp_amount(&self) -> u32 {
        self.xp_amount.unwrap_or(0)
    }

    pub fn clear_xp_amount(&mut self) {
        self.xp_amount = ::std::option::Option::None;
    }

    pub fn has_xp_amount(&self) -> bool {
        self.xp_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_amount(&mut self, v: u32) {
        self.xp_amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CDOTAUserMsg_OutpostGrantedXP| { &m.team_id },
            |m: &mut CDOTAUserMsg_OutpostGrantedXP| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xp_amount",
            |m: &CDOTAUserMsg_OutpostGrantedXP| { &m.xp_amount },
            |m: &mut CDOTAUserMsg_OutpostGrantedXP| { &mut m.xp_amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_OutpostGrantedXP>(
            "CDOTAUserMsg_OutpostGrantedXP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_OutpostGrantedXP {
    const NAME: &'static str = "CDOTAUserMsg_OutpostGrantedXP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.xp_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.xp_amount {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.xp_amount {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_OutpostGrantedXP {
        CDOTAUserMsg_OutpostGrantedXP::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.xp_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_OutpostGrantedXP {
        static instance: CDOTAUserMsg_OutpostGrantedXP = CDOTAUserMsg_OutpostGrantedXP {
            team_id: ::std::option::Option::None,
            xp_amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_OutpostGrantedXP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_OutpostGrantedXP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_OutpostGrantedXP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_OutpostGrantedXP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_MoveCameraToUnit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MoveCameraToUnit {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MoveCameraToUnit.unit_ehandle)
    pub unit_ehandle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MoveCameraToUnit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MoveCameraToUnit {
    fn default() -> &'a CDOTAUserMsg_MoveCameraToUnit {
        <CDOTAUserMsg_MoveCameraToUnit as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MoveCameraToUnit {
    pub fn new() -> CDOTAUserMsg_MoveCameraToUnit {
        ::std::default::Default::default()
    }

    // optional uint32 unit_ehandle = 1;

    pub fn unit_ehandle(&self) -> u32 {
        self.unit_ehandle.unwrap_or(0)
    }

    pub fn clear_unit_ehandle(&mut self) {
        self.unit_ehandle = ::std::option::Option::None;
    }

    pub fn has_unit_ehandle(&self) -> bool {
        self.unit_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_ehandle(&mut self, v: u32) {
        self.unit_ehandle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_ehandle",
            |m: &CDOTAUserMsg_MoveCameraToUnit| { &m.unit_ehandle },
            |m: &mut CDOTAUserMsg_MoveCameraToUnit| { &mut m.unit_ehandle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_MoveCameraToUnit>(
            "CDOTAUserMsg_MoveCameraToUnit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MoveCameraToUnit {
    const NAME: &'static str = "CDOTAUserMsg_MoveCameraToUnit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_ehandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_ehandle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MoveCameraToUnit {
        CDOTAUserMsg_MoveCameraToUnit::new()
    }

    fn clear(&mut self) {
        self.unit_ehandle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MoveCameraToUnit {
        static instance: CDOTAUserMsg_MoveCameraToUnit = CDOTAUserMsg_MoveCameraToUnit {
            unit_ehandle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_MoveCameraToUnit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MoveCameraToUnit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_MoveCameraToUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MoveCameraToUnit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_PauseMinigameData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PauseMinigameData {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PauseMinigameData.data_bits)
    pub data_bits: ::std::vec::Vec<cdotauser_msg_pause_minigame_data::DataBit>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_PauseMinigameData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PauseMinigameData {
    fn default() -> &'a CDOTAUserMsg_PauseMinigameData {
        <CDOTAUserMsg_PauseMinigameData as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PauseMinigameData {
    pub fn new() -> CDOTAUserMsg_PauseMinigameData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_bits",
            |m: &CDOTAUserMsg_PauseMinigameData| { &m.data_bits },
            |m: &mut CDOTAUserMsg_PauseMinigameData| { &mut m.data_bits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_PauseMinigameData>(
            "CDOTAUserMsg_PauseMinigameData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_PauseMinigameData {
    const NAME: &'static str = "CDOTAUserMsg_PauseMinigameData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_bits.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_bits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data_bits {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PauseMinigameData {
        CDOTAUserMsg_PauseMinigameData::new()
    }

    fn clear(&mut self) {
        self.data_bits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PauseMinigameData {
        static instance: CDOTAUserMsg_PauseMinigameData = CDOTAUserMsg_PauseMinigameData {
            data_bits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_PauseMinigameData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_PauseMinigameData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_PauseMinigameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PauseMinigameData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_PauseMinigameData`
pub mod cdotauser_msg_pause_minigame_data {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_PauseMinigameData.DataBit)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DataBit {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PauseMinigameData.DataBit.index)
        pub index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PauseMinigameData.DataBit.data)
        pub data: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PauseMinigameData.DataBit.data_extra)
        pub data_extra: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_PauseMinigameData.DataBit.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DataBit {
        fn default() -> &'a DataBit {
            <DataBit as ::protobuf::Message>::default_instance()
        }
    }

    impl DataBit {
        pub fn new() -> DataBit {
            ::std::default::Default::default()
        }

        // optional uint32 index = 1;

        pub fn index(&self) -> u32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: u32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int32 data = 2;

        pub fn data(&self) -> i32 {
            self.data.unwrap_or(0)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: i32) {
            self.data = ::std::option::Option::Some(v);
        }

        // optional int64 data_extra = 3;

        pub fn data_extra(&self) -> i64 {
            self.data_extra.unwrap_or(0)
        }

        pub fn clear_data_extra(&mut self) {
            self.data_extra = ::std::option::Option::None;
        }

        pub fn has_data_extra(&self) -> bool {
            self.data_extra.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_extra(&mut self, v: i64) {
            self.data_extra = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "index",
                |m: &DataBit| { &m.index },
                |m: &mut DataBit| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &DataBit| { &m.data },
                |m: &mut DataBit| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_extra",
                |m: &DataBit| { &m.data_extra },
                |m: &mut DataBit| { &mut m.data_extra },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataBit>(
                "CDOTAUserMsg_PauseMinigameData.DataBit",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DataBit {
        const NAME: &'static str = "DataBit";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.data = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.data_extra = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.data {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.data_extra {
                my_size += ::protobuf::rt::int64_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.data {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.data_extra {
                os.write_int64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DataBit {
            DataBit::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.data_extra = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DataBit {
            static instance: DataBit = DataBit {
                index: ::std::option::Option::None,
                data: ::std::option::Option::None,
                data_extra: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DataBit {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_PauseMinigameData.DataBit").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DataBit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DataBit {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_VersusScene_PlayerBehavior)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_VersusScene_PlayerBehavior {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VersusScene_PlayerBehavior.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VersusScene_PlayerBehavior.behavior)
    pub behavior: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_commonmessages::EDOTAVersusScenePlayerBehavior>>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VersusScene_PlayerBehavior.play_activity)
    pub play_activity: ::protobuf::MessageField<super::dota_commonmessages::VersusScene_PlayActivity>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VersusScene_PlayerBehavior.chat_wheel)
    pub chat_wheel: ::protobuf::MessageField<super::dota_commonmessages::VersusScene_ChatWheel>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_VersusScene_PlayerBehavior.playback_rate)
    pub playback_rate: ::protobuf::MessageField<super::dota_commonmessages::VersusScene_PlaybackRate>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_VersusScene_PlayerBehavior.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_VersusScene_PlayerBehavior {
    fn default() -> &'a CDOTAUserMsg_VersusScene_PlayerBehavior {
        <CDOTAUserMsg_VersusScene_PlayerBehavior as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_VersusScene_PlayerBehavior {
    pub fn new() -> CDOTAUserMsg_VersusScene_PlayerBehavior {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EDOTAVersusScenePlayerBehavior behavior = 2;

    pub fn behavior(&self) -> super::dota_commonmessages::EDOTAVersusScenePlayerBehavior {
        match self.behavior {
            Some(e) => e.enum_value_or(super::dota_commonmessages::EDOTAVersusScenePlayerBehavior::VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY),
            None => super::dota_commonmessages::EDOTAVersusScenePlayerBehavior::VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY,
        }
    }

    pub fn clear_behavior(&mut self) {
        self.behavior = ::std::option::Option::None;
    }

    pub fn has_behavior(&self) -> bool {
        self.behavior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_behavior(&mut self, v: super::dota_commonmessages::EDOTAVersusScenePlayerBehavior) {
        self.behavior = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_VersusScene_PlayerBehavior| { &m.player_id },
            |m: &mut CDOTAUserMsg_VersusScene_PlayerBehavior| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "behavior",
            |m: &CDOTAUserMsg_VersusScene_PlayerBehavior| { &m.behavior },
            |m: &mut CDOTAUserMsg_VersusScene_PlayerBehavior| { &mut m.behavior },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::VersusScene_PlayActivity>(
            "play_activity",
            |m: &CDOTAUserMsg_VersusScene_PlayerBehavior| { &m.play_activity },
            |m: &mut CDOTAUserMsg_VersusScene_PlayerBehavior| { &mut m.play_activity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::VersusScene_ChatWheel>(
            "chat_wheel",
            |m: &CDOTAUserMsg_VersusScene_PlayerBehavior| { &m.chat_wheel },
            |m: &mut CDOTAUserMsg_VersusScene_PlayerBehavior| { &mut m.chat_wheel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dota_commonmessages::VersusScene_PlaybackRate>(
            "playback_rate",
            |m: &CDOTAUserMsg_VersusScene_PlayerBehavior| { &m.playback_rate },
            |m: &mut CDOTAUserMsg_VersusScene_PlayerBehavior| { &mut m.playback_rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_VersusScene_PlayerBehavior>(
            "CDOTAUserMsg_VersusScene_PlayerBehavior",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_VersusScene_PlayerBehavior {
    const NAME: &'static str = "CDOTAUserMsg_VersusScene_PlayerBehavior";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.behavior = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.play_activity)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_wheel)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.playback_rate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.behavior {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.play_activity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chat_wheel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.playback_rate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.behavior {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.play_activity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.chat_wheel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.playback_rate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_VersusScene_PlayerBehavior {
        CDOTAUserMsg_VersusScene_PlayerBehavior::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.behavior = ::std::option::Option::None;
        self.play_activity.clear();
        self.chat_wheel.clear();
        self.playback_rate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_VersusScene_PlayerBehavior {
        static instance: CDOTAUserMsg_VersusScene_PlayerBehavior = CDOTAUserMsg_VersusScene_PlayerBehavior {
            player_id: ::std::option::Option::None,
            behavior: ::std::option::Option::None,
            play_activity: ::protobuf::MessageField::none(),
            chat_wheel: ::protobuf::MessageField::none(),
            playback_rate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_VersusScene_PlayerBehavior {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_VersusScene_PlayerBehavior").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_VersusScene_PlayerBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_VersusScene_PlayerBehavior {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_QoP_ArcanaSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_QoP_ArcanaSummary {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QoP_ArcanaSummary.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QoP_ArcanaSummary.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QoP_ArcanaSummary.players_hit)
    pub players_hit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_QoP_ArcanaSummary.players_killed)
    pub players_killed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_QoP_ArcanaSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_QoP_ArcanaSummary {
    fn default() -> &'a CDOTAUserMsg_QoP_ArcanaSummary {
        <CDOTAUserMsg_QoP_ArcanaSummary as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_QoP_ArcanaSummary {
    pub fn new() -> CDOTAUserMsg_QoP_ArcanaSummary {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 2;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    // optional uint32 players_hit = 3;

    pub fn players_hit(&self) -> u32 {
        self.players_hit.unwrap_or(0)
    }

    pub fn clear_players_hit(&mut self) {
        self.players_hit = ::std::option::Option::None;
    }

    pub fn has_players_hit(&self) -> bool {
        self.players_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_hit(&mut self, v: u32) {
        self.players_hit = ::std::option::Option::Some(v);
    }

    // optional uint32 players_killed = 4;

    pub fn players_killed(&self) -> u32 {
        self.players_killed.unwrap_or(0)
    }

    pub fn clear_players_killed(&mut self) {
        self.players_killed = ::std::option::Option::None;
    }

    pub fn has_players_killed(&self) -> bool {
        self.players_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_killed(&mut self, v: u32) {
        self.players_killed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ehandle",
            |m: &CDOTAUserMsg_QoP_ArcanaSummary| { &m.ehandle },
            |m: &mut CDOTAUserMsg_QoP_ArcanaSummary| { &mut m.ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "arcana_level",
            |m: &CDOTAUserMsg_QoP_ArcanaSummary| { &m.arcana_level },
            |m: &mut CDOTAUserMsg_QoP_ArcanaSummary| { &mut m.arcana_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players_hit",
            |m: &CDOTAUserMsg_QoP_ArcanaSummary| { &m.players_hit },
            |m: &mut CDOTAUserMsg_QoP_ArcanaSummary| { &mut m.players_hit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players_killed",
            |m: &CDOTAUserMsg_QoP_ArcanaSummary| { &m.players_killed },
            |m: &mut CDOTAUserMsg_QoP_ArcanaSummary| { &mut m.players_killed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_QoP_ArcanaSummary>(
            "CDOTAUserMsg_QoP_ArcanaSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_QoP_ArcanaSummary {
    const NAME: &'static str = "CDOTAUserMsg_QoP_ArcanaSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.players_hit = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.players_killed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.players_hit {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.players_killed {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_hit {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.players_killed {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_QoP_ArcanaSummary {
        CDOTAUserMsg_QoP_ArcanaSummary::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.players_hit = ::std::option::Option::None;
        self.players_killed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_QoP_ArcanaSummary {
        static instance: CDOTAUserMsg_QoP_ArcanaSummary = CDOTAUserMsg_QoP_ArcanaSummary {
            ehandle: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            players_hit: ::std::option::Option::None,
            players_killed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_QoP_ArcanaSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_QoP_ArcanaSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_QoP_ArcanaSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_QoP_ArcanaSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_HotPotato_Created)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HotPotato_Created {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HotPotato_Created.player_id_1)
    pub player_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HotPotato_Created.player_id_2)
    pub player_id_2: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_HotPotato_Created.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HotPotato_Created {
    fn default() -> &'a CDOTAUserMsg_HotPotato_Created {
        <CDOTAUserMsg_HotPotato_Created as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HotPotato_Created {
    pub fn new() -> CDOTAUserMsg_HotPotato_Created {
        ::std::default::Default::default()
    }

    // optional int32 player_id_1 = 1;

    pub fn player_id_1(&self) -> i32 {
        self.player_id_1.unwrap_or(0)
    }

    pub fn clear_player_id_1(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
    }

    pub fn has_player_id_1(&self) -> bool {
        self.player_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_1(&mut self, v: i32) {
        self.player_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_2 = 2;

    pub fn player_id_2(&self) -> i32 {
        self.player_id_2.unwrap_or(0)
    }

    pub fn clear_player_id_2(&mut self) {
        self.player_id_2 = ::std::option::Option::None;
    }

    pub fn has_player_id_2(&self) -> bool {
        self.player_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_2(&mut self, v: i32) {
        self.player_id_2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_1",
            |m: &CDOTAUserMsg_HotPotato_Created| { &m.player_id_1 },
            |m: &mut CDOTAUserMsg_HotPotato_Created| { &mut m.player_id_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_2",
            |m: &CDOTAUserMsg_HotPotato_Created| { &m.player_id_2 },
            |m: &mut CDOTAUserMsg_HotPotato_Created| { &mut m.player_id_2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_HotPotato_Created>(
            "CDOTAUserMsg_HotPotato_Created",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HotPotato_Created {
    const NAME: &'static str = "CDOTAUserMsg_HotPotato_Created";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_2 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_1 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_2 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_2 {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HotPotato_Created {
        CDOTAUserMsg_HotPotato_Created::new()
    }

    fn clear(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
        self.player_id_2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HotPotato_Created {
        static instance: CDOTAUserMsg_HotPotato_Created = CDOTAUserMsg_HotPotato_Created {
            player_id_1: ::std::option::Option::None,
            player_id_2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_HotPotato_Created {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_HotPotato_Created").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_HotPotato_Created {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HotPotato_Created {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_HotPotato_Exploded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HotPotato_Exploded {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_HotPotato_Exploded.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_HotPotato_Exploded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HotPotato_Exploded {
    fn default() -> &'a CDOTAUserMsg_HotPotato_Exploded {
        <CDOTAUserMsg_HotPotato_Exploded as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HotPotato_Exploded {
    pub fn new() -> CDOTAUserMsg_HotPotato_Exploded {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_HotPotato_Exploded| { &m.player_id },
            |m: &mut CDOTAUserMsg_HotPotato_Exploded| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_HotPotato_Exploded>(
            "CDOTAUserMsg_HotPotato_Exploded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HotPotato_Exploded {
    const NAME: &'static str = "CDOTAUserMsg_HotPotato_Exploded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HotPotato_Exploded {
        CDOTAUserMsg_HotPotato_Exploded::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HotPotato_Exploded {
        static instance: CDOTAUserMsg_HotPotato_Exploded = CDOTAUserMsg_HotPotato_Exploded {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_HotPotato_Exploded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_HotPotato_Exploded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_HotPotato_Exploded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HotPotato_Exploded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_WK_Arcana_Progress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WK_Arcana_Progress {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WK_Arcana_Progress.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WK_Arcana_Progress.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WK_Arcana_Progress.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_WK_Arcana_Progress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WK_Arcana_Progress {
    fn default() -> &'a CDOTAUserMsg_WK_Arcana_Progress {
        <CDOTAUserMsg_WK_Arcana_Progress as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WK_Arcana_Progress {
    pub fn new() -> CDOTAUserMsg_WK_Arcana_Progress {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 2;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_id = 3;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ehandle",
            |m: &CDOTAUserMsg_WK_Arcana_Progress| { &m.ehandle },
            |m: &mut CDOTAUserMsg_WK_Arcana_Progress| { &mut m.ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "arcana_level",
            |m: &CDOTAUserMsg_WK_Arcana_Progress| { &m.arcana_level },
            |m: &mut CDOTAUserMsg_WK_Arcana_Progress| { &mut m.arcana_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CDOTAUserMsg_WK_Arcana_Progress| { &m.hero_id },
            |m: &mut CDOTAUserMsg_WK_Arcana_Progress| { &mut m.hero_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_WK_Arcana_Progress>(
            "CDOTAUserMsg_WK_Arcana_Progress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_WK_Arcana_Progress {
    const NAME: &'static str = "CDOTAUserMsg_WK_Arcana_Progress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WK_Arcana_Progress {
        CDOTAUserMsg_WK_Arcana_Progress::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WK_Arcana_Progress {
        static instance: CDOTAUserMsg_WK_Arcana_Progress = CDOTAUserMsg_WK_Arcana_Progress {
            ehandle: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_WK_Arcana_Progress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_WK_Arcana_Progress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_WK_Arcana_Progress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_WK_Arcana_Progress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_GuildChallenge_Progress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GuildChallenge_Progress {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GuildChallenge_Progress.player_progress)
    pub player_progress: ::std::vec::Vec<cdotauser_msg_guild_challenge_progress::PlayerProgress>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GuildChallenge_Progress.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GuildChallenge_Progress.challenge_instance_id)
    pub challenge_instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GuildChallenge_Progress.challenge_parameter)
    pub challenge_parameter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GuildChallenge_Progress.challenge_type)
    pub challenge_type: ::std::option::Option<::protobuf::EnumOrUnknown<cdotauser_msg_guild_challenge_progress::EChallengeType>>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GuildChallenge_Progress.challenge_progress_at_start)
    pub challenge_progress_at_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GuildChallenge_Progress.complete)
    pub complete: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_GuildChallenge_Progress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GuildChallenge_Progress {
    fn default() -> &'a CDOTAUserMsg_GuildChallenge_Progress {
        <CDOTAUserMsg_GuildChallenge_Progress as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GuildChallenge_Progress {
    pub fn new() -> CDOTAUserMsg_GuildChallenge_Progress {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 2;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_instance_id = 3;

    pub fn challenge_instance_id(&self) -> u32 {
        self.challenge_instance_id.unwrap_or(0)
    }

    pub fn clear_challenge_instance_id(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
    }

    pub fn has_challenge_instance_id(&self) -> bool {
        self.challenge_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_instance_id(&mut self, v: u32) {
        self.challenge_instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_parameter = 4;

    pub fn challenge_parameter(&self) -> u32 {
        self.challenge_parameter.unwrap_or(0)
    }

    pub fn clear_challenge_parameter(&mut self) {
        self.challenge_parameter = ::std::option::Option::None;
    }

    pub fn has_challenge_parameter(&self) -> bool {
        self.challenge_parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_parameter(&mut self, v: u32) {
        self.challenge_parameter = ::std::option::Option::Some(v);
    }

    // optional .dota.CDOTAUserMsg_GuildChallenge_Progress.EChallengeType challenge_type = 5;

    pub fn challenge_type(&self) -> cdotauser_msg_guild_challenge_progress::EChallengeType {
        match self.challenge_type {
            Some(e) => e.enum_value_or(cdotauser_msg_guild_challenge_progress::EChallengeType::k_EChallengeType_Invalid),
            None => cdotauser_msg_guild_challenge_progress::EChallengeType::k_EChallengeType_Invalid,
        }
    }

    pub fn clear_challenge_type(&mut self) {
        self.challenge_type = ::std::option::Option::None;
    }

    pub fn has_challenge_type(&self) -> bool {
        self.challenge_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_type(&mut self, v: cdotauser_msg_guild_challenge_progress::EChallengeType) {
        self.challenge_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 challenge_progress_at_start = 7;

    pub fn challenge_progress_at_start(&self) -> u32 {
        self.challenge_progress_at_start.unwrap_or(0)
    }

    pub fn clear_challenge_progress_at_start(&mut self) {
        self.challenge_progress_at_start = ::std::option::Option::None;
    }

    pub fn has_challenge_progress_at_start(&self) -> bool {
        self.challenge_progress_at_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_progress_at_start(&mut self, v: u32) {
        self.challenge_progress_at_start = ::std::option::Option::Some(v);
    }

    // optional bool complete = 8;

    pub fn complete(&self) -> bool {
        self.complete.unwrap_or(false)
    }

    pub fn clear_complete(&mut self) {
        self.complete = ::std::option::Option::None;
    }

    pub fn has_complete(&self) -> bool {
        self.complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_complete(&mut self, v: bool) {
        self.complete = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_progress",
            |m: &CDOTAUserMsg_GuildChallenge_Progress| { &m.player_progress },
            |m: &mut CDOTAUserMsg_GuildChallenge_Progress| { &mut m.player_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CDOTAUserMsg_GuildChallenge_Progress| { &m.guild_id },
            |m: &mut CDOTAUserMsg_GuildChallenge_Progress| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_instance_id",
            |m: &CDOTAUserMsg_GuildChallenge_Progress| { &m.challenge_instance_id },
            |m: &mut CDOTAUserMsg_GuildChallenge_Progress| { &mut m.challenge_instance_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_parameter",
            |m: &CDOTAUserMsg_GuildChallenge_Progress| { &m.challenge_parameter },
            |m: &mut CDOTAUserMsg_GuildChallenge_Progress| { &mut m.challenge_parameter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_type",
            |m: &CDOTAUserMsg_GuildChallenge_Progress| { &m.challenge_type },
            |m: &mut CDOTAUserMsg_GuildChallenge_Progress| { &mut m.challenge_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_progress_at_start",
            |m: &CDOTAUserMsg_GuildChallenge_Progress| { &m.challenge_progress_at_start },
            |m: &mut CDOTAUserMsg_GuildChallenge_Progress| { &mut m.challenge_progress_at_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "complete",
            |m: &CDOTAUserMsg_GuildChallenge_Progress| { &m.complete },
            |m: &mut CDOTAUserMsg_GuildChallenge_Progress| { &mut m.complete },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_GuildChallenge_Progress>(
            "CDOTAUserMsg_GuildChallenge_Progress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GuildChallenge_Progress {
    const NAME: &'static str = "CDOTAUserMsg_GuildChallenge_Progress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_progress.push(is.read_message()?);
                },
                16 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenge_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.challenge_progress_at_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.complete = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_progress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.challenge_instance_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.challenge_parameter {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenge_type {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.challenge_progress_at_start {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.complete {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_progress {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.guild_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.challenge_instance_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.challenge_parameter {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_type {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.challenge_progress_at_start {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.complete {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GuildChallenge_Progress {
        CDOTAUserMsg_GuildChallenge_Progress::new()
    }

    fn clear(&mut self) {
        self.player_progress.clear();
        self.guild_id = ::std::option::Option::None;
        self.challenge_instance_id = ::std::option::Option::None;
        self.challenge_parameter = ::std::option::Option::None;
        self.challenge_type = ::std::option::Option::None;
        self.challenge_progress_at_start = ::std::option::Option::None;
        self.complete = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GuildChallenge_Progress {
        static instance: CDOTAUserMsg_GuildChallenge_Progress = CDOTAUserMsg_GuildChallenge_Progress {
            player_progress: ::std::vec::Vec::new(),
            guild_id: ::std::option::Option::None,
            challenge_instance_id: ::std::option::Option::None,
            challenge_parameter: ::std::option::Option::None,
            challenge_type: ::std::option::Option::None,
            challenge_progress_at_start: ::std::option::Option::None,
            complete: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_GuildChallenge_Progress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_GuildChallenge_Progress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_GuildChallenge_Progress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_GuildChallenge_Progress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDOTAUserMsg_GuildChallenge_Progress`
pub mod cdotauser_msg_guild_challenge_progress {
    // @@protoc_insertion_point(message:dota.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerProgress {
        // message fields
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.progress)
        pub progress: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerProgress {
        fn default() -> &'a PlayerProgress {
            <PlayerProgress as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerProgress {
        pub fn new() -> PlayerProgress {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional uint32 progress = 6;

        pub fn progress(&self) -> u32 {
            self.progress.unwrap_or(0)
        }

        pub fn clear_progress(&mut self) {
            self.progress = ::std::option::Option::None;
        }

        pub fn has_progress(&self) -> bool {
            self.progress.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress(&mut self, v: u32) {
            self.progress = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &PlayerProgress| { &m.player_id },
                |m: &mut PlayerProgress| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "progress",
                |m: &PlayerProgress| { &m.progress },
                |m: &mut PlayerProgress| { &mut m.progress },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerProgress>(
                "CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerProgress {
        const NAME: &'static str = "PlayerProgress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.progress = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.progress {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.progress {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerProgress {
            PlayerProgress::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.progress = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerProgress {
            static instance: PlayerProgress = PlayerProgress {
                player_id: ::std::option::Option::None,
                progress: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerProgress {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerProgress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerProgress {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CDOTAUserMsg_GuildChallenge_Progress.EChallengeType)
    pub enum EChallengeType {
        // @@protoc_insertion_point(enum_value:dota.CDOTAUserMsg_GuildChallenge_Progress.EChallengeType.k_EChallengeType_Invalid)
        k_EChallengeType_Invalid = 0,
        // @@protoc_insertion_point(enum_value:dota.CDOTAUserMsg_GuildChallenge_Progress.EChallengeType.k_EChallengeType_Cooperative)
        k_EChallengeType_Cooperative = 1,
        // @@protoc_insertion_point(enum_value:dota.CDOTAUserMsg_GuildChallenge_Progress.EChallengeType.k_EChallengeType_Contract)
        k_EChallengeType_Contract = 2,
    }

    impl ::protobuf::Enum for EChallengeType {
        const NAME: &'static str = "EChallengeType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EChallengeType> {
            match value {
                0 => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Invalid),
                1 => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Cooperative),
                2 => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Contract),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EChallengeType> {
            match str {
                "k_EChallengeType_Invalid" => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Invalid),
                "k_EChallengeType_Cooperative" => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Cooperative),
                "k_EChallengeType_Contract" => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Contract),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EChallengeType] = &[
            EChallengeType::k_EChallengeType_Invalid,
            EChallengeType::k_EChallengeType_Cooperative,
            EChallengeType::k_EChallengeType_Contract,
        ];
    }

    impl ::protobuf::EnumFull for EChallengeType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CDOTAUserMsg_GuildChallenge_Progress.EChallengeType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EChallengeType {
        fn default() -> Self {
            EChallengeType::k_EChallengeType_Invalid
        }
    }

    impl EChallengeType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EChallengeType>("CDOTAUserMsg_GuildChallenge_Progress.EChallengeType")
        }
    }
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_WRArcanaProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WRArcanaProgress {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaProgress.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaProgress.target_ehandle)
    pub target_ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaProgress.arrows_landed)
    pub arrows_landed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaProgress.damage_dealt)
    pub damage_dealt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaProgress.target_hp)
    pub target_hp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaProgress.target_max_hp)
    pub target_max_hp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaProgress.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_WRArcanaProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WRArcanaProgress {
    fn default() -> &'a CDOTAUserMsg_WRArcanaProgress {
        <CDOTAUserMsg_WRArcanaProgress as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WRArcanaProgress {
    pub fn new() -> CDOTAUserMsg_WRArcanaProgress {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_ehandle = 2;

    pub fn target_ehandle(&self) -> u32 {
        self.target_ehandle.unwrap_or(0)
    }

    pub fn clear_target_ehandle(&mut self) {
        self.target_ehandle = ::std::option::Option::None;
    }

    pub fn has_target_ehandle(&self) -> bool {
        self.target_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_ehandle(&mut self, v: u32) {
        self.target_ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 arrows_landed = 3;

    pub fn arrows_landed(&self) -> u32 {
        self.arrows_landed.unwrap_or(0)
    }

    pub fn clear_arrows_landed(&mut self) {
        self.arrows_landed = ::std::option::Option::None;
    }

    pub fn has_arrows_landed(&self) -> bool {
        self.arrows_landed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arrows_landed(&mut self, v: u32) {
        self.arrows_landed = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_dealt = 4;

    pub fn damage_dealt(&self) -> u32 {
        self.damage_dealt.unwrap_or(0)
    }

    pub fn clear_damage_dealt(&mut self) {
        self.damage_dealt = ::std::option::Option::None;
    }

    pub fn has_damage_dealt(&self) -> bool {
        self.damage_dealt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_dealt(&mut self, v: u32) {
        self.damage_dealt = ::std::option::Option::Some(v);
    }

    // optional uint32 target_hp = 5;

    pub fn target_hp(&self) -> u32 {
        self.target_hp.unwrap_or(0)
    }

    pub fn clear_target_hp(&mut self) {
        self.target_hp = ::std::option::Option::None;
    }

    pub fn has_target_hp(&self) -> bool {
        self.target_hp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hp(&mut self, v: u32) {
        self.target_hp = ::std::option::Option::Some(v);
    }

    // optional uint32 target_max_hp = 6;

    pub fn target_max_hp(&self) -> u32 {
        self.target_max_hp.unwrap_or(0)
    }

    pub fn clear_target_max_hp(&mut self) {
        self.target_max_hp = ::std::option::Option::None;
    }

    pub fn has_target_max_hp(&self) -> bool {
        self.target_max_hp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_max_hp(&mut self, v: u32) {
        self.target_max_hp = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 7;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ehandle",
            |m: &CDOTAUserMsg_WRArcanaProgress| { &m.ehandle },
            |m: &mut CDOTAUserMsg_WRArcanaProgress| { &mut m.ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_ehandle",
            |m: &CDOTAUserMsg_WRArcanaProgress| { &m.target_ehandle },
            |m: &mut CDOTAUserMsg_WRArcanaProgress| { &mut m.target_ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "arrows_landed",
            |m: &CDOTAUserMsg_WRArcanaProgress| { &m.arrows_landed },
            |m: &mut CDOTAUserMsg_WRArcanaProgress| { &mut m.arrows_landed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_dealt",
            |m: &CDOTAUserMsg_WRArcanaProgress| { &m.damage_dealt },
            |m: &mut CDOTAUserMsg_WRArcanaProgress| { &mut m.damage_dealt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_hp",
            |m: &CDOTAUserMsg_WRArcanaProgress| { &m.target_hp },
            |m: &mut CDOTAUserMsg_WRArcanaProgress| { &mut m.target_hp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_max_hp",
            |m: &CDOTAUserMsg_WRArcanaProgress| { &m.target_max_hp },
            |m: &mut CDOTAUserMsg_WRArcanaProgress| { &mut m.target_max_hp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "arcana_level",
            |m: &CDOTAUserMsg_WRArcanaProgress| { &m.arcana_level },
            |m: &mut CDOTAUserMsg_WRArcanaProgress| { &mut m.arcana_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_WRArcanaProgress>(
            "CDOTAUserMsg_WRArcanaProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_WRArcanaProgress {
    const NAME: &'static str = "CDOTAUserMsg_WRArcanaProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.arrows_landed = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.damage_dealt = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.target_hp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.target_max_hp = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_ehandle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.arrows_landed {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.damage_dealt {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.target_hp {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.target_max_hp {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_ehandle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.arrows_landed {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.damage_dealt {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.target_hp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.target_max_hp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WRArcanaProgress {
        CDOTAUserMsg_WRArcanaProgress::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.target_ehandle = ::std::option::Option::None;
        self.arrows_landed = ::std::option::Option::None;
        self.damage_dealt = ::std::option::Option::None;
        self.target_hp = ::std::option::Option::None;
        self.target_max_hp = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WRArcanaProgress {
        static instance: CDOTAUserMsg_WRArcanaProgress = CDOTAUserMsg_WRArcanaProgress {
            ehandle: ::std::option::Option::None,
            target_ehandle: ::std::option::Option::None,
            arrows_landed: ::std::option::Option::None,
            damage_dealt: ::std::option::Option::None,
            target_hp: ::std::option::Option::None,
            target_max_hp: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_WRArcanaProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_WRArcanaProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_WRArcanaProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_WRArcanaProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_WRArcanaSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WRArcanaSummary {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaSummary.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaSummary.target_ehandle)
    pub target_ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaSummary.arrows_landed)
    pub arrows_landed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaSummary.damage_dealt)
    pub damage_dealt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaSummary.target_hp)
    pub target_hp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaSummary.target_max_hp)
    pub target_max_hp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaSummary.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_WRArcanaSummary.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_WRArcanaSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WRArcanaSummary {
    fn default() -> &'a CDOTAUserMsg_WRArcanaSummary {
        <CDOTAUserMsg_WRArcanaSummary as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WRArcanaSummary {
    pub fn new() -> CDOTAUserMsg_WRArcanaSummary {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_ehandle = 2;

    pub fn target_ehandle(&self) -> u32 {
        self.target_ehandle.unwrap_or(0)
    }

    pub fn clear_target_ehandle(&mut self) {
        self.target_ehandle = ::std::option::Option::None;
    }

    pub fn has_target_ehandle(&self) -> bool {
        self.target_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_ehandle(&mut self, v: u32) {
        self.target_ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 arrows_landed = 3;

    pub fn arrows_landed(&self) -> u32 {
        self.arrows_landed.unwrap_or(0)
    }

    pub fn clear_arrows_landed(&mut self) {
        self.arrows_landed = ::std::option::Option::None;
    }

    pub fn has_arrows_landed(&self) -> bool {
        self.arrows_landed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arrows_landed(&mut self, v: u32) {
        self.arrows_landed = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_dealt = 4;

    pub fn damage_dealt(&self) -> u32 {
        self.damage_dealt.unwrap_or(0)
    }

    pub fn clear_damage_dealt(&mut self) {
        self.damage_dealt = ::std::option::Option::None;
    }

    pub fn has_damage_dealt(&self) -> bool {
        self.damage_dealt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_dealt(&mut self, v: u32) {
        self.damage_dealt = ::std::option::Option::Some(v);
    }

    // optional uint32 target_hp = 5;

    pub fn target_hp(&self) -> u32 {
        self.target_hp.unwrap_or(0)
    }

    pub fn clear_target_hp(&mut self) {
        self.target_hp = ::std::option::Option::None;
    }

    pub fn has_target_hp(&self) -> bool {
        self.target_hp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hp(&mut self, v: u32) {
        self.target_hp = ::std::option::Option::Some(v);
    }

    // optional uint32 target_max_hp = 6;

    pub fn target_max_hp(&self) -> u32 {
        self.target_max_hp.unwrap_or(0)
    }

    pub fn clear_target_max_hp(&mut self) {
        self.target_max_hp = ::std::option::Option::None;
    }

    pub fn has_target_max_hp(&self) -> bool {
        self.target_max_hp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_max_hp(&mut self, v: u32) {
        self.target_max_hp = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 7;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    // optional bool success = 8;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ehandle",
            |m: &CDOTAUserMsg_WRArcanaSummary| { &m.ehandle },
            |m: &mut CDOTAUserMsg_WRArcanaSummary| { &mut m.ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_ehandle",
            |m: &CDOTAUserMsg_WRArcanaSummary| { &m.target_ehandle },
            |m: &mut CDOTAUserMsg_WRArcanaSummary| { &mut m.target_ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "arrows_landed",
            |m: &CDOTAUserMsg_WRArcanaSummary| { &m.arrows_landed },
            |m: &mut CDOTAUserMsg_WRArcanaSummary| { &mut m.arrows_landed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_dealt",
            |m: &CDOTAUserMsg_WRArcanaSummary| { &m.damage_dealt },
            |m: &mut CDOTAUserMsg_WRArcanaSummary| { &mut m.damage_dealt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_hp",
            |m: &CDOTAUserMsg_WRArcanaSummary| { &m.target_hp },
            |m: &mut CDOTAUserMsg_WRArcanaSummary| { &mut m.target_hp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_max_hp",
            |m: &CDOTAUserMsg_WRArcanaSummary| { &m.target_max_hp },
            |m: &mut CDOTAUserMsg_WRArcanaSummary| { &mut m.target_max_hp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "arcana_level",
            |m: &CDOTAUserMsg_WRArcanaSummary| { &m.arcana_level },
            |m: &mut CDOTAUserMsg_WRArcanaSummary| { &mut m.arcana_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CDOTAUserMsg_WRArcanaSummary| { &m.success },
            |m: &mut CDOTAUserMsg_WRArcanaSummary| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_WRArcanaSummary>(
            "CDOTAUserMsg_WRArcanaSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_WRArcanaSummary {
    const NAME: &'static str = "CDOTAUserMsg_WRArcanaSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.arrows_landed = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.damage_dealt = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.target_hp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.target_max_hp = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_ehandle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.arrows_landed {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.damage_dealt {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.target_hp {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.target_max_hp {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_ehandle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.arrows_landed {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.damage_dealt {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.target_hp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.target_max_hp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.success {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WRArcanaSummary {
        CDOTAUserMsg_WRArcanaSummary::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.target_ehandle = ::std::option::Option::None;
        self.arrows_landed = ::std::option::Option::None;
        self.damage_dealt = ::std::option::Option::None;
        self.target_hp = ::std::option::Option::None;
        self.target_max_hp = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WRArcanaSummary {
        static instance: CDOTAUserMsg_WRArcanaSummary = CDOTAUserMsg_WRArcanaSummary {
            ehandle: ::std::option::Option::None,
            target_ehandle: ::std::option::Option::None,
            arrows_landed: ::std::option::Option::None,
            damage_dealt: ::std::option::Option::None,
            target_hp: ::std::option::Option::None,
            target_max_hp: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_WRArcanaSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_WRArcanaSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_WRArcanaSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_WRArcanaSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_EmptyItemSlotAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_EmptyItemSlotAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EmptyItemSlotAlert.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EmptyItemSlotAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EmptyItemSlotAlert.slot_index)
    pub slot_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_EmptyItemSlotAlert.cooldown_seconds)
    pub cooldown_seconds: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_EmptyItemSlotAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_EmptyItemSlotAlert {
    fn default() -> &'a CDOTAUserMsg_EmptyItemSlotAlert {
        <CDOTAUserMsg_EmptyItemSlotAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_EmptyItemSlotAlert {
    pub fn new() -> CDOTAUserMsg_EmptyItemSlotAlert {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(0)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 slot_index = 3;

    pub fn slot_index(&self) -> i32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: i32) {
        self.slot_index = ::std::option::Option::Some(v);
    }

    // optional int32 cooldown_seconds = 4;

    pub fn cooldown_seconds(&self) -> i32 {
        self.cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_cooldown_seconds(&mut self) {
        self.cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds(&self) -> bool {
        self.cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds(&mut self, v: i32) {
        self.cooldown_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_player_id",
            |m: &CDOTAUserMsg_EmptyItemSlotAlert| { &m.source_player_id },
            |m: &mut CDOTAUserMsg_EmptyItemSlotAlert| { &mut m.source_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAUserMsg_EmptyItemSlotAlert| { &m.target_player_id },
            |m: &mut CDOTAUserMsg_EmptyItemSlotAlert| { &mut m.target_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_index",
            |m: &CDOTAUserMsg_EmptyItemSlotAlert| { &m.slot_index },
            |m: &mut CDOTAUserMsg_EmptyItemSlotAlert| { &mut m.slot_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cooldown_seconds",
            |m: &CDOTAUserMsg_EmptyItemSlotAlert| { &m.cooldown_seconds },
            |m: &mut CDOTAUserMsg_EmptyItemSlotAlert| { &mut m.cooldown_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_EmptyItemSlotAlert>(
            "CDOTAUserMsg_EmptyItemSlotAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_EmptyItemSlotAlert {
    const NAME: &'static str = "CDOTAUserMsg_EmptyItemSlotAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.slot_index = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.cooldown_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.cooldown_seconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.cooldown_seconds {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_EmptyItemSlotAlert {
        CDOTAUserMsg_EmptyItemSlotAlert::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.cooldown_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_EmptyItemSlotAlert {
        static instance: CDOTAUserMsg_EmptyItemSlotAlert = CDOTAUserMsg_EmptyItemSlotAlert {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            cooldown_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_EmptyItemSlotAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_EmptyItemSlotAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_EmptyItemSlotAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_EmptyItemSlotAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_AghsStatusAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AghsStatusAlert {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AghsStatusAlert.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AghsStatusAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AghsStatusAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AghsStatusAlert.alert_type)
    pub alert_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AghsStatusAlert.has_scepter)
    pub has_scepter: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_AghsStatusAlert.has_shard)
    pub has_shard: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_AghsStatusAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AghsStatusAlert {
    fn default() -> &'a CDOTAUserMsg_AghsStatusAlert {
        <CDOTAUserMsg_AghsStatusAlert as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AghsStatusAlert {
    pub fn new() -> CDOTAUserMsg_AghsStatusAlert {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(0)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(0)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 3;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 alert_type = 4;

    pub fn alert_type(&self) -> u32 {
        self.alert_type.unwrap_or(0)
    }

    pub fn clear_alert_type(&mut self) {
        self.alert_type = ::std::option::Option::None;
    }

    pub fn has_alert_type(&self) -> bool {
        self.alert_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alert_type(&mut self, v: u32) {
        self.alert_type = ::std::option::Option::Some(v);
    }

    // optional bool has_scepter = 5;

    pub fn has_scepter(&self) -> bool {
        self.has_scepter.unwrap_or(false)
    }

    pub fn clear_has_scepter(&mut self) {
        self.has_scepter = ::std::option::Option::None;
    }

    pub fn has_has_scepter(&self) -> bool {
        self.has_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_scepter(&mut self, v: bool) {
        self.has_scepter = ::std::option::Option::Some(v);
    }

    // optional bool has_shard = 6;

    pub fn has_shard(&self) -> bool {
        self.has_shard.unwrap_or(false)
    }

    pub fn clear_has_shard(&mut self) {
        self.has_shard = ::std::option::Option::None;
    }

    pub fn has_has_shard(&self) -> bool {
        self.has_shard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_shard(&mut self, v: bool) {
        self.has_shard = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_player_id",
            |m: &CDOTAUserMsg_AghsStatusAlert| { &m.source_player_id },
            |m: &mut CDOTAUserMsg_AghsStatusAlert| { &mut m.source_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_player_id",
            |m: &CDOTAUserMsg_AghsStatusAlert| { &m.target_player_id },
            |m: &mut CDOTAUserMsg_AghsStatusAlert| { &mut m.target_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entindex",
            |m: &CDOTAUserMsg_AghsStatusAlert| { &m.target_entindex },
            |m: &mut CDOTAUserMsg_AghsStatusAlert| { &mut m.target_entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "alert_type",
            |m: &CDOTAUserMsg_AghsStatusAlert| { &m.alert_type },
            |m: &mut CDOTAUserMsg_AghsStatusAlert| { &mut m.alert_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_scepter",
            |m: &CDOTAUserMsg_AghsStatusAlert| { &m.has_scepter },
            |m: &mut CDOTAUserMsg_AghsStatusAlert| { &mut m.has_scepter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_shard",
            |m: &CDOTAUserMsg_AghsStatusAlert| { &m.has_shard },
            |m: &mut CDOTAUserMsg_AghsStatusAlert| { &mut m.has_shard },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_AghsStatusAlert>(
            "CDOTAUserMsg_AghsStatusAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AghsStatusAlert {
    const NAME: &'static str = "CDOTAUserMsg_AghsStatusAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.alert_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.has_scepter = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.has_shard = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.alert_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.has_scepter {
            my_size += 1 + 1;
        }
        if let Some(v) = self.has_shard {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.alert_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.has_scepter {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.has_shard {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AghsStatusAlert {
        CDOTAUserMsg_AghsStatusAlert::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.alert_type = ::std::option::Option::None;
        self.has_scepter = ::std::option::Option::None;
        self.has_shard = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AghsStatusAlert {
        static instance: CDOTAUserMsg_AghsStatusAlert = CDOTAUserMsg_AghsStatusAlert {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            alert_type: ::std::option::Option::None,
            has_scepter: ::std::option::Option::None,
            has_shard: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_AghsStatusAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_AghsStatusAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_AghsStatusAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AghsStatusAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_MutedPlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MutedPlayers {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MutedPlayers.text_muted_player_ids)
    pub text_muted_player_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MutedPlayers.voice_muted_player_ids)
    pub voice_muted_player_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MutedPlayers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MutedPlayers {
    fn default() -> &'a CDOTAUserMsg_MutedPlayers {
        <CDOTAUserMsg_MutedPlayers as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MutedPlayers {
    pub fn new() -> CDOTAUserMsg_MutedPlayers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "text_muted_player_ids",
            |m: &CDOTAUserMsg_MutedPlayers| { &m.text_muted_player_ids },
            |m: &mut CDOTAUserMsg_MutedPlayers| { &mut m.text_muted_player_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "voice_muted_player_ids",
            |m: &CDOTAUserMsg_MutedPlayers| { &m.voice_muted_player_ids },
            |m: &mut CDOTAUserMsg_MutedPlayers| { &mut m.voice_muted_player_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_MutedPlayers>(
            "CDOTAUserMsg_MutedPlayers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MutedPlayers {
    const NAME: &'static str = "CDOTAUserMsg_MutedPlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.text_muted_player_ids)?;
                },
                8 => {
                    self.text_muted_player_ids.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.voice_muted_player_ids)?;
                },
                16 => {
                    self.voice_muted_player_ids.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.text_muted_player_ids {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        for value in &self.voice_muted_player_ids {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.text_muted_player_ids {
            os.write_int32(1, *v)?;
        };
        for v in &self.voice_muted_player_ids {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MutedPlayers {
        CDOTAUserMsg_MutedPlayers::new()
    }

    fn clear(&mut self) {
        self.text_muted_player_ids.clear();
        self.voice_muted_player_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MutedPlayers {
        static instance: CDOTAUserMsg_MutedPlayers = CDOTAUserMsg_MutedPlayers {
            text_muted_player_ids: ::std::vec::Vec::new(),
            voice_muted_player_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_MutedPlayers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MutedPlayers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_MutedPlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MutedPlayers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ContextualTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ContextualTip {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.tip_id)
    pub tip_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.referenced_abilities)
    pub referenced_abilities: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.referenced_units)
    pub referenced_units: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.panorama_classes)
    pub panorama_classes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.force_annotation)
    pub force_annotation: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.variant)
    pub variant: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.int_param)
    pub int_param: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.int_param2)
    pub int_param2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.float_param)
    pub float_param: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.float_param2)
    pub float_param2: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.string_param)
    pub string_param: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.string_param2)
    pub string_param2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.tip_text_override)
    pub tip_text_override: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.tip_annotation_override)
    pub tip_annotation_override: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ContextualTip.panorama_snippet)
    pub panorama_snippet: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ContextualTip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ContextualTip {
    fn default() -> &'a CDOTAUserMsg_ContextualTip {
        <CDOTAUserMsg_ContextualTip as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ContextualTip {
    pub fn new() -> CDOTAUserMsg_ContextualTip {
        ::std::default::Default::default()
    }

    // optional int32 tip_id = 1;

    pub fn tip_id(&self) -> i32 {
        self.tip_id.unwrap_or(0)
    }

    pub fn clear_tip_id(&mut self) {
        self.tip_id = ::std::option::Option::None;
    }

    pub fn has_tip_id(&self) -> bool {
        self.tip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_id(&mut self, v: i32) {
        self.tip_id = ::std::option::Option::Some(v);
    }

    // optional bool force_annotation = 5;

    pub fn force_annotation(&self) -> bool {
        self.force_annotation.unwrap_or(false)
    }

    pub fn clear_force_annotation(&mut self) {
        self.force_annotation = ::std::option::Option::None;
    }

    pub fn has_force_annotation(&self) -> bool {
        self.force_annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_annotation(&mut self, v: bool) {
        self.force_annotation = ::std::option::Option::Some(v);
    }

    // optional int32 variant = 6;

    pub fn variant(&self) -> i32 {
        self.variant.unwrap_or(0)
    }

    pub fn clear_variant(&mut self) {
        self.variant = ::std::option::Option::None;
    }

    pub fn has_variant(&self) -> bool {
        self.variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_variant(&mut self, v: i32) {
        self.variant = ::std::option::Option::Some(v);
    }

    // optional int32 int_param = 7;

    pub fn int_param(&self) -> i32 {
        self.int_param.unwrap_or(0)
    }

    pub fn clear_int_param(&mut self) {
        self.int_param = ::std::option::Option::None;
    }

    pub fn has_int_param(&self) -> bool {
        self.int_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param(&mut self, v: i32) {
        self.int_param = ::std::option::Option::Some(v);
    }

    // optional int32 int_param2 = 8;

    pub fn int_param2(&self) -> i32 {
        self.int_param2.unwrap_or(0)
    }

    pub fn clear_int_param2(&mut self) {
        self.int_param2 = ::std::option::Option::None;
    }

    pub fn has_int_param2(&self) -> bool {
        self.int_param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param2(&mut self, v: i32) {
        self.int_param2 = ::std::option::Option::Some(v);
    }

    // optional float float_param = 9;

    pub fn float_param(&self) -> f32 {
        self.float_param.unwrap_or(0.)
    }

    pub fn clear_float_param(&mut self) {
        self.float_param = ::std::option::Option::None;
    }

    pub fn has_float_param(&self) -> bool {
        self.float_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_param(&mut self, v: f32) {
        self.float_param = ::std::option::Option::Some(v);
    }

    // optional float float_param2 = 10;

    pub fn float_param2(&self) -> f32 {
        self.float_param2.unwrap_or(0.)
    }

    pub fn clear_float_param2(&mut self) {
        self.float_param2 = ::std::option::Option::None;
    }

    pub fn has_float_param2(&self) -> bool {
        self.float_param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_param2(&mut self, v: f32) {
        self.float_param2 = ::std::option::Option::Some(v);
    }

    // optional string string_param = 11;

    pub fn string_param(&self) -> &str {
        match self.string_param.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_param(&mut self) {
        self.string_param = ::std::option::Option::None;
    }

    pub fn has_string_param(&self) -> bool {
        self.string_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_param(&mut self, v: ::std::string::String) {
        self.string_param = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_param(&mut self) -> &mut ::std::string::String {
        if self.string_param.is_none() {
            self.string_param = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_param(&mut self) -> ::std::string::String {
        self.string_param.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string string_param2 = 12;

    pub fn string_param2(&self) -> &str {
        match self.string_param2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_param2(&mut self) {
        self.string_param2 = ::std::option::Option::None;
    }

    pub fn has_string_param2(&self) -> bool {
        self.string_param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_param2(&mut self, v: ::std::string::String) {
        self.string_param2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_param2(&mut self) -> &mut ::std::string::String {
        if self.string_param2.is_none() {
            self.string_param2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_param2.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_param2(&mut self) -> ::std::string::String {
        self.string_param2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tip_text_override = 13;

    pub fn tip_text_override(&self) -> &str {
        match self.tip_text_override.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tip_text_override(&mut self) {
        self.tip_text_override = ::std::option::Option::None;
    }

    pub fn has_tip_text_override(&self) -> bool {
        self.tip_text_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_text_override(&mut self, v: ::std::string::String) {
        self.tip_text_override = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_text_override(&mut self) -> &mut ::std::string::String {
        if self.tip_text_override.is_none() {
            self.tip_text_override = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tip_text_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_text_override(&mut self) -> ::std::string::String {
        self.tip_text_override.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tip_annotation_override = 14;

    pub fn tip_annotation_override(&self) -> &str {
        match self.tip_annotation_override.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tip_annotation_override(&mut self) {
        self.tip_annotation_override = ::std::option::Option::None;
    }

    pub fn has_tip_annotation_override(&self) -> bool {
        self.tip_annotation_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_annotation_override(&mut self, v: ::std::string::String) {
        self.tip_annotation_override = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_annotation_override(&mut self) -> &mut ::std::string::String {
        if self.tip_annotation_override.is_none() {
            self.tip_annotation_override = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tip_annotation_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_annotation_override(&mut self) -> ::std::string::String {
        self.tip_annotation_override.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string panorama_snippet = 15;

    pub fn panorama_snippet(&self) -> &str {
        match self.panorama_snippet.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_panorama_snippet(&mut self) {
        self.panorama_snippet = ::std::option::Option::None;
    }

    pub fn has_panorama_snippet(&self) -> bool {
        self.panorama_snippet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_panorama_snippet(&mut self, v: ::std::string::String) {
        self.panorama_snippet = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_panorama_snippet(&mut self) -> &mut ::std::string::String {
        if self.panorama_snippet.is_none() {
            self.panorama_snippet = ::std::option::Option::Some(::std::string::String::new());
        }
        self.panorama_snippet.as_mut().unwrap()
    }

    // Take field
    pub fn take_panorama_snippet(&mut self) -> ::std::string::String {
        self.panorama_snippet.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tip_id",
            |m: &CDOTAUserMsg_ContextualTip| { &m.tip_id },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.tip_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "referenced_abilities",
            |m: &CDOTAUserMsg_ContextualTip| { &m.referenced_abilities },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.referenced_abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "referenced_units",
            |m: &CDOTAUserMsg_ContextualTip| { &m.referenced_units },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.referenced_units },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "panorama_classes",
            |m: &CDOTAUserMsg_ContextualTip| { &m.panorama_classes },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.panorama_classes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_annotation",
            |m: &CDOTAUserMsg_ContextualTip| { &m.force_annotation },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.force_annotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "variant",
            |m: &CDOTAUserMsg_ContextualTip| { &m.variant },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.variant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_param",
            |m: &CDOTAUserMsg_ContextualTip| { &m.int_param },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.int_param },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_param2",
            |m: &CDOTAUserMsg_ContextualTip| { &m.int_param2 },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.int_param2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "float_param",
            |m: &CDOTAUserMsg_ContextualTip| { &m.float_param },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.float_param },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "float_param2",
            |m: &CDOTAUserMsg_ContextualTip| { &m.float_param2 },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.float_param2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_param",
            |m: &CDOTAUserMsg_ContextualTip| { &m.string_param },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.string_param },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_param2",
            |m: &CDOTAUserMsg_ContextualTip| { &m.string_param2 },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.string_param2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tip_text_override",
            |m: &CDOTAUserMsg_ContextualTip| { &m.tip_text_override },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.tip_text_override },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tip_annotation_override",
            |m: &CDOTAUserMsg_ContextualTip| { &m.tip_annotation_override },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.tip_annotation_override },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "panorama_snippet",
            |m: &CDOTAUserMsg_ContextualTip| { &m.panorama_snippet },
            |m: &mut CDOTAUserMsg_ContextualTip| { &mut m.panorama_snippet },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ContextualTip>(
            "CDOTAUserMsg_ContextualTip",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ContextualTip {
    const NAME: &'static str = "CDOTAUserMsg_ContextualTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tip_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.referenced_abilities.push(is.read_string()?);
                },
                26 => {
                    self.referenced_units.push(is.read_string()?);
                },
                34 => {
                    self.panorama_classes.push(is.read_string()?);
                },
                40 => {
                    self.force_annotation = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.variant = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.int_param = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.int_param2 = ::std::option::Option::Some(is.read_int32()?);
                },
                77 => {
                    self.float_param = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.float_param2 = ::std::option::Option::Some(is.read_float()?);
                },
                90 => {
                    self.string_param = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.string_param2 = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.tip_text_override = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.tip_annotation_override = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.panorama_snippet = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tip_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.referenced_abilities {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.referenced_units {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.panorama_classes {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.force_annotation {
            my_size += 1 + 1;
        }
        if let Some(v) = self.variant {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.int_param {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.int_param2 {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.float_param {
            my_size += 1 + 4;
        }
        if let Some(v) = self.float_param2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.string_param.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.string_param2.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.tip_text_override.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.tip_annotation_override.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.panorama_snippet.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tip_id {
            os.write_int32(1, v)?;
        }
        for v in &self.referenced_abilities {
            os.write_string(2, &v)?;
        };
        for v in &self.referenced_units {
            os.write_string(3, &v)?;
        };
        for v in &self.panorama_classes {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.force_annotation {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.variant {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.int_param {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.int_param2 {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.float_param {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.float_param2 {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.string_param.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.string_param2.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.tip_text_override.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.tip_annotation_override.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.panorama_snippet.as_ref() {
            os.write_string(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ContextualTip {
        CDOTAUserMsg_ContextualTip::new()
    }

    fn clear(&mut self) {
        self.tip_id = ::std::option::Option::None;
        self.referenced_abilities.clear();
        self.referenced_units.clear();
        self.panorama_classes.clear();
        self.force_annotation = ::std::option::Option::None;
        self.variant = ::std::option::Option::None;
        self.int_param = ::std::option::Option::None;
        self.int_param2 = ::std::option::Option::None;
        self.float_param = ::std::option::Option::None;
        self.float_param2 = ::std::option::Option::None;
        self.string_param = ::std::option::Option::None;
        self.string_param2 = ::std::option::Option::None;
        self.tip_text_override = ::std::option::Option::None;
        self.tip_annotation_override = ::std::option::Option::None;
        self.panorama_snippet = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ContextualTip {
        static instance: CDOTAUserMsg_ContextualTip = CDOTAUserMsg_ContextualTip {
            tip_id: ::std::option::Option::None,
            referenced_abilities: ::std::vec::Vec::new(),
            referenced_units: ::std::vec::Vec::new(),
            panorama_classes: ::std::vec::Vec::new(),
            force_annotation: ::std::option::Option::None,
            variant: ::std::option::Option::None,
            int_param: ::std::option::Option::None,
            int_param2: ::std::option::Option::None,
            float_param: ::std::option::Option::None,
            float_param2: ::std::option::Option::None,
            string_param: ::std::option::Option::None,
            string_param2: ::std::option::Option::None,
            tip_text_override: ::std::option::Option::None,
            tip_annotation_override: ::std::option::Option::None,
            panorama_snippet: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ContextualTip {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ContextualTip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ContextualTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ContextualTip {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_ChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ChatMessage {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatMessage.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatMessage.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_ChatMessage.message_text)
    pub message_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_ChatMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ChatMessage {
    fn default() -> &'a CDOTAUserMsg_ChatMessage {
        <CDOTAUserMsg_ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ChatMessage {
    pub fn new() -> CDOTAUserMsg_ChatMessage {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(0)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_type = 2;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional string message_text = 3;

    pub fn message_text(&self) -> &str {
        match self.message_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_text(&mut self) {
        self.message_text = ::std::option::Option::None;
    }

    pub fn has_message_text(&self) -> bool {
        self.message_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_text(&mut self, v: ::std::string::String) {
        self.message_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_text(&mut self) -> &mut ::std::string::String {
        if self.message_text.is_none() {
            self.message_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_text(&mut self) -> ::std::string::String {
        self.message_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_player_id",
            |m: &CDOTAUserMsg_ChatMessage| { &m.source_player_id },
            |m: &mut CDOTAUserMsg_ChatMessage| { &mut m.source_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_type",
            |m: &CDOTAUserMsg_ChatMessage| { &m.channel_type },
            |m: &mut CDOTAUserMsg_ChatMessage| { &mut m.channel_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_text",
            |m: &CDOTAUserMsg_ChatMessage| { &m.message_text },
            |m: &mut CDOTAUserMsg_ChatMessage| { &mut m.message_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_ChatMessage>(
            "CDOTAUserMsg_ChatMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ChatMessage {
    const NAME: &'static str = "CDOTAUserMsg_ChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.message_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.message_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.message_text.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ChatMessage {
        CDOTAUserMsg_ChatMessage::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.channel_type = ::std::option::Option::None;
        self.message_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ChatMessage {
        static instance: CDOTAUserMsg_ChatMessage = CDOTAUserMsg_ChatMessage {
            source_player_id: ::std::option::Option::None,
            channel_type: ::std::option::Option::None,
            message_text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_ChatMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_ChatMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ChatMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_RockPaperScissorsStarted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_RockPaperScissorsStarted {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RockPaperScissorsStarted.player_id_source)
    pub player_id_source: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RockPaperScissorsStarted.player_id_target)
    pub player_id_target: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_RockPaperScissorsStarted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_RockPaperScissorsStarted {
    fn default() -> &'a CDOTAUserMsg_RockPaperScissorsStarted {
        <CDOTAUserMsg_RockPaperScissorsStarted as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_RockPaperScissorsStarted {
    pub fn new() -> CDOTAUserMsg_RockPaperScissorsStarted {
        ::std::default::Default::default()
    }

    // optional int32 player_id_source = 1;

    pub fn player_id_source(&self) -> i32 {
        self.player_id_source.unwrap_or(0)
    }

    pub fn clear_player_id_source(&mut self) {
        self.player_id_source = ::std::option::Option::None;
    }

    pub fn has_player_id_source(&self) -> bool {
        self.player_id_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_source(&mut self, v: i32) {
        self.player_id_source = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_target = 2;

    pub fn player_id_target(&self) -> i32 {
        self.player_id_target.unwrap_or(0)
    }

    pub fn clear_player_id_target(&mut self) {
        self.player_id_target = ::std::option::Option::None;
    }

    pub fn has_player_id_target(&self) -> bool {
        self.player_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_target(&mut self, v: i32) {
        self.player_id_target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_source",
            |m: &CDOTAUserMsg_RockPaperScissorsStarted| { &m.player_id_source },
            |m: &mut CDOTAUserMsg_RockPaperScissorsStarted| { &mut m.player_id_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_target",
            |m: &CDOTAUserMsg_RockPaperScissorsStarted| { &m.player_id_target },
            |m: &mut CDOTAUserMsg_RockPaperScissorsStarted| { &mut m.player_id_target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_RockPaperScissorsStarted>(
            "CDOTAUserMsg_RockPaperScissorsStarted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_RockPaperScissorsStarted {
    const NAME: &'static str = "CDOTAUserMsg_RockPaperScissorsStarted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_source = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_target = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_source {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_target {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_source {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_target {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_RockPaperScissorsStarted {
        CDOTAUserMsg_RockPaperScissorsStarted::new()
    }

    fn clear(&mut self) {
        self.player_id_source = ::std::option::Option::None;
        self.player_id_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_RockPaperScissorsStarted {
        static instance: CDOTAUserMsg_RockPaperScissorsStarted = CDOTAUserMsg_RockPaperScissorsStarted {
            player_id_source: ::std::option::Option::None,
            player_id_target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_RockPaperScissorsStarted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_RockPaperScissorsStarted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_RockPaperScissorsStarted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_RockPaperScissorsStarted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_RockPaperScissorsFinished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_RockPaperScissorsFinished {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RockPaperScissorsFinished.player_id_1)
    pub player_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RockPaperScissorsFinished.player_id_2)
    pub player_id_2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RockPaperScissorsFinished.player_1_choice)
    pub player_1_choice: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_RockPaperScissorsFinished.player_2_choice)
    pub player_2_choice: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_RockPaperScissorsFinished.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_RockPaperScissorsFinished {
    fn default() -> &'a CDOTAUserMsg_RockPaperScissorsFinished {
        <CDOTAUserMsg_RockPaperScissorsFinished as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_RockPaperScissorsFinished {
    pub fn new() -> CDOTAUserMsg_RockPaperScissorsFinished {
        ::std::default::Default::default()
    }

    // optional int32 player_id_1 = 1;

    pub fn player_id_1(&self) -> i32 {
        self.player_id_1.unwrap_or(0)
    }

    pub fn clear_player_id_1(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
    }

    pub fn has_player_id_1(&self) -> bool {
        self.player_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_1(&mut self, v: i32) {
        self.player_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_2 = 2;

    pub fn player_id_2(&self) -> i32 {
        self.player_id_2.unwrap_or(0)
    }

    pub fn clear_player_id_2(&mut self) {
        self.player_id_2 = ::std::option::Option::None;
    }

    pub fn has_player_id_2(&self) -> bool {
        self.player_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_2(&mut self, v: i32) {
        self.player_id_2 = ::std::option::Option::Some(v);
    }

    // optional int32 player_1_choice = 3;

    pub fn player_1_choice(&self) -> i32 {
        self.player_1_choice.unwrap_or(0)
    }

    pub fn clear_player_1_choice(&mut self) {
        self.player_1_choice = ::std::option::Option::None;
    }

    pub fn has_player_1_choice(&self) -> bool {
        self.player_1_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_1_choice(&mut self, v: i32) {
        self.player_1_choice = ::std::option::Option::Some(v);
    }

    // optional int32 player_2_choice = 4;

    pub fn player_2_choice(&self) -> i32 {
        self.player_2_choice.unwrap_or(0)
    }

    pub fn clear_player_2_choice(&mut self) {
        self.player_2_choice = ::std::option::Option::None;
    }

    pub fn has_player_2_choice(&self) -> bool {
        self.player_2_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_2_choice(&mut self, v: i32) {
        self.player_2_choice = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_1",
            |m: &CDOTAUserMsg_RockPaperScissorsFinished| { &m.player_id_1 },
            |m: &mut CDOTAUserMsg_RockPaperScissorsFinished| { &mut m.player_id_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_2",
            |m: &CDOTAUserMsg_RockPaperScissorsFinished| { &m.player_id_2 },
            |m: &mut CDOTAUserMsg_RockPaperScissorsFinished| { &mut m.player_id_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_1_choice",
            |m: &CDOTAUserMsg_RockPaperScissorsFinished| { &m.player_1_choice },
            |m: &mut CDOTAUserMsg_RockPaperScissorsFinished| { &mut m.player_1_choice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_2_choice",
            |m: &CDOTAUserMsg_RockPaperScissorsFinished| { &m.player_2_choice },
            |m: &mut CDOTAUserMsg_RockPaperScissorsFinished| { &mut m.player_2_choice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_RockPaperScissorsFinished>(
            "CDOTAUserMsg_RockPaperScissorsFinished",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_RockPaperScissorsFinished {
    const NAME: &'static str = "CDOTAUserMsg_RockPaperScissorsFinished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_2 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.player_1_choice = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.player_2_choice = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_1 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_2 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.player_1_choice {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.player_2_choice {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_2 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.player_1_choice {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.player_2_choice {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_RockPaperScissorsFinished {
        CDOTAUserMsg_RockPaperScissorsFinished::new()
    }

    fn clear(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
        self.player_id_2 = ::std::option::Option::None;
        self.player_1_choice = ::std::option::Option::None;
        self.player_2_choice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_RockPaperScissorsFinished {
        static instance: CDOTAUserMsg_RockPaperScissorsFinished = CDOTAUserMsg_RockPaperScissorsFinished {
            player_id_1: ::std::option::Option::None,
            player_id_2: ::std::option::Option::None,
            player_1_choice: ::std::option::Option::None,
            player_2_choice: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_RockPaperScissorsFinished {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_RockPaperScissorsFinished").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_RockPaperScissorsFinished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_RockPaperScissorsFinished {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_DuelOpponentKilled)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DuelOpponentKilled {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DuelOpponentKilled.player_id_winner)
    pub player_id_winner: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DuelOpponentKilled.player_id_loser)
    pub player_id_loser: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_DuelOpponentKilled.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DuelOpponentKilled {
    fn default() -> &'a CDOTAUserMsg_DuelOpponentKilled {
        <CDOTAUserMsg_DuelOpponentKilled as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DuelOpponentKilled {
    pub fn new() -> CDOTAUserMsg_DuelOpponentKilled {
        ::std::default::Default::default()
    }

    // optional int32 player_id_winner = 1;

    pub fn player_id_winner(&self) -> i32 {
        self.player_id_winner.unwrap_or(0)
    }

    pub fn clear_player_id_winner(&mut self) {
        self.player_id_winner = ::std::option::Option::None;
    }

    pub fn has_player_id_winner(&self) -> bool {
        self.player_id_winner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_winner(&mut self, v: i32) {
        self.player_id_winner = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_loser = 2;

    pub fn player_id_loser(&self) -> i32 {
        self.player_id_loser.unwrap_or(0)
    }

    pub fn clear_player_id_loser(&mut self) {
        self.player_id_loser = ::std::option::Option::None;
    }

    pub fn has_player_id_loser(&self) -> bool {
        self.player_id_loser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_loser(&mut self, v: i32) {
        self.player_id_loser = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_winner",
            |m: &CDOTAUserMsg_DuelOpponentKilled| { &m.player_id_winner },
            |m: &mut CDOTAUserMsg_DuelOpponentKilled| { &mut m.player_id_winner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_loser",
            |m: &CDOTAUserMsg_DuelOpponentKilled| { &m.player_id_loser },
            |m: &mut CDOTAUserMsg_DuelOpponentKilled| { &mut m.player_id_loser },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_DuelOpponentKilled>(
            "CDOTAUserMsg_DuelOpponentKilled",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DuelOpponentKilled {
    const NAME: &'static str = "CDOTAUserMsg_DuelOpponentKilled";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_winner = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_loser = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_winner {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_loser {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_winner {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_loser {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DuelOpponentKilled {
        CDOTAUserMsg_DuelOpponentKilled::new()
    }

    fn clear(&mut self) {
        self.player_id_winner = ::std::option::Option::None;
        self.player_id_loser = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DuelOpponentKilled {
        static instance: CDOTAUserMsg_DuelOpponentKilled = CDOTAUserMsg_DuelOpponentKilled {
            player_id_winner: ::std::option::Option::None,
            player_id_loser: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_DuelOpponentKilled {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_DuelOpponentKilled").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_DuelOpponentKilled {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DuelOpponentKilled {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_DuelAccepted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DuelAccepted {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DuelAccepted.player_id_1)
    pub player_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DuelAccepted.player_id_2)
    pub player_id_2: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_DuelAccepted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DuelAccepted {
    fn default() -> &'a CDOTAUserMsg_DuelAccepted {
        <CDOTAUserMsg_DuelAccepted as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DuelAccepted {
    pub fn new() -> CDOTAUserMsg_DuelAccepted {
        ::std::default::Default::default()
    }

    // optional int32 player_id_1 = 1;

    pub fn player_id_1(&self) -> i32 {
        self.player_id_1.unwrap_or(0)
    }

    pub fn clear_player_id_1(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
    }

    pub fn has_player_id_1(&self) -> bool {
        self.player_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_1(&mut self, v: i32) {
        self.player_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_2 = 2;

    pub fn player_id_2(&self) -> i32 {
        self.player_id_2.unwrap_or(0)
    }

    pub fn clear_player_id_2(&mut self) {
        self.player_id_2 = ::std::option::Option::None;
    }

    pub fn has_player_id_2(&self) -> bool {
        self.player_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_2(&mut self, v: i32) {
        self.player_id_2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_1",
            |m: &CDOTAUserMsg_DuelAccepted| { &m.player_id_1 },
            |m: &mut CDOTAUserMsg_DuelAccepted| { &mut m.player_id_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_2",
            |m: &CDOTAUserMsg_DuelAccepted| { &m.player_id_2 },
            |m: &mut CDOTAUserMsg_DuelAccepted| { &mut m.player_id_2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_DuelAccepted>(
            "CDOTAUserMsg_DuelAccepted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DuelAccepted {
    const NAME: &'static str = "CDOTAUserMsg_DuelAccepted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_2 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_1 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_2 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_2 {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DuelAccepted {
        CDOTAUserMsg_DuelAccepted::new()
    }

    fn clear(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
        self.player_id_2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DuelAccepted {
        static instance: CDOTAUserMsg_DuelAccepted = CDOTAUserMsg_DuelAccepted {
            player_id_1: ::std::option::Option::None,
            player_id_2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_DuelAccepted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_DuelAccepted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_DuelAccepted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DuelAccepted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_DuelRequested)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DuelRequested {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_DuelRequested.player_id_requestor)
    pub player_id_requestor: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_DuelRequested.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DuelRequested {
    fn default() -> &'a CDOTAUserMsg_DuelRequested {
        <CDOTAUserMsg_DuelRequested as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DuelRequested {
    pub fn new() -> CDOTAUserMsg_DuelRequested {
        ::std::default::Default::default()
    }

    // optional int32 player_id_requestor = 1;

    pub fn player_id_requestor(&self) -> i32 {
        self.player_id_requestor.unwrap_or(0)
    }

    pub fn clear_player_id_requestor(&mut self) {
        self.player_id_requestor = ::std::option::Option::None;
    }

    pub fn has_player_id_requestor(&self) -> bool {
        self.player_id_requestor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_requestor(&mut self, v: i32) {
        self.player_id_requestor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_requestor",
            |m: &CDOTAUserMsg_DuelRequested| { &m.player_id_requestor },
            |m: &mut CDOTAUserMsg_DuelRequested| { &mut m.player_id_requestor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_DuelRequested>(
            "CDOTAUserMsg_DuelRequested",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DuelRequested {
    const NAME: &'static str = "CDOTAUserMsg_DuelRequested";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_requestor = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_requestor {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_requestor {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DuelRequested {
        CDOTAUserMsg_DuelRequested::new()
    }

    fn clear(&mut self) {
        self.player_id_requestor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DuelRequested {
        static instance: CDOTAUserMsg_DuelRequested = CDOTAUserMsg_DuelRequested {
            player_id_requestor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_DuelRequested {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_DuelRequested").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_DuelRequested {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DuelRequested {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.player_id_killer)
    pub player_id_killer: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.player_id_target)
    pub player_id_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.points)
    pub points: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.points_total)
    pub points_total: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.last_hit)
    pub last_hit: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    fn default() -> &'a CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
        <CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    pub fn new() -> CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
        ::std::default::Default::default()
    }

    // required int32 player_id_killer = 1;

    pub fn player_id_killer(&self) -> i32 {
        self.player_id_killer.unwrap_or(0)
    }

    pub fn clear_player_id_killer(&mut self) {
        self.player_id_killer = ::std::option::Option::None;
    }

    pub fn has_player_id_killer(&self) -> bool {
        self.player_id_killer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_killer(&mut self, v: i32) {
        self.player_id_killer = ::std::option::Option::Some(v);
    }

    // required int32 player_id_target = 2;

    pub fn player_id_target(&self) -> i32 {
        self.player_id_target.unwrap_or(0)
    }

    pub fn clear_player_id_target(&mut self) {
        self.player_id_target = ::std::option::Option::None;
    }

    pub fn has_player_id_target(&self) -> bool {
        self.player_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_target(&mut self, v: i32) {
        self.player_id_target = ::std::option::Option::Some(v);
    }

    // required int32 points = 3;

    pub fn points(&self) -> i32 {
        self.points.unwrap_or(0)
    }

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: i32) {
        self.points = ::std::option::Option::Some(v);
    }

    // required int32 points_total = 4;

    pub fn points_total(&self) -> i32 {
        self.points_total.unwrap_or(0)
    }

    pub fn clear_points_total(&mut self) {
        self.points_total = ::std::option::Option::None;
    }

    pub fn has_points_total(&self) -> bool {
        self.points_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_total(&mut self, v: i32) {
        self.points_total = ::std::option::Option::Some(v);
    }

    // required bool last_hit = 5;

    pub fn last_hit(&self) -> bool {
        self.last_hit.unwrap_or(false)
    }

    pub fn clear_last_hit(&mut self) {
        self.last_hit = ::std::option::Option::None;
    }

    pub fn has_last_hit(&self) -> bool {
        self.last_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hit(&mut self, v: bool) {
        self.last_hit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_killer",
            |m: &CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &m.player_id_killer },
            |m: &mut CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &mut m.player_id_killer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_target",
            |m: &CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &m.player_id_target },
            |m: &mut CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &mut m.player_id_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points",
            |m: &CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &m.points },
            |m: &mut CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &mut m.points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_total",
            |m: &CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &m.points_total },
            |m: &mut CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &mut m.points_total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_hit",
            |m: &CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &m.last_hit },
            |m: &mut CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled| { &mut m.last_hit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled>(
            "CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    const NAME: &'static str = "CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled";

    fn is_initialized(&self) -> bool {
        if self.player_id_killer.is_none() {
            return false;
        }
        if self.player_id_target.is_none() {
            return false;
        }
        if self.points.is_none() {
            return false;
        }
        if self.points_total.is_none() {
            return false;
        }
        if self.last_hit.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_killer = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.points = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.points_total = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.last_hit = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_killer {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_target {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.points_total {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.last_hit {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_killer {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.points_total {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.last_hit {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
        CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled::new()
    }

    fn clear(&mut self) {
        self.player_id_killer = ::std::option::Option::None;
        self.player_id_target = ::std::option::Option::None;
        self.points = ::std::option::Option::None;
        self.points_total = ::std::option::Option::None;
        self.last_hit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
        static instance: CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled = CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
            player_id_killer: ::std::option::Option::None,
            player_id_target: ::std::option::Option::None,
            points: ::std::option::Option::None,
            points_total: ::std::option::Option::None,
            last_hit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_PlayerDraftSuggestPick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PlayerDraftSuggestPick {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PlayerDraftSuggestPick.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PlayerDraftSuggestPick.suggestion_player_id)
    pub suggestion_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_PlayerDraftSuggestPick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PlayerDraftSuggestPick {
    fn default() -> &'a CDOTAUserMsg_PlayerDraftSuggestPick {
        <CDOTAUserMsg_PlayerDraftSuggestPick as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PlayerDraftSuggestPick {
    pub fn new() -> CDOTAUserMsg_PlayerDraftSuggestPick {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 suggestion_player_id = 2;

    pub fn suggestion_player_id(&self) -> i32 {
        self.suggestion_player_id.unwrap_or(0)
    }

    pub fn clear_suggestion_player_id(&mut self) {
        self.suggestion_player_id = ::std::option::Option::None;
    }

    pub fn has_suggestion_player_id(&self) -> bool {
        self.suggestion_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suggestion_player_id(&mut self, v: i32) {
        self.suggestion_player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &CDOTAUserMsg_PlayerDraftSuggestPick| { &m.player_id },
            |m: &mut CDOTAUserMsg_PlayerDraftSuggestPick| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suggestion_player_id",
            |m: &CDOTAUserMsg_PlayerDraftSuggestPick| { &m.suggestion_player_id },
            |m: &mut CDOTAUserMsg_PlayerDraftSuggestPick| { &mut m.suggestion_player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_PlayerDraftSuggestPick>(
            "CDOTAUserMsg_PlayerDraftSuggestPick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_PlayerDraftSuggestPick {
    const NAME: &'static str = "CDOTAUserMsg_PlayerDraftSuggestPick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.suggestion_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.suggestion_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.suggestion_player_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PlayerDraftSuggestPick {
        CDOTAUserMsg_PlayerDraftSuggestPick::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.suggestion_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PlayerDraftSuggestPick {
        static instance: CDOTAUserMsg_PlayerDraftSuggestPick = CDOTAUserMsg_PlayerDraftSuggestPick {
            player_id: ::std::option::Option::None,
            suggestion_player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_PlayerDraftSuggestPick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_PlayerDraftSuggestPick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_PlayerDraftSuggestPick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PlayerDraftSuggestPick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CDOTAUserMsg_PlayerDraftPick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PlayerDraftPick {
    // message fields
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PlayerDraftPick.player_id_captain)
    pub player_id_captain: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PlayerDraftPick.player_id_target)
    pub player_id_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CDOTAUserMsg_PlayerDraftPick.team)
    pub team: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CDOTAUserMsg_PlayerDraftPick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PlayerDraftPick {
    fn default() -> &'a CDOTAUserMsg_PlayerDraftPick {
        <CDOTAUserMsg_PlayerDraftPick as ::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PlayerDraftPick {
    pub fn new() -> CDOTAUserMsg_PlayerDraftPick {
        ::std::default::Default::default()
    }

    // optional int32 player_id_captain = 1;

    pub fn player_id_captain(&self) -> i32 {
        self.player_id_captain.unwrap_or(0)
    }

    pub fn clear_player_id_captain(&mut self) {
        self.player_id_captain = ::std::option::Option::None;
    }

    pub fn has_player_id_captain(&self) -> bool {
        self.player_id_captain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_captain(&mut self, v: i32) {
        self.player_id_captain = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_target = 2;

    pub fn player_id_target(&self) -> i32 {
        self.player_id_target.unwrap_or(0)
    }

    pub fn clear_player_id_target(&mut self) {
        self.player_id_target = ::std::option::Option::None;
    }

    pub fn has_player_id_target(&self) -> bool {
        self.player_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_target(&mut self, v: i32) {
        self.player_id_target = ::std::option::Option::Some(v);
    }

    // optional int32 team = 3;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_captain",
            |m: &CDOTAUserMsg_PlayerDraftPick| { &m.player_id_captain },
            |m: &mut CDOTAUserMsg_PlayerDraftPick| { &mut m.player_id_captain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id_target",
            |m: &CDOTAUserMsg_PlayerDraftPick| { &m.player_id_target },
            |m: &mut CDOTAUserMsg_PlayerDraftPick| { &mut m.player_id_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CDOTAUserMsg_PlayerDraftPick| { &m.team },
            |m: &mut CDOTAUserMsg_PlayerDraftPick| { &mut m.team },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDOTAUserMsg_PlayerDraftPick>(
            "CDOTAUserMsg_PlayerDraftPick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDOTAUserMsg_PlayerDraftPick {
    const NAME: &'static str = "CDOTAUserMsg_PlayerDraftPick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_captain = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_captain {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_target {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id_captain {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PlayerDraftPick {
        CDOTAUserMsg_PlayerDraftPick::new()
    }

    fn clear(&mut self) {
        self.player_id_captain = ::std::option::Option::None;
        self.player_id_target = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PlayerDraftPick {
        static instance: CDOTAUserMsg_PlayerDraftPick = CDOTAUserMsg_PlayerDraftPick {
            player_id_captain: ::std::option::Option::None,
            player_id_target: ::std::option::Option::None,
            team: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDOTAUserMsg_PlayerDraftPick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDOTAUserMsg_PlayerDraftPick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDOTAUserMsg_PlayerDraftPick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PlayerDraftPick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDotaUserMessages)
pub enum EDotaUserMessages {
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_AddUnitToSelection)
    DOTA_UM_AddUnitToSelection = 464,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_AIDebugLine)
    DOTA_UM_AIDebugLine = 465,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ChatEvent)
    DOTA_UM_ChatEvent = 466,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CombatHeroPositions)
    DOTA_UM_CombatHeroPositions = 467,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CombatLogData)
    DOTA_UM_CombatLogData = 468,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CombatLogBulkData)
    DOTA_UM_CombatLogBulkData = 470,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CreateLinearProjectile)
    DOTA_UM_CreateLinearProjectile = 471,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_DestroyLinearProjectile)
    DOTA_UM_DestroyLinearProjectile = 472,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_DodgeTrackingProjectiles)
    DOTA_UM_DodgeTrackingProjectiles = 473,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_GlobalLightColor)
    DOTA_UM_GlobalLightColor = 474,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_GlobalLightDirection)
    DOTA_UM_GlobalLightDirection = 475,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_InvalidCommand)
    DOTA_UM_InvalidCommand = 476,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_LocationPing)
    DOTA_UM_LocationPing = 477,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MapLine)
    DOTA_UM_MapLine = 478,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MiniKillCamInfo)
    DOTA_UM_MiniKillCamInfo = 479,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MinimapDebugPoint)
    DOTA_UM_MinimapDebugPoint = 480,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MinimapEvent)
    DOTA_UM_MinimapEvent = 481,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_NevermoreRequiem)
    DOTA_UM_NevermoreRequiem = 482,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_OverheadEvent)
    DOTA_UM_OverheadEvent = 483,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SetNextAutobuyItem)
    DOTA_UM_SetNextAutobuyItem = 484,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SharedCooldown)
    DOTA_UM_SharedCooldown = 485,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SpectatorPlayerClick)
    DOTA_UM_SpectatorPlayerClick = 486,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TutorialTipInfo)
    DOTA_UM_TutorialTipInfo = 487,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_UnitEvent)
    DOTA_UM_UnitEvent = 488,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ParticleManager)
    DOTA_UM_ParticleManager = 489,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_BotChat)
    DOTA_UM_BotChat = 490,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_HudError)
    DOTA_UM_HudError = 491,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ItemPurchased)
    DOTA_UM_ItemPurchased = 492,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_Ping)
    DOTA_UM_Ping = 493,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ItemFound)
    DOTA_UM_ItemFound = 494,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CharacterSpeakConcept)
    DOTA_UM_CharacterSpeakConcept = 495,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SwapVerify)
    DOTA_UM_SwapVerify = 496,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_WorldLine)
    DOTA_UM_WorldLine = 497,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TournamentDrop)
    DOTA_UM_TournamentDrop = 498,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ItemAlert)
    DOTA_UM_ItemAlert = 499,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_HalloweenDrops)
    DOTA_UM_HalloweenDrops = 500,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ChatWheel)
    DOTA_UM_ChatWheel = 501,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ReceivedXmasGift)
    DOTA_UM_ReceivedXmasGift = 502,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_UpdateSharedContent)
    DOTA_UM_UpdateSharedContent = 503,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TutorialRequestExp)
    DOTA_UM_TutorialRequestExp = 504,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TutorialPingMinimap)
    DOTA_UM_TutorialPingMinimap = 505,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_GamerulesStateChanged)
    DOTA_UM_GamerulesStateChanged = 506,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ShowSurvey)
    DOTA_UM_ShowSurvey = 507,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TutorialFade)
    DOTA_UM_TutorialFade = 508,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_AddQuestLogEntry)
    DOTA_UM_AddQuestLogEntry = 509,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SendStatPopup)
    DOTA_UM_SendStatPopup = 510,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TutorialFinish)
    DOTA_UM_TutorialFinish = 511,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SendRoshanPopup)
    DOTA_UM_SendRoshanPopup = 512,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SendGenericToolTip)
    DOTA_UM_SendGenericToolTip = 513,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SendFinalGold)
    DOTA_UM_SendFinalGold = 514,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CustomMsg)
    DOTA_UM_CustomMsg = 515,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CoachHUDPing)
    DOTA_UM_CoachHUDPing = 516,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ClientLoadGridNav)
    DOTA_UM_ClientLoadGridNav = 517,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TE_Projectile)
    DOTA_UM_TE_Projectile = 518,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TE_ProjectileLoc)
    DOTA_UM_TE_ProjectileLoc = 519,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TE_DotaBloodImpact)
    DOTA_UM_TE_DotaBloodImpact = 520,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TE_UnitAnimation)
    DOTA_UM_TE_UnitAnimation = 521,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TE_UnitAnimationEnd)
    DOTA_UM_TE_UnitAnimationEnd = 522,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_AbilityPing)
    DOTA_UM_AbilityPing = 523,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ShowGenericPopup)
    DOTA_UM_ShowGenericPopup = 524,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_VoteStart)
    DOTA_UM_VoteStart = 525,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_VoteUpdate)
    DOTA_UM_VoteUpdate = 526,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_VoteEnd)
    DOTA_UM_VoteEnd = 527,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_BoosterState)
    DOTA_UM_BoosterState = 528,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_WillPurchaseAlert)
    DOTA_UM_WillPurchaseAlert = 529,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TutorialMinimapPosition)
    DOTA_UM_TutorialMinimapPosition = 530,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_PlayerMMR)
    DOTA_UM_PlayerMMR = 531,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_AbilitySteal)
    DOTA_UM_AbilitySteal = 532,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CourierKilledAlert)
    DOTA_UM_CourierKilledAlert = 533,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_EnemyItemAlert)
    DOTA_UM_EnemyItemAlert = 534,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_StatsMatchDetails)
    DOTA_UM_StatsMatchDetails = 535,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MiniTaunt)
    DOTA_UM_MiniTaunt = 536,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_BuyBackStateAlert)
    DOTA_UM_BuyBackStateAlert = 537,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SpeechBubble)
    DOTA_UM_SpeechBubble = 538,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CustomHeaderMessage)
    DOTA_UM_CustomHeaderMessage = 539,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_QuickBuyAlert)
    DOTA_UM_QuickBuyAlert = 540,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_StatsHeroDetails)
    DOTA_UM_StatsHeroDetails = 541,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_PredictionResult)
    DOTA_UM_PredictionResult = 542,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ModifierAlert)
    DOTA_UM_ModifierAlert = 543,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_HPManaAlert)
    DOTA_UM_HPManaAlert = 544,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_GlyphAlert)
    DOTA_UM_GlyphAlert = 545,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_BeastChat)
    DOTA_UM_BeastChat = 546,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SpectatorPlayerUnitOrders)
    DOTA_UM_SpectatorPlayerUnitOrders = 547,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CustomHudElement_Create)
    DOTA_UM_CustomHudElement_Create = 548,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CustomHudElement_Modify)
    DOTA_UM_CustomHudElement_Modify = 549,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CustomHudElement_Destroy)
    DOTA_UM_CustomHudElement_Destroy = 550,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CompendiumState)
    DOTA_UM_CompendiumState = 551,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ProjectionAbility)
    DOTA_UM_ProjectionAbility = 552,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ProjectionEvent)
    DOTA_UM_ProjectionEvent = 553,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_CombatLogDataHLTV)
    DOTA_UM_CombatLogDataHLTV = 554,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_XPAlert)
    DOTA_UM_XPAlert = 555,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_UpdateQuestProgress)
    DOTA_UM_UpdateQuestProgress = 556,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MatchMetadata)
    DOTA_UM_MatchMetadata = 557,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MatchDetails)
    DOTA_UM_MatchDetails = 558,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_QuestStatus)
    DOTA_UM_QuestStatus = 559,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SuggestHeroPick)
    DOTA_UM_SuggestHeroPick = 560,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SuggestHeroRole)
    DOTA_UM_SuggestHeroRole = 561,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_KillcamDamageTaken)
    DOTA_UM_KillcamDamageTaken = 562,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SelectPenaltyGold)
    DOTA_UM_SelectPenaltyGold = 563,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_RollDiceResult)
    DOTA_UM_RollDiceResult = 564,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_FlipCoinResult)
    DOTA_UM_FlipCoinResult = 565,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_RequestItemSuggestions)
    DOTA_UM_RequestItemSuggestions = 566,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TeamCaptainChanged)
    DOTA_UM_TeamCaptainChanged = 567,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SendRoshanSpectatorPhase)
    DOTA_UM_SendRoshanSpectatorPhase = 568,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ChatWheelCooldown)
    DOTA_UM_ChatWheelCooldown = 569,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_DismissAllStatPopups)
    DOTA_UM_DismissAllStatPopups = 570,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TE_DestroyProjectile)
    DOTA_UM_TE_DestroyProjectile = 571,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_HeroRelicProgress)
    DOTA_UM_HeroRelicProgress = 572,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_AbilityDraftRequestAbility)
    DOTA_UM_AbilityDraftRequestAbility = 573,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ItemSold)
    DOTA_UM_ItemSold = 574,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_DamageReport)
    DOTA_UM_DamageReport = 575,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_SalutePlayer)
    DOTA_UM_SalutePlayer = 576,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TipAlert)
    DOTA_UM_TipAlert = 577,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ReplaceQueryUnit)
    DOTA_UM_ReplaceQueryUnit = 578,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_EmptyTeleportAlert)
    DOTA_UM_EmptyTeleportAlert = 579,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MarsArenaOfBloodAttack)
    DOTA_UM_MarsArenaOfBloodAttack = 580,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ESArcanaCombo)
    DOTA_UM_ESArcanaCombo = 581,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ESArcanaComboSummary)
    DOTA_UM_ESArcanaComboSummary = 582,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_HighFiveLeftHanging)
    DOTA_UM_HighFiveLeftHanging = 583,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_HighFiveCompleted)
    DOTA_UM_HighFiveCompleted = 584,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ShovelUnearth)
    DOTA_UM_ShovelUnearth = 585,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_EM_InvokerSpellCast)
    DOTA_EM_InvokerSpellCast = 586,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_RadarAlert)
    DOTA_UM_RadarAlert = 587,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_AllStarEvent)
    DOTA_UM_AllStarEvent = 588,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_TalentTreeAlert)
    DOTA_UM_TalentTreeAlert = 589,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_QueuedOrderRemoved)
    DOTA_UM_QueuedOrderRemoved = 590,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_DebugChallenge)
    DOTA_UM_DebugChallenge = 591,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_OMArcanaCombo)
    DOTA_UM_OMArcanaCombo = 592,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_FoundNeutralItem)
    DOTA_UM_FoundNeutralItem = 593,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_OutpostCaptured)
    DOTA_UM_OutpostCaptured = 594,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_OutpostGrantedXP)
    DOTA_UM_OutpostGrantedXP = 595,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MoveCameraToUnit)
    DOTA_UM_MoveCameraToUnit = 596,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_PauseMinigameData)
    DOTA_UM_PauseMinigameData = 597,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_VersusScene_PlayerBehavior)
    DOTA_UM_VersusScene_PlayerBehavior = 598,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_QoP_ArcanaSummary)
    DOTA_UM_QoP_ArcanaSummary = 600,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_HotPotato_Created)
    DOTA_UM_HotPotato_Created = 601,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_HotPotato_Exploded)
    DOTA_UM_HotPotato_Exploded = 602,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_WK_Arcana_Progress)
    DOTA_UM_WK_Arcana_Progress = 603,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_GuildChallenge_Progress)
    DOTA_UM_GuildChallenge_Progress = 604,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_WRArcanaProgress)
    DOTA_UM_WRArcanaProgress = 605,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_WRArcanaSummary)
    DOTA_UM_WRArcanaSummary = 606,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_EmptyItemSlotAlert)
    DOTA_UM_EmptyItemSlotAlert = 607,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_AghsStatusAlert)
    DOTA_UM_AghsStatusAlert = 608,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_PingConfirmation)
    DOTA_UM_PingConfirmation = 609,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MutedPlayers)
    DOTA_UM_MutedPlayers = 610,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ContextualTip)
    DOTA_UM_ContextualTip = 611,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_ChatMessage)
    DOTA_UM_ChatMessage = 612,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_NeutralCampAlert)
    DOTA_UM_NeutralCampAlert = 613,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_RockPaperScissorsStarted)
    DOTA_UM_RockPaperScissorsStarted = 614,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_RockPaperScissorsFinished)
    DOTA_UM_RockPaperScissorsFinished = 615,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_DuelOpponentKilled)
    DOTA_UM_DuelOpponentKilled = 616,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_DuelAccepted)
    DOTA_UM_DuelAccepted = 617,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_DuelRequested)
    DOTA_UM_DuelRequested = 618,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled)
    DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled = 619,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_PlayerDraftSuggestPick)
    DOTA_UM_PlayerDraftSuggestPick = 620,
    // @@protoc_insertion_point(enum_value:dota.EDotaUserMessages.DOTA_UM_PlayerDraftPick)
    DOTA_UM_PlayerDraftPick = 621,
}

impl ::protobuf::Enum for EDotaUserMessages {
    const NAME: &'static str = "EDotaUserMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDotaUserMessages> {
        match value {
            464 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddUnitToSelection),
            465 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AIDebugLine),
            466 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatEvent),
            467 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatHeroPositions),
            468 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogData),
            470 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogBulkData),
            471 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CreateLinearProjectile),
            472 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DestroyLinearProjectile),
            473 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DodgeTrackingProjectiles),
            474 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightColor),
            475 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightDirection),
            476 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_InvalidCommand),
            477 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_LocationPing),
            478 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MapLine),
            479 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniKillCamInfo),
            480 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapDebugPoint),
            481 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapEvent),
            482 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_NevermoreRequiem),
            483 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OverheadEvent),
            484 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SetNextAutobuyItem),
            485 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SharedCooldown),
            486 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerClick),
            487 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialTipInfo),
            488 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UnitEvent),
            489 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ParticleManager),
            490 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BotChat),
            491 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HudError),
            492 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemPurchased),
            493 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_Ping),
            494 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemFound),
            495 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CharacterSpeakConcept),
            496 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SwapVerify),
            497 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WorldLine),
            498 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TournamentDrop),
            499 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemAlert),
            500 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HalloweenDrops),
            501 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheel),
            502 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ReceivedXmasGift),
            503 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateSharedContent),
            504 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialRequestExp),
            505 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialPingMinimap),
            506 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GamerulesStateChanged),
            507 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowSurvey),
            508 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFade),
            509 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddQuestLogEntry),
            510 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendStatPopup),
            511 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFinish),
            512 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanPopup),
            513 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendGenericToolTip),
            514 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendFinalGold),
            515 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomMsg),
            516 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CoachHUDPing),
            517 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ClientLoadGridNav),
            518 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_Projectile),
            519 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_ProjectileLoc),
            520 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_DotaBloodImpact),
            521 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimation),
            522 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimationEnd),
            523 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilityPing),
            524 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowGenericPopup),
            525 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteStart),
            526 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteUpdate),
            527 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteEnd),
            528 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BoosterState),
            529 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WillPurchaseAlert),
            530 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialMinimapPosition),
            531 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerMMR),
            532 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilitySteal),
            533 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CourierKilledAlert),
            534 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EnemyItemAlert),
            535 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsMatchDetails),
            536 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniTaunt),
            537 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BuyBackStateAlert),
            538 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpeechBubble),
            539 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHeaderMessage),
            540 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuickBuyAlert),
            541 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsHeroDetails),
            542 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PredictionResult),
            543 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ModifierAlert),
            544 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HPManaAlert),
            545 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlyphAlert),
            546 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BeastChat),
            547 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerUnitOrders),
            548 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Create),
            549 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Modify),
            550 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Destroy),
            551 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CompendiumState),
            552 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionAbility),
            553 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionEvent),
            554 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogDataHLTV),
            555 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_XPAlert),
            556 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateQuestProgress),
            557 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchMetadata),
            558 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchDetails),
            559 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuestStatus),
            560 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroPick),
            561 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroRole),
            562 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_KillcamDamageTaken),
            563 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SelectPenaltyGold),
            564 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RollDiceResult),
            565 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FlipCoinResult),
            566 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RequestItemSuggestions),
            567 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TeamCaptainChanged),
            568 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanSpectatorPhase),
            569 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheelCooldown),
            570 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DismissAllStatPopups),
            571 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_DestroyProjectile),
            572 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HeroRelicProgress),
            573 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilityDraftRequestAbility),
            574 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemSold),
            575 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DamageReport),
            576 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SalutePlayer),
            577 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TipAlert),
            578 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ReplaceQueryUnit),
            579 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EmptyTeleportAlert),
            580 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MarsArenaOfBloodAttack),
            581 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ESArcanaCombo),
            582 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ESArcanaComboSummary),
            583 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HighFiveLeftHanging),
            584 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HighFiveCompleted),
            585 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShovelUnearth),
            586 => ::std::option::Option::Some(EDotaUserMessages::DOTA_EM_InvokerSpellCast),
            587 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RadarAlert),
            588 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AllStarEvent),
            589 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TalentTreeAlert),
            590 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QueuedOrderRemoved),
            591 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DebugChallenge),
            592 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OMArcanaCombo),
            593 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FoundNeutralItem),
            594 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OutpostCaptured),
            595 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OutpostGrantedXP),
            596 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MoveCameraToUnit),
            597 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PauseMinigameData),
            598 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VersusScene_PlayerBehavior),
            600 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QoP_ArcanaSummary),
            601 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HotPotato_Created),
            602 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HotPotato_Exploded),
            603 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WK_Arcana_Progress),
            604 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GuildChallenge_Progress),
            605 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WRArcanaProgress),
            606 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WRArcanaSummary),
            607 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EmptyItemSlotAlert),
            608 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AghsStatusAlert),
            609 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PingConfirmation),
            610 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MutedPlayers),
            611 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ContextualTip),
            612 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatMessage),
            613 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_NeutralCampAlert),
            614 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RockPaperScissorsStarted),
            615 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RockPaperScissorsFinished),
            616 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelOpponentKilled),
            617 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelAccepted),
            618 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelRequested),
            619 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled),
            620 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerDraftSuggestPick),
            621 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerDraftPick),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDotaUserMessages> {
        match str {
            "DOTA_UM_AddUnitToSelection" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddUnitToSelection),
            "DOTA_UM_AIDebugLine" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AIDebugLine),
            "DOTA_UM_ChatEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatEvent),
            "DOTA_UM_CombatHeroPositions" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatHeroPositions),
            "DOTA_UM_CombatLogData" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogData),
            "DOTA_UM_CombatLogBulkData" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogBulkData),
            "DOTA_UM_CreateLinearProjectile" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CreateLinearProjectile),
            "DOTA_UM_DestroyLinearProjectile" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DestroyLinearProjectile),
            "DOTA_UM_DodgeTrackingProjectiles" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DodgeTrackingProjectiles),
            "DOTA_UM_GlobalLightColor" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightColor),
            "DOTA_UM_GlobalLightDirection" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightDirection),
            "DOTA_UM_InvalidCommand" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_InvalidCommand),
            "DOTA_UM_LocationPing" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_LocationPing),
            "DOTA_UM_MapLine" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MapLine),
            "DOTA_UM_MiniKillCamInfo" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniKillCamInfo),
            "DOTA_UM_MinimapDebugPoint" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapDebugPoint),
            "DOTA_UM_MinimapEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapEvent),
            "DOTA_UM_NevermoreRequiem" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_NevermoreRequiem),
            "DOTA_UM_OverheadEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OverheadEvent),
            "DOTA_UM_SetNextAutobuyItem" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SetNextAutobuyItem),
            "DOTA_UM_SharedCooldown" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SharedCooldown),
            "DOTA_UM_SpectatorPlayerClick" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerClick),
            "DOTA_UM_TutorialTipInfo" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialTipInfo),
            "DOTA_UM_UnitEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UnitEvent),
            "DOTA_UM_ParticleManager" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ParticleManager),
            "DOTA_UM_BotChat" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BotChat),
            "DOTA_UM_HudError" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HudError),
            "DOTA_UM_ItemPurchased" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemPurchased),
            "DOTA_UM_Ping" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_Ping),
            "DOTA_UM_ItemFound" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemFound),
            "DOTA_UM_CharacterSpeakConcept" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CharacterSpeakConcept),
            "DOTA_UM_SwapVerify" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SwapVerify),
            "DOTA_UM_WorldLine" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WorldLine),
            "DOTA_UM_TournamentDrop" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TournamentDrop),
            "DOTA_UM_ItemAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemAlert),
            "DOTA_UM_HalloweenDrops" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HalloweenDrops),
            "DOTA_UM_ChatWheel" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheel),
            "DOTA_UM_ReceivedXmasGift" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ReceivedXmasGift),
            "DOTA_UM_UpdateSharedContent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateSharedContent),
            "DOTA_UM_TutorialRequestExp" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialRequestExp),
            "DOTA_UM_TutorialPingMinimap" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialPingMinimap),
            "DOTA_UM_GamerulesStateChanged" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GamerulesStateChanged),
            "DOTA_UM_ShowSurvey" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowSurvey),
            "DOTA_UM_TutorialFade" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFade),
            "DOTA_UM_AddQuestLogEntry" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddQuestLogEntry),
            "DOTA_UM_SendStatPopup" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendStatPopup),
            "DOTA_UM_TutorialFinish" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFinish),
            "DOTA_UM_SendRoshanPopup" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanPopup),
            "DOTA_UM_SendGenericToolTip" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendGenericToolTip),
            "DOTA_UM_SendFinalGold" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendFinalGold),
            "DOTA_UM_CustomMsg" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomMsg),
            "DOTA_UM_CoachHUDPing" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CoachHUDPing),
            "DOTA_UM_ClientLoadGridNav" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ClientLoadGridNav),
            "DOTA_UM_TE_Projectile" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_Projectile),
            "DOTA_UM_TE_ProjectileLoc" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_ProjectileLoc),
            "DOTA_UM_TE_DotaBloodImpact" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_DotaBloodImpact),
            "DOTA_UM_TE_UnitAnimation" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimation),
            "DOTA_UM_TE_UnitAnimationEnd" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimationEnd),
            "DOTA_UM_AbilityPing" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilityPing),
            "DOTA_UM_ShowGenericPopup" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowGenericPopup),
            "DOTA_UM_VoteStart" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteStart),
            "DOTA_UM_VoteUpdate" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteUpdate),
            "DOTA_UM_VoteEnd" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteEnd),
            "DOTA_UM_BoosterState" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BoosterState),
            "DOTA_UM_WillPurchaseAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WillPurchaseAlert),
            "DOTA_UM_TutorialMinimapPosition" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialMinimapPosition),
            "DOTA_UM_PlayerMMR" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerMMR),
            "DOTA_UM_AbilitySteal" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilitySteal),
            "DOTA_UM_CourierKilledAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CourierKilledAlert),
            "DOTA_UM_EnemyItemAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EnemyItemAlert),
            "DOTA_UM_StatsMatchDetails" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsMatchDetails),
            "DOTA_UM_MiniTaunt" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniTaunt),
            "DOTA_UM_BuyBackStateAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BuyBackStateAlert),
            "DOTA_UM_SpeechBubble" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpeechBubble),
            "DOTA_UM_CustomHeaderMessage" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHeaderMessage),
            "DOTA_UM_QuickBuyAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuickBuyAlert),
            "DOTA_UM_StatsHeroDetails" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsHeroDetails),
            "DOTA_UM_PredictionResult" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PredictionResult),
            "DOTA_UM_ModifierAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ModifierAlert),
            "DOTA_UM_HPManaAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HPManaAlert),
            "DOTA_UM_GlyphAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlyphAlert),
            "DOTA_UM_BeastChat" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BeastChat),
            "DOTA_UM_SpectatorPlayerUnitOrders" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerUnitOrders),
            "DOTA_UM_CustomHudElement_Create" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Create),
            "DOTA_UM_CustomHudElement_Modify" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Modify),
            "DOTA_UM_CustomHudElement_Destroy" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Destroy),
            "DOTA_UM_CompendiumState" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CompendiumState),
            "DOTA_UM_ProjectionAbility" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionAbility),
            "DOTA_UM_ProjectionEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionEvent),
            "DOTA_UM_CombatLogDataHLTV" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogDataHLTV),
            "DOTA_UM_XPAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_XPAlert),
            "DOTA_UM_UpdateQuestProgress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateQuestProgress),
            "DOTA_UM_MatchMetadata" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchMetadata),
            "DOTA_UM_MatchDetails" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchDetails),
            "DOTA_UM_QuestStatus" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuestStatus),
            "DOTA_UM_SuggestHeroPick" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroPick),
            "DOTA_UM_SuggestHeroRole" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroRole),
            "DOTA_UM_KillcamDamageTaken" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_KillcamDamageTaken),
            "DOTA_UM_SelectPenaltyGold" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SelectPenaltyGold),
            "DOTA_UM_RollDiceResult" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RollDiceResult),
            "DOTA_UM_FlipCoinResult" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FlipCoinResult),
            "DOTA_UM_RequestItemSuggestions" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RequestItemSuggestions),
            "DOTA_UM_TeamCaptainChanged" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TeamCaptainChanged),
            "DOTA_UM_SendRoshanSpectatorPhase" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanSpectatorPhase),
            "DOTA_UM_ChatWheelCooldown" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheelCooldown),
            "DOTA_UM_DismissAllStatPopups" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DismissAllStatPopups),
            "DOTA_UM_TE_DestroyProjectile" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_DestroyProjectile),
            "DOTA_UM_HeroRelicProgress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HeroRelicProgress),
            "DOTA_UM_AbilityDraftRequestAbility" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilityDraftRequestAbility),
            "DOTA_UM_ItemSold" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemSold),
            "DOTA_UM_DamageReport" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DamageReport),
            "DOTA_UM_SalutePlayer" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SalutePlayer),
            "DOTA_UM_TipAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TipAlert),
            "DOTA_UM_ReplaceQueryUnit" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ReplaceQueryUnit),
            "DOTA_UM_EmptyTeleportAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EmptyTeleportAlert),
            "DOTA_UM_MarsArenaOfBloodAttack" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MarsArenaOfBloodAttack),
            "DOTA_UM_ESArcanaCombo" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ESArcanaCombo),
            "DOTA_UM_ESArcanaComboSummary" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ESArcanaComboSummary),
            "DOTA_UM_HighFiveLeftHanging" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HighFiveLeftHanging),
            "DOTA_UM_HighFiveCompleted" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HighFiveCompleted),
            "DOTA_UM_ShovelUnearth" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShovelUnearth),
            "DOTA_EM_InvokerSpellCast" => ::std::option::Option::Some(EDotaUserMessages::DOTA_EM_InvokerSpellCast),
            "DOTA_UM_RadarAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RadarAlert),
            "DOTA_UM_AllStarEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AllStarEvent),
            "DOTA_UM_TalentTreeAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TalentTreeAlert),
            "DOTA_UM_QueuedOrderRemoved" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QueuedOrderRemoved),
            "DOTA_UM_DebugChallenge" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DebugChallenge),
            "DOTA_UM_OMArcanaCombo" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OMArcanaCombo),
            "DOTA_UM_FoundNeutralItem" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FoundNeutralItem),
            "DOTA_UM_OutpostCaptured" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OutpostCaptured),
            "DOTA_UM_OutpostGrantedXP" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OutpostGrantedXP),
            "DOTA_UM_MoveCameraToUnit" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MoveCameraToUnit),
            "DOTA_UM_PauseMinigameData" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PauseMinigameData),
            "DOTA_UM_VersusScene_PlayerBehavior" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VersusScene_PlayerBehavior),
            "DOTA_UM_QoP_ArcanaSummary" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QoP_ArcanaSummary),
            "DOTA_UM_HotPotato_Created" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HotPotato_Created),
            "DOTA_UM_HotPotato_Exploded" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HotPotato_Exploded),
            "DOTA_UM_WK_Arcana_Progress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WK_Arcana_Progress),
            "DOTA_UM_GuildChallenge_Progress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GuildChallenge_Progress),
            "DOTA_UM_WRArcanaProgress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WRArcanaProgress),
            "DOTA_UM_WRArcanaSummary" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WRArcanaSummary),
            "DOTA_UM_EmptyItemSlotAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EmptyItemSlotAlert),
            "DOTA_UM_AghsStatusAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AghsStatusAlert),
            "DOTA_UM_PingConfirmation" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PingConfirmation),
            "DOTA_UM_MutedPlayers" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MutedPlayers),
            "DOTA_UM_ContextualTip" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ContextualTip),
            "DOTA_UM_ChatMessage" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatMessage),
            "DOTA_UM_NeutralCampAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_NeutralCampAlert),
            "DOTA_UM_RockPaperScissorsStarted" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RockPaperScissorsStarted),
            "DOTA_UM_RockPaperScissorsFinished" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RockPaperScissorsFinished),
            "DOTA_UM_DuelOpponentKilled" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelOpponentKilled),
            "DOTA_UM_DuelAccepted" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelAccepted),
            "DOTA_UM_DuelRequested" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelRequested),
            "DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled),
            "DOTA_UM_PlayerDraftSuggestPick" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerDraftSuggestPick),
            "DOTA_UM_PlayerDraftPick" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerDraftPick),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDotaUserMessages] = &[
        EDotaUserMessages::DOTA_UM_AddUnitToSelection,
        EDotaUserMessages::DOTA_UM_AIDebugLine,
        EDotaUserMessages::DOTA_UM_ChatEvent,
        EDotaUserMessages::DOTA_UM_CombatHeroPositions,
        EDotaUserMessages::DOTA_UM_CombatLogData,
        EDotaUserMessages::DOTA_UM_CombatLogBulkData,
        EDotaUserMessages::DOTA_UM_CreateLinearProjectile,
        EDotaUserMessages::DOTA_UM_DestroyLinearProjectile,
        EDotaUserMessages::DOTA_UM_DodgeTrackingProjectiles,
        EDotaUserMessages::DOTA_UM_GlobalLightColor,
        EDotaUserMessages::DOTA_UM_GlobalLightDirection,
        EDotaUserMessages::DOTA_UM_InvalidCommand,
        EDotaUserMessages::DOTA_UM_LocationPing,
        EDotaUserMessages::DOTA_UM_MapLine,
        EDotaUserMessages::DOTA_UM_MiniKillCamInfo,
        EDotaUserMessages::DOTA_UM_MinimapDebugPoint,
        EDotaUserMessages::DOTA_UM_MinimapEvent,
        EDotaUserMessages::DOTA_UM_NevermoreRequiem,
        EDotaUserMessages::DOTA_UM_OverheadEvent,
        EDotaUserMessages::DOTA_UM_SetNextAutobuyItem,
        EDotaUserMessages::DOTA_UM_SharedCooldown,
        EDotaUserMessages::DOTA_UM_SpectatorPlayerClick,
        EDotaUserMessages::DOTA_UM_TutorialTipInfo,
        EDotaUserMessages::DOTA_UM_UnitEvent,
        EDotaUserMessages::DOTA_UM_ParticleManager,
        EDotaUserMessages::DOTA_UM_BotChat,
        EDotaUserMessages::DOTA_UM_HudError,
        EDotaUserMessages::DOTA_UM_ItemPurchased,
        EDotaUserMessages::DOTA_UM_Ping,
        EDotaUserMessages::DOTA_UM_ItemFound,
        EDotaUserMessages::DOTA_UM_CharacterSpeakConcept,
        EDotaUserMessages::DOTA_UM_SwapVerify,
        EDotaUserMessages::DOTA_UM_WorldLine,
        EDotaUserMessages::DOTA_UM_TournamentDrop,
        EDotaUserMessages::DOTA_UM_ItemAlert,
        EDotaUserMessages::DOTA_UM_HalloweenDrops,
        EDotaUserMessages::DOTA_UM_ChatWheel,
        EDotaUserMessages::DOTA_UM_ReceivedXmasGift,
        EDotaUserMessages::DOTA_UM_UpdateSharedContent,
        EDotaUserMessages::DOTA_UM_TutorialRequestExp,
        EDotaUserMessages::DOTA_UM_TutorialPingMinimap,
        EDotaUserMessages::DOTA_UM_GamerulesStateChanged,
        EDotaUserMessages::DOTA_UM_ShowSurvey,
        EDotaUserMessages::DOTA_UM_TutorialFade,
        EDotaUserMessages::DOTA_UM_AddQuestLogEntry,
        EDotaUserMessages::DOTA_UM_SendStatPopup,
        EDotaUserMessages::DOTA_UM_TutorialFinish,
        EDotaUserMessages::DOTA_UM_SendRoshanPopup,
        EDotaUserMessages::DOTA_UM_SendGenericToolTip,
        EDotaUserMessages::DOTA_UM_SendFinalGold,
        EDotaUserMessages::DOTA_UM_CustomMsg,
        EDotaUserMessages::DOTA_UM_CoachHUDPing,
        EDotaUserMessages::DOTA_UM_ClientLoadGridNav,
        EDotaUserMessages::DOTA_UM_TE_Projectile,
        EDotaUserMessages::DOTA_UM_TE_ProjectileLoc,
        EDotaUserMessages::DOTA_UM_TE_DotaBloodImpact,
        EDotaUserMessages::DOTA_UM_TE_UnitAnimation,
        EDotaUserMessages::DOTA_UM_TE_UnitAnimationEnd,
        EDotaUserMessages::DOTA_UM_AbilityPing,
        EDotaUserMessages::DOTA_UM_ShowGenericPopup,
        EDotaUserMessages::DOTA_UM_VoteStart,
        EDotaUserMessages::DOTA_UM_VoteUpdate,
        EDotaUserMessages::DOTA_UM_VoteEnd,
        EDotaUserMessages::DOTA_UM_BoosterState,
        EDotaUserMessages::DOTA_UM_WillPurchaseAlert,
        EDotaUserMessages::DOTA_UM_TutorialMinimapPosition,
        EDotaUserMessages::DOTA_UM_PlayerMMR,
        EDotaUserMessages::DOTA_UM_AbilitySteal,
        EDotaUserMessages::DOTA_UM_CourierKilledAlert,
        EDotaUserMessages::DOTA_UM_EnemyItemAlert,
        EDotaUserMessages::DOTA_UM_StatsMatchDetails,
        EDotaUserMessages::DOTA_UM_MiniTaunt,
        EDotaUserMessages::DOTA_UM_BuyBackStateAlert,
        EDotaUserMessages::DOTA_UM_SpeechBubble,
        EDotaUserMessages::DOTA_UM_CustomHeaderMessage,
        EDotaUserMessages::DOTA_UM_QuickBuyAlert,
        EDotaUserMessages::DOTA_UM_StatsHeroDetails,
        EDotaUserMessages::DOTA_UM_PredictionResult,
        EDotaUserMessages::DOTA_UM_ModifierAlert,
        EDotaUserMessages::DOTA_UM_HPManaAlert,
        EDotaUserMessages::DOTA_UM_GlyphAlert,
        EDotaUserMessages::DOTA_UM_BeastChat,
        EDotaUserMessages::DOTA_UM_SpectatorPlayerUnitOrders,
        EDotaUserMessages::DOTA_UM_CustomHudElement_Create,
        EDotaUserMessages::DOTA_UM_CustomHudElement_Modify,
        EDotaUserMessages::DOTA_UM_CustomHudElement_Destroy,
        EDotaUserMessages::DOTA_UM_CompendiumState,
        EDotaUserMessages::DOTA_UM_ProjectionAbility,
        EDotaUserMessages::DOTA_UM_ProjectionEvent,
        EDotaUserMessages::DOTA_UM_CombatLogDataHLTV,
        EDotaUserMessages::DOTA_UM_XPAlert,
        EDotaUserMessages::DOTA_UM_UpdateQuestProgress,
        EDotaUserMessages::DOTA_UM_MatchMetadata,
        EDotaUserMessages::DOTA_UM_MatchDetails,
        EDotaUserMessages::DOTA_UM_QuestStatus,
        EDotaUserMessages::DOTA_UM_SuggestHeroPick,
        EDotaUserMessages::DOTA_UM_SuggestHeroRole,
        EDotaUserMessages::DOTA_UM_KillcamDamageTaken,
        EDotaUserMessages::DOTA_UM_SelectPenaltyGold,
        EDotaUserMessages::DOTA_UM_RollDiceResult,
        EDotaUserMessages::DOTA_UM_FlipCoinResult,
        EDotaUserMessages::DOTA_UM_RequestItemSuggestions,
        EDotaUserMessages::DOTA_UM_TeamCaptainChanged,
        EDotaUserMessages::DOTA_UM_SendRoshanSpectatorPhase,
        EDotaUserMessages::DOTA_UM_ChatWheelCooldown,
        EDotaUserMessages::DOTA_UM_DismissAllStatPopups,
        EDotaUserMessages::DOTA_UM_TE_DestroyProjectile,
        EDotaUserMessages::DOTA_UM_HeroRelicProgress,
        EDotaUserMessages::DOTA_UM_AbilityDraftRequestAbility,
        EDotaUserMessages::DOTA_UM_ItemSold,
        EDotaUserMessages::DOTA_UM_DamageReport,
        EDotaUserMessages::DOTA_UM_SalutePlayer,
        EDotaUserMessages::DOTA_UM_TipAlert,
        EDotaUserMessages::DOTA_UM_ReplaceQueryUnit,
        EDotaUserMessages::DOTA_UM_EmptyTeleportAlert,
        EDotaUserMessages::DOTA_UM_MarsArenaOfBloodAttack,
        EDotaUserMessages::DOTA_UM_ESArcanaCombo,
        EDotaUserMessages::DOTA_UM_ESArcanaComboSummary,
        EDotaUserMessages::DOTA_UM_HighFiveLeftHanging,
        EDotaUserMessages::DOTA_UM_HighFiveCompleted,
        EDotaUserMessages::DOTA_UM_ShovelUnearth,
        EDotaUserMessages::DOTA_EM_InvokerSpellCast,
        EDotaUserMessages::DOTA_UM_RadarAlert,
        EDotaUserMessages::DOTA_UM_AllStarEvent,
        EDotaUserMessages::DOTA_UM_TalentTreeAlert,
        EDotaUserMessages::DOTA_UM_QueuedOrderRemoved,
        EDotaUserMessages::DOTA_UM_DebugChallenge,
        EDotaUserMessages::DOTA_UM_OMArcanaCombo,
        EDotaUserMessages::DOTA_UM_FoundNeutralItem,
        EDotaUserMessages::DOTA_UM_OutpostCaptured,
        EDotaUserMessages::DOTA_UM_OutpostGrantedXP,
        EDotaUserMessages::DOTA_UM_MoveCameraToUnit,
        EDotaUserMessages::DOTA_UM_PauseMinigameData,
        EDotaUserMessages::DOTA_UM_VersusScene_PlayerBehavior,
        EDotaUserMessages::DOTA_UM_QoP_ArcanaSummary,
        EDotaUserMessages::DOTA_UM_HotPotato_Created,
        EDotaUserMessages::DOTA_UM_HotPotato_Exploded,
        EDotaUserMessages::DOTA_UM_WK_Arcana_Progress,
        EDotaUserMessages::DOTA_UM_GuildChallenge_Progress,
        EDotaUserMessages::DOTA_UM_WRArcanaProgress,
        EDotaUserMessages::DOTA_UM_WRArcanaSummary,
        EDotaUserMessages::DOTA_UM_EmptyItemSlotAlert,
        EDotaUserMessages::DOTA_UM_AghsStatusAlert,
        EDotaUserMessages::DOTA_UM_PingConfirmation,
        EDotaUserMessages::DOTA_UM_MutedPlayers,
        EDotaUserMessages::DOTA_UM_ContextualTip,
        EDotaUserMessages::DOTA_UM_ChatMessage,
        EDotaUserMessages::DOTA_UM_NeutralCampAlert,
        EDotaUserMessages::DOTA_UM_RockPaperScissorsStarted,
        EDotaUserMessages::DOTA_UM_RockPaperScissorsFinished,
        EDotaUserMessages::DOTA_UM_DuelOpponentKilled,
        EDotaUserMessages::DOTA_UM_DuelAccepted,
        EDotaUserMessages::DOTA_UM_DuelRequested,
        EDotaUserMessages::DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled,
        EDotaUserMessages::DOTA_UM_PlayerDraftSuggestPick,
        EDotaUserMessages::DOTA_UM_PlayerDraftPick,
    ];
}

impl ::protobuf::EnumFull for EDotaUserMessages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDotaUserMessages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EDotaUserMessages::DOTA_UM_AddUnitToSelection => 0,
            EDotaUserMessages::DOTA_UM_AIDebugLine => 1,
            EDotaUserMessages::DOTA_UM_ChatEvent => 2,
            EDotaUserMessages::DOTA_UM_CombatHeroPositions => 3,
            EDotaUserMessages::DOTA_UM_CombatLogData => 4,
            EDotaUserMessages::DOTA_UM_CombatLogBulkData => 5,
            EDotaUserMessages::DOTA_UM_CreateLinearProjectile => 6,
            EDotaUserMessages::DOTA_UM_DestroyLinearProjectile => 7,
            EDotaUserMessages::DOTA_UM_DodgeTrackingProjectiles => 8,
            EDotaUserMessages::DOTA_UM_GlobalLightColor => 9,
            EDotaUserMessages::DOTA_UM_GlobalLightDirection => 10,
            EDotaUserMessages::DOTA_UM_InvalidCommand => 11,
            EDotaUserMessages::DOTA_UM_LocationPing => 12,
            EDotaUserMessages::DOTA_UM_MapLine => 13,
            EDotaUserMessages::DOTA_UM_MiniKillCamInfo => 14,
            EDotaUserMessages::DOTA_UM_MinimapDebugPoint => 15,
            EDotaUserMessages::DOTA_UM_MinimapEvent => 16,
            EDotaUserMessages::DOTA_UM_NevermoreRequiem => 17,
            EDotaUserMessages::DOTA_UM_OverheadEvent => 18,
            EDotaUserMessages::DOTA_UM_SetNextAutobuyItem => 19,
            EDotaUserMessages::DOTA_UM_SharedCooldown => 20,
            EDotaUserMessages::DOTA_UM_SpectatorPlayerClick => 21,
            EDotaUserMessages::DOTA_UM_TutorialTipInfo => 22,
            EDotaUserMessages::DOTA_UM_UnitEvent => 23,
            EDotaUserMessages::DOTA_UM_ParticleManager => 24,
            EDotaUserMessages::DOTA_UM_BotChat => 25,
            EDotaUserMessages::DOTA_UM_HudError => 26,
            EDotaUserMessages::DOTA_UM_ItemPurchased => 27,
            EDotaUserMessages::DOTA_UM_Ping => 28,
            EDotaUserMessages::DOTA_UM_ItemFound => 29,
            EDotaUserMessages::DOTA_UM_CharacterSpeakConcept => 30,
            EDotaUserMessages::DOTA_UM_SwapVerify => 31,
            EDotaUserMessages::DOTA_UM_WorldLine => 32,
            EDotaUserMessages::DOTA_UM_TournamentDrop => 33,
            EDotaUserMessages::DOTA_UM_ItemAlert => 34,
            EDotaUserMessages::DOTA_UM_HalloweenDrops => 35,
            EDotaUserMessages::DOTA_UM_ChatWheel => 36,
            EDotaUserMessages::DOTA_UM_ReceivedXmasGift => 37,
            EDotaUserMessages::DOTA_UM_UpdateSharedContent => 38,
            EDotaUserMessages::DOTA_UM_TutorialRequestExp => 39,
            EDotaUserMessages::DOTA_UM_TutorialPingMinimap => 40,
            EDotaUserMessages::DOTA_UM_GamerulesStateChanged => 41,
            EDotaUserMessages::DOTA_UM_ShowSurvey => 42,
            EDotaUserMessages::DOTA_UM_TutorialFade => 43,
            EDotaUserMessages::DOTA_UM_AddQuestLogEntry => 44,
            EDotaUserMessages::DOTA_UM_SendStatPopup => 45,
            EDotaUserMessages::DOTA_UM_TutorialFinish => 46,
            EDotaUserMessages::DOTA_UM_SendRoshanPopup => 47,
            EDotaUserMessages::DOTA_UM_SendGenericToolTip => 48,
            EDotaUserMessages::DOTA_UM_SendFinalGold => 49,
            EDotaUserMessages::DOTA_UM_CustomMsg => 50,
            EDotaUserMessages::DOTA_UM_CoachHUDPing => 51,
            EDotaUserMessages::DOTA_UM_ClientLoadGridNav => 52,
            EDotaUserMessages::DOTA_UM_TE_Projectile => 53,
            EDotaUserMessages::DOTA_UM_TE_ProjectileLoc => 54,
            EDotaUserMessages::DOTA_UM_TE_DotaBloodImpact => 55,
            EDotaUserMessages::DOTA_UM_TE_UnitAnimation => 56,
            EDotaUserMessages::DOTA_UM_TE_UnitAnimationEnd => 57,
            EDotaUserMessages::DOTA_UM_AbilityPing => 58,
            EDotaUserMessages::DOTA_UM_ShowGenericPopup => 59,
            EDotaUserMessages::DOTA_UM_VoteStart => 60,
            EDotaUserMessages::DOTA_UM_VoteUpdate => 61,
            EDotaUserMessages::DOTA_UM_VoteEnd => 62,
            EDotaUserMessages::DOTA_UM_BoosterState => 63,
            EDotaUserMessages::DOTA_UM_WillPurchaseAlert => 64,
            EDotaUserMessages::DOTA_UM_TutorialMinimapPosition => 65,
            EDotaUserMessages::DOTA_UM_PlayerMMR => 66,
            EDotaUserMessages::DOTA_UM_AbilitySteal => 67,
            EDotaUserMessages::DOTA_UM_CourierKilledAlert => 68,
            EDotaUserMessages::DOTA_UM_EnemyItemAlert => 69,
            EDotaUserMessages::DOTA_UM_StatsMatchDetails => 70,
            EDotaUserMessages::DOTA_UM_MiniTaunt => 71,
            EDotaUserMessages::DOTA_UM_BuyBackStateAlert => 72,
            EDotaUserMessages::DOTA_UM_SpeechBubble => 73,
            EDotaUserMessages::DOTA_UM_CustomHeaderMessage => 74,
            EDotaUserMessages::DOTA_UM_QuickBuyAlert => 75,
            EDotaUserMessages::DOTA_UM_StatsHeroDetails => 76,
            EDotaUserMessages::DOTA_UM_PredictionResult => 77,
            EDotaUserMessages::DOTA_UM_ModifierAlert => 78,
            EDotaUserMessages::DOTA_UM_HPManaAlert => 79,
            EDotaUserMessages::DOTA_UM_GlyphAlert => 80,
            EDotaUserMessages::DOTA_UM_BeastChat => 81,
            EDotaUserMessages::DOTA_UM_SpectatorPlayerUnitOrders => 82,
            EDotaUserMessages::DOTA_UM_CustomHudElement_Create => 83,
            EDotaUserMessages::DOTA_UM_CustomHudElement_Modify => 84,
            EDotaUserMessages::DOTA_UM_CustomHudElement_Destroy => 85,
            EDotaUserMessages::DOTA_UM_CompendiumState => 86,
            EDotaUserMessages::DOTA_UM_ProjectionAbility => 87,
            EDotaUserMessages::DOTA_UM_ProjectionEvent => 88,
            EDotaUserMessages::DOTA_UM_CombatLogDataHLTV => 89,
            EDotaUserMessages::DOTA_UM_XPAlert => 90,
            EDotaUserMessages::DOTA_UM_UpdateQuestProgress => 91,
            EDotaUserMessages::DOTA_UM_MatchMetadata => 92,
            EDotaUserMessages::DOTA_UM_MatchDetails => 93,
            EDotaUserMessages::DOTA_UM_QuestStatus => 94,
            EDotaUserMessages::DOTA_UM_SuggestHeroPick => 95,
            EDotaUserMessages::DOTA_UM_SuggestHeroRole => 96,
            EDotaUserMessages::DOTA_UM_KillcamDamageTaken => 97,
            EDotaUserMessages::DOTA_UM_SelectPenaltyGold => 98,
            EDotaUserMessages::DOTA_UM_RollDiceResult => 99,
            EDotaUserMessages::DOTA_UM_FlipCoinResult => 100,
            EDotaUserMessages::DOTA_UM_RequestItemSuggestions => 101,
            EDotaUserMessages::DOTA_UM_TeamCaptainChanged => 102,
            EDotaUserMessages::DOTA_UM_SendRoshanSpectatorPhase => 103,
            EDotaUserMessages::DOTA_UM_ChatWheelCooldown => 104,
            EDotaUserMessages::DOTA_UM_DismissAllStatPopups => 105,
            EDotaUserMessages::DOTA_UM_TE_DestroyProjectile => 106,
            EDotaUserMessages::DOTA_UM_HeroRelicProgress => 107,
            EDotaUserMessages::DOTA_UM_AbilityDraftRequestAbility => 108,
            EDotaUserMessages::DOTA_UM_ItemSold => 109,
            EDotaUserMessages::DOTA_UM_DamageReport => 110,
            EDotaUserMessages::DOTA_UM_SalutePlayer => 111,
            EDotaUserMessages::DOTA_UM_TipAlert => 112,
            EDotaUserMessages::DOTA_UM_ReplaceQueryUnit => 113,
            EDotaUserMessages::DOTA_UM_EmptyTeleportAlert => 114,
            EDotaUserMessages::DOTA_UM_MarsArenaOfBloodAttack => 115,
            EDotaUserMessages::DOTA_UM_ESArcanaCombo => 116,
            EDotaUserMessages::DOTA_UM_ESArcanaComboSummary => 117,
            EDotaUserMessages::DOTA_UM_HighFiveLeftHanging => 118,
            EDotaUserMessages::DOTA_UM_HighFiveCompleted => 119,
            EDotaUserMessages::DOTA_UM_ShovelUnearth => 120,
            EDotaUserMessages::DOTA_EM_InvokerSpellCast => 121,
            EDotaUserMessages::DOTA_UM_RadarAlert => 122,
            EDotaUserMessages::DOTA_UM_AllStarEvent => 123,
            EDotaUserMessages::DOTA_UM_TalentTreeAlert => 124,
            EDotaUserMessages::DOTA_UM_QueuedOrderRemoved => 125,
            EDotaUserMessages::DOTA_UM_DebugChallenge => 126,
            EDotaUserMessages::DOTA_UM_OMArcanaCombo => 127,
            EDotaUserMessages::DOTA_UM_FoundNeutralItem => 128,
            EDotaUserMessages::DOTA_UM_OutpostCaptured => 129,
            EDotaUserMessages::DOTA_UM_OutpostGrantedXP => 130,
            EDotaUserMessages::DOTA_UM_MoveCameraToUnit => 131,
            EDotaUserMessages::DOTA_UM_PauseMinigameData => 132,
            EDotaUserMessages::DOTA_UM_VersusScene_PlayerBehavior => 133,
            EDotaUserMessages::DOTA_UM_QoP_ArcanaSummary => 134,
            EDotaUserMessages::DOTA_UM_HotPotato_Created => 135,
            EDotaUserMessages::DOTA_UM_HotPotato_Exploded => 136,
            EDotaUserMessages::DOTA_UM_WK_Arcana_Progress => 137,
            EDotaUserMessages::DOTA_UM_GuildChallenge_Progress => 138,
            EDotaUserMessages::DOTA_UM_WRArcanaProgress => 139,
            EDotaUserMessages::DOTA_UM_WRArcanaSummary => 140,
            EDotaUserMessages::DOTA_UM_EmptyItemSlotAlert => 141,
            EDotaUserMessages::DOTA_UM_AghsStatusAlert => 142,
            EDotaUserMessages::DOTA_UM_PingConfirmation => 143,
            EDotaUserMessages::DOTA_UM_MutedPlayers => 144,
            EDotaUserMessages::DOTA_UM_ContextualTip => 145,
            EDotaUserMessages::DOTA_UM_ChatMessage => 146,
            EDotaUserMessages::DOTA_UM_NeutralCampAlert => 147,
            EDotaUserMessages::DOTA_UM_RockPaperScissorsStarted => 148,
            EDotaUserMessages::DOTA_UM_RockPaperScissorsFinished => 149,
            EDotaUserMessages::DOTA_UM_DuelOpponentKilled => 150,
            EDotaUserMessages::DOTA_UM_DuelAccepted => 151,
            EDotaUserMessages::DOTA_UM_DuelRequested => 152,
            EDotaUserMessages::DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled => 153,
            EDotaUserMessages::DOTA_UM_PlayerDraftSuggestPick => 154,
            EDotaUserMessages::DOTA_UM_PlayerDraftPick => 155,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EDotaUserMessages {
    fn default() -> Self {
        EDotaUserMessages::DOTA_UM_AddUnitToSelection
    }
}

impl EDotaUserMessages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDotaUserMessages>("EDotaUserMessages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_CHAT_MESSAGE)
pub enum DOTA_CHAT_MESSAGE {
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_INVALID)
    CHAT_MESSAGE_INVALID = -1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_KILL)
    CHAT_MESSAGE_HERO_KILL = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_DENY)
    CHAT_MESSAGE_HERO_DENY = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_BARRACKS_KILL)
    CHAT_MESSAGE_BARRACKS_KILL = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_TOWER_KILL)
    CHAT_MESSAGE_TOWER_KILL = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_TOWER_DENY)
    CHAT_MESSAGE_TOWER_DENY = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_FIRSTBLOOD)
    CHAT_MESSAGE_FIRSTBLOOD = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_STREAK_KILL)
    CHAT_MESSAGE_STREAK_KILL = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_BUYBACK)
    CHAT_MESSAGE_BUYBACK = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_AEGIS)
    CHAT_MESSAGE_AEGIS = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ROSHAN_KILL)
    CHAT_MESSAGE_ROSHAN_KILL = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_COURIER_LOST)
    CHAT_MESSAGE_COURIER_LOST = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_COURIER_RESPAWNED)
    CHAT_MESSAGE_COURIER_RESPAWNED = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_GLYPH_USED)
    CHAT_MESSAGE_GLYPH_USED = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEM_PURCHASE)
    CHAT_MESSAGE_ITEM_PURCHASE = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CONNECT)
    CHAT_MESSAGE_CONNECT = 14,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT)
    CHAT_MESSAGE_DISCONNECT = 15,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT)
    CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT = 16,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT_TIME_REMAINING)
    CHAT_MESSAGE_DISCONNECT_TIME_REMAINING = 17,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL)
    CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL = 18,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RECONNECT)
    CHAT_MESSAGE_RECONNECT = 19,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_LEFT)
    CHAT_MESSAGE_PLAYER_LEFT = 20,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SAFE_TO_LEAVE)
    CHAT_MESSAGE_SAFE_TO_LEAVE = 21,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RUNE_PICKUP)
    CHAT_MESSAGE_RUNE_PICKUP = 22,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RUNE_BOTTLE)
    CHAT_MESSAGE_RUNE_BOTTLE = 23,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RUNE_DENY)
    CHAT_MESSAGE_RUNE_DENY = 114,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_INTHEBAG)
    CHAT_MESSAGE_INTHEBAG = 24,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SECRETSHOP)
    CHAT_MESSAGE_SECRETSHOP = 25,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEM_AUTOPURCHASED)
    CHAT_MESSAGE_ITEM_AUTOPURCHASED = 26,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEMS_COMBINED)
    CHAT_MESSAGE_ITEMS_COMBINED = 27,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SUPER_CREEPS)
    CHAT_MESSAGE_SUPER_CREEPS = 28,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANT_USE_ACTION_ITEM)
    CHAT_MESSAGE_CANT_USE_ACTION_ITEM = 29,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANTPAUSE)
    CHAT_MESSAGE_CANTPAUSE = 31,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_NOPAUSESLEFT)
    CHAT_MESSAGE_NOPAUSESLEFT = 32,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANTPAUSEYET)
    CHAT_MESSAGE_CANTPAUSEYET = 33,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PAUSED)
    CHAT_MESSAGE_PAUSED = 34,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_UNPAUSE_COUNTDOWN)
    CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 35,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_UNPAUSED)
    CHAT_MESSAGE_UNPAUSED = 36,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_AUTO_UNPAUSED)
    CHAT_MESSAGE_AUTO_UNPAUSED = 37,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_YOUPAUSED)
    CHAT_MESSAGE_YOUPAUSED = 38,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANTUNPAUSETEAM)
    CHAT_MESSAGE_CANTUNPAUSETEAM = 39,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_VOICE_TEXT_BANNED)
    CHAT_MESSAGE_VOICE_TEXT_BANNED = 41,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME)
    CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME = 42,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_REPORT_REMINDER)
    CHAT_MESSAGE_REPORT_REMINDER = 43,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ECON_ITEM)
    CHAT_MESSAGE_ECON_ITEM = 44,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_TAUNT)
    CHAT_MESSAGE_TAUNT = 45,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RANDOM)
    CHAT_MESSAGE_RANDOM = 46,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RD_TURN)
    CHAT_MESSAGE_RD_TURN = 47,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DROP_RATE_BONUS)
    CHAT_MESSAGE_DROP_RATE_BONUS = 49,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_NO_BATTLE_POINTS)
    CHAT_MESSAGE_NO_BATTLE_POINTS = 50,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DENIED_AEGIS)
    CHAT_MESSAGE_DENIED_AEGIS = 51,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_INFORMATIONAL)
    CHAT_MESSAGE_INFORMATIONAL = 52,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_AEGIS_STOLEN)
    CHAT_MESSAGE_AEGIS_STOLEN = 53,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ROSHAN_CANDY)
    CHAT_MESSAGE_ROSHAN_CANDY = 54,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEM_GIFTED)
    CHAT_MESSAGE_ITEM_GIFTED = 55,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL)
    CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL = 56,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED)
    CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED = 57,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED)
    CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED = 58,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HOLDOUT_WALL_FINISHED)
    CHAT_MESSAGE_HOLDOUT_WALL_FINISHED = 59,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO)
    CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO = 62,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION)
    CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION = 63,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT_LIMITED_HERO)
    CHAT_MESSAGE_DISCONNECT_LIMITED_HERO = 64,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION)
    CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION = 65,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS)
    CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS = 66,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE)
    CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE = 67,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_LEFT_AFK)
    CHAT_MESSAGE_PLAYER_LEFT_AFK = 73,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG)
    CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG = 74,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_ABANDONED)
    CHAT_MESSAGE_PLAYER_ABANDONED = 75,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_ABANDONED_AFK)
    CHAT_MESSAGE_PLAYER_ABANDONED_AFK = 76,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG)
    CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG = 77,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WILL_NOT_BE_SCORED)
    CHAT_MESSAGE_WILL_NOT_BE_SCORED = 78,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED)
    CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED = 79,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK)
    CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK = 80,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED)
    CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED = 81,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON)
    CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON = 82,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS)
    CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS = 83,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY)
    CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY = 84,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_COMPENDIUM_LEVEL)
    CHAT_MESSAGE_COMPENDIUM_LEVEL = 85,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_VICTORY_PREDICTION_STREAK)
    CHAT_MESSAGE_VICTORY_PREDICTION_STREAK = 86,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ASSASSIN_ANNOUNCE)
    CHAT_MESSAGE_ASSASSIN_ANNOUNCE = 87,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ASSASSIN_SUCCESS)
    CHAT_MESSAGE_ASSASSIN_SUCCESS = 88,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ASSASSIN_DENIED)
    CHAT_MESSAGE_ASSASSIN_DENIED = 89,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM)
    CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM = 90,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_EFFIGY_KILL)
    CHAT_MESSAGE_EFFIGY_KILL = 91,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW)
    CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW = 92,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_YEAR_BEAST_KILLED)
    CHAT_MESSAGE_YEAR_BEAST_KILLED = 93,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PAUSE_COUNTDOWN)
    CHAT_MESSAGE_PAUSE_COUNTDOWN = 94,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_COINS_WAGERED)
    CHAT_MESSAGE_COINS_WAGERED = 95,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_NOMINATED_BAN)
    CHAT_MESSAGE_HERO_NOMINATED_BAN = 96,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_BANNED)
    CHAT_MESSAGE_HERO_BANNED = 97,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_BAN_COUNT)
    CHAT_MESSAGE_HERO_BAN_COUNT = 98,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RIVER_PAINTED)
    CHAT_MESSAGE_RIVER_PAINTED = 99,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SCAN_USED)
    CHAT_MESSAGE_SCAN_USED = 100,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SHRINE_KILLED)
    CHAT_MESSAGE_SHRINE_KILLED = 101,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WAGER_TOKEN_SPENT)
    CHAT_MESSAGE_WAGER_TOKEN_SPENT = 102,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RANK_WAGER)
    CHAT_MESSAGE_RANK_WAGER = 103,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_NEW_PLAYER_REMINDER)
    CHAT_MESSAGE_NEW_PLAYER_REMINDER = 104,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_OBSERVER_WARD_KILLED)
    CHAT_MESSAGE_OBSERVER_WARD_KILLED = 105,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SENTRY_WARD_KILLED)
    CHAT_MESSAGE_SENTRY_WARD_KILLED = 106,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH)
    CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH = 107,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_CHOICE_INVALID)
    CHAT_MESSAGE_HERO_CHOICE_INVALID = 108,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_BOUNTY)
    CHAT_MESSAGE_BOUNTY = 109,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ABILITY_DRAFT_START)
    CHAT_MESSAGE_ABILITY_DRAFT_START = 110,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_FOUND_CANDY)
    CHAT_MESSAGE_HERO_FOUND_CANDY = 111,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED)
    CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED = 112,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PRIVATE_COACH_CONNECTED)
    CHAT_MESSAGE_PRIVATE_COACH_CONNECTED = 113,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY)
    CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY = 115,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN)
    CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN = 116,
}

impl ::protobuf::Enum for DOTA_CHAT_MESSAGE {
    const NAME: &'static str = "DOTA_CHAT_MESSAGE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_CHAT_MESSAGE> {
        match value {
            -1 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID),
            0 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL),
            1 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_DENY),
            2 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BARRACKS_KILL),
            3 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_KILL),
            4 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_DENY),
            5 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FIRSTBLOOD),
            6 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_STREAK_KILL),
            7 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BUYBACK),
            8 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS),
            9 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_KILL),
            10 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_LOST),
            11 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_RESPAWNED),
            12 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_GLYPH_USED),
            13 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PURCHASE),
            14 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CONNECT),
            15 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT),
            16 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT),
            17 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING),
            18 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL),
            19 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECONNECT),
            20 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT),
            21 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SAFE_TO_LEAVE),
            22 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_PICKUP),
            23 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_BOTTLE),
            114 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_DENY),
            24 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INTHEBAG),
            25 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SECRETSHOP),
            26 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_AUTOPURCHASED),
            27 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEMS_COMBINED),
            28 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SUPER_CREEPS),
            29 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_USE_ACTION_ITEM),
            31 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSE),
            32 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NOPAUSESLEFT),
            33 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSEYET),
            34 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSED),
            35 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSE_COUNTDOWN),
            36 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSED),
            37 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AUTO_UNPAUSED),
            38 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YOUPAUSED),
            39 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTUNPAUSETEAM),
            41 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED),
            42 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME),
            43 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_REPORT_REMINDER),
            44 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ECON_ITEM),
            45 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TAUNT),
            46 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANDOM),
            47 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RD_TURN),
            49 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DROP_RATE_BONUS),
            50 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NO_BATTLE_POINTS),
            51 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DENIED_AEGIS),
            52 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INFORMATIONAL),
            53 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS_STOLEN),
            54 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_CANDY),
            55 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_GIFTED),
            56 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL),
            57 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED),
            58 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED),
            59 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_FINISHED),
            62 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO),
            63 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION),
            64 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_LIMITED_HERO),
            65 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION),
            66 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS),
            67 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE),
            73 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_AFK),
            74 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG),
            75 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED),
            76 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_AFK),
            77 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG),
            78 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED),
            79 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED),
            80 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK),
            81 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED),
            82 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON),
            83 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS),
            84 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY),
            85 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COMPENDIUM_LEVEL),
            86 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_STREAK),
            87 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_ANNOUNCE),
            88 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_SUCCESS),
            89 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_DENIED),
            90 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM),
            91 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_EFFIGY_KILL),
            92 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW),
            93 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YEAR_BEAST_KILLED),
            94 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSE_COUNTDOWN),
            95 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COINS_WAGERED),
            96 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_NOMINATED_BAN),
            97 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BANNED),
            98 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BAN_COUNT),
            99 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RIVER_PAINTED),
            100 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SCAN_USED),
            101 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SHRINE_KILLED),
            102 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WAGER_TOKEN_SPENT),
            103 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANK_WAGER),
            104 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NEW_PLAYER_REMINDER),
            105 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_OBSERVER_WARD_KILLED),
            106 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SENTRY_WARD_KILLED),
            107 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH),
            108 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_CHOICE_INVALID),
            109 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BOUNTY),
            110 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_START),
            111 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_FOUND_CANDY),
            112 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED),
            113 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PRIVATE_COACH_CONNECTED),
            115 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY),
            116 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_CHAT_MESSAGE> {
        match str {
            "CHAT_MESSAGE_INVALID" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID),
            "CHAT_MESSAGE_HERO_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL),
            "CHAT_MESSAGE_HERO_DENY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_DENY),
            "CHAT_MESSAGE_BARRACKS_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BARRACKS_KILL),
            "CHAT_MESSAGE_TOWER_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_KILL),
            "CHAT_MESSAGE_TOWER_DENY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_DENY),
            "CHAT_MESSAGE_FIRSTBLOOD" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FIRSTBLOOD),
            "CHAT_MESSAGE_STREAK_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_STREAK_KILL),
            "CHAT_MESSAGE_BUYBACK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BUYBACK),
            "CHAT_MESSAGE_AEGIS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS),
            "CHAT_MESSAGE_ROSHAN_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_KILL),
            "CHAT_MESSAGE_COURIER_LOST" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_LOST),
            "CHAT_MESSAGE_COURIER_RESPAWNED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_RESPAWNED),
            "CHAT_MESSAGE_GLYPH_USED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_GLYPH_USED),
            "CHAT_MESSAGE_ITEM_PURCHASE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PURCHASE),
            "CHAT_MESSAGE_CONNECT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CONNECT),
            "CHAT_MESSAGE_DISCONNECT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT),
            "CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT),
            "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING),
            "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL),
            "CHAT_MESSAGE_RECONNECT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECONNECT),
            "CHAT_MESSAGE_PLAYER_LEFT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT),
            "CHAT_MESSAGE_SAFE_TO_LEAVE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SAFE_TO_LEAVE),
            "CHAT_MESSAGE_RUNE_PICKUP" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_PICKUP),
            "CHAT_MESSAGE_RUNE_BOTTLE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_BOTTLE),
            "CHAT_MESSAGE_RUNE_DENY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_DENY),
            "CHAT_MESSAGE_INTHEBAG" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INTHEBAG),
            "CHAT_MESSAGE_SECRETSHOP" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SECRETSHOP),
            "CHAT_MESSAGE_ITEM_AUTOPURCHASED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_AUTOPURCHASED),
            "CHAT_MESSAGE_ITEMS_COMBINED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEMS_COMBINED),
            "CHAT_MESSAGE_SUPER_CREEPS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SUPER_CREEPS),
            "CHAT_MESSAGE_CANT_USE_ACTION_ITEM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_USE_ACTION_ITEM),
            "CHAT_MESSAGE_CANTPAUSE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSE),
            "CHAT_MESSAGE_NOPAUSESLEFT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NOPAUSESLEFT),
            "CHAT_MESSAGE_CANTPAUSEYET" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSEYET),
            "CHAT_MESSAGE_PAUSED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSED),
            "CHAT_MESSAGE_UNPAUSE_COUNTDOWN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSE_COUNTDOWN),
            "CHAT_MESSAGE_UNPAUSED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSED),
            "CHAT_MESSAGE_AUTO_UNPAUSED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AUTO_UNPAUSED),
            "CHAT_MESSAGE_YOUPAUSED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YOUPAUSED),
            "CHAT_MESSAGE_CANTUNPAUSETEAM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTUNPAUSETEAM),
            "CHAT_MESSAGE_VOICE_TEXT_BANNED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED),
            "CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME),
            "CHAT_MESSAGE_REPORT_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_REPORT_REMINDER),
            "CHAT_MESSAGE_ECON_ITEM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ECON_ITEM),
            "CHAT_MESSAGE_TAUNT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TAUNT),
            "CHAT_MESSAGE_RANDOM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANDOM),
            "CHAT_MESSAGE_RD_TURN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RD_TURN),
            "CHAT_MESSAGE_DROP_RATE_BONUS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DROP_RATE_BONUS),
            "CHAT_MESSAGE_NO_BATTLE_POINTS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NO_BATTLE_POINTS),
            "CHAT_MESSAGE_DENIED_AEGIS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DENIED_AEGIS),
            "CHAT_MESSAGE_INFORMATIONAL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INFORMATIONAL),
            "CHAT_MESSAGE_AEGIS_STOLEN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS_STOLEN),
            "CHAT_MESSAGE_ROSHAN_CANDY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_CANDY),
            "CHAT_MESSAGE_ITEM_GIFTED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_GIFTED),
            "CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL),
            "CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED),
            "CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED),
            "CHAT_MESSAGE_HOLDOUT_WALL_FINISHED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_FINISHED),
            "CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO),
            "CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION),
            "CHAT_MESSAGE_DISCONNECT_LIMITED_HERO" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_LIMITED_HERO),
            "CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION),
            "CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS),
            "CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE),
            "CHAT_MESSAGE_PLAYER_LEFT_AFK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_AFK),
            "CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG),
            "CHAT_MESSAGE_PLAYER_ABANDONED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED),
            "CHAT_MESSAGE_PLAYER_ABANDONED_AFK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_AFK),
            "CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG),
            "CHAT_MESSAGE_WILL_NOT_BE_SCORED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED),
            "CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED),
            "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK),
            "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED),
            "CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON),
            "CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS),
            "CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY),
            "CHAT_MESSAGE_COMPENDIUM_LEVEL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COMPENDIUM_LEVEL),
            "CHAT_MESSAGE_VICTORY_PREDICTION_STREAK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_STREAK),
            "CHAT_MESSAGE_ASSASSIN_ANNOUNCE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_ANNOUNCE),
            "CHAT_MESSAGE_ASSASSIN_SUCCESS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_SUCCESS),
            "CHAT_MESSAGE_ASSASSIN_DENIED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_DENIED),
            "CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM),
            "CHAT_MESSAGE_EFFIGY_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_EFFIGY_KILL),
            "CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW),
            "CHAT_MESSAGE_YEAR_BEAST_KILLED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YEAR_BEAST_KILLED),
            "CHAT_MESSAGE_PAUSE_COUNTDOWN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSE_COUNTDOWN),
            "CHAT_MESSAGE_COINS_WAGERED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COINS_WAGERED),
            "CHAT_MESSAGE_HERO_NOMINATED_BAN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_NOMINATED_BAN),
            "CHAT_MESSAGE_HERO_BANNED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BANNED),
            "CHAT_MESSAGE_HERO_BAN_COUNT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BAN_COUNT),
            "CHAT_MESSAGE_RIVER_PAINTED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RIVER_PAINTED),
            "CHAT_MESSAGE_SCAN_USED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SCAN_USED),
            "CHAT_MESSAGE_SHRINE_KILLED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SHRINE_KILLED),
            "CHAT_MESSAGE_WAGER_TOKEN_SPENT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WAGER_TOKEN_SPENT),
            "CHAT_MESSAGE_RANK_WAGER" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANK_WAGER),
            "CHAT_MESSAGE_NEW_PLAYER_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NEW_PLAYER_REMINDER),
            "CHAT_MESSAGE_OBSERVER_WARD_KILLED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_OBSERVER_WARD_KILLED),
            "CHAT_MESSAGE_SENTRY_WARD_KILLED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SENTRY_WARD_KILLED),
            "CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH),
            "CHAT_MESSAGE_HERO_CHOICE_INVALID" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_CHOICE_INVALID),
            "CHAT_MESSAGE_BOUNTY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BOUNTY),
            "CHAT_MESSAGE_ABILITY_DRAFT_START" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_START),
            "CHAT_MESSAGE_HERO_FOUND_CANDY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_FOUND_CANDY),
            "CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED),
            "CHAT_MESSAGE_PRIVATE_COACH_CONNECTED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PRIVATE_COACH_CONNECTED),
            "CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY),
            "CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_CHAT_MESSAGE] = &[
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_DENY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BARRACKS_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_DENY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FIRSTBLOOD,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_STREAK_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BUYBACK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_LOST,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_RESPAWNED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_GLYPH_USED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PURCHASE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CONNECT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECONNECT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SAFE_TO_LEAVE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_PICKUP,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_BOTTLE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_DENY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INTHEBAG,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SECRETSHOP,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_AUTOPURCHASED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEMS_COMBINED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SUPER_CREEPS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_USE_ACTION_ITEM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NOPAUSESLEFT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSEYET,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSE_COUNTDOWN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AUTO_UNPAUSED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YOUPAUSED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTUNPAUSETEAM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_REPORT_REMINDER,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ECON_ITEM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TAUNT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANDOM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RD_TURN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DROP_RATE_BONUS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NO_BATTLE_POINTS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DENIED_AEGIS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INFORMATIONAL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS_STOLEN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_CANDY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_GIFTED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_FINISHED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_LIMITED_HERO,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_AFK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_AFK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COMPENDIUM_LEVEL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_STREAK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_ANNOUNCE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_SUCCESS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_DENIED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_EFFIGY_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YEAR_BEAST_KILLED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSE_COUNTDOWN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COINS_WAGERED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_NOMINATED_BAN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BANNED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BAN_COUNT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RIVER_PAINTED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SCAN_USED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SHRINE_KILLED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WAGER_TOKEN_SPENT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANK_WAGER,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NEW_PLAYER_REMINDER,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_OBSERVER_WARD_KILLED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SENTRY_WARD_KILLED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_CHOICE_INVALID,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BOUNTY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_START,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_FOUND_CANDY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PRIVATE_COACH_CONNECTED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN,
    ];
}

impl ::protobuf::EnumFull for DOTA_CHAT_MESSAGE {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_CHAT_MESSAGE").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID => 0,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL => 1,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_DENY => 2,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BARRACKS_KILL => 3,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_KILL => 4,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_DENY => 5,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FIRSTBLOOD => 6,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_STREAK_KILL => 7,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BUYBACK => 8,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS => 9,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_KILL => 10,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_LOST => 11,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_RESPAWNED => 12,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_GLYPH_USED => 13,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PURCHASE => 14,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CONNECT => 15,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT => 16,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT => 17,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING => 18,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL => 19,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECONNECT => 20,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT => 21,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SAFE_TO_LEAVE => 22,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_PICKUP => 23,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_BOTTLE => 24,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_DENY => 25,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INTHEBAG => 26,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SECRETSHOP => 27,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_AUTOPURCHASED => 28,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEMS_COMBINED => 29,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SUPER_CREEPS => 30,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_USE_ACTION_ITEM => 31,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSE => 32,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NOPAUSESLEFT => 33,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSEYET => 34,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSED => 35,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSE_COUNTDOWN => 36,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSED => 37,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AUTO_UNPAUSED => 38,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YOUPAUSED => 39,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTUNPAUSETEAM => 40,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED => 41,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME => 42,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_REPORT_REMINDER => 43,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ECON_ITEM => 44,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TAUNT => 45,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANDOM => 46,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RD_TURN => 47,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DROP_RATE_BONUS => 48,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NO_BATTLE_POINTS => 49,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DENIED_AEGIS => 50,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INFORMATIONAL => 51,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS_STOLEN => 52,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_CANDY => 53,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_GIFTED => 54,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL => 55,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED => 56,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED => 57,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_FINISHED => 58,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO => 59,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION => 60,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_LIMITED_HERO => 61,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION => 62,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS => 63,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE => 64,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_AFK => 65,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG => 66,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED => 67,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_AFK => 68,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG => 69,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED => 70,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED => 71,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK => 72,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED => 73,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON => 74,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS => 75,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY => 76,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COMPENDIUM_LEVEL => 77,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_STREAK => 78,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_ANNOUNCE => 79,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_SUCCESS => 80,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_DENIED => 81,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM => 82,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_EFFIGY_KILL => 83,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW => 84,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YEAR_BEAST_KILLED => 85,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSE_COUNTDOWN => 86,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COINS_WAGERED => 87,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_NOMINATED_BAN => 88,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BANNED => 89,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BAN_COUNT => 90,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RIVER_PAINTED => 91,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SCAN_USED => 92,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SHRINE_KILLED => 93,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WAGER_TOKEN_SPENT => 94,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANK_WAGER => 95,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NEW_PLAYER_REMINDER => 96,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_OBSERVER_WARD_KILLED => 97,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SENTRY_WARD_KILLED => 98,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH => 99,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_CHOICE_INVALID => 100,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BOUNTY => 101,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_START => 102,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_FOUND_CANDY => 103,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED => 104,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PRIVATE_COACH_CONNECTED => 105,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY => 106,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN => 107,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_CHAT_MESSAGE {
    fn default() -> Self {
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID
    }
}

impl DOTA_CHAT_MESSAGE {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_CHAT_MESSAGE>("DOTA_CHAT_MESSAGE")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_NO_BATTLE_POINTS_REASONS)
pub enum DOTA_NO_BATTLE_POINTS_REASONS {
    // @@protoc_insertion_point(enum_value:dota.DOTA_NO_BATTLE_POINTS_REASONS.NO_BATTLE_POINTS_WRONG_LOBBY_TYPE)
    NO_BATTLE_POINTS_WRONG_LOBBY_TYPE = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_NO_BATTLE_POINTS_REASONS.NO_BATTLE_POINTS_PRACTICE_BOTS)
    NO_BATTLE_POINTS_PRACTICE_BOTS = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_NO_BATTLE_POINTS_REASONS.NO_BATTLE_POINTS_CHEATS_ENABLED)
    NO_BATTLE_POINTS_CHEATS_ENABLED = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_NO_BATTLE_POINTS_REASONS.NO_BATTLE_POINTS_LOW_PRIORITY)
    NO_BATTLE_POINTS_LOW_PRIORITY = 4,
}

impl ::protobuf::Enum for DOTA_NO_BATTLE_POINTS_REASONS {
    const NAME: &'static str = "DOTA_NO_BATTLE_POINTS_REASONS";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_NO_BATTLE_POINTS_REASONS> {
        match value {
            1 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE),
            2 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_PRACTICE_BOTS),
            3 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_CHEATS_ENABLED),
            4 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_LOW_PRIORITY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_NO_BATTLE_POINTS_REASONS> {
        match str {
            "NO_BATTLE_POINTS_WRONG_LOBBY_TYPE" => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE),
            "NO_BATTLE_POINTS_PRACTICE_BOTS" => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_PRACTICE_BOTS),
            "NO_BATTLE_POINTS_CHEATS_ENABLED" => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_CHEATS_ENABLED),
            "NO_BATTLE_POINTS_LOW_PRIORITY" => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_LOW_PRIORITY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_NO_BATTLE_POINTS_REASONS] = &[
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE,
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_PRACTICE_BOTS,
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_CHEATS_ENABLED,
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_LOW_PRIORITY,
    ];
}

impl ::protobuf::EnumFull for DOTA_NO_BATTLE_POINTS_REASONS {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_NO_BATTLE_POINTS_REASONS").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE => 0,
            DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_PRACTICE_BOTS => 1,
            DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_CHEATS_ENABLED => 2,
            DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_LOW_PRIORITY => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_NO_BATTLE_POINTS_REASONS {
    fn default() -> Self {
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE
    }
}

impl DOTA_NO_BATTLE_POINTS_REASONS {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_NO_BATTLE_POINTS_REASONS>("DOTA_NO_BATTLE_POINTS_REASONS")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_CHAT_INFORMATIONAL)
pub enum DOTA_CHAT_INFORMATIONAL {
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_INFORMATIONAL.INFO_COOP_BATTLE_POINTS_RULES)
    INFO_COOP_BATTLE_POINTS_RULES = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_INFORMATIONAL.INFO_FROSTIVUS_ABANDON_REMINDER)
    INFO_FROSTIVUS_ABANDON_REMINDER = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_INFORMATIONAL.INFO_RANKED_REMINDER)
    INFO_RANKED_REMINDER = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_INFORMATIONAL.INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER)
    INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_CHAT_INFORMATIONAL.INFO_CUSTOM_GAME_PENALTY_REMINDER)
    INFO_CUSTOM_GAME_PENALTY_REMINDER = 5,
}

impl ::protobuf::Enum for DOTA_CHAT_INFORMATIONAL {
    const NAME: &'static str = "DOTA_CHAT_INFORMATIONAL";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_CHAT_INFORMATIONAL> {
        match value {
            1 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES),
            2 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_FROSTIVUS_ABANDON_REMINDER),
            3 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_RANKED_REMINDER),
            4 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER),
            5 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_CUSTOM_GAME_PENALTY_REMINDER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_CHAT_INFORMATIONAL> {
        match str {
            "INFO_COOP_BATTLE_POINTS_RULES" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES),
            "INFO_FROSTIVUS_ABANDON_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_FROSTIVUS_ABANDON_REMINDER),
            "INFO_RANKED_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_RANKED_REMINDER),
            "INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER),
            "INFO_CUSTOM_GAME_PENALTY_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_CUSTOM_GAME_PENALTY_REMINDER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_CHAT_INFORMATIONAL] = &[
        DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES,
        DOTA_CHAT_INFORMATIONAL::INFO_FROSTIVUS_ABANDON_REMINDER,
        DOTA_CHAT_INFORMATIONAL::INFO_RANKED_REMINDER,
        DOTA_CHAT_INFORMATIONAL::INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER,
        DOTA_CHAT_INFORMATIONAL::INFO_CUSTOM_GAME_PENALTY_REMINDER,
    ];
}

impl ::protobuf::EnumFull for DOTA_CHAT_INFORMATIONAL {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_CHAT_INFORMATIONAL").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES => 0,
            DOTA_CHAT_INFORMATIONAL::INFO_FROSTIVUS_ABANDON_REMINDER => 1,
            DOTA_CHAT_INFORMATIONAL::INFO_RANKED_REMINDER => 2,
            DOTA_CHAT_INFORMATIONAL::INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER => 3,
            DOTA_CHAT_INFORMATIONAL::INFO_CUSTOM_GAME_PENALTY_REMINDER => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_CHAT_INFORMATIONAL {
    fn default() -> Self {
        DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES
    }
}

impl DOTA_CHAT_INFORMATIONAL {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_CHAT_INFORMATIONAL>("DOTA_CHAT_INFORMATIONAL")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_ABILITY_PING_TYPE)
pub enum DOTA_ABILITY_PING_TYPE {
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_READY)
    ABILITY_PING_READY = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_MANA)
    ABILITY_PING_MANA = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_COOLDOWN)
    ABILITY_PING_COOLDOWN = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_ENEMY)
    ABILITY_PING_ENEMY = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_UNLEARNED)
    ABILITY_PING_UNLEARNED = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_INBACKPACK)
    ABILITY_PING_INBACKPACK = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_INSTASH)
    ABILITY_PING_INSTASH = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_ONCOURIER)
    ABILITY_PING_ONCOURIER = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_ALLY)
    ABILITY_PING_ALLY = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_LEARN_READY)
    ABILITY_PING_LEARN_READY = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_WILL_LEARN)
    ABILITY_PING_WILL_LEARN = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_FUTURE_LEARN)
    ABILITY_PING_FUTURE_LEARN = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_NEUTRAL_OFFER)
    ABILITY_PING_NEUTRAL_OFFER = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_NEUTRAL_REQUEST)
    ABILITY_PING_NEUTRAL_REQUEST = 14,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_NEUTRAL_EQUIP)
    ABILITY_PING_NEUTRAL_EQUIP = 15,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_PING_TYPE.ABILITY_PING_INCOURIERBACKPACK)
    ABILITY_PING_INCOURIERBACKPACK = 16,
}

impl ::protobuf::Enum for DOTA_ABILITY_PING_TYPE {
    const NAME: &'static str = "DOTA_ABILITY_PING_TYPE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_ABILITY_PING_TYPE> {
        match value {
            1 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY),
            2 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_MANA),
            3 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_COOLDOWN),
            4 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ENEMY),
            5 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_UNLEARNED),
            6 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INBACKPACK),
            7 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INSTASH),
            8 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ONCOURIER),
            9 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ALLY),
            10 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_LEARN_READY),
            11 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_WILL_LEARN),
            12 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_FUTURE_LEARN),
            13 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_OFFER),
            14 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_REQUEST),
            15 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_EQUIP),
            16 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INCOURIERBACKPACK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_ABILITY_PING_TYPE> {
        match str {
            "ABILITY_PING_READY" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY),
            "ABILITY_PING_MANA" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_MANA),
            "ABILITY_PING_COOLDOWN" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_COOLDOWN),
            "ABILITY_PING_ENEMY" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ENEMY),
            "ABILITY_PING_UNLEARNED" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_UNLEARNED),
            "ABILITY_PING_INBACKPACK" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INBACKPACK),
            "ABILITY_PING_INSTASH" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INSTASH),
            "ABILITY_PING_ONCOURIER" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ONCOURIER),
            "ABILITY_PING_ALLY" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ALLY),
            "ABILITY_PING_LEARN_READY" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_LEARN_READY),
            "ABILITY_PING_WILL_LEARN" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_WILL_LEARN),
            "ABILITY_PING_FUTURE_LEARN" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_FUTURE_LEARN),
            "ABILITY_PING_NEUTRAL_OFFER" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_OFFER),
            "ABILITY_PING_NEUTRAL_REQUEST" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_REQUEST),
            "ABILITY_PING_NEUTRAL_EQUIP" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_EQUIP),
            "ABILITY_PING_INCOURIERBACKPACK" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INCOURIERBACKPACK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_ABILITY_PING_TYPE] = &[
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_MANA,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_COOLDOWN,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_ENEMY,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_UNLEARNED,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_INBACKPACK,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_INSTASH,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_ONCOURIER,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_ALLY,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_LEARN_READY,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_WILL_LEARN,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_FUTURE_LEARN,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_OFFER,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_REQUEST,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_EQUIP,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_INCOURIERBACKPACK,
    ];
}

impl ::protobuf::EnumFull for DOTA_ABILITY_PING_TYPE {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_ABILITY_PING_TYPE").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY => 0,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_MANA => 1,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_COOLDOWN => 2,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_ENEMY => 3,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_UNLEARNED => 4,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_INBACKPACK => 5,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_INSTASH => 6,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_ONCOURIER => 7,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_ALLY => 8,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_LEARN_READY => 9,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_WILL_LEARN => 10,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_FUTURE_LEARN => 11,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_OFFER => 12,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_REQUEST => 13,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_EQUIP => 14,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_INCOURIERBACKPACK => 15,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_ABILITY_PING_TYPE {
    fn default() -> Self {
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY
    }
}

impl DOTA_ABILITY_PING_TYPE {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_ABILITY_PING_TYPE>("DOTA_ABILITY_PING_TYPE")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_REPLAY_STATE_EVENT)
pub enum DOTA_REPLAY_STATE_EVENT {
    // @@protoc_insertion_point(enum_value:dota.DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_GAME_START)
    DOTA_REPLAY_STATE_EVENT_GAME_START = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_STARTING_HORN)
    DOTA_REPLAY_STATE_EVENT_STARTING_HORN = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD)
    DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_SHOWCASE)
    DOTA_REPLAY_STATE_EVENT_SHOWCASE = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_POST_GAME)
    DOTA_REPLAY_STATE_EVENT_POST_GAME = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP)
    DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP = 6,
}

impl ::protobuf::Enum for DOTA_REPLAY_STATE_EVENT {
    const NAME: &'static str = "DOTA_REPLAY_STATE_EVENT";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_REPLAY_STATE_EVENT> {
        match value {
            1 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START),
            2 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_STARTING_HORN),
            3 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD),
            4 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_SHOWCASE),
            5 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_POST_GAME),
            6 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_REPLAY_STATE_EVENT> {
        match str {
            "DOTA_REPLAY_STATE_EVENT_GAME_START" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START),
            "DOTA_REPLAY_STATE_EVENT_STARTING_HORN" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_STARTING_HORN),
            "DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD),
            "DOTA_REPLAY_STATE_EVENT_SHOWCASE" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_SHOWCASE),
            "DOTA_REPLAY_STATE_EVENT_POST_GAME" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_POST_GAME),
            "DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_REPLAY_STATE_EVENT] = &[
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_STARTING_HORN,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_SHOWCASE,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_POST_GAME,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP,
    ];
}

impl ::protobuf::EnumFull for DOTA_REPLAY_STATE_EVENT {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_REPLAY_STATE_EVENT").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START => 0,
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_STARTING_HORN => 1,
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD => 2,
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_SHOWCASE => 3,
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_POST_GAME => 4,
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_REPLAY_STATE_EVENT {
    fn default() -> Self {
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START
    }
}

impl DOTA_REPLAY_STATE_EVENT {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_REPLAY_STATE_EVENT>("DOTA_REPLAY_STATE_EVENT")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EDotaEntityMessages)
pub enum EDotaEntityMessages {
    // @@protoc_insertion_point(enum_value:dota.EDotaEntityMessages.DOTA_UNIT_SPEECH)
    DOTA_UNIT_SPEECH = 0,
    // @@protoc_insertion_point(enum_value:dota.EDotaEntityMessages.DOTA_UNIT_SPEECH_MUTE)
    DOTA_UNIT_SPEECH_MUTE = 1,
    // @@protoc_insertion_point(enum_value:dota.EDotaEntityMessages.DOTA_UNIT_ADD_GESTURE)
    DOTA_UNIT_ADD_GESTURE = 2,
    // @@protoc_insertion_point(enum_value:dota.EDotaEntityMessages.DOTA_UNIT_REMOVE_GESTURE)
    DOTA_UNIT_REMOVE_GESTURE = 3,
    // @@protoc_insertion_point(enum_value:dota.EDotaEntityMessages.DOTA_UNIT_REMOVE_ALL_GESTURES)
    DOTA_UNIT_REMOVE_ALL_GESTURES = 4,
    // @@protoc_insertion_point(enum_value:dota.EDotaEntityMessages.DOTA_UNIT_FADE_GESTURE)
    DOTA_UNIT_FADE_GESTURE = 6,
    // @@protoc_insertion_point(enum_value:dota.EDotaEntityMessages.DOTA_UNIT_SPEECH_CLIENTSIDE_RULES)
    DOTA_UNIT_SPEECH_CLIENTSIDE_RULES = 7,
}

impl ::protobuf::Enum for EDotaEntityMessages {
    const NAME: &'static str = "EDotaEntityMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDotaEntityMessages> {
        match value {
            0 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH),
            1 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_MUTE),
            2 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_ADD_GESTURE),
            3 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_GESTURE),
            4 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_ALL_GESTURES),
            6 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_FADE_GESTURE),
            7 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_CLIENTSIDE_RULES),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDotaEntityMessages> {
        match str {
            "DOTA_UNIT_SPEECH" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH),
            "DOTA_UNIT_SPEECH_MUTE" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_MUTE),
            "DOTA_UNIT_ADD_GESTURE" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_ADD_GESTURE),
            "DOTA_UNIT_REMOVE_GESTURE" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_GESTURE),
            "DOTA_UNIT_REMOVE_ALL_GESTURES" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_ALL_GESTURES),
            "DOTA_UNIT_FADE_GESTURE" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_FADE_GESTURE),
            "DOTA_UNIT_SPEECH_CLIENTSIDE_RULES" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_CLIENTSIDE_RULES),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDotaEntityMessages] = &[
        EDotaEntityMessages::DOTA_UNIT_SPEECH,
        EDotaEntityMessages::DOTA_UNIT_SPEECH_MUTE,
        EDotaEntityMessages::DOTA_UNIT_ADD_GESTURE,
        EDotaEntityMessages::DOTA_UNIT_REMOVE_GESTURE,
        EDotaEntityMessages::DOTA_UNIT_REMOVE_ALL_GESTURES,
        EDotaEntityMessages::DOTA_UNIT_FADE_GESTURE,
        EDotaEntityMessages::DOTA_UNIT_SPEECH_CLIENTSIDE_RULES,
    ];
}

impl ::protobuf::EnumFull for EDotaEntityMessages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDotaEntityMessages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EDotaEntityMessages::DOTA_UNIT_SPEECH => 0,
            EDotaEntityMessages::DOTA_UNIT_SPEECH_MUTE => 1,
            EDotaEntityMessages::DOTA_UNIT_ADD_GESTURE => 2,
            EDotaEntityMessages::DOTA_UNIT_REMOVE_GESTURE => 3,
            EDotaEntityMessages::DOTA_UNIT_REMOVE_ALL_GESTURES => 4,
            EDotaEntityMessages::DOTA_UNIT_FADE_GESTURE => 5,
            EDotaEntityMessages::DOTA_UNIT_SPEECH_CLIENTSIDE_RULES => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EDotaEntityMessages {
    fn default() -> Self {
        EDotaEntityMessages::DOTA_UNIT_SPEECH
    }
}

impl EDotaEntityMessages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDotaEntityMessages>("EDotaEntityMessages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_OVERHEAD_ALERT)
pub enum DOTA_OVERHEAD_ALERT {
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_GOLD)
    OVERHEAD_ALERT_GOLD = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DENY)
    OVERHEAD_ALERT_DENY = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_CRITICAL)
    OVERHEAD_ALERT_CRITICAL = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_XP)
    OVERHEAD_ALERT_XP = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_BONUS_SPELL_DAMAGE)
    OVERHEAD_ALERT_BONUS_SPELL_DAMAGE = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_MISS)
    OVERHEAD_ALERT_MISS = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DAMAGE)
    OVERHEAD_ALERT_DAMAGE = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_EVADE)
    OVERHEAD_ALERT_EVADE = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_BLOCK)
    OVERHEAD_ALERT_BLOCK = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_BONUS_POISON_DAMAGE)
    OVERHEAD_ALERT_BONUS_POISON_DAMAGE = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_HEAL)
    OVERHEAD_ALERT_HEAL = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_MANA_ADD)
    OVERHEAD_ALERT_MANA_ADD = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_MANA_LOSS)
    OVERHEAD_ALERT_MANA_LOSS = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_LAST_HIT_EARLY)
    OVERHEAD_ALERT_LAST_HIT_EARLY = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_LAST_HIT_CLOSE)
    OVERHEAD_ALERT_LAST_HIT_CLOSE = 14,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_LAST_HIT_MISS)
    OVERHEAD_ALERT_LAST_HIT_MISS = 15,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_MAGICAL_BLOCK)
    OVERHEAD_ALERT_MAGICAL_BLOCK = 16,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_INCOMING_DAMAGE)
    OVERHEAD_ALERT_INCOMING_DAMAGE = 17,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_OUTGOING_DAMAGE)
    OVERHEAD_ALERT_OUTGOING_DAMAGE = 18,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DISABLE_RESIST)
    OVERHEAD_ALERT_DISABLE_RESIST = 19,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DEATH)
    OVERHEAD_ALERT_DEATH = 20,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_BLOCKED)
    OVERHEAD_ALERT_BLOCKED = 21,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_ITEM_RECEIVED)
    OVERHEAD_ALERT_ITEM_RECEIVED = 22,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_SHARD)
    OVERHEAD_ALERT_SHARD = 23,
    // @@protoc_insertion_point(enum_value:dota.DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DEADLY_BLOW)
    OVERHEAD_ALERT_DEADLY_BLOW = 24,
}

impl ::protobuf::Enum for DOTA_OVERHEAD_ALERT {
    const NAME: &'static str = "DOTA_OVERHEAD_ALERT";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_OVERHEAD_ALERT> {
        match value {
            0 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD),
            1 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DENY),
            2 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_CRITICAL),
            3 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_XP),
            4 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_SPELL_DAMAGE),
            5 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MISS),
            6 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DAMAGE),
            7 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_EVADE),
            8 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCK),
            9 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_POISON_DAMAGE),
            10 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_HEAL),
            11 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_ADD),
            12 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_LOSS),
            13 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_EARLY),
            14 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_CLOSE),
            15 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_MISS),
            16 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MAGICAL_BLOCK),
            17 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_INCOMING_DAMAGE),
            18 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_OUTGOING_DAMAGE),
            19 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DISABLE_RESIST),
            20 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEATH),
            21 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCKED),
            22 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_ITEM_RECEIVED),
            23 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_SHARD),
            24 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEADLY_BLOW),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_OVERHEAD_ALERT> {
        match str {
            "OVERHEAD_ALERT_GOLD" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD),
            "OVERHEAD_ALERT_DENY" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DENY),
            "OVERHEAD_ALERT_CRITICAL" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_CRITICAL),
            "OVERHEAD_ALERT_XP" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_XP),
            "OVERHEAD_ALERT_BONUS_SPELL_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_SPELL_DAMAGE),
            "OVERHEAD_ALERT_MISS" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MISS),
            "OVERHEAD_ALERT_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DAMAGE),
            "OVERHEAD_ALERT_EVADE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_EVADE),
            "OVERHEAD_ALERT_BLOCK" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCK),
            "OVERHEAD_ALERT_BONUS_POISON_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_POISON_DAMAGE),
            "OVERHEAD_ALERT_HEAL" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_HEAL),
            "OVERHEAD_ALERT_MANA_ADD" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_ADD),
            "OVERHEAD_ALERT_MANA_LOSS" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_LOSS),
            "OVERHEAD_ALERT_LAST_HIT_EARLY" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_EARLY),
            "OVERHEAD_ALERT_LAST_HIT_CLOSE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_CLOSE),
            "OVERHEAD_ALERT_LAST_HIT_MISS" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_MISS),
            "OVERHEAD_ALERT_MAGICAL_BLOCK" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MAGICAL_BLOCK),
            "OVERHEAD_ALERT_INCOMING_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_INCOMING_DAMAGE),
            "OVERHEAD_ALERT_OUTGOING_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_OUTGOING_DAMAGE),
            "OVERHEAD_ALERT_DISABLE_RESIST" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DISABLE_RESIST),
            "OVERHEAD_ALERT_DEATH" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEATH),
            "OVERHEAD_ALERT_BLOCKED" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCKED),
            "OVERHEAD_ALERT_ITEM_RECEIVED" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_ITEM_RECEIVED),
            "OVERHEAD_ALERT_SHARD" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_SHARD),
            "OVERHEAD_ALERT_DEADLY_BLOW" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEADLY_BLOW),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_OVERHEAD_ALERT] = &[
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DENY,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_CRITICAL,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_XP,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_SPELL_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MISS,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_EVADE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCK,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_POISON_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_HEAL,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_ADD,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_LOSS,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_EARLY,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_CLOSE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_MISS,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MAGICAL_BLOCK,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_INCOMING_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_OUTGOING_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DISABLE_RESIST,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEATH,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCKED,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_ITEM_RECEIVED,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_SHARD,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEADLY_BLOW,
    ];
}

impl ::protobuf::EnumFull for DOTA_OVERHEAD_ALERT {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_OVERHEAD_ALERT").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_OVERHEAD_ALERT {
    fn default() -> Self {
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD
    }
}

impl DOTA_OVERHEAD_ALERT {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_OVERHEAD_ALERT>("DOTA_OVERHEAD_ALERT")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_ROSHAN_PHASE)
pub enum DOTA_ROSHAN_PHASE {
    // @@protoc_insertion_point(enum_value:dota.DOTA_ROSHAN_PHASE.k_SRSP_ROSHAN_ALIVE)
    k_SRSP_ROSHAN_ALIVE = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ROSHAN_PHASE.k_SRSP_ROSHAN_BASE_TIMER)
    k_SRSP_ROSHAN_BASE_TIMER = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ROSHAN_PHASE.k_SRSP_ROSHAN_VISIBLE_TIMER)
    k_SRSP_ROSHAN_VISIBLE_TIMER = 2,
}

impl ::protobuf::Enum for DOTA_ROSHAN_PHASE {
    const NAME: &'static str = "DOTA_ROSHAN_PHASE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_ROSHAN_PHASE> {
        match value {
            0 => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE),
            1 => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_BASE_TIMER),
            2 => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_VISIBLE_TIMER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_ROSHAN_PHASE> {
        match str {
            "k_SRSP_ROSHAN_ALIVE" => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE),
            "k_SRSP_ROSHAN_BASE_TIMER" => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_BASE_TIMER),
            "k_SRSP_ROSHAN_VISIBLE_TIMER" => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_VISIBLE_TIMER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_ROSHAN_PHASE] = &[
        DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE,
        DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_BASE_TIMER,
        DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_VISIBLE_TIMER,
    ];
}

impl ::protobuf::EnumFull for DOTA_ROSHAN_PHASE {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_ROSHAN_PHASE").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_ROSHAN_PHASE {
    fn default() -> Self {
        DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE
    }
}

impl DOTA_ROSHAN_PHASE {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_ROSHAN_PHASE>("DOTA_ROSHAN_PHASE")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_POSITION_CATEGORY)
pub enum DOTA_POSITION_CATEGORY {
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_NONE)
    DOTA_POSITION_NONE = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_BOTTOM_LANE)
    DOTA_POSITION_BOTTOM_LANE = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_MID_LANE)
    DOTA_POSITION_MID_LANE = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_TOP_LANE)
    DOTA_POSITION_TOP_LANE = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_RADIANT_JUNGLE)
    DOTA_POSITION_RADIANT_JUNGLE = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_DIRE_JUNGLE)
    DOTA_POSITION_DIRE_JUNGLE = 5,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_RADIANT_ANCIENTS)
    DOTA_POSITION_RADIANT_ANCIENTS = 6,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_DIRE_ANCIENTS)
    DOTA_POSITION_DIRE_ANCIENTS = 7,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_RADIANT_SECRET_SHOP)
    DOTA_POSITION_RADIANT_SECRET_SHOP = 8,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_DIRE_SECRET_SHOP)
    DOTA_POSITION_DIRE_SECRET_SHOP = 9,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_RIVER)
    DOTA_POSITION_RIVER = 10,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_ROSHAN_PIT)
    DOTA_POSITION_ROSHAN_PIT = 11,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_RADIANT_BASE)
    DOTA_POSITION_RADIANT_BASE = 12,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_DIRE_BASE)
    DOTA_POSITION_DIRE_BASE = 13,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_FOUNTAIN)
    DOTA_POSITION_FOUNTAIN = 14,
    // @@protoc_insertion_point(enum_value:dota.DOTA_POSITION_CATEGORY.DOTA_POSITION_OTHER)
    DOTA_POSITION_OTHER = 15,
}

impl ::protobuf::Enum for DOTA_POSITION_CATEGORY {
    const NAME: &'static str = "DOTA_POSITION_CATEGORY";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_POSITION_CATEGORY> {
        match value {
            0 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE),
            1 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_BOTTOM_LANE),
            2 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_MID_LANE),
            3 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_TOP_LANE),
            4 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_JUNGLE),
            5 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_JUNGLE),
            6 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_ANCIENTS),
            7 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_ANCIENTS),
            8 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_SECRET_SHOP),
            9 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_SECRET_SHOP),
            10 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RIVER),
            11 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_ROSHAN_PIT),
            12 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_BASE),
            13 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_BASE),
            14 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_FOUNTAIN),
            15 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_POSITION_CATEGORY> {
        match str {
            "DOTA_POSITION_NONE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE),
            "DOTA_POSITION_BOTTOM_LANE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_BOTTOM_LANE),
            "DOTA_POSITION_MID_LANE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_MID_LANE),
            "DOTA_POSITION_TOP_LANE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_TOP_LANE),
            "DOTA_POSITION_RADIANT_JUNGLE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_JUNGLE),
            "DOTA_POSITION_DIRE_JUNGLE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_JUNGLE),
            "DOTA_POSITION_RADIANT_ANCIENTS" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_ANCIENTS),
            "DOTA_POSITION_DIRE_ANCIENTS" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_ANCIENTS),
            "DOTA_POSITION_RADIANT_SECRET_SHOP" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_SECRET_SHOP),
            "DOTA_POSITION_DIRE_SECRET_SHOP" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_SECRET_SHOP),
            "DOTA_POSITION_RIVER" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RIVER),
            "DOTA_POSITION_ROSHAN_PIT" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_ROSHAN_PIT),
            "DOTA_POSITION_RADIANT_BASE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_BASE),
            "DOTA_POSITION_DIRE_BASE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_BASE),
            "DOTA_POSITION_FOUNTAIN" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_FOUNTAIN),
            "DOTA_POSITION_OTHER" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_POSITION_CATEGORY] = &[
        DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_BOTTOM_LANE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_MID_LANE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_TOP_LANE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_JUNGLE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_JUNGLE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_ANCIENTS,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_ANCIENTS,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_SECRET_SHOP,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_SECRET_SHOP,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RIVER,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_ROSHAN_PIT,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_BASE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_BASE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_FOUNTAIN,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_OTHER,
    ];
}

impl ::protobuf::EnumFull for DOTA_POSITION_CATEGORY {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_POSITION_CATEGORY").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_POSITION_CATEGORY {
    fn default() -> Self {
        DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE
    }
}

impl DOTA_POSITION_CATEGORY {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_POSITION_CATEGORY>("DOTA_POSITION_CATEGORY")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.DOTA_ABILITY_TARGET_TYPE)
pub enum DOTA_ABILITY_TARGET_TYPE {
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_NONE)
    DOTA_ABILITY_TARGET_NONE = 0,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_SELF)
    DOTA_ABILITY_TARGET_SELF = 1,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_ALLY_HERO)
    DOTA_ABILITY_TARGET_ALLY_HERO = 2,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_ALLY_CREEP)
    DOTA_ABILITY_TARGET_ALLY_CREEP = 3,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_ENEMY_HERO)
    DOTA_ABILITY_TARGET_ENEMY_HERO = 4,
    // @@protoc_insertion_point(enum_value:dota.DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_ENEMY_CREEP)
    DOTA_ABILITY_TARGET_ENEMY_CREEP = 5,
}

impl ::protobuf::Enum for DOTA_ABILITY_TARGET_TYPE {
    const NAME: &'static str = "DOTA_ABILITY_TARGET_TYPE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_ABILITY_TARGET_TYPE> {
        match value {
            0 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE),
            1 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_SELF),
            2 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_HERO),
            3 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_CREEP),
            4 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_HERO),
            5 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_CREEP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_ABILITY_TARGET_TYPE> {
        match str {
            "DOTA_ABILITY_TARGET_NONE" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE),
            "DOTA_ABILITY_TARGET_SELF" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_SELF),
            "DOTA_ABILITY_TARGET_ALLY_HERO" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_HERO),
            "DOTA_ABILITY_TARGET_ALLY_CREEP" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_CREEP),
            "DOTA_ABILITY_TARGET_ENEMY_HERO" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_HERO),
            "DOTA_ABILITY_TARGET_ENEMY_CREEP" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_CREEP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_ABILITY_TARGET_TYPE] = &[
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_SELF,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_HERO,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_CREEP,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_HERO,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_CREEP,
    ];
}

impl ::protobuf::EnumFull for DOTA_ABILITY_TARGET_TYPE {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DOTA_ABILITY_TARGET_TYPE").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DOTA_ABILITY_TARGET_TYPE {
    fn default() -> Self {
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE
    }
}

impl DOTA_ABILITY_TARGET_TYPE {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DOTA_ABILITY_TARGET_TYPE>("DOTA_ABILITY_TARGET_TYPE")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EHeroStatType)
pub enum EHeroStatType {
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_None)
    k_EHeroStatType_None = 0,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_AxeTotalDamage)
    k_EHeroStatType_AxeTotalDamage = 2000,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_BattleHungerDamage)
    k_EHeroStatType_BattleHungerDamage = 2001,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CounterHelixDamage)
    k_EHeroStatType_CounterHelixDamage = 2002,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CullingBladeDamage)
    k_EHeroStatType_CullingBladeDamage = 2003,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_BerserkersCallCastCount)
    k_EHeroStatType_BerserkersCallCastCount = 2004,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_BerserkersCallHeroesHitAverage)
    k_EHeroStatType_BerserkersCallHeroesHitAverage = 2005,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_BerserkersCallOtherUnitsHit)
    k_EHeroStatType_BerserkersCallOtherUnitsHit = 2006,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_BerserkersCallHeroAttacksTaken)
    k_EHeroStatType_BerserkersCallHeroAttacksTaken = 2007,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_BerserkersCallOtherAttacksTaken)
    k_EHeroStatType_BerserkersCallOtherAttacksTaken = 2008,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_BattleHungerCastCount)
    k_EHeroStatType_BattleHungerCastCount = 2009,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_BattleHungerPotentialDuration)
    k_EHeroStatType_BattleHungerPotentialDuration = 2010,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_BattleHungerAverageDuration)
    k_EHeroStatType_BattleHungerAverageDuration = 2011,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CounterHelixProcCount)
    k_EHeroStatType_CounterHelixProcCount = 2012,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CounterHelixHeroProcCount)
    k_EHeroStatType_CounterHelixHeroProcCount = 2013,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CounterHelixHeroesHitAverage)
    k_EHeroStatType_CounterHelixHeroesHitAverage = 2014,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CounterHelixOtherUnitsHitCount)
    k_EHeroStatType_CounterHelixOtherUnitsHitCount = 2015,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CullingBladeCastCount)
    k_EHeroStatType_CullingBladeCastCount = 2016,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CullingBladeKillCount)
    k_EHeroStatType_CullingBladeKillCount = 2017,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CullingBladeAverageHealthCulled)
    k_EHeroStatType_CullingBladeAverageHealthCulled = 2018,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CullingBladeAverageDamageAvailable)
    k_EHeroStatType_CullingBladeAverageDamageAvailable = 2019,
    // @@protoc_insertion_point(enum_value:dota.EHeroStatType.k_EHeroStatType_CullingBladeHeroBuffAverage)
    k_EHeroStatType_CullingBladeHeroBuffAverage = 2020,
}

impl ::protobuf::Enum for EHeroStatType {
    const NAME: &'static str = "EHeroStatType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHeroStatType> {
        match value {
            0 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_None),
            2000 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_AxeTotalDamage),
            2001 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerDamage),
            2002 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixDamage),
            2003 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeDamage),
            2004 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallCastCount),
            2005 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroesHitAverage),
            2006 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherUnitsHit),
            2007 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroAttacksTaken),
            2008 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherAttacksTaken),
            2009 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerCastCount),
            2010 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerPotentialDuration),
            2011 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerAverageDuration),
            2012 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixProcCount),
            2013 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroProcCount),
            2014 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroesHitAverage),
            2015 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixOtherUnitsHitCount),
            2016 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeCastCount),
            2017 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeKillCount),
            2018 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageHealthCulled),
            2019 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageDamageAvailable),
            2020 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeHeroBuffAverage),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHeroStatType> {
        match str {
            "k_EHeroStatType_None" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_None),
            "k_EHeroStatType_AxeTotalDamage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_AxeTotalDamage),
            "k_EHeroStatType_BattleHungerDamage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerDamage),
            "k_EHeroStatType_CounterHelixDamage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixDamage),
            "k_EHeroStatType_CullingBladeDamage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeDamage),
            "k_EHeroStatType_BerserkersCallCastCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallCastCount),
            "k_EHeroStatType_BerserkersCallHeroesHitAverage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroesHitAverage),
            "k_EHeroStatType_BerserkersCallOtherUnitsHit" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherUnitsHit),
            "k_EHeroStatType_BerserkersCallHeroAttacksTaken" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroAttacksTaken),
            "k_EHeroStatType_BerserkersCallOtherAttacksTaken" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherAttacksTaken),
            "k_EHeroStatType_BattleHungerCastCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerCastCount),
            "k_EHeroStatType_BattleHungerPotentialDuration" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerPotentialDuration),
            "k_EHeroStatType_BattleHungerAverageDuration" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerAverageDuration),
            "k_EHeroStatType_CounterHelixProcCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixProcCount),
            "k_EHeroStatType_CounterHelixHeroProcCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroProcCount),
            "k_EHeroStatType_CounterHelixHeroesHitAverage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroesHitAverage),
            "k_EHeroStatType_CounterHelixOtherUnitsHitCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixOtherUnitsHitCount),
            "k_EHeroStatType_CullingBladeCastCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeCastCount),
            "k_EHeroStatType_CullingBladeKillCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeKillCount),
            "k_EHeroStatType_CullingBladeAverageHealthCulled" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageHealthCulled),
            "k_EHeroStatType_CullingBladeAverageDamageAvailable" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageDamageAvailable),
            "k_EHeroStatType_CullingBladeHeroBuffAverage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeHeroBuffAverage),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHeroStatType] = &[
        EHeroStatType::k_EHeroStatType_None,
        EHeroStatType::k_EHeroStatType_AxeTotalDamage,
        EHeroStatType::k_EHeroStatType_BattleHungerDamage,
        EHeroStatType::k_EHeroStatType_CounterHelixDamage,
        EHeroStatType::k_EHeroStatType_CullingBladeDamage,
        EHeroStatType::k_EHeroStatType_BerserkersCallCastCount,
        EHeroStatType::k_EHeroStatType_BerserkersCallHeroesHitAverage,
        EHeroStatType::k_EHeroStatType_BerserkersCallOtherUnitsHit,
        EHeroStatType::k_EHeroStatType_BerserkersCallHeroAttacksTaken,
        EHeroStatType::k_EHeroStatType_BerserkersCallOtherAttacksTaken,
        EHeroStatType::k_EHeroStatType_BattleHungerCastCount,
        EHeroStatType::k_EHeroStatType_BattleHungerPotentialDuration,
        EHeroStatType::k_EHeroStatType_BattleHungerAverageDuration,
        EHeroStatType::k_EHeroStatType_CounterHelixProcCount,
        EHeroStatType::k_EHeroStatType_CounterHelixHeroProcCount,
        EHeroStatType::k_EHeroStatType_CounterHelixHeroesHitAverage,
        EHeroStatType::k_EHeroStatType_CounterHelixOtherUnitsHitCount,
        EHeroStatType::k_EHeroStatType_CullingBladeCastCount,
        EHeroStatType::k_EHeroStatType_CullingBladeKillCount,
        EHeroStatType::k_EHeroStatType_CullingBladeAverageHealthCulled,
        EHeroStatType::k_EHeroStatType_CullingBladeAverageDamageAvailable,
        EHeroStatType::k_EHeroStatType_CullingBladeHeroBuffAverage,
    ];
}

impl ::protobuf::EnumFull for EHeroStatType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EHeroStatType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EHeroStatType::k_EHeroStatType_None => 0,
            EHeroStatType::k_EHeroStatType_AxeTotalDamage => 1,
            EHeroStatType::k_EHeroStatType_BattleHungerDamage => 2,
            EHeroStatType::k_EHeroStatType_CounterHelixDamage => 3,
            EHeroStatType::k_EHeroStatType_CullingBladeDamage => 4,
            EHeroStatType::k_EHeroStatType_BerserkersCallCastCount => 5,
            EHeroStatType::k_EHeroStatType_BerserkersCallHeroesHitAverage => 6,
            EHeroStatType::k_EHeroStatType_BerserkersCallOtherUnitsHit => 7,
            EHeroStatType::k_EHeroStatType_BerserkersCallHeroAttacksTaken => 8,
            EHeroStatType::k_EHeroStatType_BerserkersCallOtherAttacksTaken => 9,
            EHeroStatType::k_EHeroStatType_BattleHungerCastCount => 10,
            EHeroStatType::k_EHeroStatType_BattleHungerPotentialDuration => 11,
            EHeroStatType::k_EHeroStatType_BattleHungerAverageDuration => 12,
            EHeroStatType::k_EHeroStatType_CounterHelixProcCount => 13,
            EHeroStatType::k_EHeroStatType_CounterHelixHeroProcCount => 14,
            EHeroStatType::k_EHeroStatType_CounterHelixHeroesHitAverage => 15,
            EHeroStatType::k_EHeroStatType_CounterHelixOtherUnitsHitCount => 16,
            EHeroStatType::k_EHeroStatType_CullingBladeCastCount => 17,
            EHeroStatType::k_EHeroStatType_CullingBladeKillCount => 18,
            EHeroStatType::k_EHeroStatType_CullingBladeAverageHealthCulled => 19,
            EHeroStatType::k_EHeroStatType_CullingBladeAverageDamageAvailable => 20,
            EHeroStatType::k_EHeroStatType_CullingBladeHeroBuffAverage => 21,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EHeroStatType {
    fn default() -> Self {
        EHeroStatType::k_EHeroStatType_None
    }
}

impl EHeroStatType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EHeroStatType>("EHeroStatType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EPlayerVoiceListenState)
pub enum EPlayerVoiceListenState {
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_None)
    kPVLS_None = 0,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_DeniedChatBanned)
    kPVLS_DeniedChatBanned = 1,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_DeniedPartner)
    kPVLS_DeniedPartner = 2,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_DeniedHLTVTalkerNotSpectator)
    kPVLS_DeniedHLTVTalkerNotSpectator = 3,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_DeniedHLTVNoTalkerPlayerID)
    kPVLS_DeniedHLTVNoTalkerPlayerID = 4,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_DeniedHLTVTalkerNotBroadcaster)
    kPVLS_DeniedHLTVTalkerNotBroadcaster = 5,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_DeniedTeamSpectator)
    kPVLS_DeniedTeamSpectator = 6,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_DeniedStudent)
    kPVLS_DeniedStudent = 8,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_DeniedPrivateCoach)
    kPVLS_DeniedPrivateCoach = 9,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_Denied)
    kPVLS_Denied = 64,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowHLTVTalkerIsBroadcaster)
    kPVLS_AllowHLTVTalkerIsBroadcaster = 65,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowCoBroadcaster)
    kPVLS_AllowCoBroadcaster = 66,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowAllChat)
    kPVLS_AllowAllChat = 67,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowStudentToCoach)
    kPVLS_AllowStudentToCoach = 68,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowFellowStudent)
    kPVLS_AllowFellowStudent = 69,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowTalkerIsCoach)
    kPVLS_AllowTalkerIsCoach = 70,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowCoachHearTeam)
    kPVLS_AllowCoachHearTeam = 71,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowSameTeam)
    kPVLS_AllowSameTeam = 72,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowShowcase)
    kPVLS_AllowShowcase = 73,
    // @@protoc_insertion_point(enum_value:dota.EPlayerVoiceListenState.kPVLS_AllowPrivateCoach)
    kPVLS_AllowPrivateCoach = 74,
}

impl ::protobuf::Enum for EPlayerVoiceListenState {
    const NAME: &'static str = "EPlayerVoiceListenState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPlayerVoiceListenState> {
        match value {
            0 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_None),
            1 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedChatBanned),
            2 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedPartner),
            3 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotSpectator),
            4 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVNoTalkerPlayerID),
            5 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotBroadcaster),
            6 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedTeamSpectator),
            8 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedStudent),
            9 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedPrivateCoach),
            64 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_Denied),
            65 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowHLTVTalkerIsBroadcaster),
            66 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoBroadcaster),
            67 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowAllChat),
            68 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowStudentToCoach),
            69 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowFellowStudent),
            70 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowTalkerIsCoach),
            71 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoachHearTeam),
            72 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowSameTeam),
            73 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowShowcase),
            74 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowPrivateCoach),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPlayerVoiceListenState> {
        match str {
            "kPVLS_None" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_None),
            "kPVLS_DeniedChatBanned" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedChatBanned),
            "kPVLS_DeniedPartner" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedPartner),
            "kPVLS_DeniedHLTVTalkerNotSpectator" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotSpectator),
            "kPVLS_DeniedHLTVNoTalkerPlayerID" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVNoTalkerPlayerID),
            "kPVLS_DeniedHLTVTalkerNotBroadcaster" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotBroadcaster),
            "kPVLS_DeniedTeamSpectator" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedTeamSpectator),
            "kPVLS_DeniedStudent" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedStudent),
            "kPVLS_DeniedPrivateCoach" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedPrivateCoach),
            "kPVLS_Denied" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_Denied),
            "kPVLS_AllowHLTVTalkerIsBroadcaster" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowHLTVTalkerIsBroadcaster),
            "kPVLS_AllowCoBroadcaster" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoBroadcaster),
            "kPVLS_AllowAllChat" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowAllChat),
            "kPVLS_AllowStudentToCoach" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowStudentToCoach),
            "kPVLS_AllowFellowStudent" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowFellowStudent),
            "kPVLS_AllowTalkerIsCoach" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowTalkerIsCoach),
            "kPVLS_AllowCoachHearTeam" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoachHearTeam),
            "kPVLS_AllowSameTeam" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowSameTeam),
            "kPVLS_AllowShowcase" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowShowcase),
            "kPVLS_AllowPrivateCoach" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowPrivateCoach),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPlayerVoiceListenState] = &[
        EPlayerVoiceListenState::kPVLS_None,
        EPlayerVoiceListenState::kPVLS_DeniedChatBanned,
        EPlayerVoiceListenState::kPVLS_DeniedPartner,
        EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotSpectator,
        EPlayerVoiceListenState::kPVLS_DeniedHLTVNoTalkerPlayerID,
        EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotBroadcaster,
        EPlayerVoiceListenState::kPVLS_DeniedTeamSpectator,
        EPlayerVoiceListenState::kPVLS_DeniedStudent,
        EPlayerVoiceListenState::kPVLS_DeniedPrivateCoach,
        EPlayerVoiceListenState::kPVLS_Denied,
        EPlayerVoiceListenState::kPVLS_AllowHLTVTalkerIsBroadcaster,
        EPlayerVoiceListenState::kPVLS_AllowCoBroadcaster,
        EPlayerVoiceListenState::kPVLS_AllowAllChat,
        EPlayerVoiceListenState::kPVLS_AllowStudentToCoach,
        EPlayerVoiceListenState::kPVLS_AllowFellowStudent,
        EPlayerVoiceListenState::kPVLS_AllowTalkerIsCoach,
        EPlayerVoiceListenState::kPVLS_AllowCoachHearTeam,
        EPlayerVoiceListenState::kPVLS_AllowSameTeam,
        EPlayerVoiceListenState::kPVLS_AllowShowcase,
        EPlayerVoiceListenState::kPVLS_AllowPrivateCoach,
    ];
}

impl ::protobuf::EnumFull for EPlayerVoiceListenState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPlayerVoiceListenState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EPlayerVoiceListenState::kPVLS_None => 0,
            EPlayerVoiceListenState::kPVLS_DeniedChatBanned => 1,
            EPlayerVoiceListenState::kPVLS_DeniedPartner => 2,
            EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotSpectator => 3,
            EPlayerVoiceListenState::kPVLS_DeniedHLTVNoTalkerPlayerID => 4,
            EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotBroadcaster => 5,
            EPlayerVoiceListenState::kPVLS_DeniedTeamSpectator => 6,
            EPlayerVoiceListenState::kPVLS_DeniedStudent => 7,
            EPlayerVoiceListenState::kPVLS_DeniedPrivateCoach => 8,
            EPlayerVoiceListenState::kPVLS_Denied => 9,
            EPlayerVoiceListenState::kPVLS_AllowHLTVTalkerIsBroadcaster => 10,
            EPlayerVoiceListenState::kPVLS_AllowCoBroadcaster => 11,
            EPlayerVoiceListenState::kPVLS_AllowAllChat => 12,
            EPlayerVoiceListenState::kPVLS_AllowStudentToCoach => 13,
            EPlayerVoiceListenState::kPVLS_AllowFellowStudent => 14,
            EPlayerVoiceListenState::kPVLS_AllowTalkerIsCoach => 15,
            EPlayerVoiceListenState::kPVLS_AllowCoachHearTeam => 16,
            EPlayerVoiceListenState::kPVLS_AllowSameTeam => 17,
            EPlayerVoiceListenState::kPVLS_AllowShowcase => 18,
            EPlayerVoiceListenState::kPVLS_AllowPrivateCoach => 19,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPlayerVoiceListenState {
    fn default() -> Self {
        EPlayerVoiceListenState::kPVLS_None
    }
}

impl EPlayerVoiceListenState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPlayerVoiceListenState>("EPlayerVoiceListenState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EProjectionEvent)
pub enum EProjectionEvent {
    // @@protoc_insertion_point(enum_value:dota.EProjectionEvent.ePE_FirstBlood)
    ePE_FirstBlood = 0,
    // @@protoc_insertion_point(enum_value:dota.EProjectionEvent.ePE_Killstreak_godlike)
    ePE_Killstreak_godlike = 1,
}

impl ::protobuf::Enum for EProjectionEvent {
    const NAME: &'static str = "EProjectionEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProjectionEvent> {
        match value {
            0 => ::std::option::Option::Some(EProjectionEvent::ePE_FirstBlood),
            1 => ::std::option::Option::Some(EProjectionEvent::ePE_Killstreak_godlike),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProjectionEvent> {
        match str {
            "ePE_FirstBlood" => ::std::option::Option::Some(EProjectionEvent::ePE_FirstBlood),
            "ePE_Killstreak_godlike" => ::std::option::Option::Some(EProjectionEvent::ePE_Killstreak_godlike),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProjectionEvent] = &[
        EProjectionEvent::ePE_FirstBlood,
        EProjectionEvent::ePE_Killstreak_godlike,
    ];
}

impl ::protobuf::EnumFull for EProjectionEvent {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EProjectionEvent").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EProjectionEvent {
    fn default() -> Self {
        EProjectionEvent::ePE_FirstBlood
    }
}

impl EProjectionEvent {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EProjectionEvent>("EProjectionEvent")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17dota_usermessages.proto\x12\x04dota\x1a\x16networkbasetypes.proto\
    \x1a\x17dota_shared_enums.proto\x1a\x19dota_commonmessages.proto\"4\n\
    \x18CDOTAUserMsg_AIDebugLine\x12\x18\n\x07message\x18\x01\x20\x01(\tR\
    \x07message\";\n\x11CDOTAUserMsg_Ping\x12\x12\n\x04ping\x18\x02\x20\x01(\
    \rR\x04ping\x12\x12\n\x04loss\x18\x03\x20\x01(\rR\x04loss\"6\n\x17CDOTAU\
    serMsg_SwapVerify\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\
    \"\xc5\x02\n\x16CDOTAUserMsg_ChatEvent\x12+\n\x04type\x18\x01\x20\x02(\
    \x0e2\x17.dota.DOTA_CHAT_MESSAGER\x04type\x12\x14\n\x05value\x18\x02\x20\
    \x01(\rR\x05value\x12\x1d\n\nplayerid_1\x18\x03\x20\x01(\x11R\tplayerid1\
    \x12\x1d\n\nplayerid_2\x18\x04\x20\x01(\x11R\tplayerid2\x12\x1d\n\nplaye\
    rid_3\x18\x05\x20\x01(\x11R\tplayerid3\x12\x1d\n\nplayerid_4\x18\x06\x20\
    \x01(\x11R\tplayerid4\x12\x1d\n\nplayerid_5\x18\x07\x20\x01(\x11R\tplaye\
    rid5\x12\x1d\n\nplayerid_6\x18\x08\x20\x01(\x11R\tplayerid6\x12\x16\n\
    \x06value2\x18\t\x20\x01(\rR\x06value2\x12\x16\n\x06value3\x18\n\x20\x01\
    (\rR\x06value3\"\x82\x01\n\x14CDOTAUserMsg_BotChat\x12\x1b\n\tplayer_id\
    \x18\x01\x20\x01(\x05R\x08playerId\x12\x18\n\x07message\x18\x03\x20\x01(\
    \tR\x07message\x12\x16\n\x06target\x18\x04\x20\x01(\tR\x06target\x12\x1b\
    \n\tteam_only\x18\x05\x20\x01(\x08R\x08teamOnly\"\x95\x01\n\x20CDOTAUser\
    Msg_CombatHeroPositions\x12\x14\n\x05index\x18\x01\x20\x01(\rR\x05index\
    \x12\x12\n\x04time\x18\x02\x20\x01(\x05R\x04time\x12/\n\tworld_pos\x18\
    \x03\x20\x01(\x0b2\x12.dota.CMsgVector2DR\x08worldPos\x12\x16\n\x06healt\
    h\x18\x04\x20\x01(\x05R\x06health\"\xdf\x01\n\x1eCDOTAUserMsg_CombatLogB\
    ulkData\x12C\n\x0ecombat_entries\x18\x01\x20\x03(\x0b2\x1c.dota.CMsgDOTA\
    CombatLogEntryR\rcombatEntries\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x02\
    R\ttimestamp\x12\x1a\n\x08duration\x18\x03\x20\x01(\x02R\x08duration\x12\
    \x1b\n\tplayer_id\x18\x04\x20\x01(\x05R\x08playerId\x12!\n\x0crequest_ti\
    me\x18\x05\x20\x01(\x02R\x0brequestTime\"v\n%CDOTAUserMsg_ProjectilePart\
    icleCPData\x12#\n\rcontrol_point\x18\x01\x20\x01(\x05R\x0ccontrolPoint\
    \x12(\n\x06vector\x18\x02\x20\x01(\x0b2\x10.dota.CMsgVectorR\x06vector\"\
    \xef\x02\n\x1cCDOTAUserMsg_MiniKillCamInfo\x12I\n\tattackers\x18\x01\x20\
    \x03(\x0b2+.dota.CDOTAUserMsg_MiniKillCamInfo.AttackerR\tattackers\x1a\
    \x83\x02\n\x08Attacker\x12\x1a\n\x08attacker\x18\x01\x20\x01(\rR\x08atta\
    cker\x12!\n\x0ctotal_damage\x18\x02\x20\x01(\x05R\x0btotalDamage\x12Q\n\
    \tabilities\x18\x03\x20\x03(\x0b23.dota.CDOTAUserMsg_MiniKillCamInfo.Att\
    acker.AbilityR\tabilities\x12#\n\rattacker_name\x18\x04\x20\x01(\tR\x0ca\
    ttackerName\x1a@\n\x07Ability\x12\x1d\n\nability_id\x18\x01\x20\x01(\x05\
    R\tabilityId\x12\x16\n\x06damage\x18\x02\x20\x01(\x05R\x06damage\"Q\n\
    \x1dCDOTAUserMsg_GlobalLightColor\x12\x14\n\x05color\x18\x01\x20\x01(\rR\
    \x05color\x12\x1a\n\x08duration\x18\x02\x20\x01(\x02R\x08duration\"o\n!C\
    DOTAUserMsg_GlobalLightDirection\x12.\n\tdirection\x18\x01\x20\x01(\x0b2\
    \x10.dota.CMsgVectorR\tdirection\x12\x1a\n\x08duration\x18\x02\x20\x01(\
    \x02R\x08duration\"z\n\x19CDOTAUserMsg_LocationPing\x12\x1b\n\tplayer_id\
    \x18\x01\x20\x01(\x05R\x08playerId\x12@\n\rlocation_ping\x18\x02\x20\x01\
    (\x0b2\x1b.dota.CDOTAMsg_LocationPingR\x0clocationPing\"\xcd\x01\n\x1dCD\
    OTAUserMsg_PingConfirmation\x12>\n\x1cplayer_id_of_original_pinger\x18\
    \x01\x20\x01(\x05R\x18playerIdOfOriginalPinger\x12!\n\x0centity_index\
    \x18\x02\x20\x01(\rR\x0bentityIndex\x12\x1b\n\ticon_type\x18\x03\x20\x01\
    (\rR\x08iconType\x12,\n\x08location\x18\x04\x20\x01(\x0b2\x10.dota.CMsgV\
    ectorR\x08location\"n\n\x16CDOTAUserMsg_ItemAlert\x12\x1b\n\tplayer_id\
    \x18\x01\x20\x01(\x05R\x08playerId\x127\n\nitem_alert\x18\x02\x20\x01(\
    \x0b2\x18.dota.CDOTAMsg_ItemAlertR\titemAlert\"\xbb\x02\n\x1bCDOTAUserMs\
    g_EnemyItemAlert\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\
    \x12(\n\x10target_player_id\x18\x02\x20\x01(\x05R\x0etargetPlayerId\x12&\
    \n\x0fitem_ability_id\x18\x03\x20\x01(\x05R\ritemAbilityId\x12\x1b\n\tru\
    ne_type\x18\x04\x20\x01(\x05R\x08runeType\x12\x1b\n\tentity_id\x18\x05\
    \x20\x01(\x05R\x08entityId\x12\x1d\n\nitem_level\x18\x06\x20\x01(\x05R\t\
    itemLevel\x12'\n\x0fprimary_charges\x18\x07\x20\x01(\x05R\x0eprimaryChar\
    ges\x12+\n\x11secondary_charges\x18\x08\x20\x01(\x05R\x10secondaryCharge\
    s\"\xec\x01\n\x1aCDOTAUserMsg_ModifierAlert\x12\x1b\n\tplayer_id\x18\x01\
    \x20\x01(\x05R\x08playerId\x12\x1d\n\nclass_name\x18\x02\x20\x01(\tR\tcl\
    assName\x12\x1f\n\x0bstack_count\x18\x03\x20\x01(\rR\nstackCount\x12\x1b\
    \n\tis_debuff\x18\x04\x20\x01(\x08R\x08isDebuff\x12'\n\x0ftarget_entinde\
    x\x18\x05\x20\x01(\x05R\x0etargetEntindex\x12+\n\x11seconds_remaining\
    \x18\x06\x20\x01(\x02R\x10secondsRemaining\"\x88\x01\n\x18CDOTAUserMsg_H\
    PManaAlert\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12'\n\
    \x0ftarget_entindex\x18\x02\x20\x01(\x05R\x0etargetEntindex\x12&\n\x0fsh\
    ow_raw_values\x18\x03\x20\x01(\x08R\rshowRawValues\"\x98\x02\n\x1dCDOTAU\
    serMsg_NeutralCampAlert\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08pl\
    ayerId\x12)\n\x10spawner_entindex\x18\x02\x20\x01(\x05R\x0fspawnerEntind\
    ex\x12#\n\runit_entindex\x18\x03\x20\x01(\x05R\x0cunitEntindex\x12\x1f\n\
    \x0bstack_count\x18\x04\x20\x01(\x05R\nstackCount\x12\x1b\n\tcamp_type\
    \x18\x05\x20\x01(\x05R\x08campType\x12#\n\rstack_request\x18\x06\x20\x01\
    (\x08R\x0cstackRequest\x12'\n\x0fstack_intention\x18\x07\x20\x01(\x08R\
    \x0estackIntention\"R\n\x17CDOTAUserMsg_GlyphAlert\x12\x1b\n\tplayer_id\
    \x18\x01\x20\x01(\x05R\x08playerId\x12\x1a\n\x08negative\x18\x02\x20\x01\
    (\x08R\x08negative\"R\n\x17CDOTAUserMsg_RadarAlert\x12\x1b\n\tplayer_id\
    \x18\x01\x20\x01(\x05R\x08playerId\x12\x1a\n\x08negative\x18\x02\x20\x01\
    (\x08R\x08negative\"\xbe\x01\n\x1eCDOTAUserMsg_WillPurchaseAlert\x12&\n\
    \x0fitem_ability_id\x18\x01\x20\x01(\x05R\ritemAbilityId\x12\x1b\n\tplay\
    er_id\x18\x02\x20\x01(\x05R\x08playerId\x12%\n\x0egold_remaining\x18\x03\
    \x20\x01(\rR\rgoldRemaining\x120\n\x14suggestion_player_id\x18\x04\x20\
    \x01(\x05R\x12suggestionPlayerId\"\xa0\x01\n\x1fCDOTAUserMsg_EmptyTelepo\
    rtAlert\x12(\n\x10source_player_id\x18\x01\x20\x01(\x05R\x0esourcePlayer\
    Id\x12(\n\x10target_player_id\x18\x02\x20\x01(\x05R\x0etargetPlayerId\
    \x12)\n\x10cooldown_seconds\x18\x03\x20\x01(\x05R\x0fcooldownSeconds\"\
    \x98\x01\n#CDOTAUserMsg_MarsArenaOfBloodAttack\x12%\n\x0esource_ehandle\
    \x18\x01\x20\x01(\rR\rsourceEhandle\x12%\n\x0etarget_ehandle\x18\x02\x20\
    \x01(\rR\rtargetEhandle\x12#\n\rwarrior_index\x18\x03\x20\x01(\x05R\x0cw\
    arriorIndex\"w\n\x1fCDOTAEntityMsg_InvokerSpellCast\x12/\n\nentity_msg\
    \x18\x01\x20\x01(\x0b2\x10.dota.CEntityMsgR\tentityMsg\x12#\n\rcast_acti\
    vity\x18\x02\x20\x01(\x05R\x0ccastActivity\"=\n\x1eCDOTAUserMsg_BuyBackS\
    tateAlert\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\"\xd5\
    \x01\n\x1aCDOTAUserMsg_QuickBuyAlert\x12\x1b\n\tplayer_id\x18\x01\x20\
    \x01(\x05R\x08playerId\x12&\n\x0fitem_ability_id\x18\x02\x20\x01(\x05R\r\
    itemAbilityId\x12\x1b\n\tgold_cost\x18\x03\x20\x01(\x05R\x08goldCost\x12\
    2\n\x15item_cooldown_seconds\x18\x04\x20\x01(\x05R\x13itemCooldownSecond\
    s\x12!\n\x0cshow_buyback\x18\x05\x20\x01(\x08R\x0bshowBuyback\"\x8a\x03\
    \n\x1fCDOTAUserMsg_CourierKilledAlert\x12\x12\n\x04team\x18\x01\x20\x01(\
    \rR\x04team\x12\x1d\n\ngold_value\x18\x02\x20\x01(\rR\tgoldValue\x12#\n\
    \rentity_handle\x18\x03\x20\x01(\rR\x0centityHandle\x12\x1c\n\ttimestamp\
    \x18\x04\x20\x01(\x05R\ttimestamp\x12M\n\nlost_items\x18\x05\x20\x03(\
    \x0b2..dota.CDOTAUserMsg_CourierKilledAlert.LostItemR\tlostItems\x12(\n\
    \x10killer_player_id\x18\x06\x20\x01(\x05R\x0ekillerPlayerId\x12(\n\x10o\
    wning_player_id\x18\x07\x20\x01(\x05R\x0eowningPlayerId\x1aN\n\x08LostIt\
    em\x12&\n\x0fitem_ability_id\x18\x01\x20\x01(\x05R\ritemAbilityId\x12\
    \x1a\n\x08quantity\x18\x02\x20\x01(\rR\x08quantity\"\xc9\x01\n\x19CDOTAU\
    serMsg_MinimapEvent\x12\x1d\n\nevent_type\x18\x01\x20\x01(\x05R\teventTy\
    pe\x12#\n\rentity_handle\x18\x02\x20\x01(\rR\x0centityHandle\x12\x0c\n\
    \x01x\x18\x03\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x04\x20\x01(\x05R\
    \x01y\x12\x1a\n\x08duration\x18\x05\x20\x01(\x05R\x08duration\x120\n\x14\
    target_entity_handle\x18\x06\x20\x01(\rR\x12targetEntityHandle\"e\n\x14C\
    DOTAUserMsg_MapLine\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08player\
    Id\x120\n\x07mapline\x18\x02\x20\x01(\x0b2\x16.dota.CDOTAMsg_MapLineR\
    \x07mapline\"\xaa\x01\n\x1eCDOTAUserMsg_MinimapDebugPoint\x12,\n\x08loca\
    tion\x18\x01\x20\x01(\x0b2\x10.dota.CMsgVectorR\x08location\x12\x14\n\
    \x05color\x18\x02\x20\x01(\rR\x05color\x12\x12\n\x04size\x18\x03\x20\x01\
    (\x05R\x04size\x12\x1a\n\x08duration\x18\x04\x20\x01(\x02R\x08duration\
    \x12\x14\n\x05index\x18\x05\x20\x01(\x05R\x05index\"\x93\x04\n#CDOTAUser\
    Msg_CreateLinearProjectile\x12(\n\x06origin\x18\x01\x20\x01(\x0b2\x10.do\
    ta.CMsgVectorR\x06origin\x12.\n\x08velocity\x18\x02\x20\x01(\x0b2\x12.do\
    ta.CMsgVector2DR\x08velocity\x12\x1a\n\x08entindex\x18\x04\x20\x01(\x05R\
    \x08entindex\x12%\n\x0eparticle_index\x18\x05\x20\x01(\x04R\rparticleInd\
    ex\x12\x16\n\x06handle\x18\x06\x20\x01(\x05R\x06handle\x126\n\x0cacceler\
    ation\x18\x07\x20\x01(\x0b2\x12.dota.CMsgVector2DR\x0cacceleration\x12\
    \x1b\n\tmax_speed\x18\x08\x20\x01(\x02R\x08maxSpeed\x12\x1d\n\nfow_radiu\
    s\x18\t\x20\x01(\x02R\tfowRadius\x12*\n\x11sticky_fow_reveal\x18\n\x20\
    \x01(\x08R\x0fstickyFowReveal\x12\x1a\n\x08distance\x18\x0b\x20\x01(\x02\
    R\x08distance\x12$\n\rcolorgemcolor\x18\x0c\x20\x01(\x07R\rcolorgemcolor\
    \x12U\n\x10particle_cp_data\x18\r\x20\x03(\x0b2+.dota.CDOTAUserMsg_Proje\
    ctileParticleCPDataR\x0eparticleCpData\">\n$CDOTAUserMsg_DestroyLinearPr\
    ojectile\x12\x16\n\x06handle\x18\x01\x20\x01(\x05R\x06handle\"f\n%CDOTAU\
    serMsg_DodgeTrackingProjectiles\x12\x1a\n\x08entindex\x18\x01\x20\x02(\
    \x05R\x08entindex\x12!\n\x0cattacks_only\x18\x02\x20\x01(\x08R\x0battack\
    sOnly\"\x81\x01\n!CDOTAUserMsg_SpectatorPlayerClick\x12\x1a\n\x08entinde\
    x\x18\x01\x20\x02(\x05R\x08entindex\x12\x1d\n\norder_type\x18\x02\x20\
    \x01(\x05R\torderType\x12!\n\x0ctarget_index\x18\x03\x20\x01(\x05R\x0bta\
    rgetIndex\"\xbe\x02\n&CDOTAUserMsg_SpectatorPlayerUnitOrders\x12\x1a\n\
    \x08entindex\x18\x01\x20\x01(\x05R\x08entindex\x12\x1d\n\norder_type\x18\
    \x02\x20\x01(\x05R\torderType\x12\x14\n\x05units\x18\x03\x20\x03(\x05R\
    \x05units\x12!\n\x0ctarget_index\x18\x04\x20\x01(\x05R\x0btargetIndex\
    \x12\x1d\n\nability_id\x18\x05\x20\x01(\x05R\tabilityId\x12,\n\x08positi\
    on\x18\x06\x20\x01(\x0b2\x10.dota.CMsgVectorR\x08position\x12\x14\n\x05q\
    ueue\x18\x07\x20\x01(\x08R\x05queue\x12'\n\x0fsequence_number\x18\x08\
    \x20\x01(\x05R\x0esequenceNumber\x12\x14\n\x05flags\x18\t\x20\x01(\rR\
    \x05flags\"\x9e\x01\n\x1dCDOTAUserMsg_NevermoreRequiem\x12#\n\rentity_ha\
    ndle\x18\x01\x20\x01(\rR\x0centityHandle\x12\x14\n\x05lines\x18\x02\x20\
    \x01(\x05R\x05lines\x12(\n\x06origin\x18\x03\x20\x01(\x0b2\x10.dota.CMsg\
    VectorR\x06origin\x12\x18\n\x07reverse\x18\x04\x20\x01(\x08R\x07reverse\
    \"`\n\x1bCDOTAUserMsg_InvalidCommand\x12\x18\n\x07message\x18\x01\x20\
    \x01(\tR\x07message\x12'\n\x0fsequence_number\x18\x02\x20\x01(\x05R\x0es\
    equenceNumber\"[\n\x15CDOTAUserMsg_HudError\x12\x19\n\x08order_id\x18\
    \x01\x20\x01(\x05R\x07orderId\x12'\n\x0fsequence_number\x18\x02\x20\x01(\
    \x05R\x0esequenceNumber\"\x88\x01\n\x1bCDOTAUserMsg_SharedCooldown\x12\
    \x1a\n\x08entindex\x18\x01\x20\x01(\x05R\x08entindex\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12\x1a\n\x08cooldown\x18\x03\x20\x01(\x02R\
    \x08cooldown\x12\x1d\n\nname_index\x18\x04\x20\x01(\x05R\tnameIndex\"5\n\
    \x1fCDOTAUserMsg_SetNextAutobuyItem\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\"x\n\x1bCDOTAUserMsg_HalloweenDrops\x12\x1b\n\titem_defs\x18\
    \x01\x20\x03(\rR\x08itemDefs\x12\x1d\n\nplayer_ids\x18\x02\x20\x03(\x05R\
    \tplayerIds\x12\x1d\n\nprize_list\x18\x03\x20\x01(\rR\tprizeList\"\xe8\
    \x03\n\x1dCDOTAUserMsg_PredictionResult\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07m\
    atchId\x12\x18\n\x07correct\x18\x03\x20\x01(\x08R\x07correct\x12P\n\x0bp\
    redictions\x18\x04\x20\x03(\x0b2..dota.CDOTAUserMsg_PredictionResult.Pre\
    dictionR\x0bpredictions\x1a\xa0\x02\n\nPrediction\x12\x19\n\x08item_def\
    \x18\x01\x20\x01(\rR\x07itemDef\x12\x1f\n\x0bnum_correct\x18\x02\x20\x01\
    (\rR\nnumCorrect\x12\x1b\n\tnum_fails\x18\x03\x20\x01(\rR\x08numFails\
    \x12N\n\x06result\x18\x04\x20\x01(\x0e26.dota.CDOTAUserMsg_PredictionRes\
    ult.Prediction.EResultR\x06result\x12*\n\x11granted_item_defs\x18\x06\
    \x20\x03(\rR\x0fgrantedItemDefs\"=\n\x07EResult\x12\x19\n\x15k_eResult_I\
    temGranted\x10\x01\x12\x17\n\x13k_eResult_Destroyed\x10\x02\"\xaf\x03\n\
    \x1cCDOTAResponseQuerySerialized\x12=\n\x05facts\x18\x01\x20\x03(\x0b2'.\
    dota.CDOTAResponseQuerySerialized.FactR\x05facts\x1a\xcf\x02\n\x04Fact\
    \x12\x10\n\x03key\x18\x01\x20\x02(\x05R\x03key\x12K\n\x07valtype\x18\x02\
    \x20\x02(\x0e21.dota.CDOTAResponseQuerySerialized.Fact.ValueTypeR\x07val\
    type\x12\x1f\n\x0bval_numeric\x18\x03\x20\x01(\x02R\nvalNumeric\x12\x1d\
    \n\nval_string\x18\x04\x20\x01(\tR\tvalString\x122\n\x15val_stringtable_\
    index\x18\x05\x20\x01(\x05R\x13valStringtableIndex\x12&\n\x0fval_int_num\
    eric\x18\x06\x20\x01(\x11R\rvalIntNumeric\"L\n\tValueType\x12\x0b\n\x07N\
    UMERIC\x10\x01\x12\n\n\x06STRING\x10\x02\x12\x15\n\x11STRINGTABLE_INDEX\
    \x10\x03\x12\x0f\n\x0bINT_NUMERIC\x10\x04\"\xd2\x01\n\x18CDOTASpeechMatc\
    hOnClient\x12%\n\x0espeech_concept\x18\x01\x20\x01(\x05R\rspeechConcept\
    \x12%\n\x0erecipient_type\x18\x02\x20\x01(\x05R\rrecipientType\x12H\n\rr\
    esponsequery\x18\x03\x20\x01(\x0b2\".dota.CDOTAResponseQuerySerializedR\
    \rresponsequery\x12\x1e\n\nrandomseed\x18\x04\x20\x01(\x0fR\nrandomseed\
    \"\xc0\n\n\x16CDOTAUserMsg_UnitEvent\x124\n\x08msg_type\x18\x01\x20\x02(\
    \x0e2\x19.dota.EDotaEntityMessagesR\x07msgType\x12!\n\x0centity_index\
    \x18\x02\x20\x02(\x05R\x0bentityIndex\x12;\n\x06speech\x18\x03\x20\x01(\
    \x0b2#.dota.CDOTAUserMsg_UnitEvent.SpeechR\x06speech\x12H\n\x0bspeech_mu\
    te\x18\x04\x20\x01(\x0b2'.dota.CDOTAUserMsg_UnitEvent.SpeechMuteR\nspeec\
    hMute\x12H\n\x0badd_gesture\x18\x05\x20\x01(\x0b2'.dota.CDOTAUserMsg_Uni\
    tEvent.AddGestureR\naddGesture\x12Q\n\x0eremove_gesture\x18\x06\x20\x01(\
    \x0b2*.dota.CDOTAUserMsg_UnitEvent.RemoveGestureR\rremoveGesture\x12K\n\
    \x0cblood_impact\x18\x07\x20\x01(\x0b2(.dota.CDOTAUserMsg_UnitEvent.Bloo\
    dImpactR\x0bbloodImpact\x12K\n\x0cfade_gesture\x18\x08\x20\x01(\x0b2(.do\
    ta.CDOTAUserMsg_UnitEvent.FadeGestureR\x0bfadeGesture\x12S\n\x16speech_m\
    atch_on_client\x18\t\x20\x01(\x0b2\x1e.dota.CDOTASpeechMatchOnClientR\
    \x13speechMatchOnClient\x1a6\n\x08Interval\x12\x14\n\x05start\x18\x01\
    \x20\x01(\x02R\x05start\x12\x14\n\x05range\x18\x02\x20\x01(\x02R\x05rang\
    e\x1a\xe7\x01\n\x06Speech\x12%\n\x0espeech_concept\x18\x01\x20\x01(\x05R\
    \rspeechConcept\x12\x1a\n\x08response\x18\x02\x20\x01(\tR\x08response\
    \x12%\n\x0erecipient_type\x18\x03\x20\x01(\x05R\rrecipientType\x12\x1a\n\
    \x08muteable\x18\x05\x20\x01(\x08R\x08muteable\x12A\n\x08predelay\x18\
    \x06\x20\x01(\x0b2%.dota.CDOTAUserMsg_UnitEvent.IntervalR\x08predelay\
    \x12\x14\n\x05flags\x18\x07\x20\x01(\rR\x05flags\x1a\"\n\nSpeechMute\x12\
    \x14\n\x05delay\x18\x01\x20\x01(\x02R\x05delay\x1a\xc0\x01\n\nAddGesture\
    \x12\x1a\n\x08activity\x18\x01\x20\x01(\x05R\x08activity\x12\x12\n\x04sl\
    ot\x18\x02\x20\x01(\x05R\x04slot\x12\x17\n\x07fade_in\x18\x03\x20\x01(\
    \x02R\x06fadeIn\x12\x19\n\x08fade_out\x18\x04\x20\x01(\x02R\x07fadeOut\
    \x12#\n\rplayback_rate\x18\x05\x20\x01(\x02R\x0cplaybackRate\x12)\n\x10s\
    equence_variant\x18\x06\x20\x01(\x05R\x0fsequenceVariant\x1a+\n\rRemoveG\
    esture\x12\x1a\n\x08activity\x18\x01\x20\x01(\x05R\x08activity\x1aY\n\
    \x0bBloodImpact\x12\x14\n\x05scale\x18\x01\x20\x01(\x05R\x05scale\x12\
    \x19\n\x08x_normal\x18\x02\x20\x01(\x05R\x07xNormal\x12\x19\n\x08y_norma\
    l\x18\x03\x20\x01(\x05R\x07yNormal\x1a)\n\x0bFadeGesture\x12\x1a\n\x08ac\
    tivity\x18\x01\x20\x01(\x05R\x08activity\"D\n\x1aCDOTAUserMsg_ItemPurcha\
    sed\x12&\n\x0fitem_ability_id\x18\x01\x20\x01(\x05R\ritemAbilityId\"?\n\
    \x15CDOTAUserMsg_ItemSold\x12&\n\x0fitem_ability_id\x18\x01\x20\x01(\x05\
    R\ritemAbilityId\"\x94\x01\n\x16CDOTAUserMsg_ItemFound\x12\x16\n\x06play\
    er\x18\x01\x20\x01(\x05R\x06player\x12\x18\n\x07quality\x18\x02\x20\x01(\
    \x05R\x07quality\x12\x16\n\x06rarity\x18\x03\x20\x01(\x05R\x06rarity\x12\
    \x16\n\x06method\x18\x04\x20\x01(\x05R\x06method\x12\x18\n\x07itemdef\
    \x18\x05\x20\x01(\rR\x07itemdef\"\x85\x02\n\x1aCDOTAUserMsg_OverheadEven\
    t\x12<\n\x0cmessage_type\x18\x01\x20\x02(\x0e2\x19.dota.DOTA_OVERHEAD_AL\
    ERTR\x0bmessageType\x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value\
    \x124\n\x16target_player_entindex\x18\x03\x20\x01(\x05R\x14targetPlayerE\
    ntindex\x12'\n\x0ftarget_entindex\x18\x04\x20\x01(\x05R\x0etargetEntinde\
    x\x124\n\x16source_player_entindex\x18\x05\x20\x01(\x05R\x14sourcePlayer\
    Entindex\"N\n\x1cCDOTAUserMsg_TutorialTipInfo\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x1a\n\x08progress\x18\x02\x20\x01(\x05R\x08prog\
    ress\"}\n\x1bCDOTAUserMsg_TutorialFinish\x12\x18\n\x07heading\x18\x01\
    \x20\x01(\tR\x07heading\x12\x16\n\x06emblem\x18\x02\x20\x01(\tR\x06emble\
    m\x12\x12\n\x04body\x18\x03\x20\x01(\tR\x04body\x12\x18\n\x07success\x18\
    \x04\x20\x01(\x08R\x07success\"&\n$CDOTAUserMsg_TutorialMinimapPosition\
    \"}\n\x1fCDOTAUserMsg_SendGenericToolTip\x12\x14\n\x05title\x18\x01\x20\
    \x01(\tR\x05title\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\x12\x1a\
    \n\x08entindex\x18\x03\x20\x01(\x05R\x08entindex\x12\x14\n\x05close\x18\
    \x04\x20\x01(\x08R\x05close\"m\n\x16CDOTAUserMsg_WorldLine\x12\x1b\n\tpl\
    ayer_id\x18\x01\x20\x01(\x05R\x08playerId\x126\n\tworldline\x18\x02\x20\
    \x01(\x0b2\x18.dota.CDOTAMsg_WorldLineR\tworldline\"\xc1\x01\n\x16CDOTAU\
    serMsg_ChatWheel\x12&\n\x0fchat_message_id\x18\x01\x20\x01(\rR\rchatMess\
    ageId\x12\x1b\n\tplayer_id\x18\x02\x20\x01(\x05R\x08playerId\x12\x1d\n\n\
    account_id\x18\x03\x20\x01(\rR\taccountId\x12\"\n\rparam_hero_id\x18\x04\
    \x20\x01(\rR\x0bparamHeroId\x12\x1f\n\x0bemoticon_id\x18\x05\x20\x01(\rR\
    \nemoticonId\"\x80\x01\n\x1dCDOTAUserMsg_ReceivedXmasGift\x12\x1b\n\tpla\
    yer_id\x18\x01\x20\x01(\x05R\x08playerId\x12\x1b\n\titem_name\x18\x02\
    \x20\x01(\tR\x08itemName\x12%\n\x0einventory_slot\x18\x03\x20\x01(\x05R\
    \rinventorySlot\"\xf7\x01\n\x17CDOTAUserMsg_ShowSurvey\x12\x1b\n\tsurvey\
    _id\x18\x01\x20\x01(\x05R\x08surveyId\x12\x19\n\x08match_id\x18\x02\x20\
    \x01(\x04R\x07matchId\x12%\n\x0eresponse_style\x18\x03\x20\x01(\tR\rresp\
    onseStyle\x12(\n\x10teammate_hero_id\x18\x04\x20\x01(\rR\x0eteammateHero\
    Id\x12#\n\rteammate_name\x18\x05\x20\x01(\tR\x0cteammateName\x12.\n\x13t\
    eammate_account_id\x18\x06\x20\x01(\rR\x11teammateAccountId\"?\n\x20CDOT\
    AUserMsg_UpdateSharedContent\x12\x1b\n\tslot_type\x18\x01\x20\x01(\x05R\
    \x08slotType\"!\n\x1fCDOTAUserMsg_TutorialRequestExp\"8\n\x19CDOTAUserMs\
    g_TutorialFade\x12\x1b\n\ttgt_alpha\x18\x01\x20\x01(\x05R\x08tgtAlpha\"\
    \xa1\x01\n\x20CDOTAUserMsg_TutorialPingMinimap\x12\x1b\n\tplayer_id\x18\
    \x01\x20\x01(\x05R\x08playerId\x12\x13\n\x05pos_x\x18\x02\x20\x01(\x02R\
    \x04posX\x12\x13\n\x05pos_y\x18\x03\x20\x01(\x02R\x04posY\x12\x13\n\x05p\
    os_z\x18\x04\x20\x01(\x02R\x04posZ\x12!\n\x0centity_index\x18\x05\x20\
    \x01(\x05R\x0bentityIndex\":\n\"CDOTAUserMsg_GamerulesStateChanged\x12\
    \x14\n\x05state\x18\x01\x20\x01(\rR\x05state\"Y\n\x1dCDOTAUserMsg_AddQue\
    stLogEntry\x12\x19\n\x08npc_name\x18\x01\x20\x01(\tR\x07npcName\x12\x1d\
    \n\nnpc_dialog\x18\x02\x20\x01(\tR\tnpcDialog\"u\n\x1aCDOTAUserMsg_SendS\
    tatPopup\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12:\n\t\
    statpopup\x18\x02\x20\x01(\x0b2\x1c.dota.CDOTAMsg_SendStatPopupR\tstatpo\
    pup\"n\n!CDOTAUserMsg_DismissAllStatPopups\x12I\n\rdismissallmsg\x18\x01\
    \x20\x01(\x0b2#.dota.CDOTAMsg_DismissAllStatPopupsR\rdismissallmsg\"\xa3\
    \x01\n%CDOTAUserMsg_SendRoshanSpectatorPhase\x12-\n\x05phase\x18\x01\x20\
    \x01(\x0e2\x17.dota.DOTA_ROSHAN_PHASER\x05phase\x12(\n\x10phase_start_ti\
    me\x18\x02\x20\x01(\x05R\x0ephaseStartTime\x12!\n\x0cphase_length\x18\
    \x03\x20\x01(\x05R\x0bphaseLength\"X\n\x1cCDOTAUserMsg_SendRoshanPopup\
    \x12\x1c\n\treclaimed\x18\x01\x20\x01(\x08R\treclaimed\x12\x1a\n\x08game\
    time\x18\x02\x20\x01(\x05R\x08gametime\"j\n\x1aCDOTAUserMsg_SendFinalGol\
    d\x12#\n\rreliable_gold\x18\x01\x20\x03(\rR\x0creliableGold\x12'\n\x0fun\
    reliable_gold\x18\x02\x20\x03(\rR\x0eunreliableGold\"e\n\x16CDOTAUserMsg\
    _CustomMsg\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x12\x1b\n\
    \tplayer_id\x18\x02\x20\x01(\x05R\x08playerId\x12\x14\n\x05value\x18\x03\
    \x20\x01(\x05R\x05value\"p\n\x19CDOTAUserMsg_CoachHUDPing\x12\x1b\n\tpla\
    yer_id\x18\x01\x20\x01(\x05R\x08playerId\x126\n\x08hud_ping\x18\x02\x20\
    \x01(\x0b2\x1b.dota.CDOTAMsg_CoachHUDPingR\x07hudPing\"\x20\n\x1eCDOTAUs\
    erMsg_ClientLoadGridNav\"\x82\x05\n\x1aCDOTAUserMsg_TE_Projectile\x12\
    \x16\n\x06source\x18\x01\x20\x01(\rR\x06source\x12\x16\n\x06target\x18\
    \x02\x20\x01(\rR\x06target\x12\x1d\n\nmove_speed\x18\x03\x20\x01(\x05R\t\
    moveSpeed\x12+\n\x11source_attachment\x18\x04\x20\x01(\x05R\x10sourceAtt\
    achment\x124\n\x16particle_system_handle\x18\x05\x20\x01(\x03R\x14partic\
    leSystemHandle\x12\x1c\n\tdodgeable\x18\x06\x20\x01(\x08R\tdodgeable\x12\
    \x1b\n\tis_attack\x18\x07\x20\x01(\x08R\x08isAttack\x12\x1f\n\x0bexpire_\
    time\x18\t\x20\x01(\x02R\nexpireTime\x12$\n\rmaximpacttime\x18\n\x20\x01\
    (\x02R\rmaximpacttime\x12$\n\rcolorgemcolor\x18\x0b\x20\x01(\x07R\rcolor\
    gemcolor\x12\x1f\n\x0blaunch_tick\x18\x0c\x20\x01(\x05R\nlaunchTick\x12\
    \x16\n\x06handle\x18\r\x20\x01(\x05R\x06handle\x12/\n\ntarget_loc\x18\
    \x0e\x20\x01(\x0b2\x10.dota.CMsgVectorR\ttargetLoc\x12U\n\x10particle_cp\
    _data\x18\x0f\x20\x03(\x0b2+.dota.CDOTAUserMsg_ProjectileParticleCPDataR\
    \x0eparticleCpData\x12I\n!additional_particle_system_handle\x18\x10\x20\
    \x01(\x03R\x1eadditionalParticleSystemHandle\"\x90\x05\n\x1dCDOTAUserMsg\
    _TE_ProjectileLoc\x12/\n\nsource_loc\x18\x01\x20\x01(\x0b2\x10.dota.CMsg\
    VectorR\tsourceLoc\x12\x16\n\x06target\x18\x02\x20\x01(\rR\x06target\x12\
    \x1d\n\nmove_speed\x18\x03\x20\x01(\x05R\tmoveSpeed\x124\n\x16particle_s\
    ystem_handle\x18\x04\x20\x01(\x03R\x14particleSystemHandle\x12\x1c\n\tdo\
    dgeable\x18\x05\x20\x01(\x08R\tdodgeable\x12\x1b\n\tis_attack\x18\x06\
    \x20\x01(\x08R\x08isAttack\x12\x1f\n\x0bexpire_time\x18\t\x20\x01(\x02R\
    \nexpireTime\x12/\n\ntarget_loc\x18\n\x20\x01(\x0b2\x10.dota.CMsgVectorR\
    \ttargetLoc\x12$\n\rcolorgemcolor\x18\x0b\x20\x01(\x07R\rcolorgemcolor\
    \x12\x1f\n\x0blaunch_tick\x18\x0c\x20\x01(\x05R\nlaunchTick\x12\x16\n\
    \x06handle\x18\r\x20\x01(\x05R\x06handle\x12\x16\n\x06source\x18\x0e\x20\
    \x01(\rR\x06source\x12+\n\x11source_attachment\x18\x0f\x20\x01(\x05R\x10\
    sourceAttachment\x12U\n\x10particle_cp_data\x18\x10\x20\x03(\x0b2+.dota.\
    CDOTAUserMsg_ProjectileParticleCPDataR\x0eparticleCpData\x12I\n!addition\
    al_particle_system_handle\x18\x11\x20\x01(\x03R\x1eadditionalParticleSys\
    temHandle\";\n!CDOTAUserMsg_TE_DestroyProjectile\x12\x16\n\x06handle\x18\
    \x01\x20\x01(\x05R\x06handle\"\x83\x01\n\x1fCDOTAUserMsg_TE_DotaBloodImp\
    act\x12\x16\n\x06entity\x18\x01\x20\x01(\rR\x06entity\x12\x14\n\x05scale\
    \x18\x02\x20\x01(\x02R\x05scale\x12\x18\n\x07xnormal\x18\x03\x20\x01(\
    \x02R\x07xnormal\x12\x18\n\x07ynormal\x18\x04\x20\x01(\x02R\x07ynormal\"\
    \xb7\x03\n\x18CDOTAUserMsg_AbilityPing\x12\x1b\n\tplayer_id\x18\x01\x20\
    \x01(\x05R\x08playerId\x12\x1d\n\nability_id\x18\x02\x20\x01(\x05R\tabil\
    ityId\x120\n\x04type\x18\x03\x20\x01(\x0e2\x1c.dota.DOTA_ABILITY_PING_TY\
    PER\x04type\x12)\n\x10cooldown_seconds\x18\x04\x20\x01(\rR\x0fcooldownSe\
    conds\x12\x14\n\x05level\x18\x05\x20\x01(\rR\x05level\x12\x18\n\x07passi\
    ve\x18\x06\x20\x01(\x08R\x07passive\x12\x1f\n\x0bmana_needed\x18\x07\x20\
    \x01(\rR\nmanaNeeded\x12\x1b\n\tentity_id\x18\x08\x20\x01(\rR\x08entityI\
    d\x12'\n\x0fprimary_charges\x18\t\x20\x01(\x05R\x0eprimaryCharges\x12+\n\
    \x11secondary_charges\x18\n\x20\x01(\x05R\x10secondaryCharges\x12\x1b\n\
    \tctrl_held\x18\x0c\x20\x01(\x08R\x08ctrlHeld\x12!\n\x0creclaim_time\x18\
    \r\x20\x01(\x02R\x0breclaimTime\"\x88\x02\n\x1dCDOTAUserMsg_TE_UnitAnima\
    tion\x12\x16\n\x06entity\x18\x01\x20\x01(\rR\x06entity\x12)\n\x10sequenc\
    e_variant\x18\x02\x20\x01(\x05R\x0fsequenceVariant\x12\"\n\x0cplaybackra\
    te\x18\x03\x20\x01(\x02R\x0cplaybackrate\x12\x1c\n\tcastpoint\x18\x04\
    \x20\x01(\x02R\tcastpoint\x12\x12\n\x04type\x18\x05\x20\x01(\x05R\x04typ\
    e\x12\x1a\n\x08activity\x18\x06\x20\x01(\x05R\x08activity\x122\n\x15lag_\
    compensation_time\x18\x07\x20\x01(\x02R\x13lagCompensationTime\"N\n\x20C\
    DOTAUserMsg_TE_UnitAnimationEnd\x12\x16\n\x06entity\x18\x01\x20\x01(\rR\
    \x06entity\x12\x12\n\x04snap\x18\x02\x20\x01(\x08R\x04snap\"\xcf\x01\n\
    \x1dCDOTAUserMsg_ShowGenericPopup\x12\x16\n\x06header\x18\x01\x20\x02(\t\
    R\x06header\x12\x12\n\x04body\x18\x02\x20\x02(\tR\x04body\x12\x16\n\x06p\
    aram1\x18\x03\x20\x01(\tR\x06param1\x12\x16\n\x06param2\x18\x04\x20\x01(\
    \tR\x06param2\x12\x1f\n\x0btint_screen\x18\x05\x20\x01(\x08R\ntintScreen\
    \x121\n\x15show_no_other_dialogs\x18\x06\x20\x01(\x08R\x12showNoOtherDia\
    logs\"\x87\x01\n\x16CDOTAUserMsg_VoteStart\x12\x14\n\x05title\x18\x01\
    \x20\x01(\tR\x05title\x12\x1a\n\x08duration\x18\x02\x20\x01(\x02R\x08dur\
    ation\x12!\n\x0cchoice_count\x18\x03\x20\x01(\x05R\x0bchoiceCount\x12\
    \x18\n\x07choices\x18\x04\x20\x03(\tR\x07choices\">\n\x17CDOTAUserMsg_Vo\
    teUpdate\x12#\n\rchoice_counts\x18\x01\x20\x03(\x05R\x0cchoiceCounts\"?\
    \n\x14CDOTAUserMsg_VoteEnd\x12'\n\x0fselected_choice\x18\x01\x20\x01(\
    \x05R\x0eselectedChoice\"\xc8\x01\n\x1fCDOTAUserMsg_BoosterStatePlayer\
    \x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12\x14\n\x05bon\
    us\x18\x02\x20\x01(\x02R\x05bonus\x12\x1f\n\x0bevent_bonus\x18\x03\x20\
    \x01(\x02R\neventBonus\x12\"\n\rbonus_item_id\x18\x04\x20\x01(\rR\x0bbon\
    usItemId\x12-\n\x13event_bonus_item_id\x18\x05\x20\x01(\rR\x10eventBonus\
    ItemId\"k\n\x19CDOTAUserMsg_BoosterState\x12N\n\x0fboosted_players\x18\
    \x01\x20\x03(\x0b2%.dota.CDOTAUserMsg_BoosterStatePlayerR\x0eboostedPlay\
    ers\"*\n\x16CDOTAUserMsg_PlayerMMR\x12\x10\n\x03mmr\x18\x01\x20\x03(\x11\
    R\x03mmr\"|\n\x19CDOTAUserMsg_AbilitySteal\x12\x1b\n\tplayer_id\x18\x01\
    \x20\x01(\x05R\x08playerId\x12\x1d\n\nability_id\x18\x02\x20\x01(\x05R\t\
    abilityId\x12#\n\rability_level\x18\x03\x20\x01(\rR\x0cabilityLevel\"\
    \x8b\x01\n\x1cCDOTAUserMsg_StatsHeroLookup\x12\x1b\n\tplayer_id\x18\x01\
    \x20\x01(\x05R\x08playerId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\x05R\
    \x06heroId\x12\x1b\n\thero_name\x18\x03\x20\x01(\tR\x08heroName\x12\x18\
    \n\x07persona\x18\x04\x20\x01(\tR\x07persona\"\xb4\x02\n\"CDOTAUserMsg_S\
    tatsHeroPositionInfo\x12)\n\x10average_position\x18\x01\x20\x01(\x02R\
    \x0faveragePosition\x12`\n\x10position_details\x18\x02\x20\x03(\x0b25.do\
    ta.CDOTAUserMsg_StatsHeroPositionInfo.PositionPairR\x0fpositionDetails\
    \x1a\x80\x01\n\x0cPositionPair\x12I\n\x11position_category\x18\x01\x20\
    \x01(\x0e2\x1c.dota.DOTA_POSITION_CATEGORYR\x10positionCategory\x12%\n\
    \x0eposition_count\x18\x02\x20\x01(\rR\rpositionCount\"\xd1\x04\n#CDOTAU\
    serMsg_StatsHeroMinuteDetails\x12\x1b\n\tlast_hits\x18\x01\x20\x01(\rR\
    \x08lastHits\x12\x1d\n\nhero_kills\x18\x02\x20\x01(\rR\theroKills\x12\
    \x1f\n\x0bhero_damage\x18\x03\x20\x01(\rR\nheroDamage\x12!\n\x0ctower_da\
    mage\x18\x04\x20\x01(\rR\x0btowerDamage\x12M\n\rposition_info\x18\x05\
    \x20\x01(\x0b2(.dota.CDOTAUserMsg_StatsHeroPositionInfoR\x0cpositionInfo\
    \x12\x19\n\x08total_xp\x18\x06\x20\x01(\rR\x07totalXp\x12\x1b\n\tnet_wor\
    th\x18\x07\x20\x01(\rR\x08netWorth\x120\n\x14harvested_creep_gold\x18\
    \x08\x20\x01(\rR\x12harvestedCreepGold\x12!\n\x0cclaimed_farm\x18\t\x20\
    \x01(\rR\x0bclaimedFarm\x12!\n\x0cwards_placed\x18\n\x20\x01(\rR\x0bward\
    sPlaced\x12'\n\x0frunes_collected\x18\x0b\x20\x01(\rR\x0erunesCollected\
    \x12\x19\n\x08tps_used\x18\x0c\x20\x01(\rR\x07tpsUsed\x12\x1d\n\nmana_sp\
    ent\x18\r\x20\x03(\rR\tmanaSpent\x12'\n\x0fdamage_absorbed\x18\x0e\x20\
    \x03(\rR\x0edamageAbsorbed\x12\x1f\n\x0bdamage_done\x18\x0f\x20\x03(\rR\
    \ndamageDone\"\xc1\x05\n#CDOTAUserMsg_StatsTeamMinuteDetails\x12L\n\x0cp\
    layer_stats\x18\x01\x20\x03(\x0b2).dota.CDOTAUserMsg_StatsHeroMinuteDeta\
    ilsR\x0bplayerStats\x12\x1f\n\x0btower_kills\x18\x02\x20\x01(\rR\ntowerK\
    ills\x12#\n\rbarrack_kills\x18\x03\x20\x01(\rR\x0cbarrackKills\x129\n\
    \x19available_lane_creep_gold\x18\x04\x20\x01(\rR\x16availableLaneCreepG\
    old\x12,\n\x12balance_kill_value\x18\x05\x20\x01(\rR\x10balanceKillValue\
    \x12.\n\x13balance_tower_value\x18\x06\x20\x01(\rR\x11balanceTowerValue\
    \x124\n\x16balance_barracks_value\x18\x07\x20\x01(\rR\x14balanceBarracks\
    Value\x12,\n\x12balance_gold_value\x18\x08\x20\x01(\rR\x10balanceGoldVal\
    ue\x12(\n\x10balance_xp_value\x18\t\x20\x01(\rR\x0ebalanceXpValue\x12h\n\
    \x10lane_performance\x18\n\x20\x03(\x0b2=.dota.CDOTAUserMsg_StatsTeamMin\
    uteDetails.LocationPerformanceR\x0flanePerformance\x1au\n\x13LocationPer\
    formance\x12+\n\x11location_category\x18\x01\x20\x01(\rR\x10locationCate\
    gory\x12\x1b\n\tstat_type\x18\x02\x20\x01(\rR\x08statType\x12\x14\n\x05v\
    alue\x18\x03\x20\x01(\rR\x05value\"\xfc\x01\n!CDOTAUserMsg_StatsPlayerKi\
    llShare\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12,\n\
    \x12kill_share_percent\x18\x02\x20\x01(\x02R\x10killSharePercent\x12\x20\
    \n\x0cplayer_loc_x\x18\x03\x20\x01(\x02R\nplayerLocX\x12\x20\n\x0cplayer\
    _loc_y\x18\x04\x20\x01(\x02R\nplayerLocY\x12%\n\x0ehealth_percent\x18\
    \x05\x20\x01(\x02R\rhealthPercent\x12!\n\x0cmana_percent\x18\x06\x20\x01\
    (\x02R\x0bmanaPercent\"\x93\x02\n\x1dCDOTAUserMsg_StatsKillDetails\x12\
    \x1b\n\tvictim_id\x18\x01\x20\x01(\x05R\x08victimId\x12H\n\x0bkill_share\
    s\x18\x02\x20\x03(\x0b2'.dota.CDOTAUserMsg_StatsPlayerKillShareR\nkillSh\
    ares\x12$\n\x0edamage_to_kill\x18\x03\x20\x01(\rR\x0cdamageToKill\x12)\n\
    \x10effective_health\x18\x04\x20\x01(\rR\x0feffectiveHealth\x12\x1d\n\nd\
    eath_time\x18\x05\x20\x01(\x02R\tdeathTime\x12\x1b\n\tkiller_id\x18\x06\
    \x20\x01(\x05R\x08killerId\"\xe5\x07\n\x1eCDOTAUserMsg_StatsMatchDetails\
    \x12C\n\x0bhero_lookup\x18\x01\x20\x03(\x0b2\".dota.CDOTAUserMsg_StatsHe\
    roLookupR\nheroLookup\x12N\n\rradiant_stats\x18\x02\x20\x03(\x0b2).dota.\
    CDOTAUserMsg_StatsTeamMinuteDetailsR\x0cradiantStats\x12H\n\ndire_stats\
    \x18\x03\x20\x03(\x0b2).dota.CDOTAUserMsg_StatsTeamMinuteDetailsR\tdireS\
    tats\x12H\n\rradiant_kills\x18\x04\x20\x03(\x0b2#.dota.CDOTAUserMsg_Stat\
    sKillDetailsR\x0cradiantKills\x12B\n\ndire_kills\x18\x05\x20\x03(\x0b2#.\
    dota.CDOTAUserMsg_StatsKillDetailsR\tdireKills\x12h\n\rfight_details\x18\
    \x06\x20\x03(\x0b2C.dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_Sta\
    tsFightDetailsR\x0cfightDetails\x1a\x9a\x01\n\"CDOTAUserMsg_StatsFightTe\
    amDetails\x12\"\n\x0cparticipants\x18\x01\x20\x03(\x05R\x0cparticipants\
    \x12\x16\n\x06deaths\x18\x02\x20\x03(\x05R\x06deaths\x12\x1d\n\ngold_del\
    ta\x18\x03\x20\x01(\rR\tgoldDelta\x12\x19\n\x08xp_delta\x18\x04\x20\x01(\
    \rR\x07xpDelta\x1a\xce\x02\n\x1eCDOTAUserMsg_StatsFightDetails\x12\x1d\n\
    \nstart_time\x18\x01\x20\x01(\x02R\tstartTime\x12\x19\n\x08end_time\x18\
    \x02\x20\x01(\x02R\x07endTime\x12{\n\x15radiant_fight_details\x18\x03\
    \x20\x01(\x0b2G.dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFi\
    ghtTeamDetailsR\x13radiantFightDetails\x12u\n\x12dire_fight_details\x18\
    \x04\x20\x01(\x0b2G.dota.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_Sta\
    tsFightTeamDetailsR\x10direFightDetails\"F\n\x16CDOTAUserMsg_MiniTaunt\
    \x12,\n\x12taunting_player_id\x18\x01\x20\x01(\x05R\x10tauntingPlayerId\
    \"<\n\x19CDOTAUserMsg_SpeechBubble\x12\x1f\n\x0bdestroy_all\x18\x01\x20\
    \x01(\x08R\ndestroyAll\"\x8b\x01\n\x20CDOTAUserMsg_CustomHeaderMessage\
    \x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12\x1a\n\x08dur\
    ation\x18\x02\x20\x01(\x02R\x08duration\x12\x18\n\x07message\x18\x03\x20\
    \x01(\tR\x07message\x12\x14\n\x05value\x18\x04\x20\x01(\x05R\x05value\"\
    \x85\x01\n\x13CMsgHeroAbilityStat\x120\n\tstat_type\x18\x01\x20\x01(\x0e\
    2\x13.dota.EHeroStatTypeR\x08statType\x12\x1b\n\tint_value\x18\x02\x20\
    \x01(\x05R\x08intValue\x12\x1f\n\x0bfloat_value\x18\x03\x20\x01(\x02R\nf\
    loatValue\"\x86\x01\n\x1cCMsgCombatAnalyzerPlayerStat\x12\x1d\n\naccount\
    _id\x18\x01\x20\x01(\rR\taccountId\x12G\n\x12hero_ability_stats\x18\x02\
    \x20\x03(\x0b2\x19.dota.CMsgHeroAbilityStatR\x10heroAbilityStats\"{\n\
    \x17CMsgCombatAnalyzerStats\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\
    \x07matchId\x12E\n\x0cplayer_stats\x18\x02\x20\x03(\x0b2\".dota.CMsgComb\
    atAnalyzerPlayerStatR\x0bplayerStats\"v\n\x16CDOTAUserMsg_BeastChat\x12\
    \x12\n\x04team\x18\x01\x20\x01(\rR\x04team\x12\x16\n\x06format\x18\x02\
    \x20\x01(\tR\x06format\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07messa\
    ge\x12\x16\n\x06target\x18\x04\x20\x01(\tR\x06target\"\x82\x01\n$CDOTAUs\
    erMsg_CustomHudElement_Create\x12\x1d\n\nelement_id\x18\x01\x20\x01(\tR\
    \telementId\x12'\n\x0flayout_filename\x18\x02\x20\x01(\tR\x0elayoutFilen\
    ame\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\x80\x01\n$CDOTAUse\
    rMsg_CustomHudElement_Modify\x12\x1d\n\nelement_id\x18\x01\x20\x01(\tR\t\
    elementId\x12%\n\x0emodify_visible\x18\x02\x20\x01(\x08R\rmodifyVisible\
    \x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"F\n%CDOTAUserMsg_Custo\
    mHudElement_Destroy\x12\x1d\n\nelement_id\x18\x01\x20\x01(\tR\telementId\
    \"W\n\"CDOTAUserMsg_CompendiumStatePlayer\x12\x1b\n\tplayer_id\x18\x01\
    \x20\x01(\x05R\x08playerId\x12\x14\n\x05level\x18\x02\x20\x01(\rR\x05lev\
    el\"w\n\x1cCDOTAUserMsg_CompendiumState\x12W\n\x12compendium_players\x18\
    \x01\x20\x03(\x0b2(.dota.CDOTAUserMsg_CompendiumStatePlayerR\x11compendi\
    umPlayers\"\xc6\x02\n\x1eCDOTAUserMsg_ProjectionAbility\x12\x1d\n\nabili\
    ty_id\x18\x01\x20\x01(\x05R\tabilityId\x12(\n\x10caster_ent_index\x18\
    \x02\x20\x01(\x05R\x0ecasterEntIndex\x12\x1f\n\x0bcaster_team\x18\x03\
    \x20\x01(\x05R\ncasterTeam\x12\x1f\n\x0bchannel_end\x18\x04\x20\x01(\x08\
    R\nchannelEnd\x12(\n\x06origin\x18\x05\x20\x01(\x0b2\x10.dota.CMsgVector\
    R\x06origin\x12*\n\x11track_caster_only\x18\x06\x20\x01(\x08R\x0ftrackCa\
    sterOnly\x12\x19\n\x08end_time\x18\x07\x20\x01(\x02R\x07endTime\x12(\n\
    \x10victim_ent_index\x18\x08\x20\x01(\x05R\x0evictimEntIndex\"e\n\x1cCDO\
    TAUserMsg_ProjectionEvent\x121\n\x08event_id\x18\x01\x20\x01(\x0e2\x16.d\
    ota.EProjectionEventR\x07eventId\x12\x12\n\x04team\x18\x02\x20\x01(\rR\
    \x04team\"\\\n\x14CDOTAUserMsg_XPAlert\x12\x1b\n\tplayer_id\x18\x01\x20\
    \x01(\x05R\x08playerId\x12'\n\x0ftarget_entindex\x18\x02\x20\x01(\x05R\
    \x0etargetEntindex\"\xb1\x01\n\x1cCDOTAUserMsg_TalentTreeAlert\x12\x1b\n\
    \tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12'\n\x0ftarget_entindex\
    \x18\x02\x20\x01(\x05R\x0etargetEntindex\x12\x1d\n\nability_id\x18\x03\
    \x20\x01(\x05R\tabilityId\x12\x12\n\x04slot\x18\x04\x20\x01(\x05R\x04slo\
    t\x12\x18\n\x07learned\x18\x05\x20\x01(\x08R\x07learned\"\"\n\x20CDOTAUs\
    erMsg_UpdateQuestProgress\"\x88\x02\n\x18CDOTAUserMsg_QuestStatus\x12\
    \x1b\n\tplayer_id\x18\x01\x20\x02(\x05R\x08playerId\x12\x19\n\x08quest_i\
    d\x18\x02\x20\x01(\rR\x07questId\x12!\n\x0cchallenge_id\x18\x03\x20\x01(\
    \rR\x0bchallengeId\x12\x1a\n\x08progress\x18\x04\x20\x01(\rR\x08progress\
    \x12\x12\n\x04goal\x18\x05\x20\x01(\rR\x04goal\x12\x14\n\x05query\x18\
    \x06\x20\x01(\rR\x05query\x12#\n\rfail_gametime\x18\x07\x20\x01(\x02R\
    \x0cfailGametime\x12&\n\x0fitem_ability_id\x18\x08\x20\x01(\x05R\ritemAb\
    ilityId\"f\n\x1cCDOTAUserMsg_SuggestHeroPick\x12\x1b\n\tplayer_id\x18\
    \x01\x20\x02(\x05R\x08playerId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\
    \x06heroId\x12\x10\n\x03ban\x18\x03\x20\x01(\x08R\x03ban\"X\n\x1cCDOTAUs\
    erMsg_SuggestHeroRole\x12\x1b\n\tplayer_id\x18\x01\x20\x02(\x05R\x08play\
    erId\x12\x1b\n\thero_role\x18\x02\x20\x01(\tR\x08heroRole\"\xe6\x01\n\
    \x1fCDOTAUserMsg_KillcamDamageTaken\x12\x1b\n\tplayer_id\x18\x01\x20\x02\
    (\x05R\x08playerId\x12!\n\x0cdamage_taken\x18\x02\x20\x01(\rR\x0bdamageT\
    aken\x12\x1b\n\titem_type\x18\x03\x20\x01(\rR\x08itemType\x12&\n\x0fitem\
    _ability_id\x18\x04\x20\x01(\x05R\ritemAbilityId\x12\x1b\n\thero_name\
    \x18\x05\x20\x01(\tR\x08heroName\x12!\n\x0cdamage_color\x18\x06\x20\x01(\
    \tR\x0bdamageColor\"Q\n\x1eCDOTAUserMsg_SelectPenaltyGold\x12\x1b\n\tpla\
    yer_id\x18\x01\x20\x02(\x05R\x08playerId\x12\x12\n\x04cost\x18\x02\x20\
    \x01(\x11R\x04cost\"\xab\x01\n\x1bCDOTAUserMsg_RollDiceResult\x12\x1b\n\
    \tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12!\n\x0cchannel_type\x18\
    \x02\x20\x01(\rR\x0bchannelType\x12\x19\n\x08roll_min\x18\x03\x20\x01(\r\
    R\x07rollMin\x12\x19\n\x08roll_max\x18\x04\x20\x01(\rR\x07rollMax\x12\
    \x16\n\x06result\x18\x05\x20\x01(\rR\x06result\"u\n\x1bCDOTAUserMsg_Flip\
    CoinResult\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12!\n\
    \x0cchannel_type\x18\x02\x20\x01(\rR\x0bchannelType\x12\x16\n\x06result\
    \x18\x03\x20\x01(\x08R\x06result\"F\n'CDOTAUserMessage_RequestItemSugges\
    tions\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\"e\n#CDOTAU\
    serMessage_TeamCaptainChanged\x12\x12\n\x04team\x18\x01\x20\x01(\rR\x04t\
    eam\x12*\n\x11captain_player_id\x18\x02\x20\x01(\x05R\x0fcaptainPlayerId\
    \"n\n\x1eCDOTAUserMsg_ChatWheelCooldown\x12\x1d\n\nmessage_id\x18\x01\
    \x20\x01(\rR\tmessageId\x12-\n\x12cooldown_remaining\x18\x02\x20\x01(\
    \x02R\x11cooldownRemaining\"\xb8\x01\n\x1eCDOTAUserMsg_HeroRelicProgress\
    \x12&\n\x0fhero_relic_type\x18\x01\x20\x01(\rR\rheroRelicType\x12\x14\n\
    \x05value\x18\x02\x20\x01(\rR\x05value\x12\x18\n\x07ehandle\x18\x03\x20\
    \x01(\rR\x07ehandle\x12\x19\n\x08event_id\x18\x04\x20\x01(\rR\x07eventId\
    \x12#\n\rvalue_display\x18\x05\x20\x01(\x02R\x0cvalueDisplay\"\x9a\x01\n\
    'CDOTAUserMsg_AbilityDraftRequestAbility\x12\x1b\n\tplayer_id\x18\x01\
    \x20\x01(\x05R\x08playerId\x120\n\x14requested_ability_id\x18\x02\x20\
    \x01(\x05R\x12requestedAbilityId\x12\x20\n\x0cctrl_is_down\x18\x03\x20\
    \x01(\x08R\nctrlIsDown\"\xc7\x01\n\x19CDOTAUserMsg_DamageReport\x12\x1b\
    \n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12$\n\x0etarget_hero_id\
    \x18\x02\x20\x01(\rR\x0ctargetHeroId\x12$\n\x0esource_hero_id\x18\x03\
    \x20\x01(\rR\x0csourceHeroId\x12#\n\rdamage_amount\x18\x04\x20\x01(\x05R\
    \x0cdamageAmount\x12\x1c\n\tbroadcast\x18\x05\x20\x01(\x08R\tbroadcast\"\
    \xfb\x01\n\x19CDOTAUserMsg_SalutePlayer\x12(\n\x10source_player_id\x18\
    \x01\x20\x01(\x05R\x0esourcePlayerId\x12(\n\x10target_player_id\x18\x02\
    \x20\x01(\x05R\x0etargetPlayerId\x12\x1d\n\ntip_amount\x18\x03\x20\x01(\
    \rR\ttipAmount\x12\x19\n\x08event_id\x18\x04\x20\x01(\rR\x07eventId\x12(\
    \n\x10custom_tip_style\x18\x05\x20\x01(\tR\x0ecustomTipStyle\x12&\n\x0fn\
    um_recent_tips\x18\x06\x20\x01(\rR\rnumRecentTips\"O\n\x15CDOTAUserMsg_T\
    ipAlert\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12\x19\n\
    \x08tip_text\x18\x02\x20\x01(\tR\x07tipText\"\x8e\x01\n\x1dCDOTAUserMsg_\
    ReplaceQueryUnit\x12\x1b\n\tplayer_id\x18\x01\x20\x02(\x05R\x08playerId\
    \x12'\n\x0fsource_entindex\x18\x02\x20\x01(\x05R\x0esourceEntindex\x12'\
    \n\x0ftarget_entindex\x18\x03\x20\x01(\x05R\x0etargetEntindex\"z\n\x1aCD\
    OTAUserMsg_ESArcanaCombo\x12\x18\n\x07ehandle\x18\x01\x20\x01(\rR\x07eha\
    ndle\x12\x1f\n\x0bcombo_count\x18\x02\x20\x01(\rR\ncomboCount\x12!\n\x0c\
    arcana_level\x18\x03\x20\x01(\rR\x0barcanaLevel\"\x83\x01\n!CDOTAUserMsg\
    _ESArcanaComboSummary\x12\x18\n\x07ehandle\x18\x01\x20\x01(\rR\x07ehandl\
    e\x12\x1f\n\x0bcombo_count\x18\x02\x20\x01(\rR\ncomboCount\x12#\n\rdamag\
    e_amount\x18\x03\x20\x01(\rR\x0cdamageAmount\"\xaf\x01\n\x1aCDOTAUserMsg\
    _OMArcanaCombo\x12\x18\n\x07ehandle\x18\x01\x20\x01(\rR\x07ehandle\x12)\
    \n\x10multicast_amount\x18\x02\x20\x01(\rR\x0fmulticastAmount\x12!\n\x0c\
    arcana_level\x18\x03\x20\x01(\rR\x0barcanaLevel\x12)\n\x10multicast_chan\
    ce\x18\x04\x20\x01(\rR\x0fmulticastChance\"\xb7\x01\n\x1eCDOTAUserMsg_Hi\
    ghFiveCompleted\x12\x1e\n\x0bplayer_id_1\x18\x01\x20\x01(\x05R\tplayerId\
    1\x12\x1e\n\x0bplayer_id_2\x18\x02\x20\x01(\x05R\tplayerId2\x12*\n\x11sp\
    ecial_high_five\x18\x03\x20\x01(\x08R\x0fspecialHighFive\x12)\n\x10speci\
    al_entindex\x18\x04\x20\x01(\x05R\x0fspecialEntindex\"?\n\x20CDOTAUserMs\
    g_HighFiveLeftHanging\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08play\
    erId\"\x8e\x01\n\x1aCDOTAUserMsg_ShovelUnearth\x12\x1b\n\tplayer_id\x18\
    \x01\x20\x01(\x05R\x08playerId\x12\x19\n\x08all_chat\x18\x02\x20\x01(\
    \x08R\x07allChat\x12\x1c\n\tlocstring\x18\x03\x20\x01(\tR\tlocstring\x12\
    \x1a\n\x08quantity\x18\x04\x20\x01(\rR\x08quantity\"\xd1\x02\n\x19CDOTAU\
    serMsg_AllStarEvent\x12(\n\x10source_player_id\x18\x01\x20\x01(\x05R\x0e\
    sourcePlayerId\x12(\n\x10target_player_id\x18\x02\x20\x01(\x05R\x0etarge\
    tPlayerId\x12!\n\x0cpoint_amount\x18\x03\x20\x01(\rR\x0bpointAmount\x12\
    \x19\n\x08event_id\x18\x04\x20\x01(\rR\x07eventId\x12P\n\rplayer_scores\
    \x18\x05\x20\x03(\x0b2+.dota.CDOTAUserMsg_AllStarEvent.PlayerScoreR\x0cp\
    layerScores\x1aP\n\x0bPlayerScore\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\
    \x05R\x08playerId\x12$\n\x0escore_sans_kda\x18\x02\x20\x01(\rR\x0cscoreS\
    ansKda\"Q\n\x1fCDOTAUserMsg_QueuedOrderRemoved\x12.\n\x13unit_order_sequ\
    ence\x18\x01\x20\x03(\rR\x11unitOrderSequence\"\xac\x02\n\x1bCDOTAUserMs\
    g_DebugChallenge\x12%\n\x0echallenge_type\x18\x01\x20\x02(\rR\rchallenge\
    Type\x12,\n\x12challenge_query_id\x18\x02\x20\x02(\rR\x10challengeQueryI\
    d\x12\x19\n\x08event_id\x18\x03\x20\x02(\rR\x07eventId\x12\x1f\n\x0binst\
    ance_id\x18\x04\x20\x01(\rR\ninstanceId\x12&\n\x0fchallenge_var_0\x18\
    \x05\x20\x01(\rR\rchallengeVar0\x12&\n\x0fchallenge_var_1\x18\x06\x20\
    \x01(\rR\rchallengeVar1\x12,\n\x12challenge_max_rank\x18\x07\x20\x01(\rR\
    \x10challengeMaxRank\"\xa9\x01\n\x1dCDOTAUserMsg_FoundNeutralItem\x12\
    \x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12&\n\x0fitem_abili\
    ty_id\x18\x02\x20\x01(\x05R\ritemAbilityId\x12\x1b\n\titem_tier\x18\x03\
    \x20\x01(\rR\x08itemTier\x12&\n\x0ftier_item_count\x18\x04\x20\x01(\rR\r\
    tierItemCount\"b\n\x1cCDOTAUserMsg_OutpostCaptured\x12)\n\x10outpost_ent\
    index\x18\x01\x20\x01(\x05R\x0foutpostEntindex\x12\x17\n\x07team_id\x18\
    \x02\x20\x01(\rR\x06teamId\"U\n\x1dCDOTAUserMsg_OutpostGrantedXP\x12\x17\
    \n\x07team_id\x18\x01\x20\x01(\rR\x06teamId\x12\x1b\n\txp_amount\x18\x02\
    \x20\x01(\rR\x08xpAmount\"B\n\x1dCDOTAUserMsg_MoveCameraToUnit\x12!\n\
    \x0cunit_ehandle\x18\x01\x20\x01(\rR\x0bunitEhandle\"\xbf\x01\n\x1eCDOTA\
    UserMsg_PauseMinigameData\x12I\n\tdata_bits\x18\x01\x20\x03(\x0b2,.dota.\
    CDOTAUserMsg_PauseMinigameData.DataBitR\x08dataBits\x1aR\n\x07DataBit\
    \x12\x14\n\x05index\x18\x01\x20\x01(\rR\x05index\x12\x12\n\x04data\x18\
    \x02\x20\x01(\x05R\x04data\x12\x1d\n\ndata_extra\x18\x03\x20\x01(\x03R\t\
    dataExtra\"\xce\x02\n'CDOTAUserMsg_VersusScene_PlayerBehavior\x12\x1b\n\
    \tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12@\n\x08behavior\x18\x02\
    \x20\x01(\x0e2$.dota.EDOTAVersusScenePlayerBehaviorR\x08behavior\x12C\n\
    \rplay_activity\x18\x03\x20\x01(\x0b2\x1e.dota.VersusScene_PlayActivityR\
    \x0cplayActivity\x12:\n\nchat_wheel\x18\x04\x20\x01(\x0b2\x1b.dota.Versu\
    sScene_ChatWheelR\tchatWheel\x12C\n\rplayback_rate\x18\x05\x20\x01(\x0b2\
    \x1e.dota.VersusScene_PlaybackRateR\x0cplaybackRate\"\xa5\x01\n\x1eCDOTA\
    UserMsg_QoP_ArcanaSummary\x12\x18\n\x07ehandle\x18\x01\x20\x01(\rR\x07eh\
    andle\x12!\n\x0carcana_level\x18\x02\x20\x01(\rR\x0barcanaLevel\x12\x1f\
    \n\x0bplayers_hit\x18\x03\x20\x01(\rR\nplayersHit\x12%\n\x0eplayers_kill\
    ed\x18\x04\x20\x01(\rR\rplayersKilled\"`\n\x1eCDOTAUserMsg_HotPotato_Cre\
    ated\x12\x1e\n\x0bplayer_id_1\x18\x01\x20\x01(\x05R\tplayerId1\x12\x1e\n\
    \x0bplayer_id_2\x18\x02\x20\x01(\x05R\tplayerId2\">\n\x1fCDOTAUserMsg_Ho\
    tPotato_Exploded\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\
    \"w\n\x1fCDOTAUserMsg_WK_Arcana_Progress\x12\x18\n\x07ehandle\x18\x01\
    \x20\x01(\rR\x07ehandle\x12!\n\x0carcana_level\x18\x02\x20\x01(\rR\x0bar\
    canaLevel\x12\x17\n\x07hero_id\x18\x03\x20\x01(\rR\x06heroId\"\x83\x05\n\
    $CDOTAUserMsg_GuildChallenge_Progress\x12b\n\x0fplayer_progress\x18\x01\
    \x20\x03(\x0b29.dota.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress\
    R\x0eplayerProgress\x12\x19\n\x08guild_id\x18\x02\x20\x01(\rR\x07guildId\
    \x122\n\x15challenge_instance_id\x18\x03\x20\x01(\rR\x13challengeInstanc\
    eId\x12/\n\x13challenge_parameter\x18\x04\x20\x01(\rR\x12challengeParame\
    ter\x12`\n\x0echallenge_type\x18\x05\x20\x01(\x0e29.dota.CDOTAUserMsg_Gu\
    ildChallenge_Progress.EChallengeTypeR\rchallengeType\x12=\n\x1bchallenge\
    _progress_at_start\x18\x07\x20\x01(\rR\x18challengeProgressAtStart\x12\
    \x1a\n\x08complete\x18\x08\x20\x01(\x08R\x08complete\x1aI\n\x0ePlayerPro\
    gress\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12\x1a\n\
    \x08progress\x18\x06\x20\x01(\rR\x08progress\"o\n\x0eEChallengeType\x12\
    \x1c\n\x18k_EChallengeType_Invalid\x10\0\x12\x20\n\x1ck_EChallengeType_C\
    ooperative\x10\x01\x12\x1d\n\x19k_EChallengeType_Contract\x10\x02\"\x8c\
    \x02\n\x1dCDOTAUserMsg_WRArcanaProgress\x12\x18\n\x07ehandle\x18\x01\x20\
    \x01(\rR\x07ehandle\x12%\n\x0etarget_ehandle\x18\x02\x20\x01(\rR\rtarget\
    Ehandle\x12#\n\rarrows_landed\x18\x03\x20\x01(\rR\x0carrowsLanded\x12!\n\
    \x0cdamage_dealt\x18\x04\x20\x01(\rR\x0bdamageDealt\x12\x1b\n\ttarget_hp\
    \x18\x05\x20\x01(\rR\x08targetHp\x12\"\n\rtarget_max_hp\x18\x06\x20\x01(\
    \rR\x0btargetMaxHp\x12!\n\x0carcana_level\x18\x07\x20\x01(\rR\x0barcanaL\
    evel\"\xa5\x02\n\x1cCDOTAUserMsg_WRArcanaSummary\x12\x18\n\x07ehandle\
    \x18\x01\x20\x01(\rR\x07ehandle\x12%\n\x0etarget_ehandle\x18\x02\x20\x01\
    (\rR\rtargetEhandle\x12#\n\rarrows_landed\x18\x03\x20\x01(\rR\x0carrowsL\
    anded\x12!\n\x0cdamage_dealt\x18\x04\x20\x01(\rR\x0bdamageDealt\x12\x1b\
    \n\ttarget_hp\x18\x05\x20\x01(\rR\x08targetHp\x12\"\n\rtarget_max_hp\x18\
    \x06\x20\x01(\rR\x0btargetMaxHp\x12!\n\x0carcana_level\x18\x07\x20\x01(\
    \rR\x0barcanaLevel\x12\x18\n\x07success\x18\x08\x20\x01(\x08R\x07success\
    \"\xbf\x01\n\x1fCDOTAUserMsg_EmptyItemSlotAlert\x12(\n\x10source_player_\
    id\x18\x01\x20\x01(\x05R\x0esourcePlayerId\x12(\n\x10target_player_id\
    \x18\x02\x20\x01(\x05R\x0etargetPlayerId\x12\x1d\n\nslot_index\x18\x03\
    \x20\x01(\x05R\tslotIndex\x12)\n\x10cooldown_seconds\x18\x04\x20\x01(\
    \x05R\x0fcooldownSeconds\"\xf8\x01\n\x1cCDOTAUserMsg_AghsStatusAlert\x12\
    (\n\x10source_player_id\x18\x01\x20\x01(\x05R\x0esourcePlayerId\x12(\n\
    \x10target_player_id\x18\x02\x20\x01(\x05R\x0etargetPlayerId\x12'\n\x0ft\
    arget_entindex\x18\x03\x20\x01(\x05R\x0etargetEntindex\x12\x1d\n\nalert_\
    type\x18\x04\x20\x01(\rR\talertType\x12\x1f\n\x0bhas_scepter\x18\x05\x20\
    \x01(\x08R\nhasScepter\x12\x1b\n\thas_shard\x18\x06\x20\x01(\x08R\x08has\
    Shard\"\x83\x01\n\x19CDOTAUserMsg_MutedPlayers\x121\n\x15text_muted_play\
    er_ids\x18\x01\x20\x03(\x05R\x12textMutedPlayerIds\x123\n\x16voice_muted\
    _player_ids\x18\x02\x20\x03(\x05R\x13voiceMutedPlayerIds\"\xd8\x04\n\x1a\
    CDOTAUserMsg_ContextualTip\x12\x15\n\x06tip_id\x18\x01\x20\x01(\x05R\x05\
    tipId\x121\n\x14referenced_abilities\x18\x02\x20\x03(\tR\x13referencedAb\
    ilities\x12)\n\x10referenced_units\x18\x03\x20\x03(\tR\x0freferencedUnit\
    s\x12)\n\x10panorama_classes\x18\x04\x20\x03(\tR\x0fpanoramaClasses\x12)\
    \n\x10force_annotation\x18\x05\x20\x01(\x08R\x0fforceAnnotation\x12\x18\
    \n\x07variant\x18\x06\x20\x01(\x05R\x07variant\x12\x1b\n\tint_param\x18\
    \x07\x20\x01(\x05R\x08intParam\x12\x1d\n\nint_param2\x18\x08\x20\x01(\
    \x05R\tintParam2\x12\x1f\n\x0bfloat_param\x18\t\x20\x01(\x02R\nfloatPara\
    m\x12!\n\x0cfloat_param2\x18\n\x20\x01(\x02R\x0bfloatParam2\x12!\n\x0cst\
    ring_param\x18\x0b\x20\x01(\tR\x0bstringParam\x12#\n\rstring_param2\x18\
    \x0c\x20\x01(\tR\x0cstringParam2\x12*\n\x11tip_text_override\x18\r\x20\
    \x01(\tR\x0ftipTextOverride\x126\n\x17tip_annotation_override\x18\x0e\
    \x20\x01(\tR\x15tipAnnotationOverride\x12)\n\x10panorama_snippet\x18\x0f\
    \x20\x01(\tR\x0fpanoramaSnippet\"\x8a\x01\n\x18CDOTAUserMsg_ChatMessage\
    \x12(\n\x10source_player_id\x18\x01\x20\x01(\x05R\x0esourcePlayerId\x12!\
    \n\x0cchannel_type\x18\x02\x20\x01(\rR\x0bchannelType\x12!\n\x0cmessage_\
    text\x18\x03\x20\x01(\tR\x0bmessageText\"{\n%CDOTAUserMsg_RockPaperSciss\
    orsStarted\x12(\n\x10player_id_source\x18\x01\x20\x01(\x05R\x0eplayerIdS\
    ource\x12(\n\x10player_id_target\x18\x02\x20\x01(\x05R\x0eplayerIdTarget\
    \"\xb8\x01\n&CDOTAUserMsg_RockPaperScissorsFinished\x12\x1e\n\x0bplayer_\
    id_1\x18\x01\x20\x01(\x05R\tplayerId1\x12\x1e\n\x0bplayer_id_2\x18\x02\
    \x20\x01(\x05R\tplayerId2\x12&\n\x0fplayer_1_choice\x18\x03\x20\x01(\x05\
    R\rplayer1Choice\x12&\n\x0fplayer_2_choice\x18\x04\x20\x01(\x05R\rplayer\
    2Choice\"s\n\x1fCDOTAUserMsg_DuelOpponentKilled\x12(\n\x10player_id_winn\
    er\x18\x01\x20\x01(\x05R\x0eplayerIdWinner\x12&\n\x0fplayer_id_loser\x18\
    \x02\x20\x01(\x05R\rplayerIdLoser\"[\n\x19CDOTAUserMsg_DuelAccepted\x12\
    \x1e\n\x0bplayer_id_1\x18\x01\x20\x01(\x05R\tplayerId1\x12\x1e\n\x0bplay\
    er_id_2\x18\x02\x20\x01(\x05R\tplayerId2\"L\n\x1aCDOTAUserMsg_DuelReques\
    ted\x12.\n\x13player_id_requestor\x18\x01\x20\x01(\x05R\x11playerIdReque\
    stor\"\xe0\x01\n4CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled\
    \x12(\n\x10player_id_killer\x18\x01\x20\x02(\x05R\x0eplayerIdKiller\x12(\
    \n\x10player_id_target\x18\x02\x20\x02(\x05R\x0eplayerIdTarget\x12\x16\n\
    \x06points\x18\x03\x20\x02(\x05R\x06points\x12!\n\x0cpoints_total\x18\
    \x04\x20\x02(\x05R\x0bpointsTotal\x12\x19\n\x08last_hit\x18\x05\x20\x02(\
    \x08R\x07lastHit\"t\n#CDOTAUserMsg_PlayerDraftSuggestPick\x12\x1b\n\tpla\
    yer_id\x18\x01\x20\x01(\x05R\x08playerId\x120\n\x14suggestion_player_id\
    \x18\x02\x20\x01(\x05R\x12suggestionPlayerId\"\x88\x01\n\x1cCDOTAUserMsg\
    _PlayerDraftPick\x12*\n\x11player_id_captain\x18\x01\x20\x01(\x05R\x0fpl\
    ayerIdCaptain\x12(\n\x10player_id_target\x18\x02\x20\x01(\x05R\x0eplayer\
    IdTarget\x12\x12\n\x04team\x18\x03\x20\x01(\x05R\x04team*\xa4%\n\x11EDot\
    aUserMessages\x12\x1f\n\x1aDOTA_UM_AddUnitToSelection\x10\xd0\x03\x12\
    \x18\n\x13DOTA_UM_AIDebugLine\x10\xd1\x03\x12\x16\n\x11DOTA_UM_ChatEvent\
    \x10\xd2\x03\x12\x20\n\x1bDOTA_UM_CombatHeroPositions\x10\xd3\x03\x12\
    \x1a\n\x15DOTA_UM_CombatLogData\x10\xd4\x03\x12\x1e\n\x19DOTA_UM_CombatL\
    ogBulkData\x10\xd6\x03\x12#\n\x1eDOTA_UM_CreateLinearProjectile\x10\xd7\
    \x03\x12$\n\x1fDOTA_UM_DestroyLinearProjectile\x10\xd8\x03\x12%\n\x20DOT\
    A_UM_DodgeTrackingProjectiles\x10\xd9\x03\x12\x1d\n\x18DOTA_UM_GlobalLig\
    htColor\x10\xda\x03\x12!\n\x1cDOTA_UM_GlobalLightDirection\x10\xdb\x03\
    \x12\x1b\n\x16DOTA_UM_InvalidCommand\x10\xdc\x03\x12\x19\n\x14DOTA_UM_Lo\
    cationPing\x10\xdd\x03\x12\x14\n\x0fDOTA_UM_MapLine\x10\xde\x03\x12\x1c\
    \n\x17DOTA_UM_MiniKillCamInfo\x10\xdf\x03\x12\x1e\n\x19DOTA_UM_MinimapDe\
    bugPoint\x10\xe0\x03\x12\x19\n\x14DOTA_UM_MinimapEvent\x10\xe1\x03\x12\
    \x1d\n\x18DOTA_UM_NevermoreRequiem\x10\xe2\x03\x12\x1a\n\x15DOTA_UM_Over\
    headEvent\x10\xe3\x03\x12\x1f\n\x1aDOTA_UM_SetNextAutobuyItem\x10\xe4\
    \x03\x12\x1b\n\x16DOTA_UM_SharedCooldown\x10\xe5\x03\x12!\n\x1cDOTA_UM_S\
    pectatorPlayerClick\x10\xe6\x03\x12\x1c\n\x17DOTA_UM_TutorialTipInfo\x10\
    \xe7\x03\x12\x16\n\x11DOTA_UM_UnitEvent\x10\xe8\x03\x12\x1c\n\x17DOTA_UM\
    _ParticleManager\x10\xe9\x03\x12\x14\n\x0fDOTA_UM_BotChat\x10\xea\x03\
    \x12\x15\n\x10DOTA_UM_HudError\x10\xeb\x03\x12\x1a\n\x15DOTA_UM_ItemPurc\
    hased\x10\xec\x03\x12\x11\n\x0cDOTA_UM_Ping\x10\xed\x03\x12\x16\n\x11DOT\
    A_UM_ItemFound\x10\xee\x03\x12\"\n\x1dDOTA_UM_CharacterSpeakConcept\x10\
    \xef\x03\x12\x17\n\x12DOTA_UM_SwapVerify\x10\xf0\x03\x12\x16\n\x11DOTA_U\
    M_WorldLine\x10\xf1\x03\x12\x1b\n\x16DOTA_UM_TournamentDrop\x10\xf2\x03\
    \x12\x16\n\x11DOTA_UM_ItemAlert\x10\xf3\x03\x12\x1b\n\x16DOTA_UM_Hallowe\
    enDrops\x10\xf4\x03\x12\x16\n\x11DOTA_UM_ChatWheel\x10\xf5\x03\x12\x1d\n\
    \x18DOTA_UM_ReceivedXmasGift\x10\xf6\x03\x12\x20\n\x1bDOTA_UM_UpdateShar\
    edContent\x10\xf7\x03\x12\x1f\n\x1aDOTA_UM_TutorialRequestExp\x10\xf8\
    \x03\x12\x20\n\x1bDOTA_UM_TutorialPingMinimap\x10\xf9\x03\x12\"\n\x1dDOT\
    A_UM_GamerulesStateChanged\x10\xfa\x03\x12\x17\n\x12DOTA_UM_ShowSurvey\
    \x10\xfb\x03\x12\x19\n\x14DOTA_UM_TutorialFade\x10\xfc\x03\x12\x1d\n\x18\
    DOTA_UM_AddQuestLogEntry\x10\xfd\x03\x12\x1a\n\x15DOTA_UM_SendStatPopup\
    \x10\xfe\x03\x12\x1b\n\x16DOTA_UM_TutorialFinish\x10\xff\x03\x12\x1c\n\
    \x17DOTA_UM_SendRoshanPopup\x10\x80\x04\x12\x1f\n\x1aDOTA_UM_SendGeneric\
    ToolTip\x10\x81\x04\x12\x1a\n\x15DOTA_UM_SendFinalGold\x10\x82\x04\x12\
    \x16\n\x11DOTA_UM_CustomMsg\x10\x83\x04\x12\x19\n\x14DOTA_UM_CoachHUDPin\
    g\x10\x84\x04\x12\x1e\n\x19DOTA_UM_ClientLoadGridNav\x10\x85\x04\x12\x1a\
    \n\x15DOTA_UM_TE_Projectile\x10\x86\x04\x12\x1d\n\x18DOTA_UM_TE_Projecti\
    leLoc\x10\x87\x04\x12\x1f\n\x1aDOTA_UM_TE_DotaBloodImpact\x10\x88\x04\
    \x12\x1d\n\x18DOTA_UM_TE_UnitAnimation\x10\x89\x04\x12\x20\n\x1bDOTA_UM_\
    TE_UnitAnimationEnd\x10\x8a\x04\x12\x18\n\x13DOTA_UM_AbilityPing\x10\x8b\
    \x04\x12\x1d\n\x18DOTA_UM_ShowGenericPopup\x10\x8c\x04\x12\x16\n\x11DOTA\
    _UM_VoteStart\x10\x8d\x04\x12\x17\n\x12DOTA_UM_VoteUpdate\x10\x8e\x04\
    \x12\x14\n\x0fDOTA_UM_VoteEnd\x10\x8f\x04\x12\x19\n\x14DOTA_UM_BoosterSt\
    ate\x10\x90\x04\x12\x1e\n\x19DOTA_UM_WillPurchaseAlert\x10\x91\x04\x12$\
    \n\x1fDOTA_UM_TutorialMinimapPosition\x10\x92\x04\x12\x16\n\x11DOTA_UM_P\
    layerMMR\x10\x93\x04\x12\x19\n\x14DOTA_UM_AbilitySteal\x10\x94\x04\x12\
    \x1f\n\x1aDOTA_UM_CourierKilledAlert\x10\x95\x04\x12\x1b\n\x16DOTA_UM_En\
    emyItemAlert\x10\x96\x04\x12\x1e\n\x19DOTA_UM_StatsMatchDetails\x10\x97\
    \x04\x12\x16\n\x11DOTA_UM_MiniTaunt\x10\x98\x04\x12\x1e\n\x19DOTA_UM_Buy\
    BackStateAlert\x10\x99\x04\x12\x19\n\x14DOTA_UM_SpeechBubble\x10\x9a\x04\
    \x12\x20\n\x1bDOTA_UM_CustomHeaderMessage\x10\x9b\x04\x12\x1a\n\x15DOTA_\
    UM_QuickBuyAlert\x10\x9c\x04\x12\x1d\n\x18DOTA_UM_StatsHeroDetails\x10\
    \x9d\x04\x12\x1d\n\x18DOTA_UM_PredictionResult\x10\x9e\x04\x12\x1a\n\x15\
    DOTA_UM_ModifierAlert\x10\x9f\x04\x12\x18\n\x13DOTA_UM_HPManaAlert\x10\
    \xa0\x04\x12\x17\n\x12DOTA_UM_GlyphAlert\x10\xa1\x04\x12\x16\n\x11DOTA_U\
    M_BeastChat\x10\xa2\x04\x12&\n!DOTA_UM_SpectatorPlayerUnitOrders\x10\xa3\
    \x04\x12$\n\x1fDOTA_UM_CustomHudElement_Create\x10\xa4\x04\x12$\n\x1fDOT\
    A_UM_CustomHudElement_Modify\x10\xa5\x04\x12%\n\x20DOTA_UM_CustomHudElem\
    ent_Destroy\x10\xa6\x04\x12\x1c\n\x17DOTA_UM_CompendiumState\x10\xa7\x04\
    \x12\x1e\n\x19DOTA_UM_ProjectionAbility\x10\xa8\x04\x12\x1c\n\x17DOTA_UM\
    _ProjectionEvent\x10\xa9\x04\x12\x1e\n\x19DOTA_UM_CombatLogDataHLTV\x10\
    \xaa\x04\x12\x14\n\x0fDOTA_UM_XPAlert\x10\xab\x04\x12\x20\n\x1bDOTA_UM_U\
    pdateQuestProgress\x10\xac\x04\x12\x1a\n\x15DOTA_UM_MatchMetadata\x10\
    \xad\x04\x12\x19\n\x14DOTA_UM_MatchDetails\x10\xae\x04\x12\x18\n\x13DOTA\
    _UM_QuestStatus\x10\xaf\x04\x12\x1c\n\x17DOTA_UM_SuggestHeroPick\x10\xb0\
    \x04\x12\x1c\n\x17DOTA_UM_SuggestHeroRole\x10\xb1\x04\x12\x1f\n\x1aDOTA_\
    UM_KillcamDamageTaken\x10\xb2\x04\x12\x1e\n\x19DOTA_UM_SelectPenaltyGold\
    \x10\xb3\x04\x12\x1b\n\x16DOTA_UM_RollDiceResult\x10\xb4\x04\x12\x1b\n\
    \x16DOTA_UM_FlipCoinResult\x10\xb5\x04\x12#\n\x1eDOTA_UM_RequestItemSugg\
    estions\x10\xb6\x04\x12\x1f\n\x1aDOTA_UM_TeamCaptainChanged\x10\xb7\x04\
    \x12%\n\x20DOTA_UM_SendRoshanSpectatorPhase\x10\xb8\x04\x12\x1e\n\x19DOT\
    A_UM_ChatWheelCooldown\x10\xb9\x04\x12!\n\x1cDOTA_UM_DismissAllStatPopup\
    s\x10\xba\x04\x12!\n\x1cDOTA_UM_TE_DestroyProjectile\x10\xbb\x04\x12\x1e\
    \n\x19DOTA_UM_HeroRelicProgress\x10\xbc\x04\x12'\n\"DOTA_UM_AbilityDraft\
    RequestAbility\x10\xbd\x04\x12\x15\n\x10DOTA_UM_ItemSold\x10\xbe\x04\x12\
    \x19\n\x14DOTA_UM_DamageReport\x10\xbf\x04\x12\x19\n\x14DOTA_UM_SalutePl\
    ayer\x10\xc0\x04\x12\x15\n\x10DOTA_UM_TipAlert\x10\xc1\x04\x12\x1d\n\x18\
    DOTA_UM_ReplaceQueryUnit\x10\xc2\x04\x12\x1f\n\x1aDOTA_UM_EmptyTeleportA\
    lert\x10\xc3\x04\x12#\n\x1eDOTA_UM_MarsArenaOfBloodAttack\x10\xc4\x04\
    \x12\x1a\n\x15DOTA_UM_ESArcanaCombo\x10\xc5\x04\x12!\n\x1cDOTA_UM_ESArca\
    naComboSummary\x10\xc6\x04\x12\x20\n\x1bDOTA_UM_HighFiveLeftHanging\x10\
    \xc7\x04\x12\x1e\n\x19DOTA_UM_HighFiveCompleted\x10\xc8\x04\x12\x1a\n\
    \x15DOTA_UM_ShovelUnearth\x10\xc9\x04\x12\x1d\n\x18DOTA_EM_InvokerSpellC\
    ast\x10\xca\x04\x12\x17\n\x12DOTA_UM_RadarAlert\x10\xcb\x04\x12\x19\n\
    \x14DOTA_UM_AllStarEvent\x10\xcc\x04\x12\x1c\n\x17DOTA_UM_TalentTreeAler\
    t\x10\xcd\x04\x12\x1f\n\x1aDOTA_UM_QueuedOrderRemoved\x10\xce\x04\x12\
    \x1b\n\x16DOTA_UM_DebugChallenge\x10\xcf\x04\x12\x1a\n\x15DOTA_UM_OMArca\
    naCombo\x10\xd0\x04\x12\x1d\n\x18DOTA_UM_FoundNeutralItem\x10\xd1\x04\
    \x12\x1c\n\x17DOTA_UM_OutpostCaptured\x10\xd2\x04\x12\x1d\n\x18DOTA_UM_O\
    utpostGrantedXP\x10\xd3\x04\x12\x1d\n\x18DOTA_UM_MoveCameraToUnit\x10\
    \xd4\x04\x12\x1e\n\x19DOTA_UM_PauseMinigameData\x10\xd5\x04\x12'\n\"DOTA\
    _UM_VersusScene_PlayerBehavior\x10\xd6\x04\x12\x1e\n\x19DOTA_UM_QoP_Arca\
    naSummary\x10\xd8\x04\x12\x1e\n\x19DOTA_UM_HotPotato_Created\x10\xd9\x04\
    \x12\x1f\n\x1aDOTA_UM_HotPotato_Exploded\x10\xda\x04\x12\x1f\n\x1aDOTA_U\
    M_WK_Arcana_Progress\x10\xdb\x04\x12$\n\x1fDOTA_UM_GuildChallenge_Progre\
    ss\x10\xdc\x04\x12\x1d\n\x18DOTA_UM_WRArcanaProgress\x10\xdd\x04\x12\x1c\
    \n\x17DOTA_UM_WRArcanaSummary\x10\xde\x04\x12\x1f\n\x1aDOTA_UM_EmptyItem\
    SlotAlert\x10\xdf\x04\x12\x1c\n\x17DOTA_UM_AghsStatusAlert\x10\xe0\x04\
    \x12\x1d\n\x18DOTA_UM_PingConfirmation\x10\xe1\x04\x12\x19\n\x14DOTA_UM_\
    MutedPlayers\x10\xe2\x04\x12\x1a\n\x15DOTA_UM_ContextualTip\x10\xe3\x04\
    \x12\x18\n\x13DOTA_UM_ChatMessage\x10\xe4\x04\x12\x1d\n\x18DOTA_UM_Neutr\
    alCampAlert\x10\xe5\x04\x12%\n\x20DOTA_UM_RockPaperScissorsStarted\x10\
    \xe6\x04\x12&\n!DOTA_UM_RockPaperScissorsFinished\x10\xe7\x04\x12\x1f\n\
    \x1aDOTA_UM_DuelOpponentKilled\x10\xe8\x04\x12\x19\n\x14DOTA_UM_DuelAcce\
    pted\x10\xe9\x04\x12\x1a\n\x15DOTA_UM_DuelRequested\x10\xea\x04\x124\n/D\
    OTA_UM_MuertaReleaseEvent_AssignedTargetKilled\x10\xeb\x04\x12#\n\x1eDOT\
    A_UM_PlayerDraftSuggestPick\x10\xec\x04\x12\x1c\n\x17DOTA_UM_PlayerDraft\
    Pick\x10\xed\x04*\xb9\x1e\n\x11DOTA_CHAT_MESSAGE\x12!\n\x14CHAT_MESSAGE_\
    INVALID\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x1a\n\x16CHAT_ME\
    SSAGE_HERO_KILL\x10\0\x12\x1a\n\x16CHAT_MESSAGE_HERO_DENY\x10\x01\x12\
    \x1e\n\x1aCHAT_MESSAGE_BARRACKS_KILL\x10\x02\x12\x1b\n\x17CHAT_MESSAGE_T\
    OWER_KILL\x10\x03\x12\x1b\n\x17CHAT_MESSAGE_TOWER_DENY\x10\x04\x12\x1b\n\
    \x17CHAT_MESSAGE_FIRSTBLOOD\x10\x05\x12\x1c\n\x18CHAT_MESSAGE_STREAK_KIL\
    L\x10\x06\x12\x18\n\x14CHAT_MESSAGE_BUYBACK\x10\x07\x12\x16\n\x12CHAT_ME\
    SSAGE_AEGIS\x10\x08\x12\x1c\n\x18CHAT_MESSAGE_ROSHAN_KILL\x10\t\x12\x1d\
    \n\x19CHAT_MESSAGE_COURIER_LOST\x10\n\x12\"\n\x1eCHAT_MESSAGE_COURIER_RE\
    SPAWNED\x10\x0b\x12\x1b\n\x17CHAT_MESSAGE_GLYPH_USED\x10\x0c\x12\x1e\n\
    \x1aCHAT_MESSAGE_ITEM_PURCHASE\x10\r\x12\x18\n\x14CHAT_MESSAGE_CONNECT\
    \x10\x0e\x12\x1b\n\x17CHAT_MESSAGE_DISCONNECT\x10\x0f\x12.\n*CHAT_MESSAG\
    E_DISCONNECT_WAIT_FOR_RECONNECT\x10\x10\x12*\n&CHAT_MESSAGE_DISCONNECT_T\
    IME_REMAINING\x10\x11\x121\n-CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLUR\
    AL\x10\x12\x12\x1a\n\x16CHAT_MESSAGE_RECONNECT\x10\x13\x12\x1c\n\x18CHAT\
    _MESSAGE_PLAYER_LEFT\x10\x14\x12\x1e\n\x1aCHAT_MESSAGE_SAFE_TO_LEAVE\x10\
    \x15\x12\x1c\n\x18CHAT_MESSAGE_RUNE_PICKUP\x10\x16\x12\x1c\n\x18CHAT_MES\
    SAGE_RUNE_BOTTLE\x10\x17\x12\x1a\n\x16CHAT_MESSAGE_RUNE_DENY\x10r\x12\
    \x19\n\x15CHAT_MESSAGE_INTHEBAG\x10\x18\x12\x1b\n\x17CHAT_MESSAGE_SECRET\
    SHOP\x10\x19\x12#\n\x1fCHAT_MESSAGE_ITEM_AUTOPURCHASED\x10\x1a\x12\x1f\n\
    \x1bCHAT_MESSAGE_ITEMS_COMBINED\x10\x1b\x12\x1d\n\x19CHAT_MESSAGE_SUPER_\
    CREEPS\x10\x1c\x12%\n!CHAT_MESSAGE_CANT_USE_ACTION_ITEM\x10\x1d\x12\x1a\
    \n\x16CHAT_MESSAGE_CANTPAUSE\x10\x1f\x12\x1d\n\x19CHAT_MESSAGE_NOPAUSESL\
    EFT\x10\x20\x12\x1d\n\x19CHAT_MESSAGE_CANTPAUSEYET\x10!\x12\x17\n\x13CHA\
    T_MESSAGE_PAUSED\x10\"\x12\"\n\x1eCHAT_MESSAGE_UNPAUSE_COUNTDOWN\x10#\
    \x12\x19\n\x15CHAT_MESSAGE_UNPAUSED\x10$\x12\x1e\n\x1aCHAT_MESSAGE_AUTO_\
    UNPAUSED\x10%\x12\x1a\n\x16CHAT_MESSAGE_YOUPAUSED\x10&\x12\x20\n\x1cCHAT\
    _MESSAGE_CANTUNPAUSETEAM\x10'\x12\"\n\x1eCHAT_MESSAGE_VOICE_TEXT_BANNED\
    \x10)\x12.\n*CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME\x10*\x12\x20\n\
    \x1cCHAT_MESSAGE_REPORT_REMINDER\x10+\x12\x1a\n\x16CHAT_MESSAGE_ECON_ITE\
    M\x10,\x12\x16\n\x12CHAT_MESSAGE_TAUNT\x10-\x12\x17\n\x13CHAT_MESSAGE_RA\
    NDOM\x10.\x12\x18\n\x14CHAT_MESSAGE_RD_TURN\x10/\x12\x20\n\x1cCHAT_MESSA\
    GE_DROP_RATE_BONUS\x101\x12!\n\x1dCHAT_MESSAGE_NO_BATTLE_POINTS\x102\x12\
    \x1d\n\x19CHAT_MESSAGE_DENIED_AEGIS\x103\x12\x1e\n\x1aCHAT_MESSAGE_INFOR\
    MATIONAL\x104\x12\x1d\n\x19CHAT_MESSAGE_AEGIS_STOLEN\x105\x12\x1d\n\x19C\
    HAT_MESSAGE_ROSHAN_CANDY\x106\x12\x1c\n\x18CHAT_MESSAGE_ITEM_GIFTED\x107\
    \x12'\n#CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL\x108\x12(\n$CHAT_MESSAGE_HOL\
    DOUT_TOWER_DESTROYED\x109\x12'\n#CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED\x10\
    :\x12&\n\"CHAT_MESSAGE_HOLDOUT_WALL_FINISHED\x10;\x12)\n%CHAT_MESSAGE_PL\
    AYER_LEFT_LIMITED_HERO\x10>\x121\n-CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXP\
    LANATION\x10?\x12(\n$CHAT_MESSAGE_DISCONNECT_LIMITED_HERO\x10@\x123\n/CH\
    AT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION\x10A\x12,\n(CHAT_MESSAGE_R\
    ECRUITMENT_DROP_RATE_BONUS\x10B\x121\n-CHAT_MESSAGE_FROSTIVUS_SHINING_BO\
    OSTER_ACTIVE\x10C\x12\x20\n\x1cCHAT_MESSAGE_PLAYER_LEFT_AFK\x10I\x122\n.\
    CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG\x10J\x12!\n\x1dCHAT_MESSA\
    GE_PLAYER_ABANDONED\x10K\x12%\n!CHAT_MESSAGE_PLAYER_ABANDONED_AFK\x10L\
    \x127\n3CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG\x10M\x12#\n\
    \x1fCHAT_MESSAGE_WILL_NOT_BE_SCORED\x10N\x12*\n&CHAT_MESSAGE_WILL_NOT_BE\
    _SCORED_RANKED\x10O\x12+\n'CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK\x10P\
    \x122\n.CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED\x10Q\x12)\n%CHAT_\
    MESSAGE_CAN_QUIT_WITHOUT_ABANDON\x10R\x12:\n6CHAT_MESSAGE_RANKED_GAME_ST\
    ILL_SCORED_LEAVERS_GET_LOSS\x10S\x128\n4CHAT_MESSAGE_ABANDON_RANKED_BEFO\
    RE_FIRST_BLOOD_PARTY\x10T\x12!\n\x1dCHAT_MESSAGE_COMPENDIUM_LEVEL\x10U\
    \x12*\n&CHAT_MESSAGE_VICTORY_PREDICTION_STREAK\x10V\x12\"\n\x1eCHAT_MESS\
    AGE_ASSASSIN_ANNOUNCE\x10W\x12!\n\x1dCHAT_MESSAGE_ASSASSIN_SUCCESS\x10X\
    \x12\x20\n\x1cCHAT_MESSAGE_ASSASSIN_DENIED\x10Y\x127\n3CHAT_MESSAGE_VICT\
    ORY_PREDICTION_SINGLE_USER_CONFIRM\x10Z\x12\x1c\n\x18CHAT_MESSAGE_EFFIGY\
    _KILL\x10[\x12+\n'CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW\x10\\\x12\"\n\
    \x1eCHAT_MESSAGE_YEAR_BEAST_KILLED\x10]\x12\x20\n\x1cCHAT_MESSAGE_PAUSE_\
    COUNTDOWN\x10^\x12\x1e\n\x1aCHAT_MESSAGE_COINS_WAGERED\x10_\x12#\n\x1fCH\
    AT_MESSAGE_HERO_NOMINATED_BAN\x10`\x12\x1c\n\x18CHAT_MESSAGE_HERO_BANNED\
    \x10a\x12\x1f\n\x1bCHAT_MESSAGE_HERO_BAN_COUNT\x10b\x12\x1e\n\x1aCHAT_ME\
    SSAGE_RIVER_PAINTED\x10c\x12\x1a\n\x16CHAT_MESSAGE_SCAN_USED\x10d\x12\
    \x1e\n\x1aCHAT_MESSAGE_SHRINE_KILLED\x10e\x12\"\n\x1eCHAT_MESSAGE_WAGER_\
    TOKEN_SPENT\x10f\x12\x1b\n\x17CHAT_MESSAGE_RANK_WAGER\x10g\x12$\n\x20CHA\
    T_MESSAGE_NEW_PLAYER_REMINDER\x10h\x12%\n!CHAT_MESSAGE_OBSERVER_WARD_KIL\
    LED\x10i\x12#\n\x1fCHAT_MESSAGE_SENTRY_WARD_KILLED\x10j\x12-\n)CHAT_MESS\
    AGE_ITEM_PLACED_IN_NEUTRAL_STASH\x10k\x12$\n\x20CHAT_MESSAGE_HERO_CHOICE\
    _INVALID\x10l\x12\x17\n\x13CHAT_MESSAGE_BOUNTY\x10m\x12$\n\x20CHAT_MESSA\
    GE_ABILITY_DRAFT_START\x10n\x12!\n\x1dCHAT_MESSAGE_HERO_FOUND_CANDY\x10o\
    \x12'\n#CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED\x10p\x12(\n$CHAT_MESSAGE_PRI\
    VATE_COACH_CONNECTED\x10q\x12%\n!CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY\x10s\
    \x12'\n#CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN\x10t*\xb2\x01\n\x1dDOTA_NO_B\
    ATTLE_POINTS_REASONS\x12%\n!NO_BATTLE_POINTS_WRONG_LOBBY_TYPE\x10\x01\
    \x12\"\n\x1eNO_BATTLE_POINTS_PRACTICE_BOTS\x10\x02\x12#\n\x1fNO_BATTLE_P\
    OINTS_CHEATS_ENABLED\x10\x03\x12!\n\x1dNO_BATTLE_POINTS_LOW_PRIORITY\x10\
    \x04*\xcf\x01\n\x17DOTA_CHAT_INFORMATIONAL\x12!\n\x1dINFO_COOP_BATTLE_PO\
    INTS_RULES\x10\x01\x12#\n\x1fINFO_FROSTIVUS_ABANDON_REMINDER\x10\x02\x12\
    \x18\n\x14INFO_RANKED_REMINDER\x10\x03\x12+\n'INFO_COOP_LOW_PRIORITY_PAS\
    SIVE_REMINDER\x10\x04\x12%\n!INFO_CUSTOM_GAME_PENALTY_REMINDER\x10\x05*\
    \xe0\x03\n\x16DOTA_ABILITY_PING_TYPE\x12\x16\n\x12ABILITY_PING_READY\x10\
    \x01\x12\x15\n\x11ABILITY_PING_MANA\x10\x02\x12\x19\n\x15ABILITY_PING_CO\
    OLDOWN\x10\x03\x12\x16\n\x12ABILITY_PING_ENEMY\x10\x04\x12\x1a\n\x16ABIL\
    ITY_PING_UNLEARNED\x10\x05\x12\x1b\n\x17ABILITY_PING_INBACKPACK\x10\x06\
    \x12\x18\n\x14ABILITY_PING_INSTASH\x10\x07\x12\x1a\n\x16ABILITY_PING_ONC\
    OURIER\x10\x08\x12\x15\n\x11ABILITY_PING_ALLY\x10\t\x12\x1c\n\x18ABILITY\
    _PING_LEARN_READY\x10\n\x12\x1b\n\x17ABILITY_PING_WILL_LEARN\x10\x0b\x12\
    \x1d\n\x19ABILITY_PING_FUTURE_LEARN\x10\x0c\x12\x1e\n\x1aABILITY_PING_NE\
    UTRAL_OFFER\x10\r\x12\x20\n\x1cABILITY_PING_NEUTRAL_REQUEST\x10\x0e\x12\
    \x1e\n\x1aABILITY_PING_NEUTRAL_EQUIP\x10\x0f\x12\"\n\x1eABILITY_PING_INC\
    OURIERBACKPACK\x10\x10*\x8c\x02\n\x17DOTA_REPLAY_STATE_EVENT\x12&\n\"DOT\
    A_REPLAY_STATE_EVENT_GAME_START\x10\x01\x12)\n%DOTA_REPLAY_STATE_EVENT_S\
    TARTING_HORN\x10\x02\x12'\n#DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD\x10\x03\
    \x12$\n\x20DOTA_REPLAY_STATE_EVENT_SHOWCASE\x10\x04\x12%\n!DOTA_REPLAY_S\
    TATE_EVENT_POST_GAME\x10\x05\x12(\n$DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP\
    \x10\x06*\xe5\x01\n\x13EDotaEntityMessages\x12\x14\n\x10DOTA_UNIT_SPEECH\
    \x10\0\x12\x19\n\x15DOTA_UNIT_SPEECH_MUTE\x10\x01\x12\x19\n\x15DOTA_UNIT\
    _ADD_GESTURE\x10\x02\x12\x1c\n\x18DOTA_UNIT_REMOVE_GESTURE\x10\x03\x12!\
    \n\x1dDOTA_UNIT_REMOVE_ALL_GESTURES\x10\x04\x12\x1a\n\x16DOTA_UNIT_FADE_\
    GESTURE\x10\x06\x12%\n!DOTA_UNIT_SPEECH_CLIENTSIDE_RULES\x10\x07*\x8d\
    \x06\n\x13DOTA_OVERHEAD_ALERT\x12\x17\n\x13OVERHEAD_ALERT_GOLD\x10\0\x12\
    \x17\n\x13OVERHEAD_ALERT_DENY\x10\x01\x12\x1b\n\x17OVERHEAD_ALERT_CRITIC\
    AL\x10\x02\x12\x15\n\x11OVERHEAD_ALERT_XP\x10\x03\x12%\n!OVERHEAD_ALERT_\
    BONUS_SPELL_DAMAGE\x10\x04\x12\x17\n\x13OVERHEAD_ALERT_MISS\x10\x05\x12\
    \x19\n\x15OVERHEAD_ALERT_DAMAGE\x10\x06\x12\x18\n\x14OVERHEAD_ALERT_EVAD\
    E\x10\x07\x12\x18\n\x14OVERHEAD_ALERT_BLOCK\x10\x08\x12&\n\"OVERHEAD_ALE\
    RT_BONUS_POISON_DAMAGE\x10\t\x12\x17\n\x13OVERHEAD_ALERT_HEAL\x10\n\x12\
    \x1b\n\x17OVERHEAD_ALERT_MANA_ADD\x10\x0b\x12\x1c\n\x18OVERHEAD_ALERT_MA\
    NA_LOSS\x10\x0c\x12!\n\x1dOVERHEAD_ALERT_LAST_HIT_EARLY\x10\r\x12!\n\x1d\
    OVERHEAD_ALERT_LAST_HIT_CLOSE\x10\x0e\x12\x20\n\x1cOVERHEAD_ALERT_LAST_H\
    IT_MISS\x10\x0f\x12\x20\n\x1cOVERHEAD_ALERT_MAGICAL_BLOCK\x10\x10\x12\"\
    \n\x1eOVERHEAD_ALERT_INCOMING_DAMAGE\x10\x11\x12\"\n\x1eOVERHEAD_ALERT_O\
    UTGOING_DAMAGE\x10\x12\x12!\n\x1dOVERHEAD_ALERT_DISABLE_RESIST\x10\x13\
    \x12\x18\n\x14OVERHEAD_ALERT_DEATH\x10\x14\x12\x1a\n\x16OVERHEAD_ALERT_B\
    LOCKED\x10\x15\x12\x20\n\x1cOVERHEAD_ALERT_ITEM_RECEIVED\x10\x16\x12\x18\
    \n\x14OVERHEAD_ALERT_SHARD\x10\x17\x12\x1e\n\x1aOVERHEAD_ALERT_DEADLY_BL\
    OW\x10\x18*k\n\x11DOTA_ROSHAN_PHASE\x12\x17\n\x13k_SRSP_ROSHAN_ALIVE\x10\
    \0\x12\x1c\n\x18k_SRSP_ROSHAN_BASE_TIMER\x10\x01\x12\x1f\n\x1bk_SRSP_ROS\
    HAN_VISIBLE_TIMER\x10\x02*\x81\x04\n\x16DOTA_POSITION_CATEGORY\x12\x16\n\
    \x12DOTA_POSITION_NONE\x10\0\x12\x1d\n\x19DOTA_POSITION_BOTTOM_LANE\x10\
    \x01\x12\x1a\n\x16DOTA_POSITION_MID_LANE\x10\x02\x12\x1a\n\x16DOTA_POSIT\
    ION_TOP_LANE\x10\x03\x12\x20\n\x1cDOTA_POSITION_RADIANT_JUNGLE\x10\x04\
    \x12\x1d\n\x19DOTA_POSITION_DIRE_JUNGLE\x10\x05\x12\"\n\x1eDOTA_POSITION\
    _RADIANT_ANCIENTS\x10\x06\x12\x1f\n\x1bDOTA_POSITION_DIRE_ANCIENTS\x10\
    \x07\x12%\n!DOTA_POSITION_RADIANT_SECRET_SHOP\x10\x08\x12\"\n\x1eDOTA_PO\
    SITION_DIRE_SECRET_SHOP\x10\t\x12\x17\n\x13DOTA_POSITION_RIVER\x10\n\x12\
    \x1c\n\x18DOTA_POSITION_ROSHAN_PIT\x10\x0b\x12\x1e\n\x1aDOTA_POSITION_RA\
    DIANT_BASE\x10\x0c\x12\x1b\n\x17DOTA_POSITION_DIRE_BASE\x10\r\x12\x1a\n\
    \x16DOTA_POSITION_FOUNTAIN\x10\x0e\x12\x17\n\x13DOTA_POSITION_OTHER\x10\
    \x0f*\xe6\x01\n\x18DOTA_ABILITY_TARGET_TYPE\x12\x1c\n\x18DOTA_ABILITY_TA\
    RGET_NONE\x10\0\x12\x1c\n\x18DOTA_ABILITY_TARGET_SELF\x10\x01\x12!\n\x1d\
    DOTA_ABILITY_TARGET_ALLY_HERO\x10\x02\x12\"\n\x1eDOTA_ABILITY_TARGET_ALL\
    Y_CREEP\x10\x03\x12\"\n\x1eDOTA_ABILITY_TARGET_ENEMY_HERO\x10\x04\x12#\n\
    \x1fDOTA_ABILITY_TARGET_ENEMY_CREEP\x10\x05*\x98\x08\n\rEHeroStatType\
    \x12\x18\n\x14k_EHeroStatType_None\x10\0\x12#\n\x1ek_EHeroStatType_AxeTo\
    talDamage\x10\xd0\x0f\x12'\n\"k_EHeroStatType_BattleHungerDamage\x10\xd1\
    \x0f\x12'\n\"k_EHeroStatType_CounterHelixDamage\x10\xd2\x0f\x12'\n\"k_EH\
    eroStatType_CullingBladeDamage\x10\xd3\x0f\x12,\n'k_EHeroStatType_Berser\
    kersCallCastCount\x10\xd4\x0f\x123\n.k_EHeroStatType_BerserkersCallHeroe\
    sHitAverage\x10\xd5\x0f\x120\n+k_EHeroStatType_BerserkersCallOtherUnitsH\
    it\x10\xd6\x0f\x123\n.k_EHeroStatType_BerserkersCallHeroAttacksTaken\x10\
    \xd7\x0f\x124\n/k_EHeroStatType_BerserkersCallOtherAttacksTaken\x10\xd8\
    \x0f\x12*\n%k_EHeroStatType_BattleHungerCastCount\x10\xd9\x0f\x122\n-k_E\
    HeroStatType_BattleHungerPotentialDuration\x10\xda\x0f\x120\n+k_EHeroSta\
    tType_BattleHungerAverageDuration\x10\xdb\x0f\x12*\n%k_EHeroStatType_Cou\
    nterHelixProcCount\x10\xdc\x0f\x12.\n)k_EHeroStatType_CounterHelixHeroPr\
    ocCount\x10\xdd\x0f\x121\n,k_EHeroStatType_CounterHelixHeroesHitAverage\
    \x10\xde\x0f\x123\n.k_EHeroStatType_CounterHelixOtherUnitsHitCount\x10\
    \xdf\x0f\x12*\n%k_EHeroStatType_CullingBladeCastCount\x10\xe0\x0f\x12*\n\
    %k_EHeroStatType_CullingBladeKillCount\x10\xe1\x0f\x124\n/k_EHeroStatTyp\
    e_CullingBladeAverageHealthCulled\x10\xe2\x0f\x127\n2k_EHeroStatType_Cul\
    lingBladeAverageDamageAvailable\x10\xe3\x0f\x120\n+k_EHeroStatType_Culli\
    ngBladeHeroBuffAverage\x10\xe4\x0f*\xe4\x04\n\x17EPlayerVoiceListenState\
    \x12\x0e\n\nkPVLS_None\x10\0\x12\x1a\n\x16kPVLS_DeniedChatBanned\x10\x01\
    \x12\x17\n\x13kPVLS_DeniedPartner\x10\x02\x12&\n\"kPVLS_DeniedHLTVTalker\
    NotSpectator\x10\x03\x12$\n\x20kPVLS_DeniedHLTVNoTalkerPlayerID\x10\x04\
    \x12(\n$kPVLS_DeniedHLTVTalkerNotBroadcaster\x10\x05\x12\x1d\n\x19kPVLS_\
    DeniedTeamSpectator\x10\x06\x12\x17\n\x13kPVLS_DeniedStudent\x10\x08\x12\
    \x1c\n\x18kPVLS_DeniedPrivateCoach\x10\t\x12\x10\n\x0ckPVLS_Denied\x10@\
    \x12&\n\"kPVLS_AllowHLTVTalkerIsBroadcaster\x10A\x12\x1c\n\x18kPVLS_Allo\
    wCoBroadcaster\x10B\x12\x16\n\x12kPVLS_AllowAllChat\x10C\x12\x1d\n\x19kP\
    VLS_AllowStudentToCoach\x10D\x12\x1c\n\x18kPVLS_AllowFellowStudent\x10E\
    \x12\x1c\n\x18kPVLS_AllowTalkerIsCoach\x10F\x12\x1c\n\x18kPVLS_AllowCoac\
    hHearTeam\x10G\x12\x17\n\x13kPVLS_AllowSameTeam\x10H\x12\x17\n\x13kPVLS_\
    AllowShowcase\x10I\x12\x1b\n\x17kPVLS_AllowPrivateCoach\x10J*B\n\x10EPro\
    jectionEvent\x12\x12\n\x0eePE_FirstBlood\x10\0\x12\x1a\n\x16ePE_Killstre\
    ak_godlike\x10\x01B%Z#github.com/dotabuff/manta/dota;dotaJ\x8c\xb7\x04\n\
    \x07\x12\x05\0\0\xf5\x0c\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\
    \x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\
    \x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1f\n\t\n\x02\x03\
    \x01\x12\x03\x06\x07\x20\n\t\n\x02\x03\x02\x12\x03\x07\x07\"\n\x0b\n\x02\
    \x05\0\x12\x05\t\0\xa6\x01\x01\n\n\n\x03\x05\0\x01\x12\x03\t\x05\x16\n\
    \x0b\n\x04\x05\0\x02\0\x12\x03\n\x08)\n\x0c\n\x05\x05\0\x02\0\x01\x12\
    \x03\n\x08\"\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\n%(\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\x0b\x08\"\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x0b\x08\
    \x1b\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x0b\x1e!\n\x0b\n\x04\x05\0\
    \x02\x02\x12\x03\x0c\x08\x20\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x0c\
    \x08\x19\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x0c\x1c\x1f\n\x0b\n\x04\
    \x05\0\x02\x03\x12\x03\r\x08*\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\r\
    \x08#\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\r&)\n\x0b\n\x04\x05\0\x02\
    \x04\x12\x03\x0e\x08$\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x0e\x08\x1d\
    \n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0e\x20#\n\x0b\n\x04\x05\0\x02\
    \x05\x12\x03\x0f\x08(\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0f\x08!\n\
    \x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0f$'\n\x0b\n\x04\x05\0\x02\x06\x12\
    \x03\x10\x08-\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x10\x08&\n\x0c\n\x05\
    \x05\0\x02\x06\x02\x12\x03\x10),\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x11\
    \x08.\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x11\x08'\n\x0c\n\x05\x05\0\
    \x02\x07\x02\x12\x03\x11*-\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x12\x08/\n\
    \x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x12\x08(\n\x0c\n\x05\x05\0\x02\x08\
    \x02\x12\x03\x12+.\n\x0b\n\x04\x05\0\x02\t\x12\x03\x13\x08'\n\x0c\n\x05\
    \x05\0\x02\t\x01\x12\x03\x13\x08\x20\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\
    \x13#&\n\x0b\n\x04\x05\0\x02\n\x12\x03\x14\x08+\n\x0c\n\x05\x05\0\x02\n\
    \x01\x12\x03\x14\x08$\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x14'*\n\x0b\n\
    \x04\x05\0\x02\x0b\x12\x03\x15\x08%\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\
    \x03\x15\x08\x1e\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x15!$\n\x0b\n\x04\
    \x05\0\x02\x0c\x12\x03\x16\x08#\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\
    \x16\x08\x1c\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x16\x1f\"\n\x0b\n\x04\
    \x05\0\x02\r\x12\x03\x17\x08\x1e\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x17\
    \x08\x17\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x17\x1a\x1d\n\x0b\n\x04\x05\
    \0\x02\x0e\x12\x03\x18\x08&\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x18\
    \x08\x1f\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x18\"%\n\x0b\n\x04\x05\0\
    \x02\x0f\x12\x03\x19\x08(\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\x19\x08!\
    \n\x0c\n\x05\x05\0\x02\x0f\x02\x12\x03\x19$'\n\x0b\n\x04\x05\0\x02\x10\
    \x12\x03\x1a\x08#\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\x1a\x08\x1c\n\
    \x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x1a\x1f\"\n\x0b\n\x04\x05\0\x02\x11\
    \x12\x03\x1b\x08'\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x1b\x08\x20\n\
    \x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x1b#&\n\x0b\n\x04\x05\0\x02\x12\x12\
    \x03\x1c\x08$\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03\x1c\x08\x1d\n\x0c\n\
    \x05\x05\0\x02\x12\x02\x12\x03\x1c\x20#\n\x0b\n\x04\x05\0\x02\x13\x12\
    \x03\x1d\x08)\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\x1d\x08\"\n\x0c\n\
    \x05\x05\0\x02\x13\x02\x12\x03\x1d%(\n\x0b\n\x04\x05\0\x02\x14\x12\x03\
    \x1e\x08%\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1e\x08\x1e\n\x0c\n\x05\
    \x05\0\x02\x14\x02\x12\x03\x1e!$\n\x0b\n\x04\x05\0\x02\x15\x12\x03\x1f\
    \x08+\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\x1f\x08$\n\x0c\n\x05\x05\0\
    \x02\x15\x02\x12\x03\x1f'*\n\x0b\n\x04\x05\0\x02\x16\x12\x03\x20\x08&\n\
    \x0c\n\x05\x05\0\x02\x16\x01\x12\x03\x20\x08\x1f\n\x0c\n\x05\x05\0\x02\
    \x16\x02\x12\x03\x20\"%\n\x0b\n\x04\x05\0\x02\x17\x12\x03!\x08\x20\n\x0c\
    \n\x05\x05\0\x02\x17\x01\x12\x03!\x08\x19\n\x0c\n\x05\x05\0\x02\x17\x02\
    \x12\x03!\x1c\x1f\n\x0b\n\x04\x05\0\x02\x18\x12\x03\"\x08&\n\x0c\n\x05\
    \x05\0\x02\x18\x01\x12\x03\"\x08\x1f\n\x0c\n\x05\x05\0\x02\x18\x02\x12\
    \x03\"\"%\n\x0b\n\x04\x05\0\x02\x19\x12\x03#\x08\x1e\n\x0c\n\x05\x05\0\
    \x02\x19\x01\x12\x03#\x08\x17\n\x0c\n\x05\x05\0\x02\x19\x02\x12\x03#\x1a\
    \x1d\n\x0b\n\x04\x05\0\x02\x1a\x12\x03$\x08\x1f\n\x0c\n\x05\x05\0\x02\
    \x1a\x01\x12\x03$\x08\x18\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\x03$\x1b\x1e\
    \n\x0b\n\x04\x05\0\x02\x1b\x12\x03%\x08$\n\x0c\n\x05\x05\0\x02\x1b\x01\
    \x12\x03%\x08\x1d\n\x0c\n\x05\x05\0\x02\x1b\x02\x12\x03%\x20#\n\x0b\n\
    \x04\x05\0\x02\x1c\x12\x03&\x08\x1b\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\
    \x03&\x08\x14\n\x0c\n\x05\x05\0\x02\x1c\x02\x12\x03&\x17\x1a\n\x0b\n\x04\
    \x05\0\x02\x1d\x12\x03'\x08\x20\n\x0c\n\x05\x05\0\x02\x1d\x01\x12\x03'\
    \x08\x19\n\x0c\n\x05\x05\0\x02\x1d\x02\x12\x03'\x1c\x1f\n\x0b\n\x04\x05\
    \0\x02\x1e\x12\x03(\x08,\n\x0c\n\x05\x05\0\x02\x1e\x01\x12\x03(\x08%\n\
    \x0c\n\x05\x05\0\x02\x1e\x02\x12\x03((+\n\x0b\n\x04\x05\0\x02\x1f\x12\
    \x03)\x08!\n\x0c\n\x05\x05\0\x02\x1f\x01\x12\x03)\x08\x1a\n\x0c\n\x05\
    \x05\0\x02\x1f\x02\x12\x03)\x1d\x20\n\x0b\n\x04\x05\0\x02\x20\x12\x03*\
    \x08\x20\n\x0c\n\x05\x05\0\x02\x20\x01\x12\x03*\x08\x19\n\x0c\n\x05\x05\
    \0\x02\x20\x02\x12\x03*\x1c\x1f\n\x0b\n\x04\x05\0\x02!\x12\x03+\x08%\n\
    \x0c\n\x05\x05\0\x02!\x01\x12\x03+\x08\x1e\n\x0c\n\x05\x05\0\x02!\x02\
    \x12\x03+!$\n\x0b\n\x04\x05\0\x02\"\x12\x03,\x08\x20\n\x0c\n\x05\x05\0\
    \x02\"\x01\x12\x03,\x08\x19\n\x0c\n\x05\x05\0\x02\"\x02\x12\x03,\x1c\x1f\
    \n\x0b\n\x04\x05\0\x02#\x12\x03-\x08%\n\x0c\n\x05\x05\0\x02#\x01\x12\x03\
    -\x08\x1e\n\x0c\n\x05\x05\0\x02#\x02\x12\x03-!$\n\x0b\n\x04\x05\0\x02$\
    \x12\x03.\x08\x20\n\x0c\n\x05\x05\0\x02$\x01\x12\x03.\x08\x19\n\x0c\n\
    \x05\x05\0\x02$\x02\x12\x03.\x1c\x1f\n\x0b\n\x04\x05\0\x02%\x12\x03/\x08\
    '\n\x0c\n\x05\x05\0\x02%\x01\x12\x03/\x08\x20\n\x0c\n\x05\x05\0\x02%\x02\
    \x12\x03/#&\n\x0b\n\x04\x05\0\x02&\x12\x030\x08*\n\x0c\n\x05\x05\0\x02&\
    \x01\x12\x030\x08#\n\x0c\n\x05\x05\0\x02&\x02\x12\x030&)\n\x0b\n\x04\x05\
    \0\x02'\x12\x031\x08)\n\x0c\n\x05\x05\0\x02'\x01\x12\x031\x08\"\n\x0c\n\
    \x05\x05\0\x02'\x02\x12\x031%(\n\x0b\n\x04\x05\0\x02(\x12\x032\x08*\n\
    \x0c\n\x05\x05\0\x02(\x01\x12\x032\x08#\n\x0c\n\x05\x05\0\x02(\x02\x12\
    \x032&)\n\x0b\n\x04\x05\0\x02)\x12\x033\x08,\n\x0c\n\x05\x05\0\x02)\x01\
    \x12\x033\x08%\n\x0c\n\x05\x05\0\x02)\x02\x12\x033(+\n\x0b\n\x04\x05\0\
    \x02*\x12\x034\x08!\n\x0c\n\x05\x05\0\x02*\x01\x12\x034\x08\x1a\n\x0c\n\
    \x05\x05\0\x02*\x02\x12\x034\x1d\x20\n\x0b\n\x04\x05\0\x02+\x12\x035\x08\
    #\n\x0c\n\x05\x05\0\x02+\x01\x12\x035\x08\x1c\n\x0c\n\x05\x05\0\x02+\x02\
    \x12\x035\x1f\"\n\x0b\n\x04\x05\0\x02,\x12\x036\x08'\n\x0c\n\x05\x05\0\
    \x02,\x01\x12\x036\x08\x20\n\x0c\n\x05\x05\0\x02,\x02\x12\x036#&\n\x0b\n\
    \x04\x05\0\x02-\x12\x037\x08$\n\x0c\n\x05\x05\0\x02-\x01\x12\x037\x08\
    \x1d\n\x0c\n\x05\x05\0\x02-\x02\x12\x037\x20#\n\x0b\n\x04\x05\0\x02.\x12\
    \x038\x08%\n\x0c\n\x05\x05\0\x02.\x01\x12\x038\x08\x1e\n\x0c\n\x05\x05\0\
    \x02.\x02\x12\x038!$\n\x0b\n\x04\x05\0\x02/\x12\x039\x08&\n\x0c\n\x05\
    \x05\0\x02/\x01\x12\x039\x08\x1f\n\x0c\n\x05\x05\0\x02/\x02\x12\x039\"%\
    \n\x0b\n\x04\x05\0\x020\x12\x03:\x08)\n\x0c\n\x05\x05\0\x020\x01\x12\x03\
    :\x08\"\n\x0c\n\x05\x05\0\x020\x02\x12\x03:%(\n\x0b\n\x04\x05\0\x021\x12\
    \x03;\x08$\n\x0c\n\x05\x05\0\x021\x01\x12\x03;\x08\x1d\n\x0c\n\x05\x05\0\
    \x021\x02\x12\x03;\x20#\n\x0b\n\x04\x05\0\x022\x12\x03<\x08\x20\n\x0c\n\
    \x05\x05\0\x022\x01\x12\x03<\x08\x19\n\x0c\n\x05\x05\0\x022\x02\x12\x03<\
    \x1c\x1f\n\x0b\n\x04\x05\0\x023\x12\x03=\x08#\n\x0c\n\x05\x05\0\x023\x01\
    \x12\x03=\x08\x1c\n\x0c\n\x05\x05\0\x023\x02\x12\x03=\x1f\"\n\x0b\n\x04\
    \x05\0\x024\x12\x03>\x08(\n\x0c\n\x05\x05\0\x024\x01\x12\x03>\x08!\n\x0c\
    \n\x05\x05\0\x024\x02\x12\x03>$'\n\x0b\n\x04\x05\0\x025\x12\x03?\x08$\n\
    \x0c\n\x05\x05\0\x025\x01\x12\x03?\x08\x1d\n\x0c\n\x05\x05\0\x025\x02\
    \x12\x03?\x20#\n\x0b\n\x04\x05\0\x026\x12\x03@\x08'\n\x0c\n\x05\x05\0\
    \x026\x01\x12\x03@\x08\x20\n\x0c\n\x05\x05\0\x026\x02\x12\x03@#&\n\x0b\n\
    \x04\x05\0\x027\x12\x03A\x08)\n\x0c\n\x05\x05\0\x027\x01\x12\x03A\x08\"\
    \n\x0c\n\x05\x05\0\x027\x02\x12\x03A%(\n\x0b\n\x04\x05\0\x028\x12\x03B\
    \x08'\n\x0c\n\x05\x05\0\x028\x01\x12\x03B\x08\x20\n\x0c\n\x05\x05\0\x028\
    \x02\x12\x03B#&\n\x0b\n\x04\x05\0\x029\x12\x03C\x08*\n\x0c\n\x05\x05\0\
    \x029\x01\x12\x03C\x08#\n\x0c\n\x05\x05\0\x029\x02\x12\x03C&)\n\x0b\n\
    \x04\x05\0\x02:\x12\x03D\x08\"\n\x0c\n\x05\x05\0\x02:\x01\x12\x03D\x08\
    \x1b\n\x0c\n\x05\x05\0\x02:\x02\x12\x03D\x1e!\n\x0b\n\x04\x05\0\x02;\x12\
    \x03E\x08'\n\x0c\n\x05\x05\0\x02;\x01\x12\x03E\x08\x20\n\x0c\n\x05\x05\0\
    \x02;\x02\x12\x03E#&\n\x0b\n\x04\x05\0\x02<\x12\x03F\x08\x20\n\x0c\n\x05\
    \x05\0\x02<\x01\x12\x03F\x08\x19\n\x0c\n\x05\x05\0\x02<\x02\x12\x03F\x1c\
    \x1f\n\x0b\n\x04\x05\0\x02=\x12\x03G\x08!\n\x0c\n\x05\x05\0\x02=\x01\x12\
    \x03G\x08\x1a\n\x0c\n\x05\x05\0\x02=\x02\x12\x03G\x1d\x20\n\x0b\n\x04\
    \x05\0\x02>\x12\x03H\x08\x1e\n\x0c\n\x05\x05\0\x02>\x01\x12\x03H\x08\x17\
    \n\x0c\n\x05\x05\0\x02>\x02\x12\x03H\x1a\x1d\n\x0b\n\x04\x05\0\x02?\x12\
    \x03I\x08#\n\x0c\n\x05\x05\0\x02?\x01\x12\x03I\x08\x1c\n\x0c\n\x05\x05\0\
    \x02?\x02\x12\x03I\x1f\"\n\x0b\n\x04\x05\0\x02@\x12\x03J\x08(\n\x0c\n\
    \x05\x05\0\x02@\x01\x12\x03J\x08!\n\x0c\n\x05\x05\0\x02@\x02\x12\x03J$'\
    \n\x0b\n\x04\x05\0\x02A\x12\x03K\x08.\n\x0c\n\x05\x05\0\x02A\x01\x12\x03\
    K\x08'\n\x0c\n\x05\x05\0\x02A\x02\x12\x03K*-\n\x0b\n\x04\x05\0\x02B\x12\
    \x03L\x08\x20\n\x0c\n\x05\x05\0\x02B\x01\x12\x03L\x08\x19\n\x0c\n\x05\
    \x05\0\x02B\x02\x12\x03L\x1c\x1f\n\x0b\n\x04\x05\0\x02C\x12\x03M\x08#\n\
    \x0c\n\x05\x05\0\x02C\x01\x12\x03M\x08\x1c\n\x0c\n\x05\x05\0\x02C\x02\
    \x12\x03M\x1f\"\n\x0b\n\x04\x05\0\x02D\x12\x03N\x08)\n\x0c\n\x05\x05\0\
    \x02D\x01\x12\x03N\x08\"\n\x0c\n\x05\x05\0\x02D\x02\x12\x03N%(\n\x0b\n\
    \x04\x05\0\x02E\x12\x03O\x08%\n\x0c\n\x05\x05\0\x02E\x01\x12\x03O\x08\
    \x1e\n\x0c\n\x05\x05\0\x02E\x02\x12\x03O!$\n\x0b\n\x04\x05\0\x02F\x12\
    \x03P\x08(\n\x0c\n\x05\x05\0\x02F\x01\x12\x03P\x08!\n\x0c\n\x05\x05\0\
    \x02F\x02\x12\x03P$'\n\x0b\n\x04\x05\0\x02G\x12\x03Q\x08\x20\n\x0c\n\x05\
    \x05\0\x02G\x01\x12\x03Q\x08\x19\n\x0c\n\x05\x05\0\x02G\x02\x12\x03Q\x1c\
    \x1f\n\x0b\n\x04\x05\0\x02H\x12\x03R\x08(\n\x0c\n\x05\x05\0\x02H\x01\x12\
    \x03R\x08!\n\x0c\n\x05\x05\0\x02H\x02\x12\x03R$'\n\x0b\n\x04\x05\0\x02I\
    \x12\x03S\x08#\n\x0c\n\x05\x05\0\x02I\x01\x12\x03S\x08\x1c\n\x0c\n\x05\
    \x05\0\x02I\x02\x12\x03S\x1f\"\n\x0b\n\x04\x05\0\x02J\x12\x03T\x08*\n\
    \x0c\n\x05\x05\0\x02J\x01\x12\x03T\x08#\n\x0c\n\x05\x05\0\x02J\x02\x12\
    \x03T&)\n\x0b\n\x04\x05\0\x02K\x12\x03U\x08$\n\x0c\n\x05\x05\0\x02K\x01\
    \x12\x03U\x08\x1d\n\x0c\n\x05\x05\0\x02K\x02\x12\x03U\x20#\n\x0b\n\x04\
    \x05\0\x02L\x12\x03V\x08'\n\x0c\n\x05\x05\0\x02L\x01\x12\x03V\x08\x20\n\
    \x0c\n\x05\x05\0\x02L\x02\x12\x03V#&\n\x0b\n\x04\x05\0\x02M\x12\x03W\x08\
    '\n\x0c\n\x05\x05\0\x02M\x01\x12\x03W\x08\x20\n\x0c\n\x05\x05\0\x02M\x02\
    \x12\x03W#&\n\x0b\n\x04\x05\0\x02N\x12\x03X\x08$\n\x0c\n\x05\x05\0\x02N\
    \x01\x12\x03X\x08\x1d\n\x0c\n\x05\x05\0\x02N\x02\x12\x03X\x20#\n\x0b\n\
    \x04\x05\0\x02O\x12\x03Y\x08\"\n\x0c\n\x05\x05\0\x02O\x01\x12\x03Y\x08\
    \x1b\n\x0c\n\x05\x05\0\x02O\x02\x12\x03Y\x1e!\n\x0b\n\x04\x05\0\x02P\x12\
    \x03Z\x08!\n\x0c\n\x05\x05\0\x02P\x01\x12\x03Z\x08\x1a\n\x0c\n\x05\x05\0\
    \x02P\x02\x12\x03Z\x1d\x20\n\x0b\n\x04\x05\0\x02Q\x12\x03[\x08\x20\n\x0c\
    \n\x05\x05\0\x02Q\x01\x12\x03[\x08\x19\n\x0c\n\x05\x05\0\x02Q\x02\x12\
    \x03[\x1c\x1f\n\x0b\n\x04\x05\0\x02R\x12\x03\\\x080\n\x0c\n\x05\x05\0\
    \x02R\x01\x12\x03\\\x08)\n\x0c\n\x05\x05\0\x02R\x02\x12\x03\\,/\n\x0b\n\
    \x04\x05\0\x02S\x12\x03]\x08.\n\x0c\n\x05\x05\0\x02S\x01\x12\x03]\x08'\n\
    \x0c\n\x05\x05\0\x02S\x02\x12\x03]*-\n\x0b\n\x04\x05\0\x02T\x12\x03^\x08\
    .\n\x0c\n\x05\x05\0\x02T\x01\x12\x03^\x08'\n\x0c\n\x05\x05\0\x02T\x02\
    \x12\x03^*-\n\x0b\n\x04\x05\0\x02U\x12\x03_\x08/\n\x0c\n\x05\x05\0\x02U\
    \x01\x12\x03_\x08(\n\x0c\n\x05\x05\0\x02U\x02\x12\x03_+.\n\x0b\n\x04\x05\
    \0\x02V\x12\x03`\x08&\n\x0c\n\x05\x05\0\x02V\x01\x12\x03`\x08\x1f\n\x0c\
    \n\x05\x05\0\x02V\x02\x12\x03`\"%\n\x0b\n\x04\x05\0\x02W\x12\x03a\x08(\n\
    \x0c\n\x05\x05\0\x02W\x01\x12\x03a\x08!\n\x0c\n\x05\x05\0\x02W\x02\x12\
    \x03a$'\n\x0b\n\x04\x05\0\x02X\x12\x03b\x08&\n\x0c\n\x05\x05\0\x02X\x01\
    \x12\x03b\x08\x1f\n\x0c\n\x05\x05\0\x02X\x02\x12\x03b\"%\n\x0b\n\x04\x05\
    \0\x02Y\x12\x03c\x08(\n\x0c\n\x05\x05\0\x02Y\x01\x12\x03c\x08!\n\x0c\n\
    \x05\x05\0\x02Y\x02\x12\x03c$'\n\x0b\n\x04\x05\0\x02Z\x12\x03d\x08\x1e\n\
    \x0c\n\x05\x05\0\x02Z\x01\x12\x03d\x08\x17\n\x0c\n\x05\x05\0\x02Z\x02\
    \x12\x03d\x1a\x1d\n\x0b\n\x04\x05\0\x02[\x12\x03e\x08*\n\x0c\n\x05\x05\0\
    \x02[\x01\x12\x03e\x08#\n\x0c\n\x05\x05\0\x02[\x02\x12\x03e&)\n\x0b\n\
    \x04\x05\0\x02\\\x12\x03f\x08$\n\x0c\n\x05\x05\0\x02\\\x01\x12\x03f\x08\
    \x1d\n\x0c\n\x05\x05\0\x02\\\x02\x12\x03f\x20#\n\x0b\n\x04\x05\0\x02]\
    \x12\x03g\x08#\n\x0c\n\x05\x05\0\x02]\x01\x12\x03g\x08\x1c\n\x0c\n\x05\
    \x05\0\x02]\x02\x12\x03g\x1f\"\n\x0b\n\x04\x05\0\x02^\x12\x03h\x08\"\n\
    \x0c\n\x05\x05\0\x02^\x01\x12\x03h\x08\x1b\n\x0c\n\x05\x05\0\x02^\x02\
    \x12\x03h\x1e!\n\x0b\n\x04\x05\0\x02_\x12\x03i\x08&\n\x0c\n\x05\x05\0\
    \x02_\x01\x12\x03i\x08\x1f\n\x0c\n\x05\x05\0\x02_\x02\x12\x03i\"%\n\x0b\
    \n\x04\x05\0\x02`\x12\x03j\x08&\n\x0c\n\x05\x05\0\x02`\x01\x12\x03j\x08\
    \x1f\n\x0c\n\x05\x05\0\x02`\x02\x12\x03j\"%\n\x0b\n\x04\x05\0\x02a\x12\
    \x03k\x08)\n\x0c\n\x05\x05\0\x02a\x01\x12\x03k\x08\"\n\x0c\n\x05\x05\0\
    \x02a\x02\x12\x03k%(\n\x0b\n\x04\x05\0\x02b\x12\x03l\x08(\n\x0c\n\x05\
    \x05\0\x02b\x01\x12\x03l\x08!\n\x0c\n\x05\x05\0\x02b\x02\x12\x03l$'\n\
    \x0b\n\x04\x05\0\x02c\x12\x03m\x08%\n\x0c\n\x05\x05\0\x02c\x01\x12\x03m\
    \x08\x1e\n\x0c\n\x05\x05\0\x02c\x02\x12\x03m!$\n\x0b\n\x04\x05\0\x02d\
    \x12\x03n\x08%\n\x0c\n\x05\x05\0\x02d\x01\x12\x03n\x08\x1e\n\x0c\n\x05\
    \x05\0\x02d\x02\x12\x03n!$\n\x0b\n\x04\x05\0\x02e\x12\x03o\x08-\n\x0c\n\
    \x05\x05\0\x02e\x01\x12\x03o\x08&\n\x0c\n\x05\x05\0\x02e\x02\x12\x03o),\
    \n\x0b\n\x04\x05\0\x02f\x12\x03p\x08)\n\x0c\n\x05\x05\0\x02f\x01\x12\x03\
    p\x08\"\n\x0c\n\x05\x05\0\x02f\x02\x12\x03p%(\n\x0b\n\x04\x05\0\x02g\x12\
    \x03q\x08/\n\x0c\n\x05\x05\0\x02g\x01\x12\x03q\x08(\n\x0c\n\x05\x05\0\
    \x02g\x02\x12\x03q+.\n\x0b\n\x04\x05\0\x02h\x12\x03r\x08(\n\x0c\n\x05\
    \x05\0\x02h\x01\x12\x03r\x08!\n\x0c\n\x05\x05\0\x02h\x02\x12\x03r$'\n\
    \x0b\n\x04\x05\0\x02i\x12\x03s\x08+\n\x0c\n\x05\x05\0\x02i\x01\x12\x03s\
    \x08$\n\x0c\n\x05\x05\0\x02i\x02\x12\x03s'*\n\x0b\n\x04\x05\0\x02j\x12\
    \x03t\x08+\n\x0c\n\x05\x05\0\x02j\x01\x12\x03t\x08$\n\x0c\n\x05\x05\0\
    \x02j\x02\x12\x03t'*\n\x0b\n\x04\x05\0\x02k\x12\x03u\x08(\n\x0c\n\x05\
    \x05\0\x02k\x01\x12\x03u\x08!\n\x0c\n\x05\x05\0\x02k\x02\x12\x03u$'\n\
    \x0b\n\x04\x05\0\x02l\x12\x03v\x081\n\x0c\n\x05\x05\0\x02l\x01\x12\x03v\
    \x08*\n\x0c\n\x05\x05\0\x02l\x02\x12\x03v-0\n\x0b\n\x04\x05\0\x02m\x12\
    \x03w\x08\x1f\n\x0c\n\x05\x05\0\x02m\x01\x12\x03w\x08\x18\n\x0c\n\x05\
    \x05\0\x02m\x02\x12\x03w\x1b\x1e\n\x0b\n\x04\x05\0\x02n\x12\x03x\x08#\n\
    \x0c\n\x05\x05\0\x02n\x01\x12\x03x\x08\x1c\n\x0c\n\x05\x05\0\x02n\x02\
    \x12\x03x\x1f\"\n\x0b\n\x04\x05\0\x02o\x12\x03y\x08#\n\x0c\n\x05\x05\0\
    \x02o\x01\x12\x03y\x08\x1c\n\x0c\n\x05\x05\0\x02o\x02\x12\x03y\x1f\"\n\
    \x0b\n\x04\x05\0\x02p\x12\x03z\x08\x1f\n\x0c\n\x05\x05\0\x02p\x01\x12\
    \x03z\x08\x18\n\x0c\n\x05\x05\0\x02p\x02\x12\x03z\x1b\x1e\n\x0b\n\x04\
    \x05\0\x02q\x12\x03{\x08'\n\x0c\n\x05\x05\0\x02q\x01\x12\x03{\x08\x20\n\
    \x0c\n\x05\x05\0\x02q\x02\x12\x03{#&\n\x0b\n\x04\x05\0\x02r\x12\x03|\x08\
    )\n\x0c\n\x05\x05\0\x02r\x01\x12\x03|\x08\"\n\x0c\n\x05\x05\0\x02r\x02\
    \x12\x03|%(\n\x0b\n\x04\x05\0\x02s\x12\x03}\x08-\n\x0c\n\x05\x05\0\x02s\
    \x01\x12\x03}\x08&\n\x0c\n\x05\x05\0\x02s\x02\x12\x03}),\n\x0b\n\x04\x05\
    \0\x02t\x12\x03~\x08$\n\x0c\n\x05\x05\0\x02t\x01\x12\x03~\x08\x1d\n\x0c\
    \n\x05\x05\0\x02t\x02\x12\x03~\x20#\n\x0b\n\x04\x05\0\x02u\x12\x03\x7f\
    \x08+\n\x0c\n\x05\x05\0\x02u\x01\x12\x03\x7f\x08$\n\x0c\n\x05\x05\0\x02u\
    \x02\x12\x03\x7f'*\n\x0c\n\x04\x05\0\x02v\x12\x04\x80\x01\x08*\n\r\n\x05\
    \x05\0\x02v\x01\x12\x04\x80\x01\x08#\n\r\n\x05\x05\0\x02v\x02\x12\x04\
    \x80\x01&)\n\x0c\n\x04\x05\0\x02w\x12\x04\x81\x01\x08(\n\r\n\x05\x05\0\
    \x02w\x01\x12\x04\x81\x01\x08!\n\r\n\x05\x05\0\x02w\x02\x12\x04\x81\x01$\
    '\n\x0c\n\x04\x05\0\x02x\x12\x04\x82\x01\x08$\n\r\n\x05\x05\0\x02x\x01\
    \x12\x04\x82\x01\x08\x1d\n\r\n\x05\x05\0\x02x\x02\x12\x04\x82\x01\x20#\n\
    \x0c\n\x04\x05\0\x02y\x12\x04\x83\x01\x08'\n\r\n\x05\x05\0\x02y\x01\x12\
    \x04\x83\x01\x08\x20\n\r\n\x05\x05\0\x02y\x02\x12\x04\x83\x01#&\n\x0c\n\
    \x04\x05\0\x02z\x12\x04\x84\x01\x08!\n\r\n\x05\x05\0\x02z\x01\x12\x04\
    \x84\x01\x08\x1a\n\r\n\x05\x05\0\x02z\x02\x12\x04\x84\x01\x1d\x20\n\x0c\
    \n\x04\x05\0\x02{\x12\x04\x85\x01\x08#\n\r\n\x05\x05\0\x02{\x01\x12\x04\
    \x85\x01\x08\x1c\n\r\n\x05\x05\0\x02{\x02\x12\x04\x85\x01\x1f\"\n\x0c\n\
    \x04\x05\0\x02|\x12\x04\x86\x01\x08&\n\r\n\x05\x05\0\x02|\x01\x12\x04\
    \x86\x01\x08\x1f\n\r\n\x05\x05\0\x02|\x02\x12\x04\x86\x01\"%\n\x0c\n\x04\
    \x05\0\x02}\x12\x04\x87\x01\x08)\n\r\n\x05\x05\0\x02}\x01\x12\x04\x87\
    \x01\x08\"\n\r\n\x05\x05\0\x02}\x02\x12\x04\x87\x01%(\n\x0c\n\x04\x05\0\
    \x02~\x12\x04\x88\x01\x08%\n\r\n\x05\x05\0\x02~\x01\x12\x04\x88\x01\x08\
    \x1e\n\r\n\x05\x05\0\x02~\x02\x12\x04\x88\x01!$\n\x0c\n\x04\x05\0\x02\
    \x7f\x12\x04\x89\x01\x08$\n\r\n\x05\x05\0\x02\x7f\x01\x12\x04\x89\x01\
    \x08\x1d\n\r\n\x05\x05\0\x02\x7f\x02\x12\x04\x89\x01\x20#\n\r\n\x05\x05\
    \0\x02\x80\x01\x12\x04\x8a\x01\x08'\n\x0e\n\x06\x05\0\x02\x80\x01\x01\
    \x12\x04\x8a\x01\x08\x20\n\x0e\n\x06\x05\0\x02\x80\x01\x02\x12\x04\x8a\
    \x01#&\n\r\n\x05\x05\0\x02\x81\x01\x12\x04\x8b\x01\x08&\n\x0e\n\x06\x05\
    \0\x02\x81\x01\x01\x12\x04\x8b\x01\x08\x1f\n\x0e\n\x06\x05\0\x02\x81\x01\
    \x02\x12\x04\x8b\x01\"%\n\r\n\x05\x05\0\x02\x82\x01\x12\x04\x8c\x01\x08'\
    \n\x0e\n\x06\x05\0\x02\x82\x01\x01\x12\x04\x8c\x01\x08\x20\n\x0e\n\x06\
    \x05\0\x02\x82\x01\x02\x12\x04\x8c\x01#&\n\r\n\x05\x05\0\x02\x83\x01\x12\
    \x04\x8d\x01\x08'\n\x0e\n\x06\x05\0\x02\x83\x01\x01\x12\x04\x8d\x01\x08\
    \x20\n\x0e\n\x06\x05\0\x02\x83\x01\x02\x12\x04\x8d\x01#&\n\r\n\x05\x05\0\
    \x02\x84\x01\x12\x04\x8e\x01\x08(\n\x0e\n\x06\x05\0\x02\x84\x01\x01\x12\
    \x04\x8e\x01\x08!\n\x0e\n\x06\x05\0\x02\x84\x01\x02\x12\x04\x8e\x01$'\n\
    \r\n\x05\x05\0\x02\x85\x01\x12\x04\x8f\x01\x081\n\x0e\n\x06\x05\0\x02\
    \x85\x01\x01\x12\x04\x8f\x01\x08*\n\x0e\n\x06\x05\0\x02\x85\x01\x02\x12\
    \x04\x8f\x01-0\n\r\n\x05\x05\0\x02\x86\x01\x12\x04\x90\x01\x08(\n\x0e\n\
    \x06\x05\0\x02\x86\x01\x01\x12\x04\x90\x01\x08!\n\x0e\n\x06\x05\0\x02\
    \x86\x01\x02\x12\x04\x90\x01$'\n\r\n\x05\x05\0\x02\x87\x01\x12\x04\x91\
    \x01\x08(\n\x0e\n\x06\x05\0\x02\x87\x01\x01\x12\x04\x91\x01\x08!\n\x0e\n\
    \x06\x05\0\x02\x87\x01\x02\x12\x04\x91\x01$'\n\r\n\x05\x05\0\x02\x88\x01\
    \x12\x04\x92\x01\x08)\n\x0e\n\x06\x05\0\x02\x88\x01\x01\x12\x04\x92\x01\
    \x08\"\n\x0e\n\x06\x05\0\x02\x88\x01\x02\x12\x04\x92\x01%(\n\r\n\x05\x05\
    \0\x02\x89\x01\x12\x04\x93\x01\x08)\n\x0e\n\x06\x05\0\x02\x89\x01\x01\
    \x12\x04\x93\x01\x08\"\n\x0e\n\x06\x05\0\x02\x89\x01\x02\x12\x04\x93\x01\
    %(\n\r\n\x05\x05\0\x02\x8a\x01\x12\x04\x94\x01\x08.\n\x0e\n\x06\x05\0\
    \x02\x8a\x01\x01\x12\x04\x94\x01\x08'\n\x0e\n\x06\x05\0\x02\x8a\x01\x02\
    \x12\x04\x94\x01*-\n\r\n\x05\x05\0\x02\x8b\x01\x12\x04\x95\x01\x08'\n\
    \x0e\n\x06\x05\0\x02\x8b\x01\x01\x12\x04\x95\x01\x08\x20\n\x0e\n\x06\x05\
    \0\x02\x8b\x01\x02\x12\x04\x95\x01#&\n\r\n\x05\x05\0\x02\x8c\x01\x12\x04\
    \x96\x01\x08&\n\x0e\n\x06\x05\0\x02\x8c\x01\x01\x12\x04\x96\x01\x08\x1f\
    \n\x0e\n\x06\x05\0\x02\x8c\x01\x02\x12\x04\x96\x01\"%\n\r\n\x05\x05\0\
    \x02\x8d\x01\x12\x04\x97\x01\x08)\n\x0e\n\x06\x05\0\x02\x8d\x01\x01\x12\
    \x04\x97\x01\x08\"\n\x0e\n\x06\x05\0\x02\x8d\x01\x02\x12\x04\x97\x01%(\n\
    \r\n\x05\x05\0\x02\x8e\x01\x12\x04\x98\x01\x08&\n\x0e\n\x06\x05\0\x02\
    \x8e\x01\x01\x12\x04\x98\x01\x08\x1f\n\x0e\n\x06\x05\0\x02\x8e\x01\x02\
    \x12\x04\x98\x01\"%\n\r\n\x05\x05\0\x02\x8f\x01\x12\x04\x99\x01\x08'\n\
    \x0e\n\x06\x05\0\x02\x8f\x01\x01\x12\x04\x99\x01\x08\x20\n\x0e\n\x06\x05\
    \0\x02\x8f\x01\x02\x12\x04\x99\x01#&\n\r\n\x05\x05\0\x02\x90\x01\x12\x04\
    \x9a\x01\x08#\n\x0e\n\x06\x05\0\x02\x90\x01\x01\x12\x04\x9a\x01\x08\x1c\
    \n\x0e\n\x06\x05\0\x02\x90\x01\x02\x12\x04\x9a\x01\x1f\"\n\r\n\x05\x05\0\
    \x02\x91\x01\x12\x04\x9b\x01\x08$\n\x0e\n\x06\x05\0\x02\x91\x01\x01\x12\
    \x04\x9b\x01\x08\x1d\n\x0e\n\x06\x05\0\x02\x91\x01\x02\x12\x04\x9b\x01\
    \x20#\n\r\n\x05\x05\0\x02\x92\x01\x12\x04\x9c\x01\x08\"\n\x0e\n\x06\x05\
    \0\x02\x92\x01\x01\x12\x04\x9c\x01\x08\x1b\n\x0e\n\x06\x05\0\x02\x92\x01\
    \x02\x12\x04\x9c\x01\x1e!\n\r\n\x05\x05\0\x02\x93\x01\x12\x04\x9d\x01\
    \x08'\n\x0e\n\x06\x05\0\x02\x93\x01\x01\x12\x04\x9d\x01\x08\x20\n\x0e\n\
    \x06\x05\0\x02\x93\x01\x02\x12\x04\x9d\x01#&\n\r\n\x05\x05\0\x02\x94\x01\
    \x12\x04\x9e\x01\x08/\n\x0e\n\x06\x05\0\x02\x94\x01\x01\x12\x04\x9e\x01\
    \x08(\n\x0e\n\x06\x05\0\x02\x94\x01\x02\x12\x04\x9e\x01+.\n\r\n\x05\x05\
    \0\x02\x95\x01\x12\x04\x9f\x01\x080\n\x0e\n\x06\x05\0\x02\x95\x01\x01\
    \x12\x04\x9f\x01\x08)\n\x0e\n\x06\x05\0\x02\x95\x01\x02\x12\x04\x9f\x01,\
    /\n\r\n\x05\x05\0\x02\x96\x01\x12\x04\xa0\x01\x08)\n\x0e\n\x06\x05\0\x02\
    \x96\x01\x01\x12\x04\xa0\x01\x08\"\n\x0e\n\x06\x05\0\x02\x96\x01\x02\x12\
    \x04\xa0\x01%(\n\r\n\x05\x05\0\x02\x97\x01\x12\x04\xa1\x01\x08#\n\x0e\n\
    \x06\x05\0\x02\x97\x01\x01\x12\x04\xa1\x01\x08\x1c\n\x0e\n\x06\x05\0\x02\
    \x97\x01\x02\x12\x04\xa1\x01\x1f\"\n\r\n\x05\x05\0\x02\x98\x01\x12\x04\
    \xa2\x01\x08$\n\x0e\n\x06\x05\0\x02\x98\x01\x01\x12\x04\xa2\x01\x08\x1d\
    \n\x0e\n\x06\x05\0\x02\x98\x01\x02\x12\x04\xa2\x01\x20#\n\r\n\x05\x05\0\
    \x02\x99\x01\x12\x04\xa3\x01\x08>\n\x0e\n\x06\x05\0\x02\x99\x01\x01\x12\
    \x04\xa3\x01\x087\n\x0e\n\x06\x05\0\x02\x99\x01\x02\x12\x04\xa3\x01:=\n\
    \r\n\x05\x05\0\x02\x9a\x01\x12\x04\xa4\x01\x08-\n\x0e\n\x06\x05\0\x02\
    \x9a\x01\x01\x12\x04\xa4\x01\x08&\n\x0e\n\x06\x05\0\x02\x9a\x01\x02\x12\
    \x04\xa4\x01),\n\r\n\x05\x05\0\x02\x9b\x01\x12\x04\xa5\x01\x08&\n\x0e\n\
    \x06\x05\0\x02\x9b\x01\x01\x12\x04\xa5\x01\x08\x1f\n\x0e\n\x06\x05\0\x02\
    \x9b\x01\x02\x12\x04\xa5\x01\"%\n\x0c\n\x02\x05\x01\x12\x06\xa8\x01\0\
    \x95\x02\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\xa8\x01\x05\x16\n\x0c\n\x04\
    \x05\x01\x02\0\x12\x04\xa9\x01\x08\"\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\
    \xa9\x01\x08\x1c\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xa9\x01\x1f!\n\x0c\
    \n\x04\x05\x01\x02\x01\x12\x04\xaa\x01\x08#\n\r\n\x05\x05\x01\x02\x01\
    \x01\x12\x04\xaa\x01\x08\x1e\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xaa\
    \x01!\"\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\xab\x01\x08#\n\r\n\x05\x05\
    \x01\x02\x02\x01\x12\x04\xab\x01\x08\x1e\n\r\n\x05\x05\x01\x02\x02\x02\
    \x12\x04\xab\x01!\"\n\x0c\n\x04\x05\x01\x02\x03\x12\x04\xac\x01\x08'\n\r\
    \n\x05\x05\x01\x02\x03\x01\x12\x04\xac\x01\x08\"\n\r\n\x05\x05\x01\x02\
    \x03\x02\x12\x04\xac\x01%&\n\x0c\n\x04\x05\x01\x02\x04\x12\x04\xad\x01\
    \x08$\n\r\n\x05\x05\x01\x02\x04\x01\x12\x04\xad\x01\x08\x1f\n\r\n\x05\
    \x05\x01\x02\x04\x02\x12\x04\xad\x01\"#\n\x0c\n\x04\x05\x01\x02\x05\x12\
    \x04\xae\x01\x08$\n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\xae\x01\x08\x1f\
    \n\r\n\x05\x05\x01\x02\x05\x02\x12\x04\xae\x01\"#\n\x0c\n\x04\x05\x01\
    \x02\x06\x12\x04\xaf\x01\x08$\n\r\n\x05\x05\x01\x02\x06\x01\x12\x04\xaf\
    \x01\x08\x1f\n\r\n\x05\x05\x01\x02\x06\x02\x12\x04\xaf\x01\"#\n\x0c\n\
    \x04\x05\x01\x02\x07\x12\x04\xb0\x01\x08%\n\r\n\x05\x05\x01\x02\x07\x01\
    \x12\x04\xb0\x01\x08\x20\n\r\n\x05\x05\x01\x02\x07\x02\x12\x04\xb0\x01#$\
    \n\x0c\n\x04\x05\x01\x02\x08\x12\x04\xb1\x01\x08!\n\r\n\x05\x05\x01\x02\
    \x08\x01\x12\x04\xb1\x01\x08\x1c\n\r\n\x05\x05\x01\x02\x08\x02\x12\x04\
    \xb1\x01\x1f\x20\n\x0c\n\x04\x05\x01\x02\t\x12\x04\xb2\x01\x08\x1f\n\r\n\
    \x05\x05\x01\x02\t\x01\x12\x04\xb2\x01\x08\x1a\n\r\n\x05\x05\x01\x02\t\
    \x02\x12\x04\xb2\x01\x1d\x1e\n\x0c\n\x04\x05\x01\x02\n\x12\x04\xb3\x01\
    \x08%\n\r\n\x05\x05\x01\x02\n\x01\x12\x04\xb3\x01\x08\x20\n\r\n\x05\x05\
    \x01\x02\n\x02\x12\x04\xb3\x01#$\n\x0c\n\x04\x05\x01\x02\x0b\x12\x04\xb4\
    \x01\x08'\n\r\n\x05\x05\x01\x02\x0b\x01\x12\x04\xb4\x01\x08!\n\r\n\x05\
    \x05\x01\x02\x0b\x02\x12\x04\xb4\x01$&\n\x0c\n\x04\x05\x01\x02\x0c\x12\
    \x04\xb5\x01\x08,\n\r\n\x05\x05\x01\x02\x0c\x01\x12\x04\xb5\x01\x08&\n\r\
    \n\x05\x05\x01\x02\x0c\x02\x12\x04\xb5\x01)+\n\x0c\n\x04\x05\x01\x02\r\
    \x12\x04\xb6\x01\x08%\n\r\n\x05\x05\x01\x02\r\x01\x12\x04\xb6\x01\x08\
    \x1f\n\r\n\x05\x05\x01\x02\r\x02\x12\x04\xb6\x01\"$\n\x0c\n\x04\x05\x01\
    \x02\x0e\x12\x04\xb7\x01\x08(\n\r\n\x05\x05\x01\x02\x0e\x01\x12\x04\xb7\
    \x01\x08\"\n\r\n\x05\x05\x01\x02\x0e\x02\x12\x04\xb7\x01%'\n\x0c\n\x04\
    \x05\x01\x02\x0f\x12\x04\xb8\x01\x08\"\n\r\n\x05\x05\x01\x02\x0f\x01\x12\
    \x04\xb8\x01\x08\x1c\n\r\n\x05\x05\x01\x02\x0f\x02\x12\x04\xb8\x01\x1f!\
    \n\x0c\n\x04\x05\x01\x02\x10\x12\x04\xb9\x01\x08%\n\r\n\x05\x05\x01\x02\
    \x10\x01\x12\x04\xb9\x01\x08\x1f\n\r\n\x05\x05\x01\x02\x10\x02\x12\x04\
    \xb9\x01\"$\n\x0c\n\x04\x05\x01\x02\x11\x12\x04\xba\x01\x088\n\r\n\x05\
    \x05\x01\x02\x11\x01\x12\x04\xba\x01\x082\n\r\n\x05\x05\x01\x02\x11\x02\
    \x12\x04\xba\x0157\n\x0c\n\x04\x05\x01\x02\x12\x12\x04\xbb\x01\x084\n\r\
    \n\x05\x05\x01\x02\x12\x01\x12\x04\xbb\x01\x08.\n\r\n\x05\x05\x01\x02\
    \x12\x02\x12\x04\xbb\x0113\n\x0c\n\x04\x05\x01\x02\x13\x12\x04\xbc\x01\
    \x08;\n\r\n\x05\x05\x01\x02\x13\x01\x12\x04\xbc\x01\x085\n\r\n\x05\x05\
    \x01\x02\x13\x02\x12\x04\xbc\x018:\n\x0c\n\x04\x05\x01\x02\x14\x12\x04\
    \xbd\x01\x08$\n\r\n\x05\x05\x01\x02\x14\x01\x12\x04\xbd\x01\x08\x1e\n\r\
    \n\x05\x05\x01\x02\x14\x02\x12\x04\xbd\x01!#\n\x0c\n\x04\x05\x01\x02\x15\
    \x12\x04\xbe\x01\x08&\n\r\n\x05\x05\x01\x02\x15\x01\x12\x04\xbe\x01\x08\
    \x20\n\r\n\x05\x05\x01\x02\x15\x02\x12\x04\xbe\x01#%\n\x0c\n\x04\x05\x01\
    \x02\x16\x12\x04\xbf\x01\x08(\n\r\n\x05\x05\x01\x02\x16\x01\x12\x04\xbf\
    \x01\x08\"\n\r\n\x05\x05\x01\x02\x16\x02\x12\x04\xbf\x01%'\n\x0c\n\x04\
    \x05\x01\x02\x17\x12\x04\xc0\x01\x08&\n\r\n\x05\x05\x01\x02\x17\x01\x12\
    \x04\xc0\x01\x08\x20\n\r\n\x05\x05\x01\x02\x17\x02\x12\x04\xc0\x01#%\n\
    \x0c\n\x04\x05\x01\x02\x18\x12\x04\xc1\x01\x08&\n\r\n\x05\x05\x01\x02\
    \x18\x01\x12\x04\xc1\x01\x08\x20\n\r\n\x05\x05\x01\x02\x18\x02\x12\x04\
    \xc1\x01#%\n\x0c\n\x04\x05\x01\x02\x19\x12\x04\xc2\x01\x08%\n\r\n\x05\
    \x05\x01\x02\x19\x01\x12\x04\xc2\x01\x08\x1e\n\r\n\x05\x05\x01\x02\x19\
    \x02\x12\x04\xc2\x01!$\n\x0c\n\x04\x05\x01\x02\x1a\x12\x04\xc3\x01\x08#\
    \n\r\n\x05\x05\x01\x02\x1a\x01\x12\x04\xc3\x01\x08\x1d\n\r\n\x05\x05\x01\
    \x02\x1a\x02\x12\x04\xc3\x01\x20\"\n\x0c\n\x04\x05\x01\x02\x1b\x12\x04\
    \xc4\x01\x08%\n\r\n\x05\x05\x01\x02\x1b\x01\x12\x04\xc4\x01\x08\x1f\n\r\
    \n\x05\x05\x01\x02\x1b\x02\x12\x04\xc4\x01\"$\n\x0c\n\x04\x05\x01\x02\
    \x1c\x12\x04\xc5\x01\x08-\n\r\n\x05\x05\x01\x02\x1c\x01\x12\x04\xc5\x01\
    \x08'\n\r\n\x05\x05\x01\x02\x1c\x02\x12\x04\xc5\x01*,\n\x0c\n\x04\x05\
    \x01\x02\x1d\x12\x04\xc6\x01\x08)\n\r\n\x05\x05\x01\x02\x1d\x01\x12\x04\
    \xc6\x01\x08#\n\r\n\x05\x05\x01\x02\x1d\x02\x12\x04\xc6\x01&(\n\x0c\n\
    \x04\x05\x01\x02\x1e\x12\x04\xc7\x01\x08'\n\r\n\x05\x05\x01\x02\x1e\x01\
    \x12\x04\xc7\x01\x08!\n\r\n\x05\x05\x01\x02\x1e\x02\x12\x04\xc7\x01$&\n\
    \x0c\n\x04\x05\x01\x02\x1f\x12\x04\xc8\x01\x08/\n\r\n\x05\x05\x01\x02\
    \x1f\x01\x12\x04\xc8\x01\x08)\n\r\n\x05\x05\x01\x02\x1f\x02\x12\x04\xc8\
    \x01,.\n\x0c\n\x04\x05\x01\x02\x20\x12\x04\xc9\x01\x08$\n\r\n\x05\x05\
    \x01\x02\x20\x01\x12\x04\xc9\x01\x08\x1e\n\r\n\x05\x05\x01\x02\x20\x02\
    \x12\x04\xc9\x01!#\n\x0c\n\x04\x05\x01\x02!\x12\x04\xca\x01\x08'\n\r\n\
    \x05\x05\x01\x02!\x01\x12\x04\xca\x01\x08!\n\r\n\x05\x05\x01\x02!\x02\
    \x12\x04\xca\x01$&\n\x0c\n\x04\x05\x01\x02\"\x12\x04\xcb\x01\x08'\n\r\n\
    \x05\x05\x01\x02\"\x01\x12\x04\xcb\x01\x08!\n\r\n\x05\x05\x01\x02\"\x02\
    \x12\x04\xcb\x01$&\n\x0c\n\x04\x05\x01\x02#\x12\x04\xcc\x01\x08!\n\r\n\
    \x05\x05\x01\x02#\x01\x12\x04\xcc\x01\x08\x1b\n\r\n\x05\x05\x01\x02#\x02\
    \x12\x04\xcc\x01\x1e\x20\n\x0c\n\x04\x05\x01\x02$\x12\x04\xcd\x01\x08,\n\
    \r\n\x05\x05\x01\x02$\x01\x12\x04\xcd\x01\x08&\n\r\n\x05\x05\x01\x02$\
    \x02\x12\x04\xcd\x01)+\n\x0c\n\x04\x05\x01\x02%\x12\x04\xce\x01\x08#\n\r\
    \n\x05\x05\x01\x02%\x01\x12\x04\xce\x01\x08\x1d\n\r\n\x05\x05\x01\x02%\
    \x02\x12\x04\xce\x01\x20\"\n\x0c\n\x04\x05\x01\x02&\x12\x04\xcf\x01\x08(\
    \n\r\n\x05\x05\x01\x02&\x01\x12\x04\xcf\x01\x08\"\n\r\n\x05\x05\x01\x02&\
    \x02\x12\x04\xcf\x01%'\n\x0c\n\x04\x05\x01\x02'\x12\x04\xd0\x01\x08$\n\r\
    \n\x05\x05\x01\x02'\x01\x12\x04\xd0\x01\x08\x1e\n\r\n\x05\x05\x01\x02'\
    \x02\x12\x04\xd0\x01!#\n\x0c\n\x04\x05\x01\x02(\x12\x04\xd1\x01\x08*\n\r\
    \n\x05\x05\x01\x02(\x01\x12\x04\xd1\x01\x08$\n\r\n\x05\x05\x01\x02(\x02\
    \x12\x04\xd1\x01')\n\x0c\n\x04\x05\x01\x02)\x12\x04\xd2\x01\x08,\n\r\n\
    \x05\x05\x01\x02)\x01\x12\x04\xd2\x01\x08&\n\r\n\x05\x05\x01\x02)\x02\
    \x12\x04\xd2\x01)+\n\x0c\n\x04\x05\x01\x02*\x12\x04\xd3\x01\x088\n\r\n\
    \x05\x05\x01\x02*\x01\x12\x04\xd3\x01\x082\n\r\n\x05\x05\x01\x02*\x02\
    \x12\x04\xd3\x0157\n\x0c\n\x04\x05\x01\x02+\x12\x04\xd4\x01\x08*\n\r\n\
    \x05\x05\x01\x02+\x01\x12\x04\xd4\x01\x08$\n\r\n\x05\x05\x01\x02+\x02\
    \x12\x04\xd4\x01')\n\x0c\n\x04\x05\x01\x02,\x12\x04\xd5\x01\x08$\n\r\n\
    \x05\x05\x01\x02,\x01\x12\x04\xd5\x01\x08\x1e\n\r\n\x05\x05\x01\x02,\x02\
    \x12\x04\xd5\x01!#\n\x0c\n\x04\x05\x01\x02-\x12\x04\xd6\x01\x08\x20\n\r\
    \n\x05\x05\x01\x02-\x01\x12\x04\xd6\x01\x08\x1a\n\r\n\x05\x05\x01\x02-\
    \x02\x12\x04\xd6\x01\x1d\x1f\n\x0c\n\x04\x05\x01\x02.\x12\x04\xd7\x01\
    \x08!\n\r\n\x05\x05\x01\x02.\x01\x12\x04\xd7\x01\x08\x1b\n\r\n\x05\x05\
    \x01\x02.\x02\x12\x04\xd7\x01\x1e\x20\n\x0c\n\x04\x05\x01\x02/\x12\x04\
    \xd8\x01\x08\"\n\r\n\x05\x05\x01\x02/\x01\x12\x04\xd8\x01\x08\x1c\n\r\n\
    \x05\x05\x01\x02/\x02\x12\x04\xd8\x01\x1f!\n\x0c\n\x04\x05\x01\x020\x12\
    \x04\xd9\x01\x08*\n\r\n\x05\x05\x01\x020\x01\x12\x04\xd9\x01\x08$\n\r\n\
    \x05\x05\x01\x020\x02\x12\x04\xd9\x01')\n\x0c\n\x04\x05\x01\x021\x12\x04\
    \xda\x01\x08+\n\r\n\x05\x05\x01\x021\x01\x12\x04\xda\x01\x08%\n\r\n\x05\
    \x05\x01\x021\x02\x12\x04\xda\x01(*\n\x0c\n\x04\x05\x01\x022\x12\x04\xdb\
    \x01\x08'\n\r\n\x05\x05\x01\x022\x01\x12\x04\xdb\x01\x08!\n\r\n\x05\x05\
    \x01\x022\x02\x12\x04\xdb\x01$&\n\x0c\n\x04\x05\x01\x023\x12\x04\xdc\x01\
    \x08(\n\r\n\x05\x05\x01\x023\x01\x12\x04\xdc\x01\x08\"\n\r\n\x05\x05\x01\
    \x023\x02\x12\x04\xdc\x01%'\n\x0c\n\x04\x05\x01\x024\x12\x04\xdd\x01\x08\
    '\n\r\n\x05\x05\x01\x024\x01\x12\x04\xdd\x01\x08!\n\r\n\x05\x05\x01\x024\
    \x02\x12\x04\xdd\x01$&\n\x0c\n\x04\x05\x01\x025\x12\x04\xde\x01\x08'\n\r\
    \n\x05\x05\x01\x025\x01\x12\x04\xde\x01\x08!\n\r\n\x05\x05\x01\x025\x02\
    \x12\x04\xde\x01$&\n\x0c\n\x04\x05\x01\x026\x12\x04\xdf\x01\x08&\n\r\n\
    \x05\x05\x01\x026\x01\x12\x04\xdf\x01\x08\x20\n\r\n\x05\x05\x01\x026\x02\
    \x12\x04\xdf\x01#%\n\x0c\n\x04\x05\x01\x027\x12\x04\xe0\x01\x081\n\r\n\
    \x05\x05\x01\x027\x01\x12\x04\xe0\x01\x08+\n\r\n\x05\x05\x01\x027\x02\
    \x12\x04\xe0\x01.0\n\x0c\n\x04\x05\x01\x028\x12\x04\xe1\x01\x082\n\r\n\
    \x05\x05\x01\x028\x01\x12\x04\xe1\x01\x08,\n\r\n\x05\x05\x01\x028\x02\
    \x12\x04\xe1\x01/1\n\x0c\n\x04\x05\x01\x029\x12\x04\xe2\x01\x081\n\r\n\
    \x05\x05\x01\x029\x01\x12\x04\xe2\x01\x08+\n\r\n\x05\x05\x01\x029\x02\
    \x12\x04\xe2\x01.0\n\x0c\n\x04\x05\x01\x02:\x12\x04\xe3\x01\x080\n\r\n\
    \x05\x05\x01\x02:\x01\x12\x04\xe3\x01\x08*\n\r\n\x05\x05\x01\x02:\x02\
    \x12\x04\xe3\x01-/\n\x0c\n\x04\x05\x01\x02;\x12\x04\xe4\x01\x083\n\r\n\
    \x05\x05\x01\x02;\x01\x12\x04\xe4\x01\x08-\n\r\n\x05\x05\x01\x02;\x02\
    \x12\x04\xe4\x0102\n\x0c\n\x04\x05\x01\x02<\x12\x04\xe5\x01\x08;\n\r\n\
    \x05\x05\x01\x02<\x01\x12\x04\xe5\x01\x085\n\r\n\x05\x05\x01\x02<\x02\
    \x12\x04\xe5\x018:\n\x0c\n\x04\x05\x01\x02=\x12\x04\xe6\x01\x082\n\r\n\
    \x05\x05\x01\x02=\x01\x12\x04\xe6\x01\x08,\n\r\n\x05\x05\x01\x02=\x02\
    \x12\x04\xe6\x01/1\n\x0c\n\x04\x05\x01\x02>\x12\x04\xe7\x01\x08=\n\r\n\
    \x05\x05\x01\x02>\x01\x12\x04\xe7\x01\x087\n\r\n\x05\x05\x01\x02>\x02\
    \x12\x04\xe7\x01:<\n\x0c\n\x04\x05\x01\x02?\x12\x04\xe8\x01\x086\n\r\n\
    \x05\x05\x01\x02?\x01\x12\x04\xe8\x01\x080\n\r\n\x05\x05\x01\x02?\x02\
    \x12\x04\xe8\x0135\n\x0c\n\x04\x05\x01\x02@\x12\x04\xe9\x01\x08;\n\r\n\
    \x05\x05\x01\x02@\x01\x12\x04\xe9\x01\x085\n\r\n\x05\x05\x01\x02@\x02\
    \x12\x04\xe9\x018:\n\x0c\n\x04\x05\x01\x02A\x12\x04\xea\x01\x08*\n\r\n\
    \x05\x05\x01\x02A\x01\x12\x04\xea\x01\x08$\n\r\n\x05\x05\x01\x02A\x02\
    \x12\x04\xea\x01')\n\x0c\n\x04\x05\x01\x02B\x12\x04\xeb\x01\x08<\n\r\n\
    \x05\x05\x01\x02B\x01\x12\x04\xeb\x01\x086\n\r\n\x05\x05\x01\x02B\x02\
    \x12\x04\xeb\x019;\n\x0c\n\x04\x05\x01\x02C\x12\x04\xec\x01\x08+\n\r\n\
    \x05\x05\x01\x02C\x01\x12\x04\xec\x01\x08%\n\r\n\x05\x05\x01\x02C\x02\
    \x12\x04\xec\x01(*\n\x0c\n\x04\x05\x01\x02D\x12\x04\xed\x01\x08/\n\r\n\
    \x05\x05\x01\x02D\x01\x12\x04\xed\x01\x08)\n\r\n\x05\x05\x01\x02D\x02\
    \x12\x04\xed\x01,.\n\x0c\n\x04\x05\x01\x02E\x12\x04\xee\x01\x08A\n\r\n\
    \x05\x05\x01\x02E\x01\x12\x04\xee\x01\x08;\n\r\n\x05\x05\x01\x02E\x02\
    \x12\x04\xee\x01>@\n\x0c\n\x04\x05\x01\x02F\x12\x04\xef\x01\x08-\n\r\n\
    \x05\x05\x01\x02F\x01\x12\x04\xef\x01\x08'\n\r\n\x05\x05\x01\x02F\x02\
    \x12\x04\xef\x01*,\n\x0c\n\x04\x05\x01\x02G\x12\x04\xf0\x01\x084\n\r\n\
    \x05\x05\x01\x02G\x01\x12\x04\xf0\x01\x08.\n\r\n\x05\x05\x01\x02G\x02\
    \x12\x04\xf0\x0113\n\x0c\n\x04\x05\x01\x02H\x12\x04\xf1\x01\x085\n\r\n\
    \x05\x05\x01\x02H\x01\x12\x04\xf1\x01\x08/\n\r\n\x05\x05\x01\x02H\x02\
    \x12\x04\xf1\x0124\n\x0c\n\x04\x05\x01\x02I\x12\x04\xf2\x01\x08<\n\r\n\
    \x05\x05\x01\x02I\x01\x12\x04\xf2\x01\x086\n\r\n\x05\x05\x01\x02I\x02\
    \x12\x04\xf2\x019;\n\x0c\n\x04\x05\x01\x02J\x12\x04\xf3\x01\x083\n\r\n\
    \x05\x05\x01\x02J\x01\x12\x04\xf3\x01\x08-\n\r\n\x05\x05\x01\x02J\x02\
    \x12\x04\xf3\x0102\n\x0c\n\x04\x05\x01\x02K\x12\x04\xf4\x01\x08D\n\r\n\
    \x05\x05\x01\x02K\x01\x12\x04\xf4\x01\x08>\n\r\n\x05\x05\x01\x02K\x02\
    \x12\x04\xf4\x01AC\n\x0c\n\x04\x05\x01\x02L\x12\x04\xf5\x01\x08B\n\r\n\
    \x05\x05\x01\x02L\x01\x12\x04\xf5\x01\x08<\n\r\n\x05\x05\x01\x02L\x02\
    \x12\x04\xf5\x01?A\n\x0c\n\x04\x05\x01\x02M\x12\x04\xf6\x01\x08+\n\r\n\
    \x05\x05\x01\x02M\x01\x12\x04\xf6\x01\x08%\n\r\n\x05\x05\x01\x02M\x02\
    \x12\x04\xf6\x01(*\n\x0c\n\x04\x05\x01\x02N\x12\x04\xf7\x01\x084\n\r\n\
    \x05\x05\x01\x02N\x01\x12\x04\xf7\x01\x08.\n\r\n\x05\x05\x01\x02N\x02\
    \x12\x04\xf7\x0113\n\x0c\n\x04\x05\x01\x02O\x12\x04\xf8\x01\x08,\n\r\n\
    \x05\x05\x01\x02O\x01\x12\x04\xf8\x01\x08&\n\r\n\x05\x05\x01\x02O\x02\
    \x12\x04\xf8\x01)+\n\x0c\n\x04\x05\x01\x02P\x12\x04\xf9\x01\x08+\n\r\n\
    \x05\x05\x01\x02P\x01\x12\x04\xf9\x01\x08%\n\r\n\x05\x05\x01\x02P\x02\
    \x12\x04\xf9\x01(*\n\x0c\n\x04\x05\x01\x02Q\x12\x04\xfa\x01\x08*\n\r\n\
    \x05\x05\x01\x02Q\x01\x12\x04\xfa\x01\x08$\n\r\n\x05\x05\x01\x02Q\x02\
    \x12\x04\xfa\x01')\n\x0c\n\x04\x05\x01\x02R\x12\x04\xfb\x01\x08A\n\r\n\
    \x05\x05\x01\x02R\x01\x12\x04\xfb\x01\x08;\n\r\n\x05\x05\x01\x02R\x02\
    \x12\x04\xfb\x01>@\n\x0c\n\x04\x05\x01\x02S\x12\x04\xfc\x01\x08&\n\r\n\
    \x05\x05\x01\x02S\x01\x12\x04\xfc\x01\x08\x20\n\r\n\x05\x05\x01\x02S\x02\
    \x12\x04\xfc\x01#%\n\x0c\n\x04\x05\x01\x02T\x12\x04\xfd\x01\x085\n\r\n\
    \x05\x05\x01\x02T\x01\x12\x04\xfd\x01\x08/\n\r\n\x05\x05\x01\x02T\x02\
    \x12\x04\xfd\x0124\n\x0c\n\x04\x05\x01\x02U\x12\x04\xfe\x01\x08,\n\r\n\
    \x05\x05\x01\x02U\x01\x12\x04\xfe\x01\x08&\n\r\n\x05\x05\x01\x02U\x02\
    \x12\x04\xfe\x01)+\n\x0c\n\x04\x05\x01\x02V\x12\x04\xff\x01\x08*\n\r\n\
    \x05\x05\x01\x02V\x01\x12\x04\xff\x01\x08$\n\r\n\x05\x05\x01\x02V\x02\
    \x12\x04\xff\x01')\n\x0c\n\x04\x05\x01\x02W\x12\x04\x80\x02\x08(\n\r\n\
    \x05\x05\x01\x02W\x01\x12\x04\x80\x02\x08\"\n\r\n\x05\x05\x01\x02W\x02\
    \x12\x04\x80\x02%'\n\x0c\n\x04\x05\x01\x02X\x12\x04\x81\x02\x08-\n\r\n\
    \x05\x05\x01\x02X\x01\x12\x04\x81\x02\x08'\n\r\n\x05\x05\x01\x02X\x02\
    \x12\x04\x81\x02*,\n\x0c\n\x04\x05\x01\x02Y\x12\x04\x82\x02\x08&\n\r\n\
    \x05\x05\x01\x02Y\x01\x12\x04\x82\x02\x08\x20\n\r\n\x05\x05\x01\x02Y\x02\
    \x12\x04\x82\x02#%\n\x0c\n\x04\x05\x01\x02Z\x12\x04\x83\x02\x08)\n\r\n\
    \x05\x05\x01\x02Z\x01\x12\x04\x83\x02\x08#\n\r\n\x05\x05\x01\x02Z\x02\
    \x12\x04\x83\x02&(\n\x0c\n\x04\x05\x01\x02[\x12\x04\x84\x02\x08(\n\r\n\
    \x05\x05\x01\x02[\x01\x12\x04\x84\x02\x08\"\n\r\n\x05\x05\x01\x02[\x02\
    \x12\x04\x84\x02%'\n\x0c\n\x04\x05\x01\x02\\\x12\x04\x85\x02\x08%\n\r\n\
    \x05\x05\x01\x02\\\x01\x12\x04\x85\x02\x08\x1e\n\r\n\x05\x05\x01\x02\\\
    \x02\x12\x04\x85\x02!$\n\x0c\n\x04\x05\x01\x02]\x12\x04\x86\x02\x08)\n\r\
    \n\x05\x05\x01\x02]\x01\x12\x04\x86\x02\x08\"\n\r\n\x05\x05\x01\x02]\x02\
    \x12\x04\x86\x02%(\n\x0c\n\x04\x05\x01\x02^\x12\x04\x87\x02\x08-\n\r\n\
    \x05\x05\x01\x02^\x01\x12\x04\x87\x02\x08&\n\r\n\x05\x05\x01\x02^\x02\
    \x12\x04\x87\x02),\n\x0c\n\x04\x05\x01\x02_\x12\x04\x88\x02\x08&\n\r\n\
    \x05\x05\x01\x02_\x01\x12\x04\x88\x02\x08\x1f\n\r\n\x05\x05\x01\x02_\x02\
    \x12\x04\x88\x02\"%\n\x0c\n\x04\x05\x01\x02`\x12\x04\x89\x02\x08/\n\r\n\
    \x05\x05\x01\x02`\x01\x12\x04\x89\x02\x08(\n\r\n\x05\x05\x01\x02`\x02\
    \x12\x04\x89\x02+.\n\x0c\n\x04\x05\x01\x02a\x12\x04\x8a\x02\x080\n\r\n\
    \x05\x05\x01\x02a\x01\x12\x04\x8a\x02\x08)\n\r\n\x05\x05\x01\x02a\x02\
    \x12\x04\x8a\x02,/\n\x0c\n\x04\x05\x01\x02b\x12\x04\x8b\x02\x08.\n\r\n\
    \x05\x05\x01\x02b\x01\x12\x04\x8b\x02\x08'\n\r\n\x05\x05\x01\x02b\x02\
    \x12\x04\x8b\x02*-\n\x0c\n\x04\x05\x01\x02c\x12\x04\x8c\x02\x088\n\r\n\
    \x05\x05\x01\x02c\x01\x12\x04\x8c\x02\x081\n\r\n\x05\x05\x01\x02c\x02\
    \x12\x04\x8c\x0247\n\x0c\n\x04\x05\x01\x02d\x12\x04\x8d\x02\x08/\n\r\n\
    \x05\x05\x01\x02d\x01\x12\x04\x8d\x02\x08(\n\r\n\x05\x05\x01\x02d\x02\
    \x12\x04\x8d\x02+.\n\x0c\n\x04\x05\x01\x02e\x12\x04\x8e\x02\x08\"\n\r\n\
    \x05\x05\x01\x02e\x01\x12\x04\x8e\x02\x08\x1b\n\r\n\x05\x05\x01\x02e\x02\
    \x12\x04\x8e\x02\x1e!\n\x0c\n\x04\x05\x01\x02f\x12\x04\x8f\x02\x08/\n\r\
    \n\x05\x05\x01\x02f\x01\x12\x04\x8f\x02\x08(\n\r\n\x05\x05\x01\x02f\x02\
    \x12\x04\x8f\x02+.\n\x0c\n\x04\x05\x01\x02g\x12\x04\x90\x02\x08,\n\r\n\
    \x05\x05\x01\x02g\x01\x12\x04\x90\x02\x08%\n\r\n\x05\x05\x01\x02g\x02\
    \x12\x04\x90\x02(+\n\x0c\n\x04\x05\x01\x02h\x12\x04\x91\x02\x082\n\r\n\
    \x05\x05\x01\x02h\x01\x12\x04\x91\x02\x08+\n\r\n\x05\x05\x01\x02h\x02\
    \x12\x04\x91\x02.1\n\x0c\n\x04\x05\x01\x02i\x12\x04\x92\x02\x083\n\r\n\
    \x05\x05\x01\x02i\x01\x12\x04\x92\x02\x08,\n\r\n\x05\x05\x01\x02i\x02\
    \x12\x04\x92\x02/2\n\x0c\n\x04\x05\x01\x02j\x12\x04\x93\x02\x080\n\r\n\
    \x05\x05\x01\x02j\x01\x12\x04\x93\x02\x08)\n\r\n\x05\x05\x01\x02j\x02\
    \x12\x04\x93\x02,/\n\x0c\n\x04\x05\x01\x02k\x12\x04\x94\x02\x082\n\r\n\
    \x05\x05\x01\x02k\x01\x12\x04\x94\x02\x08+\n\r\n\x05\x05\x01\x02k\x02\
    \x12\x04\x94\x02.1\n\x0c\n\x02\x05\x02\x12\x06\x97\x02\0\x9c\x02\x01\n\
    \x0b\n\x03\x05\x02\x01\x12\x04\x97\x02\x05\"\n\x0c\n\x04\x05\x02\x02\0\
    \x12\x04\x98\x02\x08.\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\x98\x02\x08)\n\
    \r\n\x05\x05\x02\x02\0\x02\x12\x04\x98\x02,-\n\x0c\n\x04\x05\x02\x02\x01\
    \x12\x04\x99\x02\x08+\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\x99\x02\x08&\
    \n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\x99\x02)*\n\x0c\n\x04\x05\x02\x02\
    \x02\x12\x04\x9a\x02\x08,\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\x9a\x02\
    \x08'\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\x9a\x02*+\n\x0c\n\x04\x05\
    \x02\x02\x03\x12\x04\x9b\x02\x08*\n\r\n\x05\x05\x02\x02\x03\x01\x12\x04\
    \x9b\x02\x08%\n\r\n\x05\x05\x02\x02\x03\x02\x12\x04\x9b\x02()\n\x0c\n\
    \x02\x05\x03\x12\x06\x9e\x02\0\xa4\x02\x01\n\x0b\n\x03\x05\x03\x01\x12\
    \x04\x9e\x02\x05\x1c\n\x0c\n\x04\x05\x03\x02\0\x12\x04\x9f\x02\x08*\n\r\
    \n\x05\x05\x03\x02\0\x01\x12\x04\x9f\x02\x08%\n\r\n\x05\x05\x03\x02\0\
    \x02\x12\x04\x9f\x02()\n\x0c\n\x04\x05\x03\x02\x01\x12\x04\xa0\x02\x08,\
    \n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\xa0\x02\x08'\n\r\n\x05\x05\x03\
    \x02\x01\x02\x12\x04\xa0\x02*+\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\xa1\
    \x02\x08!\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\xa1\x02\x08\x1c\n\r\n\
    \x05\x05\x03\x02\x02\x02\x12\x04\xa1\x02\x1f\x20\n\x0c\n\x04\x05\x03\x02\
    \x03\x12\x04\xa2\x02\x084\n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\xa2\x02\
    \x08/\n\r\n\x05\x05\x03\x02\x03\x02\x12\x04\xa2\x0223\n\x0c\n\x04\x05\
    \x03\x02\x04\x12\x04\xa3\x02\x08.\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\
    \xa3\x02\x08)\n\r\n\x05\x05\x03\x02\x04\x02\x12\x04\xa3\x02,-\n\x0c\n\
    \x02\x05\x04\x12\x06\xa6\x02\0\xb7\x02\x01\n\x0b\n\x03\x05\x04\x01\x12\
    \x04\xa6\x02\x05\x1b\n\x0c\n\x04\x05\x04\x02\0\x12\x04\xa7\x02\x08\x1f\n\
    \r\n\x05\x05\x04\x02\0\x01\x12\x04\xa7\x02\x08\x1a\n\r\n\x05\x05\x04\x02\
    \0\x02\x12\x04\xa7\x02\x1d\x1e\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\xa8\
    \x02\x08\x1e\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\xa8\x02\x08\x19\n\r\n\
    \x05\x05\x04\x02\x01\x02\x12\x04\xa8\x02\x1c\x1d\n\x0c\n\x04\x05\x04\x02\
    \x02\x12\x04\xa9\x02\x08\"\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xa9\x02\
    \x08\x1d\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\xa9\x02\x20!\n\x0c\n\x04\
    \x05\x04\x02\x03\x12\x04\xaa\x02\x08\x1f\n\r\n\x05\x05\x04\x02\x03\x01\
    \x12\x04\xaa\x02\x08\x1a\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\xaa\x02\
    \x1d\x1e\n\x0c\n\x04\x05\x04\x02\x04\x12\x04\xab\x02\x08#\n\r\n\x05\x05\
    \x04\x02\x04\x01\x12\x04\xab\x02\x08\x1e\n\r\n\x05\x05\x04\x02\x04\x02\
    \x12\x04\xab\x02!\"\n\x0c\n\x04\x05\x04\x02\x05\x12\x04\xac\x02\x08$\n\r\
    \n\x05\x05\x04\x02\x05\x01\x12\x04\xac\x02\x08\x1f\n\r\n\x05\x05\x04\x02\
    \x05\x02\x12\x04\xac\x02\"#\n\x0c\n\x04\x05\x04\x02\x06\x12\x04\xad\x02\
    \x08!\n\r\n\x05\x05\x04\x02\x06\x01\x12\x04\xad\x02\x08\x1c\n\r\n\x05\
    \x05\x04\x02\x06\x02\x12\x04\xad\x02\x1f\x20\n\x0c\n\x04\x05\x04\x02\x07\
    \x12\x04\xae\x02\x08#\n\r\n\x05\x05\x04\x02\x07\x01\x12\x04\xae\x02\x08\
    \x1e\n\r\n\x05\x05\x04\x02\x07\x02\x12\x04\xae\x02!\"\n\x0c\n\x04\x05\
    \x04\x02\x08\x12\x04\xaf\x02\x08\x1e\n\r\n\x05\x05\x04\x02\x08\x01\x12\
    \x04\xaf\x02\x08\x19\n\r\n\x05\x05\x04\x02\x08\x02\x12\x04\xaf\x02\x1c\
    \x1d\n\x0c\n\x04\x05\x04\x02\t\x12\x04\xb0\x02\x08&\n\r\n\x05\x05\x04\
    \x02\t\x01\x12\x04\xb0\x02\x08\x20\n\r\n\x05\x05\x04\x02\t\x02\x12\x04\
    \xb0\x02#%\n\x0c\n\x04\x05\x04\x02\n\x12\x04\xb1\x02\x08%\n\r\n\x05\x05\
    \x04\x02\n\x01\x12\x04\xb1\x02\x08\x1f\n\r\n\x05\x05\x04\x02\n\x02\x12\
    \x04\xb1\x02\"$\n\x0c\n\x04\x05\x04\x02\x0b\x12\x04\xb2\x02\x08'\n\r\n\
    \x05\x05\x04\x02\x0b\x01\x12\x04\xb2\x02\x08!\n\r\n\x05\x05\x04\x02\x0b\
    \x02\x12\x04\xb2\x02$&\n\x0c\n\x04\x05\x04\x02\x0c\x12\x04\xb3\x02\x08(\
    \n\r\n\x05\x05\x04\x02\x0c\x01\x12\x04\xb3\x02\x08\"\n\r\n\x05\x05\x04\
    \x02\x0c\x02\x12\x04\xb3\x02%'\n\x0c\n\x04\x05\x04\x02\r\x12\x04\xb4\x02\
    \x08*\n\r\n\x05\x05\x04\x02\r\x01\x12\x04\xb4\x02\x08$\n\r\n\x05\x05\x04\
    \x02\r\x02\x12\x04\xb4\x02')\n\x0c\n\x04\x05\x04\x02\x0e\x12\x04\xb5\x02\
    \x08(\n\r\n\x05\x05\x04\x02\x0e\x01\x12\x04\xb5\x02\x08\"\n\r\n\x05\x05\
    \x04\x02\x0e\x02\x12\x04\xb5\x02%'\n\x0c\n\x04\x05\x04\x02\x0f\x12\x04\
    \xb6\x02\x08,\n\r\n\x05\x05\x04\x02\x0f\x01\x12\x04\xb6\x02\x08&\n\r\n\
    \x05\x05\x04\x02\x0f\x02\x12\x04\xb6\x02)+\n\x0c\n\x02\x05\x05\x12\x06\
    \xb9\x02\0\xc0\x02\x01\n\x0b\n\x03\x05\x05\x01\x12\x04\xb9\x02\x05\x1c\n\
    \x0c\n\x04\x05\x05\x02\0\x12\x04\xba\x02\x08/\n\r\n\x05\x05\x05\x02\0\
    \x01\x12\x04\xba\x02\x08*\n\r\n\x05\x05\x05\x02\0\x02\x12\x04\xba\x02-.\
    \n\x0c\n\x04\x05\x05\x02\x01\x12\x04\xbb\x02\x082\n\r\n\x05\x05\x05\x02\
    \x01\x01\x12\x04\xbb\x02\x08-\n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\xbb\
    \x0201\n\x0c\n\x04\x05\x05\x02\x02\x12\x04\xbc\x02\x080\n\r\n\x05\x05\
    \x05\x02\x02\x01\x12\x04\xbc\x02\x08+\n\r\n\x05\x05\x05\x02\x02\x02\x12\
    \x04\xbc\x02./\n\x0c\n\x04\x05\x05\x02\x03\x12\x04\xbd\x02\x08-\n\r\n\
    \x05\x05\x05\x02\x03\x01\x12\x04\xbd\x02\x08(\n\r\n\x05\x05\x05\x02\x03\
    \x02\x12\x04\xbd\x02+,\n\x0c\n\x04\x05\x05\x02\x04\x12\x04\xbe\x02\x08.\
    \n\r\n\x05\x05\x05\x02\x04\x01\x12\x04\xbe\x02\x08)\n\r\n\x05\x05\x05\
    \x02\x04\x02\x12\x04\xbe\x02,-\n\x0c\n\x04\x05\x05\x02\x05\x12\x04\xbf\
    \x02\x081\n\r\n\x05\x05\x05\x02\x05\x01\x12\x04\xbf\x02\x08,\n\r\n\x05\
    \x05\x05\x02\x05\x02\x12\x04\xbf\x02/0\n\x0c\n\x02\x05\x06\x12\x06\xc2\
    \x02\0\xca\x02\x01\n\x0b\n\x03\x05\x06\x01\x12\x04\xc2\x02\x05\x18\n\x0c\
    \n\x04\x05\x06\x02\0\x12\x04\xc3\x02\x08\x1d\n\r\n\x05\x05\x06\x02\0\x01\
    \x12\x04\xc3\x02\x08\x18\n\r\n\x05\x05\x06\x02\0\x02\x12\x04\xc3\x02\x1b\
    \x1c\n\x0c\n\x04\x05\x06\x02\x01\x12\x04\xc4\x02\x08\"\n\r\n\x05\x05\x06\
    \x02\x01\x01\x12\x04\xc4\x02\x08\x1d\n\r\n\x05\x05\x06\x02\x01\x02\x12\
    \x04\xc4\x02\x20!\n\x0c\n\x04\x05\x06\x02\x02\x12\x04\xc5\x02\x08\"\n\r\
    \n\x05\x05\x06\x02\x02\x01\x12\x04\xc5\x02\x08\x1d\n\r\n\x05\x05\x06\x02\
    \x02\x02\x12\x04\xc5\x02\x20!\n\x0c\n\x04\x05\x06\x02\x03\x12\x04\xc6\
    \x02\x08%\n\r\n\x05\x05\x06\x02\x03\x01\x12\x04\xc6\x02\x08\x20\n\r\n\
    \x05\x05\x06\x02\x03\x02\x12\x04\xc6\x02#$\n\x0c\n\x04\x05\x06\x02\x04\
    \x12\x04\xc7\x02\x08*\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\xc7\x02\x08%\
    \n\r\n\x05\x05\x06\x02\x04\x02\x12\x04\xc7\x02()\n\x0c\n\x04\x05\x06\x02\
    \x05\x12\x04\xc8\x02\x08#\n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\xc8\x02\
    \x08\x1e\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\xc8\x02!\"\n\x0c\n\x04\
    \x05\x06\x02\x06\x12\x04\xc9\x02\x08.\n\r\n\x05\x05\x06\x02\x06\x01\x12\
    \x04\xc9\x02\x08)\n\r\n\x05\x05\x06\x02\x06\x02\x12\x04\xc9\x02,-\n\x0c\
    \n\x02\x05\x07\x12\x06\xcc\x02\0\xe6\x02\x01\n\x0b\n\x03\x05\x07\x01\x12\
    \x04\xcc\x02\x05\x18\n\x0c\n\x04\x05\x07\x02\0\x12\x04\xcd\x02\x08\x20\n\
    \r\n\x05\x05\x07\x02\0\x01\x12\x04\xcd\x02\x08\x1b\n\r\n\x05\x05\x07\x02\
    \0\x02\x12\x04\xcd\x02\x1e\x1f\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\xce\
    \x02\x08\x20\n\r\n\x05\x05\x07\x02\x01\x01\x12\x04\xce\x02\x08\x1b\n\r\n\
    \x05\x05\x07\x02\x01\x02\x12\x04\xce\x02\x1e\x1f\n\x0c\n\x04\x05\x07\x02\
    \x02\x12\x04\xcf\x02\x08$\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\xcf\x02\
    \x08\x1f\n\r\n\x05\x05\x07\x02\x02\x02\x12\x04\xcf\x02\"#\n\x0c\n\x04\
    \x05\x07\x02\x03\x12\x04\xd0\x02\x08\x1e\n\r\n\x05\x05\x07\x02\x03\x01\
    \x12\x04\xd0\x02\x08\x19\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\xd0\x02\
    \x1c\x1d\n\x0c\n\x04\x05\x07\x02\x04\x12\x04\xd1\x02\x08.\n\r\n\x05\x05\
    \x07\x02\x04\x01\x12\x04\xd1\x02\x08)\n\r\n\x05\x05\x07\x02\x04\x02\x12\
    \x04\xd1\x02,-\n\x0c\n\x04\x05\x07\x02\x05\x12\x04\xd2\x02\x08\x20\n\r\n\
    \x05\x05\x07\x02\x05\x01\x12\x04\xd2\x02\x08\x1b\n\r\n\x05\x05\x07\x02\
    \x05\x02\x12\x04\xd2\x02\x1e\x1f\n\x0c\n\x04\x05\x07\x02\x06\x12\x04\xd3\
    \x02\x08\"\n\r\n\x05\x05\x07\x02\x06\x01\x12\x04\xd3\x02\x08\x1d\n\r\n\
    \x05\x05\x07\x02\x06\x02\x12\x04\xd3\x02\x20!\n\x0c\n\x04\x05\x07\x02\
    \x07\x12\x04\xd4\x02\x08!\n\r\n\x05\x05\x07\x02\x07\x01\x12\x04\xd4\x02\
    \x08\x1c\n\r\n\x05\x05\x07\x02\x07\x02\x12\x04\xd4\x02\x1f\x20\n\x0c\n\
    \x04\x05\x07\x02\x08\x12\x04\xd5\x02\x08!\n\r\n\x05\x05\x07\x02\x08\x01\
    \x12\x04\xd5\x02\x08\x1c\n\r\n\x05\x05\x07\x02\x08\x02\x12\x04\xd5\x02\
    \x1f\x20\n\x0c\n\x04\x05\x07\x02\t\x12\x04\xd6\x02\x08/\n\r\n\x05\x05\
    \x07\x02\t\x01\x12\x04\xd6\x02\x08*\n\r\n\x05\x05\x07\x02\t\x02\x12\x04\
    \xd6\x02-.\n\x0c\n\x04\x05\x07\x02\n\x12\x04\xd7\x02\x08!\n\r\n\x05\x05\
    \x07\x02\n\x01\x12\x04\xd7\x02\x08\x1b\n\r\n\x05\x05\x07\x02\n\x02\x12\
    \x04\xd7\x02\x1e\x20\n\x0c\n\x04\x05\x07\x02\x0b\x12\x04\xd8\x02\x08%\n\
    \r\n\x05\x05\x07\x02\x0b\x01\x12\x04\xd8\x02\x08\x1f\n\r\n\x05\x05\x07\
    \x02\x0b\x02\x12\x04\xd8\x02\"$\n\x0c\n\x04\x05\x07\x02\x0c\x12\x04\xd9\
    \x02\x08&\n\r\n\x05\x05\x07\x02\x0c\x01\x12\x04\xd9\x02\x08\x20\n\r\n\
    \x05\x05\x07\x02\x0c\x02\x12\x04\xd9\x02#%\n\x0c\n\x04\x05\x07\x02\r\x12\
    \x04\xda\x02\x08+\n\r\n\x05\x05\x07\x02\r\x01\x12\x04\xda\x02\x08%\n\r\n\
    \x05\x05\x07\x02\r\x02\x12\x04\xda\x02(*\n\x0c\n\x04\x05\x07\x02\x0e\x12\
    \x04\xdb\x02\x08+\n\r\n\x05\x05\x07\x02\x0e\x01\x12\x04\xdb\x02\x08%\n\r\
    \n\x05\x05\x07\x02\x0e\x02\x12\x04\xdb\x02(*\n\x0c\n\x04\x05\x07\x02\x0f\
    \x12\x04\xdc\x02\x08*\n\r\n\x05\x05\x07\x02\x0f\x01\x12\x04\xdc\x02\x08$\
    \n\r\n\x05\x05\x07\x02\x0f\x02\x12\x04\xdc\x02')\n\x0c\n\x04\x05\x07\x02\
    \x10\x12\x04\xdd\x02\x08*\n\r\n\x05\x05\x07\x02\x10\x01\x12\x04\xdd\x02\
    \x08$\n\r\n\x05\x05\x07\x02\x10\x02\x12\x04\xdd\x02')\n\x0c\n\x04\x05\
    \x07\x02\x11\x12\x04\xde\x02\x08,\n\r\n\x05\x05\x07\x02\x11\x01\x12\x04\
    \xde\x02\x08&\n\r\n\x05\x05\x07\x02\x11\x02\x12\x04\xde\x02)+\n\x0c\n\
    \x04\x05\x07\x02\x12\x12\x04\xdf\x02\x08,\n\r\n\x05\x05\x07\x02\x12\x01\
    \x12\x04\xdf\x02\x08&\n\r\n\x05\x05\x07\x02\x12\x02\x12\x04\xdf\x02)+\n\
    \x0c\n\x04\x05\x07\x02\x13\x12\x04\xe0\x02\x08+\n\r\n\x05\x05\x07\x02\
    \x13\x01\x12\x04\xe0\x02\x08%\n\r\n\x05\x05\x07\x02\x13\x02\x12\x04\xe0\
    \x02(*\n\x0c\n\x04\x05\x07\x02\x14\x12\x04\xe1\x02\x08\"\n\r\n\x05\x05\
    \x07\x02\x14\x01\x12\x04\xe1\x02\x08\x1c\n\r\n\x05\x05\x07\x02\x14\x02\
    \x12\x04\xe1\x02\x1f!\n\x0c\n\x04\x05\x07\x02\x15\x12\x04\xe2\x02\x08$\n\
    \r\n\x05\x05\x07\x02\x15\x01\x12\x04\xe2\x02\x08\x1e\n\r\n\x05\x05\x07\
    \x02\x15\x02\x12\x04\xe2\x02!#\n\x0c\n\x04\x05\x07\x02\x16\x12\x04\xe3\
    \x02\x08*\n\r\n\x05\x05\x07\x02\x16\x01\x12\x04\xe3\x02\x08$\n\r\n\x05\
    \x05\x07\x02\x16\x02\x12\x04\xe3\x02')\n\x0c\n\x04\x05\x07\x02\x17\x12\
    \x04\xe4\x02\x08\"\n\r\n\x05\x05\x07\x02\x17\x01\x12\x04\xe4\x02\x08\x1c\
    \n\r\n\x05\x05\x07\x02\x17\x02\x12\x04\xe4\x02\x1f!\n\x0c\n\x04\x05\x07\
    \x02\x18\x12\x04\xe5\x02\x08(\n\r\n\x05\x05\x07\x02\x18\x01\x12\x04\xe5\
    \x02\x08\"\n\r\n\x05\x05\x07\x02\x18\x02\x12\x04\xe5\x02%'\n\x0c\n\x02\
    \x05\x08\x12\x06\xe8\x02\0\xec\x02\x01\n\x0b\n\x03\x05\x08\x01\x12\x04\
    \xe8\x02\x05\x16\n\x0c\n\x04\x05\x08\x02\0\x12\x04\xe9\x02\x08\x20\n\r\n\
    \x05\x05\x08\x02\0\x01\x12\x04\xe9\x02\x08\x1b\n\r\n\x05\x05\x08\x02\0\
    \x02\x12\x04\xe9\x02\x1e\x1f\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\xea\x02\
    \x08%\n\r\n\x05\x05\x08\x02\x01\x01\x12\x04\xea\x02\x08\x20\n\r\n\x05\
    \x05\x08\x02\x01\x02\x12\x04\xea\x02#$\n\x0c\n\x04\x05\x08\x02\x02\x12\
    \x04\xeb\x02\x08(\n\r\n\x05\x05\x08\x02\x02\x01\x12\x04\xeb\x02\x08#\n\r\
    \n\x05\x05\x08\x02\x02\x02\x12\x04\xeb\x02&'\n\x0c\n\x02\x05\t\x12\x06\
    \xee\x02\0\xff\x02\x01\n\x0b\n\x03\x05\t\x01\x12\x04\xee\x02\x05\x1b\n\
    \x0c\n\x04\x05\t\x02\0\x12\x04\xef\x02\x08\x1f\n\r\n\x05\x05\t\x02\0\x01\
    \x12\x04\xef\x02\x08\x1a\n\r\n\x05\x05\t\x02\0\x02\x12\x04\xef\x02\x1d\
    \x1e\n\x0c\n\x04\x05\t\x02\x01\x12\x04\xf0\x02\x08&\n\r\n\x05\x05\t\x02\
    \x01\x01\x12\x04\xf0\x02\x08!\n\r\n\x05\x05\t\x02\x01\x02\x12\x04\xf0\
    \x02$%\n\x0c\n\x04\x05\t\x02\x02\x12\x04\xf1\x02\x08#\n\r\n\x05\x05\t\
    \x02\x02\x01\x12\x04\xf1\x02\x08\x1e\n\r\n\x05\x05\t\x02\x02\x02\x12\x04\
    \xf1\x02!\"\n\x0c\n\x04\x05\t\x02\x03\x12\x04\xf2\x02\x08#\n\r\n\x05\x05\
    \t\x02\x03\x01\x12\x04\xf2\x02\x08\x1e\n\r\n\x05\x05\t\x02\x03\x02\x12\
    \x04\xf2\x02!\"\n\x0c\n\x04\x05\t\x02\x04\x12\x04\xf3\x02\x08)\n\r\n\x05\
    \x05\t\x02\x04\x01\x12\x04\xf3\x02\x08$\n\r\n\x05\x05\t\x02\x04\x02\x12\
    \x04\xf3\x02'(\n\x0c\n\x04\x05\t\x02\x05\x12\x04\xf4\x02\x08&\n\r\n\x05\
    \x05\t\x02\x05\x01\x12\x04\xf4\x02\x08!\n\r\n\x05\x05\t\x02\x05\x02\x12\
    \x04\xf4\x02$%\n\x0c\n\x04\x05\t\x02\x06\x12\x04\xf5\x02\x08+\n\r\n\x05\
    \x05\t\x02\x06\x01\x12\x04\xf5\x02\x08&\n\r\n\x05\x05\t\x02\x06\x02\x12\
    \x04\xf5\x02)*\n\x0c\n\x04\x05\t\x02\x07\x12\x04\xf6\x02\x08(\n\r\n\x05\
    \x05\t\x02\x07\x01\x12\x04\xf6\x02\x08#\n\r\n\x05\x05\t\x02\x07\x02\x12\
    \x04\xf6\x02&'\n\x0c\n\x04\x05\t\x02\x08\x12\x04\xf7\x02\x08.\n\r\n\x05\
    \x05\t\x02\x08\x01\x12\x04\xf7\x02\x08)\n\r\n\x05\x05\t\x02\x08\x02\x12\
    \x04\xf7\x02,-\n\x0c\n\x04\x05\t\x02\t\x12\x04\xf8\x02\x08+\n\r\n\x05\
    \x05\t\x02\t\x01\x12\x04\xf8\x02\x08&\n\r\n\x05\x05\t\x02\t\x02\x12\x04\
    \xf8\x02)*\n\x0c\n\x04\x05\t\x02\n\x12\x04\xf9\x02\x08!\n\r\n\x05\x05\t\
    \x02\n\x01\x12\x04\xf9\x02\x08\x1b\n\r\n\x05\x05\t\x02\n\x02\x12\x04\xf9\
    \x02\x1e\x20\n\x0c\n\x04\x05\t\x02\x0b\x12\x04\xfa\x02\x08&\n\r\n\x05\
    \x05\t\x02\x0b\x01\x12\x04\xfa\x02\x08\x20\n\r\n\x05\x05\t\x02\x0b\x02\
    \x12\x04\xfa\x02#%\n\x0c\n\x04\x05\t\x02\x0c\x12\x04\xfb\x02\x08(\n\r\n\
    \x05\x05\t\x02\x0c\x01\x12\x04\xfb\x02\x08\"\n\r\n\x05\x05\t\x02\x0c\x02\
    \x12\x04\xfb\x02%'\n\x0c\n\x04\x05\t\x02\r\x12\x04\xfc\x02\x08%\n\r\n\
    \x05\x05\t\x02\r\x01\x12\x04\xfc\x02\x08\x1f\n\r\n\x05\x05\t\x02\r\x02\
    \x12\x04\xfc\x02\"$\n\x0c\n\x04\x05\t\x02\x0e\x12\x04\xfd\x02\x08$\n\r\n\
    \x05\x05\t\x02\x0e\x01\x12\x04\xfd\x02\x08\x1e\n\r\n\x05\x05\t\x02\x0e\
    \x02\x12\x04\xfd\x02!#\n\x0c\n\x04\x05\t\x02\x0f\x12\x04\xfe\x02\x08!\n\
    \r\n\x05\x05\t\x02\x0f\x01\x12\x04\xfe\x02\x08\x1b\n\r\n\x05\x05\t\x02\
    \x0f\x02\x12\x04\xfe\x02\x1e\x20\n\x0c\n\x02\x05\n\x12\x06\x81\x03\0\x88\
    \x03\x01\n\x0b\n\x03\x05\n\x01\x12\x04\x81\x03\x05\x1d\n\x0c\n\x04\x05\n\
    \x02\0\x12\x04\x82\x03\x08%\n\r\n\x05\x05\n\x02\0\x01\x12\x04\x82\x03\
    \x08\x20\n\r\n\x05\x05\n\x02\0\x02\x12\x04\x82\x03#$\n\x0c\n\x04\x05\n\
    \x02\x01\x12\x04\x83\x03\x08%\n\r\n\x05\x05\n\x02\x01\x01\x12\x04\x83\
    \x03\x08\x20\n\r\n\x05\x05\n\x02\x01\x02\x12\x04\x83\x03#$\n\x0c\n\x04\
    \x05\n\x02\x02\x12\x04\x84\x03\x08*\n\r\n\x05\x05\n\x02\x02\x01\x12\x04\
    \x84\x03\x08%\n\r\n\x05\x05\n\x02\x02\x02\x12\x04\x84\x03()\n\x0c\n\x04\
    \x05\n\x02\x03\x12\x04\x85\x03\x08+\n\r\n\x05\x05\n\x02\x03\x01\x12\x04\
    \x85\x03\x08&\n\r\n\x05\x05\n\x02\x03\x02\x12\x04\x85\x03)*\n\x0c\n\x04\
    \x05\n\x02\x04\x12\x04\x86\x03\x08+\n\r\n\x05\x05\n\x02\x04\x01\x12\x04\
    \x86\x03\x08&\n\r\n\x05\x05\n\x02\x04\x02\x12\x04\x86\x03)*\n\x0c\n\x04\
    \x05\n\x02\x05\x12\x04\x87\x03\x08,\n\r\n\x05\x05\n\x02\x05\x01\x12\x04\
    \x87\x03\x08'\n\r\n\x05\x05\n\x02\x05\x02\x12\x04\x87\x03*+\n\x0c\n\x02\
    \x05\x0b\x12\x06\x8a\x03\0\xa1\x03\x01\n\x0b\n\x03\x05\x0b\x01\x12\x04\
    \x8a\x03\x05\x12\n\x0c\n\x04\x05\x0b\x02\0\x12\x04\x8b\x03\x08!\n\r\n\
    \x05\x05\x0b\x02\0\x01\x12\x04\x8b\x03\x08\x1c\n\r\n\x05\x05\x0b\x02\0\
    \x02\x12\x04\x8b\x03\x1f\x20\n\x0c\n\x04\x05\x0b\x02\x01\x12\x04\x8c\x03\
    \x08.\n\r\n\x05\x05\x0b\x02\x01\x01\x12\x04\x8c\x03\x08&\n\r\n\x05\x05\
    \x0b\x02\x01\x02\x12\x04\x8c\x03)-\n\x0c\n\x04\x05\x0b\x02\x02\x12\x04\
    \x8d\x03\x082\n\r\n\x05\x05\x0b\x02\x02\x01\x12\x04\x8d\x03\x08*\n\r\n\
    \x05\x05\x0b\x02\x02\x02\x12\x04\x8d\x03-1\n\x0c\n\x04\x05\x0b\x02\x03\
    \x12\x04\x8e\x03\x082\n\r\n\x05\x05\x0b\x02\x03\x01\x12\x04\x8e\x03\x08*\
    \n\r\n\x05\x05\x0b\x02\x03\x02\x12\x04\x8e\x03-1\n\x0c\n\x04\x05\x0b\x02\
    \x04\x12\x04\x8f\x03\x082\n\r\n\x05\x05\x0b\x02\x04\x01\x12\x04\x8f\x03\
    \x08*\n\r\n\x05\x05\x0b\x02\x04\x02\x12\x04\x8f\x03-1\n\x0c\n\x04\x05\
    \x0b\x02\x05\x12\x04\x90\x03\x087\n\r\n\x05\x05\x0b\x02\x05\x01\x12\x04\
    \x90\x03\x08/\n\r\n\x05\x05\x0b\x02\x05\x02\x12\x04\x90\x0326\n\x0c\n\
    \x04\x05\x0b\x02\x06\x12\x04\x91\x03\x08>\n\r\n\x05\x05\x0b\x02\x06\x01\
    \x12\x04\x91\x03\x086\n\r\n\x05\x05\x0b\x02\x06\x02\x12\x04\x91\x039=\n\
    \x0c\n\x04\x05\x0b\x02\x07\x12\x04\x92\x03\x08;\n\r\n\x05\x05\x0b\x02\
    \x07\x01\x12\x04\x92\x03\x083\n\r\n\x05\x05\x0b\x02\x07\x02\x12\x04\x92\
    \x036:\n\x0c\n\x04\x05\x0b\x02\x08\x12\x04\x93\x03\x08>\n\r\n\x05\x05\
    \x0b\x02\x08\x01\x12\x04\x93\x03\x086\n\r\n\x05\x05\x0b\x02\x08\x02\x12\
    \x04\x93\x039=\n\x0c\n\x04\x05\x0b\x02\t\x12\x04\x94\x03\x08?\n\r\n\x05\
    \x05\x0b\x02\t\x01\x12\x04\x94\x03\x087\n\r\n\x05\x05\x0b\x02\t\x02\x12\
    \x04\x94\x03:>\n\x0c\n\x04\x05\x0b\x02\n\x12\x04\x95\x03\x085\n\r\n\x05\
    \x05\x0b\x02\n\x01\x12\x04\x95\x03\x08-\n\r\n\x05\x05\x0b\x02\n\x02\x12\
    \x04\x95\x0304\n\x0c\n\x04\x05\x0b\x02\x0b\x12\x04\x96\x03\x08=\n\r\n\
    \x05\x05\x0b\x02\x0b\x01\x12\x04\x96\x03\x085\n\r\n\x05\x05\x0b\x02\x0b\
    \x02\x12\x04\x96\x038<\n\x0c\n\x04\x05\x0b\x02\x0c\x12\x04\x97\x03\x08;\
    \n\r\n\x05\x05\x0b\x02\x0c\x01\x12\x04\x97\x03\x083\n\r\n\x05\x05\x0b\
    \x02\x0c\x02\x12\x04\x97\x036:\n\x0c\n\x04\x05\x0b\x02\r\x12\x04\x98\x03\
    \x085\n\r\n\x05\x05\x0b\x02\r\x01\x12\x04\x98\x03\x08-\n\r\n\x05\x05\x0b\
    \x02\r\x02\x12\x04\x98\x0304\n\x0c\n\x04\x05\x0b\x02\x0e\x12\x04\x99\x03\
    \x089\n\r\n\x05\x05\x0b\x02\x0e\x01\x12\x04\x99\x03\x081\n\r\n\x05\x05\
    \x0b\x02\x0e\x02\x12\x04\x99\x0348\n\x0c\n\x04\x05\x0b\x02\x0f\x12\x04\
    \x9a\x03\x08<\n\r\n\x05\x05\x0b\x02\x0f\x01\x12\x04\x9a\x03\x084\n\r\n\
    \x05\x05\x0b\x02\x0f\x02\x12\x04\x9a\x037;\n\x0c\n\x04\x05\x0b\x02\x10\
    \x12\x04\x9b\x03\x08>\n\r\n\x05\x05\x0b\x02\x10\x01\x12\x04\x9b\x03\x086\
    \n\r\n\x05\x05\x0b\x02\x10\x02\x12\x04\x9b\x039=\n\x0c\n\x04\x05\x0b\x02\
    \x11\x12\x04\x9c\x03\x085\n\r\n\x05\x05\x0b\x02\x11\x01\x12\x04\x9c\x03\
    \x08-\n\r\n\x05\x05\x0b\x02\x11\x02\x12\x04\x9c\x0304\n\x0c\n\x04\x05\
    \x0b\x02\x12\x12\x04\x9d\x03\x085\n\r\n\x05\x05\x0b\x02\x12\x01\x12\x04\
    \x9d\x03\x08-\n\r\n\x05\x05\x0b\x02\x12\x02\x12\x04\x9d\x0304\n\x0c\n\
    \x04\x05\x0b\x02\x13\x12\x04\x9e\x03\x08?\n\r\n\x05\x05\x0b\x02\x13\x01\
    \x12\x04\x9e\x03\x087\n\r\n\x05\x05\x0b\x02\x13\x02\x12\x04\x9e\x03:>\n\
    \x0c\n\x04\x05\x0b\x02\x14\x12\x04\x9f\x03\x08B\n\r\n\x05\x05\x0b\x02\
    \x14\x01\x12\x04\x9f\x03\x08:\n\r\n\x05\x05\x0b\x02\x14\x02\x12\x04\x9f\
    \x03=A\n\x0c\n\x04\x05\x0b\x02\x15\x12\x04\xa0\x03\x08;\n\r\n\x05\x05\
    \x0b\x02\x15\x01\x12\x04\xa0\x03\x083\n\r\n\x05\x05\x0b\x02\x15\x02\x12\
    \x04\xa0\x036:\n\x0c\n\x02\x05\x0c\x12\x06\xa3\x03\0\xb8\x03\x01\n\x0b\n\
    \x03\x05\x0c\x01\x12\x04\xa3\x03\x05\x1c\n\x0c\n\x04\x05\x0c\x02\0\x12\
    \x04\xa4\x03\x08\x17\n\r\n\x05\x05\x0c\x02\0\x01\x12\x04\xa4\x03\x08\x12\
    \n\r\n\x05\x05\x0c\x02\0\x02\x12\x04\xa4\x03\x15\x16\n\x0c\n\x04\x05\x0c\
    \x02\x01\x12\x04\xa5\x03\x08#\n\r\n\x05\x05\x0c\x02\x01\x01\x12\x04\xa5\
    \x03\x08\x1e\n\r\n\x05\x05\x0c\x02\x01\x02\x12\x04\xa5\x03!\"\n\x0c\n\
    \x04\x05\x0c\x02\x02\x12\x04\xa6\x03\x08\x20\n\r\n\x05\x05\x0c\x02\x02\
    \x01\x12\x04\xa6\x03\x08\x1b\n\r\n\x05\x05\x0c\x02\x02\x02\x12\x04\xa6\
    \x03\x1e\x1f\n\x0c\n\x04\x05\x0c\x02\x03\x12\x04\xa7\x03\x08/\n\r\n\x05\
    \x05\x0c\x02\x03\x01\x12\x04\xa7\x03\x08*\n\r\n\x05\x05\x0c\x02\x03\x02\
    \x12\x04\xa7\x03-.\n\x0c\n\x04\x05\x0c\x02\x04\x12\x04\xa8\x03\x08-\n\r\
    \n\x05\x05\x0c\x02\x04\x01\x12\x04\xa8\x03\x08(\n\r\n\x05\x05\x0c\x02\
    \x04\x02\x12\x04\xa8\x03+,\n\x0c\n\x04\x05\x0c\x02\x05\x12\x04\xa9\x03\
    \x081\n\r\n\x05\x05\x0c\x02\x05\x01\x12\x04\xa9\x03\x08,\n\r\n\x05\x05\
    \x0c\x02\x05\x02\x12\x04\xa9\x03/0\n\x0c\n\x04\x05\x0c\x02\x06\x12\x04\
    \xaa\x03\x08&\n\r\n\x05\x05\x0c\x02\x06\x01\x12\x04\xaa\x03\x08!\n\r\n\
    \x05\x05\x0c\x02\x06\x02\x12\x04\xaa\x03$%\n\x0c\n\x04\x05\x0c\x02\x07\
    \x12\x04\xab\x03\x08\x20\n\r\n\x05\x05\x0c\x02\x07\x01\x12\x04\xab\x03\
    \x08\x1b\n\r\n\x05\x05\x0c\x02\x07\x02\x12\x04\xab\x03\x1e\x1f\n\x0c\n\
    \x04\x05\x0c\x02\x08\x12\x04\xac\x03\x08%\n\r\n\x05\x05\x0c\x02\x08\x01\
    \x12\x04\xac\x03\x08\x20\n\r\n\x05\x05\x0c\x02\x08\x02\x12\x04\xac\x03#$\
    \n\x0c\n\x04\x05\x0c\x02\t\x12\x04\xad\x03\x08\x1a\n\r\n\x05\x05\x0c\x02\
    \t\x01\x12\x04\xad\x03\x08\x14\n\r\n\x05\x05\x0c\x02\t\x02\x12\x04\xad\
    \x03\x17\x19\n\x0c\n\x04\x05\x0c\x02\n\x12\x04\xae\x03\x080\n\r\n\x05\
    \x05\x0c\x02\n\x01\x12\x04\xae\x03\x08*\n\r\n\x05\x05\x0c\x02\n\x02\x12\
    \x04\xae\x03-/\n\x0c\n\x04\x05\x0c\x02\x0b\x12\x04\xaf\x03\x08&\n\r\n\
    \x05\x05\x0c\x02\x0b\x01\x12\x04\xaf\x03\x08\x20\n\r\n\x05\x05\x0c\x02\
    \x0b\x02\x12\x04\xaf\x03#%\n\x0c\n\x04\x05\x0c\x02\x0c\x12\x04\xb0\x03\
    \x08\x20\n\r\n\x05\x05\x0c\x02\x0c\x01\x12\x04\xb0\x03\x08\x1a\n\r\n\x05\
    \x05\x0c\x02\x0c\x02\x12\x04\xb0\x03\x1d\x1f\n\x0c\n\x04\x05\x0c\x02\r\
    \x12\x04\xb1\x03\x08'\n\r\n\x05\x05\x0c\x02\r\x01\x12\x04\xb1\x03\x08!\n\
    \r\n\x05\x05\x0c\x02\r\x02\x12\x04\xb1\x03$&\n\x0c\n\x04\x05\x0c\x02\x0e\
    \x12\x04\xb2\x03\x08&\n\r\n\x05\x05\x0c\x02\x0e\x01\x12\x04\xb2\x03\x08\
    \x20\n\r\n\x05\x05\x0c\x02\x0e\x02\x12\x04\xb2\x03#%\n\x0c\n\x04\x05\x0c\
    \x02\x0f\x12\x04\xb3\x03\x08&\n\r\n\x05\x05\x0c\x02\x0f\x01\x12\x04\xb3\
    \x03\x08\x20\n\r\n\x05\x05\x0c\x02\x0f\x02\x12\x04\xb3\x03#%\n\x0c\n\x04\
    \x05\x0c\x02\x10\x12\x04\xb4\x03\x08&\n\r\n\x05\x05\x0c\x02\x10\x01\x12\
    \x04\xb4\x03\x08\x20\n\r\n\x05\x05\x0c\x02\x10\x02\x12\x04\xb4\x03#%\n\
    \x0c\n\x04\x05\x0c\x02\x11\x12\x04\xb5\x03\x08!\n\r\n\x05\x05\x0c\x02\
    \x11\x01\x12\x04\xb5\x03\x08\x1b\n\r\n\x05\x05\x0c\x02\x11\x02\x12\x04\
    \xb5\x03\x1e\x20\n\x0c\n\x04\x05\x0c\x02\x12\x12\x04\xb6\x03\x08!\n\r\n\
    \x05\x05\x0c\x02\x12\x01\x12\x04\xb6\x03\x08\x1b\n\r\n\x05\x05\x0c\x02\
    \x12\x02\x12\x04\xb6\x03\x1e\x20\n\x0c\n\x04\x05\x0c\x02\x13\x12\x04\xb7\
    \x03\x08%\n\r\n\x05\x05\x0c\x02\x13\x01\x12\x04\xb7\x03\x08\x1f\n\r\n\
    \x05\x05\x0c\x02\x13\x02\x12\x04\xb7\x03\"$\n\x0c\n\x02\x05\r\x12\x06\
    \xba\x03\0\xbd\x03\x01\n\x0b\n\x03\x05\r\x01\x12\x04\xba\x03\x05\x15\n\
    \x0c\n\x04\x05\r\x02\0\x12\x04\xbb\x03\x08\x1b\n\r\n\x05\x05\r\x02\0\x01\
    \x12\x04\xbb\x03\x08\x16\n\r\n\x05\x05\r\x02\0\x02\x12\x04\xbb\x03\x19\
    \x1a\n\x0c\n\x04\x05\r\x02\x01\x12\x04\xbc\x03\x08#\n\r\n\x05\x05\r\x02\
    \x01\x01\x12\x04\xbc\x03\x08\x1e\n\r\n\x05\x05\r\x02\x01\x02\x12\x04\xbc\
    \x03!\"\n\x0c\n\x02\x04\0\x12\x06\xbf\x03\0\xc1\x03\x01\n\x0b\n\x03\x04\
    \0\x01\x12\x04\xbf\x03\x08\x20\n\x0c\n\x04\x04\0\x02\0\x12\x04\xc0\x03\
    \x08$\n\r\n\x05\x04\0\x02\0\x04\x12\x04\xc0\x03\x08\x10\n\r\n\x05\x04\0\
    \x02\0\x05\x12\x04\xc0\x03\x11\x17\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xc0\
    \x03\x18\x1f\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xc0\x03\"#\n\x0c\n\x02\
    \x04\x01\x12\x06\xc3\x03\0\xc6\x03\x01\n\x0b\n\x03\x04\x01\x01\x12\x04\
    \xc3\x03\x08\x19\n\x0c\n\x04\x04\x01\x02\0\x12\x04\xc4\x03\x08!\n\r\n\
    \x05\x04\x01\x02\0\x04\x12\x04\xc4\x03\x08\x10\n\r\n\x05\x04\x01\x02\0\
    \x05\x12\x04\xc4\x03\x11\x17\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xc4\x03\
    \x18\x1c\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xc4\x03\x1f\x20\n\x0c\n\x04\
    \x04\x01\x02\x01\x12\x04\xc5\x03\x08!\n\r\n\x05\x04\x01\x02\x01\x04\x12\
    \x04\xc5\x03\x08\x10\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\xc5\x03\x11\
    \x17\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xc5\x03\x18\x1c\n\r\n\x05\x04\
    \x01\x02\x01\x03\x12\x04\xc5\x03\x1f\x20\n\x0c\n\x02\x04\x02\x12\x06\xc8\
    \x03\0\xca\x03\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\xc8\x03\x08\x1f\n\x0c\
    \n\x04\x04\x02\x02\0\x12\x04\xc9\x03\x08%\n\r\n\x05\x04\x02\x02\0\x04\
    \x12\x04\xc9\x03\x08\x10\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xc9\x03\x11\
    \x16\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xc9\x03\x17\x20\n\r\n\x05\x04\
    \x02\x02\0\x03\x12\x04\xc9\x03#$\n\x0c\n\x02\x04\x03\x12\x06\xcc\x03\0\
    \xd7\x03\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xcc\x03\x08\x1e\n\x0c\n\x04\
    \x04\x03\x02\0\x12\x04\xcd\x03\x08,\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\
    \xcd\x03\x08\x10\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\xcd\x03\x11\"\n\r\n\
    \x05\x04\x03\x02\0\x01\x12\x04\xcd\x03#'\n\r\n\x05\x04\x03\x02\0\x03\x12\
    \x04\xcd\x03*+\n\x0c\n\x04\x04\x03\x02\x01\x12\x04\xce\x03\x08\"\n\r\n\
    \x05\x04\x03\x02\x01\x04\x12\x04\xce\x03\x08\x10\n\r\n\x05\x04\x03\x02\
    \x01\x05\x12\x04\xce\x03\x11\x17\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\
    \xce\x03\x18\x1d\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xce\x03\x20!\n\
    \x0c\n\x04\x04\x03\x02\x02\x12\x04\xcf\x03\x08'\n\r\n\x05\x04\x03\x02\
    \x02\x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\
    \xcf\x03\x11\x17\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xcf\x03\x18\"\n\r\
    \n\x05\x04\x03\x02\x02\x03\x12\x04\xcf\x03%&\n\x0c\n\x04\x04\x03\x02\x03\
    \x12\x04\xd0\x03\x08'\n\r\n\x05\x04\x03\x02\x03\x04\x12\x04\xd0\x03\x08\
    \x10\n\r\n\x05\x04\x03\x02\x03\x05\x12\x04\xd0\x03\x11\x17\n\r\n\x05\x04\
    \x03\x02\x03\x01\x12\x04\xd0\x03\x18\"\n\r\n\x05\x04\x03\x02\x03\x03\x12\
    \x04\xd0\x03%&\n\x0c\n\x04\x04\x03\x02\x04\x12\x04\xd1\x03\x08'\n\r\n\
    \x05\x04\x03\x02\x04\x04\x12\x04\xd1\x03\x08\x10\n\r\n\x05\x04\x03\x02\
    \x04\x05\x12\x04\xd1\x03\x11\x17\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\
    \xd1\x03\x18\"\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\xd1\x03%&\n\x0c\n\
    \x04\x04\x03\x02\x05\x12\x04\xd2\x03\x08'\n\r\n\x05\x04\x03\x02\x05\x04\
    \x12\x04\xd2\x03\x08\x10\n\r\n\x05\x04\x03\x02\x05\x05\x12\x04\xd2\x03\
    \x11\x17\n\r\n\x05\x04\x03\x02\x05\x01\x12\x04\xd2\x03\x18\"\n\r\n\x05\
    \x04\x03\x02\x05\x03\x12\x04\xd2\x03%&\n\x0c\n\x04\x04\x03\x02\x06\x12\
    \x04\xd3\x03\x08'\n\r\n\x05\x04\x03\x02\x06\x04\x12\x04\xd3\x03\x08\x10\
    \n\r\n\x05\x04\x03\x02\x06\x05\x12\x04\xd3\x03\x11\x17\n\r\n\x05\x04\x03\
    \x02\x06\x01\x12\x04\xd3\x03\x18\"\n\r\n\x05\x04\x03\x02\x06\x03\x12\x04\
    \xd3\x03%&\n\x0c\n\x04\x04\x03\x02\x07\x12\x04\xd4\x03\x08'\n\r\n\x05\
    \x04\x03\x02\x07\x04\x12\x04\xd4\x03\x08\x10\n\r\n\x05\x04\x03\x02\x07\
    \x05\x12\x04\xd4\x03\x11\x17\n\r\n\x05\x04\x03\x02\x07\x01\x12\x04\xd4\
    \x03\x18\"\n\r\n\x05\x04\x03\x02\x07\x03\x12\x04\xd4\x03%&\n\x0c\n\x04\
    \x04\x03\x02\x08\x12\x04\xd5\x03\x08#\n\r\n\x05\x04\x03\x02\x08\x04\x12\
    \x04\xd5\x03\x08\x10\n\r\n\x05\x04\x03\x02\x08\x05\x12\x04\xd5\x03\x11\
    \x17\n\r\n\x05\x04\x03\x02\x08\x01\x12\x04\xd5\x03\x18\x1e\n\r\n\x05\x04\
    \x03\x02\x08\x03\x12\x04\xd5\x03!\"\n\x0c\n\x04\x04\x03\x02\t\x12\x04\
    \xd6\x03\x08$\n\r\n\x05\x04\x03\x02\t\x04\x12\x04\xd6\x03\x08\x10\n\r\n\
    \x05\x04\x03\x02\t\x05\x12\x04\xd6\x03\x11\x17\n\r\n\x05\x04\x03\x02\t\
    \x01\x12\x04\xd6\x03\x18\x1e\n\r\n\x05\x04\x03\x02\t\x03\x12\x04\xd6\x03\
    !#\n\x0c\n\x02\x04\x04\x12\x06\xd9\x03\0\xde\x03\x01\n\x0b\n\x03\x04\x04\
    \x01\x12\x04\xd9\x03\x08\x1c\n\x0c\n\x04\x04\x04\x02\0\x12\x04\xda\x03\
    \x08%\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\xda\x03\x08\x10\n\r\n\x05\x04\
    \x04\x02\0\x05\x12\x04\xda\x03\x11\x16\n\r\n\x05\x04\x04\x02\0\x01\x12\
    \x04\xda\x03\x17\x20\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xda\x03#$\n\x0c\
    \n\x04\x04\x04\x02\x01\x12\x04\xdb\x03\x08$\n\r\n\x05\x04\x04\x02\x01\
    \x04\x12\x04\xdb\x03\x08\x10\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xdb\
    \x03\x11\x17\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xdb\x03\x18\x1f\n\r\n\
    \x05\x04\x04\x02\x01\x03\x12\x04\xdb\x03\"#\n\x0c\n\x04\x04\x04\x02\x02\
    \x12\x04\xdc\x03\x08#\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\xdc\x03\x08\
    \x10\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xdc\x03\x11\x17\n\r\n\x05\x04\
    \x04\x02\x02\x01\x12\x04\xdc\x03\x18\x1e\n\r\n\x05\x04\x04\x02\x02\x03\
    \x12\x04\xdc\x03!\"\n\x0c\n\x04\x04\x04\x02\x03\x12\x04\xdd\x03\x08$\n\r\
    \n\x05\x04\x04\x02\x03\x04\x12\x04\xdd\x03\x08\x10\n\r\n\x05\x04\x04\x02\
    \x03\x05\x12\x04\xdd\x03\x11\x15\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\
    \xdd\x03\x16\x1f\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xdd\x03\"#\n\x0c\
    \n\x02\x04\x05\x12\x06\xe0\x03\0\xe5\x03\x01\n\x0b\n\x03\x04\x05\x01\x12\
    \x04\xe0\x03\x08(\n\x0c\n\x04\x04\x05\x02\0\x12\x04\xe1\x03\x08\"\n\r\n\
    \x05\x04\x05\x02\0\x04\x12\x04\xe1\x03\x08\x10\n\r\n\x05\x04\x05\x02\0\
    \x05\x12\x04\xe1\x03\x11\x17\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xe1\x03\
    \x18\x1d\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xe1\x03\x20!\n\x0c\n\x04\
    \x04\x05\x02\x01\x12\x04\xe2\x03\x08\x20\n\r\n\x05\x04\x05\x02\x01\x04\
    \x12\x04\xe2\x03\x08\x10\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xe2\x03\
    \x11\x16\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xe2\x03\x17\x1b\n\r\n\x05\
    \x04\x05\x02\x01\x03\x12\x04\xe2\x03\x1e\x1f\n\x0c\n\x04\x04\x05\x02\x02\
    \x12\x04\xe3\x03\x08,\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\xe3\x03\x08\
    \x10\n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\xe3\x03\x11\x1d\n\r\n\x05\x04\
    \x05\x02\x02\x01\x12\x04\xe3\x03\x1e'\n\r\n\x05\x04\x05\x02\x02\x03\x12\
    \x04\xe3\x03*+\n\x0c\n\x04\x04\x05\x02\x03\x12\x04\xe4\x03\x08\"\n\r\n\
    \x05\x04\x05\x02\x03\x04\x12\x04\xe4\x03\x08\x10\n\r\n\x05\x04\x05\x02\
    \x03\x05\x12\x04\xe4\x03\x11\x16\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\
    \xe4\x03\x17\x1d\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\xe4\x03\x20!\n\
    \x0c\n\x02\x04\x06\x12\x06\xe7\x03\0\xed\x03\x01\n\x0b\n\x03\x04\x06\x01\
    \x12\x04\xe7\x03\x08&\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xe8\x03\x08;\n\r\
    \n\x05\x04\x06\x02\0\x04\x12\x04\xe8\x03\x08\x10\n\r\n\x05\x04\x06\x02\0\
    \x06\x12\x04\xe8\x03\x11'\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xe8\x03(6\
    \n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xe8\x039:\n\x0c\n\x04\x04\x06\x02\
    \x01\x12\x04\xe9\x03\x08%\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xe9\x03\
    \x08\x10\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xe9\x03\x11\x16\n\r\n\x05\
    \x04\x06\x02\x01\x01\x12\x04\xe9\x03\x17\x20\n\r\n\x05\x04\x06\x02\x01\
    \x03\x12\x04\xe9\x03#$\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xea\x03\x08$\
    \n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\xea\x03\x08\x10\n\r\n\x05\x04\x06\
    \x02\x02\x05\x12\x04\xea\x03\x11\x16\n\r\n\x05\x04\x06\x02\x02\x01\x12\
    \x04\xea\x03\x17\x1f\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xea\x03\"#\n\
    \x0c\n\x04\x04\x06\x02\x03\x12\x04\xeb\x03\x08%\n\r\n\x05\x04\x06\x02\
    \x03\x04\x12\x04\xeb\x03\x08\x10\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\
    \xeb\x03\x11\x16\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xeb\x03\x17\x20\n\
    \r\n\x05\x04\x06\x02\x03\x03\x12\x04\xeb\x03#$\n\x0c\n\x04\x04\x06\x02\
    \x04\x12\x04\xec\x03\x08(\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04\xec\x03\
    \x08\x10\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\xec\x03\x11\x16\n\r\n\x05\
    \x04\x06\x02\x04\x01\x12\x04\xec\x03\x17#\n\r\n\x05\x04\x06\x02\x04\x03\
    \x12\x04\xec\x03&'\n\x0c\n\x02\x04\x07\x12\x06\xef\x03\0\xf2\x03\x01\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\xef\x03\x08-\n\x0c\n\x04\x04\x07\x02\0\
    \x12\x04\xf0\x03\x08)\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xf0\x03\x08\
    \x10\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xf0\x03\x11\x16\n\r\n\x05\x04\
    \x07\x02\0\x01\x12\x04\xf0\x03\x17$\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\
    \xf0\x03'(\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xf1\x03\x08'\n\r\n\x05\
    \x04\x07\x02\x01\x04\x12\x04\xf1\x03\x08\x10\n\r\n\x05\x04\x07\x02\x01\
    \x06\x12\x04\xf1\x03\x11\x1b\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xf1\
    \x03\x1c\"\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xf1\x03%&\n\x0c\n\x02\
    \x04\x08\x12\x06\xf4\x03\0\x82\x04\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \xf4\x03\x08$\n\x0e\n\x04\x04\x08\x03\0\x12\x06\xf5\x03\x08\xff\x03\t\n\
    \r\n\x05\x04\x08\x03\0\x01\x12\x04\xf5\x03\x10\x18\n\x10\n\x06\x04\x08\
    \x03\0\x03\0\x12\x06\xf6\x03\x10\xf9\x03\x11\n\x0f\n\x07\x04\x08\x03\0\
    \x03\0\x01\x12\x04\xf6\x03\x18\x1f\n\x10\n\x08\x04\x08\x03\0\x03\0\x02\0\
    \x12\x04\xf7\x03\x186\n\x11\n\t\x04\x08\x03\0\x03\0\x02\0\x04\x12\x04\
    \xf7\x03\x18\x20\n\x11\n\t\x04\x08\x03\0\x03\0\x02\0\x05\x12\x04\xf7\x03\
    !&\n\x11\n\t\x04\x08\x03\0\x03\0\x02\0\x01\x12\x04\xf7\x03'1\n\x11\n\t\
    \x04\x08\x03\0\x03\0\x02\0\x03\x12\x04\xf7\x0345\n\x10\n\x08\x04\x08\x03\
    \0\x03\0\x02\x01\x12\x04\xf8\x03\x182\n\x11\n\t\x04\x08\x03\0\x03\0\x02\
    \x01\x04\x12\x04\xf8\x03\x18\x20\n\x11\n\t\x04\x08\x03\0\x03\0\x02\x01\
    \x05\x12\x04\xf8\x03!&\n\x11\n\t\x04\x08\x03\0\x03\0\x02\x01\x01\x12\x04\
    \xf8\x03'-\n\x11\n\t\x04\x08\x03\0\x03\0\x02\x01\x03\x12\x04\xf8\x0301\n\
    \x0e\n\x06\x04\x08\x03\0\x02\0\x12\x04\xfb\x03\x10-\n\x0f\n\x07\x04\x08\
    \x03\0\x02\0\x04\x12\x04\xfb\x03\x10\x18\n\x0f\n\x07\x04\x08\x03\0\x02\0\
    \x05\x12\x04\xfb\x03\x19\x1f\n\x0f\n\x07\x04\x08\x03\0\x02\0\x01\x12\x04\
    \xfb\x03\x20(\n\x0f\n\x07\x04\x08\x03\0\x02\0\x03\x12\x04\xfb\x03+,\n\
    \x0e\n\x06\x04\x08\x03\0\x02\x01\x12\x04\xfc\x03\x100\n\x0f\n\x07\x04\
    \x08\x03\0\x02\x01\x04\x12\x04\xfc\x03\x10\x18\n\x0f\n\x07\x04\x08\x03\0\
    \x02\x01\x05\x12\x04\xfc\x03\x19\x1e\n\x0f\n\x07\x04\x08\x03\0\x02\x01\
    \x01\x12\x04\xfc\x03\x1f+\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x03\x12\x04\
    \xfc\x03./\n\x0e\n\x06\x04\x08\x03\0\x02\x02\x12\x04\xfd\x03\x10U\n\x0f\
    \n\x07\x04\x08\x03\0\x02\x02\x04\x12\x04\xfd\x03\x10\x18\n\x0f\n\x07\x04\
    \x08\x03\0\x02\x02\x06\x12\x04\xfd\x03\x19F\n\x0f\n\x07\x04\x08\x03\0\
    \x02\x02\x01\x12\x04\xfd\x03GP\n\x0f\n\x07\x04\x08\x03\0\x02\x02\x03\x12\
    \x04\xfd\x03ST\n\x0e\n\x06\x04\x08\x03\0\x02\x03\x12\x04\xfe\x03\x102\n\
    \x0f\n\x07\x04\x08\x03\0\x02\x03\x04\x12\x04\xfe\x03\x10\x18\n\x0f\n\x07\
    \x04\x08\x03\0\x02\x03\x05\x12\x04\xfe\x03\x19\x1f\n\x0f\n\x07\x04\x08\
    \x03\0\x02\x03\x01\x12\x04\xfe\x03\x20-\n\x0f\n\x07\x04\x08\x03\0\x02\
    \x03\x03\x12\x04\xfe\x0301\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x81\x04\x08\
    E\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x81\x04\x08\x10\n\r\n\x05\x04\x08\
    \x02\0\x06\x12\x04\x81\x04\x116\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x81\
    \x047@\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x81\x04CD\n\x0c\n\x02\x04\t\
    \x12\x06\x84\x04\0\x87\x04\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x84\x04\x08\
    %\n\x0c\n\x04\x04\t\x02\0\x12\x04\x85\x04\x08\"\n\r\n\x05\x04\t\x02\0\
    \x04\x12\x04\x85\x04\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x85\x04\
    \x11\x17\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x85\x04\x18\x1d\n\r\n\x05\x04\
    \t\x02\0\x03\x12\x04\x85\x04\x20!\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x86\
    \x04\x08$\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\x86\x04\x08\x10\n\r\n\x05\
    \x04\t\x02\x01\x05\x12\x04\x86\x04\x11\x16\n\r\n\x05\x04\t\x02\x01\x01\
    \x12\x04\x86\x04\x17\x1f\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x86\x04\"#\
    \n\x0c\n\x02\x04\n\x12\x06\x89\x04\0\x8c\x04\x01\n\x0b\n\x03\x04\n\x01\
    \x12\x04\x89\x04\x08)\n\x0c\n\x04\x04\n\x02\0\x12\x04\x8a\x04\x08*\n\r\n\
    \x05\x04\n\x02\0\x04\x12\x04\x8a\x04\x08\x10\n\r\n\x05\x04\n\x02\0\x06\
    \x12\x04\x8a\x04\x11\x1b\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x8a\x04\x1c%\
    \n\r\n\x05\x04\n\x02\0\x03\x12\x04\x8a\x04()\n\x0c\n\x04\x04\n\x02\x01\
    \x12\x04\x8b\x04\x08$\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x8b\x04\x08\
    \x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x8b\x04\x11\x16\n\r\n\x05\x04\n\
    \x02\x01\x01\x12\x04\x8b\x04\x17\x1f\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\
    \x8b\x04\"#\n\x0c\n\x02\x04\x0b\x12\x06\x8e\x04\0\x91\x04\x01\n\x0b\n\
    \x03\x04\x0b\x01\x12\x04\x8e\x04\x08!\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\
    \x8f\x04\x08%\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x8f\x04\x08\x10\n\r\n\
    \x05\x04\x0b\x02\0\x05\x12\x04\x8f\x04\x11\x16\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\x8f\x04\x17\x20\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x8f\x04\
    #$\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x90\x04\x089\n\r\n\x05\x04\x0b\
    \x02\x01\x04\x12\x04\x90\x04\x08\x10\n\r\n\x05\x04\x0b\x02\x01\x06\x12\
    \x04\x90\x04\x11&\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x90\x04'4\n\r\n\
    \x05\x04\x0b\x02\x01\x03\x12\x04\x90\x0478\n\x0c\n\x02\x04\x0c\x12\x06\
    \x93\x04\0\x98\x04\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x93\x04\x08%\n\
    \x0c\n\x04\x04\x0c\x02\0\x12\x04\x94\x04\x088\n\r\n\x05\x04\x0c\x02\0\
    \x04\x12\x04\x94\x04\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x94\x04\
    \x11\x16\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x94\x04\x173\n\r\n\x05\x04\
    \x0c\x02\0\x03\x12\x04\x94\x0467\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x95\
    \x04\x08)\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\x95\x04\x08\x10\n\r\n\
    \x05\x04\x0c\x02\x01\x05\x12\x04\x95\x04\x11\x17\n\r\n\x05\x04\x0c\x02\
    \x01\x01\x12\x04\x95\x04\x18$\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x95\
    \x04'(\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\x96\x04\x08&\n\r\n\x05\x04\
    \x0c\x02\x02\x04\x12\x04\x96\x04\x08\x10\n\r\n\x05\x04\x0c\x02\x02\x05\
    \x12\x04\x96\x04\x11\x17\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x96\x04\
    \x18!\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x96\x04$%\n\x0c\n\x04\x04\
    \x0c\x02\x03\x12\x04\x97\x04\x08)\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04\
    \x97\x04\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x06\x12\x04\x97\x04\x11\x1b\n\
    \r\n\x05\x04\x0c\x02\x03\x01\x12\x04\x97\x04\x1c$\n\r\n\x05\x04\x0c\x02\
    \x03\x03\x12\x04\x97\x04'(\n\x0c\n\x02\x04\r\x12\x06\x9a\x04\0\x9d\x04\
    \x01\n\x0b\n\x03\x04\r\x01\x12\x04\x9a\x04\x08\x1e\n\x0c\n\x04\x04\r\x02\
    \0\x12\x04\x9b\x04\x08%\n\r\n\x05\x04\r\x02\0\x04\x12\x04\x9b\x04\x08\
    \x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x9b\x04\x11\x16\n\r\n\x05\x04\r\
    \x02\0\x01\x12\x04\x9b\x04\x17\x20\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x9b\
    \x04#$\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x9c\x04\x083\n\r\n\x05\x04\r\
    \x02\x01\x04\x12\x04\x9c\x04\x08\x10\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\
    \x9c\x04\x11#\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x9c\x04$.\n\r\n\x05\
    \x04\r\x02\x01\x03\x12\x04\x9c\x0412\n\x0c\n\x02\x04\x0e\x12\x06\x9f\x04\
    \0\xa8\x04\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\x9f\x04\x08#\n\x0c\n\x04\
    \x04\x0e\x02\0\x12\x04\xa0\x04\x08%\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\
    \xa0\x04\x08\x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xa0\x04\x11\x16\n\r\
    \n\x05\x04\x0e\x02\0\x01\x12\x04\xa0\x04\x17\x20\n\r\n\x05\x04\x0e\x02\0\
    \x03\x12\x04\xa0\x04#$\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xa1\x04\x08,\
    \n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xa1\x04\x08\x10\n\r\n\x05\x04\x0e\
    \x02\x01\x05\x12\x04\xa1\x04\x11\x16\n\r\n\x05\x04\x0e\x02\x01\x01\x12\
    \x04\xa1\x04\x17'\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xa1\x04*+\n\x0c\
    \n\x04\x04\x0e\x02\x02\x12\x04\xa2\x04\x08+\n\r\n\x05\x04\x0e\x02\x02\
    \x04\x12\x04\xa2\x04\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xa2\
    \x04\x11\x16\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xa2\x04\x17&\n\r\n\
    \x05\x04\x0e\x02\x02\x03\x12\x04\xa2\x04)*\n\x0c\n\x04\x04\x0e\x02\x03\
    \x12\x04\xa3\x04\x08%\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xa3\x04\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xa3\x04\x11\x16\n\r\n\x05\x04\
    \x0e\x02\x03\x01\x12\x04\xa3\x04\x17\x20\n\r\n\x05\x04\x0e\x02\x03\x03\
    \x12\x04\xa3\x04#$\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\xa4\x04\x08%\n\r\
    \n\x05\x04\x0e\x02\x04\x04\x12\x04\xa4\x04\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x04\x05\x12\x04\xa4\x04\x11\x16\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \xa4\x04\x17\x20\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xa4\x04#$\n\x0c\n\
    \x04\x04\x0e\x02\x05\x12\x04\xa5\x04\x08&\n\r\n\x05\x04\x0e\x02\x05\x04\
    \x12\x04\xa5\x04\x08\x10\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xa5\x04\
    \x11\x16\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xa5\x04\x17!\n\r\n\x05\
    \x04\x0e\x02\x05\x03\x12\x04\xa5\x04$%\n\x0c\n\x04\x04\x0e\x02\x06\x12\
    \x04\xa6\x04\x08+\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\xa6\x04\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x06\x05\x12\x04\xa6\x04\x11\x16\n\r\n\x05\x04\x0e\
    \x02\x06\x01\x12\x04\xa6\x04\x17&\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\
    \xa6\x04)*\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\xa7\x04\x08-\n\r\n\x05\
    \x04\x0e\x02\x07\x04\x12\x04\xa7\x04\x08\x10\n\r\n\x05\x04\x0e\x02\x07\
    \x05\x12\x04\xa7\x04\x11\x16\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xa7\
    \x04\x17(\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\xa7\x04+,\n\x0c\n\x02\
    \x04\x0f\x12\x06\xaa\x04\0\xb1\x04\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\
    \xaa\x04\x08\"\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xab\x04\x08%\n\r\n\x05\
    \x04\x0f\x02\0\x04\x12\x04\xab\x04\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\
    \x12\x04\xab\x04\x11\x16\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xab\x04\x17\
    \x20\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xab\x04#$\n\x0c\n\x04\x04\x0f\
    \x02\x01\x12\x04\xac\x04\x08'\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xac\
    \x04\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xac\x04\x11\x17\n\r\n\
    \x05\x04\x0f\x02\x01\x01\x12\x04\xac\x04\x18\"\n\r\n\x05\x04\x0f\x02\x01\
    \x03\x12\x04\xac\x04%&\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xad\x04\x08(\
    \n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xad\x04\x08\x10\n\r\n\x05\x04\x0f\
    \x02\x02\x05\x12\x04\xad\x04\x11\x17\n\r\n\x05\x04\x0f\x02\x02\x01\x12\
    \x04\xad\x04\x18#\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xad\x04&'\n\x0c\
    \n\x04\x04\x0f\x02\x03\x12\x04\xae\x04\x08$\n\r\n\x05\x04\x0f\x02\x03\
    \x04\x12\x04\xae\x04\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\xae\
    \x04\x11\x15\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xae\x04\x16\x1f\n\r\n\
    \x05\x04\x0f\x02\x03\x03\x12\x04\xae\x04\"#\n\x0c\n\x04\x04\x0f\x02\x04\
    \x12\x04\xaf\x04\x08+\n\r\n\x05\x04\x0f\x02\x04\x04\x12\x04\xaf\x04\x08\
    \x10\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\xaf\x04\x11\x16\n\r\n\x05\x04\
    \x0f\x02\x04\x01\x12\x04\xaf\x04\x17&\n\r\n\x05\x04\x0f\x02\x04\x03\x12\
    \x04\xaf\x04)*\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\xb0\x04\x08-\n\r\n\
    \x05\x04\x0f\x02\x05\x04\x12\x04\xb0\x04\x08\x10\n\r\n\x05\x04\x0f\x02\
    \x05\x05\x12\x04\xb0\x04\x11\x16\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\
    \xb0\x04\x17(\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xb0\x04+,\n\x0c\n\
    \x02\x04\x10\x12\x06\xb3\x04\0\xb7\x04\x01\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\xb3\x04\x08\x20\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xb4\x04\x08%\n\r\
    \n\x05\x04\x10\x02\0\x04\x12\x04\xb4\x04\x08\x10\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\xb4\x04\x11\x16\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xb4\x04\
    \x17\x20\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xb4\x04#$\n\x0c\n\x04\x04\
    \x10\x02\x01\x12\x04\xb5\x04\x08+\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\
    \xb5\x04\x08\x10\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xb5\x04\x11\x16\n\
    \r\n\x05\x04\x10\x02\x01\x01\x12\x04\xb5\x04\x17&\n\r\n\x05\x04\x10\x02\
    \x01\x03\x12\x04\xb5\x04)*\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xb6\x04\
    \x08*\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xb6\x04\x08\x10\n\r\n\x05\
    \x04\x10\x02\x02\x05\x12\x04\xb6\x04\x11\x15\n\r\n\x05\x04\x10\x02\x02\
    \x01\x12\x04\xb6\x04\x16%\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xb6\x04(\
    )\n\x0c\n\x02\x04\x11\x12\x06\xb9\x04\0\xc1\x04\x01\n\x0b\n\x03\x04\x11\
    \x01\x12\x04\xb9\x04\x08%\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xba\x04\x08%\
    \n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xba\x04\x08\x10\n\r\n\x05\x04\x11\
    \x02\0\x05\x12\x04\xba\x04\x11\x16\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\
    \xba\x04\x17\x20\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xba\x04#$\n\x0c\n\
    \x04\x04\x11\x02\x01\x12\x04\xbb\x04\x08,\n\r\n\x05\x04\x11\x02\x01\x04\
    \x12\x04\xbb\x04\x08\x10\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xbb\x04\
    \x11\x16\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xbb\x04\x17'\n\r\n\x05\
    \x04\x11\x02\x01\x03\x12\x04\xbb\x04*+\n\x0c\n\x04\x04\x11\x02\x02\x12\
    \x04\xbc\x04\x08)\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xbc\x04\x08\x10\
    \n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xbc\x04\x11\x16\n\r\n\x05\x04\x11\
    \x02\x02\x01\x12\x04\xbc\x04\x17$\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\
    \xbc\x04'(\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\xbd\x04\x08'\n\r\n\x05\
    \x04\x11\x02\x03\x04\x12\x04\xbd\x04\x08\x10\n\r\n\x05\x04\x11\x02\x03\
    \x05\x12\x04\xbd\x04\x11\x16\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xbd\
    \x04\x17\"\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xbd\x04%&\n\x0c\n\x04\
    \x04\x11\x02\x04\x12\x04\xbe\x04\x08%\n\r\n\x05\x04\x11\x02\x04\x04\x12\
    \x04\xbe\x04\x08\x10\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xbe\x04\x11\
    \x16\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xbe\x04\x17\x20\n\r\n\x05\x04\
    \x11\x02\x04\x03\x12\x04\xbe\x04#$\n\x0c\n\x04\x04\x11\x02\x05\x12\x04\
    \xbf\x04\x08(\n\r\n\x05\x04\x11\x02\x05\x04\x12\x04\xbf\x04\x08\x10\n\r\
    \n\x05\x04\x11\x02\x05\x05\x12\x04\xbf\x04\x11\x15\n\r\n\x05\x04\x11\x02\
    \x05\x01\x12\x04\xbf\x04\x16#\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xbf\
    \x04&'\n\x0c\n\x04\x04\x11\x02\x06\x12\x04\xc0\x04\x08*\n\r\n\x05\x04\
    \x11\x02\x06\x04\x12\x04\xc0\x04\x08\x10\n\r\n\x05\x04\x11\x02\x06\x05\
    \x12\x04\xc0\x04\x11\x15\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xc0\x04\
    \x16%\n\r\n\x05\x04\x11\x02\x06\x03\x12\x04\xc0\x04()\n\x0c\n\x02\x04\
    \x12\x12\x06\xc3\x04\0\xc6\x04\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xc3\
    \x04\x08\x1f\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xc4\x04\x08%\n\r\n\x05\
    \x04\x12\x02\0\x04\x12\x04\xc4\x04\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\
    \x12\x04\xc4\x04\x11\x16\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xc4\x04\x17\
    \x20\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xc4\x04#$\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xc5\x04\x08#\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xc5\
    \x04\x08\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xc5\x04\x11\x15\n\r\n\
    \x05\x04\x12\x02\x01\x01\x12\x04\xc5\x04\x16\x1e\n\r\n\x05\x04\x12\x02\
    \x01\x03\x12\x04\xc5\x04!\"\n\x0c\n\x02\x04\x13\x12\x06\xc8\x04\0\xcb\
    \x04\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xc8\x04\x08\x1f\n\x0c\n\x04\x04\
    \x13\x02\0\x12\x04\xc9\x04\x08%\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xc9\
    \x04\x08\x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xc9\x04\x11\x16\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xc9\x04\x17\x20\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\xc9\x04#$\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xca\x04\x08#\
    \n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xca\x04\x08\x10\n\r\n\x05\x04\x13\
    \x02\x01\x05\x12\x04\xca\x04\x11\x15\n\r\n\x05\x04\x13\x02\x01\x01\x12\
    \x04\xca\x04\x16\x1e\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xca\x04!\"\n\
    \x0c\n\x02\x04\x14\x12\x06\xcd\x04\0\xd2\x04\x01\n\x0b\n\x03\x04\x14\x01\
    \x12\x04\xcd\x04\x08&\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xce\x04\x08+\n\r\
    \n\x05\x04\x14\x02\0\x04\x12\x04\xce\x04\x08\x10\n\r\n\x05\x04\x14\x02\0\
    \x05\x12\x04\xce\x04\x11\x16\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xce\x04\
    \x17&\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xce\x04)*\n\x0c\n\x04\x04\x14\
    \x02\x01\x12\x04\xcf\x04\x08%\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xcf\
    \x04\x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xcf\x04\x11\x16\n\r\n\
    \x05\x04\x14\x02\x01\x01\x12\x04\xcf\x04\x17\x20\n\r\n\x05\x04\x14\x02\
    \x01\x03\x12\x04\xcf\x04#$\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xd0\x04\
    \x08+\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xd0\x04\x08\x10\n\r\n\x05\
    \x04\x14\x02\x02\x05\x12\x04\xd0\x04\x11\x17\n\r\n\x05\x04\x14\x02\x02\
    \x01\x12\x04\xd0\x04\x18&\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xd0\x04)\
    *\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xd1\x04\x080\n\r\n\x05\x04\x14\x02\
    \x03\x04\x12\x04\xd1\x04\x08\x10\n\r\n\x05\x04\x14\x02\x03\x05\x12\x04\
    \xd1\x04\x11\x16\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xd1\x04\x17+\n\r\
    \n\x05\x04\x14\x02\x03\x03\x12\x04\xd1\x04./\n\x0c\n\x02\x04\x15\x12\x06\
    \xd4\x04\0\xd8\x04\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xd4\x04\x08'\n\
    \x0c\n\x04\x04\x15\x02\0\x12\x04\xd5\x04\x08,\n\r\n\x05\x04\x15\x02\0\
    \x04\x12\x04\xd5\x04\x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xd5\x04\
    \x11\x16\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xd5\x04\x17'\n\r\n\x05\x04\
    \x15\x02\0\x03\x12\x04\xd5\x04*+\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xd6\
    \x04\x08,\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xd6\x04\x08\x10\n\r\n\
    \x05\x04\x15\x02\x01\x05\x12\x04\xd6\x04\x11\x16\n\r\n\x05\x04\x15\x02\
    \x01\x01\x12\x04\xd6\x04\x17'\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xd6\
    \x04*+\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xd7\x04\x08,\n\r\n\x05\x04\
    \x15\x02\x02\x04\x12\x04\xd7\x04\x08\x10\n\r\n\x05\x04\x15\x02\x02\x05\
    \x12\x04\xd7\x04\x11\x16\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xd7\x04\
    \x17'\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xd7\x04*+\n\x0c\n\x02\x04\
    \x16\x12\x06\xda\x04\0\xde\x04\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xda\
    \x04\x08+\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xdb\x04\x08+\n\r\n\x05\x04\
    \x16\x02\0\x04\x12\x04\xdb\x04\x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\
    \x04\xdb\x04\x11\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xdb\x04\x18&\n\
    \r\n\x05\x04\x16\x02\0\x03\x12\x04\xdb\x04)*\n\x0c\n\x04\x04\x16\x02\x01\
    \x12\x04\xdc\x04\x08+\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xdc\x04\x08\
    \x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xdc\x04\x11\x17\n\r\n\x05\x04\
    \x16\x02\x01\x01\x12\x04\xdc\x04\x18&\n\r\n\x05\x04\x16\x02\x01\x03\x12\
    \x04\xdc\x04)*\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xdd\x04\x08)\n\r\n\
    \x05\x04\x16\x02\x02\x04\x12\x04\xdd\x04\x08\x10\n\r\n\x05\x04\x16\x02\
    \x02\x05\x12\x04\xdd\x04\x11\x16\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\
    \xdd\x04\x17$\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xdd\x04'(\n\x0c\n\
    \x02\x04\x17\x12\x06\xe0\x04\0\xe3\x04\x01\n\x0b\n\x03\x04\x17\x01\x12\
    \x04\xe0\x04\x08'\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xe1\x04\x08+\n\r\n\
    \x05\x04\x17\x02\0\x04\x12\x04\xe1\x04\x08\x10\n\r\n\x05\x04\x17\x02\0\
    \x06\x12\x04\xe1\x04\x11\x1b\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xe1\x04\
    \x1c&\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xe1\x04)*\n\x0c\n\x04\x04\x17\
    \x02\x01\x12\x04\xe2\x04\x08)\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xe2\
    \x04\x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xe2\x04\x11\x16\n\r\n\
    \x05\x04\x17\x02\x01\x01\x12\x04\xe2\x04\x17$\n\r\n\x05\x04\x17\x02\x01\
    \x03\x12\x04\xe2\x04'(\n\x0c\n\x02\x04\x18\x12\x06\xe5\x04\0\xe7\x04\x01\
    \n\x0b\n\x03\x04\x18\x01\x12\x04\xe5\x04\x08&\n\x0c\n\x04\x04\x18\x02\0\
    \x12\x04\xe6\x04\x08%\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xe6\x04\x08\
    \x10\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xe6\x04\x11\x16\n\r\n\x05\x04\
    \x18\x02\0\x01\x12\x04\xe6\x04\x17\x20\n\r\n\x05\x04\x18\x02\0\x03\x12\
    \x04\xe6\x04#$\n\x0c\n\x02\x04\x19\x12\x06\xe9\x04\0\xef\x04\x01\n\x0b\n\
    \x03\x04\x19\x01\x12\x04\xe9\x04\x08\"\n\x0c\n\x04\x04\x19\x02\0\x12\x04\
    \xea\x04\x08%\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xea\x04\x08\x10\n\r\n\
    \x05\x04\x19\x02\0\x05\x12\x04\xea\x04\x11\x16\n\r\n\x05\x04\x19\x02\0\
    \x01\x12\x04\xea\x04\x17\x20\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xea\x04\
    #$\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xeb\x04\x08+\n\r\n\x05\x04\x19\
    \x02\x01\x04\x12\x04\xeb\x04\x08\x10\n\r\n\x05\x04\x19\x02\x01\x05\x12\
    \x04\xeb\x04\x11\x16\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xeb\x04\x17&\
    \n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xeb\x04)*\n\x0c\n\x04\x04\x19\x02\
    \x02\x12\x04\xec\x04\x08%\n\r\n\x05\x04\x19\x02\x02\x04\x12\x04\xec\x04\
    \x08\x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xec\x04\x11\x16\n\r\n\x05\
    \x04\x19\x02\x02\x01\x12\x04\xec\x04\x17\x20\n\r\n\x05\x04\x19\x02\x02\
    \x03\x12\x04\xec\x04#$\n\x0c\n\x04\x04\x19\x02\x03\x12\x04\xed\x04\x081\
    \n\r\n\x05\x04\x19\x02\x03\x04\x12\x04\xed\x04\x08\x10\n\r\n\x05\x04\x19\
    \x02\x03\x05\x12\x04\xed\x04\x11\x16\n\r\n\x05\x04\x19\x02\x03\x01\x12\
    \x04\xed\x04\x17,\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xed\x04/0\n\x0c\
    \n\x04\x04\x19\x02\x04\x12\x04\xee\x04\x08'\n\r\n\x05\x04\x19\x02\x04\
    \x04\x12\x04\xee\x04\x08\x10\n\r\n\x05\x04\x19\x02\x04\x05\x12\x04\xee\
    \x04\x11\x15\n\r\n\x05\x04\x19\x02\x04\x01\x12\x04\xee\x04\x16\"\n\r\n\
    \x05\x04\x19\x02\x04\x03\x12\x04\xee\x04%&\n\x0c\n\x02\x04\x1a\x12\x06\
    \xf1\x04\0\xfe\x04\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xf1\x04\x08'\n\
    \x0e\n\x04\x04\x1a\x03\0\x12\x06\xf2\x04\x08\xf5\x04\t\n\r\n\x05\x04\x1a\
    \x03\0\x01\x12\x04\xf2\x04\x10\x18\n\x0e\n\x06\x04\x1a\x03\0\x02\0\x12\
    \x04\xf3\x04\x103\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x04\x12\x04\xf3\x04\
    \x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x05\x12\x04\xf3\x04\x19\x1e\n\
    \x0f\n\x07\x04\x1a\x03\0\x02\0\x01\x12\x04\xf3\x04\x1f.\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\0\x03\x12\x04\xf3\x0412\n\x0e\n\x06\x04\x1a\x03\0\x02\x01\
    \x12\x04\xf4\x04\x10-\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x04\x12\x04\xf4\
    \x04\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x05\x12\x04\xf4\x04\x19\
    \x1f\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x01\x12\x04\xf4\x04\x20(\n\x0f\n\
    \x07\x04\x1a\x03\0\x02\x01\x03\x12\x04\xf4\x04+,\n\x0c\n\x04\x04\x1a\x02\
    \0\x12\x04\xf7\x04\x08!\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xf7\x04\x08\
    \x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xf7\x04\x11\x17\n\r\n\x05\x04\
    \x1a\x02\0\x01\x12\x04\xf7\x04\x18\x1c\n\r\n\x05\x04\x1a\x02\0\x03\x12\
    \x04\xf7\x04\x1f\x20\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xf8\x04\x08'\n\
    \r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xf8\x04\x08\x10\n\r\n\x05\x04\x1a\
    \x02\x01\x05\x12\x04\xf8\x04\x11\x17\n\r\n\x05\x04\x1a\x02\x01\x01\x12\
    \x04\xf8\x04\x18\"\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xf8\x04%&\n\x0c\
    \n\x04\x04\x1a\x02\x02\x12\x04\xf9\x04\x08*\n\r\n\x05\x04\x1a\x02\x02\
    \x04\x12\x04\xf9\x04\x08\x10\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xf9\
    \x04\x11\x17\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xf9\x04\x18%\n\r\n\
    \x05\x04\x1a\x02\x02\x03\x12\x04\xf9\x04()\n\x0c\n\x04\x04\x1a\x02\x03\
    \x12\x04\xfa\x04\x08%\n\r\n\x05\x04\x1a\x02\x03\x04\x12\x04\xfa\x04\x08\
    \x10\n\r\n\x05\x04\x1a\x02\x03\x05\x12\x04\xfa\x04\x11\x16\n\r\n\x05\x04\
    \x1a\x02\x03\x01\x12\x04\xfa\x04\x17\x20\n\r\n\x05\x04\x1a\x02\x03\x03\
    \x12\x04\xfa\x04#$\n\x0c\n\x04\x04\x1a\x02\x04\x12\x04\xfb\x04\x08I\n\r\
    \n\x05\x04\x1a\x02\x04\x04\x12\x04\xfb\x04\x08\x10\n\r\n\x05\x04\x1a\x02\
    \x04\x06\x12\x04\xfb\x04\x119\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\xfb\
    \x04:D\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\xfb\x04GH\n\x0c\n\x04\x04\
    \x1a\x02\x05\x12\x04\xfc\x04\x08,\n\r\n\x05\x04\x1a\x02\x05\x04\x12\x04\
    \xfc\x04\x08\x10\n\r\n\x05\x04\x1a\x02\x05\x05\x12\x04\xfc\x04\x11\x16\n\
    \r\n\x05\x04\x1a\x02\x05\x01\x12\x04\xfc\x04\x17'\n\r\n\x05\x04\x1a\x02\
    \x05\x03\x12\x04\xfc\x04*+\n\x0c\n\x04\x04\x1a\x02\x06\x12\x04\xfd\x04\
    \x08,\n\r\n\x05\x04\x1a\x02\x06\x04\x12\x04\xfd\x04\x08\x10\n\r\n\x05\
    \x04\x1a\x02\x06\x05\x12\x04\xfd\x04\x11\x16\n\r\n\x05\x04\x1a\x02\x06\
    \x01\x12\x04\xfd\x04\x17'\n\r\n\x05\x04\x1a\x02\x06\x03\x12\x04\xfd\x04*\
    +\n\x0c\n\x02\x04\x1b\x12\x06\x80\x05\0\x87\x05\x01\n\x0b\n\x03\x04\x1b\
    \x01\x12\x04\x80\x05\x08!\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\x81\x05\x08&\
    \n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\x81\x05\x08\x10\n\r\n\x05\x04\x1b\
    \x02\0\x05\x12\x04\x81\x05\x11\x16\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\
    \x81\x05\x17!\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\x81\x05$%\n\x0c\n\x04\
    \x04\x1b\x02\x01\x12\x04\x82\x05\x08*\n\r\n\x05\x04\x1b\x02\x01\x04\x12\
    \x04\x82\x05\x08\x10\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\x82\x05\x11\
    \x17\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\x82\x05\x18%\n\r\n\x05\x04\
    \x1b\x02\x01\x03\x12\x04\x82\x05()\n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\
    \x83\x05\x08\x1d\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\x83\x05\x08\x10\n\
    \r\n\x05\x04\x1b\x02\x02\x05\x12\x04\x83\x05\x11\x16\n\r\n\x05\x04\x1b\
    \x02\x02\x01\x12\x04\x83\x05\x17\x18\n\r\n\x05\x04\x1b\x02\x02\x03\x12\
    \x04\x83\x05\x1b\x1c\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\x84\x05\x08\x1d\
    \n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\x84\x05\x08\x10\n\r\n\x05\x04\x1b\
    \x02\x03\x05\x12\x04\x84\x05\x11\x16\n\r\n\x05\x04\x1b\x02\x03\x01\x12\
    \x04\x84\x05\x17\x18\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\x84\x05\x1b\
    \x1c\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\x85\x05\x08$\n\r\n\x05\x04\x1b\
    \x02\x04\x04\x12\x04\x85\x05\x08\x10\n\r\n\x05\x04\x1b\x02\x04\x05\x12\
    \x04\x85\x05\x11\x16\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\x85\x05\x17\
    \x1f\n\r\n\x05\x04\x1b\x02\x04\x03\x12\x04\x85\x05\"#\n\x0c\n\x04\x04\
    \x1b\x02\x05\x12\x04\x86\x05\x081\n\r\n\x05\x04\x1b\x02\x05\x04\x12\x04\
    \x86\x05\x08\x10\n\r\n\x05\x04\x1b\x02\x05\x05\x12\x04\x86\x05\x11\x17\n\
    \r\n\x05\x04\x1b\x02\x05\x01\x12\x04\x86\x05\x18,\n\r\n\x05\x04\x1b\x02\
    \x05\x03\x12\x04\x86\x05/0\n\x0c\n\x02\x04\x1c\x12\x06\x89\x05\0\x8c\x05\
    \x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x89\x05\x08\x1c\n\x0c\n\x04\x04\x1c\
    \x02\0\x12\x04\x8a\x05\x08%\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\x8a\x05\
    \x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\x8a\x05\x11\x16\n\r\n\x05\
    \x04\x1c\x02\0\x01\x12\x04\x8a\x05\x17\x20\n\r\n\x05\x04\x1c\x02\0\x03\
    \x12\x04\x8a\x05#$\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\x8b\x05\x08.\n\r\
    \n\x05\x04\x1c\x02\x01\x04\x12\x04\x8b\x05\x08\x10\n\r\n\x05\x04\x1c\x02\
    \x01\x06\x12\x04\x8b\x05\x11!\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\x8b\
    \x05\")\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\x8b\x05,-\n\x0c\n\x02\x04\
    \x1d\x12\x06\x8e\x05\0\x94\x05\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\x8e\
    \x05\x08&\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\x8f\x05\x08)\n\r\n\x05\x04\
    \x1d\x02\0\x04\x12\x04\x8f\x05\x08\x10\n\r\n\x05\x04\x1d\x02\0\x06\x12\
    \x04\x8f\x05\x11\x1b\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x8f\x05\x1c$\n\
    \r\n\x05\x04\x1d\x02\0\x03\x12\x04\x8f\x05'(\n\x0c\n\x04\x04\x1d\x02\x01\
    \x12\x04\x90\x05\x08\"\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\x90\x05\x08\
    \x10\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\x90\x05\x11\x17\n\r\n\x05\x04\
    \x1d\x02\x01\x01\x12\x04\x90\x05\x18\x1d\n\r\n\x05\x04\x1d\x02\x01\x03\
    \x12\x04\x90\x05\x20!\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\x91\x05\x08\
    \x20\n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\x91\x05\x08\x10\n\r\n\x05\x04\
    \x1d\x02\x02\x05\x12\x04\x91\x05\x11\x16\n\r\n\x05\x04\x1d\x02\x02\x01\
    \x12\x04\x91\x05\x17\x1b\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\x91\x05\
    \x1e\x1f\n\x0c\n\x04\x04\x1d\x02\x03\x12\x04\x92\x05\x08$\n\r\n\x05\x04\
    \x1d\x02\x03\x04\x12\x04\x92\x05\x08\x10\n\r\n\x05\x04\x1d\x02\x03\x05\
    \x12\x04\x92\x05\x11\x16\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\x92\x05\
    \x17\x1f\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\x92\x05\"#\n\x0c\n\x04\
    \x04\x1d\x02\x04\x12\x04\x93\x05\x08!\n\r\n\x05\x04\x1d\x02\x04\x04\x12\
    \x04\x93\x05\x08\x10\n\r\n\x05\x04\x1d\x02\x04\x05\x12\x04\x93\x05\x11\
    \x16\n\r\n\x05\x04\x1d\x02\x04\x01\x12\x04\x93\x05\x17\x1c\n\r\n\x05\x04\
    \x1d\x02\x04\x03\x12\x04\x93\x05\x1f\x20\n\x0c\n\x02\x04\x1e\x12\x06\x96\
    \x05\0\xa3\x05\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\x96\x05\x08+\n\x0c\n\
    \x04\x04\x1e\x02\0\x12\x04\x97\x05\x08'\n\r\n\x05\x04\x1e\x02\0\x04\x12\
    \x04\x97\x05\x08\x10\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\x97\x05\x11\x1b\
    \n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x97\x05\x1c\"\n\r\n\x05\x04\x1e\x02\
    \0\x03\x12\x04\x97\x05%&\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\x98\x05\x08\
    +\n\r\n\x05\x04\x1e\x02\x01\x04\x12\x04\x98\x05\x08\x10\n\r\n\x05\x04\
    \x1e\x02\x01\x06\x12\x04\x98\x05\x11\x1d\n\r\n\x05\x04\x1e\x02\x01\x01\
    \x12\x04\x98\x05\x1e&\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\x98\x05)*\n\
    \x0c\n\x04\x04\x1e\x02\x02\x12\x04\x99\x05\x08$\n\r\n\x05\x04\x1e\x02\
    \x02\x04\x12\x04\x99\x05\x08\x10\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\
    \x99\x05\x11\x16\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\x99\x05\x17\x1f\n\
    \r\n\x05\x04\x1e\x02\x02\x03\x12\x04\x99\x05\"#\n\x0c\n\x04\x04\x1e\x02\
    \x03\x12\x04\x9a\x05\x08+\n\r\n\x05\x04\x1e\x02\x03\x04\x12\x04\x9a\x05\
    \x08\x10\n\r\n\x05\x04\x1e\x02\x03\x05\x12\x04\x9a\x05\x11\x17\n\r\n\x05\
    \x04\x1e\x02\x03\x01\x12\x04\x9a\x05\x18&\n\r\n\x05\x04\x1e\x02\x03\x03\
    \x12\x04\x9a\x05)*\n\x0c\n\x04\x04\x1e\x02\x04\x12\x04\x9b\x05\x08\"\n\r\
    \n\x05\x04\x1e\x02\x04\x04\x12\x04\x9b\x05\x08\x10\n\r\n\x05\x04\x1e\x02\
    \x04\x05\x12\x04\x9b\x05\x11\x16\n\r\n\x05\x04\x1e\x02\x04\x01\x12\x04\
    \x9b\x05\x17\x1d\n\r\n\x05\x04\x1e\x02\x04\x03\x12\x04\x9b\x05\x20!\n\
    \x0c\n\x04\x04\x1e\x02\x05\x12\x04\x9c\x05\x08/\n\r\n\x05\x04\x1e\x02\
    \x05\x04\x12\x04\x9c\x05\x08\x10\n\r\n\x05\x04\x1e\x02\x05\x06\x12\x04\
    \x9c\x05\x11\x1d\n\r\n\x05\x04\x1e\x02\x05\x01\x12\x04\x9c\x05\x1e*\n\r\
    \n\x05\x04\x1e\x02\x05\x03\x12\x04\x9c\x05-.\n\x0c\n\x04\x04\x1e\x02\x06\
    \x12\x04\x9d\x05\x08%\n\r\n\x05\x04\x1e\x02\x06\x04\x12\x04\x9d\x05\x08\
    \x10\n\r\n\x05\x04\x1e\x02\x06\x05\x12\x04\x9d\x05\x11\x16\n\r\n\x05\x04\
    \x1e\x02\x06\x01\x12\x04\x9d\x05\x17\x20\n\r\n\x05\x04\x1e\x02\x06\x03\
    \x12\x04\x9d\x05#$\n\x0c\n\x04\x04\x1e\x02\x07\x12\x04\x9e\x05\x08&\n\r\
    \n\x05\x04\x1e\x02\x07\x04\x12\x04\x9e\x05\x08\x10\n\r\n\x05\x04\x1e\x02\
    \x07\x05\x12\x04\x9e\x05\x11\x16\n\r\n\x05\x04\x1e\x02\x07\x01\x12\x04\
    \x9e\x05\x17!\n\r\n\x05\x04\x1e\x02\x07\x03\x12\x04\x9e\x05$%\n\x0c\n\
    \x04\x04\x1e\x02\x08\x12\x04\x9f\x05\x08-\n\r\n\x05\x04\x1e\x02\x08\x04\
    \x12\x04\x9f\x05\x08\x10\n\r\n\x05\x04\x1e\x02\x08\x05\x12\x04\x9f\x05\
    \x11\x15\n\r\n\x05\x04\x1e\x02\x08\x01\x12\x04\x9f\x05\x16'\n\r\n\x05\
    \x04\x1e\x02\x08\x03\x12\x04\x9f\x05*,\n\x0c\n\x04\x04\x1e\x02\t\x12\x04\
    \xa0\x05\x08%\n\r\n\x05\x04\x1e\x02\t\x04\x12\x04\xa0\x05\x08\x10\n\r\n\
    \x05\x04\x1e\x02\t\x05\x12\x04\xa0\x05\x11\x16\n\r\n\x05\x04\x1e\x02\t\
    \x01\x12\x04\xa0\x05\x17\x1f\n\r\n\x05\x04\x1e\x02\t\x03\x12\x04\xa0\x05\
    \"$\n\x0c\n\x04\x04\x1e\x02\n\x12\x04\xa1\x05\x08,\n\r\n\x05\x04\x1e\x02\
    \n\x04\x12\x04\xa1\x05\x08\x10\n\r\n\x05\x04\x1e\x02\n\x05\x12\x04\xa1\
    \x05\x11\x18\n\r\n\x05\x04\x1e\x02\n\x01\x12\x04\xa1\x05\x19&\n\r\n\x05\
    \x04\x1e\x02\n\x03\x12\x04\xa1\x05)+\n\x0c\n\x04\x04\x1e\x02\x0b\x12\x04\
    \xa2\x05\x08M\n\r\n\x05\x04\x1e\x02\x0b\x04\x12\x04\xa2\x05\x08\x10\n\r\
    \n\x05\x04\x1e\x02\x0b\x06\x12\x04\xa2\x05\x116\n\r\n\x05\x04\x1e\x02\
    \x0b\x01\x12\x04\xa2\x057G\n\r\n\x05\x04\x1e\x02\x0b\x03\x12\x04\xa2\x05\
    JL\n\x0c\n\x02\x04\x1f\x12\x06\xa5\x05\0\xa7\x05\x01\n\x0b\n\x03\x04\x1f\
    \x01\x12\x04\xa5\x05\x08,\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xa6\x05\x08\
    \"\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\xa6\x05\x08\x10\n\r\n\x05\x04\x1f\
    \x02\0\x05\x12\x04\xa6\x05\x11\x16\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\
    \xa6\x05\x17\x1d\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xa6\x05\x20!\n\x0c\
    \n\x02\x04\x20\x12\x06\xa9\x05\0\xac\x05\x01\n\x0b\n\x03\x04\x20\x01\x12\
    \x04\xa9\x05\x08-\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xaa\x05\x08$\n\r\n\
    \x05\x04\x20\x02\0\x04\x12\x04\xaa\x05\x08\x10\n\r\n\x05\x04\x20\x02\0\
    \x05\x12\x04\xaa\x05\x11\x16\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xaa\x05\
    \x17\x1f\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xaa\x05\"#\n\x0c\n\x04\x04\
    \x20\x02\x01\x12\x04\xab\x05\x08'\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\
    \xab\x05\x08\x10\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xab\x05\x11\x15\n\
    \r\n\x05\x04\x20\x02\x01\x01\x12\x04\xab\x05\x16\"\n\r\n\x05\x04\x20\x02\
    \x01\x03\x12\x04\xab\x05%&\n\x0c\n\x02\x04!\x12\x06\xae\x05\0\xb2\x05\
    \x01\n\x0b\n\x03\x04!\x01\x12\x04\xae\x05\x08)\n\x0c\n\x04\x04!\x02\0\
    \x12\x04\xaf\x05\x08$\n\r\n\x05\x04!\x02\0\x04\x12\x04\xaf\x05\x08\x10\n\
    \r\n\x05\x04!\x02\0\x05\x12\x04\xaf\x05\x11\x16\n\r\n\x05\x04!\x02\0\x01\
    \x12\x04\xaf\x05\x17\x1f\n\r\n\x05\x04!\x02\0\x03\x12\x04\xaf\x05\"#\n\
    \x0c\n\x04\x04!\x02\x01\x12\x04\xb0\x05\x08&\n\r\n\x05\x04!\x02\x01\x04\
    \x12\x04\xb0\x05\x08\x10\n\r\n\x05\x04!\x02\x01\x05\x12\x04\xb0\x05\x11\
    \x16\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xb0\x05\x17!\n\r\n\x05\x04!\x02\
    \x01\x03\x12\x04\xb0\x05$%\n\x0c\n\x04\x04!\x02\x02\x12\x04\xb1\x05\x08(\
    \n\r\n\x05\x04!\x02\x02\x04\x12\x04\xb1\x05\x08\x10\n\r\n\x05\x04!\x02\
    \x02\x05\x12\x04\xb1\x05\x11\x16\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xb1\
    \x05\x17#\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xb1\x05&'\n\x0c\n\x02\x04\"\
    \x12\x06\xb4\x05\0\xbe\x05\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xb4\x05\x08\
    .\n\x0c\n\x04\x04\"\x02\0\x12\x04\xb5\x05\x08$\n\r\n\x05\x04\"\x02\0\x04\
    \x12\x04\xb5\x05\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xb5\x05\x11\
    \x16\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xb5\x05\x17\x1f\n\r\n\x05\x04\"\
    \x02\0\x03\x12\x04\xb5\x05\"#\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xb6\x05\
    \x08&\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xb6\x05\x08\x10\n\r\n\x05\x04\
    \"\x02\x01\x05\x12\x04\xb6\x05\x11\x16\n\r\n\x05\x04\"\x02\x01\x01\x12\
    \x04\xb6\x05\x17!\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xb6\x05$%\n\x0c\n\
    \x04\x04\"\x02\x02\x12\x04\xb7\x05\x08!\n\r\n\x05\x04\"\x02\x02\x04\x12\
    \x04\xb7\x05\x08\x10\n\r\n\x05\x04\"\x02\x02\x05\x12\x04\xb7\x05\x11\x16\
    \n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xb7\x05\x17\x1c\n\r\n\x05\x04\"\x02\
    \x02\x03\x12\x04\xb7\x05\x1f\x20\n\x0c\n\x04\x04\"\x02\x03\x12\x04\xb8\
    \x05\x08(\n\r\n\x05\x04\"\x02\x03\x04\x12\x04\xb8\x05\x08\x10\n\r\n\x05\
    \x04\"\x02\x03\x05\x12\x04\xb8\x05\x11\x16\n\r\n\x05\x04\"\x02\x03\x01\
    \x12\x04\xb8\x05\x17#\n\r\n\x05\x04\"\x02\x03\x03\x12\x04\xb8\x05&'\n\
    \x0c\n\x04\x04\"\x02\x04\x12\x04\xb9\x05\x08&\n\r\n\x05\x04\"\x02\x04\
    \x04\x12\x04\xb9\x05\x08\x10\n\r\n\x05\x04\"\x02\x04\x05\x12\x04\xb9\x05\
    \x11\x16\n\r\n\x05\x04\"\x02\x04\x01\x12\x04\xb9\x05\x17!\n\r\n\x05\x04\
    \"\x02\x04\x03\x12\x04\xb9\x05$%\n\x0c\n\x04\x04\"\x02\x05\x12\x04\xba\
    \x05\x08)\n\r\n\x05\x04\"\x02\x05\x04\x12\x04\xba\x05\x08\x10\n\r\n\x05\
    \x04\"\x02\x05\x06\x12\x04\xba\x05\x11\x1b\n\r\n\x05\x04\"\x02\x05\x01\
    \x12\x04\xba\x05\x1c$\n\r\n\x05\x04\"\x02\x05\x03\x12\x04\xba\x05'(\n\
    \x0c\n\x04\x04\"\x02\x06\x12\x04\xbb\x05\x08\x20\n\r\n\x05\x04\"\x02\x06\
    \x04\x12\x04\xbb\x05\x08\x10\n\r\n\x05\x04\"\x02\x06\x05\x12\x04\xbb\x05\
    \x11\x15\n\r\n\x05\x04\"\x02\x06\x01\x12\x04\xbb\x05\x16\x1b\n\r\n\x05\
    \x04\"\x02\x06\x03\x12\x04\xbb\x05\x1e\x1f\n\x0c\n\x04\x04\"\x02\x07\x12\
    \x04\xbc\x05\x08+\n\r\n\x05\x04\"\x02\x07\x04\x12\x04\xbc\x05\x08\x10\n\
    \r\n\x05\x04\"\x02\x07\x05\x12\x04\xbc\x05\x11\x16\n\r\n\x05\x04\"\x02\
    \x07\x01\x12\x04\xbc\x05\x17&\n\r\n\x05\x04\"\x02\x07\x03\x12\x04\xbc\
    \x05)*\n\x0c\n\x04\x04\"\x02\x08\x12\x04\xbd\x05\x08\"\n\r\n\x05\x04\"\
    \x02\x08\x04\x12\x04\xbd\x05\x08\x10\n\r\n\x05\x04\"\x02\x08\x05\x12\x04\
    \xbd\x05\x11\x17\n\r\n\x05\x04\"\x02\x08\x01\x12\x04\xbd\x05\x18\x1d\n\r\
    \n\x05\x04\"\x02\x08\x03\x12\x04\xbd\x05\x20!\n\x0c\n\x02\x04#\x12\x06\
    \xc0\x05\0\xc5\x05\x01\n\x0b\n\x03\x04#\x01\x12\x04\xc0\x05\x08%\n\x0c\n\
    \x04\x04#\x02\0\x12\x04\xc1\x05\x08*\n\r\n\x05\x04#\x02\0\x04\x12\x04\
    \xc1\x05\x08\x10\n\r\n\x05\x04#\x02\0\x05\x12\x04\xc1\x05\x11\x17\n\r\n\
    \x05\x04#\x02\0\x01\x12\x04\xc1\x05\x18%\n\r\n\x05\x04#\x02\0\x03\x12\
    \x04\xc1\x05()\n\x0c\n\x04\x04#\x02\x01\x12\x04\xc2\x05\x08!\n\r\n\x05\
    \x04#\x02\x01\x04\x12\x04\xc2\x05\x08\x10\n\r\n\x05\x04#\x02\x01\x05\x12\
    \x04\xc2\x05\x11\x16\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xc2\x05\x17\x1c\
    \n\r\n\x05\x04#\x02\x01\x03\x12\x04\xc2\x05\x1f\x20\n\x0c\n\x04\x04#\x02\
    \x02\x12\x04\xc3\x05\x08'\n\r\n\x05\x04#\x02\x02\x04\x12\x04\xc3\x05\x08\
    \x10\n\r\n\x05\x04#\x02\x02\x06\x12\x04\xc3\x05\x11\x1b\n\r\n\x05\x04#\
    \x02\x02\x01\x12\x04\xc3\x05\x1c\"\n\r\n\x05\x04#\x02\x02\x03\x12\x04\
    \xc3\x05%&\n\x0c\n\x04\x04#\x02\x03\x12\x04\xc4\x05\x08\"\n\r\n\x05\x04#\
    \x02\x03\x04\x12\x04\xc4\x05\x08\x10\n\r\n\x05\x04#\x02\x03\x05\x12\x04\
    \xc4\x05\x11\x15\n\r\n\x05\x04#\x02\x03\x01\x12\x04\xc4\x05\x16\x1d\n\r\
    \n\x05\x04#\x02\x03\x03\x12\x04\xc4\x05\x20!\n\x0c\n\x02\x04$\x12\x06\
    \xc7\x05\0\xca\x05\x01\n\x0b\n\x03\x04$\x01\x12\x04\xc7\x05\x08#\n\x0c\n\
    \x04\x04$\x02\0\x12\x04\xc8\x05\x08$\n\r\n\x05\x04$\x02\0\x04\x12\x04\
    \xc8\x05\x08\x10\n\r\n\x05\x04$\x02\0\x05\x12\x04\xc8\x05\x11\x17\n\r\n\
    \x05\x04$\x02\0\x01\x12\x04\xc8\x05\x18\x1f\n\r\n\x05\x04$\x02\0\x03\x12\
    \x04\xc8\x05\"#\n\x0c\n\x04\x04$\x02\x01\x12\x04\xc9\x05\x08+\n\r\n\x05\
    \x04$\x02\x01\x04\x12\x04\xc9\x05\x08\x10\n\r\n\x05\x04$\x02\x01\x05\x12\
    \x04\xc9\x05\x11\x16\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xc9\x05\x17&\n\r\
    \n\x05\x04$\x02\x01\x03\x12\x04\xc9\x05)*\n\x0c\n\x02\x04%\x12\x06\xcc\
    \x05\0\xcf\x05\x01\n\x0b\n\x03\x04%\x01\x12\x04\xcc\x05\x08\x1d\n\x0c\n\
    \x04\x04%\x02\0\x12\x04\xcd\x05\x08$\n\r\n\x05\x04%\x02\0\x04\x12\x04\
    \xcd\x05\x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\xcd\x05\x11\x16\n\r\n\
    \x05\x04%\x02\0\x01\x12\x04\xcd\x05\x17\x1f\n\r\n\x05\x04%\x02\0\x03\x12\
    \x04\xcd\x05\"#\n\x0c\n\x04\x04%\x02\x01\x12\x04\xce\x05\x08+\n\r\n\x05\
    \x04%\x02\x01\x04\x12\x04\xce\x05\x08\x10\n\r\n\x05\x04%\x02\x01\x05\x12\
    \x04\xce\x05\x11\x16\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xce\x05\x17&\n\r\
    \n\x05\x04%\x02\x01\x03\x12\x04\xce\x05)*\n\x0c\n\x02\x04&\x12\x06\xd1\
    \x05\0\xd6\x05\x01\n\x0b\n\x03\x04&\x01\x12\x04\xd1\x05\x08#\n\x0c\n\x04\
    \x04&\x02\0\x12\x04\xd2\x05\x08$\n\r\n\x05\x04&\x02\0\x04\x12\x04\xd2\
    \x05\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\xd2\x05\x11\x16\n\r\n\x05\
    \x04&\x02\0\x01\x12\x04\xd2\x05\x17\x1f\n\r\n\x05\x04&\x02\0\x03\x12\x04\
    \xd2\x05\"#\n\x0c\n\x04\x04&\x02\x01\x12\x04\xd3\x05\x08!\n\r\n\x05\x04&\
    \x02\x01\x04\x12\x04\xd3\x05\x08\x10\n\r\n\x05\x04&\x02\x01\x05\x12\x04\
    \xd3\x05\x11\x17\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xd3\x05\x18\x1c\n\r\
    \n\x05\x04&\x02\x01\x03\x12\x04\xd3\x05\x1f\x20\n\x0c\n\x04\x04&\x02\x02\
    \x12\x04\xd4\x05\x08$\n\r\n\x05\x04&\x02\x02\x04\x12\x04\xd4\x05\x08\x10\
    \n\r\n\x05\x04&\x02\x02\x05\x12\x04\xd4\x05\x11\x16\n\r\n\x05\x04&\x02\
    \x02\x01\x12\x04\xd4\x05\x17\x1f\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xd4\
    \x05\"#\n\x0c\n\x04\x04&\x02\x03\x12\x04\xd5\x05\x08&\n\r\n\x05\x04&\x02\
    \x03\x04\x12\x04\xd5\x05\x08\x10\n\r\n\x05\x04&\x02\x03\x05\x12\x04\xd5\
    \x05\x11\x16\n\r\n\x05\x04&\x02\x03\x01\x12\x04\xd5\x05\x17!\n\r\n\x05\
    \x04&\x02\x03\x03\x12\x04\xd5\x05$%\n\x0c\n\x02\x04'\x12\x06\xd8\x05\0\
    \xda\x05\x01\n\x0b\n\x03\x04'\x01\x12\x04\xd8\x05\x08'\n\x0c\n\x04\x04'\
    \x02\0\x12\x04\xd9\x05\x08!\n\r\n\x05\x04'\x02\0\x04\x12\x04\xd9\x05\x08\
    \x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xd9\x05\x11\x17\n\r\n\x05\x04'\x02\
    \0\x01\x12\x04\xd9\x05\x18\x1c\n\r\n\x05\x04'\x02\0\x03\x12\x04\xd9\x05\
    \x1f\x20\n\x0c\n\x02\x04(\x12\x06\xdc\x05\0\xe0\x05\x01\n\x0b\n\x03\x04(\
    \x01\x12\x04\xdc\x05\x08#\n\x0c\n\x04\x04(\x02\0\x12\x04\xdd\x05\x08&\n\
    \r\n\x05\x04(\x02\0\x04\x12\x04\xdd\x05\x08\x10\n\r\n\x05\x04(\x02\0\x05\
    \x12\x04\xdd\x05\x11\x17\n\r\n\x05\x04(\x02\0\x01\x12\x04\xdd\x05\x18!\n\
    \r\n\x05\x04(\x02\0\x03\x12\x04\xdd\x05$%\n\x0c\n\x04\x04(\x02\x01\x12\
    \x04\xde\x05\x08&\n\r\n\x05\x04(\x02\x01\x04\x12\x04\xde\x05\x08\x10\n\r\
    \n\x05\x04(\x02\x01\x05\x12\x04\xde\x05\x11\x16\n\r\n\x05\x04(\x02\x01\
    \x01\x12\x04\xde\x05\x17!\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xde\x05$%\n\
    \x0c\n\x04\x04(\x02\x02\x12\x04\xdf\x05\x08'\n\r\n\x05\x04(\x02\x02\x04\
    \x12\x04\xdf\x05\x08\x10\n\r\n\x05\x04(\x02\x02\x05\x12\x04\xdf\x05\x11\
    \x17\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xdf\x05\x18\"\n\r\n\x05\x04(\x02\
    \x02\x03\x12\x04\xdf\x05%&\n\x0c\n\x02\x04)\x12\x06\xe2\x05\0\xf4\x05\
    \x01\n\x0b\n\x03\x04)\x01\x12\x04\xe2\x05\x08%\n\x0e\n\x04\x04)\x03\0\
    \x12\x06\xe3\x05\x08\xee\x05\t\n\r\n\x05\x04)\x03\0\x01\x12\x04\xe3\x05\
    \x10\x1a\n\x10\n\x06\x04)\x03\0\x04\0\x12\x06\xe4\x05\x10\xe7\x05\x11\n\
    \x0f\n\x07\x04)\x03\0\x04\0\x01\x12\x04\xe4\x05\x15\x1c\n\x10\n\x08\x04)\
    \x03\0\x04\0\x02\0\x12\x04\xe5\x05\x182\n\x11\n\t\x04)\x03\0\x04\0\x02\0\
    \x01\x12\x04\xe5\x05\x18-\n\x11\n\t\x04)\x03\0\x04\0\x02\0\x02\x12\x04\
    \xe5\x0501\n\x10\n\x08\x04)\x03\0\x04\0\x02\x01\x12\x04\xe6\x05\x180\n\
    \x11\n\t\x04)\x03\0\x04\0\x02\x01\x01\x12\x04\xe6\x05\x18+\n\x11\n\t\x04\
    )\x03\0\x04\0\x02\x01\x02\x12\x04\xe6\x05./\n\x0e\n\x06\x04)\x03\0\x02\0\
    \x12\x04\xe9\x05\x10-\n\x0f\n\x07\x04)\x03\0\x02\0\x04\x12\x04\xe9\x05\
    \x10\x18\n\x0f\n\x07\x04)\x03\0\x02\0\x05\x12\x04\xe9\x05\x19\x1f\n\x0f\
    \n\x07\x04)\x03\0\x02\0\x01\x12\x04\xe9\x05\x20(\n\x0f\n\x07\x04)\x03\0\
    \x02\0\x03\x12\x04\xe9\x05+,\n\x0e\n\x06\x04)\x03\0\x02\x01\x12\x04\xea\
    \x05\x100\n\x0f\n\x07\x04)\x03\0\x02\x01\x04\x12\x04\xea\x05\x10\x18\n\
    \x0f\n\x07\x04)\x03\0\x02\x01\x05\x12\x04\xea\x05\x19\x1f\n\x0f\n\x07\
    \x04)\x03\0\x02\x01\x01\x12\x04\xea\x05\x20+\n\x0f\n\x07\x04)\x03\0\x02\
    \x01\x03\x12\x04\xea\x05./\n\x0e\n\x06\x04)\x03\0\x02\x02\x12\x04\xeb\
    \x05\x10.\n\x0f\n\x07\x04)\x03\0\x02\x02\x04\x12\x04\xeb\x05\x10\x18\n\
    \x0f\n\x07\x04)\x03\0\x02\x02\x05\x12\x04\xeb\x05\x19\x1f\n\x0f\n\x07\
    \x04)\x03\0\x02\x02\x01\x12\x04\xeb\x05\x20)\n\x0f\n\x07\x04)\x03\0\x02\
    \x02\x03\x12\x04\xeb\x05,-\n\x0e\n\x06\x04)\x03\0\x02\x03\x12\x04\xec\
    \x05\x10U\n\x0f\n\x07\x04)\x03\0\x02\x03\x04\x12\x04\xec\x05\x10\x18\n\
    \x0f\n\x07\x04)\x03\0\x02\x03\x06\x12\x04\xec\x05\x19I\n\x0f\n\x07\x04)\
    \x03\0\x02\x03\x01\x12\x04\xec\x05JP\n\x0f\n\x07\x04)\x03\0\x02\x03\x03\
    \x12\x04\xec\x05ST\n\x0e\n\x06\x04)\x03\0\x02\x04\x12\x04\xed\x05\x106\n\
    \x0f\n\x07\x04)\x03\0\x02\x04\x04\x12\x04\xed\x05\x10\x18\n\x0f\n\x07\
    \x04)\x03\0\x02\x04\x05\x12\x04\xed\x05\x19\x1f\n\x0f\n\x07\x04)\x03\0\
    \x02\x04\x01\x12\x04\xed\x05\x201\n\x0f\n\x07\x04)\x03\0\x02\x04\x03\x12\
    \x04\xed\x0545\n\x0c\n\x04\x04)\x02\0\x12\x04\xf0\x05\x08'\n\r\n\x05\x04\
    )\x02\0\x04\x12\x04\xf0\x05\x08\x10\n\r\n\x05\x04)\x02\0\x05\x12\x04\xf0\
    \x05\x11\x17\n\r\n\x05\x04)\x02\0\x01\x12\x04\xf0\x05\x18\"\n\r\n\x05\
    \x04)\x02\0\x03\x12\x04\xf0\x05%&\n\x0c\n\x04\x04)\x02\x01\x12\x04\xf1\
    \x05\x08%\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xf1\x05\x08\x10\n\r\n\x05\
    \x04)\x02\x01\x05\x12\x04\xf1\x05\x11\x17\n\r\n\x05\x04)\x02\x01\x01\x12\
    \x04\xf1\x05\x18\x20\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xf1\x05#$\n\x0c\
    \n\x04\x04)\x02\x02\x12\x04\xf2\x05\x08\"\n\r\n\x05\x04)\x02\x02\x04\x12\
    \x04\xf2\x05\x08\x10\n\r\n\x05\x04)\x02\x02\x05\x12\x04\xf2\x05\x11\x15\
    \n\r\n\x05\x04)\x02\x02\x01\x12\x04\xf2\x05\x16\x1d\n\r\n\x05\x04)\x02\
    \x02\x03\x12\x04\xf2\x05\x20!\n\x0c\n\x04\x04)\x02\x03\x12\x04\xf3\x05\
    \x08J\n\r\n\x05\x04)\x02\x03\x04\x12\x04\xf3\x05\x08\x10\n\r\n\x05\x04)\
    \x02\x03\x06\x12\x04\xf3\x05\x119\n\r\n\x05\x04)\x02\x03\x01\x12\x04\xf3\
    \x05:E\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xf3\x05HI\n\x0c\n\x02\x04*\x12\
    \x06\xf6\x05\0\x88\x06\x01\n\x0b\n\x03\x04*\x01\x12\x04\xf6\x05\x08$\n\
    \x0e\n\x04\x04*\x03\0\x12\x06\xf7\x05\x08\x85\x06\t\n\r\n\x05\x04*\x03\0\
    \x01\x12\x04\xf7\x05\x10\x14\n\x10\n\x06\x04*\x03\0\x04\0\x12\x06\xf8\
    \x05\x10\xfd\x05\x11\n\x0f\n\x07\x04*\x03\0\x04\0\x01\x12\x04\xf8\x05\
    \x15\x1e\n\x10\n\x08\x04*\x03\0\x04\0\x02\0\x12\x04\xf9\x05\x18$\n\x11\n\
    \t\x04*\x03\0\x04\0\x02\0\x01\x12\x04\xf9\x05\x18\x1f\n\x11\n\t\x04*\x03\
    \0\x04\0\x02\0\x02\x12\x04\xf9\x05\"#\n\x10\n\x08\x04*\x03\0\x04\0\x02\
    \x01\x12\x04\xfa\x05\x18#\n\x11\n\t\x04*\x03\0\x04\0\x02\x01\x01\x12\x04\
    \xfa\x05\x18\x1e\n\x11\n\t\x04*\x03\0\x04\0\x02\x01\x02\x12\x04\xfa\x05!\
    \"\n\x10\n\x08\x04*\x03\0\x04\0\x02\x02\x12\x04\xfb\x05\x18.\n\x11\n\t\
    \x04*\x03\0\x04\0\x02\x02\x01\x12\x04\xfb\x05\x18)\n\x11\n\t\x04*\x03\0\
    \x04\0\x02\x02\x02\x12\x04\xfb\x05,-\n\x10\n\x08\x04*\x03\0\x04\0\x02\
    \x03\x12\x04\xfc\x05\x18(\n\x11\n\t\x04*\x03\0\x04\0\x02\x03\x01\x12\x04\
    \xfc\x05\x18#\n\x11\n\t\x04*\x03\0\x04\0\x02\x03\x02\x12\x04\xfc\x05&'\n\
    \x0e\n\x06\x04*\x03\0\x02\0\x12\x04\xff\x05\x10'\n\x0f\n\x07\x04*\x03\0\
    \x02\0\x04\x12\x04\xff\x05\x10\x18\n\x0f\n\x07\x04*\x03\0\x02\0\x05\x12\
    \x04\xff\x05\x19\x1e\n\x0f\n\x07\x04*\x03\0\x02\0\x01\x12\x04\xff\x05\
    \x1f\"\n\x0f\n\x07\x04*\x03\0\x02\0\x03\x12\x04\xff\x05%&\n\x0e\n\x06\
    \x04*\x03\0\x02\x01\x12\x04\x80\x06\x10Q\n\x0f\n\x07\x04*\x03\0\x02\x01\
    \x04\x12\x04\x80\x06\x10\x18\n\x0f\n\x07\x04*\x03\0\x02\x01\x06\x12\x04\
    \x80\x06\x19D\n\x0f\n\x07\x04*\x03\0\x02\x01\x01\x12\x04\x80\x06EL\n\x0f\
    \n\x07\x04*\x03\0\x02\x01\x03\x12\x04\x80\x06OP\n\x0e\n\x06\x04*\x03\0\
    \x02\x02\x12\x04\x81\x06\x10/\n\x0f\n\x07\x04*\x03\0\x02\x02\x04\x12\x04\
    \x81\x06\x10\x18\n\x0f\n\x07\x04*\x03\0\x02\x02\x05\x12\x04\x81\x06\x19\
    \x1e\n\x0f\n\x07\x04*\x03\0\x02\x02\x01\x12\x04\x81\x06\x1f*\n\x0f\n\x07\
    \x04*\x03\0\x02\x02\x03\x12\x04\x81\x06-.\n\x0e\n\x06\x04*\x03\0\x02\x03\
    \x12\x04\x82\x06\x10/\n\x0f\n\x07\x04*\x03\0\x02\x03\x04\x12\x04\x82\x06\
    \x10\x18\n\x0f\n\x07\x04*\x03\0\x02\x03\x05\x12\x04\x82\x06\x19\x1f\n\
    \x0f\n\x07\x04*\x03\0\x02\x03\x01\x12\x04\x82\x06\x20*\n\x0f\n\x07\x04*\
    \x03\0\x02\x03\x03\x12\x04\x82\x06-.\n\x0e\n\x06\x04*\x03\0\x02\x04\x12\
    \x04\x83\x06\x109\n\x0f\n\x07\x04*\x03\0\x02\x04\x04\x12\x04\x83\x06\x10\
    \x18\n\x0f\n\x07\x04*\x03\0\x02\x04\x05\x12\x04\x83\x06\x19\x1e\n\x0f\n\
    \x07\x04*\x03\0\x02\x04\x01\x12\x04\x83\x06\x1f4\n\x0f\n\x07\x04*\x03\0\
    \x02\x04\x03\x12\x04\x83\x0678\n\x0e\n\x06\x04*\x03\0\x02\x05\x12\x04\
    \x84\x06\x104\n\x0f\n\x07\x04*\x03\0\x02\x05\x04\x12\x04\x84\x06\x10\x18\
    \n\x0f\n\x07\x04*\x03\0\x02\x05\x05\x12\x04\x84\x06\x19\x1f\n\x0f\n\x07\
    \x04*\x03\0\x02\x05\x01\x12\x04\x84\x06\x20/\n\x0f\n\x07\x04*\x03\0\x02\
    \x05\x03\x12\x04\x84\x0623\n\x0c\n\x04\x04*\x02\0\x12\x04\x87\x06\x08=\n\
    \r\n\x05\x04*\x02\0\x04\x12\x04\x87\x06\x08\x10\n\r\n\x05\x04*\x02\0\x06\
    \x12\x04\x87\x06\x112\n\r\n\x05\x04*\x02\0\x01\x12\x04\x87\x0638\n\r\n\
    \x05\x04*\x02\0\x03\x12\x04\x87\x06;<\n\x0c\n\x02\x04+\x12\x06\x8a\x06\0\
    \x8f\x06\x01\n\x0b\n\x03\x04+\x01\x12\x04\x8a\x06\x08\x20\n\x0c\n\x04\
    \x04+\x02\0\x12\x04\x8b\x06\x08*\n\r\n\x05\x04+\x02\0\x04\x12\x04\x8b\
    \x06\x08\x10\n\r\n\x05\x04+\x02\0\x05\x12\x04\x8b\x06\x11\x16\n\r\n\x05\
    \x04+\x02\0\x01\x12\x04\x8b\x06\x17%\n\r\n\x05\x04+\x02\0\x03\x12\x04\
    \x8b\x06()\n\x0c\n\x04\x04+\x02\x01\x12\x04\x8c\x06\x08*\n\r\n\x05\x04+\
    \x02\x01\x04\x12\x04\x8c\x06\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\
    \x8c\x06\x11\x16\n\r\n\x05\x04+\x02\x01\x01\x12\x04\x8c\x06\x17%\n\r\n\
    \x05\x04+\x02\x01\x03\x12\x04\x8c\x06()\n\x0c\n\x04\x04+\x02\x02\x12\x04\
    \x8d\x06\x08@\n\r\n\x05\x04+\x02\x02\x04\x12\x04\x8d\x06\x08\x10\n\r\n\
    \x05\x04+\x02\x02\x06\x12\x04\x8d\x06\x11-\n\r\n\x05\x04+\x02\x02\x01\
    \x12\x04\x8d\x06.;\n\r\n\x05\x04+\x02\x02\x03\x12\x04\x8d\x06>?\n\x0c\n\
    \x04\x04+\x02\x03\x12\x04\x8e\x06\x08)\n\r\n\x05\x04+\x02\x03\x04\x12\
    \x04\x8e\x06\x08\x10\n\r\n\x05\x04+\x02\x03\x05\x12\x04\x8e\x06\x11\x19\
    \n\r\n\x05\x04+\x02\x03\x01\x12\x04\x8e\x06\x1a$\n\r\n\x05\x04+\x02\x03\
    \x03\x12\x04\x8e\x06'(\n\x0c\n\x02\x04,\x12\x06\x91\x06\0\xc4\x06\x01\n\
    \x0b\n\x03\x04,\x01\x12\x04\x91\x06\x08\x1e\n\x0e\n\x04\x04,\x03\0\x12\
    \x06\x92\x06\x08\x95\x06\t\n\r\n\x05\x04,\x03\0\x01\x12\x04\x92\x06\x10\
    \x18\n\x0e\n\x06\x04,\x03\0\x02\0\x12\x04\x93\x06\x10)\n\x0f\n\x07\x04,\
    \x03\0\x02\0\x04\x12\x04\x93\x06\x10\x18\n\x0f\n\x07\x04,\x03\0\x02\0\
    \x05\x12\x04\x93\x06\x19\x1e\n\x0f\n\x07\x04,\x03\0\x02\0\x01\x12\x04\
    \x93\x06\x1f$\n\x0f\n\x07\x04,\x03\0\x02\0\x03\x12\x04\x93\x06'(\n\x0e\n\
    \x06\x04,\x03\0\x02\x01\x12\x04\x94\x06\x10)\n\x0f\n\x07\x04,\x03\0\x02\
    \x01\x04\x12\x04\x94\x06\x10\x18\n\x0f\n\x07\x04,\x03\0\x02\x01\x05\x12\
    \x04\x94\x06\x19\x1e\n\x0f\n\x07\x04,\x03\0\x02\x01\x01\x12\x04\x94\x06\
    \x1f$\n\x0f\n\x07\x04,\x03\0\x02\x01\x03\x12\x04\x94\x06'(\n\x0e\n\x04\
    \x04,\x03\x01\x12\x06\x97\x06\x08\x9e\x06\t\n\r\n\x05\x04,\x03\x01\x01\
    \x12\x04\x97\x06\x10\x16\n\x0e\n\x06\x04,\x03\x01\x02\0\x12\x04\x98\x06\
    \x102\n\x0f\n\x07\x04,\x03\x01\x02\0\x04\x12\x04\x98\x06\x10\x18\n\x0f\n\
    \x07\x04,\x03\x01\x02\0\x05\x12\x04\x98\x06\x19\x1e\n\x0f\n\x07\x04,\x03\
    \x01\x02\0\x01\x12\x04\x98\x06\x1f-\n\x0f\n\x07\x04,\x03\x01\x02\0\x03\
    \x12\x04\x98\x0601\n\x0e\n\x06\x04,\x03\x01\x02\x01\x12\x04\x99\x06\x10-\
    \n\x0f\n\x07\x04,\x03\x01\x02\x01\x04\x12\x04\x99\x06\x10\x18\n\x0f\n\
    \x07\x04,\x03\x01\x02\x01\x05\x12\x04\x99\x06\x19\x1f\n\x0f\n\x07\x04,\
    \x03\x01\x02\x01\x01\x12\x04\x99\x06\x20(\n\x0f\n\x07\x04,\x03\x01\x02\
    \x01\x03\x12\x04\x99\x06+,\n\x0e\n\x06\x04,\x03\x01\x02\x02\x12\x04\x9a\
    \x06\x102\n\x0f\n\x07\x04,\x03\x01\x02\x02\x04\x12\x04\x9a\x06\x10\x18\n\
    \x0f\n\x07\x04,\x03\x01\x02\x02\x05\x12\x04\x9a\x06\x19\x1e\n\x0f\n\x07\
    \x04,\x03\x01\x02\x02\x01\x12\x04\x9a\x06\x1f-\n\x0f\n\x07\x04,\x03\x01\
    \x02\x02\x03\x12\x04\x9a\x0601\n\x0e\n\x06\x04,\x03\x01\x02\x03\x12\x04\
    \x9b\x06\x10+\n\x0f\n\x07\x04,\x03\x01\x02\x03\x04\x12\x04\x9b\x06\x10\
    \x18\n\x0f\n\x07\x04,\x03\x01\x02\x03\x05\x12\x04\x9b\x06\x19\x1d\n\x0f\
    \n\x07\x04,\x03\x01\x02\x03\x01\x12\x04\x9b\x06\x1e&\n\x0f\n\x07\x04,\
    \x03\x01\x02\x03\x03\x12\x04\x9b\x06)*\n\x0e\n\x06\x04,\x03\x01\x02\x04\
    \x12\x04\x9c\x06\x10F\n\x0f\n\x07\x04,\x03\x01\x02\x04\x04\x12\x04\x9c\
    \x06\x10\x18\n\x0f\n\x07\x04,\x03\x01\x02\x04\x06\x12\x04\x9c\x06\x198\n\
    \x0f\n\x07\x04,\x03\x01\x02\x04\x01\x12\x04\x9c\x069A\n\x0f\n\x07\x04,\
    \x03\x01\x02\x04\x03\x12\x04\x9c\x06DE\n\x0e\n\x06\x04,\x03\x01\x02\x05\
    \x12\x04\x9d\x06\x10*\n\x0f\n\x07\x04,\x03\x01\x02\x05\x04\x12\x04\x9d\
    \x06\x10\x18\n\x0f\n\x07\x04,\x03\x01\x02\x05\x05\x12\x04\x9d\x06\x19\
    \x1f\n\x0f\n\x07\x04,\x03\x01\x02\x05\x01\x12\x04\x9d\x06\x20%\n\x0f\n\
    \x07\x04,\x03\x01\x02\x05\x03\x12\x04\x9d\x06()\n\x0e\n\x04\x04,\x03\x02\
    \x12\x06\xa0\x06\x08\xa2\x06\t\n\r\n\x05\x04,\x03\x02\x01\x12\x04\xa0\
    \x06\x10\x1a\n\x0e\n\x06\x04,\x03\x02\x02\0\x12\x04\xa1\x06\x10)\n\x0f\n\
    \x07\x04,\x03\x02\x02\0\x04\x12\x04\xa1\x06\x10\x18\n\x0f\n\x07\x04,\x03\
    \x02\x02\0\x05\x12\x04\xa1\x06\x19\x1e\n\x0f\n\x07\x04,\x03\x02\x02\0\
    \x01\x12\x04\xa1\x06\x1f$\n\x0f\n\x07\x04,\x03\x02\x02\0\x03\x12\x04\xa1\
    \x06'(\n\x0e\n\x04\x04,\x03\x03\x12\x06\xa4\x06\x08\xab\x06\t\n\r\n\x05\
    \x04,\x03\x03\x01\x12\x04\xa4\x06\x10\x1a\n\x0e\n\x06\x04,\x03\x03\x02\0\
    \x12\x04\xa5\x06\x10,\n\x0f\n\x07\x04,\x03\x03\x02\0\x04\x12\x04\xa5\x06\
    \x10\x18\n\x0f\n\x07\x04,\x03\x03\x02\0\x05\x12\x04\xa5\x06\x19\x1e\n\
    \x0f\n\x07\x04,\x03\x03\x02\0\x01\x12\x04\xa5\x06\x1f'\n\x0f\n\x07\x04,\
    \x03\x03\x02\0\x03\x12\x04\xa5\x06*+\n\x0e\n\x06\x04,\x03\x03\x02\x01\
    \x12\x04\xa6\x06\x10(\n\x0f\n\x07\x04,\x03\x03\x02\x01\x04\x12\x04\xa6\
    \x06\x10\x18\n\x0f\n\x07\x04,\x03\x03\x02\x01\x05\x12\x04\xa6\x06\x19\
    \x1e\n\x0f\n\x07\x04,\x03\x03\x02\x01\x01\x12\x04\xa6\x06\x1f#\n\x0f\n\
    \x07\x04,\x03\x03\x02\x01\x03\x12\x04\xa6\x06&'\n\x0e\n\x06\x04,\x03\x03\
    \x02\x02\x12\x04\xa7\x06\x10+\n\x0f\n\x07\x04,\x03\x03\x02\x02\x04\x12\
    \x04\xa7\x06\x10\x18\n\x0f\n\x07\x04,\x03\x03\x02\x02\x05\x12\x04\xa7\
    \x06\x19\x1e\n\x0f\n\x07\x04,\x03\x03\x02\x02\x01\x12\x04\xa7\x06\x1f&\n\
    \x0f\n\x07\x04,\x03\x03\x02\x02\x03\x12\x04\xa7\x06)*\n\x0e\n\x06\x04,\
    \x03\x03\x02\x03\x12\x04\xa8\x06\x10,\n\x0f\n\x07\x04,\x03\x03\x02\x03\
    \x04\x12\x04\xa8\x06\x10\x18\n\x0f\n\x07\x04,\x03\x03\x02\x03\x05\x12\
    \x04\xa8\x06\x19\x1e\n\x0f\n\x07\x04,\x03\x03\x02\x03\x01\x12\x04\xa8\
    \x06\x1f'\n\x0f\n\x07\x04,\x03\x03\x02\x03\x03\x12\x04\xa8\x06*+\n\x0e\n\
    \x06\x04,\x03\x03\x02\x04\x12\x04\xa9\x06\x101\n\x0f\n\x07\x04,\x03\x03\
    \x02\x04\x04\x12\x04\xa9\x06\x10\x18\n\x0f\n\x07\x04,\x03\x03\x02\x04\
    \x05\x12\x04\xa9\x06\x19\x1e\n\x0f\n\x07\x04,\x03\x03\x02\x04\x01\x12\
    \x04\xa9\x06\x1f,\n\x0f\n\x07\x04,\x03\x03\x02\x04\x03\x12\x04\xa9\x06/0\
    \n\x0e\n\x06\x04,\x03\x03\x02\x05\x12\x04\xaa\x06\x104\n\x0f\n\x07\x04,\
    \x03\x03\x02\x05\x04\x12\x04\xaa\x06\x10\x18\n\x0f\n\x07\x04,\x03\x03\
    \x02\x05\x05\x12\x04\xaa\x06\x19\x1e\n\x0f\n\x07\x04,\x03\x03\x02\x05\
    \x01\x12\x04\xaa\x06\x1f/\n\x0f\n\x07\x04,\x03\x03\x02\x05\x03\x12\x04\
    \xaa\x0623\n\x0e\n\x04\x04,\x03\x04\x12\x06\xad\x06\x08\xaf\x06\t\n\r\n\
    \x05\x04,\x03\x04\x01\x12\x04\xad\x06\x10\x1d\n\x0e\n\x06\x04,\x03\x04\
    \x02\0\x12\x04\xae\x06\x10,\n\x0f\n\x07\x04,\x03\x04\x02\0\x04\x12\x04\
    \xae\x06\x10\x18\n\x0f\n\x07\x04,\x03\x04\x02\0\x05\x12\x04\xae\x06\x19\
    \x1e\n\x0f\n\x07\x04,\x03\x04\x02\0\x01\x12\x04\xae\x06\x1f'\n\x0f\n\x07\
    \x04,\x03\x04\x02\0\x03\x12\x04\xae\x06*+\n\x0e\n\x04\x04,\x03\x05\x12\
    \x06\xb1\x06\x08\xb5\x06\t\n\r\n\x05\x04,\x03\x05\x01\x12\x04\xb1\x06\
    \x10\x1b\n\x0e\n\x06\x04,\x03\x05\x02\0\x12\x04\xb2\x06\x10)\n\x0f\n\x07\
    \x04,\x03\x05\x02\0\x04\x12\x04\xb2\x06\x10\x18\n\x0f\n\x07\x04,\x03\x05\
    \x02\0\x05\x12\x04\xb2\x06\x19\x1e\n\x0f\n\x07\x04,\x03\x05\x02\0\x01\
    \x12\x04\xb2\x06\x1f$\n\x0f\n\x07\x04,\x03\x05\x02\0\x03\x12\x04\xb2\x06\
    '(\n\x0e\n\x06\x04,\x03\x05\x02\x01\x12\x04\xb3\x06\x10,\n\x0f\n\x07\x04\
    ,\x03\x05\x02\x01\x04\x12\x04\xb3\x06\x10\x18\n\x0f\n\x07\x04,\x03\x05\
    \x02\x01\x05\x12\x04\xb3\x06\x19\x1e\n\x0f\n\x07\x04,\x03\x05\x02\x01\
    \x01\x12\x04\xb3\x06\x1f'\n\x0f\n\x07\x04,\x03\x05\x02\x01\x03\x12\x04\
    \xb3\x06*+\n\x0e\n\x06\x04,\x03\x05\x02\x02\x12\x04\xb4\x06\x10,\n\x0f\n\
    \x07\x04,\x03\x05\x02\x02\x04\x12\x04\xb4\x06\x10\x18\n\x0f\n\x07\x04,\
    \x03\x05\x02\x02\x05\x12\x04\xb4\x06\x19\x1e\n\x0f\n\x07\x04,\x03\x05\
    \x02\x02\x01\x12\x04\xb4\x06\x1f'\n\x0f\n\x07\x04,\x03\x05\x02\x02\x03\
    \x12\x04\xb4\x06*+\n\x0e\n\x04\x04,\x03\x06\x12\x06\xb7\x06\x08\xb9\x06\
    \t\n\r\n\x05\x04,\x03\x06\x01\x12\x04\xb7\x06\x10\x1b\n\x0e\n\x06\x04,\
    \x03\x06\x02\0\x12\x04\xb8\x06\x10,\n\x0f\n\x07\x04,\x03\x06\x02\0\x04\
    \x12\x04\xb8\x06\x10\x18\n\x0f\n\x07\x04,\x03\x06\x02\0\x05\x12\x04\xb8\
    \x06\x19\x1e\n\x0f\n\x07\x04,\x03\x06\x02\0\x01\x12\x04\xb8\x06\x1f'\n\
    \x0f\n\x07\x04,\x03\x06\x02\0\x03\x12\x04\xb8\x06*+\n\x0c\n\x04\x04,\x02\
    \0\x12\x04\xbb\x06\x082\n\r\n\x05\x04,\x02\0\x04\x12\x04\xbb\x06\x08\x10\
    \n\r\n\x05\x04,\x02\0\x06\x12\x04\xbb\x06\x11$\n\r\n\x05\x04,\x02\0\x01\
    \x12\x04\xbb\x06%-\n\r\n\x05\x04,\x02\0\x03\x12\x04\xbb\x0601\n\x0c\n\
    \x04\x04,\x02\x01\x12\x04\xbc\x06\x08(\n\r\n\x05\x04,\x02\x01\x04\x12\
    \x04\xbc\x06\x08\x10\n\r\n\x05\x04,\x02\x01\x05\x12\x04\xbc\x06\x11\x16\
    \n\r\n\x05\x04,\x02\x01\x01\x12\x04\xbc\x06\x17#\n\r\n\x05\x04,\x02\x01\
    \x03\x12\x04\xbc\x06&'\n\x0c\n\x04\x04,\x02\x02\x12\x04\xbd\x06\x08:\n\r\
    \n\x05\x04,\x02\x02\x04\x12\x04\xbd\x06\x08\x10\n\r\n\x05\x04,\x02\x02\
    \x06\x12\x04\xbd\x06\x11.\n\r\n\x05\x04,\x02\x02\x01\x12\x04\xbd\x06/5\n\
    \r\n\x05\x04,\x02\x02\x03\x12\x04\xbd\x0689\n\x0c\n\x04\x04,\x02\x03\x12\
    \x04\xbe\x06\x08C\n\r\n\x05\x04,\x02\x03\x04\x12\x04\xbe\x06\x08\x10\n\r\
    \n\x05\x04,\x02\x03\x06\x12\x04\xbe\x06\x112\n\r\n\x05\x04,\x02\x03\x01\
    \x12\x04\xbe\x063>\n\r\n\x05\x04,\x02\x03\x03\x12\x04\xbe\x06AB\n\x0c\n\
    \x04\x04,\x02\x04\x12\x04\xbf\x06\x08C\n\r\n\x05\x04,\x02\x04\x04\x12\
    \x04\xbf\x06\x08\x10\n\r\n\x05\x04,\x02\x04\x06\x12\x04\xbf\x06\x112\n\r\
    \n\x05\x04,\x02\x04\x01\x12\x04\xbf\x063>\n\r\n\x05\x04,\x02\x04\x03\x12\
    \x04\xbf\x06AB\n\x0c\n\x04\x04,\x02\x05\x12\x04\xc0\x06\x08I\n\r\n\x05\
    \x04,\x02\x05\x04\x12\x04\xc0\x06\x08\x10\n\r\n\x05\x04,\x02\x05\x06\x12\
    \x04\xc0\x06\x115\n\r\n\x05\x04,\x02\x05\x01\x12\x04\xc0\x066D\n\r\n\x05\
    \x04,\x02\x05\x03\x12\x04\xc0\x06GH\n\x0c\n\x04\x04,\x02\x06\x12\x04\xc1\
    \x06\x08E\n\r\n\x05\x04,\x02\x06\x04\x12\x04\xc1\x06\x08\x10\n\r\n\x05\
    \x04,\x02\x06\x06\x12\x04\xc1\x06\x113\n\r\n\x05\x04,\x02\x06\x01\x12\
    \x04\xc1\x064@\n\r\n\x05\x04,\x02\x06\x03\x12\x04\xc1\x06CD\n\x0c\n\x04\
    \x04,\x02\x07\x12\x04\xc2\x06\x08E\n\r\n\x05\x04,\x02\x07\x04\x12\x04\
    \xc2\x06\x08\x10\n\r\n\x05\x04,\x02\x07\x06\x12\x04\xc2\x06\x113\n\r\n\
    \x05\x04,\x02\x07\x01\x12\x04\xc2\x064@\n\r\n\x05\x04,\x02\x07\x03\x12\
    \x04\xc2\x06CD\n\x0c\n\x04\x04,\x02\x08\x12\x04\xc3\x06\x08E\n\r\n\x05\
    \x04,\x02\x08\x04\x12\x04\xc3\x06\x08\x10\n\r\n\x05\x04,\x02\x08\x06\x12\
    \x04\xc3\x06\x11)\n\r\n\x05\x04,\x02\x08\x01\x12\x04\xc3\x06*@\n\r\n\x05\
    \x04,\x02\x08\x03\x12\x04\xc3\x06CD\n\x0c\n\x02\x04-\x12\x06\xc6\x06\0\
    \xc8\x06\x01\n\x0b\n\x03\x04-\x01\x12\x04\xc6\x06\x08\"\n\x0c\n\x04\x04-\
    \x02\0\x12\x04\xc7\x06\x08+\n\r\n\x05\x04-\x02\0\x04\x12\x04\xc7\x06\x08\
    \x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\xc7\x06\x11\x16\n\r\n\x05\x04-\x02\
    \0\x01\x12\x04\xc7\x06\x17&\n\r\n\x05\x04-\x02\0\x03\x12\x04\xc7\x06)*\n\
    \x0c\n\x02\x04.\x12\x06\xca\x06\0\xcc\x06\x01\n\x0b\n\x03\x04.\x01\x12\
    \x04\xca\x06\x08\x1d\n\x0c\n\x04\x04.\x02\0\x12\x04\xcb\x06\x08+\n\r\n\
    \x05\x04.\x02\0\x04\x12\x04\xcb\x06\x08\x10\n\r\n\x05\x04.\x02\0\x05\x12\
    \x04\xcb\x06\x11\x16\n\r\n\x05\x04.\x02\0\x01\x12\x04\xcb\x06\x17&\n\r\n\
    \x05\x04.\x02\0\x03\x12\x04\xcb\x06)*\n\x0c\n\x02\x04/\x12\x06\xce\x06\0\
    \xd4\x06\x01\n\x0b\n\x03\x04/\x01\x12\x04\xce\x06\x08\x1e\n\x0c\n\x04\
    \x04/\x02\0\x12\x04\xcf\x06\x08\"\n\r\n\x05\x04/\x02\0\x04\x12\x04\xcf\
    \x06\x08\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xcf\x06\x11\x16\n\r\n\x05\
    \x04/\x02\0\x01\x12\x04\xcf\x06\x17\x1d\n\r\n\x05\x04/\x02\0\x03\x12\x04\
    \xcf\x06\x20!\n\x0c\n\x04\x04/\x02\x01\x12\x04\xd0\x06\x08#\n\r\n\x05\
    \x04/\x02\x01\x04\x12\x04\xd0\x06\x08\x10\n\r\n\x05\x04/\x02\x01\x05\x12\
    \x04\xd0\x06\x11\x16\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xd0\x06\x17\x1e\
    \n\r\n\x05\x04/\x02\x01\x03\x12\x04\xd0\x06!\"\n\x0c\n\x04\x04/\x02\x02\
    \x12\x04\xd1\x06\x08\"\n\r\n\x05\x04/\x02\x02\x04\x12\x04\xd1\x06\x08\
    \x10\n\r\n\x05\x04/\x02\x02\x05\x12\x04\xd1\x06\x11\x16\n\r\n\x05\x04/\
    \x02\x02\x01\x12\x04\xd1\x06\x17\x1d\n\r\n\x05\x04/\x02\x02\x03\x12\x04\
    \xd1\x06\x20!\n\x0c\n\x04\x04/\x02\x03\x12\x04\xd2\x06\x08\"\n\r\n\x05\
    \x04/\x02\x03\x04\x12\x04\xd2\x06\x08\x10\n\r\n\x05\x04/\x02\x03\x05\x12\
    \x04\xd2\x06\x11\x16\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xd2\x06\x17\x1d\
    \n\r\n\x05\x04/\x02\x03\x03\x12\x04\xd2\x06\x20!\n\x0c\n\x04\x04/\x02\
    \x04\x12\x04\xd3\x06\x08$\n\r\n\x05\x04/\x02\x04\x04\x12\x04\xd3\x06\x08\
    \x10\n\r\n\x05\x04/\x02\x04\x05\x12\x04\xd3\x06\x11\x17\n\r\n\x05\x04/\
    \x02\x04\x01\x12\x04\xd3\x06\x18\x1f\n\r\n\x05\x04/\x02\x04\x03\x12\x04\
    \xd3\x06\"#\n\x0c\n\x02\x040\x12\x06\xd6\x06\0\xdc\x06\x01\n\x0b\n\x03\
    \x040\x01\x12\x04\xd6\x06\x08\"\n\x0c\n\x04\x040\x02\0\x12\x04\xd7\x06\
    \x086\n\r\n\x05\x040\x02\0\x04\x12\x04\xd7\x06\x08\x10\n\r\n\x05\x040\
    \x02\0\x06\x12\x04\xd7\x06\x11$\n\r\n\x05\x040\x02\0\x01\x12\x04\xd7\x06\
    %1\n\r\n\x05\x040\x02\0\x03\x12\x04\xd7\x0645\n\x0c\n\x04\x040\x02\x01\
    \x12\x04\xd8\x06\x08!\n\r\n\x05\x040\x02\x01\x04\x12\x04\xd8\x06\x08\x10\
    \n\r\n\x05\x040\x02\x01\x05\x12\x04\xd8\x06\x11\x16\n\r\n\x05\x040\x02\
    \x01\x01\x12\x04\xd8\x06\x17\x1c\n\r\n\x05\x040\x02\x01\x03\x12\x04\xd8\
    \x06\x1f\x20\n\x0c\n\x04\x040\x02\x02\x12\x04\xd9\x06\x082\n\r\n\x05\x04\
    0\x02\x02\x04\x12\x04\xd9\x06\x08\x10\n\r\n\x05\x040\x02\x02\x05\x12\x04\
    \xd9\x06\x11\x16\n\r\n\x05\x040\x02\x02\x01\x12\x04\xd9\x06\x17-\n\r\n\
    \x05\x040\x02\x02\x03\x12\x04\xd9\x0601\n\x0c\n\x04\x040\x02\x03\x12\x04\
    \xda\x06\x08+\n\r\n\x05\x040\x02\x03\x04\x12\x04\xda\x06\x08\x10\n\r\n\
    \x05\x040\x02\x03\x05\x12\x04\xda\x06\x11\x16\n\r\n\x05\x040\x02\x03\x01\
    \x12\x04\xda\x06\x17&\n\r\n\x05\x040\x02\x03\x03\x12\x04\xda\x06)*\n\x0c\
    \n\x04\x040\x02\x04\x12\x04\xdb\x06\x082\n\r\n\x05\x040\x02\x04\x04\x12\
    \x04\xdb\x06\x08\x10\n\r\n\x05\x040\x02\x04\x05\x12\x04\xdb\x06\x11\x16\
    \n\r\n\x05\x040\x02\x04\x01\x12\x04\xdb\x06\x17-\n\r\n\x05\x040\x02\x04\
    \x03\x12\x04\xdb\x0601\n\x0c\n\x02\x041\x12\x06\xde\x06\0\xe1\x06\x01\n\
    \x0b\n\x03\x041\x01\x12\x04\xde\x06\x08$\n\x0c\n\x04\x041\x02\0\x12\x04\
    \xdf\x06\x08!\n\r\n\x05\x041\x02\0\x04\x12\x04\xdf\x06\x08\x10\n\r\n\x05\
    \x041\x02\0\x05\x12\x04\xdf\x06\x11\x17\n\r\n\x05\x041\x02\0\x01\x12\x04\
    \xdf\x06\x18\x1c\n\r\n\x05\x041\x02\0\x03\x12\x04\xdf\x06\x1f\x20\n\x0c\
    \n\x04\x041\x02\x01\x12\x04\xe0\x06\x08$\n\r\n\x05\x041\x02\x01\x04\x12\
    \x04\xe0\x06\x08\x10\n\r\n\x05\x041\x02\x01\x05\x12\x04\xe0\x06\x11\x16\
    \n\r\n\x05\x041\x02\x01\x01\x12\x04\xe0\x06\x17\x1f\n\r\n\x05\x041\x02\
    \x01\x03\x12\x04\xe0\x06\"#\n\x0c\n\x02\x042\x12\x06\xe3\x06\0\xe8\x06\
    \x01\n\x0b\n\x03\x042\x01\x12\x04\xe3\x06\x08#\n\x0c\n\x04\x042\x02\0\
    \x12\x04\xe4\x06\x08$\n\r\n\x05\x042\x02\0\x04\x12\x04\xe4\x06\x08\x10\n\
    \r\n\x05\x042\x02\0\x05\x12\x04\xe4\x06\x11\x17\n\r\n\x05\x042\x02\0\x01\
    \x12\x04\xe4\x06\x18\x1f\n\r\n\x05\x042\x02\0\x03\x12\x04\xe4\x06\"#\n\
    \x0c\n\x04\x042\x02\x01\x12\x04\xe5\x06\x08#\n\r\n\x05\x042\x02\x01\x04\
    \x12\x04\xe5\x06\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\x04\xe5\x06\x11\
    \x17\n\r\n\x05\x042\x02\x01\x01\x12\x04\xe5\x06\x18\x1e\n\r\n\x05\x042\
    \x02\x01\x03\x12\x04\xe5\x06!\"\n\x0c\n\x04\x042\x02\x02\x12\x04\xe6\x06\
    \x08!\n\r\n\x05\x042\x02\x02\x04\x12\x04\xe6\x06\x08\x10\n\r\n\x05\x042\
    \x02\x02\x05\x12\x04\xe6\x06\x11\x17\n\r\n\x05\x042\x02\x02\x01\x12\x04\
    \xe6\x06\x18\x1c\n\r\n\x05\x042\x02\x02\x03\x12\x04\xe6\x06\x1f\x20\n\
    \x0c\n\x04\x042\x02\x03\x12\x04\xe7\x06\x08\"\n\r\n\x05\x042\x02\x03\x04\
    \x12\x04\xe7\x06\x08\x10\n\r\n\x05\x042\x02\x03\x05\x12\x04\xe7\x06\x11\
    \x15\n\r\n\x05\x042\x02\x03\x01\x12\x04\xe7\x06\x16\x1d\n\r\n\x05\x042\
    \x02\x03\x03\x12\x04\xe7\x06\x20!\n\x0c\n\x02\x043\x12\x06\xea\x06\0\xeb\
    \x06\x01\n\x0b\n\x03\x043\x01\x12\x04\xea\x06\x08,\n\x0c\n\x02\x044\x12\
    \x06\xed\x06\0\xf2\x06\x01\n\x0b\n\x03\x044\x01\x12\x04\xed\x06\x08'\n\
    \x0c\n\x04\x044\x02\0\x12\x04\xee\x06\x08\"\n\r\n\x05\x044\x02\0\x04\x12\
    \x04\xee\x06\x08\x10\n\r\n\x05\x044\x02\0\x05\x12\x04\xee\x06\x11\x17\n\
    \r\n\x05\x044\x02\0\x01\x12\x04\xee\x06\x18\x1d\n\r\n\x05\x044\x02\0\x03\
    \x12\x04\xee\x06\x20!\n\x0c\n\x04\x044\x02\x01\x12\x04\xef\x06\x08!\n\r\
    \n\x05\x044\x02\x01\x04\x12\x04\xef\x06\x08\x10\n\r\n\x05\x044\x02\x01\
    \x05\x12\x04\xef\x06\x11\x17\n\r\n\x05\x044\x02\x01\x01\x12\x04\xef\x06\
    \x18\x1c\n\r\n\x05\x044\x02\x01\x03\x12\x04\xef\x06\x1f\x20\n\x0c\n\x04\
    \x044\x02\x02\x12\x04\xf0\x06\x08$\n\r\n\x05\x044\x02\x02\x04\x12\x04\
    \xf0\x06\x08\x10\n\r\n\x05\x044\x02\x02\x05\x12\x04\xf0\x06\x11\x16\n\r\
    \n\x05\x044\x02\x02\x01\x12\x04\xf0\x06\x17\x1f\n\r\n\x05\x044\x02\x02\
    \x03\x12\x04\xf0\x06\"#\n\x0c\n\x04\x044\x02\x03\x12\x04\xf1\x06\x08\x20\
    \n\r\n\x05\x044\x02\x03\x04\x12\x04\xf1\x06\x08\x10\n\r\n\x05\x044\x02\
    \x03\x05\x12\x04\xf1\x06\x11\x15\n\r\n\x05\x044\x02\x03\x01\x12\x04\xf1\
    \x06\x16\x1b\n\r\n\x05\x044\x02\x03\x03\x12\x04\xf1\x06\x1e\x1f\n\x0c\n\
    \x02\x045\x12\x06\xf4\x06\0\xf7\x06\x01\n\x0b\n\x03\x045\x01\x12\x04\xf4\
    \x06\x08\x1e\n\x0c\n\x04\x045\x02\0\x12\x04\xf5\x06\x08%\n\r\n\x05\x045\
    \x02\0\x04\x12\x04\xf5\x06\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\x04\xf5\
    \x06\x11\x16\n\r\n\x05\x045\x02\0\x01\x12\x04\xf5\x06\x17\x20\n\r\n\x05\
    \x045\x02\0\x03\x12\x04\xf5\x06#$\n\x0c\n\x04\x045\x02\x01\x12\x04\xf6\
    \x06\x082\n\r\n\x05\x045\x02\x01\x04\x12\x04\xf6\x06\x08\x10\n\r\n\x05\
    \x045\x02\x01\x06\x12\x04\xf6\x06\x11#\n\r\n\x05\x045\x02\x01\x01\x12\
    \x04\xf6\x06$-\n\r\n\x05\x045\x02\x01\x03\x12\x04\xf6\x0601\n\x0c\n\x02\
    \x046\x12\x06\xf9\x06\0\xff\x06\x01\n\x0b\n\x03\x046\x01\x12\x04\xf9\x06\
    \x08\x1e\n\x0c\n\x04\x046\x02\0\x12\x04\xfa\x06\x08,\n\r\n\x05\x046\x02\
    \0\x04\x12\x04\xfa\x06\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\xfa\x06\
    \x11\x17\n\r\n\x05\x046\x02\0\x01\x12\x04\xfa\x06\x18'\n\r\n\x05\x046\
    \x02\0\x03\x12\x04\xfa\x06*+\n\x0c\n\x04\x046\x02\x01\x12\x04\xfb\x06\
    \x08%\n\r\n\x05\x046\x02\x01\x04\x12\x04\xfb\x06\x08\x10\n\r\n\x05\x046\
    \x02\x01\x05\x12\x04\xfb\x06\x11\x16\n\r\n\x05\x046\x02\x01\x01\x12\x04\
    \xfb\x06\x17\x20\n\r\n\x05\x046\x02\x01\x03\x12\x04\xfb\x06#$\n\x0c\n\
    \x04\x046\x02\x02\x12\x04\xfc\x06\x08'\n\r\n\x05\x046\x02\x02\x04\x12\
    \x04\xfc\x06\x08\x10\n\r\n\x05\x046\x02\x02\x05\x12\x04\xfc\x06\x11\x17\
    \n\r\n\x05\x046\x02\x02\x01\x12\x04\xfc\x06\x18\"\n\r\n\x05\x046\x02\x02\
    \x03\x12\x04\xfc\x06%&\n\x0c\n\x04\x046\x02\x03\x12\x04\xfd\x06\x08*\n\r\
    \n\x05\x046\x02\x03\x04\x12\x04\xfd\x06\x08\x10\n\r\n\x05\x046\x02\x03\
    \x05\x12\x04\xfd\x06\x11\x17\n\r\n\x05\x046\x02\x03\x01\x12\x04\xfd\x06\
    \x18%\n\r\n\x05\x046\x02\x03\x03\x12\x04\xfd\x06()\n\x0c\n\x04\x046\x02\
    \x04\x12\x04\xfe\x06\x08(\n\r\n\x05\x046\x02\x04\x04\x12\x04\xfe\x06\x08\
    \x10\n\r\n\x05\x046\x02\x04\x05\x12\x04\xfe\x06\x11\x17\n\r\n\x05\x046\
    \x02\x04\x01\x12\x04\xfe\x06\x18#\n\r\n\x05\x046\x02\x04\x03\x12\x04\xfe\
    \x06&'\n\x0c\n\x02\x047\x12\x06\x81\x07\0\x85\x07\x01\n\x0b\n\x03\x047\
    \x01\x12\x04\x81\x07\x08%\n\x0c\n\x04\x047\x02\0\x12\x04\x82\x07\x08%\n\
    \r\n\x05\x047\x02\0\x04\x12\x04\x82\x07\x08\x10\n\r\n\x05\x047\x02\0\x05\
    \x12\x04\x82\x07\x11\x16\n\r\n\x05\x047\x02\0\x01\x12\x04\x82\x07\x17\
    \x20\n\r\n\x05\x047\x02\0\x03\x12\x04\x82\x07#$\n\x0c\n\x04\x047\x02\x01\
    \x12\x04\x83\x07\x08&\n\r\n\x05\x047\x02\x01\x04\x12\x04\x83\x07\x08\x10\
    \n\r\n\x05\x047\x02\x01\x05\x12\x04\x83\x07\x11\x17\n\r\n\x05\x047\x02\
    \x01\x01\x12\x04\x83\x07\x18!\n\r\n\x05\x047\x02\x01\x03\x12\x04\x83\x07\
    $%\n\x0c\n\x04\x047\x02\x02\x12\x04\x84\x07\x08*\n\r\n\x05\x047\x02\x02\
    \x04\x12\x04\x84\x07\x08\x10\n\r\n\x05\x047\x02\x02\x05\x12\x04\x84\x07\
    \x11\x16\n\r\n\x05\x047\x02\x02\x01\x12\x04\x84\x07\x17%\n\r\n\x05\x047\
    \x02\x02\x03\x12\x04\x84\x07()\n\x0c\n\x02\x048\x12\x06\x87\x07\0\x8e\
    \x07\x01\n\x0b\n\x03\x048\x01\x12\x04\x87\x07\x08\x1f\n\x0c\n\x04\x048\
    \x02\0\x12\x04\x88\x07\x08%\n\r\n\x05\x048\x02\0\x04\x12\x04\x88\x07\x08\
    \x10\n\r\n\x05\x048\x02\0\x05\x12\x04\x88\x07\x11\x16\n\r\n\x05\x048\x02\
    \0\x01\x12\x04\x88\x07\x17\x20\n\r\n\x05\x048\x02\0\x03\x12\x04\x88\x07#\
    $\n\x0c\n\x04\x048\x02\x01\x12\x04\x89\x07\x08%\n\r\n\x05\x048\x02\x01\
    \x04\x12\x04\x89\x07\x08\x10\n\r\n\x05\x048\x02\x01\x05\x12\x04\x89\x07\
    \x11\x17\n\r\n\x05\x048\x02\x01\x01\x12\x04\x89\x07\x18\x20\n\r\n\x05\
    \x048\x02\x01\x03\x12\x04\x89\x07#$\n\x0c\n\x04\x048\x02\x02\x12\x04\x8a\
    \x07\x08+\n\r\n\x05\x048\x02\x02\x04\x12\x04\x8a\x07\x08\x10\n\r\n\x05\
    \x048\x02\x02\x05\x12\x04\x8a\x07\x11\x17\n\r\n\x05\x048\x02\x02\x01\x12\
    \x04\x8a\x07\x18&\n\r\n\x05\x048\x02\x02\x03\x12\x04\x8a\x07)*\n\x0c\n\
    \x04\x048\x02\x03\x12\x04\x8b\x07\x08-\n\r\n\x05\x048\x02\x03\x04\x12\
    \x04\x8b\x07\x08\x10\n\r\n\x05\x048\x02\x03\x05\x12\x04\x8b\x07\x11\x17\
    \n\r\n\x05\x048\x02\x03\x01\x12\x04\x8b\x07\x18(\n\r\n\x05\x048\x02\x03\
    \x03\x12\x04\x8b\x07+,\n\x0c\n\x04\x048\x02\x04\x12\x04\x8c\x07\x08*\n\r\
    \n\x05\x048\x02\x04\x04\x12\x04\x8c\x07\x08\x10\n\r\n\x05\x048\x02\x04\
    \x05\x12\x04\x8c\x07\x11\x17\n\r\n\x05\x048\x02\x04\x01\x12\x04\x8c\x07\
    \x18%\n\r\n\x05\x048\x02\x04\x03\x12\x04\x8c\x07()\n\x0c\n\x04\x048\x02\
    \x05\x12\x04\x8d\x07\x080\n\r\n\x05\x048\x02\x05\x04\x12\x04\x8d\x07\x08\
    \x10\n\r\n\x05\x048\x02\x05\x05\x12\x04\x8d\x07\x11\x17\n\r\n\x05\x048\
    \x02\x05\x01\x12\x04\x8d\x07\x18+\n\r\n\x05\x048\x02\x05\x03\x12\x04\x8d\
    \x07./\n\x0c\n\x02\x049\x12\x06\x90\x07\0\x92\x07\x01\n\x0b\n\x03\x049\
    \x01\x12\x04\x90\x07\x08(\n\x0c\n\x04\x049\x02\0\x12\x04\x91\x07\x08%\n\
    \r\n\x05\x049\x02\0\x04\x12\x04\x91\x07\x08\x10\n\r\n\x05\x049\x02\0\x05\
    \x12\x04\x91\x07\x11\x16\n\r\n\x05\x049\x02\0\x01\x12\x04\x91\x07\x17\
    \x20\n\r\n\x05\x049\x02\0\x03\x12\x04\x91\x07#$\n\x0c\n\x02\x04:\x12\x06\
    \x94\x07\0\x95\x07\x01\n\x0b\n\x03\x04:\x01\x12\x04\x94\x07\x08'\n\x0c\n\
    \x02\x04;\x12\x06\x97\x07\0\x99\x07\x01\n\x0b\n\x03\x04;\x01\x12\x04\x97\
    \x07\x08!\n\x0c\n\x04\x04;\x02\0\x12\x04\x98\x07\x08%\n\r\n\x05\x04;\x02\
    \0\x04\x12\x04\x98\x07\x08\x10\n\r\n\x05\x04;\x02\0\x05\x12\x04\x98\x07\
    \x11\x16\n\r\n\x05\x04;\x02\0\x01\x12\x04\x98\x07\x17\x20\n\r\n\x05\x04;\
    \x02\0\x03\x12\x04\x98\x07#$\n\x0c\n\x02\x04<\x12\x06\x9b\x07\0\xa1\x07\
    \x01\n\x0b\n\x03\x04<\x01\x12\x04\x9b\x07\x08(\n\x0c\n\x04\x04<\x02\0\
    \x12\x04\x9c\x07\x08%\n\r\n\x05\x04<\x02\0\x04\x12\x04\x9c\x07\x08\x10\n\
    \r\n\x05\x04<\x02\0\x05\x12\x04\x9c\x07\x11\x16\n\r\n\x05\x04<\x02\0\x01\
    \x12\x04\x9c\x07\x17\x20\n\r\n\x05\x04<\x02\0\x03\x12\x04\x9c\x07#$\n\
    \x0c\n\x04\x04<\x02\x01\x12\x04\x9d\x07\x08!\n\r\n\x05\x04<\x02\x01\x04\
    \x12\x04\x9d\x07\x08\x10\n\r\n\x05\x04<\x02\x01\x05\x12\x04\x9d\x07\x11\
    \x16\n\r\n\x05\x04<\x02\x01\x01\x12\x04\x9d\x07\x17\x1c\n\r\n\x05\x04<\
    \x02\x01\x03\x12\x04\x9d\x07\x1f\x20\n\x0c\n\x04\x04<\x02\x02\x12\x04\
    \x9e\x07\x08!\n\r\n\x05\x04<\x02\x02\x04\x12\x04\x9e\x07\x08\x10\n\r\n\
    \x05\x04<\x02\x02\x05\x12\x04\x9e\x07\x11\x16\n\r\n\x05\x04<\x02\x02\x01\
    \x12\x04\x9e\x07\x17\x1c\n\r\n\x05\x04<\x02\x02\x03\x12\x04\x9e\x07\x1f\
    \x20\n\x0c\n\x04\x04<\x02\x03\x12\x04\x9f\x07\x08!\n\r\n\x05\x04<\x02\
    \x03\x04\x12\x04\x9f\x07\x08\x10\n\r\n\x05\x04<\x02\x03\x05\x12\x04\x9f\
    \x07\x11\x16\n\r\n\x05\x04<\x02\x03\x01\x12\x04\x9f\x07\x17\x1c\n\r\n\
    \x05\x04<\x02\x03\x03\x12\x04\x9f\x07\x1f\x20\n\x0c\n\x04\x04<\x02\x04\
    \x12\x04\xa0\x07\x08(\n\r\n\x05\x04<\x02\x04\x04\x12\x04\xa0\x07\x08\x10\
    \n\r\n\x05\x04<\x02\x04\x05\x12\x04\xa0\x07\x11\x16\n\r\n\x05\x04<\x02\
    \x04\x01\x12\x04\xa0\x07\x17#\n\r\n\x05\x04<\x02\x04\x03\x12\x04\xa0\x07\
    &'\n\x0c\n\x02\x04=\x12\x06\xa3\x07\0\xa5\x07\x01\n\x0b\n\x03\x04=\x01\
    \x12\x04\xa3\x07\x08*\n\x0c\n\x04\x04=\x02\0\x12\x04\xa4\x07\x08\"\n\r\n\
    \x05\x04=\x02\0\x04\x12\x04\xa4\x07\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\
    \x04\xa4\x07\x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\xa4\x07\x18\x1d\n\
    \r\n\x05\x04=\x02\0\x03\x12\x04\xa4\x07\x20!\n\x0c\n\x02\x04>\x12\x06\
    \xa7\x07\0\xaa\x07\x01\n\x0b\n\x03\x04>\x01\x12\x04\xa7\x07\x08%\n\x0c\n\
    \x04\x04>\x02\0\x12\x04\xa8\x07\x08%\n\r\n\x05\x04>\x02\0\x04\x12\x04\
    \xa8\x07\x08\x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\xa8\x07\x11\x17\n\r\n\
    \x05\x04>\x02\0\x01\x12\x04\xa8\x07\x18\x20\n\r\n\x05\x04>\x02\0\x03\x12\
    \x04\xa8\x07#$\n\x0c\n\x04\x04>\x02\x01\x12\x04\xa9\x07\x08'\n\r\n\x05\
    \x04>\x02\x01\x04\x12\x04\xa9\x07\x08\x10\n\r\n\x05\x04>\x02\x01\x05\x12\
    \x04\xa9\x07\x11\x17\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xa9\x07\x18\"\n\
    \r\n\x05\x04>\x02\x01\x03\x12\x04\xa9\x07%&\n\x0c\n\x02\x04?\x12\x06\xac\
    \x07\0\xaf\x07\x01\n\x0b\n\x03\x04?\x01\x12\x04\xac\x07\x08\"\n\x0c\n\
    \x04\x04?\x02\0\x12\x04\xad\x07\x08%\n\r\n\x05\x04?\x02\0\x04\x12\x04\
    \xad\x07\x08\x10\n\r\n\x05\x04?\x02\0\x05\x12\x04\xad\x07\x11\x16\n\r\n\
    \x05\x04?\x02\0\x01\x12\x04\xad\x07\x17\x20\n\r\n\x05\x04?\x02\0\x03\x12\
    \x04\xad\x07#$\n\x0c\n\x04\x04?\x02\x01\x12\x04\xae\x07\x086\n\r\n\x05\
    \x04?\x02\x01\x04\x12\x04\xae\x07\x08\x10\n\r\n\x05\x04?\x02\x01\x06\x12\
    \x04\xae\x07\x11'\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xae\x07(1\n\r\n\x05\
    \x04?\x02\x01\x03\x12\x04\xae\x0745\n\x0c\n\x02\x04@\x12\x06\xb1\x07\0\
    \xb3\x07\x01\n\x0b\n\x03\x04@\x01\x12\x04\xb1\x07\x08)\n\x0c\n\x04\x04@\
    \x02\0\x12\x04\xb2\x07\x08A\n\r\n\x05\x04@\x02\0\x04\x12\x04\xb2\x07\x08\
    \x10\n\r\n\x05\x04@\x02\0\x06\x12\x04\xb2\x07\x11.\n\r\n\x05\x04@\x02\0\
    \x01\x12\x04\xb2\x07/<\n\r\n\x05\x04@\x02\0\x03\x12\x04\xb2\x07?@\n\x0c\
    \n\x02\x04A\x12\x06\xb5\x07\0\xb9\x07\x01\n\x0b\n\x03\x04A\x01\x12\x04\
    \xb5\x07\x08-\n\x0c\n\x04\x04A\x02\0\x12\x04\xb6\x07\x08-\n\r\n\x05\x04A\
    \x02\0\x04\x12\x04\xb6\x07\x08\x10\n\r\n\x05\x04A\x02\0\x06\x12\x04\xb6\
    \x07\x11\"\n\r\n\x05\x04A\x02\0\x01\x12\x04\xb6\x07#(\n\r\n\x05\x04A\x02\
    \0\x03\x12\x04\xb6\x07+,\n\x0c\n\x04\x04A\x02\x01\x12\x04\xb7\x07\x08,\n\
    \r\n\x05\x04A\x02\x01\x04\x12\x04\xb7\x07\x08\x10\n\r\n\x05\x04A\x02\x01\
    \x05\x12\x04\xb7\x07\x11\x16\n\r\n\x05\x04A\x02\x01\x01\x12\x04\xb7\x07\
    \x17'\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xb7\x07*+\n\x0c\n\x04\x04A\x02\
    \x02\x12\x04\xb8\x07\x08(\n\r\n\x05\x04A\x02\x02\x04\x12\x04\xb8\x07\x08\
    \x10\n\r\n\x05\x04A\x02\x02\x05\x12\x04\xb8\x07\x11\x16\n\r\n\x05\x04A\
    \x02\x02\x01\x12\x04\xb8\x07\x17#\n\r\n\x05\x04A\x02\x02\x03\x12\x04\xb8\
    \x07&'\n\x0c\n\x02\x04B\x12\x06\xbb\x07\0\xbe\x07\x01\n\x0b\n\x03\x04B\
    \x01\x12\x04\xbb\x07\x08$\n\x0c\n\x04\x04B\x02\0\x12\x04\xbc\x07\x08$\n\
    \r\n\x05\x04B\x02\0\x04\x12\x04\xbc\x07\x08\x10\n\r\n\x05\x04B\x02\0\x05\
    \x12\x04\xbc\x07\x11\x15\n\r\n\x05\x04B\x02\0\x01\x12\x04\xbc\x07\x16\
    \x1f\n\r\n\x05\x04B\x02\0\x03\x12\x04\xbc\x07\"#\n\x0c\n\x04\x04B\x02\
    \x01\x12\x04\xbd\x07\x08$\n\r\n\x05\x04B\x02\x01\x04\x12\x04\xbd\x07\x08\
    \x10\n\r\n\x05\x04B\x02\x01\x05\x12\x04\xbd\x07\x11\x16\n\r\n\x05\x04B\
    \x02\x01\x01\x12\x04\xbd\x07\x17\x1f\n\r\n\x05\x04B\x02\x01\x03\x12\x04\
    \xbd\x07\"#\n\x0c\n\x02\x04C\x12\x06\xc0\x07\0\xc3\x07\x01\n\x0b\n\x03\
    \x04C\x01\x12\x04\xc0\x07\x08\"\n\x0c\n\x04\x04C\x02\0\x12\x04\xc1\x07\
    \x08*\n\r\n\x05\x04C\x02\0\x04\x12\x04\xc1\x07\x08\x10\n\r\n\x05\x04C\
    \x02\0\x05\x12\x04\xc1\x07\x11\x17\n\r\n\x05\x04C\x02\0\x01\x12\x04\xc1\
    \x07\x18%\n\r\n\x05\x04C\x02\0\x03\x12\x04\xc1\x07()\n\x0c\n\x04\x04C\
    \x02\x01\x12\x04\xc2\x07\x08,\n\r\n\x05\x04C\x02\x01\x04\x12\x04\xc2\x07\
    \x08\x10\n\r\n\x05\x04C\x02\x01\x05\x12\x04\xc2\x07\x11\x17\n\r\n\x05\
    \x04C\x02\x01\x01\x12\x04\xc2\x07\x18'\n\r\n\x05\x04C\x02\x01\x03\x12\
    \x04\xc2\x07*+\n\x0c\n\x02\x04D\x12\x06\xc5\x07\0\xc9\x07\x01\n\x0b\n\
    \x03\x04D\x01\x12\x04\xc5\x07\x08\x1e\n\x0c\n\x04\x04D\x02\0\x12\x04\xc6\
    \x07\x08$\n\r\n\x05\x04D\x02\0\x04\x12\x04\xc6\x07\x08\x10\n\r\n\x05\x04\
    D\x02\0\x05\x12\x04\xc6\x07\x11\x17\n\r\n\x05\x04D\x02\0\x01\x12\x04\xc6\
    \x07\x18\x1f\n\r\n\x05\x04D\x02\0\x03\x12\x04\xc6\x07\"#\n\x0c\n\x04\x04\
    D\x02\x01\x12\x04\xc7\x07\x08%\n\r\n\x05\x04D\x02\x01\x04\x12\x04\xc7\
    \x07\x08\x10\n\r\n\x05\x04D\x02\x01\x05\x12\x04\xc7\x07\x11\x16\n\r\n\
    \x05\x04D\x02\x01\x01\x12\x04\xc7\x07\x17\x20\n\r\n\x05\x04D\x02\x01\x03\
    \x12\x04\xc7\x07#$\n\x0c\n\x04\x04D\x02\x02\x12\x04\xc8\x07\x08!\n\r\n\
    \x05\x04D\x02\x02\x04\x12\x04\xc8\x07\x08\x10\n\r\n\x05\x04D\x02\x02\x05\
    \x12\x04\xc8\x07\x11\x16\n\r\n\x05\x04D\x02\x02\x01\x12\x04\xc8\x07\x17\
    \x1c\n\r\n\x05\x04D\x02\x02\x03\x12\x04\xc8\x07\x1f\x20\n\x0c\n\x02\x04E\
    \x12\x06\xcb\x07\0\xce\x07\x01\n\x0b\n\x03\x04E\x01\x12\x04\xcb\x07\x08!\
    \n\x0c\n\x04\x04E\x02\0\x12\x04\xcc\x07\x08%\n\r\n\x05\x04E\x02\0\x04\
    \x12\x04\xcc\x07\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\x04\xcc\x07\x11\
    \x16\n\r\n\x05\x04E\x02\0\x01\x12\x04\xcc\x07\x17\x20\n\r\n\x05\x04E\x02\
    \0\x03\x12\x04\xcc\x07#$\n\x0c\n\x04\x04E\x02\x01\x12\x04\xcd\x07\x084\n\
    \r\n\x05\x04E\x02\x01\x04\x12\x04\xcd\x07\x08\x10\n\r\n\x05\x04E\x02\x01\
    \x06\x12\x04\xcd\x07\x11&\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xcd\x07'/\n\
    \r\n\x05\x04E\x02\x01\x03\x12\x04\xcd\x0723\n\x0c\n\x02\x04F\x12\x06\xd0\
    \x07\0\xd1\x07\x01\n\x0b\n\x03\x04F\x01\x12\x04\xd0\x07\x08&\n\x0c\n\x02\
    \x04G\x12\x06\xd3\x07\0\xe3\x07\x01\n\x0b\n\x03\x04G\x01\x12\x04\xd3\x07\
    \x08\"\n\x0c\n\x04\x04G\x02\0\x12\x04\xd4\x07\x08#\n\r\n\x05\x04G\x02\0\
    \x04\x12\x04\xd4\x07\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\xd4\x07\
    \x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\xd4\x07\x18\x1e\n\r\n\x05\x04G\
    \x02\0\x03\x12\x04\xd4\x07!\"\n\x0c\n\x04\x04G\x02\x01\x12\x04\xd5\x07\
    \x08#\n\r\n\x05\x04G\x02\x01\x04\x12\x04\xd5\x07\x08\x10\n\r\n\x05\x04G\
    \x02\x01\x05\x12\x04\xd5\x07\x11\x17\n\r\n\x05\x04G\x02\x01\x01\x12\x04\
    \xd5\x07\x18\x1e\n\r\n\x05\x04G\x02\x01\x03\x12\x04\xd5\x07!\"\n\x0c\n\
    \x04\x04G\x02\x02\x12\x04\xd6\x07\x08&\n\r\n\x05\x04G\x02\x02\x04\x12\
    \x04\xd6\x07\x08\x10\n\r\n\x05\x04G\x02\x02\x05\x12\x04\xd6\x07\x11\x16\
    \n\r\n\x05\x04G\x02\x02\x01\x12\x04\xd6\x07\x17!\n\r\n\x05\x04G\x02\x02\
    \x03\x12\x04\xd6\x07$%\n\x0c\n\x04\x04G\x02\x03\x12\x04\xd7\x07\x08-\n\r\
    \n\x05\x04G\x02\x03\x04\x12\x04\xd7\x07\x08\x10\n\r\n\x05\x04G\x02\x03\
    \x05\x12\x04\xd7\x07\x11\x16\n\r\n\x05\x04G\x02\x03\x01\x12\x04\xd7\x07\
    \x17(\n\r\n\x05\x04G\x02\x03\x03\x12\x04\xd7\x07+,\n\x0c\n\x04\x04G\x02\
    \x04\x12\x04\xd8\x07\x082\n\r\n\x05\x04G\x02\x04\x04\x12\x04\xd8\x07\x08\
    \x10\n\r\n\x05\x04G\x02\x04\x05\x12\x04\xd8\x07\x11\x16\n\r\n\x05\x04G\
    \x02\x04\x01\x12\x04\xd8\x07\x17-\n\r\n\x05\x04G\x02\x04\x03\x12\x04\xd8\
    \x0701\n\x0c\n\x04\x04G\x02\x05\x12\x04\xd9\x07\x08$\n\r\n\x05\x04G\x02\
    \x05\x04\x12\x04\xd9\x07\x08\x10\n\r\n\x05\x04G\x02\x05\x05\x12\x04\xd9\
    \x07\x11\x15\n\r\n\x05\x04G\x02\x05\x01\x12\x04\xd9\x07\x16\x1f\n\r\n\
    \x05\x04G\x02\x05\x03\x12\x04\xd9\x07\"#\n\x0c\n\x04\x04G\x02\x06\x12\
    \x04\xda\x07\x08$\n\r\n\x05\x04G\x02\x06\x04\x12\x04\xda\x07\x08\x10\n\r\
    \n\x05\x04G\x02\x06\x05\x12\x04\xda\x07\x11\x15\n\r\n\x05\x04G\x02\x06\
    \x01\x12\x04\xda\x07\x16\x1f\n\r\n\x05\x04G\x02\x06\x03\x12\x04\xda\x07\
    \"#\n\x0c\n\x04\x04G\x02\x07\x12\x04\xdb\x07\x08'\n\r\n\x05\x04G\x02\x07\
    \x04\x12\x04\xdb\x07\x08\x10\n\r\n\x05\x04G\x02\x07\x05\x12\x04\xdb\x07\
    \x11\x16\n\r\n\x05\x04G\x02\x07\x01\x12\x04\xdb\x07\x17\"\n\r\n\x05\x04G\
    \x02\x07\x03\x12\x04\xdb\x07%&\n\x0c\n\x04\x04G\x02\x08\x12\x04\xdc\x07\
    \x08*\n\r\n\x05\x04G\x02\x08\x04\x12\x04\xdc\x07\x08\x10\n\r\n\x05\x04G\
    \x02\x08\x05\x12\x04\xdc\x07\x11\x16\n\r\n\x05\x04G\x02\x08\x01\x12\x04\
    \xdc\x07\x17$\n\r\n\x05\x04G\x02\x08\x03\x12\x04\xdc\x07')\n\x0c\n\x04\
    \x04G\x02\t\x12\x04\xdd\x07\x08,\n\r\n\x05\x04G\x02\t\x04\x12\x04\xdd\
    \x07\x08\x10\n\r\n\x05\x04G\x02\t\x05\x12\x04\xdd\x07\x11\x18\n\r\n\x05\
    \x04G\x02\t\x01\x12\x04\xdd\x07\x19&\n\r\n\x05\x04G\x02\t\x03\x12\x04\
    \xdd\x07)+\n\x0c\n\x04\x04G\x02\n\x12\x04\xde\x07\x08(\n\r\n\x05\x04G\
    \x02\n\x04\x12\x04\xde\x07\x08\x10\n\r\n\x05\x04G\x02\n\x05\x12\x04\xde\
    \x07\x11\x16\n\r\n\x05\x04G\x02\n\x01\x12\x04\xde\x07\x17\"\n\r\n\x05\
    \x04G\x02\n\x03\x12\x04\xde\x07%'\n\x0c\n\x04\x04G\x02\x0b\x12\x04\xdf\
    \x07\x08#\n\r\n\x05\x04G\x02\x0b\x04\x12\x04\xdf\x07\x08\x10\n\r\n\x05\
    \x04G\x02\x0b\x05\x12\x04\xdf\x07\x11\x16\n\r\n\x05\x04G\x02\x0b\x01\x12\
    \x04\xdf\x07\x17\x1d\n\r\n\x05\x04G\x02\x0b\x03\x12\x04\xdf\x07\x20\"\n\
    \x0c\n\x04\x04G\x02\x0c\x12\x04\xe0\x07\x08,\n\r\n\x05\x04G\x02\x0c\x04\
    \x12\x04\xe0\x07\x08\x10\n\r\n\x05\x04G\x02\x0c\x06\x12\x04\xe0\x07\x11\
    \x1b\n\r\n\x05\x04G\x02\x0c\x01\x12\x04\xe0\x07\x1c&\n\r\n\x05\x04G\x02\
    \x0c\x03\x12\x04\xe0\x07)+\n\x0c\n\x04\x04G\x02\r\x12\x04\xe1\x07\x08M\n\
    \r\n\x05\x04G\x02\r\x04\x12\x04\xe1\x07\x08\x10\n\r\n\x05\x04G\x02\r\x06\
    \x12\x04\xe1\x07\x116\n\r\n\x05\x04G\x02\r\x01\x12\x04\xe1\x077G\n\r\n\
    \x05\x04G\x02\r\x03\x12\x04\xe1\x07JL\n\x0c\n\x04\x04G\x02\x0e\x12\x04\
    \xe2\x07\x08>\n\r\n\x05\x04G\x02\x0e\x04\x12\x04\xe2\x07\x08\x10\n\r\n\
    \x05\x04G\x02\x0e\x05\x12\x04\xe2\x07\x11\x16\n\r\n\x05\x04G\x02\x0e\x01\
    \x12\x04\xe2\x07\x178\n\r\n\x05\x04G\x02\x0e\x03\x12\x04\xe2\x07;=\n\x0c\
    \n\x02\x04H\x12\x06\xe5\x07\0\xf5\x07\x01\n\x0b\n\x03\x04H\x01\x12\x04\
    \xe5\x07\x08%\n\x0c\n\x04\x04H\x02\0\x12\x04\xe6\x07\x08+\n\r\n\x05\x04H\
    \x02\0\x04\x12\x04\xe6\x07\x08\x10\n\r\n\x05\x04H\x02\0\x06\x12\x04\xe6\
    \x07\x11\x1b\n\r\n\x05\x04H\x02\0\x01\x12\x04\xe6\x07\x1c&\n\r\n\x05\x04\
    H\x02\0\x03\x12\x04\xe6\x07)*\n\x0c\n\x04\x04H\x02\x01\x12\x04\xe7\x07\
    \x08#\n\r\n\x05\x04H\x02\x01\x04\x12\x04\xe7\x07\x08\x10\n\r\n\x05\x04H\
    \x02\x01\x05\x12\x04\xe7\x07\x11\x17\n\r\n\x05\x04H\x02\x01\x01\x12\x04\
    \xe7\x07\x18\x1e\n\r\n\x05\x04H\x02\x01\x03\x12\x04\xe7\x07!\"\n\x0c\n\
    \x04\x04H\x02\x02\x12\x04\xe8\x07\x08&\n\r\n\x05\x04H\x02\x02\x04\x12\
    \x04\xe8\x07\x08\x10\n\r\n\x05\x04H\x02\x02\x05\x12\x04\xe8\x07\x11\x16\
    \n\r\n\x05\x04H\x02\x02\x01\x12\x04\xe8\x07\x17!\n\r\n\x05\x04H\x02\x02\
    \x03\x12\x04\xe8\x07$%\n\x0c\n\x04\x04H\x02\x03\x12\x04\xe9\x07\x082\n\r\
    \n\x05\x04H\x02\x03\x04\x12\x04\xe9\x07\x08\x10\n\r\n\x05\x04H\x02\x03\
    \x05\x12\x04\xe9\x07\x11\x16\n\r\n\x05\x04H\x02\x03\x01\x12\x04\xe9\x07\
    \x17-\n\r\n\x05\x04H\x02\x03\x03\x12\x04\xe9\x0701\n\x0c\n\x04\x04H\x02\
    \x04\x12\x04\xea\x07\x08$\n\r\n\x05\x04H\x02\x04\x04\x12\x04\xea\x07\x08\
    \x10\n\r\n\x05\x04H\x02\x04\x05\x12\x04\xea\x07\x11\x15\n\r\n\x05\x04H\
    \x02\x04\x01\x12\x04\xea\x07\x16\x1f\n\r\n\x05\x04H\x02\x04\x03\x12\x04\
    \xea\x07\"#\n\x0c\n\x04\x04H\x02\x05\x12\x04\xeb\x07\x08$\n\r\n\x05\x04H\
    \x02\x05\x04\x12\x04\xeb\x07\x08\x10\n\r\n\x05\x04H\x02\x05\x05\x12\x04\
    \xeb\x07\x11\x15\n\r\n\x05\x04H\x02\x05\x01\x12\x04\xeb\x07\x16\x1f\n\r\
    \n\x05\x04H\x02\x05\x03\x12\x04\xeb\x07\"#\n\x0c\n\x04\x04H\x02\x06\x12\
    \x04\xec\x07\x08'\n\r\n\x05\x04H\x02\x06\x04\x12\x04\xec\x07\x08\x10\n\r\
    \n\x05\x04H\x02\x06\x05\x12\x04\xec\x07\x11\x16\n\r\n\x05\x04H\x02\x06\
    \x01\x12\x04\xec\x07\x17\"\n\r\n\x05\x04H\x02\x06\x03\x12\x04\xec\x07%&\
    \n\x0c\n\x04\x04H\x02\x07\x12\x04\xed\x07\x08,\n\r\n\x05\x04H\x02\x07\
    \x04\x12\x04\xed\x07\x08\x10\n\r\n\x05\x04H\x02\x07\x06\x12\x04\xed\x07\
    \x11\x1b\n\r\n\x05\x04H\x02\x07\x01\x12\x04\xed\x07\x1c&\n\r\n\x05\x04H\
    \x02\x07\x03\x12\x04\xed\x07)+\n\x0c\n\x04\x04H\x02\x08\x12\x04\xee\x07\
    \x08,\n\r\n\x05\x04H\x02\x08\x04\x12\x04\xee\x07\x08\x10\n\r\n\x05\x04H\
    \x02\x08\x05\x12\x04\xee\x07\x11\x18\n\r\n\x05\x04H\x02\x08\x01\x12\x04\
    \xee\x07\x19&\n\r\n\x05\x04H\x02\x08\x03\x12\x04\xee\x07)+\n\x0c\n\x04\
    \x04H\x02\t\x12\x04\xef\x07\x08(\n\r\n\x05\x04H\x02\t\x04\x12\x04\xef\
    \x07\x08\x10\n\r\n\x05\x04H\x02\t\x05\x12\x04\xef\x07\x11\x16\n\r\n\x05\
    \x04H\x02\t\x01\x12\x04\xef\x07\x17\"\n\r\n\x05\x04H\x02\t\x03\x12\x04\
    \xef\x07%'\n\x0c\n\x04\x04H\x02\n\x12\x04\xf0\x07\x08#\n\r\n\x05\x04H\
    \x02\n\x04\x12\x04\xf0\x07\x08\x10\n\r\n\x05\x04H\x02\n\x05\x12\x04\xf0\
    \x07\x11\x16\n\r\n\x05\x04H\x02\n\x01\x12\x04\xf0\x07\x17\x1d\n\r\n\x05\
    \x04H\x02\n\x03\x12\x04\xf0\x07\x20\"\n\x0c\n\x04\x04H\x02\x0b\x12\x04\
    \xf1\x07\x08$\n\r\n\x05\x04H\x02\x0b\x04\x12\x04\xf1\x07\x08\x10\n\r\n\
    \x05\x04H\x02\x0b\x05\x12\x04\xf1\x07\x11\x17\n\r\n\x05\x04H\x02\x0b\x01\
    \x12\x04\xf1\x07\x18\x1e\n\r\n\x05\x04H\x02\x0b\x03\x12\x04\xf1\x07!#\n\
    \x0c\n\x04\x04H\x02\x0c\x12\x04\xf2\x07\x08.\n\r\n\x05\x04H\x02\x0c\x04\
    \x12\x04\xf2\x07\x08\x10\n\r\n\x05\x04H\x02\x0c\x05\x12\x04\xf2\x07\x11\
    \x16\n\r\n\x05\x04H\x02\x0c\x01\x12\x04\xf2\x07\x17(\n\r\n\x05\x04H\x02\
    \x0c\x03\x12\x04\xf2\x07+-\n\x0c\n\x04\x04H\x02\r\x12\x04\xf3\x07\x08M\n\
    \r\n\x05\x04H\x02\r\x04\x12\x04\xf3\x07\x08\x10\n\r\n\x05\x04H\x02\r\x06\
    \x12\x04\xf3\x07\x116\n\r\n\x05\x04H\x02\r\x01\x12\x04\xf3\x077G\n\r\n\
    \x05\x04H\x02\r\x03\x12\x04\xf3\x07JL\n\x0c\n\x04\x04H\x02\x0e\x12\x04\
    \xf4\x07\x08>\n\r\n\x05\x04H\x02\x0e\x04\x12\x04\xf4\x07\x08\x10\n\r\n\
    \x05\x04H\x02\x0e\x05\x12\x04\xf4\x07\x11\x16\n\r\n\x05\x04H\x02\x0e\x01\
    \x12\x04\xf4\x07\x178\n\r\n\x05\x04H\x02\x0e\x03\x12\x04\xf4\x07;=\n\x0c\
    \n\x02\x04I\x12\x06\xf7\x07\0\xf9\x07\x01\n\x0b\n\x03\x04I\x01\x12\x04\
    \xf7\x07\x08)\n\x0c\n\x04\x04I\x02\0\x12\x04\xf8\x07\x08\"\n\r\n\x05\x04\
    I\x02\0\x04\x12\x04\xf8\x07\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\xf8\
    \x07\x11\x16\n\r\n\x05\x04I\x02\0\x01\x12\x04\xf8\x07\x17\x1d\n\r\n\x05\
    \x04I\x02\0\x03\x12\x04\xf8\x07\x20!\n\x0c\n\x02\x04J\x12\x06\xfb\x07\0\
    \x80\x08\x01\n\x0b\n\x03\x04J\x01\x12\x04\xfb\x07\x08'\n\x0c\n\x04\x04J\
    \x02\0\x12\x04\xfc\x07\x08#\n\r\n\x05\x04J\x02\0\x04\x12\x04\xfc\x07\x08\
    \x10\n\r\n\x05\x04J\x02\0\x05\x12\x04\xfc\x07\x11\x17\n\r\n\x05\x04J\x02\
    \0\x01\x12\x04\xfc\x07\x18\x1e\n\r\n\x05\x04J\x02\0\x03\x12\x04\xfc\x07!\
    \"\n\x0c\n\x04\x04J\x02\x01\x12\x04\xfd\x07\x08!\n\r\n\x05\x04J\x02\x01\
    \x04\x12\x04\xfd\x07\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xfd\x07\
    \x11\x16\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xfd\x07\x17\x1c\n\r\n\x05\
    \x04J\x02\x01\x03\x12\x04\xfd\x07\x1f\x20\n\x0c\n\x04\x04J\x02\x02\x12\
    \x04\xfe\x07\x08#\n\r\n\x05\x04J\x02\x02\x04\x12\x04\xfe\x07\x08\x10\n\r\
    \n\x05\x04J\x02\x02\x05\x12\x04\xfe\x07\x11\x16\n\r\n\x05\x04J\x02\x02\
    \x01\x12\x04\xfe\x07\x17\x1e\n\r\n\x05\x04J\x02\x02\x03\x12\x04\xfe\x07!\
    \"\n\x0c\n\x04\x04J\x02\x03\x12\x04\xff\x07\x08#\n\r\n\x05\x04J\x02\x03\
    \x04\x12\x04\xff\x07\x08\x10\n\r\n\x05\x04J\x02\x03\x05\x12\x04\xff\x07\
    \x11\x16\n\r\n\x05\x04J\x02\x03\x01\x12\x04\xff\x07\x17\x1e\n\r\n\x05\
    \x04J\x02\x03\x03\x12\x04\xff\x07!\"\n\x0c\n\x02\x04K\x12\x06\x82\x08\0\
    \x8f\x08\x01\n\x0b\n\x03\x04K\x01\x12\x04\x82\x08\x08\x20\n\x0c\n\x04\
    \x04K\x02\0\x12\x04\x83\x08\x08%\n\r\n\x05\x04K\x02\0\x04\x12\x04\x83\
    \x08\x08\x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\x83\x08\x11\x16\n\r\n\x05\
    \x04K\x02\0\x01\x12\x04\x83\x08\x17\x20\n\r\n\x05\x04K\x02\0\x03\x12\x04\
    \x83\x08#$\n\x0c\n\x04\x04K\x02\x01\x12\x04\x84\x08\x08&\n\r\n\x05\x04K\
    \x02\x01\x04\x12\x04\x84\x08\x08\x10\n\r\n\x05\x04K\x02\x01\x05\x12\x04\
    \x84\x08\x11\x16\n\r\n\x05\x04K\x02\x01\x01\x12\x04\x84\x08\x17!\n\r\n\
    \x05\x04K\x02\x01\x03\x12\x04\x84\x08$%\n\x0c\n\x04\x04K\x02\x02\x12\x04\
    \x85\x08\x081\n\r\n\x05\x04K\x02\x02\x04\x12\x04\x85\x08\x08\x10\n\r\n\
    \x05\x04K\x02\x02\x06\x12\x04\x85\x08\x11'\n\r\n\x05\x04K\x02\x02\x01\
    \x12\x04\x85\x08(,\n\r\n\x05\x04K\x02\x02\x03\x12\x04\x85\x08/0\n\x0c\n\
    \x04\x04K\x02\x03\x12\x04\x86\x08\x08-\n\r\n\x05\x04K\x02\x03\x04\x12\
    \x04\x86\x08\x08\x10\n\r\n\x05\x04K\x02\x03\x05\x12\x04\x86\x08\x11\x17\
    \n\r\n\x05\x04K\x02\x03\x01\x12\x04\x86\x08\x18(\n\r\n\x05\x04K\x02\x03\
    \x03\x12\x04\x86\x08+,\n\x0c\n\x04\x04K\x02\x04\x12\x04\x87\x08\x08\"\n\
    \r\n\x05\x04K\x02\x04\x04\x12\x04\x87\x08\x08\x10\n\r\n\x05\x04K\x02\x04\
    \x05\x12\x04\x87\x08\x11\x17\n\r\n\x05\x04K\x02\x04\x01\x12\x04\x87\x08\
    \x18\x1d\n\r\n\x05\x04K\x02\x04\x03\x12\x04\x87\x08\x20!\n\x0c\n\x04\x04\
    K\x02\x05\x12\x04\x88\x08\x08\"\n\r\n\x05\x04K\x02\x05\x04\x12\x04\x88\
    \x08\x08\x10\n\r\n\x05\x04K\x02\x05\x05\x12\x04\x88\x08\x11\x15\n\r\n\
    \x05\x04K\x02\x05\x01\x12\x04\x88\x08\x16\x1d\n\r\n\x05\x04K\x02\x05\x03\
    \x12\x04\x88\x08\x20!\n\x0c\n\x04\x04K\x02\x06\x12\x04\x89\x08\x08(\n\r\
    \n\x05\x04K\x02\x06\x04\x12\x04\x89\x08\x08\x10\n\r\n\x05\x04K\x02\x06\
    \x05\x12\x04\x89\x08\x11\x17\n\r\n\x05\x04K\x02\x06\x01\x12\x04\x89\x08\
    \x18#\n\r\n\x05\x04K\x02\x06\x03\x12\x04\x89\x08&'\n\x0c\n\x04\x04K\x02\
    \x07\x12\x04\x8a\x08\x08&\n\r\n\x05\x04K\x02\x07\x04\x12\x04\x8a\x08\x08\
    \x10\n\r\n\x05\x04K\x02\x07\x05\x12\x04\x8a\x08\x11\x17\n\r\n\x05\x04K\
    \x02\x07\x01\x12\x04\x8a\x08\x18!\n\r\n\x05\x04K\x02\x07\x03\x12\x04\x8a\
    \x08$%\n\x0c\n\x04\x04K\x02\x08\x12\x04\x8b\x08\x08+\n\r\n\x05\x04K\x02\
    \x08\x04\x12\x04\x8b\x08\x08\x10\n\r\n\x05\x04K\x02\x08\x05\x12\x04\x8b\
    \x08\x11\x16\n\r\n\x05\x04K\x02\x08\x01\x12\x04\x8b\x08\x17&\n\r\n\x05\
    \x04K\x02\x08\x03\x12\x04\x8b\x08)*\n\x0c\n\x04\x04K\x02\t\x12\x04\x8c\
    \x08\x08.\n\r\n\x05\x04K\x02\t\x04\x12\x04\x8c\x08\x08\x10\n\r\n\x05\x04\
    K\x02\t\x05\x12\x04\x8c\x08\x11\x16\n\r\n\x05\x04K\x02\t\x01\x12\x04\x8c\
    \x08\x17(\n\r\n\x05\x04K\x02\t\x03\x12\x04\x8c\x08+-\n\x0c\n\x04\x04K\
    \x02\n\x12\x04\x8d\x08\x08%\n\r\n\x05\x04K\x02\n\x04\x12\x04\x8d\x08\x08\
    \x10\n\r\n\x05\x04K\x02\n\x05\x12\x04\x8d\x08\x11\x15\n\r\n\x05\x04K\x02\
    \n\x01\x12\x04\x8d\x08\x16\x1f\n\r\n\x05\x04K\x02\n\x03\x12\x04\x8d\x08\
    \"$\n\x0c\n\x04\x04K\x02\x0b\x12\x04\x8e\x08\x08)\n\r\n\x05\x04K\x02\x0b\
    \x04\x12\x04\x8e\x08\x08\x10\n\r\n\x05\x04K\x02\x0b\x05\x12\x04\x8e\x08\
    \x11\x16\n\r\n\x05\x04K\x02\x0b\x01\x12\x04\x8e\x08\x17#\n\r\n\x05\x04K\
    \x02\x0b\x03\x12\x04\x8e\x08&(\n\x0c\n\x02\x04L\x12\x06\x91\x08\0\x99\
    \x08\x01\n\x0b\n\x03\x04L\x01\x12\x04\x91\x08\x08%\n\x0c\n\x04\x04L\x02\
    \0\x12\x04\x92\x08\x08#\n\r\n\x05\x04L\x02\0\x04\x12\x04\x92\x08\x08\x10\
    \n\r\n\x05\x04L\x02\0\x05\x12\x04\x92\x08\x11\x17\n\r\n\x05\x04L\x02\0\
    \x01\x12\x04\x92\x08\x18\x1e\n\r\n\x05\x04L\x02\0\x03\x12\x04\x92\x08!\"\
    \n\x0c\n\x04\x04L\x02\x01\x12\x04\x93\x08\x08,\n\r\n\x05\x04L\x02\x01\
    \x04\x12\x04\x93\x08\x08\x10\n\r\n\x05\x04L\x02\x01\x05\x12\x04\x93\x08\
    \x11\x16\n\r\n\x05\x04L\x02\x01\x01\x12\x04\x93\x08\x17'\n\r\n\x05\x04L\
    \x02\x01\x03\x12\x04\x93\x08*+\n\x0c\n\x04\x04L\x02\x02\x12\x04\x94\x08\
    \x08(\n\r\n\x05\x04L\x02\x02\x04\x12\x04\x94\x08\x08\x10\n\r\n\x05\x04L\
    \x02\x02\x05\x12\x04\x94\x08\x11\x16\n\r\n\x05\x04L\x02\x02\x01\x12\x04\
    \x94\x08\x17#\n\r\n\x05\x04L\x02\x02\x03\x12\x04\x94\x08&'\n\x0c\n\x04\
    \x04L\x02\x03\x12\x04\x95\x08\x08%\n\r\n\x05\x04L\x02\x03\x04\x12\x04\
    \x95\x08\x08\x10\n\r\n\x05\x04L\x02\x03\x05\x12\x04\x95\x08\x11\x16\n\r\
    \n\x05\x04L\x02\x03\x01\x12\x04\x95\x08\x17\x20\n\r\n\x05\x04L\x02\x03\
    \x03\x12\x04\x95\x08#$\n\x0c\n\x04\x04L\x02\x04\x12\x04\x96\x08\x08\x20\
    \n\r\n\x05\x04L\x02\x04\x04\x12\x04\x96\x08\x08\x10\n\r\n\x05\x04L\x02\
    \x04\x05\x12\x04\x96\x08\x11\x16\n\r\n\x05\x04L\x02\x04\x01\x12\x04\x96\
    \x08\x17\x1b\n\r\n\x05\x04L\x02\x04\x03\x12\x04\x96\x08\x1e\x1f\n\x0c\n\
    \x04\x04L\x02\x05\x12\x04\x97\x08\x08$\n\r\n\x05\x04L\x02\x05\x04\x12\
    \x04\x97\x08\x08\x10\n\r\n\x05\x04L\x02\x05\x05\x12\x04\x97\x08\x11\x16\
    \n\r\n\x05\x04L\x02\x05\x01\x12\x04\x97\x08\x17\x1f\n\r\n\x05\x04L\x02\
    \x05\x03\x12\x04\x97\x08\"#\n\x0c\n\x04\x04L\x02\x06\x12\x04\x98\x08\x08\
    1\n\r\n\x05\x04L\x02\x06\x04\x12\x04\x98\x08\x08\x10\n\r\n\x05\x04L\x02\
    \x06\x05\x12\x04\x98\x08\x11\x16\n\r\n\x05\x04L\x02\x06\x01\x12\x04\x98\
    \x08\x17,\n\r\n\x05\x04L\x02\x06\x03\x12\x04\x98\x08/0\n\x0c\n\x02\x04M\
    \x12\x06\x9b\x08\0\x9e\x08\x01\n\x0b\n\x03\x04M\x01\x12\x04\x9b\x08\x08(\
    \n\x0c\n\x04\x04M\x02\0\x12\x04\x9c\x08\x08#\n\r\n\x05\x04M\x02\0\x04\
    \x12\x04\x9c\x08\x08\x10\n\r\n\x05\x04M\x02\0\x05\x12\x04\x9c\x08\x11\
    \x17\n\r\n\x05\x04M\x02\0\x01\x12\x04\x9c\x08\x18\x1e\n\r\n\x05\x04M\x02\
    \0\x03\x12\x04\x9c\x08!\"\n\x0c\n\x04\x04M\x02\x01\x12\x04\x9d\x08\x08\
    \x1f\n\r\n\x05\x04M\x02\x01\x04\x12\x04\x9d\x08\x08\x10\n\r\n\x05\x04M\
    \x02\x01\x05\x12\x04\x9d\x08\x11\x15\n\r\n\x05\x04M\x02\x01\x01\x12\x04\
    \x9d\x08\x16\x1a\n\r\n\x05\x04M\x02\x01\x03\x12\x04\x9d\x08\x1d\x1e\n\
    \x0c\n\x02\x04N\x12\x06\xa0\x08\0\xa7\x08\x01\n\x0b\n\x03\x04N\x01\x12\
    \x04\xa0\x08\x08%\n\x0c\n\x04\x04N\x02\0\x12\x04\xa1\x08\x08#\n\r\n\x05\
    \x04N\x02\0\x04\x12\x04\xa1\x08\x08\x10\n\r\n\x05\x04N\x02\0\x05\x12\x04\
    \xa1\x08\x11\x17\n\r\n\x05\x04N\x02\0\x01\x12\x04\xa1\x08\x18\x1e\n\r\n\
    \x05\x04N\x02\0\x03\x12\x04\xa1\x08!\"\n\x0c\n\x04\x04N\x02\x01\x12\x04\
    \xa2\x08\x08!\n\r\n\x05\x04N\x02\x01\x04\x12\x04\xa2\x08\x08\x10\n\r\n\
    \x05\x04N\x02\x01\x05\x12\x04\xa2\x08\x11\x17\n\r\n\x05\x04N\x02\x01\x01\
    \x12\x04\xa2\x08\x18\x1c\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xa2\x08\x1f\
    \x20\n\x0c\n\x04\x04N\x02\x02\x12\x04\xa3\x08\x08#\n\r\n\x05\x04N\x02\
    \x02\x04\x12\x04\xa3\x08\x08\x10\n\r\n\x05\x04N\x02\x02\x05\x12\x04\xa3\
    \x08\x11\x17\n\r\n\x05\x04N\x02\x02\x01\x12\x04\xa3\x08\x18\x1e\n\r\n\
    \x05\x04N\x02\x02\x03\x12\x04\xa3\x08!\"\n\x0c\n\x04\x04N\x02\x03\x12\
    \x04\xa4\x08\x08#\n\r\n\x05\x04N\x02\x03\x04\x12\x04\xa4\x08\x08\x10\n\r\
    \n\x05\x04N\x02\x03\x05\x12\x04\xa4\x08\x11\x17\n\r\n\x05\x04N\x02\x03\
    \x01\x12\x04\xa4\x08\x18\x1e\n\r\n\x05\x04N\x02\x03\x03\x12\x04\xa4\x08!\
    \"\n\x0c\n\x04\x04N\x02\x04\x12\x04\xa5\x08\x08&\n\r\n\x05\x04N\x02\x04\
    \x04\x12\x04\xa5\x08\x08\x10\n\r\n\x05\x04N\x02\x04\x05\x12\x04\xa5\x08\
    \x11\x15\n\r\n\x05\x04N\x02\x04\x01\x12\x04\xa5\x08\x16!\n\r\n\x05\x04N\
    \x02\x04\x03\x12\x04\xa5\x08$%\n\x0c\n\x04\x04N\x02\x05\x12\x04\xa6\x08\
    \x080\n\r\n\x05\x04N\x02\x05\x04\x12\x04\xa6\x08\x08\x10\n\r\n\x05\x04N\
    \x02\x05\x05\x12\x04\xa6\x08\x11\x15\n\r\n\x05\x04N\x02\x05\x01\x12\x04\
    \xa6\x08\x16+\n\r\n\x05\x04N\x02\x05\x03\x12\x04\xa6\x08./\n\x0c\n\x02\
    \x04O\x12\x06\xa9\x08\0\xae\x08\x01\n\x0b\n\x03\x04O\x01\x12\x04\xa9\x08\
    \x08\x1e\n\x0c\n\x04\x04O\x02\0\x12\x04\xaa\x08\x08\"\n\r\n\x05\x04O\x02\
    \0\x04\x12\x04\xaa\x08\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\x04\xaa\x08\
    \x11\x17\n\r\n\x05\x04O\x02\0\x01\x12\x04\xaa\x08\x18\x1d\n\r\n\x05\x04O\
    \x02\0\x03\x12\x04\xaa\x08\x20!\n\x0c\n\x04\x04O\x02\x01\x12\x04\xab\x08\
    \x08$\n\r\n\x05\x04O\x02\x01\x04\x12\x04\xab\x08\x08\x10\n\r\n\x05\x04O\
    \x02\x01\x05\x12\x04\xab\x08\x11\x16\n\r\n\x05\x04O\x02\x01\x01\x12\x04\
    \xab\x08\x17\x1f\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xab\x08\"#\n\x0c\n\
    \x04\x04O\x02\x02\x12\x04\xac\x08\x08(\n\r\n\x05\x04O\x02\x02\x04\x12\
    \x04\xac\x08\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\x04\xac\x08\x11\x16\
    \n\r\n\x05\x04O\x02\x02\x01\x12\x04\xac\x08\x17#\n\r\n\x05\x04O\x02\x02\
    \x03\x12\x04\xac\x08&'\n\x0c\n\x04\x04O\x02\x03\x12\x04\xad\x08\x08$\n\r\
    \n\x05\x04O\x02\x03\x04\x12\x04\xad\x08\x08\x10\n\r\n\x05\x04O\x02\x03\
    \x05\x12\x04\xad\x08\x11\x17\n\r\n\x05\x04O\x02\x03\x01\x12\x04\xad\x08\
    \x18\x1f\n\r\n\x05\x04O\x02\x03\x03\x12\x04\xad\x08\"#\n\x0c\n\x02\x04P\
    \x12\x06\xb0\x08\0\xb2\x08\x01\n\x0b\n\x03\x04P\x01\x12\x04\xb0\x08\x08\
    \x1f\n\x0c\n\x04\x04P\x02\0\x12\x04\xb1\x08\x08)\n\r\n\x05\x04P\x02\0\
    \x04\x12\x04\xb1\x08\x08\x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\xb1\x08\
    \x11\x16\n\r\n\x05\x04P\x02\0\x01\x12\x04\xb1\x08\x17$\n\r\n\x05\x04P\
    \x02\0\x03\x12\x04\xb1\x08'(\n\x0c\n\x02\x04Q\x12\x06\xb4\x08\0\xb6\x08\
    \x01\n\x0b\n\x03\x04Q\x01\x12\x04\xb4\x08\x08\x1c\n\x0c\n\x04\x04Q\x02\0\
    \x12\x04\xb5\x08\x08+\n\r\n\x05\x04Q\x02\0\x04\x12\x04\xb5\x08\x08\x10\n\
    \r\n\x05\x04Q\x02\0\x05\x12\x04\xb5\x08\x11\x16\n\r\n\x05\x04Q\x02\0\x01\
    \x12\x04\xb5\x08\x17&\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xb5\x08)*\n\x0c\n\
    \x02\x04R\x12\x06\xb8\x08\0\xbe\x08\x01\n\x0b\n\x03\x04R\x01\x12\x04\xb8\
    \x08\x08'\n\x0c\n\x04\x04R\x02\0\x12\x04\xb9\x08\x08%\n\r\n\x05\x04R\x02\
    \0\x04\x12\x04\xb9\x08\x08\x10\n\r\n\x05\x04R\x02\0\x05\x12\x04\xb9\x08\
    \x11\x16\n\r\n\x05\x04R\x02\0\x01\x12\x04\xb9\x08\x17\x20\n\r\n\x05\x04R\
    \x02\0\x03\x12\x04\xb9\x08#$\n\x0c\n\x04\x04R\x02\x01\x12\x04\xba\x08\
    \x08!\n\r\n\x05\x04R\x02\x01\x04\x12\x04\xba\x08\x08\x10\n\r\n\x05\x04R\
    \x02\x01\x05\x12\x04\xba\x08\x11\x16\n\r\n\x05\x04R\x02\x01\x01\x12\x04\
    \xba\x08\x17\x1c\n\r\n\x05\x04R\x02\x01\x03\x12\x04\xba\x08\x1f\x20\n\
    \x0c\n\x04\x04R\x02\x02\x12\x04\xbb\x08\x08'\n\r\n\x05\x04R\x02\x02\x04\
    \x12\x04\xbb\x08\x08\x10\n\r\n\x05\x04R\x02\x02\x05\x12\x04\xbb\x08\x11\
    \x16\n\r\n\x05\x04R\x02\x02\x01\x12\x04\xbb\x08\x17\"\n\r\n\x05\x04R\x02\
    \x02\x03\x12\x04\xbb\x08%&\n\x0c\n\x04\x04R\x02\x03\x12\x04\xbc\x08\x08*\
    \n\r\n\x05\x04R\x02\x03\x04\x12\x04\xbc\x08\x08\x10\n\r\n\x05\x04R\x02\
    \x03\x05\x12\x04\xbc\x08\x11\x17\n\r\n\x05\x04R\x02\x03\x01\x12\x04\xbc\
    \x08\x18%\n\r\n\x05\x04R\x02\x03\x03\x12\x04\xbc\x08()\n\x0c\n\x04\x04R\
    \x02\x04\x12\x04\xbd\x08\x080\n\r\n\x05\x04R\x02\x04\x04\x12\x04\xbd\x08\
    \x08\x10\n\r\n\x05\x04R\x02\x04\x05\x12\x04\xbd\x08\x11\x17\n\r\n\x05\
    \x04R\x02\x04\x01\x12\x04\xbd\x08\x18+\n\r\n\x05\x04R\x02\x04\x03\x12\
    \x04\xbd\x08./\n\x0c\n\x02\x04S\x12\x06\xc0\x08\0\xc2\x08\x01\n\x0b\n\
    \x03\x04S\x01\x12\x04\xc0\x08\x08!\n\x0c\n\x04\x04S\x02\0\x12\x04\xc1\
    \x08\x08E\n\r\n\x05\x04S\x02\0\x04\x12\x04\xc1\x08\x08\x10\n\r\n\x05\x04\
    S\x02\0\x06\x12\x04\xc1\x08\x110\n\r\n\x05\x04S\x02\0\x01\x12\x04\xc1\
    \x081@\n\r\n\x05\x04S\x02\0\x03\x12\x04\xc1\x08CD\n\x0c\n\x02\x04T\x12\
    \x06\xc4\x08\0\xc6\x08\x01\n\x0b\n\x03\x04T\x01\x12\x04\xc4\x08\x08\x1e\
    \n\x0c\n\x04\x04T\x02\0\x12\x04\xc5\x08\x08\x20\n\r\n\x05\x04T\x02\0\x04\
    \x12\x04\xc5\x08\x08\x10\n\r\n\x05\x04T\x02\0\x05\x12\x04\xc5\x08\x11\
    \x17\n\r\n\x05\x04T\x02\0\x01\x12\x04\xc5\x08\x18\x1b\n\r\n\x05\x04T\x02\
    \0\x03\x12\x04\xc5\x08\x1e\x1f\n\x0c\n\x02\x04U\x12\x06\xc8\x08\0\xcc\
    \x08\x01\n\x0b\n\x03\x04U\x01\x12\x04\xc8\x08\x08!\n\x0c\n\x04\x04U\x02\
    \0\x12\x04\xc9\x08\x08%\n\r\n\x05\x04U\x02\0\x04\x12\x04\xc9\x08\x08\x10\
    \n\r\n\x05\x04U\x02\0\x05\x12\x04\xc9\x08\x11\x16\n\r\n\x05\x04U\x02\0\
    \x01\x12\x04\xc9\x08\x17\x20\n\r\n\x05\x04U\x02\0\x03\x12\x04\xc9\x08#$\
    \n\x0c\n\x04\x04U\x02\x01\x12\x04\xca\x08\x08&\n\r\n\x05\x04U\x02\x01\
    \x04\x12\x04\xca\x08\x08\x10\n\r\n\x05\x04U\x02\x01\x05\x12\x04\xca\x08\
    \x11\x16\n\r\n\x05\x04U\x02\x01\x01\x12\x04\xca\x08\x17!\n\r\n\x05\x04U\
    \x02\x01\x03\x12\x04\xca\x08$%\n\x0c\n\x04\x04U\x02\x02\x12\x04\xcb\x08\
    \x08*\n\r\n\x05\x04U\x02\x02\x04\x12\x04\xcb\x08\x08\x10\n\r\n\x05\x04U\
    \x02\x02\x05\x12\x04\xcb\x08\x11\x17\n\r\n\x05\x04U\x02\x02\x01\x12\x04\
    \xcb\x08\x18%\n\r\n\x05\x04U\x02\x02\x03\x12\x04\xcb\x08()\n\x0c\n\x02\
    \x04V\x12\x06\xce\x08\0\xd3\x08\x01\n\x0b\n\x03\x04V\x01\x12\x04\xce\x08\
    \x08$\n\x0c\n\x04\x04V\x02\0\x12\x04\xcf\x08\x08%\n\r\n\x05\x04V\x02\0\
    \x04\x12\x04\xcf\x08\x08\x10\n\r\n\x05\x04V\x02\0\x05\x12\x04\xcf\x08\
    \x11\x16\n\r\n\x05\x04V\x02\0\x01\x12\x04\xcf\x08\x17\x20\n\r\n\x05\x04V\
    \x02\0\x03\x12\x04\xcf\x08#$\n\x0c\n\x04\x04V\x02\x01\x12\x04\xd0\x08\
    \x08#\n\r\n\x05\x04V\x02\x01\x04\x12\x04\xd0\x08\x08\x10\n\r\n\x05\x04V\
    \x02\x01\x05\x12\x04\xd0\x08\x11\x16\n\r\n\x05\x04V\x02\x01\x01\x12\x04\
    \xd0\x08\x17\x1e\n\r\n\x05\x04V\x02\x01\x03\x12\x04\xd0\x08!\"\n\x0c\n\
    \x04\x04V\x02\x02\x12\x04\xd1\x08\x08&\n\r\n\x05\x04V\x02\x02\x04\x12\
    \x04\xd1\x08\x08\x10\n\r\n\x05\x04V\x02\x02\x05\x12\x04\xd1\x08\x11\x17\
    \n\r\n\x05\x04V\x02\x02\x01\x12\x04\xd1\x08\x18!\n\r\n\x05\x04V\x02\x02\
    \x03\x12\x04\xd1\x08$%\n\x0c\n\x04\x04V\x02\x03\x12\x04\xd2\x08\x08$\n\r\
    \n\x05\x04V\x02\x03\x04\x12\x04\xd2\x08\x08\x10\n\r\n\x05\x04V\x02\x03\
    \x05\x12\x04\xd2\x08\x11\x17\n\r\n\x05\x04V\x02\x03\x01\x12\x04\xd2\x08\
    \x18\x1f\n\r\n\x05\x04V\x02\x03\x03\x12\x04\xd2\x08\"#\n\x0c\n\x02\x04W\
    \x12\x06\xd5\x08\0\xdd\x08\x01\n\x0b\n\x03\x04W\x01\x12\x04\xd5\x08\x08*\
    \n\x0e\n\x04\x04W\x03\0\x12\x06\xd6\x08\x08\xd9\x08\t\n\r\n\x05\x04W\x03\
    \0\x01\x12\x04\xd6\x08\x10\x1c\n\x0e\n\x06\x04W\x03\0\x02\0\x12\x04\xd7\
    \x08\x10F\n\x0f\n\x07\x04W\x03\0\x02\0\x04\x12\x04\xd7\x08\x10\x18\n\x0f\
    \n\x07\x04W\x03\0\x02\0\x06\x12\x04\xd7\x08\x19/\n\x0f\n\x07\x04W\x03\0\
    \x02\0\x01\x12\x04\xd7\x080A\n\x0f\n\x07\x04W\x03\0\x02\0\x03\x12\x04\
    \xd7\x08DE\n\x0e\n\x06\x04W\x03\0\x02\x01\x12\x04\xd8\x08\x103\n\x0f\n\
    \x07\x04W\x03\0\x02\x01\x04\x12\x04\xd8\x08\x10\x18\n\x0f\n\x07\x04W\x03\
    \0\x02\x01\x05\x12\x04\xd8\x08\x19\x1f\n\x0f\n\x07\x04W\x03\0\x02\x01\
    \x01\x12\x04\xd8\x08\x20.\n\x0f\n\x07\x04W\x03\0\x02\x01\x03\x12\x04\xd8\
    \x0812\n\x0c\n\x04\x04W\x02\0\x12\x04\xdb\x08\x08,\n\r\n\x05\x04W\x02\0\
    \x04\x12\x04\xdb\x08\x08\x10\n\r\n\x05\x04W\x02\0\x05\x12\x04\xdb\x08\
    \x11\x16\n\r\n\x05\x04W\x02\0\x01\x12\x04\xdb\x08\x17'\n\r\n\x05\x04W\
    \x02\0\x03\x12\x04\xdb\x08*+\n\x0c\n\x04\x04W\x02\x01\x12\x04\xdc\x08\
    \x08V\n\r\n\x05\x04W\x02\x01\x04\x12\x04\xdc\x08\x08\x10\n\r\n\x05\x04W\
    \x02\x01\x06\x12\x04\xdc\x08\x11@\n\r\n\x05\x04W\x02\x01\x01\x12\x04\xdc\
    \x08AQ\n\r\n\x05\x04W\x02\x01\x03\x12\x04\xdc\x08TU\n\x0c\n\x02\x04X\x12\
    \x06\xdf\x08\0\xef\x08\x01\n\x0b\n\x03\x04X\x01\x12\x04\xdf\x08\x08+\n\
    \x0c\n\x04\x04X\x02\0\x12\x04\xe0\x08\x08&\n\r\n\x05\x04X\x02\0\x04\x12\
    \x04\xe0\x08\x08\x10\n\r\n\x05\x04X\x02\0\x05\x12\x04\xe0\x08\x11\x17\n\
    \r\n\x05\x04X\x02\0\x01\x12\x04\xe0\x08\x18!\n\r\n\x05\x04X\x02\0\x03\
    \x12\x04\xe0\x08$%\n\x0c\n\x04\x04X\x02\x01\x12\x04\xe1\x08\x08'\n\r\n\
    \x05\x04X\x02\x01\x04\x12\x04\xe1\x08\x08\x10\n\r\n\x05\x04X\x02\x01\x05\
    \x12\x04\xe1\x08\x11\x17\n\r\n\x05\x04X\x02\x01\x01\x12\x04\xe1\x08\x18\
    \"\n\r\n\x05\x04X\x02\x01\x03\x12\x04\xe1\x08%&\n\x0c\n\x04\x04X\x02\x02\
    \x12\x04\xe2\x08\x08(\n\r\n\x05\x04X\x02\x02\x04\x12\x04\xe2\x08\x08\x10\
    \n\r\n\x05\x04X\x02\x02\x05\x12\x04\xe2\x08\x11\x17\n\r\n\x05\x04X\x02\
    \x02\x01\x12\x04\xe2\x08\x18#\n\r\n\x05\x04X\x02\x02\x03\x12\x04\xe2\x08\
    &'\n\x0c\n\x04\x04X\x02\x03\x12\x04\xe3\x08\x08)\n\r\n\x05\x04X\x02\x03\
    \x04\x12\x04\xe3\x08\x08\x10\n\r\n\x05\x04X\x02\x03\x05\x12\x04\xe3\x08\
    \x11\x17\n\r\n\x05\x04X\x02\x03\x01\x12\x04\xe3\x08\x18$\n\r\n\x05\x04X\
    \x02\x03\x03\x12\x04\xe3\x08'(\n\x0c\n\x04\x04X\x02\x04\x12\x04\xe4\x08\
    \x08F\n\r\n\x05\x04X\x02\x04\x04\x12\x04\xe4\x08\x08\x10\n\r\n\x05\x04X\
    \x02\x04\x06\x12\x04\xe4\x08\x113\n\r\n\x05\x04X\x02\x04\x01\x12\x04\xe4\
    \x084A\n\r\n\x05\x04X\x02\x04\x03\x12\x04\xe4\x08DE\n\x0c\n\x04\x04X\x02\
    \x05\x12\x04\xe5\x08\x08%\n\r\n\x05\x04X\x02\x05\x04\x12\x04\xe5\x08\x08\
    \x10\n\r\n\x05\x04X\x02\x05\x05\x12\x04\xe5\x08\x11\x17\n\r\n\x05\x04X\
    \x02\x05\x01\x12\x04\xe5\x08\x18\x20\n\r\n\x05\x04X\x02\x05\x03\x12\x04\
    \xe5\x08#$\n\x0c\n\x04\x04X\x02\x06\x12\x04\xe6\x08\x08&\n\r\n\x05\x04X\
    \x02\x06\x04\x12\x04\xe6\x08\x08\x10\n\r\n\x05\x04X\x02\x06\x05\x12\x04\
    \xe6\x08\x11\x17\n\r\n\x05\x04X\x02\x06\x01\x12\x04\xe6\x08\x18!\n\r\n\
    \x05\x04X\x02\x06\x03\x12\x04\xe6\x08$%\n\x0c\n\x04\x04X\x02\x07\x12\x04\
    \xe7\x08\x081\n\r\n\x05\x04X\x02\x07\x04\x12\x04\xe7\x08\x08\x10\n\r\n\
    \x05\x04X\x02\x07\x05\x12\x04\xe7\x08\x11\x17\n\r\n\x05\x04X\x02\x07\x01\
    \x12\x04\xe7\x08\x18,\n\r\n\x05\x04X\x02\x07\x03\x12\x04\xe7\x08/0\n\x0c\
    \n\x04\x04X\x02\x08\x12\x04\xe8\x08\x08)\n\r\n\x05\x04X\x02\x08\x04\x12\
    \x04\xe8\x08\x08\x10\n\r\n\x05\x04X\x02\x08\x05\x12\x04\xe8\x08\x11\x17\
    \n\r\n\x05\x04X\x02\x08\x01\x12\x04\xe8\x08\x18$\n\r\n\x05\x04X\x02\x08\
    \x03\x12\x04\xe8\x08'(\n\x0c\n\x04\x04X\x02\t\x12\x04\xe9\x08\x08*\n\r\n\
    \x05\x04X\x02\t\x04\x12\x04\xe9\x08\x08\x10\n\r\n\x05\x04X\x02\t\x05\x12\
    \x04\xe9\x08\x11\x17\n\r\n\x05\x04X\x02\t\x01\x12\x04\xe9\x08\x18$\n\r\n\
    \x05\x04X\x02\t\x03\x12\x04\xe9\x08')\n\x0c\n\x04\x04X\x02\n\x12\x04\xea\
    \x08\x08-\n\r\n\x05\x04X\x02\n\x04\x12\x04\xea\x08\x08\x10\n\r\n\x05\x04\
    X\x02\n\x05\x12\x04\xea\x08\x11\x17\n\r\n\x05\x04X\x02\n\x01\x12\x04\xea\
    \x08\x18'\n\r\n\x05\x04X\x02\n\x03\x12\x04\xea\x08*,\n\x0c\n\x04\x04X\
    \x02\x0b\x12\x04\xeb\x08\x08&\n\r\n\x05\x04X\x02\x0b\x04\x12\x04\xeb\x08\
    \x08\x10\n\r\n\x05\x04X\x02\x0b\x05\x12\x04\xeb\x08\x11\x17\n\r\n\x05\
    \x04X\x02\x0b\x01\x12\x04\xeb\x08\x18\x20\n\r\n\x05\x04X\x02\x0b\x03\x12\
    \x04\xeb\x08#%\n\x0c\n\x04\x04X\x02\x0c\x12\x04\xec\x08\x08(\n\r\n\x05\
    \x04X\x02\x0c\x04\x12\x04\xec\x08\x08\x10\n\r\n\x05\x04X\x02\x0c\x05\x12\
    \x04\xec\x08\x11\x17\n\r\n\x05\x04X\x02\x0c\x01\x12\x04\xec\x08\x18\"\n\
    \r\n\x05\x04X\x02\x0c\x03\x12\x04\xec\x08%'\n\x0c\n\x04\x04X\x02\r\x12\
    \x04\xed\x08\x08-\n\r\n\x05\x04X\x02\r\x04\x12\x04\xed\x08\x08\x10\n\r\n\
    \x05\x04X\x02\r\x05\x12\x04\xed\x08\x11\x17\n\r\n\x05\x04X\x02\r\x01\x12\
    \x04\xed\x08\x18'\n\r\n\x05\x04X\x02\r\x03\x12\x04\xed\x08*,\n\x0c\n\x04\
    \x04X\x02\x0e\x12\x04\xee\x08\x08)\n\r\n\x05\x04X\x02\x0e\x04\x12\x04\
    \xee\x08\x08\x10\n\r\n\x05\x04X\x02\x0e\x05\x12\x04\xee\x08\x11\x17\n\r\
    \n\x05\x04X\x02\x0e\x01\x12\x04\xee\x08\x18#\n\r\n\x05\x04X\x02\x0e\x03\
    \x12\x04\xee\x08&(\n\x0c\n\x02\x04Y\x12\x06\xf1\x08\0\x82\t\x01\n\x0b\n\
    \x03\x04Y\x01\x12\x04\xf1\x08\x08+\n\x0e\n\x04\x04Y\x03\0\x12\x06\xf2\
    \x08\x08\xf6\x08\t\n\r\n\x05\x04Y\x03\0\x01\x12\x04\xf2\x08\x10#\n\x0e\n\
    \x06\x04Y\x03\0\x02\0\x12\x04\xf3\x08\x106\n\x0f\n\x07\x04Y\x03\0\x02\0\
    \x04\x12\x04\xf3\x08\x10\x18\n\x0f\n\x07\x04Y\x03\0\x02\0\x05\x12\x04\
    \xf3\x08\x19\x1f\n\x0f\n\x07\x04Y\x03\0\x02\0\x01\x12\x04\xf3\x08\x201\n\
    \x0f\n\x07\x04Y\x03\0\x02\0\x03\x12\x04\xf3\x0845\n\x0e\n\x06\x04Y\x03\0\
    \x02\x01\x12\x04\xf4\x08\x10.\n\x0f\n\x07\x04Y\x03\0\x02\x01\x04\x12\x04\
    \xf4\x08\x10\x18\n\x0f\n\x07\x04Y\x03\0\x02\x01\x05\x12\x04\xf4\x08\x19\
    \x1f\n\x0f\n\x07\x04Y\x03\0\x02\x01\x01\x12\x04\xf4\x08\x20)\n\x0f\n\x07\
    \x04Y\x03\0\x02\x01\x03\x12\x04\xf4\x08,-\n\x0e\n\x06\x04Y\x03\0\x02\x02\
    \x12\x04\xf5\x08\x10*\n\x0f\n\x07\x04Y\x03\0\x02\x02\x04\x12\x04\xf5\x08\
    \x10\x18\n\x0f\n\x07\x04Y\x03\0\x02\x02\x05\x12\x04\xf5\x08\x19\x1f\n\
    \x0f\n\x07\x04Y\x03\0\x02\x02\x01\x12\x04\xf5\x08\x20%\n\x0f\n\x07\x04Y\
    \x03\0\x02\x02\x03\x12\x04\xf5\x08()\n\x0c\n\x04\x04Y\x02\0\x12\x04\xf8\
    \x08\x08F\n\r\n\x05\x04Y\x02\0\x04\x12\x04\xf8\x08\x08\x10\n\r\n\x05\x04\
    Y\x02\0\x06\x12\x04\xf8\x08\x114\n\r\n\x05\x04Y\x02\0\x01\x12\x04\xf8\
    \x085A\n\r\n\x05\x04Y\x02\0\x03\x12\x04\xf8\x08DE\n\x0c\n\x04\x04Y\x02\
    \x01\x12\x04\xf9\x08\x08(\n\r\n\x05\x04Y\x02\x01\x04\x12\x04\xf9\x08\x08\
    \x10\n\r\n\x05\x04Y\x02\x01\x05\x12\x04\xf9\x08\x11\x17\n\r\n\x05\x04Y\
    \x02\x01\x01\x12\x04\xf9\x08\x18#\n\r\n\x05\x04Y\x02\x01\x03\x12\x04\xf9\
    \x08&'\n\x0c\n\x04\x04Y\x02\x02\x12\x04\xfa\x08\x08*\n\r\n\x05\x04Y\x02\
    \x02\x04\x12\x04\xfa\x08\x08\x10\n\r\n\x05\x04Y\x02\x02\x05\x12\x04\xfa\
    \x08\x11\x17\n\r\n\x05\x04Y\x02\x02\x01\x12\x04\xfa\x08\x18%\n\r\n\x05\
    \x04Y\x02\x02\x03\x12\x04\xfa\x08()\n\x0c\n\x04\x04Y\x02\x03\x12\x04\xfb\
    \x08\x086\n\r\n\x05\x04Y\x02\x03\x04\x12\x04\xfb\x08\x08\x10\n\r\n\x05\
    \x04Y\x02\x03\x05\x12\x04\xfb\x08\x11\x17\n\r\n\x05\x04Y\x02\x03\x01\x12\
    \x04\xfb\x08\x181\n\r\n\x05\x04Y\x02\x03\x03\x12\x04\xfb\x0845\n\x0c\n\
    \x04\x04Y\x02\x04\x12\x04\xfc\x08\x08/\n\r\n\x05\x04Y\x02\x04\x04\x12\
    \x04\xfc\x08\x08\x10\n\r\n\x05\x04Y\x02\x04\x05\x12\x04\xfc\x08\x11\x17\
    \n\r\n\x05\x04Y\x02\x04\x01\x12\x04\xfc\x08\x18*\n\r\n\x05\x04Y\x02\x04\
    \x03\x12\x04\xfc\x08-.\n\x0c\n\x04\x04Y\x02\x05\x12\x04\xfd\x08\x080\n\r\
    \n\x05\x04Y\x02\x05\x04\x12\x04\xfd\x08\x08\x10\n\r\n\x05\x04Y\x02\x05\
    \x05\x12\x04\xfd\x08\x11\x17\n\r\n\x05\x04Y\x02\x05\x01\x12\x04\xfd\x08\
    \x18+\n\r\n\x05\x04Y\x02\x05\x03\x12\x04\xfd\x08./\n\x0c\n\x04\x04Y\x02\
    \x06\x12\x04\xfe\x08\x083\n\r\n\x05\x04Y\x02\x06\x04\x12\x04\xfe\x08\x08\
    \x10\n\r\n\x05\x04Y\x02\x06\x05\x12\x04\xfe\x08\x11\x17\n\r\n\x05\x04Y\
    \x02\x06\x01\x12\x04\xfe\x08\x18.\n\r\n\x05\x04Y\x02\x06\x03\x12\x04\xfe\
    \x0812\n\x0c\n\x04\x04Y\x02\x07\x12\x04\xff\x08\x08/\n\r\n\x05\x04Y\x02\
    \x07\x04\x12\x04\xff\x08\x08\x10\n\r\n\x05\x04Y\x02\x07\x05\x12\x04\xff\
    \x08\x11\x17\n\r\n\x05\x04Y\x02\x07\x01\x12\x04\xff\x08\x18*\n\r\n\x05\
    \x04Y\x02\x07\x03\x12\x04\xff\x08-.\n\x0c\n\x04\x04Y\x02\x08\x12\x04\x80\
    \t\x08-\n\r\n\x05\x04Y\x02\x08\x04\x12\x04\x80\t\x08\x10\n\r\n\x05\x04Y\
    \x02\x08\x05\x12\x04\x80\t\x11\x17\n\r\n\x05\x04Y\x02\x08\x01\x12\x04\
    \x80\t\x18(\n\r\n\x05\x04Y\x02\x08\x03\x12\x04\x80\t+,\n\x0c\n\x04\x04Y\
    \x02\t\x12\x04\x81\t\x08_\n\r\n\x05\x04Y\x02\t\x04\x12\x04\x81\t\x08\x10\
    \n\r\n\x05\x04Y\x02\t\x06\x12\x04\x81\t\x11H\n\r\n\x05\x04Y\x02\t\x01\
    \x12\x04\x81\tIY\n\r\n\x05\x04Y\x02\t\x03\x12\x04\x81\t\\^\n\x0c\n\x02\
    \x04Z\x12\x06\x84\t\0\x8b\t\x01\n\x0b\n\x03\x04Z\x01\x12\x04\x84\t\x08)\
    \n\x0c\n\x04\x04Z\x02\0\x12\x04\x85\t\x08%\n\r\n\x05\x04Z\x02\0\x04\x12\
    \x04\x85\t\x08\x10\n\r\n\x05\x04Z\x02\0\x05\x12\x04\x85\t\x11\x16\n\r\n\
    \x05\x04Z\x02\0\x01\x12\x04\x85\t\x17\x20\n\r\n\x05\x04Z\x02\0\x03\x12\
    \x04\x85\t#$\n\x0c\n\x04\x04Z\x02\x01\x12\x04\x86\t\x08.\n\r\n\x05\x04Z\
    \x02\x01\x04\x12\x04\x86\t\x08\x10\n\r\n\x05\x04Z\x02\x01\x05\x12\x04\
    \x86\t\x11\x16\n\r\n\x05\x04Z\x02\x01\x01\x12\x04\x86\t\x17)\n\r\n\x05\
    \x04Z\x02\x01\x03\x12\x04\x86\t,-\n\x0c\n\x04\x04Z\x02\x02\x12\x04\x87\t\
    \x08(\n\r\n\x05\x04Z\x02\x02\x04\x12\x04\x87\t\x08\x10\n\r\n\x05\x04Z\
    \x02\x02\x05\x12\x04\x87\t\x11\x16\n\r\n\x05\x04Z\x02\x02\x01\x12\x04\
    \x87\t\x17#\n\r\n\x05\x04Z\x02\x02\x03\x12\x04\x87\t&'\n\x0c\n\x04\x04Z\
    \x02\x03\x12\x04\x88\t\x08(\n\r\n\x05\x04Z\x02\x03\x04\x12\x04\x88\t\x08\
    \x10\n\r\n\x05\x04Z\x02\x03\x05\x12\x04\x88\t\x11\x16\n\r\n\x05\x04Z\x02\
    \x03\x01\x12\x04\x88\t\x17#\n\r\n\x05\x04Z\x02\x03\x03\x12\x04\x88\t&'\n\
    \x0c\n\x04\x04Z\x02\x04\x12\x04\x89\t\x08*\n\r\n\x05\x04Z\x02\x04\x04\
    \x12\x04\x89\t\x08\x10\n\r\n\x05\x04Z\x02\x04\x05\x12\x04\x89\t\x11\x16\
    \n\r\n\x05\x04Z\x02\x04\x01\x12\x04\x89\t\x17%\n\r\n\x05\x04Z\x02\x04\
    \x03\x12\x04\x89\t()\n\x0c\n\x04\x04Z\x02\x05\x12\x04\x8a\t\x08(\n\r\n\
    \x05\x04Z\x02\x05\x04\x12\x04\x8a\t\x08\x10\n\r\n\x05\x04Z\x02\x05\x05\
    \x12\x04\x8a\t\x11\x16\n\r\n\x05\x04Z\x02\x05\x01\x12\x04\x8a\t\x17#\n\r\
    \n\x05\x04Z\x02\x05\x03\x12\x04\x8a\t&'\n\x0c\n\x02\x04[\x12\x06\x8d\t\0\
    \x94\t\x01\n\x0b\n\x03\x04[\x01\x12\x04\x8d\t\x08%\n\x0c\n\x04\x04[\x02\
    \0\x12\x04\x8e\t\x08%\n\r\n\x05\x04[\x02\0\x04\x12\x04\x8e\t\x08\x10\n\r\
    \n\x05\x04[\x02\0\x05\x12\x04\x8e\t\x11\x16\n\r\n\x05\x04[\x02\0\x01\x12\
    \x04\x8e\t\x17\x20\n\r\n\x05\x04[\x02\0\x03\x12\x04\x8e\t#$\n\x0c\n\x04\
    \x04[\x02\x01\x12\x04\x8f\t\x08C\n\r\n\x05\x04[\x02\x01\x04\x12\x04\x8f\
    \t\x08\x10\n\r\n\x05\x04[\x02\x01\x06\x12\x04\x8f\t\x112\n\r\n\x05\x04[\
    \x02\x01\x01\x12\x04\x8f\t3>\n\r\n\x05\x04[\x02\x01\x03\x12\x04\x8f\tAB\
    \n\x0c\n\x04\x04[\x02\x02\x12\x04\x90\t\x08+\n\r\n\x05\x04[\x02\x02\x04\
    \x12\x04\x90\t\x08\x10\n\r\n\x05\x04[\x02\x02\x05\x12\x04\x90\t\x11\x17\
    \n\r\n\x05\x04[\x02\x02\x01\x12\x04\x90\t\x18&\n\r\n\x05\x04[\x02\x02\
    \x03\x12\x04\x90\t)*\n\x0c\n\x04\x04[\x02\x03\x12\x04\x91\t\x08-\n\r\n\
    \x05\x04[\x02\x03\x04\x12\x04\x91\t\x08\x10\n\r\n\x05\x04[\x02\x03\x05\
    \x12\x04\x91\t\x11\x17\n\r\n\x05\x04[\x02\x03\x01\x12\x04\x91\t\x18(\n\r\
    \n\x05\x04[\x02\x03\x03\x12\x04\x91\t+,\n\x0c\n\x04\x04[\x02\x04\x12\x04\
    \x92\t\x08&\n\r\n\x05\x04[\x02\x04\x04\x12\x04\x92\t\x08\x10\n\r\n\x05\
    \x04[\x02\x04\x05\x12\x04\x92\t\x11\x16\n\r\n\x05\x04[\x02\x04\x01\x12\
    \x04\x92\t\x17!\n\r\n\x05\x04[\x02\x04\x03\x12\x04\x92\t$%\n\x0c\n\x04\
    \x04[\x02\x05\x12\x04\x93\t\x08%\n\r\n\x05\x04[\x02\x05\x04\x12\x04\x93\
    \t\x08\x10\n\r\n\x05\x04[\x02\x05\x05\x12\x04\x93\t\x11\x16\n\r\n\x05\
    \x04[\x02\x05\x01\x12\x04\x93\t\x17\x20\n\r\n\x05\x04[\x02\x05\x03\x12\
    \x04\x93\t#$\n\x0c\n\x02\x04\\\x12\x06\x96\t\0\xab\t\x01\n\x0b\n\x03\x04\
    \\\x01\x12\x04\x96\t\x08&\n\x0e\n\x04\x04\\\x03\0\x12\x06\x97\t\x08\x9c\
    \t\t\n\r\n\x05\x04\\\x03\0\x01\x12\x04\x97\t\x102\n\x0e\n\x06\x04\\\x03\
    \0\x02\0\x12\x04\x98\t\x100\n\x0f\n\x07\x04\\\x03\0\x02\0\x04\x12\x04\
    \x98\t\x10\x18\n\x0f\n\x07\x04\\\x03\0\x02\0\x05\x12\x04\x98\t\x19\x1e\n\
    \x0f\n\x07\x04\\\x03\0\x02\0\x01\x12\x04\x98\t\x1f+\n\x0f\n\x07\x04\\\
    \x03\0\x02\0\x03\x12\x04\x98\t./\n\x0e\n\x06\x04\\\x03\0\x02\x01\x12\x04\
    \x99\t\x10*\n\x0f\n\x07\x04\\\x03\0\x02\x01\x04\x12\x04\x99\t\x10\x18\n\
    \x0f\n\x07\x04\\\x03\0\x02\x01\x05\x12\x04\x99\t\x19\x1e\n\x0f\n\x07\x04\
    \\\x03\0\x02\x01\x01\x12\x04\x99\t\x1f%\n\x0f\n\x07\x04\\\x03\0\x02\x01\
    \x03\x12\x04\x99\t()\n\x0e\n\x06\x04\\\x03\0\x02\x02\x12\x04\x9a\t\x10/\
    \n\x0f\n\x07\x04\\\x03\0\x02\x02\x04\x12\x04\x9a\t\x10\x18\n\x0f\n\x07\
    \x04\\\x03\0\x02\x02\x05\x12\x04\x9a\t\x19\x1f\n\x0f\n\x07\x04\\\x03\0\
    \x02\x02\x01\x12\x04\x9a\t\x20*\n\x0f\n\x07\x04\\\x03\0\x02\x02\x03\x12\
    \x04\x9a\t-.\n\x0e\n\x06\x04\\\x03\0\x02\x03\x12\x04\x9b\t\x10-\n\x0f\n\
    \x07\x04\\\x03\0\x02\x03\x04\x12\x04\x9b\t\x10\x18\n\x0f\n\x07\x04\\\x03\
    \0\x02\x03\x05\x12\x04\x9b\t\x19\x1f\n\x0f\n\x07\x04\\\x03\0\x02\x03\x01\
    \x12\x04\x9b\t\x20(\n\x0f\n\x07\x04\\\x03\0\x02\x03\x03\x12\x04\x9b\t+,\
    \n\x0e\n\x04\x04\\\x03\x01\x12\x06\x9e\t\x08\xa3\t\t\n\r\n\x05\x04\\\x03\
    \x01\x01\x12\x04\x9e\t\x10.\n\x0e\n\x06\x04\\\x03\x01\x02\0\x12\x04\x9f\
    \t\x10.\n\x0f\n\x07\x04\\\x03\x01\x02\0\x04\x12\x04\x9f\t\x10\x18\n\x0f\
    \n\x07\x04\\\x03\x01\x02\0\x05\x12\x04\x9f\t\x19\x1e\n\x0f\n\x07\x04\\\
    \x03\x01\x02\0\x01\x12\x04\x9f\t\x1f)\n\x0f\n\x07\x04\\\x03\x01\x02\0\
    \x03\x12\x04\x9f\t,-\n\x0e\n\x06\x04\\\x03\x01\x02\x01\x12\x04\xa0\t\x10\
    ,\n\x0f\n\x07\x04\\\x03\x01\x02\x01\x04\x12\x04\xa0\t\x10\x18\n\x0f\n\
    \x07\x04\\\x03\x01\x02\x01\x05\x12\x04\xa0\t\x19\x1e\n\x0f\n\x07\x04\\\
    \x03\x01\x02\x01\x01\x12\x04\xa0\t\x1f'\n\x0f\n\x07\x04\\\x03\x01\x02\
    \x01\x03\x12\x04\xa0\t*+\n\x0e\n\x06\x04\\\x03\x01\x02\x02\x12\x04\xa1\t\
    \x10u\n\x0f\n\x07\x04\\\x03\x01\x02\x02\x04\x12\x04\xa1\t\x10\x18\n\x0f\
    \n\x07\x04\\\x03\x01\x02\x02\x06\x12\x04\xa1\t\x19Z\n\x0f\n\x07\x04\\\
    \x03\x01\x02\x02\x01\x12\x04\xa1\t[p\n\x0f\n\x07\x04\\\x03\x01\x02\x02\
    \x03\x12\x04\xa1\tst\n\x0e\n\x06\x04\\\x03\x01\x02\x03\x12\x04\xa2\t\x10\
    r\n\x0f\n\x07\x04\\\x03\x01\x02\x03\x04\x12\x04\xa2\t\x10\x18\n\x0f\n\
    \x07\x04\\\x03\x01\x02\x03\x06\x12\x04\xa2\t\x19Z\n\x0f\n\x07\x04\\\x03\
    \x01\x02\x03\x01\x12\x04\xa2\t[m\n\x0f\n\x07\x04\\\x03\x01\x02\x03\x03\
    \x12\x04\xa2\tpq\n\x0c\n\x04\x04\\\x02\0\x12\x04\xa5\t\x08>\n\r\n\x05\
    \x04\\\x02\0\x04\x12\x04\xa5\t\x08\x10\n\r\n\x05\x04\\\x02\0\x06\x12\x04\
    \xa5\t\x11-\n\r\n\x05\x04\\\x02\0\x01\x12\x04\xa5\t.9\n\r\n\x05\x04\\\
    \x02\0\x03\x12\x04\xa5\t<=\n\x0c\n\x04\x04\\\x02\x01\x12\x04\xa6\t\x08G\
    \n\r\n\x05\x04\\\x02\x01\x04\x12\x04\xa6\t\x08\x10\n\r\n\x05\x04\\\x02\
    \x01\x06\x12\x04\xa6\t\x114\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\xa6\t5B\
    \n\r\n\x05\x04\\\x02\x01\x03\x12\x04\xa6\tEF\n\x0c\n\x04\x04\\\x02\x02\
    \x12\x04\xa7\t\x08D\n\r\n\x05\x04\\\x02\x02\x04\x12\x04\xa7\t\x08\x10\n\
    \r\n\x05\x04\\\x02\x02\x06\x12\x04\xa7\t\x114\n\r\n\x05\x04\\\x02\x02\
    \x01\x12\x04\xa7\t5?\n\r\n\x05\x04\\\x02\x02\x03\x12\x04\xa7\tBC\n\x0c\n\
    \x04\x04\\\x02\x03\x12\x04\xa8\t\x08A\n\r\n\x05\x04\\\x02\x03\x04\x12\
    \x04\xa8\t\x08\x10\n\r\n\x05\x04\\\x02\x03\x06\x12\x04\xa8\t\x11.\n\r\n\
    \x05\x04\\\x02\x03\x01\x12\x04\xa8\t/<\n\r\n\x05\x04\\\x02\x03\x03\x12\
    \x04\xa8\t?@\n\x0c\n\x04\x04\\\x02\x04\x12\x04\xa9\t\x08>\n\r\n\x05\x04\
    \\\x02\x04\x04\x12\x04\xa9\t\x08\x10\n\r\n\x05\x04\\\x02\x04\x06\x12\x04\
    \xa9\t\x11.\n\r\n\x05\x04\\\x02\x04\x01\x12\x04\xa9\t/9\n\r\n\x05\x04\\\
    \x02\x04\x03\x12\x04\xa9\t<=\n\x0c\n\x04\x04\\\x02\x05\x12\x04\xaa\t\x08\
    a\n\r\n\x05\x04\\\x02\x05\x04\x12\x04\xaa\t\x08\x10\n\r\n\x05\x04\\\x02\
    \x05\x06\x12\x04\xaa\t\x11N\n\r\n\x05\x04\\\x02\x05\x01\x12\x04\xaa\tO\\\
    \n\r\n\x05\x04\\\x02\x05\x03\x12\x04\xaa\t_`\n\x0c\n\x02\x04]\x12\x06\
    \xad\t\0\xaf\t\x01\n\x0b\n\x03\x04]\x01\x12\x04\xad\t\x08\x1e\n\x0c\n\
    \x04\x04]\x02\0\x12\x04\xae\t\x08.\n\r\n\x05\x04]\x02\0\x04\x12\x04\xae\
    \t\x08\x10\n\r\n\x05\x04]\x02\0\x05\x12\x04\xae\t\x11\x16\n\r\n\x05\x04]\
    \x02\0\x01\x12\x04\xae\t\x17)\n\r\n\x05\x04]\x02\0\x03\x12\x04\xae\t,-\n\
    \x0c\n\x02\x04^\x12\x06\xb1\t\0\xb3\t\x01\n\x0b\n\x03\x04^\x01\x12\x04\
    \xb1\t\x08!\n\x0c\n\x04\x04^\x02\0\x12\x04\xb2\t\x08&\n\r\n\x05\x04^\x02\
    \0\x04\x12\x04\xb2\t\x08\x10\n\r\n\x05\x04^\x02\0\x05\x12\x04\xb2\t\x11\
    \x15\n\r\n\x05\x04^\x02\0\x01\x12\x04\xb2\t\x16!\n\r\n\x05\x04^\x02\0\
    \x03\x12\x04\xb2\t$%\n\x0c\n\x02\x04_\x12\x06\xb5\t\0\xba\t\x01\n\x0b\n\
    \x03\x04_\x01\x12\x04\xb5\t\x08(\n\x0c\n\x04\x04_\x02\0\x12\x04\xb6\t\
    \x08%\n\r\n\x05\x04_\x02\0\x04\x12\x04\xb6\t\x08\x10\n\r\n\x05\x04_\x02\
    \0\x05\x12\x04\xb6\t\x11\x16\n\r\n\x05\x04_\x02\0\x01\x12\x04\xb6\t\x17\
    \x20\n\r\n\x05\x04_\x02\0\x03\x12\x04\xb6\t#$\n\x0c\n\x04\x04_\x02\x01\
    \x12\x04\xb7\t\x08$\n\r\n\x05\x04_\x02\x01\x04\x12\x04\xb7\t\x08\x10\n\r\
    \n\x05\x04_\x02\x01\x05\x12\x04\xb7\t\x11\x16\n\r\n\x05\x04_\x02\x01\x01\
    \x12\x04\xb7\t\x17\x1f\n\r\n\x05\x04_\x02\x01\x03\x12\x04\xb7\t\"#\n\x0c\
    \n\x04\x04_\x02\x02\x12\x04\xb8\t\x08$\n\r\n\x05\x04_\x02\x02\x04\x12\
    \x04\xb8\t\x08\x10\n\r\n\x05\x04_\x02\x02\x05\x12\x04\xb8\t\x11\x17\n\r\
    \n\x05\x04_\x02\x02\x01\x12\x04\xb8\t\x18\x1f\n\r\n\x05\x04_\x02\x02\x03\
    \x12\x04\xb8\t\"#\n\x0c\n\x04\x04_\x02\x03\x12\x04\xb9\t\x08!\n\r\n\x05\
    \x04_\x02\x03\x04\x12\x04\xb9\t\x08\x10\n\r\n\x05\x04_\x02\x03\x05\x12\
    \x04\xb9\t\x11\x16\n\r\n\x05\x04_\x02\x03\x01\x12\x04\xb9\t\x17\x1c\n\r\
    \n\x05\x04_\x02\x03\x03\x12\x04\xb9\t\x1f\x20\n\x0c\n\x02\x04`\x12\x06\
    \xbc\t\0\xc0\t\x01\n\x0b\n\x03\x04`\x01\x12\x04\xbc\t\x08\x1b\n\x0c\n\
    \x04\x04`\x02\0\x12\x04\xbd\t\x08-\n\r\n\x05\x04`\x02\0\x04\x12\x04\xbd\
    \t\x08\x10\n\r\n\x05\x04`\x02\0\x06\x12\x04\xbd\t\x11\x1e\n\r\n\x05\x04`\
    \x02\0\x01\x12\x04\xbd\t\x1f(\n\r\n\x05\x04`\x02\0\x03\x12\x04\xbd\t+,\n\
    \x0c\n\x04\x04`\x02\x01\x12\x04\xbe\t\x08%\n\r\n\x05\x04`\x02\x01\x04\
    \x12\x04\xbe\t\x08\x10\n\r\n\x05\x04`\x02\x01\x05\x12\x04\xbe\t\x11\x16\
    \n\r\n\x05\x04`\x02\x01\x01\x12\x04\xbe\t\x17\x20\n\r\n\x05\x04`\x02\x01\
    \x03\x12\x04\xbe\t#$\n\x0c\n\x04\x04`\x02\x02\x12\x04\xbf\t\x08'\n\r\n\
    \x05\x04`\x02\x02\x04\x12\x04\xbf\t\x08\x10\n\r\n\x05\x04`\x02\x02\x05\
    \x12\x04\xbf\t\x11\x16\n\r\n\x05\x04`\x02\x02\x01\x12\x04\xbf\t\x17\"\n\
    \r\n\x05\x04`\x02\x02\x03\x12\x04\xbf\t%&\n\x0c\n\x02\x04a\x12\x06\xc2\t\
    \0\xc5\t\x01\n\x0b\n\x03\x04a\x01\x12\x04\xc2\t\x08$\n\x0c\n\x04\x04a\
    \x02\0\x12\x04\xc3\t\x08'\n\r\n\x05\x04a\x02\0\x04\x12\x04\xc3\t\x08\x10\
    \n\r\n\x05\x04a\x02\0\x05\x12\x04\xc3\t\x11\x17\n\r\n\x05\x04a\x02\0\x01\
    \x12\x04\xc3\t\x18\"\n\r\n\x05\x04a\x02\0\x03\x12\x04\xc3\t%&\n\x0c\n\
    \x04\x04a\x02\x01\x12\x04\xc4\t\x08<\n\r\n\x05\x04a\x02\x01\x04\x12\x04\
    \xc4\t\x08\x10\n\r\n\x05\x04a\x02\x01\x06\x12\x04\xc4\t\x11$\n\r\n\x05\
    \x04a\x02\x01\x01\x12\x04\xc4\t%7\n\r\n\x05\x04a\x02\x01\x03\x12\x04\xc4\
    \t:;\n\x0c\n\x02\x04b\x12\x06\xc7\t\0\xca\t\x01\n\x0b\n\x03\x04b\x01\x12\
    \x04\xc7\t\x08\x1f\n\x0c\n\x04\x04b\x02\0\x12\x04\xc8\t\x08%\n\r\n\x05\
    \x04b\x02\0\x04\x12\x04\xc8\t\x08\x10\n\r\n\x05\x04b\x02\0\x05\x12\x04\
    \xc8\t\x11\x17\n\r\n\x05\x04b\x02\0\x01\x12\x04\xc8\t\x18\x20\n\r\n\x05\
    \x04b\x02\0\x03\x12\x04\xc8\t#$\n\x0c\n\x04\x04b\x02\x01\x12\x04\xc9\t\
    \x08?\n\r\n\x05\x04b\x02\x01\x04\x12\x04\xc9\t\x08\x10\n\r\n\x05\x04b\
    \x02\x01\x06\x12\x04\xc9\t\x11-\n\r\n\x05\x04b\x02\x01\x01\x12\x04\xc9\t\
    .:\n\r\n\x05\x04b\x02\x01\x03\x12\x04\xc9\t=>\n\x0c\n\x02\x04c\x12\x06\
    \xcc\t\0\xd1\t\x01\n\x0b\n\x03\x04c\x01\x12\x04\xcc\t\x08\x1e\n\x0c\n\
    \x04\x04c\x02\0\x12\x04\xcd\t\x08!\n\r\n\x05\x04c\x02\0\x04\x12\x04\xcd\
    \t\x08\x10\n\r\n\x05\x04c\x02\0\x05\x12\x04\xcd\t\x11\x17\n\r\n\x05\x04c\
    \x02\0\x01\x12\x04\xcd\t\x18\x1c\n\r\n\x05\x04c\x02\0\x03\x12\x04\xcd\t\
    \x1f\x20\n\x0c\n\x04\x04c\x02\x01\x12\x04\xce\t\x08#\n\r\n\x05\x04c\x02\
    \x01\x04\x12\x04\xce\t\x08\x10\n\r\n\x05\x04c\x02\x01\x05\x12\x04\xce\t\
    \x11\x17\n\r\n\x05\x04c\x02\x01\x01\x12\x04\xce\t\x18\x1e\n\r\n\x05\x04c\
    \x02\x01\x03\x12\x04\xce\t!\"\n\x0c\n\x04\x04c\x02\x02\x12\x04\xcf\t\x08\
    $\n\r\n\x05\x04c\x02\x02\x04\x12\x04\xcf\t\x08\x10\n\r\n\x05\x04c\x02\
    \x02\x05\x12\x04\xcf\t\x11\x17\n\r\n\x05\x04c\x02\x02\x01\x12\x04\xcf\t\
    \x18\x1f\n\r\n\x05\x04c\x02\x02\x03\x12\x04\xcf\t\"#\n\x0c\n\x04\x04c\
    \x02\x03\x12\x04\xd0\t\x08#\n\r\n\x05\x04c\x02\x03\x04\x12\x04\xd0\t\x08\
    \x10\n\r\n\x05\x04c\x02\x03\x05\x12\x04\xd0\t\x11\x17\n\r\n\x05\x04c\x02\
    \x03\x01\x12\x04\xd0\t\x18\x1e\n\r\n\x05\x04c\x02\x03\x03\x12\x04\xd0\t!\
    \"\n\x0c\n\x02\x04d\x12\x06\xd3\t\0\xd7\t\x01\n\x0b\n\x03\x04d\x01\x12\
    \x04\xd3\t\x08,\n\x0c\n\x04\x04d\x02\0\x12\x04\xd4\t\x08'\n\r\n\x05\x04d\
    \x02\0\x04\x12\x04\xd4\t\x08\x10\n\r\n\x05\x04d\x02\0\x05\x12\x04\xd4\t\
    \x11\x17\n\r\n\x05\x04d\x02\0\x01\x12\x04\xd4\t\x18\"\n\r\n\x05\x04d\x02\
    \0\x03\x12\x04\xd4\t%&\n\x0c\n\x04\x04d\x02\x01\x12\x04\xd5\t\x08,\n\r\n\
    \x05\x04d\x02\x01\x04\x12\x04\xd5\t\x08\x10\n\r\n\x05\x04d\x02\x01\x05\
    \x12\x04\xd5\t\x11\x17\n\r\n\x05\x04d\x02\x01\x01\x12\x04\xd5\t\x18'\n\r\
    \n\x05\x04d\x02\x01\x03\x12\x04\xd5\t*+\n\x0c\n\x04\x04d\x02\x02\x12\x04\
    \xd6\t\x08\x20\n\r\n\x05\x04d\x02\x02\x04\x12\x04\xd6\t\x08\x10\n\r\n\
    \x05\x04d\x02\x02\x05\x12\x04\xd6\t\x11\x16\n\r\n\x05\x04d\x02\x02\x01\
    \x12\x04\xd6\t\x17\x1b\n\r\n\x05\x04d\x02\x02\x03\x12\x04\xd6\t\x1e\x1f\
    \n\x0c\n\x02\x04e\x12\x06\xd9\t\0\xdd\t\x01\n\x0b\n\x03\x04e\x01\x12\x04\
    \xd9\t\x08,\n\x0c\n\x04\x04e\x02\0\x12\x04\xda\t\x08'\n\r\n\x05\x04e\x02\
    \0\x04\x12\x04\xda\t\x08\x10\n\r\n\x05\x04e\x02\0\x05\x12\x04\xda\t\x11\
    \x17\n\r\n\x05\x04e\x02\0\x01\x12\x04\xda\t\x18\"\n\r\n\x05\x04e\x02\0\
    \x03\x12\x04\xda\t%&\n\x0c\n\x04\x04e\x02\x01\x12\x04\xdb\t\x08)\n\r\n\
    \x05\x04e\x02\x01\x04\x12\x04\xdb\t\x08\x10\n\r\n\x05\x04e\x02\x01\x05\
    \x12\x04\xdb\t\x11\x15\n\r\n\x05\x04e\x02\x01\x01\x12\x04\xdb\t\x16$\n\r\
    \n\x05\x04e\x02\x01\x03\x12\x04\xdb\t'(\n\x0c\n\x04\x04e\x02\x02\x12\x04\
    \xdc\t\x08\x20\n\r\n\x05\x04e\x02\x02\x04\x12\x04\xdc\t\x08\x10\n\r\n\
    \x05\x04e\x02\x02\x05\x12\x04\xdc\t\x11\x16\n\r\n\x05\x04e\x02\x02\x01\
    \x12\x04\xdc\t\x17\x1b\n\r\n\x05\x04e\x02\x02\x03\x12\x04\xdc\t\x1e\x1f\
    \n\x0c\n\x02\x04f\x12\x06\xdf\t\0\xe1\t\x01\n\x0b\n\x03\x04f\x01\x12\x04\
    \xdf\t\x08-\n\x0c\n\x04\x04f\x02\0\x12\x04\xe0\t\x08'\n\r\n\x05\x04f\x02\
    \0\x04\x12\x04\xe0\t\x08\x10\n\r\n\x05\x04f\x02\0\x05\x12\x04\xe0\t\x11\
    \x17\n\r\n\x05\x04f\x02\0\x01\x12\x04\xe0\t\x18\"\n\r\n\x05\x04f\x02\0\
    \x03\x12\x04\xe0\t%&\n\x0c\n\x02\x04g\x12\x06\xe3\t\0\xe6\t\x01\n\x0b\n\
    \x03\x04g\x01\x12\x04\xe3\t\x08*\n\x0c\n\x04\x04g\x02\0\x12\x04\xe4\t\
    \x08%\n\r\n\x05\x04g\x02\0\x04\x12\x04\xe4\t\x08\x10\n\r\n\x05\x04g\x02\
    \0\x05\x12\x04\xe4\t\x11\x16\n\r\n\x05\x04g\x02\0\x01\x12\x04\xe4\t\x17\
    \x20\n\r\n\x05\x04g\x02\0\x03\x12\x04\xe4\t#$\n\x0c\n\x04\x04g\x02\x01\
    \x12\x04\xe5\t\x08\"\n\r\n\x05\x04g\x02\x01\x04\x12\x04\xe5\t\x08\x10\n\
    \r\n\x05\x04g\x02\x01\x05\x12\x04\xe5\t\x11\x17\n\r\n\x05\x04g\x02\x01\
    \x01\x12\x04\xe5\t\x18\x1d\n\r\n\x05\x04g\x02\x01\x03\x12\x04\xe5\t\x20!\
    \n\x0c\n\x02\x04h\x12\x06\xe8\t\0\xea\t\x01\n\x0b\n\x03\x04h\x01\x12\x04\
    \xe8\t\x08$\n\x0c\n\x04\x04h\x02\0\x12\x04\xe9\t\x08K\n\r\n\x05\x04h\x02\
    \0\x04\x12\x04\xe9\t\x08\x10\n\r\n\x05\x04h\x02\0\x06\x12\x04\xe9\t\x113\
    \n\r\n\x05\x04h\x02\0\x01\x12\x04\xe9\t4F\n\r\n\x05\x04h\x02\0\x03\x12\
    \x04\xe9\tIJ\n\x0c\n\x02\x04i\x12\x06\xec\t\0\xf5\t\x01\n\x0b\n\x03\x04i\
    \x01\x12\x04\xec\t\x08&\n\x0c\n\x04\x04i\x02\0\x12\x04\xed\t\x08&\n\r\n\
    \x05\x04i\x02\0\x04\x12\x04\xed\t\x08\x10\n\r\n\x05\x04i\x02\0\x05\x12\
    \x04\xed\t\x11\x16\n\r\n\x05\x04i\x02\0\x01\x12\x04\xed\t\x17!\n\r\n\x05\
    \x04i\x02\0\x03\x12\x04\xed\t$%\n\x0c\n\x04\x04i\x02\x01\x12\x04\xee\t\
    \x08,\n\r\n\x05\x04i\x02\x01\x04\x12\x04\xee\t\x08\x10\n\r\n\x05\x04i\
    \x02\x01\x05\x12\x04\xee\t\x11\x16\n\r\n\x05\x04i\x02\x01\x01\x12\x04\
    \xee\t\x17'\n\r\n\x05\x04i\x02\x01\x03\x12\x04\xee\t*+\n\x0c\n\x04\x04i\
    \x02\x02\x12\x04\xef\t\x08'\n\r\n\x05\x04i\x02\x02\x04\x12\x04\xef\t\x08\
    \x10\n\r\n\x05\x04i\x02\x02\x05\x12\x04\xef\t\x11\x16\n\r\n\x05\x04i\x02\
    \x02\x01\x12\x04\xef\t\x17\"\n\r\n\x05\x04i\x02\x02\x03\x12\x04\xef\t%&\
    \n\x0c\n\x04\x04i\x02\x03\x12\x04\xf0\t\x08&\n\r\n\x05\x04i\x02\x03\x04\
    \x12\x04\xf0\t\x08\x10\n\r\n\x05\x04i\x02\x03\x05\x12\x04\xf0\t\x11\x15\
    \n\r\n\x05\x04i\x02\x03\x01\x12\x04\xf0\t\x16!\n\r\n\x05\x04i\x02\x03\
    \x03\x12\x04\xf0\t$%\n\x0c\n\x04\x04i\x02\x04\x12\x04\xf1\t\x08'\n\r\n\
    \x05\x04i\x02\x04\x04\x12\x04\xf1\t\x08\x10\n\r\n\x05\x04i\x02\x04\x06\
    \x12\x04\xf1\t\x11\x1b\n\r\n\x05\x04i\x02\x04\x01\x12\x04\xf1\t\x1c\"\n\
    \r\n\x05\x04i\x02\x04\x03\x12\x04\xf1\t%&\n\x0c\n\x04\x04i\x02\x05\x12\
    \x04\xf2\t\x08,\n\r\n\x05\x04i\x02\x05\x04\x12\x04\xf2\t\x08\x10\n\r\n\
    \x05\x04i\x02\x05\x05\x12\x04\xf2\t\x11\x15\n\r\n\x05\x04i\x02\x05\x01\
    \x12\x04\xf2\t\x16'\n\r\n\x05\x04i\x02\x05\x03\x12\x04\xf2\t*+\n\x0c\n\
    \x04\x04i\x02\x06\x12\x04\xf3\t\x08$\n\r\n\x05\x04i\x02\x06\x04\x12\x04\
    \xf3\t\x08\x10\n\r\n\x05\x04i\x02\x06\x05\x12\x04\xf3\t\x11\x16\n\r\n\
    \x05\x04i\x02\x06\x01\x12\x04\xf3\t\x17\x1f\n\r\n\x05\x04i\x02\x06\x03\
    \x12\x04\xf3\t\"#\n\x0c\n\x04\x04i\x02\x07\x12\x04\xf4\t\x08,\n\r\n\x05\
    \x04i\x02\x07\x04\x12\x04\xf4\t\x08\x10\n\r\n\x05\x04i\x02\x07\x05\x12\
    \x04\xf4\t\x11\x16\n\r\n\x05\x04i\x02\x07\x01\x12\x04\xf4\t\x17'\n\r\n\
    \x05\x04i\x02\x07\x03\x12\x04\xf4\t*+\n\x0c\n\x02\x04j\x12\x06\xf7\t\0\
    \xfa\t\x01\n\x0b\n\x03\x04j\x01\x12\x04\xf7\t\x08$\n\x0c\n\x04\x04j\x02\
    \0\x12\x04\xf8\t\x08/\n\r\n\x05\x04j\x02\0\x04\x12\x04\xf8\t\x08\x10\n\r\
    \n\x05\x04j\x02\0\x06\x12\x04\xf8\t\x11!\n\r\n\x05\x04j\x02\0\x01\x12\
    \x04\xf8\t\"*\n\r\n\x05\x04j\x02\0\x03\x12\x04\xf8\t-.\n\x0c\n\x04\x04j\
    \x02\x01\x12\x04\xf9\t\x08!\n\r\n\x05\x04j\x02\x01\x04\x12\x04\xf9\t\x08\
    \x10\n\r\n\x05\x04j\x02\x01\x05\x12\x04\xf9\t\x11\x17\n\r\n\x05\x04j\x02\
    \x01\x01\x12\x04\xf9\t\x18\x1c\n\r\n\x05\x04j\x02\x01\x03\x12\x04\xf9\t\
    \x1f\x20\n\x0c\n\x02\x04k\x12\x06\xfc\t\0\xff\t\x01\n\x0b\n\x03\x04k\x01\
    \x12\x04\xfc\t\x08\x1c\n\x0c\n\x04\x04k\x02\0\x12\x04\xfd\t\x08%\n\r\n\
    \x05\x04k\x02\0\x04\x12\x04\xfd\t\x08\x10\n\r\n\x05\x04k\x02\0\x05\x12\
    \x04\xfd\t\x11\x16\n\r\n\x05\x04k\x02\0\x01\x12\x04\xfd\t\x17\x20\n\r\n\
    \x05\x04k\x02\0\x03\x12\x04\xfd\t#$\n\x0c\n\x04\x04k\x02\x01\x12\x04\xfe\
    \t\x08+\n\r\n\x05\x04k\x02\x01\x04\x12\x04\xfe\t\x08\x10\n\r\n\x05\x04k\
    \x02\x01\x05\x12\x04\xfe\t\x11\x16\n\r\n\x05\x04k\x02\x01\x01\x12\x04\
    \xfe\t\x17&\n\r\n\x05\x04k\x02\x01\x03\x12\x04\xfe\t)*\n\x0c\n\x02\x04l\
    \x12\x06\x81\n\0\x87\n\x01\n\x0b\n\x03\x04l\x01\x12\x04\x81\n\x08$\n\x0c\
    \n\x04\x04l\x02\0\x12\x04\x82\n\x08%\n\r\n\x05\x04l\x02\0\x04\x12\x04\
    \x82\n\x08\x10\n\r\n\x05\x04l\x02\0\x05\x12\x04\x82\n\x11\x16\n\r\n\x05\
    \x04l\x02\0\x01\x12\x04\x82\n\x17\x20\n\r\n\x05\x04l\x02\0\x03\x12\x04\
    \x82\n#$\n\x0c\n\x04\x04l\x02\x01\x12\x04\x83\n\x08+\n\r\n\x05\x04l\x02\
    \x01\x04\x12\x04\x83\n\x08\x10\n\r\n\x05\x04l\x02\x01\x05\x12\x04\x83\n\
    \x11\x16\n\r\n\x05\x04l\x02\x01\x01\x12\x04\x83\n\x17&\n\r\n\x05\x04l\
    \x02\x01\x03\x12\x04\x83\n)*\n\x0c\n\x04\x04l\x02\x02\x12\x04\x84\n\x08&\
    \n\r\n\x05\x04l\x02\x02\x04\x12\x04\x84\n\x08\x10\n\r\n\x05\x04l\x02\x02\
    \x05\x12\x04\x84\n\x11\x16\n\r\n\x05\x04l\x02\x02\x01\x12\x04\x84\n\x17!\
    \n\r\n\x05\x04l\x02\x02\x03\x12\x04\x84\n$%\n\x0c\n\x04\x04l\x02\x03\x12\
    \x04\x85\n\x08\x20\n\r\n\x05\x04l\x02\x03\x04\x12\x04\x85\n\x08\x10\n\r\
    \n\x05\x04l\x02\x03\x05\x12\x04\x85\n\x11\x16\n\r\n\x05\x04l\x02\x03\x01\
    \x12\x04\x85\n\x17\x1b\n\r\n\x05\x04l\x02\x03\x03\x12\x04\x85\n\x1e\x1f\
    \n\x0c\n\x04\x04l\x02\x04\x12\x04\x86\n\x08\"\n\r\n\x05\x04l\x02\x04\x04\
    \x12\x04\x86\n\x08\x10\n\r\n\x05\x04l\x02\x04\x05\x12\x04\x86\n\x11\x15\
    \n\r\n\x05\x04l\x02\x04\x01\x12\x04\x86\n\x16\x1d\n\r\n\x05\x04l\x02\x04\
    \x03\x12\x04\x86\n\x20!\n\x0c\n\x02\x04m\x12\x06\x89\n\0\x8a\n\x01\n\x0b\
    \n\x03\x04m\x01\x12\x04\x89\n\x08(\n\x0c\n\x02\x04n\x12\x06\x8c\n\0\x95\
    \n\x01\n\x0b\n\x03\x04n\x01\x12\x04\x8c\n\x08\x20\n\x0c\n\x04\x04n\x02\0\
    \x12\x04\x8d\n\x08%\n\r\n\x05\x04n\x02\0\x04\x12\x04\x8d\n\x08\x10\n\r\n\
    \x05\x04n\x02\0\x05\x12\x04\x8d\n\x11\x16\n\r\n\x05\x04n\x02\0\x01\x12\
    \x04\x8d\n\x17\x20\n\r\n\x05\x04n\x02\0\x03\x12\x04\x8d\n#$\n\x0c\n\x04\
    \x04n\x02\x01\x12\x04\x8e\n\x08%\n\r\n\x05\x04n\x02\x01\x04\x12\x04\x8e\
    \n\x08\x10\n\r\n\x05\x04n\x02\x01\x05\x12\x04\x8e\n\x11\x17\n\r\n\x05\
    \x04n\x02\x01\x01\x12\x04\x8e\n\x18\x20\n\r\n\x05\x04n\x02\x01\x03\x12\
    \x04\x8e\n#$\n\x0c\n\x04\x04n\x02\x02\x12\x04\x8f\n\x08)\n\r\n\x05\x04n\
    \x02\x02\x04\x12\x04\x8f\n\x08\x10\n\r\n\x05\x04n\x02\x02\x05\x12\x04\
    \x8f\n\x11\x17\n\r\n\x05\x04n\x02\x02\x01\x12\x04\x8f\n\x18$\n\r\n\x05\
    \x04n\x02\x02\x03\x12\x04\x8f\n'(\n\x0c\n\x04\x04n\x02\x03\x12\x04\x90\n\
    \x08%\n\r\n\x05\x04n\x02\x03\x04\x12\x04\x90\n\x08\x10\n\r\n\x05\x04n\
    \x02\x03\x05\x12\x04\x90\n\x11\x17\n\r\n\x05\x04n\x02\x03\x01\x12\x04\
    \x90\n\x18\x20\n\r\n\x05\x04n\x02\x03\x03\x12\x04\x90\n#$\n\x0c\n\x04\
    \x04n\x02\x04\x12\x04\x91\n\x08!\n\r\n\x05\x04n\x02\x04\x04\x12\x04\x91\
    \n\x08\x10\n\r\n\x05\x04n\x02\x04\x05\x12\x04\x91\n\x11\x17\n\r\n\x05\
    \x04n\x02\x04\x01\x12\x04\x91\n\x18\x1c\n\r\n\x05\x04n\x02\x04\x03\x12\
    \x04\x91\n\x1f\x20\n\x0c\n\x04\x04n\x02\x05\x12\x04\x92\n\x08\"\n\r\n\
    \x05\x04n\x02\x05\x04\x12\x04\x92\n\x08\x10\n\r\n\x05\x04n\x02\x05\x05\
    \x12\x04\x92\n\x11\x17\n\r\n\x05\x04n\x02\x05\x01\x12\x04\x92\n\x18\x1d\
    \n\r\n\x05\x04n\x02\x05\x03\x12\x04\x92\n\x20!\n\x0c\n\x04\x04n\x02\x06\
    \x12\x04\x93\n\x08)\n\r\n\x05\x04n\x02\x06\x04\x12\x04\x93\n\x08\x10\n\r\
    \n\x05\x04n\x02\x06\x05\x12\x04\x93\n\x11\x16\n\r\n\x05\x04n\x02\x06\x01\
    \x12\x04\x93\n\x17$\n\r\n\x05\x04n\x02\x06\x03\x12\x04\x93\n'(\n\x0c\n\
    \x04\x04n\x02\x07\x12\x04\x94\n\x08+\n\r\n\x05\x04n\x02\x07\x04\x12\x04\
    \x94\n\x08\x10\n\r\n\x05\x04n\x02\x07\x05\x12\x04\x94\n\x11\x16\n\r\n\
    \x05\x04n\x02\x07\x01\x12\x04\x94\n\x17&\n\r\n\x05\x04n\x02\x07\x03\x12\
    \x04\x94\n)*\n\x0c\n\x02\x04o\x12\x06\x97\n\0\x9b\n\x01\n\x0b\n\x03\x04o\
    \x01\x12\x04\x97\n\x08$\n\x0c\n\x04\x04o\x02\0\x12\x04\x98\n\x08%\n\r\n\
    \x05\x04o\x02\0\x04\x12\x04\x98\n\x08\x10\n\r\n\x05\x04o\x02\0\x05\x12\
    \x04\x98\n\x11\x16\n\r\n\x05\x04o\x02\0\x01\x12\x04\x98\n\x17\x20\n\r\n\
    \x05\x04o\x02\0\x03\x12\x04\x98\n#$\n\x0c\n\x04\x04o\x02\x01\x12\x04\x99\
    \n\x08$\n\r\n\x05\x04o\x02\x01\x04\x12\x04\x99\n\x08\x10\n\r\n\x05\x04o\
    \x02\x01\x05\x12\x04\x99\n\x11\x17\n\r\n\x05\x04o\x02\x01\x01\x12\x04\
    \x99\n\x18\x1f\n\r\n\x05\x04o\x02\x01\x03\x12\x04\x99\n\"#\n\x0c\n\x04\
    \x04o\x02\x02\x12\x04\x9a\n\x08\x1e\n\r\n\x05\x04o\x02\x02\x04\x12\x04\
    \x9a\n\x08\x10\n\r\n\x05\x04o\x02\x02\x05\x12\x04\x9a\n\x11\x15\n\r\n\
    \x05\x04o\x02\x02\x01\x12\x04\x9a\n\x16\x19\n\r\n\x05\x04o\x02\x02\x03\
    \x12\x04\x9a\n\x1c\x1d\n\x0c\n\x02\x04p\x12\x06\x9d\n\0\xa0\n\x01\n\x0b\
    \n\x03\x04p\x01\x12\x04\x9d\n\x08$\n\x0c\n\x04\x04p\x02\0\x12\x04\x9e\n\
    \x08%\n\r\n\x05\x04p\x02\0\x04\x12\x04\x9e\n\x08\x10\n\r\n\x05\x04p\x02\
    \0\x05\x12\x04\x9e\n\x11\x16\n\r\n\x05\x04p\x02\0\x01\x12\x04\x9e\n\x17\
    \x20\n\r\n\x05\x04p\x02\0\x03\x12\x04\x9e\n#$\n\x0c\n\x04\x04p\x02\x01\
    \x12\x04\x9f\n\x08&\n\r\n\x05\x04p\x02\x01\x04\x12\x04\x9f\n\x08\x10\n\r\
    \n\x05\x04p\x02\x01\x05\x12\x04\x9f\n\x11\x17\n\r\n\x05\x04p\x02\x01\x01\
    \x12\x04\x9f\n\x18!\n\r\n\x05\x04p\x02\x01\x03\x12\x04\x9f\n$%\n\x0c\n\
    \x02\x04q\x12\x06\xa2\n\0\xa9\n\x01\n\x0b\n\x03\x04q\x01\x12\x04\xa2\n\
    \x08'\n\x0c\n\x04\x04q\x02\0\x12\x04\xa3\n\x08%\n\r\n\x05\x04q\x02\0\x04\
    \x12\x04\xa3\n\x08\x10\n\r\n\x05\x04q\x02\0\x05\x12\x04\xa3\n\x11\x16\n\
    \r\n\x05\x04q\x02\0\x01\x12\x04\xa3\n\x17\x20\n\r\n\x05\x04q\x02\0\x03\
    \x12\x04\xa3\n#$\n\x0c\n\x04\x04q\x02\x01\x12\x04\xa4\n\x08)\n\r\n\x05\
    \x04q\x02\x01\x04\x12\x04\xa4\n\x08\x10\n\r\n\x05\x04q\x02\x01\x05\x12\
    \x04\xa4\n\x11\x17\n\r\n\x05\x04q\x02\x01\x01\x12\x04\xa4\n\x18$\n\r\n\
    \x05\x04q\x02\x01\x03\x12\x04\xa4\n'(\n\x0c\n\x04\x04q\x02\x02\x12\x04\
    \xa5\n\x08&\n\r\n\x05\x04q\x02\x02\x04\x12\x04\xa5\n\x08\x10\n\r\n\x05\
    \x04q\x02\x02\x05\x12\x04\xa5\n\x11\x17\n\r\n\x05\x04q\x02\x02\x01\x12\
    \x04\xa5\n\x18!\n\r\n\x05\x04q\x02\x02\x03\x12\x04\xa5\n$%\n\x0c\n\x04\
    \x04q\x02\x03\x12\x04\xa6\n\x08+\n\r\n\x05\x04q\x02\x03\x04\x12\x04\xa6\
    \n\x08\x10\n\r\n\x05\x04q\x02\x03\x05\x12\x04\xa6\n\x11\x16\n\r\n\x05\
    \x04q\x02\x03\x01\x12\x04\xa6\n\x17&\n\r\n\x05\x04q\x02\x03\x03\x12\x04\
    \xa6\n)*\n\x0c\n\x04\x04q\x02\x04\x12\x04\xa7\n\x08&\n\r\n\x05\x04q\x02\
    \x04\x04\x12\x04\xa7\n\x08\x10\n\r\n\x05\x04q\x02\x04\x05\x12\x04\xa7\n\
    \x11\x17\n\r\n\x05\x04q\x02\x04\x01\x12\x04\xa7\n\x18!\n\r\n\x05\x04q\
    \x02\x04\x03\x12\x04\xa7\n$%\n\x0c\n\x04\x04q\x02\x05\x12\x04\xa8\n\x08)\
    \n\r\n\x05\x04q\x02\x05\x04\x12\x04\xa8\n\x08\x10\n\r\n\x05\x04q\x02\x05\
    \x05\x12\x04\xa8\n\x11\x17\n\r\n\x05\x04q\x02\x05\x01\x12\x04\xa8\n\x18$\
    \n\r\n\x05\x04q\x02\x05\x03\x12\x04\xa8\n'(\n\x0c\n\x02\x04r\x12\x06\xab\
    \n\0\xae\n\x01\n\x0b\n\x03\x04r\x01\x12\x04\xab\n\x08&\n\x0c\n\x04\x04r\
    \x02\0\x12\x04\xac\n\x08%\n\r\n\x05\x04r\x02\0\x04\x12\x04\xac\n\x08\x10\
    \n\r\n\x05\x04r\x02\0\x05\x12\x04\xac\n\x11\x16\n\r\n\x05\x04r\x02\0\x01\
    \x12\x04\xac\n\x17\x20\n\r\n\x05\x04r\x02\0\x03\x12\x04\xac\n#$\n\x0c\n\
    \x04\x04r\x02\x01\x12\x04\xad\n\x08!\n\r\n\x05\x04r\x02\x01\x04\x12\x04\
    \xad\n\x08\x10\n\r\n\x05\x04r\x02\x01\x05\x12\x04\xad\n\x11\x17\n\r\n\
    \x05\x04r\x02\x01\x01\x12\x04\xad\n\x18\x1c\n\r\n\x05\x04r\x02\x01\x03\
    \x12\x04\xad\n\x1f\x20\n\x0c\n\x02\x04s\x12\x06\xb0\n\0\xb6\n\x01\n\x0b\
    \n\x03\x04s\x01\x12\x04\xb0\n\x08#\n\x0c\n\x04\x04s\x02\0\x12\x04\xb1\n\
    \x08%\n\r\n\x05\x04s\x02\0\x04\x12\x04\xb1\n\x08\x10\n\r\n\x05\x04s\x02\
    \0\x05\x12\x04\xb1\n\x11\x16\n\r\n\x05\x04s\x02\0\x01\x12\x04\xb1\n\x17\
    \x20\n\r\n\x05\x04s\x02\0\x03\x12\x04\xb1\n#$\n\x0c\n\x04\x04s\x02\x01\
    \x12\x04\xb2\n\x08)\n\r\n\x05\x04s\x02\x01\x04\x12\x04\xb2\n\x08\x10\n\r\
    \n\x05\x04s\x02\x01\x05\x12\x04\xb2\n\x11\x17\n\r\n\x05\x04s\x02\x01\x01\
    \x12\x04\xb2\n\x18$\n\r\n\x05\x04s\x02\x01\x03\x12\x04\xb2\n'(\n\x0c\n\
    \x04\x04s\x02\x02\x12\x04\xb3\n\x08%\n\r\n\x05\x04s\x02\x02\x04\x12\x04\
    \xb3\n\x08\x10\n\r\n\x05\x04s\x02\x02\x05\x12\x04\xb3\n\x11\x17\n\r\n\
    \x05\x04s\x02\x02\x01\x12\x04\xb3\n\x18\x20\n\r\n\x05\x04s\x02\x02\x03\
    \x12\x04\xb3\n#$\n\x0c\n\x04\x04s\x02\x03\x12\x04\xb4\n\x08%\n\r\n\x05\
    \x04s\x02\x03\x04\x12\x04\xb4\n\x08\x10\n\r\n\x05\x04s\x02\x03\x05\x12\
    \x04\xb4\n\x11\x17\n\r\n\x05\x04s\x02\x03\x01\x12\x04\xb4\n\x18\x20\n\r\
    \n\x05\x04s\x02\x03\x03\x12\x04\xb4\n#$\n\x0c\n\x04\x04s\x02\x04\x12\x04\
    \xb5\n\x08#\n\r\n\x05\x04s\x02\x04\x04\x12\x04\xb5\n\x08\x10\n\r\n\x05\
    \x04s\x02\x04\x05\x12\x04\xb5\n\x11\x17\n\r\n\x05\x04s\x02\x04\x01\x12\
    \x04\xb5\n\x18\x1e\n\r\n\x05\x04s\x02\x04\x03\x12\x04\xb5\n!\"\n\x0c\n\
    \x02\x04t\x12\x06\xb8\n\0\xbc\n\x01\n\x0b\n\x03\x04t\x01\x12\x04\xb8\n\
    \x08#\n\x0c\n\x04\x04t\x02\0\x12\x04\xb9\n\x08%\n\r\n\x05\x04t\x02\0\x04\
    \x12\x04\xb9\n\x08\x10\n\r\n\x05\x04t\x02\0\x05\x12\x04\xb9\n\x11\x16\n\
    \r\n\x05\x04t\x02\0\x01\x12\x04\xb9\n\x17\x20\n\r\n\x05\x04t\x02\0\x03\
    \x12\x04\xb9\n#$\n\x0c\n\x04\x04t\x02\x01\x12\x04\xba\n\x08)\n\r\n\x05\
    \x04t\x02\x01\x04\x12\x04\xba\n\x08\x10\n\r\n\x05\x04t\x02\x01\x05\x12\
    \x04\xba\n\x11\x17\n\r\n\x05\x04t\x02\x01\x01\x12\x04\xba\n\x18$\n\r\n\
    \x05\x04t\x02\x01\x03\x12\x04\xba\n'(\n\x0c\n\x04\x04t\x02\x02\x12\x04\
    \xbb\n\x08!\n\r\n\x05\x04t\x02\x02\x04\x12\x04\xbb\n\x08\x10\n\r\n\x05\
    \x04t\x02\x02\x05\x12\x04\xbb\n\x11\x15\n\r\n\x05\x04t\x02\x02\x01\x12\
    \x04\xbb\n\x16\x1c\n\r\n\x05\x04t\x02\x02\x03\x12\x04\xbb\n\x1f\x20\n\
    \x0c\n\x02\x04u\x12\x06\xbe\n\0\xc0\n\x01\n\x0b\n\x03\x04u\x01\x12\x04\
    \xbe\n\x08/\n\x0c\n\x04\x04u\x02\0\x12\x04\xbf\n\x08%\n\r\n\x05\x04u\x02\
    \0\x04\x12\x04\xbf\n\x08\x10\n\r\n\x05\x04u\x02\0\x05\x12\x04\xbf\n\x11\
    \x16\n\r\n\x05\x04u\x02\0\x01\x12\x04\xbf\n\x17\x20\n\r\n\x05\x04u\x02\0\
    \x03\x12\x04\xbf\n#$\n\x0c\n\x02\x04v\x12\x06\xc2\n\0\xc5\n\x01\n\x0b\n\
    \x03\x04v\x01\x12\x04\xc2\n\x08+\n\x0c\n\x04\x04v\x02\0\x12\x04\xc3\n\
    \x08!\n\r\n\x05\x04v\x02\0\x04\x12\x04\xc3\n\x08\x10\n\r\n\x05\x04v\x02\
    \0\x05\x12\x04\xc3\n\x11\x17\n\r\n\x05\x04v\x02\0\x01\x12\x04\xc3\n\x18\
    \x1c\n\r\n\x05\x04v\x02\0\x03\x12\x04\xc3\n\x1f\x20\n\x0c\n\x04\x04v\x02\
    \x01\x12\x04\xc4\n\x08-\n\r\n\x05\x04v\x02\x01\x04\x12\x04\xc4\n\x08\x10\
    \n\r\n\x05\x04v\x02\x01\x05\x12\x04\xc4\n\x11\x16\n\r\n\x05\x04v\x02\x01\
    \x01\x12\x04\xc4\n\x17(\n\r\n\x05\x04v\x02\x01\x03\x12\x04\xc4\n+,\n\x0c\
    \n\x02\x04w\x12\x06\xc7\n\0\xca\n\x01\n\x0b\n\x03\x04w\x01\x12\x04\xc7\n\
    \x08&\n\x0c\n\x04\x04w\x02\0\x12\x04\xc8\n\x08'\n\r\n\x05\x04w\x02\0\x04\
    \x12\x04\xc8\n\x08\x10\n\r\n\x05\x04w\x02\0\x05\x12\x04\xc8\n\x11\x17\n\
    \r\n\x05\x04w\x02\0\x01\x12\x04\xc8\n\x18\"\n\r\n\x05\x04w\x02\0\x03\x12\
    \x04\xc8\n%&\n\x0c\n\x04\x04w\x02\x01\x12\x04\xc9\n\x08.\n\r\n\x05\x04w\
    \x02\x01\x04\x12\x04\xc9\n\x08\x10\n\r\n\x05\x04w\x02\x01\x05\x12\x04\
    \xc9\n\x11\x16\n\r\n\x05\x04w\x02\x01\x01\x12\x04\xc9\n\x17)\n\r\n\x05\
    \x04w\x02\x01\x03\x12\x04\xc9\n,-\n\x0c\n\x02\x04x\x12\x06\xcc\n\0\xd2\n\
    \x01\n\x0b\n\x03\x04x\x01\x12\x04\xcc\n\x08&\n\x0c\n\x04\x04x\x02\0\x12\
    \x04\xcd\n\x08,\n\r\n\x05\x04x\x02\0\x04\x12\x04\xcd\n\x08\x10\n\r\n\x05\
    \x04x\x02\0\x05\x12\x04\xcd\n\x11\x17\n\r\n\x05\x04x\x02\0\x01\x12\x04\
    \xcd\n\x18'\n\r\n\x05\x04x\x02\0\x03\x12\x04\xcd\n*+\n\x0c\n\x04\x04x\
    \x02\x01\x12\x04\xce\n\x08\"\n\r\n\x05\x04x\x02\x01\x04\x12\x04\xce\n\
    \x08\x10\n\r\n\x05\x04x\x02\x01\x05\x12\x04\xce\n\x11\x17\n\r\n\x05\x04x\
    \x02\x01\x01\x12\x04\xce\n\x18\x1d\n\r\n\x05\x04x\x02\x01\x03\x12\x04\
    \xce\n\x20!\n\x0c\n\x04\x04x\x02\x02\x12\x04\xcf\n\x08$\n\r\n\x05\x04x\
    \x02\x02\x04\x12\x04\xcf\n\x08\x10\n\r\n\x05\x04x\x02\x02\x05\x12\x04\
    \xcf\n\x11\x17\n\r\n\x05\x04x\x02\x02\x01\x12\x04\xcf\n\x18\x1f\n\r\n\
    \x05\x04x\x02\x02\x03\x12\x04\xcf\n\"#\n\x0c\n\x04\x04x\x02\x03\x12\x04\
    \xd0\n\x08%\n\r\n\x05\x04x\x02\x03\x04\x12\x04\xd0\n\x08\x10\n\r\n\x05\
    \x04x\x02\x03\x05\x12\x04\xd0\n\x11\x17\n\r\n\x05\x04x\x02\x03\x01\x12\
    \x04\xd0\n\x18\x20\n\r\n\x05\x04x\x02\x03\x03\x12\x04\xd0\n#$\n\x0c\n\
    \x04\x04x\x02\x04\x12\x04\xd1\n\x08)\n\r\n\x05\x04x\x02\x04\x04\x12\x04\
    \xd1\n\x08\x10\n\r\n\x05\x04x\x02\x04\x05\x12\x04\xd1\n\x11\x16\n\r\n\
    \x05\x04x\x02\x04\x01\x12\x04\xd1\n\x17$\n\r\n\x05\x04x\x02\x04\x03\x12\
    \x04\xd1\n'(\n\x0c\n\x02\x04y\x12\x06\xd4\n\0\xd8\n\x01\n\x0b\n\x03\x04y\
    \x01\x12\x04\xd4\n\x08/\n\x0c\n\x04\x04y\x02\0\x12\x04\xd5\n\x08%\n\r\n\
    \x05\x04y\x02\0\x04\x12\x04\xd5\n\x08\x10\n\r\n\x05\x04y\x02\0\x05\x12\
    \x04\xd5\n\x11\x16\n\r\n\x05\x04y\x02\0\x01\x12\x04\xd5\n\x17\x20\n\r\n\
    \x05\x04y\x02\0\x03\x12\x04\xd5\n#$\n\x0c\n\x04\x04y\x02\x01\x12\x04\xd6\
    \n\x080\n\r\n\x05\x04y\x02\x01\x04\x12\x04\xd6\n\x08\x10\n\r\n\x05\x04y\
    \x02\x01\x05\x12\x04\xd6\n\x11\x16\n\r\n\x05\x04y\x02\x01\x01\x12\x04\
    \xd6\n\x17+\n\r\n\x05\x04y\x02\x01\x03\x12\x04\xd6\n./\n\x0c\n\x04\x04y\
    \x02\x02\x12\x04\xd7\n\x08'\n\r\n\x05\x04y\x02\x02\x04\x12\x04\xd7\n\x08\
    \x10\n\r\n\x05\x04y\x02\x02\x05\x12\x04\xd7\n\x11\x15\n\r\n\x05\x04y\x02\
    \x02\x01\x12\x04\xd7\n\x16\"\n\r\n\x05\x04y\x02\x02\x03\x12\x04\xd7\n%&\
    \n\x0c\n\x02\x04z\x12\x06\xda\n\0\xe0\n\x01\n\x0b\n\x03\x04z\x01\x12\x04\
    \xda\n\x08!\n\x0c\n\x04\x04z\x02\0\x12\x04\xdb\n\x08%\n\r\n\x05\x04z\x02\
    \0\x04\x12\x04\xdb\n\x08\x10\n\r\n\x05\x04z\x02\0\x05\x12\x04\xdb\n\x11\
    \x16\n\r\n\x05\x04z\x02\0\x01\x12\x04\xdb\n\x17\x20\n\r\n\x05\x04z\x02\0\
    \x03\x12\x04\xdb\n#$\n\x0c\n\x04\x04z\x02\x01\x12\x04\xdc\n\x08+\n\r\n\
    \x05\x04z\x02\x01\x04\x12\x04\xdc\n\x08\x10\n\r\n\x05\x04z\x02\x01\x05\
    \x12\x04\xdc\n\x11\x17\n\r\n\x05\x04z\x02\x01\x01\x12\x04\xdc\n\x18&\n\r\
    \n\x05\x04z\x02\x01\x03\x12\x04\xdc\n)*\n\x0c\n\x04\x04z\x02\x02\x12\x04\
    \xdd\n\x08+\n\r\n\x05\x04z\x02\x02\x04\x12\x04\xdd\n\x08\x10\n\r\n\x05\
    \x04z\x02\x02\x05\x12\x04\xdd\n\x11\x17\n\r\n\x05\x04z\x02\x02\x01\x12\
    \x04\xdd\n\x18&\n\r\n\x05\x04z\x02\x02\x03\x12\x04\xdd\n)*\n\x0c\n\x04\
    \x04z\x02\x03\x12\x04\xde\n\x08)\n\r\n\x05\x04z\x02\x03\x04\x12\x04\xde\
    \n\x08\x10\n\r\n\x05\x04z\x02\x03\x05\x12\x04\xde\n\x11\x16\n\r\n\x05\
    \x04z\x02\x03\x01\x12\x04\xde\n\x17$\n\r\n\x05\x04z\x02\x03\x03\x12\x04\
    \xde\n'(\n\x0c\n\x04\x04z\x02\x04\x12\x04\xdf\n\x08$\n\r\n\x05\x04z\x02\
    \x04\x04\x12\x04\xdf\n\x08\x10\n\r\n\x05\x04z\x02\x04\x05\x12\x04\xdf\n\
    \x11\x15\n\r\n\x05\x04z\x02\x04\x01\x12\x04\xdf\n\x16\x1f\n\r\n\x05\x04z\
    \x02\x04\x03\x12\x04\xdf\n\"#\n\x0c\n\x02\x04{\x12\x06\xe2\n\0\xe9\n\x01\
    \n\x0b\n\x03\x04{\x01\x12\x04\xe2\n\x08!\n\x0c\n\x04\x04{\x02\0\x12\x04\
    \xe3\n\x08,\n\r\n\x05\x04{\x02\0\x04\x12\x04\xe3\n\x08\x10\n\r\n\x05\x04\
    {\x02\0\x05\x12\x04\xe3\n\x11\x16\n\r\n\x05\x04{\x02\0\x01\x12\x04\xe3\n\
    \x17'\n\r\n\x05\x04{\x02\0\x03\x12\x04\xe3\n*+\n\x0c\n\x04\x04{\x02\x01\
    \x12\x04\xe4\n\x08,\n\r\n\x05\x04{\x02\x01\x04\x12\x04\xe4\n\x08\x10\n\r\
    \n\x05\x04{\x02\x01\x05\x12\x04\xe4\n\x11\x16\n\r\n\x05\x04{\x02\x01\x01\
    \x12\x04\xe4\n\x17'\n\r\n\x05\x04{\x02\x01\x03\x12\x04\xe4\n*+\n\x0c\n\
    \x04\x04{\x02\x02\x12\x04\xe5\n\x08'\n\r\n\x05\x04{\x02\x02\x04\x12\x04\
    \xe5\n\x08\x10\n\r\n\x05\x04{\x02\x02\x05\x12\x04\xe5\n\x11\x17\n\r\n\
    \x05\x04{\x02\x02\x01\x12\x04\xe5\n\x18\"\n\r\n\x05\x04{\x02\x02\x03\x12\
    \x04\xe5\n%&\n\x0c\n\x04\x04{\x02\x03\x12\x04\xe6\n\x08%\n\r\n\x05\x04{\
    \x02\x03\x04\x12\x04\xe6\n\x08\x10\n\r\n\x05\x04{\x02\x03\x05\x12\x04\
    \xe6\n\x11\x17\n\r\n\x05\x04{\x02\x03\x01\x12\x04\xe6\n\x18\x20\n\r\n\
    \x05\x04{\x02\x03\x03\x12\x04\xe6\n#$\n\x0c\n\x04\x04{\x02\x04\x12\x04\
    \xe7\n\x08-\n\r\n\x05\x04{\x02\x04\x04\x12\x04\xe7\n\x08\x10\n\r\n\x05\
    \x04{\x02\x04\x05\x12\x04\xe7\n\x11\x17\n\r\n\x05\x04{\x02\x04\x01\x12\
    \x04\xe7\n\x18(\n\r\n\x05\x04{\x02\x04\x03\x12\x04\xe7\n+,\n\x0c\n\x04\
    \x04{\x02\x05\x12\x04\xe8\n\x08,\n\r\n\x05\x04{\x02\x05\x04\x12\x04\xe8\
    \n\x08\x10\n\r\n\x05\x04{\x02\x05\x05\x12\x04\xe8\n\x11\x17\n\r\n\x05\
    \x04{\x02\x05\x01\x12\x04\xe8\n\x18'\n\r\n\x05\x04{\x02\x05\x03\x12\x04\
    \xe8\n*+\n\x0c\n\x02\x04|\x12\x06\xeb\n\0\xee\n\x01\n\x0b\n\x03\x04|\x01\
    \x12\x04\xeb\n\x08\x1d\n\x0c\n\x04\x04|\x02\0\x12\x04\xec\n\x08%\n\r\n\
    \x05\x04|\x02\0\x04\x12\x04\xec\n\x08\x10\n\r\n\x05\x04|\x02\0\x05\x12\
    \x04\xec\n\x11\x16\n\r\n\x05\x04|\x02\0\x01\x12\x04\xec\n\x17\x20\n\r\n\
    \x05\x04|\x02\0\x03\x12\x04\xec\n#$\n\x0c\n\x04\x04|\x02\x01\x12\x04\xed\
    \n\x08%\n\r\n\x05\x04|\x02\x01\x04\x12\x04\xed\n\x08\x10\n\r\n\x05\x04|\
    \x02\x01\x05\x12\x04\xed\n\x11\x17\n\r\n\x05\x04|\x02\x01\x01\x12\x04\
    \xed\n\x18\x20\n\r\n\x05\x04|\x02\x01\x03\x12\x04\xed\n#$\n\x0c\n\x02\
    \x04}\x12\x06\xf0\n\0\xf4\n\x01\n\x0b\n\x03\x04}\x01\x12\x04\xf0\n\x08%\
    \n\x0c\n\x04\x04}\x02\0\x12\x04\xf1\n\x08%\n\r\n\x05\x04}\x02\0\x04\x12\
    \x04\xf1\n\x08\x10\n\r\n\x05\x04}\x02\0\x05\x12\x04\xf1\n\x11\x16\n\r\n\
    \x05\x04}\x02\0\x01\x12\x04\xf1\n\x17\x20\n\r\n\x05\x04}\x02\0\x03\x12\
    \x04\xf1\n#$\n\x0c\n\x04\x04}\x02\x01\x12\x04\xf2\n\x08+\n\r\n\x05\x04}\
    \x02\x01\x04\x12\x04\xf2\n\x08\x10\n\r\n\x05\x04}\x02\x01\x05\x12\x04\
    \xf2\n\x11\x16\n\r\n\x05\x04}\x02\x01\x01\x12\x04\xf2\n\x17&\n\r\n\x05\
    \x04}\x02\x01\x03\x12\x04\xf2\n)*\n\x0c\n\x04\x04}\x02\x02\x12\x04\xf3\n\
    \x08+\n\r\n\x05\x04}\x02\x02\x04\x12\x04\xf3\n\x08\x10\n\r\n\x05\x04}\
    \x02\x02\x05\x12\x04\xf3\n\x11\x16\n\r\n\x05\x04}\x02\x02\x01\x12\x04\
    \xf3\n\x17&\n\r\n\x05\x04}\x02\x02\x03\x12\x04\xf3\n)*\n\x0c\n\x02\x04~\
    \x12\x06\xf6\n\0\xfa\n\x01\n\x0b\n\x03\x04~\x01\x12\x04\xf6\n\x08\"\n\
    \x0c\n\x04\x04~\x02\0\x12\x04\xf7\n\x08$\n\r\n\x05\x04~\x02\0\x04\x12\
    \x04\xf7\n\x08\x10\n\r\n\x05\x04~\x02\0\x05\x12\x04\xf7\n\x11\x17\n\r\n\
    \x05\x04~\x02\0\x01\x12\x04\xf7\n\x18\x1f\n\r\n\x05\x04~\x02\0\x03\x12\
    \x04\xf7\n\"#\n\x0c\n\x04\x04~\x02\x01\x12\x04\xf8\n\x08(\n\r\n\x05\x04~\
    \x02\x01\x04\x12\x04\xf8\n\x08\x10\n\r\n\x05\x04~\x02\x01\x05\x12\x04\
    \xf8\n\x11\x17\n\r\n\x05\x04~\x02\x01\x01\x12\x04\xf8\n\x18#\n\r\n\x05\
    \x04~\x02\x01\x03\x12\x04\xf8\n&'\n\x0c\n\x04\x04~\x02\x02\x12\x04\xf9\n\
    \x08)\n\r\n\x05\x04~\x02\x02\x04\x12\x04\xf9\n\x08\x10\n\r\n\x05\x04~\
    \x02\x02\x05\x12\x04\xf9\n\x11\x17\n\r\n\x05\x04~\x02\x02\x01\x12\x04\
    \xf9\n\x18$\n\r\n\x05\x04~\x02\x02\x03\x12\x04\xf9\n'(\n\x0c\n\x02\x04\
    \x7f\x12\x06\xfc\n\0\x80\x0b\x01\n\x0b\n\x03\x04\x7f\x01\x12\x04\xfc\n\
    \x08)\n\x0c\n\x04\x04\x7f\x02\0\x12\x04\xfd\n\x08$\n\r\n\x05\x04\x7f\x02\
    \0\x04\x12\x04\xfd\n\x08\x10\n\r\n\x05\x04\x7f\x02\0\x05\x12\x04\xfd\n\
    \x11\x17\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\xfd\n\x18\x1f\n\r\n\x05\x04\
    \x7f\x02\0\x03\x12\x04\xfd\n\"#\n\x0c\n\x04\x04\x7f\x02\x01\x12\x04\xfe\
    \n\x08(\n\r\n\x05\x04\x7f\x02\x01\x04\x12\x04\xfe\n\x08\x10\n\r\n\x05\
    \x04\x7f\x02\x01\x05\x12\x04\xfe\n\x11\x17\n\r\n\x05\x04\x7f\x02\x01\x01\
    \x12\x04\xfe\n\x18#\n\r\n\x05\x04\x7f\x02\x01\x03\x12\x04\xfe\n&'\n\x0c\
    \n\x04\x04\x7f\x02\x02\x12\x04\xff\n\x08*\n\r\n\x05\x04\x7f\x02\x02\x04\
    \x12\x04\xff\n\x08\x10\n\r\n\x05\x04\x7f\x02\x02\x05\x12\x04\xff\n\x11\
    \x17\n\r\n\x05\x04\x7f\x02\x02\x01\x12\x04\xff\n\x18%\n\r\n\x05\x04\x7f\
    \x02\x02\x03\x12\x04\xff\n()\n\r\n\x03\x04\x80\x01\x12\x06\x82\x0b\0\x87\
    \x0b\x01\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\x82\x0b\x08\"\n\r\n\x05\x04\
    \x80\x01\x02\0\x12\x04\x83\x0b\x08$\n\x0e\n\x06\x04\x80\x01\x02\0\x04\
    \x12\x04\x83\x0b\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\0\x05\x12\x04\x83\
    \x0b\x11\x17\n\x0e\n\x06\x04\x80\x01\x02\0\x01\x12\x04\x83\x0b\x18\x1f\n\
    \x0e\n\x06\x04\x80\x01\x02\0\x03\x12\x04\x83\x0b\"#\n\r\n\x05\x04\x80\
    \x01\x02\x01\x12\x04\x84\x0b\x08-\n\x0e\n\x06\x04\x80\x01\x02\x01\x04\
    \x12\x04\x84\x0b\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\x01\x05\x12\x04\x84\
    \x0b\x11\x17\n\x0e\n\x06\x04\x80\x01\x02\x01\x01\x12\x04\x84\x0b\x18(\n\
    \x0e\n\x06\x04\x80\x01\x02\x01\x03\x12\x04\x84\x0b+,\n\r\n\x05\x04\x80\
    \x01\x02\x02\x12\x04\x85\x0b\x08)\n\x0e\n\x06\x04\x80\x01\x02\x02\x04\
    \x12\x04\x85\x0b\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\x02\x05\x12\x04\x85\
    \x0b\x11\x17\n\x0e\n\x06\x04\x80\x01\x02\x02\x01\x12\x04\x85\x0b\x18$\n\
    \x0e\n\x06\x04\x80\x01\x02\x02\x03\x12\x04\x85\x0b'(\n\r\n\x05\x04\x80\
    \x01\x02\x03\x12\x04\x86\x0b\x08-\n\x0e\n\x06\x04\x80\x01\x02\x03\x04\
    \x12\x04\x86\x0b\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\x03\x05\x12\x04\x86\
    \x0b\x11\x17\n\x0e\n\x06\x04\x80\x01\x02\x03\x01\x12\x04\x86\x0b\x18(\n\
    \x0e\n\x06\x04\x80\x01\x02\x03\x03\x12\x04\x86\x0b+,\n\r\n\x03\x04\x81\
    \x01\x12\x06\x89\x0b\0\x8e\x0b\x01\n\x0c\n\x04\x04\x81\x01\x01\x12\x04\
    \x89\x0b\x08&\n\r\n\x05\x04\x81\x01\x02\0\x12\x04\x8a\x0b\x08'\n\x0e\n\
    \x06\x04\x81\x01\x02\0\x04\x12\x04\x8a\x0b\x08\x10\n\x0e\n\x06\x04\x81\
    \x01\x02\0\x05\x12\x04\x8a\x0b\x11\x16\n\x0e\n\x06\x04\x81\x01\x02\0\x01\
    \x12\x04\x8a\x0b\x17\"\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\x8a\x0b\
    %&\n\r\n\x05\x04\x81\x01\x02\x01\x12\x04\x8b\x0b\x08'\n\x0e\n\x06\x04\
    \x81\x01\x02\x01\x04\x12\x04\x8b\x0b\x08\x10\n\x0e\n\x06\x04\x81\x01\x02\
    \x01\x05\x12\x04\x8b\x0b\x11\x16\n\x0e\n\x06\x04\x81\x01\x02\x01\x01\x12\
    \x04\x8b\x0b\x17\"\n\x0e\n\x06\x04\x81\x01\x02\x01\x03\x12\x04\x8b\x0b%&\
    \n\r\n\x05\x04\x81\x01\x02\x02\x12\x04\x8c\x0b\x08,\n\x0e\n\x06\x04\x81\
    \x01\x02\x02\x04\x12\x04\x8c\x0b\x08\x10\n\x0e\n\x06\x04\x81\x01\x02\x02\
    \x05\x12\x04\x8c\x0b\x11\x15\n\x0e\n\x06\x04\x81\x01\x02\x02\x01\x12\x04\
    \x8c\x0b\x16'\n\x0e\n\x06\x04\x81\x01\x02\x02\x03\x12\x04\x8c\x0b*+\n\r\
    \n\x05\x04\x81\x01\x02\x03\x12\x04\x8d\x0b\x08,\n\x0e\n\x06\x04\x81\x01\
    \x02\x03\x04\x12\x04\x8d\x0b\x08\x10\n\x0e\n\x06\x04\x81\x01\x02\x03\x05\
    \x12\x04\x8d\x0b\x11\x16\n\x0e\n\x06\x04\x81\x01\x02\x03\x01\x12\x04\x8d\
    \x0b\x17'\n\x0e\n\x06\x04\x81\x01\x02\x03\x03\x12\x04\x8d\x0b*+\n\r\n\
    \x03\x04\x82\x01\x12\x06\x90\x0b\0\x92\x0b\x01\n\x0c\n\x04\x04\x82\x01\
    \x01\x12\x04\x90\x0b\x08(\n\r\n\x05\x04\x82\x01\x02\0\x12\x04\x91\x0b\
    \x08%\n\x0e\n\x06\x04\x82\x01\x02\0\x04\x12\x04\x91\x0b\x08\x10\n\x0e\n\
    \x06\x04\x82\x01\x02\0\x05\x12\x04\x91\x0b\x11\x16\n\x0e\n\x06\x04\x82\
    \x01\x02\0\x01\x12\x04\x91\x0b\x17\x20\n\x0e\n\x06\x04\x82\x01\x02\0\x03\
    \x12\x04\x91\x0b#$\n\r\n\x03\x04\x83\x01\x12\x06\x94\x0b\0\x99\x0b\x01\n\
    \x0c\n\x04\x04\x83\x01\x01\x12\x04\x94\x0b\x08\"\n\r\n\x05\x04\x83\x01\
    \x02\0\x12\x04\x95\x0b\x08%\n\x0e\n\x06\x04\x83\x01\x02\0\x04\x12\x04\
    \x95\x0b\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\0\x05\x12\x04\x95\x0b\x11\
    \x16\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\x95\x0b\x17\x20\n\x0e\n\
    \x06\x04\x83\x01\x02\0\x03\x12\x04\x95\x0b#$\n\r\n\x05\x04\x83\x01\x02\
    \x01\x12\x04\x96\x0b\x08#\n\x0e\n\x06\x04\x83\x01\x02\x01\x04\x12\x04\
    \x96\x0b\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\x01\x05\x12\x04\x96\x0b\x11\
    \x15\n\x0e\n\x06\x04\x83\x01\x02\x01\x01\x12\x04\x96\x0b\x16\x1e\n\x0e\n\
    \x06\x04\x83\x01\x02\x01\x03\x12\x04\x96\x0b!\"\n\r\n\x05\x04\x83\x01\
    \x02\x02\x12\x04\x97\x0b\x08&\n\x0e\n\x06\x04\x83\x01\x02\x02\x04\x12\
    \x04\x97\x0b\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\x02\x05\x12\x04\x97\x0b\
    \x11\x17\n\x0e\n\x06\x04\x83\x01\x02\x02\x01\x12\x04\x97\x0b\x18!\n\x0e\
    \n\x06\x04\x83\x01\x02\x02\x03\x12\x04\x97\x0b$%\n\r\n\x05\x04\x83\x01\
    \x02\x03\x12\x04\x98\x0b\x08%\n\x0e\n\x06\x04\x83\x01\x02\x03\x04\x12\
    \x04\x98\x0b\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\x03\x05\x12\x04\x98\x0b\
    \x11\x17\n\x0e\n\x06\x04\x83\x01\x02\x03\x01\x12\x04\x98\x0b\x18\x20\n\
    \x0e\n\x06\x04\x83\x01\x02\x03\x03\x12\x04\x98\x0b#$\n\r\n\x03\x04\x84\
    \x01\x12\x06\x9b\x0b\0\xa6\x0b\x01\n\x0c\n\x04\x04\x84\x01\x01\x12\x04\
    \x9b\x0b\x08!\n\x0f\n\x05\x04\x84\x01\x03\0\x12\x06\x9c\x0b\x08\x9f\x0b\
    \t\n\x0e\n\x06\x04\x84\x01\x03\0\x01\x12\x04\x9c\x0b\x10\x1b\n\x0f\n\x07\
    \x04\x84\x01\x03\0\x02\0\x12\x04\x9d\x0b\x10-\n\x10\n\x08\x04\x84\x01\
    \x03\0\x02\0\x04\x12\x04\x9d\x0b\x10\x18\n\x10\n\x08\x04\x84\x01\x03\0\
    \x02\0\x05\x12\x04\x9d\x0b\x19\x1e\n\x10\n\x08\x04\x84\x01\x03\0\x02\0\
    \x01\x12\x04\x9d\x0b\x1f(\n\x10\n\x08\x04\x84\x01\x03\0\x02\0\x03\x12\
    \x04\x9d\x0b+,\n\x0f\n\x07\x04\x84\x01\x03\0\x02\x01\x12\x04\x9e\x0b\x10\
    3\n\x10\n\x08\x04\x84\x01\x03\0\x02\x01\x04\x12\x04\x9e\x0b\x10\x18\n\
    \x10\n\x08\x04\x84\x01\x03\0\x02\x01\x05\x12\x04\x9e\x0b\x19\x1f\n\x10\n\
    \x08\x04\x84\x01\x03\0\x02\x01\x01\x12\x04\x9e\x0b\x20.\n\x10\n\x08\x04\
    \x84\x01\x03\0\x02\x01\x03\x12\x04\x9e\x0b12\n\r\n\x05\x04\x84\x01\x02\0\
    \x12\x04\xa1\x0b\x08,\n\x0e\n\x06\x04\x84\x01\x02\0\x04\x12\x04\xa1\x0b\
    \x08\x10\n\x0e\n\x06\x04\x84\x01\x02\0\x05\x12\x04\xa1\x0b\x11\x16\n\x0e\
    \n\x06\x04\x84\x01\x02\0\x01\x12\x04\xa1\x0b\x17'\n\x0e\n\x06\x04\x84\
    \x01\x02\0\x03\x12\x04\xa1\x0b*+\n\r\n\x05\x04\x84\x01\x02\x01\x12\x04\
    \xa2\x0b\x08,\n\x0e\n\x06\x04\x84\x01\x02\x01\x04\x12\x04\xa2\x0b\x08\
    \x10\n\x0e\n\x06\x04\x84\x01\x02\x01\x05\x12\x04\xa2\x0b\x11\x16\n\x0e\n\
    \x06\x04\x84\x01\x02\x01\x01\x12\x04\xa2\x0b\x17'\n\x0e\n\x06\x04\x84\
    \x01\x02\x01\x03\x12\x04\xa2\x0b*+\n\r\n\x05\x04\x84\x01\x02\x02\x12\x04\
    \xa3\x0b\x08)\n\x0e\n\x06\x04\x84\x01\x02\x02\x04\x12\x04\xa3\x0b\x08\
    \x10\n\x0e\n\x06\x04\x84\x01\x02\x02\x05\x12\x04\xa3\x0b\x11\x17\n\x0e\n\
    \x06\x04\x84\x01\x02\x02\x01\x12\x04\xa3\x0b\x18$\n\x0e\n\x06\x04\x84\
    \x01\x02\x02\x03\x12\x04\xa3\x0b'(\n\r\n\x05\x04\x84\x01\x02\x03\x12\x04\
    \xa4\x0b\x08%\n\x0e\n\x06\x04\x84\x01\x02\x03\x04\x12\x04\xa4\x0b\x08\
    \x10\n\x0e\n\x06\x04\x84\x01\x02\x03\x05\x12\x04\xa4\x0b\x11\x17\n\x0e\n\
    \x06\x04\x84\x01\x02\x03\x01\x12\x04\xa4\x0b\x18\x20\n\x0e\n\x06\x04\x84\
    \x01\x02\x03\x03\x12\x04\xa4\x0b#$\n\r\n\x05\x04\x84\x01\x02\x04\x12\x04\
    \xa5\x0b\x08I\n\x0e\n\x06\x04\x84\x01\x02\x04\x04\x12\x04\xa5\x0b\x08\
    \x10\n\x0e\n\x06\x04\x84\x01\x02\x04\x06\x12\x04\xa5\x0b\x116\n\x0e\n\
    \x06\x04\x84\x01\x02\x04\x01\x12\x04\xa5\x0b7D\n\x0e\n\x06\x04\x84\x01\
    \x02\x04\x03\x12\x04\xa5\x0bGH\n\r\n\x03\x04\x85\x01\x12\x06\xa8\x0b\0\
    \xaa\x0b\x01\n\x0c\n\x04\x04\x85\x01\x01\x12\x04\xa8\x0b\x08'\n\r\n\x05\
    \x04\x85\x01\x02\0\x12\x04\xa9\x0b\x080\n\x0e\n\x06\x04\x85\x01\x02\0\
    \x04\x12\x04\xa9\x0b\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\0\x05\x12\x04\
    \xa9\x0b\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\xa9\x0b\x18+\
    \n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\x04\xa9\x0b./\n\r\n\x03\x04\x86\
    \x01\x12\x06\xac\x0b\0\xb4\x0b\x01\n\x0c\n\x04\x04\x86\x01\x01\x12\x04\
    \xac\x0b\x08#\n\r\n\x05\x04\x86\x01\x02\0\x12\x04\xad\x0b\x08+\n\x0e\n\
    \x06\x04\x86\x01\x02\0\x04\x12\x04\xad\x0b\x08\x10\n\x0e\n\x06\x04\x86\
    \x01\x02\0\x05\x12\x04\xad\x0b\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\0\x01\
    \x12\x04\xad\x0b\x18&\n\x0e\n\x06\x04\x86\x01\x02\0\x03\x12\x04\xad\x0b)\
    *\n\r\n\x05\x04\x86\x01\x02\x01\x12\x04\xae\x0b\x08/\n\x0e\n\x06\x04\x86\
    \x01\x02\x01\x04\x12\x04\xae\x0b\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x01\
    \x05\x12\x04\xae\x0b\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x01\x01\x12\x04\
    \xae\x0b\x18*\n\x0e\n\x06\x04\x86\x01\x02\x01\x03\x12\x04\xae\x0b-.\n\r\
    \n\x05\x04\x86\x01\x02\x02\x12\x04\xaf\x0b\x08%\n\x0e\n\x06\x04\x86\x01\
    \x02\x02\x04\x12\x04\xaf\x0b\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x02\x05\
    \x12\x04\xaf\x0b\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x02\x01\x12\x04\xaf\
    \x0b\x18\x20\n\x0e\n\x06\x04\x86\x01\x02\x02\x03\x12\x04\xaf\x0b#$\n\r\n\
    \x05\x04\x86\x01\x02\x03\x12\x04\xb0\x0b\x08(\n\x0e\n\x06\x04\x86\x01\
    \x02\x03\x04\x12\x04\xb0\x0b\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x03\x05\
    \x12\x04\xb0\x0b\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x03\x01\x12\x04\xb0\
    \x0b\x18#\n\x0e\n\x06\x04\x86\x01\x02\x03\x03\x12\x04\xb0\x0b&'\n\r\n\
    \x05\x04\x86\x01\x02\x04\x12\x04\xb1\x0b\x08,\n\x0e\n\x06\x04\x86\x01\
    \x02\x04\x04\x12\x04\xb1\x0b\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x04\x05\
    \x12\x04\xb1\x0b\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x04\x01\x12\x04\xb1\
    \x0b\x18'\n\x0e\n\x06\x04\x86\x01\x02\x04\x03\x12\x04\xb1\x0b*+\n\r\n\
    \x05\x04\x86\x01\x02\x05\x12\x04\xb2\x0b\x08,\n\x0e\n\x06\x04\x86\x01\
    \x02\x05\x04\x12\x04\xb2\x0b\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x05\x05\
    \x12\x04\xb2\x0b\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x05\x01\x12\x04\xb2\
    \x0b\x18'\n\x0e\n\x06\x04\x86\x01\x02\x05\x03\x12\x04\xb2\x0b*+\n\r\n\
    \x05\x04\x86\x01\x02\x06\x12\x04\xb3\x0b\x08/\n\x0e\n\x06\x04\x86\x01\
    \x02\x06\x04\x12\x04\xb3\x0b\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x06\x05\
    \x12\x04\xb3\x0b\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x06\x01\x12\x04\xb3\
    \x0b\x18*\n\x0e\n\x06\x04\x86\x01\x02\x06\x03\x12\x04\xb3\x0b-.\n\r\n\
    \x03\x04\x87\x01\x12\x06\xb6\x0b\0\xbb\x0b\x01\n\x0c\n\x04\x04\x87\x01\
    \x01\x12\x04\xb6\x0b\x08%\n\r\n\x05\x04\x87\x01\x02\0\x12\x04\xb7\x0b\
    \x08%\n\x0e\n\x06\x04\x87\x01\x02\0\x04\x12\x04\xb7\x0b\x08\x10\n\x0e\n\
    \x06\x04\x87\x01\x02\0\x05\x12\x04\xb7\x0b\x11\x16\n\x0e\n\x06\x04\x87\
    \x01\x02\0\x01\x12\x04\xb7\x0b\x17\x20\n\x0e\n\x06\x04\x87\x01\x02\0\x03\
    \x12\x04\xb7\x0b#$\n\r\n\x05\x04\x87\x01\x02\x01\x12\x04\xb8\x0b\x08+\n\
    \x0e\n\x06\x04\x87\x01\x02\x01\x04\x12\x04\xb8\x0b\x08\x10\n\x0e\n\x06\
    \x04\x87\x01\x02\x01\x05\x12\x04\xb8\x0b\x11\x16\n\x0e\n\x06\x04\x87\x01\
    \x02\x01\x01\x12\x04\xb8\x0b\x17&\n\x0e\n\x06\x04\x87\x01\x02\x01\x03\
    \x12\x04\xb8\x0b)*\n\r\n\x05\x04\x87\x01\x02\x02\x12\x04\xb9\x0b\x08&\n\
    \x0e\n\x06\x04\x87\x01\x02\x02\x04\x12\x04\xb9\x0b\x08\x10\n\x0e\n\x06\
    \x04\x87\x01\x02\x02\x05\x12\x04\xb9\x0b\x11\x17\n\x0e\n\x06\x04\x87\x01\
    \x02\x02\x01\x12\x04\xb9\x0b\x18!\n\x0e\n\x06\x04\x87\x01\x02\x02\x03\
    \x12\x04\xb9\x0b$%\n\r\n\x05\x04\x87\x01\x02\x03\x12\x04\xba\x0b\x08,\n\
    \x0e\n\x06\x04\x87\x01\x02\x03\x04\x12\x04\xba\x0b\x08\x10\n\x0e\n\x06\
    \x04\x87\x01\x02\x03\x05\x12\x04\xba\x0b\x11\x17\n\x0e\n\x06\x04\x87\x01\
    \x02\x03\x01\x12\x04\xba\x0b\x18'\n\x0e\n\x06\x04\x87\x01\x02\x03\x03\
    \x12\x04\xba\x0b*+\n\r\n\x03\x04\x88\x01\x12\x06\xbd\x0b\0\xc0\x0b\x01\n\
    \x0c\n\x04\x04\x88\x01\x01\x12\x04\xbd\x0b\x08$\n\r\n\x05\x04\x88\x01\
    \x02\0\x12\x04\xbe\x0b\x08,\n\x0e\n\x06\x04\x88\x01\x02\0\x04\x12\x04\
    \xbe\x0b\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\0\x05\x12\x04\xbe\x0b\x11\
    \x16\n\x0e\n\x06\x04\x88\x01\x02\0\x01\x12\x04\xbe\x0b\x17'\n\x0e\n\x06\
    \x04\x88\x01\x02\0\x03\x12\x04\xbe\x0b*+\n\r\n\x05\x04\x88\x01\x02\x01\
    \x12\x04\xbf\x0b\x08$\n\x0e\n\x06\x04\x88\x01\x02\x01\x04\x12\x04\xbf\
    \x0b\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x01\x05\x12\x04\xbf\x0b\x11\x17\
    \n\x0e\n\x06\x04\x88\x01\x02\x01\x01\x12\x04\xbf\x0b\x18\x1f\n\x0e\n\x06\
    \x04\x88\x01\x02\x01\x03\x12\x04\xbf\x0b\"#\n\r\n\x03\x04\x89\x01\x12\
    \x06\xc2\x0b\0\xc5\x0b\x01\n\x0c\n\x04\x04\x89\x01\x01\x12\x04\xc2\x0b\
    \x08%\n\r\n\x05\x04\x89\x01\x02\0\x12\x04\xc3\x0b\x08$\n\x0e\n\x06\x04\
    \x89\x01\x02\0\x04\x12\x04\xc3\x0b\x08\x10\n\x0e\n\x06\x04\x89\x01\x02\0\
    \x05\x12\x04\xc3\x0b\x11\x17\n\x0e\n\x06\x04\x89\x01\x02\0\x01\x12\x04\
    \xc3\x0b\x18\x1f\n\x0e\n\x06\x04\x89\x01\x02\0\x03\x12\x04\xc3\x0b\"#\n\
    \r\n\x05\x04\x89\x01\x02\x01\x12\x04\xc4\x0b\x08&\n\x0e\n\x06\x04\x89\
    \x01\x02\x01\x04\x12\x04\xc4\x0b\x08\x10\n\x0e\n\x06\x04\x89\x01\x02\x01\
    \x05\x12\x04\xc4\x0b\x11\x17\n\x0e\n\x06\x04\x89\x01\x02\x01\x01\x12\x04\
    \xc4\x0b\x18!\n\x0e\n\x06\x04\x89\x01\x02\x01\x03\x12\x04\xc4\x0b$%\n\r\
    \n\x03\x04\x8a\x01\x12\x06\xc7\x0b\0\xc9\x0b\x01\n\x0c\n\x04\x04\x8a\x01\
    \x01\x12\x04\xc7\x0b\x08%\n\r\n\x05\x04\x8a\x01\x02\0\x12\x04\xc8\x0b\
    \x08)\n\x0e\n\x06\x04\x8a\x01\x02\0\x04\x12\x04\xc8\x0b\x08\x10\n\x0e\n\
    \x06\x04\x8a\x01\x02\0\x05\x12\x04\xc8\x0b\x11\x17\n\x0e\n\x06\x04\x8a\
    \x01\x02\0\x01\x12\x04\xc8\x0b\x18$\n\x0e\n\x06\x04\x8a\x01\x02\0\x03\
    \x12\x04\xc8\x0b'(\n\r\n\x03\x04\x8b\x01\x12\x06\xcb\x0b\0\xd3\x0b\x01\n\
    \x0c\n\x04\x04\x8b\x01\x01\x12\x04\xcb\x0b\x08&\n\x0f\n\x05\x04\x8b\x01\
    \x03\0\x12\x06\xcc\x0b\x08\xd0\x0b\t\n\x0e\n\x06\x04\x8b\x01\x03\0\x01\
    \x12\x04\xcc\x0b\x10\x17\n\x0f\n\x07\x04\x8b\x01\x03\0\x02\0\x12\x04\xcd\
    \x0b\x10*\n\x10\n\x08\x04\x8b\x01\x03\0\x02\0\x04\x12\x04\xcd\x0b\x10\
    \x18\n\x10\n\x08\x04\x8b\x01\x03\0\x02\0\x05\x12\x04\xcd\x0b\x19\x1f\n\
    \x10\n\x08\x04\x8b\x01\x03\0\x02\0\x01\x12\x04\xcd\x0b\x20%\n\x10\n\x08\
    \x04\x8b\x01\x03\0\x02\0\x03\x12\x04\xcd\x0b()\n\x0f\n\x07\x04\x8b\x01\
    \x03\0\x02\x01\x12\x04\xce\x0b\x10(\n\x10\n\x08\x04\x8b\x01\x03\0\x02\
    \x01\x04\x12\x04\xce\x0b\x10\x18\n\x10\n\x08\x04\x8b\x01\x03\0\x02\x01\
    \x05\x12\x04\xce\x0b\x19\x1e\n\x10\n\x08\x04\x8b\x01\x03\0\x02\x01\x01\
    \x12\x04\xce\x0b\x1f#\n\x10\n\x08\x04\x8b\x01\x03\0\x02\x01\x03\x12\x04\
    \xce\x0b&'\n\x0f\n\x07\x04\x8b\x01\x03\0\x02\x02\x12\x04\xcf\x0b\x10.\n\
    \x10\n\x08\x04\x8b\x01\x03\0\x02\x02\x04\x12\x04\xcf\x0b\x10\x18\n\x10\n\
    \x08\x04\x8b\x01\x03\0\x02\x02\x05\x12\x04\xcf\x0b\x19\x1e\n\x10\n\x08\
    \x04\x8b\x01\x03\0\x02\x02\x01\x12\x04\xcf\x0b\x1f)\n\x10\n\x08\x04\x8b\
    \x01\x03\0\x02\x02\x03\x12\x04\xcf\x0b,-\n\r\n\x05\x04\x8b\x01\x02\0\x12\
    \x04\xd2\x0b\x08F\n\x0e\n\x06\x04\x8b\x01\x02\0\x04\x12\x04\xd2\x0b\x08\
    \x10\n\x0e\n\x06\x04\x8b\x01\x02\0\x06\x12\x04\xd2\x0b\x117\n\x0e\n\x06\
    \x04\x8b\x01\x02\0\x01\x12\x04\xd2\x0b8A\n\x0e\n\x06\x04\x8b\x01\x02\0\
    \x03\x12\x04\xd2\x0bDE\n\r\n\x03\x04\x8c\x01\x12\x06\xd5\x0b\0\xdb\x0b\
    \x01\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xd5\x0b\x08/\n\r\n\x05\x04\x8c\
    \x01\x02\0\x12\x04\xd6\x0b\x08%\n\x0e\n\x06\x04\x8c\x01\x02\0\x04\x12\
    \x04\xd6\x0b\x08\x10\n\x0e\n\x06\x04\x8c\x01\x02\0\x05\x12\x04\xd6\x0b\
    \x11\x16\n\x0e\n\x06\x04\x8c\x01\x02\0\x01\x12\x04\xd6\x0b\x17\x20\n\x0e\
    \n\x06\x04\x8c\x01\x02\0\x03\x12\x04\xd6\x0b#$\n\r\n\x05\x04\x8c\x01\x02\
    \x01\x12\x04\xd7\x0b\x08=\n\x0e\n\x06\x04\x8c\x01\x02\x01\x04\x12\x04\
    \xd7\x0b\x08\x10\n\x0e\n\x06\x04\x8c\x01\x02\x01\x06\x12\x04\xd7\x0b\x11\
    /\n\x0e\n\x06\x04\x8c\x01\x02\x01\x01\x12\x04\xd7\x0b08\n\x0e\n\x06\x04\
    \x8c\x01\x02\x01\x03\x12\x04\xd7\x0b;<\n\r\n\x05\x04\x8c\x01\x02\x02\x12\
    \x04\xd8\x0b\x08<\n\x0e\n\x06\x04\x8c\x01\x02\x02\x04\x12\x04\xd8\x0b\
    \x08\x10\n\x0e\n\x06\x04\x8c\x01\x02\x02\x06\x12\x04\xd8\x0b\x11)\n\x0e\
    \n\x06\x04\x8c\x01\x02\x02\x01\x12\x04\xd8\x0b*7\n\x0e\n\x06\x04\x8c\x01\
    \x02\x02\x03\x12\x04\xd8\x0b:;\n\r\n\x05\x04\x8c\x01\x02\x03\x12\x04\xd9\
    \x0b\x086\n\x0e\n\x06\x04\x8c\x01\x02\x03\x04\x12\x04\xd9\x0b\x08\x10\n\
    \x0e\n\x06\x04\x8c\x01\x02\x03\x06\x12\x04\xd9\x0b\x11&\n\x0e\n\x06\x04\
    \x8c\x01\x02\x03\x01\x12\x04\xd9\x0b'1\n\x0e\n\x06\x04\x8c\x01\x02\x03\
    \x03\x12\x04\xd9\x0b45\n\r\n\x05\x04\x8c\x01\x02\x04\x12\x04\xda\x0b\x08\
    <\n\x0e\n\x06\x04\x8c\x01\x02\x04\x04\x12\x04\xda\x0b\x08\x10\n\x0e\n\
    \x06\x04\x8c\x01\x02\x04\x06\x12\x04\xda\x0b\x11)\n\x0e\n\x06\x04\x8c\
    \x01\x02\x04\x01\x12\x04\xda\x0b*7\n\x0e\n\x06\x04\x8c\x01\x02\x04\x03\
    \x12\x04\xda\x0b:;\n\r\n\x03\x04\x8d\x01\x12\x06\xdd\x0b\0\xe2\x0b\x01\n\
    \x0c\n\x04\x04\x8d\x01\x01\x12\x04\xdd\x0b\x08&\n\r\n\x05\x04\x8d\x01\
    \x02\0\x12\x04\xde\x0b\x08$\n\x0e\n\x06\x04\x8d\x01\x02\0\x04\x12\x04\
    \xde\x0b\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\0\x05\x12\x04\xde\x0b\x11\
    \x17\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xde\x0b\x18\x1f\n\x0e\n\
    \x06\x04\x8d\x01\x02\0\x03\x12\x04\xde\x0b\"#\n\r\n\x05\x04\x8d\x01\x02\
    \x01\x12\x04\xdf\x0b\x08)\n\x0e\n\x06\x04\x8d\x01\x02\x01\x04\x12\x04\
    \xdf\x0b\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\x01\x05\x12\x04\xdf\x0b\x11\
    \x17\n\x0e\n\x06\x04\x8d\x01\x02\x01\x01\x12\x04\xdf\x0b\x18$\n\x0e\n\
    \x06\x04\x8d\x01\x02\x01\x03\x12\x04\xdf\x0b'(\n\r\n\x05\x04\x8d\x01\x02\
    \x02\x12\x04\xe0\x0b\x08(\n\x0e\n\x06\x04\x8d\x01\x02\x02\x04\x12\x04\
    \xe0\x0b\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\x02\x05\x12\x04\xe0\x0b\x11\
    \x17\n\x0e\n\x06\x04\x8d\x01\x02\x02\x01\x12\x04\xe0\x0b\x18#\n\x0e\n\
    \x06\x04\x8d\x01\x02\x02\x03\x12\x04\xe0\x0b&'\n\r\n\x05\x04\x8d\x01\x02\
    \x03\x12\x04\xe1\x0b\x08+\n\x0e\n\x06\x04\x8d\x01\x02\x03\x04\x12\x04\
    \xe1\x0b\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\x03\x05\x12\x04\xe1\x0b\x11\
    \x17\n\x0e\n\x06\x04\x8d\x01\x02\x03\x01\x12\x04\xe1\x0b\x18&\n\x0e\n\
    \x06\x04\x8d\x01\x02\x03\x03\x12\x04\xe1\x0b)*\n\r\n\x03\x04\x8e\x01\x12\
    \x06\xe4\x0b\0\xe7\x0b\x01\n\x0c\n\x04\x04\x8e\x01\x01\x12\x04\xe4\x0b\
    \x08&\n\r\n\x05\x04\x8e\x01\x02\0\x12\x04\xe5\x0b\x08'\n\x0e\n\x06\x04\
    \x8e\x01\x02\0\x04\x12\x04\xe5\x0b\x08\x10\n\x0e\n\x06\x04\x8e\x01\x02\0\
    \x05\x12\x04\xe5\x0b\x11\x16\n\x0e\n\x06\x04\x8e\x01\x02\0\x01\x12\x04\
    \xe5\x0b\x17\"\n\x0e\n\x06\x04\x8e\x01\x02\0\x03\x12\x04\xe5\x0b%&\n\r\n\
    \x05\x04\x8e\x01\x02\x01\x12\x04\xe6\x0b\x08'\n\x0e\n\x06\x04\x8e\x01\
    \x02\x01\x04\x12\x04\xe6\x0b\x08\x10\n\x0e\n\x06\x04\x8e\x01\x02\x01\x05\
    \x12\x04\xe6\x0b\x11\x16\n\x0e\n\x06\x04\x8e\x01\x02\x01\x01\x12\x04\xe6\
    \x0b\x17\"\n\x0e\n\x06\x04\x8e\x01\x02\x01\x03\x12\x04\xe6\x0b%&\n\r\n\
    \x03\x04\x8f\x01\x12\x06\xe9\x0b\0\xeb\x0b\x01\n\x0c\n\x04\x04\x8f\x01\
    \x01\x12\x04\xe9\x0b\x08'\n\r\n\x05\x04\x8f\x01\x02\0\x12\x04\xea\x0b\
    \x08%\n\x0e\n\x06\x04\x8f\x01\x02\0\x04\x12\x04\xea\x0b\x08\x10\n\x0e\n\
    \x06\x04\x8f\x01\x02\0\x05\x12\x04\xea\x0b\x11\x16\n\x0e\n\x06\x04\x8f\
    \x01\x02\0\x01\x12\x04\xea\x0b\x17\x20\n\x0e\n\x06\x04\x8f\x01\x02\0\x03\
    \x12\x04\xea\x0b#$\n\r\n\x03\x04\x90\x01\x12\x06\xed\x0b\0\xf1\x0b\x01\n\
    \x0c\n\x04\x04\x90\x01\x01\x12\x04\xed\x0b\x08'\n\r\n\x05\x04\x90\x01\
    \x02\0\x12\x04\xee\x0b\x08$\n\x0e\n\x06\x04\x90\x01\x02\0\x04\x12\x04\
    \xee\x0b\x08\x10\n\x0e\n\x06\x04\x90\x01\x02\0\x05\x12\x04\xee\x0b\x11\
    \x17\n\x0e\n\x06\x04\x90\x01\x02\0\x01\x12\x04\xee\x0b\x18\x1f\n\x0e\n\
    \x06\x04\x90\x01\x02\0\x03\x12\x04\xee\x0b\"#\n\r\n\x05\x04\x90\x01\x02\
    \x01\x12\x04\xef\x0b\x08)\n\x0e\n\x06\x04\x90\x01\x02\x01\x04\x12\x04\
    \xef\x0b\x08\x10\n\x0e\n\x06\x04\x90\x01\x02\x01\x05\x12\x04\xef\x0b\x11\
    \x17\n\x0e\n\x06\x04\x90\x01\x02\x01\x01\x12\x04\xef\x0b\x18$\n\x0e\n\
    \x06\x04\x90\x01\x02\x01\x03\x12\x04\xef\x0b'(\n\r\n\x05\x04\x90\x01\x02\
    \x02\x12\x04\xf0\x0b\x08$\n\x0e\n\x06\x04\x90\x01\x02\x02\x04\x12\x04\
    \xf0\x0b\x08\x10\n\x0e\n\x06\x04\x90\x01\x02\x02\x05\x12\x04\xf0\x0b\x11\
    \x17\n\x0e\n\x06\x04\x90\x01\x02\x02\x01\x12\x04\xf0\x0b\x18\x1f\n\x0e\n\
    \x06\x04\x90\x01\x02\x02\x03\x12\x04\xf0\x0b\"#\n\r\n\x03\x04\x91\x01\
    \x12\x06\xf3\x0b\0\x86\x0c\x01\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\xf3\
    \x0b\x08,\n\x0f\n\x05\x04\x91\x01\x03\0\x12\x06\xf4\x0b\x08\xf7\x0b\t\n\
    \x0e\n\x06\x04\x91\x01\x03\0\x01\x12\x04\xf4\x0b\x10\x1e\n\x0f\n\x07\x04\
    \x91\x01\x03\0\x02\0\x12\x04\xf5\x0b\x10-\n\x10\n\x08\x04\x91\x01\x03\0\
    \x02\0\x04\x12\x04\xf5\x0b\x10\x18\n\x10\n\x08\x04\x91\x01\x03\0\x02\0\
    \x05\x12\x04\xf5\x0b\x19\x1e\n\x10\n\x08\x04\x91\x01\x03\0\x02\0\x01\x12\
    \x04\xf5\x0b\x1f(\n\x10\n\x08\x04\x91\x01\x03\0\x02\0\x03\x12\x04\xf5\
    \x0b+,\n\x0f\n\x07\x04\x91\x01\x03\0\x02\x01\x12\x04\xf6\x0b\x10-\n\x10\
    \n\x08\x04\x91\x01\x03\0\x02\x01\x04\x12\x04\xf6\x0b\x10\x18\n\x10\n\x08\
    \x04\x91\x01\x03\0\x02\x01\x05\x12\x04\xf6\x0b\x19\x1f\n\x10\n\x08\x04\
    \x91\x01\x03\0\x02\x01\x01\x12\x04\xf6\x0b\x20(\n\x10\n\x08\x04\x91\x01\
    \x03\0\x02\x01\x03\x12\x04\xf6\x0b+,\n\x0f\n\x05\x04\x91\x01\x04\0\x12\
    \x06\xf9\x0b\x08\xfd\x0b\t\n\x0e\n\x06\x04\x91\x01\x04\0\x01\x12\x04\xf9\
    \x0b\r\x1b\n\x0f\n\x07\x04\x91\x01\x04\0\x02\0\x12\x04\xfa\x0b\x10-\n\
    \x10\n\x08\x04\x91\x01\x04\0\x02\0\x01\x12\x04\xfa\x0b\x10(\n\x10\n\x08\
    \x04\x91\x01\x04\0\x02\0\x02\x12\x04\xfa\x0b+,\n\x0f\n\x07\x04\x91\x01\
    \x04\0\x02\x01\x12\x04\xfb\x0b\x101\n\x10\n\x08\x04\x91\x01\x04\0\x02\
    \x01\x01\x12\x04\xfb\x0b\x10,\n\x10\n\x08\x04\x91\x01\x04\0\x02\x01\x02\
    \x12\x04\xfb\x0b/0\n\x0f\n\x07\x04\x91\x01\x04\0\x02\x02\x12\x04\xfc\x0b\
    \x10.\n\x10\n\x08\x04\x91\x01\x04\0\x02\x02\x01\x12\x04\xfc\x0b\x10)\n\
    \x10\n\x08\x04\x91\x01\x04\0\x02\x02\x02\x12\x04\xfc\x0b,-\n\r\n\x05\x04\
    \x91\x01\x02\0\x12\x04\xff\x0b\x08Y\n\x0e\n\x06\x04\x91\x01\x02\0\x04\
    \x12\x04\xff\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\0\x06\x12\x04\xff\
    \x0b\x11D\n\x0e\n\x06\x04\x91\x01\x02\0\x01\x12\x04\xff\x0bET\n\x0e\n\
    \x06\x04\x91\x01\x02\0\x03\x12\x04\xff\x0bWX\n\r\n\x05\x04\x91\x01\x02\
    \x01\x12\x04\x80\x0c\x08%\n\x0e\n\x06\x04\x91\x01\x02\x01\x04\x12\x04\
    \x80\x0c\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x01\x05\x12\x04\x80\x0c\x11\
    \x17\n\x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\x04\x80\x0c\x18\x20\n\x0e\n\
    \x06\x04\x91\x01\x02\x01\x03\x12\x04\x80\x0c#$\n\r\n\x05\x04\x91\x01\x02\
    \x02\x12\x04\x81\x0c\x082\n\x0e\n\x06\x04\x91\x01\x02\x02\x04\x12\x04\
    \x81\x0c\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x02\x05\x12\x04\x81\x0c\x11\
    \x17\n\x0e\n\x06\x04\x91\x01\x02\x02\x01\x12\x04\x81\x0c\x18-\n\x0e\n\
    \x06\x04\x91\x01\x02\x02\x03\x12\x04\x81\x0c01\n\r\n\x05\x04\x91\x01\x02\
    \x03\x12\x04\x82\x0c\x080\n\x0e\n\x06\x04\x91\x01\x02\x03\x04\x12\x04\
    \x82\x0c\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x03\x05\x12\x04\x82\x0c\x11\
    \x17\n\x0e\n\x06\x04\x91\x01\x02\x03\x01\x12\x04\x82\x0c\x18+\n\x0e\n\
    \x06\x04\x91\x01\x02\x03\x03\x12\x04\x82\x0c./\n\r\n\x05\x04\x91\x01\x02\
    \x04\x12\x04\x83\x0c\x08X\n\x0e\n\x06\x04\x91\x01\x02\x04\x04\x12\x04\
    \x83\x0c\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x04\x06\x12\x04\x83\x0c\x11\
    D\n\x0e\n\x06\x04\x91\x01\x02\x04\x01\x12\x04\x83\x0cES\n\x0e\n\x06\x04\
    \x91\x01\x02\x04\x03\x12\x04\x83\x0cVW\n\r\n\x05\x04\x91\x01\x02\x05\x12\
    \x04\x84\x0c\x088\n\x0e\n\x06\x04\x91\x01\x02\x05\x04\x12\x04\x84\x0c\
    \x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x05\x05\x12\x04\x84\x0c\x11\x17\n\
    \x0e\n\x06\x04\x91\x01\x02\x05\x01\x12\x04\x84\x0c\x183\n\x0e\n\x06\x04\
    \x91\x01\x02\x05\x03\x12\x04\x84\x0c67\n\r\n\x05\x04\x91\x01\x02\x06\x12\
    \x04\x85\x0c\x08#\n\x0e\n\x06\x04\x91\x01\x02\x06\x04\x12\x04\x85\x0c\
    \x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x06\x05\x12\x04\x85\x0c\x11\x15\n\
    \x0e\n\x06\x04\x91\x01\x02\x06\x01\x12\x04\x85\x0c\x16\x1e\n\x0e\n\x06\
    \x04\x91\x01\x02\x06\x03\x12\x04\x85\x0c!\"\n\r\n\x03\x04\x92\x01\x12\
    \x06\x88\x0c\0\x90\x0c\x01\n\x0c\n\x04\x04\x92\x01\x01\x12\x04\x88\x0c\
    \x08%\n\r\n\x05\x04\x92\x01\x02\0\x12\x04\x89\x0c\x08$\n\x0e\n\x06\x04\
    \x92\x01\x02\0\x04\x12\x04\x89\x0c\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\0\
    \x05\x12\x04\x89\x0c\x11\x17\n\x0e\n\x06\x04\x92\x01\x02\0\x01\x12\x04\
    \x89\x0c\x18\x1f\n\x0e\n\x06\x04\x92\x01\x02\0\x03\x12\x04\x89\x0c\"#\n\
    \r\n\x05\x04\x92\x01\x02\x01\x12\x04\x8a\x0c\x08+\n\x0e\n\x06\x04\x92\
    \x01\x02\x01\x04\x12\x04\x8a\x0c\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\x01\
    \x05\x12\x04\x8a\x0c\x11\x17\n\x0e\n\x06\x04\x92\x01\x02\x01\x01\x12\x04\
    \x8a\x0c\x18&\n\x0e\n\x06\x04\x92\x01\x02\x01\x03\x12\x04\x8a\x0c)*\n\r\
    \n\x05\x04\x92\x01\x02\x02\x12\x04\x8b\x0c\x08*\n\x0e\n\x06\x04\x92\x01\
    \x02\x02\x04\x12\x04\x8b\x0c\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\x02\x05\
    \x12\x04\x8b\x0c\x11\x17\n\x0e\n\x06\x04\x92\x01\x02\x02\x01\x12\x04\x8b\
    \x0c\x18%\n\x0e\n\x06\x04\x92\x01\x02\x02\x03\x12\x04\x8b\x0c()\n\r\n\
    \x05\x04\x92\x01\x02\x03\x12\x04\x8c\x0c\x08)\n\x0e\n\x06\x04\x92\x01\
    \x02\x03\x04\x12\x04\x8c\x0c\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\x03\x05\
    \x12\x04\x8c\x0c\x11\x17\n\x0e\n\x06\x04\x92\x01\x02\x03\x01\x12\x04\x8c\
    \x0c\x18$\n\x0e\n\x06\x04\x92\x01\x02\x03\x03\x12\x04\x8c\x0c'(\n\r\n\
    \x05\x04\x92\x01\x02\x04\x12\x04\x8d\x0c\x08&\n\x0e\n\x06\x04\x92\x01\
    \x02\x04\x04\x12\x04\x8d\x0c\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\x04\x05\
    \x12\x04\x8d\x0c\x11\x17\n\x0e\n\x06\x04\x92\x01\x02\x04\x01\x12\x04\x8d\
    \x0c\x18!\n\x0e\n\x06\x04\x92\x01\x02\x04\x03\x12\x04\x8d\x0c$%\n\r\n\
    \x05\x04\x92\x01\x02\x05\x12\x04\x8e\x0c\x08*\n\x0e\n\x06\x04\x92\x01\
    \x02\x05\x04\x12\x04\x8e\x0c\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\x05\x05\
    \x12\x04\x8e\x0c\x11\x17\n\x0e\n\x06\x04\x92\x01\x02\x05\x01\x12\x04\x8e\
    \x0c\x18%\n\x0e\n\x06\x04\x92\x01\x02\x05\x03\x12\x04\x8e\x0c()\n\r\n\
    \x05\x04\x92\x01\x02\x06\x12\x04\x8f\x0c\x08)\n\x0e\n\x06\x04\x92\x01\
    \x02\x06\x04\x12\x04\x8f\x0c\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\x06\x05\
    \x12\x04\x8f\x0c\x11\x17\n\x0e\n\x06\x04\x92\x01\x02\x06\x01\x12\x04\x8f\
    \x0c\x18$\n\x0e\n\x06\x04\x92\x01\x02\x06\x03\x12\x04\x8f\x0c'(\n\r\n\
    \x03\x04\x93\x01\x12\x06\x92\x0c\0\x9b\x0c\x01\n\x0c\n\x04\x04\x93\x01\
    \x01\x12\x04\x92\x0c\x08$\n\r\n\x05\x04\x93\x01\x02\0\x12\x04\x93\x0c\
    \x08$\n\x0e\n\x06\x04\x93\x01\x02\0\x04\x12\x04\x93\x0c\x08\x10\n\x0e\n\
    \x06\x04\x93\x01\x02\0\x05\x12\x04\x93\x0c\x11\x17\n\x0e\n\x06\x04\x93\
    \x01\x02\0\x01\x12\x04\x93\x0c\x18\x1f\n\x0e\n\x06\x04\x93\x01\x02\0\x03\
    \x12\x04\x93\x0c\"#\n\r\n\x05\x04\x93\x01\x02\x01\x12\x04\x94\x0c\x08+\n\
    \x0e\n\x06\x04\x93\x01\x02\x01\x04\x12\x04\x94\x0c\x08\x10\n\x0e\n\x06\
    \x04\x93\x01\x02\x01\x05\x12\x04\x94\x0c\x11\x17\n\x0e\n\x06\x04\x93\x01\
    \x02\x01\x01\x12\x04\x94\x0c\x18&\n\x0e\n\x06\x04\x93\x01\x02\x01\x03\
    \x12\x04\x94\x0c)*\n\r\n\x05\x04\x93\x01\x02\x02\x12\x04\x95\x0c\x08*\n\
    \x0e\n\x06\x04\x93\x01\x02\x02\x04\x12\x04\x95\x0c\x08\x10\n\x0e\n\x06\
    \x04\x93\x01\x02\x02\x05\x12\x04\x95\x0c\x11\x17\n\x0e\n\x06\x04\x93\x01\
    \x02\x02\x01\x12\x04\x95\x0c\x18%\n\x0e\n\x06\x04\x93\x01\x02\x02\x03\
    \x12\x04\x95\x0c()\n\r\n\x05\x04\x93\x01\x02\x03\x12\x04\x96\x0c\x08)\n\
    \x0e\n\x06\x04\x93\x01\x02\x03\x04\x12\x04\x96\x0c\x08\x10\n\x0e\n\x06\
    \x04\x93\x01\x02\x03\x05\x12\x04\x96\x0c\x11\x17\n\x0e\n\x06\x04\x93\x01\
    \x02\x03\x01\x12\x04\x96\x0c\x18$\n\x0e\n\x06\x04\x93\x01\x02\x03\x03\
    \x12\x04\x96\x0c'(\n\r\n\x05\x04\x93\x01\x02\x04\x12\x04\x97\x0c\x08&\n\
    \x0e\n\x06\x04\x93\x01\x02\x04\x04\x12\x04\x97\x0c\x08\x10\n\x0e\n\x06\
    \x04\x93\x01\x02\x04\x05\x12\x04\x97\x0c\x11\x17\n\x0e\n\x06\x04\x93\x01\
    \x02\x04\x01\x12\x04\x97\x0c\x18!\n\x0e\n\x06\x04\x93\x01\x02\x04\x03\
    \x12\x04\x97\x0c$%\n\r\n\x05\x04\x93\x01\x02\x05\x12\x04\x98\x0c\x08*\n\
    \x0e\n\x06\x04\x93\x01\x02\x05\x04\x12\x04\x98\x0c\x08\x10\n\x0e\n\x06\
    \x04\x93\x01\x02\x05\x05\x12\x04\x98\x0c\x11\x17\n\x0e\n\x06\x04\x93\x01\
    \x02\x05\x01\x12\x04\x98\x0c\x18%\n\x0e\n\x06\x04\x93\x01\x02\x05\x03\
    \x12\x04\x98\x0c()\n\r\n\x05\x04\x93\x01\x02\x06\x12\x04\x99\x0c\x08)\n\
    \x0e\n\x06\x04\x93\x01\x02\x06\x04\x12\x04\x99\x0c\x08\x10\n\x0e\n\x06\
    \x04\x93\x01\x02\x06\x05\x12\x04\x99\x0c\x11\x17\n\x0e\n\x06\x04\x93\x01\
    \x02\x06\x01\x12\x04\x99\x0c\x18$\n\x0e\n\x06\x04\x93\x01\x02\x06\x03\
    \x12\x04\x99\x0c'(\n\r\n\x05\x04\x93\x01\x02\x07\x12\x04\x9a\x0c\x08\"\n\
    \x0e\n\x06\x04\x93\x01\x02\x07\x04\x12\x04\x9a\x0c\x08\x10\n\x0e\n\x06\
    \x04\x93\x01\x02\x07\x05\x12\x04\x9a\x0c\x11\x15\n\x0e\n\x06\x04\x93\x01\
    \x02\x07\x01\x12\x04\x9a\x0c\x16\x1d\n\x0e\n\x06\x04\x93\x01\x02\x07\x03\
    \x12\x04\x9a\x0c\x20!\n\r\n\x03\x04\x94\x01\x12\x06\x9d\x0c\0\xa2\x0c\
    \x01\n\x0c\n\x04\x04\x94\x01\x01\x12\x04\x9d\x0c\x08'\n\r\n\x05\x04\x94\
    \x01\x02\0\x12\x04\x9e\x0c\x08,\n\x0e\n\x06\x04\x94\x01\x02\0\x04\x12\
    \x04\x9e\x0c\x08\x10\n\x0e\n\x06\x04\x94\x01\x02\0\x05\x12\x04\x9e\x0c\
    \x11\x16\n\x0e\n\x06\x04\x94\x01\x02\0\x01\x12\x04\x9e\x0c\x17'\n\x0e\n\
    \x06\x04\x94\x01\x02\0\x03\x12\x04\x9e\x0c*+\n\r\n\x05\x04\x94\x01\x02\
    \x01\x12\x04\x9f\x0c\x08,\n\x0e\n\x06\x04\x94\x01\x02\x01\x04\x12\x04\
    \x9f\x0c\x08\x10\n\x0e\n\x06\x04\x94\x01\x02\x01\x05\x12\x04\x9f\x0c\x11\
    \x16\n\x0e\n\x06\x04\x94\x01\x02\x01\x01\x12\x04\x9f\x0c\x17'\n\x0e\n\
    \x06\x04\x94\x01\x02\x01\x03\x12\x04\x9f\x0c*+\n\r\n\x05\x04\x94\x01\x02\
    \x02\x12\x04\xa0\x0c\x08&\n\x0e\n\x06\x04\x94\x01\x02\x02\x04\x12\x04\
    \xa0\x0c\x08\x10\n\x0e\n\x06\x04\x94\x01\x02\x02\x05\x12\x04\xa0\x0c\x11\
    \x16\n\x0e\n\x06\x04\x94\x01\x02\x02\x01\x12\x04\xa0\x0c\x17!\n\x0e\n\
    \x06\x04\x94\x01\x02\x02\x03\x12\x04\xa0\x0c$%\n\r\n\x05\x04\x94\x01\x02\
    \x03\x12\x04\xa1\x0c\x08,\n\x0e\n\x06\x04\x94\x01\x02\x03\x04\x12\x04\
    \xa1\x0c\x08\x10\n\x0e\n\x06\x04\x94\x01\x02\x03\x05\x12\x04\xa1\x0c\x11\
    \x16\n\x0e\n\x06\x04\x94\x01\x02\x03\x01\x12\x04\xa1\x0c\x17'\n\x0e\n\
    \x06\x04\x94\x01\x02\x03\x03\x12\x04\xa1\x0c*+\n\r\n\x03\x04\x95\x01\x12\
    \x06\xa4\x0c\0\xab\x0c\x01\n\x0c\n\x04\x04\x95\x01\x01\x12\x04\xa4\x0c\
    \x08$\n\r\n\x05\x04\x95\x01\x02\0\x12\x04\xa5\x0c\x08,\n\x0e\n\x06\x04\
    \x95\x01\x02\0\x04\x12\x04\xa5\x0c\x08\x10\n\x0e\n\x06\x04\x95\x01\x02\0\
    \x05\x12\x04\xa5\x0c\x11\x16\n\x0e\n\x06\x04\x95\x01\x02\0\x01\x12\x04\
    \xa5\x0c\x17'\n\x0e\n\x06\x04\x95\x01\x02\0\x03\x12\x04\xa5\x0c*+\n\r\n\
    \x05\x04\x95\x01\x02\x01\x12\x04\xa6\x0c\x08,\n\x0e\n\x06\x04\x95\x01\
    \x02\x01\x04\x12\x04\xa6\x0c\x08\x10\n\x0e\n\x06\x04\x95\x01\x02\x01\x05\
    \x12\x04\xa6\x0c\x11\x16\n\x0e\n\x06\x04\x95\x01\x02\x01\x01\x12\x04\xa6\
    \x0c\x17'\n\x0e\n\x06\x04\x95\x01\x02\x01\x03\x12\x04\xa6\x0c*+\n\r\n\
    \x05\x04\x95\x01\x02\x02\x12\x04\xa7\x0c\x08+\n\x0e\n\x06\x04\x95\x01\
    \x02\x02\x04\x12\x04\xa7\x0c\x08\x10\n\x0e\n\x06\x04\x95\x01\x02\x02\x05\
    \x12\x04\xa7\x0c\x11\x16\n\x0e\n\x06\x04\x95\x01\x02\x02\x01\x12\x04\xa7\
    \x0c\x17&\n\x0e\n\x06\x04\x95\x01\x02\x02\x03\x12\x04\xa7\x0c)*\n\r\n\
    \x05\x04\x95\x01\x02\x03\x12\x04\xa8\x0c\x08'\n\x0e\n\x06\x04\x95\x01\
    \x02\x03\x04\x12\x04\xa8\x0c\x08\x10\n\x0e\n\x06\x04\x95\x01\x02\x03\x05\
    \x12\x04\xa8\x0c\x11\x17\n\x0e\n\x06\x04\x95\x01\x02\x03\x01\x12\x04\xa8\
    \x0c\x18\"\n\x0e\n\x06\x04\x95\x01\x02\x03\x03\x12\x04\xa8\x0c%&\n\r\n\
    \x05\x04\x95\x01\x02\x04\x12\x04\xa9\x0c\x08&\n\x0e\n\x06\x04\x95\x01\
    \x02\x04\x04\x12\x04\xa9\x0c\x08\x10\n\x0e\n\x06\x04\x95\x01\x02\x04\x05\
    \x12\x04\xa9\x0c\x11\x15\n\x0e\n\x06\x04\x95\x01\x02\x04\x01\x12\x04\xa9\
    \x0c\x16!\n\x0e\n\x06\x04\x95\x01\x02\x04\x03\x12\x04\xa9\x0c$%\n\r\n\
    \x05\x04\x95\x01\x02\x05\x12\x04\xaa\x0c\x08$\n\x0e\n\x06\x04\x95\x01\
    \x02\x05\x04\x12\x04\xaa\x0c\x08\x10\n\x0e\n\x06\x04\x95\x01\x02\x05\x05\
    \x12\x04\xaa\x0c\x11\x15\n\x0e\n\x06\x04\x95\x01\x02\x05\x01\x12\x04\xaa\
    \x0c\x16\x1f\n\x0e\n\x06\x04\x95\x01\x02\x05\x03\x12\x04\xaa\x0c\"#\n\r\
    \n\x03\x04\x96\x01\x12\x06\xad\x0c\0\xb0\x0c\x01\n\x0c\n\x04\x04\x96\x01\
    \x01\x12\x04\xad\x0c\x08!\n\r\n\x05\x04\x96\x01\x02\0\x12\x04\xae\x0c\
    \x081\n\x0e\n\x06\x04\x96\x01\x02\0\x04\x12\x04\xae\x0c\x08\x10\n\x0e\n\
    \x06\x04\x96\x01\x02\0\x05\x12\x04\xae\x0c\x11\x16\n\x0e\n\x06\x04\x96\
    \x01\x02\0\x01\x12\x04\xae\x0c\x17,\n\x0e\n\x06\x04\x96\x01\x02\0\x03\
    \x12\x04\xae\x0c/0\n\r\n\x05\x04\x96\x01\x02\x01\x12\x04\xaf\x0c\x082\n\
    \x0e\n\x06\x04\x96\x01\x02\x01\x04\x12\x04\xaf\x0c\x08\x10\n\x0e\n\x06\
    \x04\x96\x01\x02\x01\x05\x12\x04\xaf\x0c\x11\x16\n\x0e\n\x06\x04\x96\x01\
    \x02\x01\x01\x12\x04\xaf\x0c\x17-\n\x0e\n\x06\x04\x96\x01\x02\x01\x03\
    \x12\x04\xaf\x0c01\n\r\n\x03\x04\x97\x01\x12\x06\xb2\x0c\0\xc2\x0c\x01\n\
    \x0c\n\x04\x04\x97\x01\x01\x12\x04\xb2\x0c\x08\"\n\r\n\x05\x04\x97\x01\
    \x02\0\x12\x04\xb3\x0c\x08\"\n\x0e\n\x06\x04\x97\x01\x02\0\x04\x12\x04\
    \xb3\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\0\x05\x12\x04\xb3\x0c\x11\
    \x16\n\x0e\n\x06\x04\x97\x01\x02\0\x01\x12\x04\xb3\x0c\x17\x1d\n\x0e\n\
    \x06\x04\x97\x01\x02\0\x03\x12\x04\xb3\x0c\x20!\n\r\n\x05\x04\x97\x01\
    \x02\x01\x12\x04\xb4\x0c\x081\n\x0e\n\x06\x04\x97\x01\x02\x01\x04\x12\
    \x04\xb4\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\x01\x05\x12\x04\xb4\x0c\
    \x11\x17\n\x0e\n\x06\x04\x97\x01\x02\x01\x01\x12\x04\xb4\x0c\x18,\n\x0e\
    \n\x06\x04\x97\x01\x02\x01\x03\x12\x04\xb4\x0c/0\n\r\n\x05\x04\x97\x01\
    \x02\x02\x12\x04\xb5\x0c\x08-\n\x0e\n\x06\x04\x97\x01\x02\x02\x04\x12\
    \x04\xb5\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\x02\x05\x12\x04\xb5\x0c\
    \x11\x17\n\x0e\n\x06\x04\x97\x01\x02\x02\x01\x12\x04\xb5\x0c\x18(\n\x0e\
    \n\x06\x04\x97\x01\x02\x02\x03\x12\x04\xb5\x0c+,\n\r\n\x05\x04\x97\x01\
    \x02\x03\x12\x04\xb6\x0c\x08-\n\x0e\n\x06\x04\x97\x01\x02\x03\x04\x12\
    \x04\xb6\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\x03\x05\x12\x04\xb6\x0c\
    \x11\x17\n\x0e\n\x06\x04\x97\x01\x02\x03\x01\x12\x04\xb6\x0c\x18(\n\x0e\
    \n\x06\x04\x97\x01\x02\x03\x03\x12\x04\xb6\x0c+,\n\r\n\x05\x04\x97\x01\
    \x02\x04\x12\x04\xb7\x0c\x08+\n\x0e\n\x06\x04\x97\x01\x02\x04\x04\x12\
    \x04\xb7\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\x04\x05\x12\x04\xb7\x0c\
    \x11\x15\n\x0e\n\x06\x04\x97\x01\x02\x04\x01\x12\x04\xb7\x0c\x16&\n\x0e\
    \n\x06\x04\x97\x01\x02\x04\x03\x12\x04\xb7\x0c)*\n\r\n\x05\x04\x97\x01\
    \x02\x05\x12\x04\xb8\x0c\x08#\n\x0e\n\x06\x04\x97\x01\x02\x05\x04\x12\
    \x04\xb8\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\x05\x05\x12\x04\xb8\x0c\
    \x11\x16\n\x0e\n\x06\x04\x97\x01\x02\x05\x01\x12\x04\xb8\x0c\x17\x1e\n\
    \x0e\n\x06\x04\x97\x01\x02\x05\x03\x12\x04\xb8\x0c!\"\n\r\n\x05\x04\x97\
    \x01\x02\x06\x12\x04\xb9\x0c\x08%\n\x0e\n\x06\x04\x97\x01\x02\x06\x04\
    \x12\x04\xb9\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\x06\x05\x12\x04\xb9\
    \x0c\x11\x16\n\x0e\n\x06\x04\x97\x01\x02\x06\x01\x12\x04\xb9\x0c\x17\x20\
    \n\x0e\n\x06\x04\x97\x01\x02\x06\x03\x12\x04\xb9\x0c#$\n\r\n\x05\x04\x97\
    \x01\x02\x07\x12\x04\xba\x0c\x08&\n\x0e\n\x06\x04\x97\x01\x02\x07\x04\
    \x12\x04\xba\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\x07\x05\x12\x04\xba\
    \x0c\x11\x16\n\x0e\n\x06\x04\x97\x01\x02\x07\x01\x12\x04\xba\x0c\x17!\n\
    \x0e\n\x06\x04\x97\x01\x02\x07\x03\x12\x04\xba\x0c$%\n\r\n\x05\x04\x97\
    \x01\x02\x08\x12\x04\xbb\x0c\x08'\n\x0e\n\x06\x04\x97\x01\x02\x08\x04\
    \x12\x04\xbb\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\x08\x05\x12\x04\xbb\
    \x0c\x11\x16\n\x0e\n\x06\x04\x97\x01\x02\x08\x01\x12\x04\xbb\x0c\x17\"\n\
    \x0e\n\x06\x04\x97\x01\x02\x08\x03\x12\x04\xbb\x0c%&\n\r\n\x05\x04\x97\
    \x01\x02\t\x12\x04\xbc\x0c\x08)\n\x0e\n\x06\x04\x97\x01\x02\t\x04\x12\
    \x04\xbc\x0c\x08\x10\n\x0e\n\x06\x04\x97\x01\x02\t\x05\x12\x04\xbc\x0c\
    \x11\x16\n\x0e\n\x06\x04\x97\x01\x02\t\x01\x12\x04\xbc\x0c\x17#\n\x0e\n\
    \x06\x04\x97\x01\x02\t\x03\x12\x04\xbc\x0c&(\n\r\n\x05\x04\x97\x01\x02\n\
    \x12\x04\xbd\x0c\x08*\n\x0e\n\x06\x04\x97\x01\x02\n\x04\x12\x04\xbd\x0c\
    \x08\x10\n\x0e\n\x06\x04\x97\x01\x02\n\x05\x12\x04\xbd\x0c\x11\x17\n\x0e\
    \n\x06\x04\x97\x01\x02\n\x01\x12\x04\xbd\x0c\x18$\n\x0e\n\x06\x04\x97\
    \x01\x02\n\x03\x12\x04\xbd\x0c')\n\r\n\x05\x04\x97\x01\x02\x0b\x12\x04\
    \xbe\x0c\x08+\n\x0e\n\x06\x04\x97\x01\x02\x0b\x04\x12\x04\xbe\x0c\x08\
    \x10\n\x0e\n\x06\x04\x97\x01\x02\x0b\x05\x12\x04\xbe\x0c\x11\x17\n\x0e\n\
    \x06\x04\x97\x01\x02\x0b\x01\x12\x04\xbe\x0c\x18%\n\x0e\n\x06\x04\x97\
    \x01\x02\x0b\x03\x12\x04\xbe\x0c(*\n\r\n\x05\x04\x97\x01\x02\x0c\x12\x04\
    \xbf\x0c\x08/\n\x0e\n\x06\x04\x97\x01\x02\x0c\x04\x12\x04\xbf\x0c\x08\
    \x10\n\x0e\n\x06\x04\x97\x01\x02\x0c\x05\x12\x04\xbf\x0c\x11\x17\n\x0e\n\
    \x06\x04\x97\x01\x02\x0c\x01\x12\x04\xbf\x0c\x18)\n\x0e\n\x06\x04\x97\
    \x01\x02\x0c\x03\x12\x04\xbf\x0c,.\n\r\n\x05\x04\x97\x01\x02\r\x12\x04\
    \xc0\x0c\x085\n\x0e\n\x06\x04\x97\x01\x02\r\x04\x12\x04\xc0\x0c\x08\x10\
    \n\x0e\n\x06\x04\x97\x01\x02\r\x05\x12\x04\xc0\x0c\x11\x17\n\x0e\n\x06\
    \x04\x97\x01\x02\r\x01\x12\x04\xc0\x0c\x18/\n\x0e\n\x06\x04\x97\x01\x02\
    \r\x03\x12\x04\xc0\x0c24\n\r\n\x05\x04\x97\x01\x02\x0e\x12\x04\xc1\x0c\
    \x08.\n\x0e\n\x06\x04\x97\x01\x02\x0e\x04\x12\x04\xc1\x0c\x08\x10\n\x0e\
    \n\x06\x04\x97\x01\x02\x0e\x05\x12\x04\xc1\x0c\x11\x17\n\x0e\n\x06\x04\
    \x97\x01\x02\x0e\x01\x12\x04\xc1\x0c\x18(\n\x0e\n\x06\x04\x97\x01\x02\
    \x0e\x03\x12\x04\xc1\x0c+-\n\r\n\x03\x04\x98\x01\x12\x06\xc4\x0c\0\xc8\
    \x0c\x01\n\x0c\n\x04\x04\x98\x01\x01\x12\x04\xc4\x0c\x08\x20\n\r\n\x05\
    \x04\x98\x01\x02\0\x12\x04\xc5\x0c\x08,\n\x0e\n\x06\x04\x98\x01\x02\0\
    \x04\x12\x04\xc5\x0c\x08\x10\n\x0e\n\x06\x04\x98\x01\x02\0\x05\x12\x04\
    \xc5\x0c\x11\x16\n\x0e\n\x06\x04\x98\x01\x02\0\x01\x12\x04\xc5\x0c\x17'\
    \n\x0e\n\x06\x04\x98\x01\x02\0\x03\x12\x04\xc5\x0c*+\n\r\n\x05\x04\x98\
    \x01\x02\x01\x12\x04\xc6\x0c\x08)\n\x0e\n\x06\x04\x98\x01\x02\x01\x04\
    \x12\x04\xc6\x0c\x08\x10\n\x0e\n\x06\x04\x98\x01\x02\x01\x05\x12\x04\xc6\
    \x0c\x11\x17\n\x0e\n\x06\x04\x98\x01\x02\x01\x01\x12\x04\xc6\x0c\x18$\n\
    \x0e\n\x06\x04\x98\x01\x02\x01\x03\x12\x04\xc6\x0c'(\n\r\n\x05\x04\x98\
    \x01\x02\x02\x12\x04\xc7\x0c\x08)\n\x0e\n\x06\x04\x98\x01\x02\x02\x04\
    \x12\x04\xc7\x0c\x08\x10\n\x0e\n\x06\x04\x98\x01\x02\x02\x05\x12\x04\xc7\
    \x0c\x11\x17\n\x0e\n\x06\x04\x98\x01\x02\x02\x01\x12\x04\xc7\x0c\x18$\n\
    \x0e\n\x06\x04\x98\x01\x02\x02\x03\x12\x04\xc7\x0c'(\n\r\n\x03\x04\x99\
    \x01\x12\x06\xca\x0c\0\xcd\x0c\x01\n\x0c\n\x04\x04\x99\x01\x01\x12\x04\
    \xca\x0c\x08-\n\r\n\x05\x04\x99\x01\x02\0\x12\x04\xcb\x0c\x08,\n\x0e\n\
    \x06\x04\x99\x01\x02\0\x04\x12\x04\xcb\x0c\x08\x10\n\x0e\n\x06\x04\x99\
    \x01\x02\0\x05\x12\x04\xcb\x0c\x11\x16\n\x0e\n\x06\x04\x99\x01\x02\0\x01\
    \x12\x04\xcb\x0c\x17'\n\x0e\n\x06\x04\x99\x01\x02\0\x03\x12\x04\xcb\x0c*\
    +\n\r\n\x05\x04\x99\x01\x02\x01\x12\x04\xcc\x0c\x08,\n\x0e\n\x06\x04\x99\
    \x01\x02\x01\x04\x12\x04\xcc\x0c\x08\x10\n\x0e\n\x06\x04\x99\x01\x02\x01\
    \x05\x12\x04\xcc\x0c\x11\x16\n\x0e\n\x06\x04\x99\x01\x02\x01\x01\x12\x04\
    \xcc\x0c\x17'\n\x0e\n\x06\x04\x99\x01\x02\x01\x03\x12\x04\xcc\x0c*+\n\r\
    \n\x03\x04\x9a\x01\x12\x06\xcf\x0c\0\xd4\x0c\x01\n\x0c\n\x04\x04\x9a\x01\
    \x01\x12\x04\xcf\x0c\x08.\n\r\n\x05\x04\x9a\x01\x02\0\x12\x04\xd0\x0c\
    \x08'\n\x0e\n\x06\x04\x9a\x01\x02\0\x04\x12\x04\xd0\x0c\x08\x10\n\x0e\n\
    \x06\x04\x9a\x01\x02\0\x05\x12\x04\xd0\x0c\x11\x16\n\x0e\n\x06\x04\x9a\
    \x01\x02\0\x01\x12\x04\xd0\x0c\x17\"\n\x0e\n\x06\x04\x9a\x01\x02\0\x03\
    \x12\x04\xd0\x0c%&\n\r\n\x05\x04\x9a\x01\x02\x01\x12\x04\xd1\x0c\x08'\n\
    \x0e\n\x06\x04\x9a\x01\x02\x01\x04\x12\x04\xd1\x0c\x08\x10\n\x0e\n\x06\
    \x04\x9a\x01\x02\x01\x05\x12\x04\xd1\x0c\x11\x16\n\x0e\n\x06\x04\x9a\x01\
    \x02\x01\x01\x12\x04\xd1\x0c\x17\"\n\x0e\n\x06\x04\x9a\x01\x02\x01\x03\
    \x12\x04\xd1\x0c%&\n\r\n\x05\x04\x9a\x01\x02\x02\x12\x04\xd2\x0c\x08+\n\
    \x0e\n\x06\x04\x9a\x01\x02\x02\x04\x12\x04\xd2\x0c\x08\x10\n\x0e\n\x06\
    \x04\x9a\x01\x02\x02\x05\x12\x04\xd2\x0c\x11\x16\n\x0e\n\x06\x04\x9a\x01\
    \x02\x02\x01\x12\x04\xd2\x0c\x17&\n\x0e\n\x06\x04\x9a\x01\x02\x02\x03\
    \x12\x04\xd2\x0c)*\n\r\n\x05\x04\x9a\x01\x02\x03\x12\x04\xd3\x0c\x08+\n\
    \x0e\n\x06\x04\x9a\x01\x02\x03\x04\x12\x04\xd3\x0c\x08\x10\n\x0e\n\x06\
    \x04\x9a\x01\x02\x03\x05\x12\x04\xd3\x0c\x11\x16\n\x0e\n\x06\x04\x9a\x01\
    \x02\x03\x01\x12\x04\xd3\x0c\x17&\n\x0e\n\x06\x04\x9a\x01\x02\x03\x03\
    \x12\x04\xd3\x0c)*\n\r\n\x03\x04\x9b\x01\x12\x06\xd6\x0c\0\xd9\x0c\x01\n\
    \x0c\n\x04\x04\x9b\x01\x01\x12\x04\xd6\x0c\x08'\n\r\n\x05\x04\x9b\x01\
    \x02\0\x12\x04\xd7\x0c\x08,\n\x0e\n\x06\x04\x9b\x01\x02\0\x04\x12\x04\
    \xd7\x0c\x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\0\x05\x12\x04\xd7\x0c\x11\
    \x16\n\x0e\n\x06\x04\x9b\x01\x02\0\x01\x12\x04\xd7\x0c\x17'\n\x0e\n\x06\
    \x04\x9b\x01\x02\0\x03\x12\x04\xd7\x0c*+\n\r\n\x05\x04\x9b\x01\x02\x01\
    \x12\x04\xd8\x0c\x08+\n\x0e\n\x06\x04\x9b\x01\x02\x01\x04\x12\x04\xd8\
    \x0c\x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\x01\x05\x12\x04\xd8\x0c\x11\x16\
    \n\x0e\n\x06\x04\x9b\x01\x02\x01\x01\x12\x04\xd8\x0c\x17&\n\x0e\n\x06\
    \x04\x9b\x01\x02\x01\x03\x12\x04\xd8\x0c)*\n\r\n\x03\x04\x9c\x01\x12\x06\
    \xdb\x0c\0\xde\x0c\x01\n\x0c\n\x04\x04\x9c\x01\x01\x12\x04\xdb\x0c\x08!\
    \n\r\n\x05\x04\x9c\x01\x02\0\x12\x04\xdc\x0c\x08'\n\x0e\n\x06\x04\x9c\
    \x01\x02\0\x04\x12\x04\xdc\x0c\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\0\x05\
    \x12\x04\xdc\x0c\x11\x16\n\x0e\n\x06\x04\x9c\x01\x02\0\x01\x12\x04\xdc\
    \x0c\x17\"\n\x0e\n\x06\x04\x9c\x01\x02\0\x03\x12\x04\xdc\x0c%&\n\r\n\x05\
    \x04\x9c\x01\x02\x01\x12\x04\xdd\x0c\x08'\n\x0e\n\x06\x04\x9c\x01\x02\
    \x01\x04\x12\x04\xdd\x0c\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x01\x05\x12\
    \x04\xdd\x0c\x11\x16\n\x0e\n\x06\x04\x9c\x01\x02\x01\x01\x12\x04\xdd\x0c\
    \x17\"\n\x0e\n\x06\x04\x9c\x01\x02\x01\x03\x12\x04\xdd\x0c%&\n\r\n\x03\
    \x04\x9d\x01\x12\x06\xe0\x0c\0\xe2\x0c\x01\n\x0c\n\x04\x04\x9d\x01\x01\
    \x12\x04\xe0\x0c\x08\"\n\r\n\x05\x04\x9d\x01\x02\0\x12\x04\xe1\x0c\x08/\
    \n\x0e\n\x06\x04\x9d\x01\x02\0\x04\x12\x04\xe1\x0c\x08\x10\n\x0e\n\x06\
    \x04\x9d\x01\x02\0\x05\x12\x04\xe1\x0c\x11\x16\n\x0e\n\x06\x04\x9d\x01\
    \x02\0\x01\x12\x04\xe1\x0c\x17*\n\x0e\n\x06\x04\x9d\x01\x02\0\x03\x12\
    \x04\xe1\x0c-.\n\r\n\x03\x04\x9e\x01\x12\x06\xe4\x0c\0\xea\x0c\x01\n\x0c\
    \n\x04\x04\x9e\x01\x01\x12\x04\xe4\x0c\x08<\n\r\n\x05\x04\x9e\x01\x02\0\
    \x12\x04\xe5\x0c\x08,\n\x0e\n\x06\x04\x9e\x01\x02\0\x04\x12\x04\xe5\x0c\
    \x08\x10\n\x0e\n\x06\x04\x9e\x01\x02\0\x05\x12\x04\xe5\x0c\x11\x16\n\x0e\
    \n\x06\x04\x9e\x01\x02\0\x01\x12\x04\xe5\x0c\x17'\n\x0e\n\x06\x04\x9e\
    \x01\x02\0\x03\x12\x04\xe5\x0c*+\n\r\n\x05\x04\x9e\x01\x02\x01\x12\x04\
    \xe6\x0c\x08,\n\x0e\n\x06\x04\x9e\x01\x02\x01\x04\x12\x04\xe6\x0c\x08\
    \x10\n\x0e\n\x06\x04\x9e\x01\x02\x01\x05\x12\x04\xe6\x0c\x11\x16\n\x0e\n\
    \x06\x04\x9e\x01\x02\x01\x01\x12\x04\xe6\x0c\x17'\n\x0e\n\x06\x04\x9e\
    \x01\x02\x01\x03\x12\x04\xe6\x0c*+\n\r\n\x05\x04\x9e\x01\x02\x02\x12\x04\
    \xe7\x0c\x08\"\n\x0e\n\x06\x04\x9e\x01\x02\x02\x04\x12\x04\xe7\x0c\x08\
    \x10\n\x0e\n\x06\x04\x9e\x01\x02\x02\x05\x12\x04\xe7\x0c\x11\x16\n\x0e\n\
    \x06\x04\x9e\x01\x02\x02\x01\x12\x04\xe7\x0c\x17\x1d\n\x0e\n\x06\x04\x9e\
    \x01\x02\x02\x03\x12\x04\xe7\x0c\x20!\n\r\n\x05\x04\x9e\x01\x02\x03\x12\
    \x04\xe8\x0c\x08(\n\x0e\n\x06\x04\x9e\x01\x02\x03\x04\x12\x04\xe8\x0c\
    \x08\x10\n\x0e\n\x06\x04\x9e\x01\x02\x03\x05\x12\x04\xe8\x0c\x11\x16\n\
    \x0e\n\x06\x04\x9e\x01\x02\x03\x01\x12\x04\xe8\x0c\x17#\n\x0e\n\x06\x04\
    \x9e\x01\x02\x03\x03\x12\x04\xe8\x0c&'\n\r\n\x05\x04\x9e\x01\x02\x04\x12\
    \x04\xe9\x0c\x08#\n\x0e\n\x06\x04\x9e\x01\x02\x04\x04\x12\x04\xe9\x0c\
    \x08\x10\n\x0e\n\x06\x04\x9e\x01\x02\x04\x05\x12\x04\xe9\x0c\x11\x15\n\
    \x0e\n\x06\x04\x9e\x01\x02\x04\x01\x12\x04\xe9\x0c\x16\x1e\n\x0e\n\x06\
    \x04\x9e\x01\x02\x04\x03\x12\x04\xe9\x0c!\"\n\r\n\x03\x04\x9f\x01\x12\
    \x06\xec\x0c\0\xef\x0c\x01\n\x0c\n\x04\x04\x9f\x01\x01\x12\x04\xec\x0c\
    \x08+\n\r\n\x05\x04\x9f\x01\x02\0\x12\x04\xed\x0c\x08%\n\x0e\n\x06\x04\
    \x9f\x01\x02\0\x04\x12\x04\xed\x0c\x08\x10\n\x0e\n\x06\x04\x9f\x01\x02\0\
    \x05\x12\x04\xed\x0c\x11\x16\n\x0e\n\x06\x04\x9f\x01\x02\0\x01\x12\x04\
    \xed\x0c\x17\x20\n\x0e\n\x06\x04\x9f\x01\x02\0\x03\x12\x04\xed\x0c#$\n\r\
    \n\x05\x04\x9f\x01\x02\x01\x12\x04\xee\x0c\x080\n\x0e\n\x06\x04\x9f\x01\
    \x02\x01\x04\x12\x04\xee\x0c\x08\x10\n\x0e\n\x06\x04\x9f\x01\x02\x01\x05\
    \x12\x04\xee\x0c\x11\x16\n\x0e\n\x06\x04\x9f\x01\x02\x01\x01\x12\x04\xee\
    \x0c\x17+\n\x0e\n\x06\x04\x9f\x01\x02\x01\x03\x12\x04\xee\x0c./\n\r\n\
    \x03\x04\xa0\x01\x12\x06\xf1\x0c\0\xf5\x0c\x01\n\x0c\n\x04\x04\xa0\x01\
    \x01\x12\x04\xf1\x0c\x08$\n\r\n\x05\x04\xa0\x01\x02\0\x12\x04\xf2\x0c\
    \x08-\n\x0e\n\x06\x04\xa0\x01\x02\0\x04\x12\x04\xf2\x0c\x08\x10\n\x0e\n\
    \x06\x04\xa0\x01\x02\0\x05\x12\x04\xf2\x0c\x11\x16\n\x0e\n\x06\x04\xa0\
    \x01\x02\0\x01\x12\x04\xf2\x0c\x17(\n\x0e\n\x06\x04\xa0\x01\x02\0\x03\
    \x12\x04\xf2\x0c+,\n\r\n\x05\x04\xa0\x01\x02\x01\x12\x04\xf3\x0c\x08,\n\
    \x0e\n\x06\x04\xa0\x01\x02\x01\x04\x12\x04\xf3\x0c\x08\x10\n\x0e\n\x06\
    \x04\xa0\x01\x02\x01\x05\x12\x04\xf3\x0c\x11\x16\n\x0e\n\x06\x04\xa0\x01\
    \x02\x01\x01\x12\x04\xf3\x0c\x17'\n\x0e\n\x06\x04\xa0\x01\x02\x01\x03\
    \x12\x04\xf3\x0c*+\n\r\n\x05\x04\xa0\x01\x02\x02\x12\x04\xf4\x0c\x08\x20\
    \n\x0e\n\x06\x04\xa0\x01\x02\x02\x04\x12\x04\xf4\x0c\x08\x10\n\x0e\n\x06\
    \x04\xa0\x01\x02\x02\x05\x12\x04\xf4\x0c\x11\x16\n\x0e\n\x06\x04\xa0\x01\
    \x02\x02\x01\x12\x04\xf4\x0c\x17\x1b\n\x0e\n\x06\x04\xa0\x01\x02\x02\x03\
    \x12\x04\xf4\x0c\x1e\x1f\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::networkbasetypes::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            deps.push(super::dota_commonmessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(180);
            messages.push(CDOTAUserMsg_AIDebugLine::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_Ping::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SwapVerify::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ChatEvent::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_BotChat::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CombatHeroPositions::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CombatLogBulkData::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ProjectileParticleCPData::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_MiniKillCamInfo::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_GlobalLightColor::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_GlobalLightDirection::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_LocationPing::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_PingConfirmation::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ItemAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_EnemyItemAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ModifierAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_HPManaAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_NeutralCampAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_GlyphAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_RadarAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_WillPurchaseAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_EmptyTeleportAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_MarsArenaOfBloodAttack::generated_message_descriptor_data());
            messages.push(CDOTAEntityMsg_InvokerSpellCast::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_BuyBackStateAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_QuickBuyAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CourierKilledAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_MinimapEvent::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_MapLine::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_MinimapDebugPoint::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CreateLinearProjectile::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_DestroyLinearProjectile::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_DodgeTrackingProjectiles::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SpectatorPlayerClick::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SpectatorPlayerUnitOrders::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_NevermoreRequiem::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_InvalidCommand::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_HudError::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SharedCooldown::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SetNextAutobuyItem::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_HalloweenDrops::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_PredictionResult::generated_message_descriptor_data());
            messages.push(CDOTAResponseQuerySerialized::generated_message_descriptor_data());
            messages.push(CDOTASpeechMatchOnClient::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_UnitEvent::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ItemPurchased::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ItemSold::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ItemFound::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_OverheadEvent::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TutorialTipInfo::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TutorialFinish::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TutorialMinimapPosition::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SendGenericToolTip::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_WorldLine::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ChatWheel::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ReceivedXmasGift::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ShowSurvey::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_UpdateSharedContent::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TutorialRequestExp::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TutorialFade::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TutorialPingMinimap::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_GamerulesStateChanged::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_AddQuestLogEntry::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SendStatPopup::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_DismissAllStatPopups::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SendRoshanSpectatorPhase::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SendRoshanPopup::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SendFinalGold::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CustomMsg::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CoachHUDPing::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ClientLoadGridNav::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TE_Projectile::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TE_ProjectileLoc::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TE_DestroyProjectile::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TE_DotaBloodImpact::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_AbilityPing::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TE_UnitAnimation::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TE_UnitAnimationEnd::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ShowGenericPopup::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_VoteStart::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_VoteUpdate::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_VoteEnd::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_BoosterStatePlayer::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_BoosterState::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_PlayerMMR::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_AbilitySteal::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_StatsHeroLookup::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_StatsHeroPositionInfo::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_StatsHeroMinuteDetails::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_StatsTeamMinuteDetails::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_StatsPlayerKillShare::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_StatsKillDetails::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_StatsMatchDetails::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_MiniTaunt::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SpeechBubble::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CustomHeaderMessage::generated_message_descriptor_data());
            messages.push(CMsgHeroAbilityStat::generated_message_descriptor_data());
            messages.push(CMsgCombatAnalyzerPlayerStat::generated_message_descriptor_data());
            messages.push(CMsgCombatAnalyzerStats::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_BeastChat::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CustomHudElement_Create::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CustomHudElement_Modify::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CustomHudElement_Destroy::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CompendiumStatePlayer::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_CompendiumState::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ProjectionAbility::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ProjectionEvent::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_XPAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TalentTreeAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_UpdateQuestProgress::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_QuestStatus::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SuggestHeroPick::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SuggestHeroRole::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_KillcamDamageTaken::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SelectPenaltyGold::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_RollDiceResult::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_FlipCoinResult::generated_message_descriptor_data());
            messages.push(CDOTAUserMessage_RequestItemSuggestions::generated_message_descriptor_data());
            messages.push(CDOTAUserMessage_TeamCaptainChanged::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ChatWheelCooldown::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_HeroRelicProgress::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_AbilityDraftRequestAbility::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_DamageReport::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_SalutePlayer::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_TipAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ReplaceQueryUnit::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ESArcanaCombo::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ESArcanaComboSummary::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_OMArcanaCombo::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_HighFiveCompleted::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_HighFiveLeftHanging::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ShovelUnearth::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_AllStarEvent::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_QueuedOrderRemoved::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_DebugChallenge::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_FoundNeutralItem::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_OutpostCaptured::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_OutpostGrantedXP::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_MoveCameraToUnit::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_PauseMinigameData::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_VersusScene_PlayerBehavior::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_QoP_ArcanaSummary::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_HotPotato_Created::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_HotPotato_Exploded::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_WK_Arcana_Progress::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_GuildChallenge_Progress::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_WRArcanaProgress::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_WRArcanaSummary::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_EmptyItemSlotAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_AghsStatusAlert::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_MutedPlayers::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ContextualTip::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_ChatMessage::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_RockPaperScissorsStarted::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_RockPaperScissorsFinished::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_DuelOpponentKilled::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_DuelAccepted::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_DuelRequested::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_PlayerDraftSuggestPick::generated_message_descriptor_data());
            messages.push(CDOTAUserMsg_PlayerDraftPick::generated_message_descriptor_data());
            messages.push(cdotauser_msg_mini_kill_cam_info::Attacker::generated_message_descriptor_data());
            messages.push(cdotauser_msg_mini_kill_cam_info::attacker::Ability::generated_message_descriptor_data());
            messages.push(cdotauser_msg_courier_killed_alert::LostItem::generated_message_descriptor_data());
            messages.push(cdotauser_msg_prediction_result::Prediction::generated_message_descriptor_data());
            messages.push(cdotaresponse_query_serialized::Fact::generated_message_descriptor_data());
            messages.push(cdotauser_msg_unit_event::Interval::generated_message_descriptor_data());
            messages.push(cdotauser_msg_unit_event::Speech::generated_message_descriptor_data());
            messages.push(cdotauser_msg_unit_event::SpeechMute::generated_message_descriptor_data());
            messages.push(cdotauser_msg_unit_event::AddGesture::generated_message_descriptor_data());
            messages.push(cdotauser_msg_unit_event::RemoveGesture::generated_message_descriptor_data());
            messages.push(cdotauser_msg_unit_event::BloodImpact::generated_message_descriptor_data());
            messages.push(cdotauser_msg_unit_event::FadeGesture::generated_message_descriptor_data());
            messages.push(cdotauser_msg_stats_hero_position_info::PositionPair::generated_message_descriptor_data());
            messages.push(cdotauser_msg_stats_team_minute_details::LocationPerformance::generated_message_descriptor_data());
            messages.push(cdotauser_msg_stats_match_details::CDOTAUserMsg_StatsFightTeamDetails::generated_message_descriptor_data());
            messages.push(cdotauser_msg_stats_match_details::CDOTAUserMsg_StatsFightDetails::generated_message_descriptor_data());
            messages.push(cdotauser_msg_all_star_event::PlayerScore::generated_message_descriptor_data());
            messages.push(cdotauser_msg_pause_minigame_data::DataBit::generated_message_descriptor_data());
            messages.push(cdotauser_msg_guild_challenge_progress::PlayerProgress::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(17);
            enums.push(EDotaUserMessages::generated_enum_descriptor_data());
            enums.push(DOTA_CHAT_MESSAGE::generated_enum_descriptor_data());
            enums.push(DOTA_NO_BATTLE_POINTS_REASONS::generated_enum_descriptor_data());
            enums.push(DOTA_CHAT_INFORMATIONAL::generated_enum_descriptor_data());
            enums.push(DOTA_ABILITY_PING_TYPE::generated_enum_descriptor_data());
            enums.push(DOTA_REPLAY_STATE_EVENT::generated_enum_descriptor_data());
            enums.push(EDotaEntityMessages::generated_enum_descriptor_data());
            enums.push(DOTA_OVERHEAD_ALERT::generated_enum_descriptor_data());
            enums.push(DOTA_ROSHAN_PHASE::generated_enum_descriptor_data());
            enums.push(DOTA_POSITION_CATEGORY::generated_enum_descriptor_data());
            enums.push(DOTA_ABILITY_TARGET_TYPE::generated_enum_descriptor_data());
            enums.push(EHeroStatType::generated_enum_descriptor_data());
            enums.push(EPlayerVoiceListenState::generated_enum_descriptor_data());
            enums.push(EProjectionEvent::generated_enum_descriptor_data());
            enums.push(cdotauser_msg_prediction_result::prediction::EResult::generated_enum_descriptor_data());
            enums.push(cdotaresponse_query_serialized::fact::ValueType::generated_enum_descriptor_data());
            enums.push(cdotauser_msg_guild_challenge_progress::EChallengeType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
