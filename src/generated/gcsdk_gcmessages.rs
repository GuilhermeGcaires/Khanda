// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gcsdk_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CExtraMsgBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CExtraMsgBlock {
    // message fields
    // @@protoc_insertion_point(field:dota.CExtraMsgBlock.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CExtraMsgBlock.contents)
    pub contents: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CExtraMsgBlock.msg_key)
    pub msg_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CExtraMsgBlock.is_compressed)
    pub is_compressed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CExtraMsgBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CExtraMsgBlock {
    fn default() -> &'a CExtraMsgBlock {
        <CExtraMsgBlock as ::protobuf::Message>::default_instance()
    }
}

impl CExtraMsgBlock {
    pub fn new() -> CExtraMsgBlock {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes contents = 2;

    pub fn contents(&self) -> &[u8] {
        match self.contents.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_contents(&mut self) {
        self.contents = ::std::option::Option::None;
    }

    pub fn has_contents(&self) -> bool {
        self.contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
        self.contents = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.contents.is_none() {
            self.contents = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.contents.as_mut().unwrap()
    }

    // Take field
    pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
        self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 msg_key = 3;

    pub fn msg_key(&self) -> u64 {
        self.msg_key.unwrap_or(0)
    }

    pub fn clear_msg_key(&mut self) {
        self.msg_key = ::std::option::Option::None;
    }

    pub fn has_msg_key(&self) -> bool {
        self.msg_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_key(&mut self, v: u64) {
        self.msg_key = ::std::option::Option::Some(v);
    }

    // optional bool is_compressed = 4;

    pub fn is_compressed(&self) -> bool {
        self.is_compressed.unwrap_or(false)
    }

    pub fn clear_is_compressed(&mut self) {
        self.is_compressed = ::std::option::Option::None;
    }

    pub fn has_is_compressed(&self) -> bool {
        self.is_compressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_compressed(&mut self, v: bool) {
        self.is_compressed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CExtraMsgBlock| { &m.msg_type },
            |m: &mut CExtraMsgBlock| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contents",
            |m: &CExtraMsgBlock| { &m.contents },
            |m: &mut CExtraMsgBlock| { &mut m.contents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_key",
            |m: &CExtraMsgBlock| { &m.msg_key },
            |m: &mut CExtraMsgBlock| { &mut m.msg_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_compressed",
            |m: &CExtraMsgBlock| { &m.is_compressed },
            |m: &mut CExtraMsgBlock| { &mut m.is_compressed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CExtraMsgBlock>(
            "CExtraMsgBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CExtraMsgBlock {
    const NAME: &'static str = "CExtraMsgBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.contents = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.msg_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.is_compressed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.contents.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.msg_key {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.is_compressed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.contents.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.msg_key {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.is_compressed {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CExtraMsgBlock {
        CExtraMsgBlock::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.contents = ::std::option::Option::None;
        self.msg_key = ::std::option::Option::None;
        self.is_compressed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CExtraMsgBlock {
        static instance: CExtraMsgBlock = CExtraMsgBlock {
            msg_type: ::std::option::Option::None,
            contents: ::std::option::Option::None,
            msg_key: ::std::option::Option::None,
            is_compressed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CExtraMsgBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CExtraMsgBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CExtraMsgBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CExtraMsgBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCAssertJobData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCAssertJobData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCAssertJobData.message_type)
    pub message_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGCAssertJobData.message_data)
    pub message_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCAssertJobData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCAssertJobData {
    fn default() -> &'a CMsgGCAssertJobData {
        <CMsgGCAssertJobData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCAssertJobData {
    pub fn new() -> CMsgGCAssertJobData {
        ::std::default::Default::default()
    }

    // optional string message_type = 1;

    pub fn message_type(&self) -> &str {
        match self.message_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: ::std::string::String) {
        self.message_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_type(&mut self) -> &mut ::std::string::String {
        if self.message_type.is_none() {
            self.message_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_type(&mut self) -> ::std::string::String {
        self.message_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes message_data = 2;

    pub fn message_data(&self) -> &[u8] {
        match self.message_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_data(&mut self) {
        self.message_data = ::std::option::Option::None;
    }

    pub fn has_message_data(&self) -> bool {
        self.message_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_data.is_none() {
            self.message_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_data(&mut self) -> ::std::vec::Vec<u8> {
        self.message_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_type",
            |m: &CMsgGCAssertJobData| { &m.message_type },
            |m: &mut CMsgGCAssertJobData| { &mut m.message_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_data",
            |m: &CMsgGCAssertJobData| { &m.message_data },
            |m: &mut CMsgGCAssertJobData| { &mut m.message_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCAssertJobData>(
            "CMsgGCAssertJobData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCAssertJobData {
    const NAME: &'static str = "CMsgGCAssertJobData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_type = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_type.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCAssertJobData {
        CMsgGCAssertJobData::new()
    }

    fn clear(&mut self) {
        self.message_type = ::std::option::Option::None;
        self.message_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCAssertJobData {
        static instance: CMsgGCAssertJobData = CMsgGCAssertJobData {
            message_type: ::std::option::Option::None,
            message_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCAssertJobData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCAssertJobData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCAssertJobData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCAssertJobData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCConCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCConCommand {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCConCommand.command)
    pub command: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCConCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCConCommand {
    fn default() -> &'a CMsgGCConCommand {
        <CMsgGCConCommand as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCConCommand {
    pub fn new() -> CMsgGCConCommand {
        ::std::default::Default::default()
    }

    // optional string command = 1;

    pub fn command(&self) -> &str {
        match self.command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        if self.command.is_none() {
            self.command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        self.command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &CMsgGCConCommand| { &m.command },
            |m: &mut CMsgGCConCommand| { &mut m.command },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCConCommand>(
            "CMsgGCConCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCConCommand {
    const NAME: &'static str = "CMsgGCConCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCConCommand {
        CMsgGCConCommand::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCConCommand {
        static instance: CMsgGCConCommand = CMsgGCConCommand {
            command: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCConCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCConCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCConCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCConCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSDOAssert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSDOAssert {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSDOAssert.sdo_type)
    pub sdo_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgSDOAssert.requests)
    pub requests: ::std::vec::Vec<cmsg_sdoassert::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSDOAssert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSDOAssert {
    fn default() -> &'a CMsgSDOAssert {
        <CMsgSDOAssert as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSDOAssert {
    pub fn new() -> CMsgSDOAssert {
        ::std::default::Default::default()
    }

    // optional int32 sdo_type = 1;

    pub fn sdo_type(&self) -> i32 {
        self.sdo_type.unwrap_or(0)
    }

    pub fn clear_sdo_type(&mut self) {
        self.sdo_type = ::std::option::Option::None;
    }

    pub fn has_sdo_type(&self) -> bool {
        self.sdo_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdo_type(&mut self, v: i32) {
        self.sdo_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdo_type",
            |m: &CMsgSDOAssert| { &m.sdo_type },
            |m: &mut CMsgSDOAssert| { &mut m.sdo_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &CMsgSDOAssert| { &m.requests },
            |m: &mut CMsgSDOAssert| { &mut m.requests },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSDOAssert>(
            "CMsgSDOAssert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSDOAssert {
    const NAME: &'static str = "CMsgSDOAssert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sdo_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.requests.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sdo_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sdo_type {
            os.write_int32(1, v)?;
        }
        for v in &self.requests {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSDOAssert {
        CMsgSDOAssert::new()
    }

    fn clear(&mut self) {
        self.sdo_type = ::std::option::Option::None;
        self.requests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSDOAssert {
        static instance: CMsgSDOAssert = CMsgSDOAssert {
            sdo_type: ::std::option::Option::None,
            requests: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSDOAssert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSDOAssert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSDOAssert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSDOAssert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSDOAssert`
pub mod cmsg_sdoassert {
    // @@protoc_insertion_point(message:dota.CMsgSDOAssert.Request)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Request {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSDOAssert.Request.key)
        pub key: ::std::vec::Vec<u64>,
        // @@protoc_insertion_point(field:dota.CMsgSDOAssert.Request.requesting_job)
        pub requesting_job: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSDOAssert.Request.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Request {
        fn default() -> &'a Request {
            <Request as ::protobuf::Message>::default_instance()
        }
    }

    impl Request {
        pub fn new() -> Request {
            ::std::default::Default::default()
        }

        // optional string requesting_job = 2;

        pub fn requesting_job(&self) -> &str {
            match self.requesting_job.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_requesting_job(&mut self) {
            self.requesting_job = ::std::option::Option::None;
        }

        pub fn has_requesting_job(&self) -> bool {
            self.requesting_job.is_some()
        }

        // Param is passed by value, moved
        pub fn set_requesting_job(&mut self, v: ::std::string::String) {
            self.requesting_job = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_requesting_job(&mut self) -> &mut ::std::string::String {
            if self.requesting_job.is_none() {
                self.requesting_job = ::std::option::Option::Some(::std::string::String::new());
            }
            self.requesting_job.as_mut().unwrap()
        }

        // Take field
        pub fn take_requesting_job(&mut self) -> ::std::string::String {
            self.requesting_job.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "key",
                |m: &Request| { &m.key },
                |m: &mut Request| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "requesting_job",
                |m: &Request| { &m.requesting_job },
                |m: &mut Request| { &mut m.requesting_job },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Request>(
                "CMsgSDOAssert.Request",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Request {
        const NAME: &'static str = "Request";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_uint64_into(&mut self.key)?;
                    },
                    8 => {
                        self.key.push(is.read_uint64()?);
                    },
                    18 => {
                        self.requesting_job = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.key {
                my_size += ::protobuf::rt::uint64_size(1, *value);
            };
            if let Some(v) = self.requesting_job.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.key {
                os.write_uint64(1, *v)?;
            };
            if let Some(v) = self.requesting_job.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Request {
            Request::new()
        }

        fn clear(&mut self) {
            self.key.clear();
            self.requesting_job = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Request {
            static instance: Request = Request {
                key: ::std::vec::Vec::new(),
                requesting_job: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Request {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSDOAssert.Request").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Request {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Request {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSOIDOwner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOIDOwner {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOIDOwner.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSOIDOwner.id)
    pub id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOIDOwner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOIDOwner {
    fn default() -> &'a CMsgSOIDOwner {
        <CMsgSOIDOwner as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOIDOwner {
    pub fn new() -> CMsgSOIDOwner {
        ::std::default::Default::default()
    }

    // optional uint32 type = 1;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint64 id = 2;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgSOIDOwner| { &m.type_ },
            |m: &mut CMsgSOIDOwner| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgSOIDOwner| { &m.id },
            |m: &mut CMsgSOIDOwner| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOIDOwner>(
            "CMsgSOIDOwner",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOIDOwner {
    const NAME: &'static str = "CMsgSOIDOwner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOIDOwner {
        CMsgSOIDOwner::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOIDOwner {
        static instance: CMsgSOIDOwner = CMsgSOIDOwner {
            type_: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOIDOwner {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOIDOwner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOIDOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOIDOwner {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSOSingleObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOSingleObject {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOSingleObject.type_id)
    pub type_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgSOSingleObject.object_data)
    pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgSOSingleObject.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSOSingleObject.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:dota.CMsgSOSingleObject.service_id)
    pub service_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOSingleObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOSingleObject {
    fn default() -> &'a CMsgSOSingleObject {
        <CMsgSOSingleObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOSingleObject {
    pub fn new() -> CMsgSOSingleObject {
        ::std::default::Default::default()
    }

    // optional int32 type_id = 2;

    pub fn type_id(&self) -> i32 {
        self.type_id.unwrap_or(0)
    }

    pub fn clear_type_id(&mut self) {
        self.type_id = ::std::option::Option::None;
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = ::std::option::Option::Some(v);
    }

    // optional bytes object_data = 3;

    pub fn object_data(&self) -> &[u8] {
        match self.object_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_object_data(&mut self) {
        self.object_data = ::std::option::Option::None;
    }

    pub fn has_object_data(&self) -> bool {
        self.object_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.object_data.is_none() {
            self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.object_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
        self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 version = 4;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 6;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type_id",
            |m: &CMsgSOSingleObject| { &m.type_id },
            |m: &mut CMsgSOSingleObject| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "object_data",
            |m: &CMsgSOSingleObject| { &m.object_data },
            |m: &mut CMsgSOSingleObject| { &mut m.object_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOSingleObject| { &m.version },
            |m: &mut CMsgSOSingleObject| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOSingleObject| { &m.owner_soid },
            |m: &mut CMsgSOSingleObject| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOSingleObject| { &m.service_id },
            |m: &mut CMsgSOSingleObject| { &mut m.service_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOSingleObject>(
            "CMsgSOSingleObject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOSingleObject {
    const NAME: &'static str = "CMsgSOSingleObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.type_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                33 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                48 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.object_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.object_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOSingleObject {
        CMsgSOSingleObject::new()
    }

    fn clear(&mut self) {
        self.type_id = ::std::option::Option::None;
        self.object_data = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOSingleObject {
        static instance: CMsgSOSingleObject = CMsgSOSingleObject {
            type_id: ::std::option::Option::None,
            object_data: ::std::option::Option::None,
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOSingleObject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOSingleObject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOSingleObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOSingleObject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSOMultipleObjects)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOMultipleObjects {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOMultipleObjects.objects_modified)
    pub objects_modified: ::std::vec::Vec<cmsg_somultiple_objects::SingleObject>,
    // @@protoc_insertion_point(field:dota.CMsgSOMultipleObjects.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSOMultipleObjects.objects_added)
    pub objects_added: ::std::vec::Vec<cmsg_somultiple_objects::SingleObject>,
    // @@protoc_insertion_point(field:dota.CMsgSOMultipleObjects.objects_removed)
    pub objects_removed: ::std::vec::Vec<cmsg_somultiple_objects::SingleObject>,
    // @@protoc_insertion_point(field:dota.CMsgSOMultipleObjects.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:dota.CMsgSOMultipleObjects.service_id)
    pub service_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOMultipleObjects.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOMultipleObjects {
    fn default() -> &'a CMsgSOMultipleObjects {
        <CMsgSOMultipleObjects as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOMultipleObjects {
    pub fn new() -> CMsgSOMultipleObjects {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 7;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects_modified",
            |m: &CMsgSOMultipleObjects| { &m.objects_modified },
            |m: &mut CMsgSOMultipleObjects| { &mut m.objects_modified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOMultipleObjects| { &m.version },
            |m: &mut CMsgSOMultipleObjects| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects_added",
            |m: &CMsgSOMultipleObjects| { &m.objects_added },
            |m: &mut CMsgSOMultipleObjects| { &mut m.objects_added },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects_removed",
            |m: &CMsgSOMultipleObjects| { &m.objects_removed },
            |m: &mut CMsgSOMultipleObjects| { &mut m.objects_removed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOMultipleObjects| { &m.owner_soid },
            |m: &mut CMsgSOMultipleObjects| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOMultipleObjects| { &m.service_id },
            |m: &mut CMsgSOMultipleObjects| { &mut m.service_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOMultipleObjects>(
            "CMsgSOMultipleObjects",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOMultipleObjects {
    const NAME: &'static str = "CMsgSOMultipleObjects";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.objects_modified.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.objects_added.push(is.read_message()?);
                },
                42 => {
                    self.objects_removed.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                56 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objects_modified {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        for value in &self.objects_added {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.objects_removed {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.objects_modified {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        for v in &self.objects_added {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.objects_removed {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOMultipleObjects {
        CMsgSOMultipleObjects::new()
    }

    fn clear(&mut self) {
        self.objects_modified.clear();
        self.version = ::std::option::Option::None;
        self.objects_added.clear();
        self.objects_removed.clear();
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOMultipleObjects {
        static instance: CMsgSOMultipleObjects = CMsgSOMultipleObjects {
            objects_modified: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            objects_added: ::std::vec::Vec::new(),
            objects_removed: ::std::vec::Vec::new(),
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOMultipleObjects {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOMultipleObjects").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOMultipleObjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOMultipleObjects {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSOMultipleObjects`
pub mod cmsg_somultiple_objects {
    // @@protoc_insertion_point(message:dota.CMsgSOMultipleObjects.SingleObject)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleObject {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSOMultipleObjects.SingleObject.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSOMultipleObjects.SingleObject.object_data)
        pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSOMultipleObjects.SingleObject.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleObject {
        fn default() -> &'a SingleObject {
            <SingleObject as ::protobuf::Message>::default_instance()
        }
    }

    impl SingleObject {
        pub fn new() -> SingleObject {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }

        // optional bytes object_data = 2;

        pub fn object_data(&self) -> &[u8] {
            match self.object_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_object_data(&mut self) {
            self.object_data = ::std::option::Option::None;
        }

        pub fn has_object_data(&self) -> bool {
            self.object_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.object_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.object_data.is_none() {
                self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.object_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
            self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type_id",
                |m: &SingleObject| { &m.type_id },
                |m: &mut SingleObject| { &mut m.type_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "object_data",
                |m: &SingleObject| { &m.object_data },
                |m: &mut SingleObject| { &mut m.object_data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleObject>(
                "CMsgSOMultipleObjects.SingleObject",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SingleObject {
        const NAME: &'static str = "SingleObject";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.object_data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.object_data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleObject {
            SingleObject::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleObject {
            static instance: SingleObject = SingleObject {
                type_id: ::std::option::Option::None,
                object_data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SingleObject {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSOMultipleObjects.SingleObject").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SingleObject {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SingleObject {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSOCacheSubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscribed {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribed.objects)
    pub objects: ::std::vec::Vec<cmsg_socache_subscribed::SubscribedType>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribed.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribed.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribed.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribed.service_list)
    pub service_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribed.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOCacheSubscribed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribed {
    fn default() -> &'a CMsgSOCacheSubscribed {
        <CMsgSOCacheSubscribed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribed {
    pub fn new() -> CMsgSOCacheSubscribed {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 5;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 7;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects",
            |m: &CMsgSOCacheSubscribed| { &m.objects },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.objects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheSubscribed| { &m.version },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscribed| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOCacheSubscribed| { &m.service_id },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.service_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_list",
            |m: &CMsgSOCacheSubscribed| { &m.service_list },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.service_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sync_version",
            |m: &CMsgSOCacheSubscribed| { &m.sync_version },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.sync_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscribed>(
            "CMsgSOCacheSubscribed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscribed {
    const NAME: &'static str = "CMsgSOCacheSubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.objects.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                40 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.service_list)?;
                },
                48 => {
                    self.service_list.push(is.read_uint32()?);
                },
                57 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.service_list {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.objects {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(5, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscribed {
        CMsgSOCacheSubscribed::new()
    }

    fn clear(&mut self) {
        self.objects.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribed {
        static instance: CMsgSOCacheSubscribed = CMsgSOCacheSubscribed {
            objects: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            service_list: ::std::vec::Vec::new(),
            sync_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscribed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscribed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscribed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSOCacheSubscribed`
pub mod cmsg_socache_subscribed {
    // @@protoc_insertion_point(message:dota.CMsgSOCacheSubscribed.SubscribedType)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SubscribedType {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribed.SubscribedType.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribed.SubscribedType.object_data)
        pub object_data: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSOCacheSubscribed.SubscribedType.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SubscribedType {
        fn default() -> &'a SubscribedType {
            <SubscribedType as ::protobuf::Message>::default_instance()
        }
    }

    impl SubscribedType {
        pub fn new() -> SubscribedType {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type_id",
                |m: &SubscribedType| { &m.type_id },
                |m: &mut SubscribedType| { &mut m.type_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "object_data",
                |m: &SubscribedType| { &m.object_data },
                |m: &mut SubscribedType| { &mut m.object_data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribedType>(
                "CMsgSOCacheSubscribed.SubscribedType",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SubscribedType {
        const NAME: &'static str = "SubscribedType";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data.push(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            for value in &self.object_data {
                my_size += ::protobuf::rt::bytes_size(2, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            for v in &self.object_data {
                os.write_bytes(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SubscribedType {
            SubscribedType::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SubscribedType {
            static instance: SubscribedType = SubscribedType {
                type_id: ::std::option::Option::None,
                object_data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SubscribedType {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscribed.SubscribedType").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SubscribedType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SubscribedType {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgSOCacheSubscribedUpToDate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscribedUpToDate {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribedUpToDate.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribedUpToDate.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribedUpToDate.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribedUpToDate.service_list)
    pub service_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscribedUpToDate.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOCacheSubscribedUpToDate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribedUpToDate {
    fn default() -> &'a CMsgSOCacheSubscribedUpToDate {
        <CMsgSOCacheSubscribedUpToDate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribedUpToDate {
    pub fn new() -> CMsgSOCacheSubscribedUpToDate {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 3;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 5;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.version },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.service_id },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.service_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_list",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.service_list },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.service_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sync_version",
            |m: &CMsgSOCacheSubscribedUpToDate| { &m.sync_version },
            |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.sync_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscribedUpToDate>(
            "CMsgSOCacheSubscribedUpToDate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscribedUpToDate {
    const NAME: &'static str = "CMsgSOCacheSubscribedUpToDate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                24 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.service_list)?;
                },
                32 => {
                    self.service_list.push(is.read_uint32()?);
                },
                41 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.service_list {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscribedUpToDate {
        CMsgSOCacheSubscribedUpToDate::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribedUpToDate {
        static instance: CMsgSOCacheSubscribedUpToDate = CMsgSOCacheSubscribedUpToDate {
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            service_list: ::std::vec::Vec::new(),
            sync_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscribedUpToDate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscribedUpToDate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscribedUpToDate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscribedUpToDate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSOCacheUnsubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheUnsubscribed {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOCacheUnsubscribed.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOCacheUnsubscribed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheUnsubscribed {
    fn default() -> &'a CMsgSOCacheUnsubscribed {
        <CMsgSOCacheUnsubscribed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheUnsubscribed {
    pub fn new() -> CMsgSOCacheUnsubscribed {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheUnsubscribed| { &m.owner_soid },
            |m: &mut CMsgSOCacheUnsubscribed| { &mut m.owner_soid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheUnsubscribed>(
            "CMsgSOCacheUnsubscribed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheUnsubscribed {
    const NAME: &'static str = "CMsgSOCacheUnsubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheUnsubscribed {
        CMsgSOCacheUnsubscribed::new()
    }

    fn clear(&mut self) {
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheUnsubscribed {
        static instance: CMsgSOCacheUnsubscribed = CMsgSOCacheUnsubscribed {
            owner_soid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheUnsubscribed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheUnsubscribed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheUnsubscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheUnsubscribed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSOCacheSubscriptionCheck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionCheck {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscriptionCheck.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscriptionCheck.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscriptionCheck.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscriptionCheck.service_list)
    pub service_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscriptionCheck.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOCacheSubscriptionCheck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionCheck {
    fn default() -> &'a CMsgSOCacheSubscriptionCheck {
        <CMsgSOCacheSubscriptionCheck as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionCheck {
    pub fn new() -> CMsgSOCacheSubscriptionCheck {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 4;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 6;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.version },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.owner_soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.service_id },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.service_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_list",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.service_list },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.service_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sync_version",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.sync_version },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.sync_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscriptionCheck>(
            "CMsgSOCacheSubscriptionCheck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscriptionCheck {
    const NAME: &'static str = "CMsgSOCacheSubscriptionCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                32 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.service_list)?;
                },
                40 => {
                    self.service_list.push(is.read_uint32()?);
                },
                49 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.service_list {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(4, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionCheck {
        CMsgSOCacheSubscriptionCheck::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionCheck {
        static instance: CMsgSOCacheSubscriptionCheck = CMsgSOCacheSubscriptionCheck {
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            service_list: ::std::vec::Vec::new(),
            sync_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscriptionCheck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscriptionCheck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscriptionCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscriptionCheck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSOCacheSubscriptionRefresh)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionRefresh {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOCacheSubscriptionRefresh.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOCacheSubscriptionRefresh.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionRefresh {
    fn default() -> &'a CMsgSOCacheSubscriptionRefresh {
        <CMsgSOCacheSubscriptionRefresh as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionRefresh {
    pub fn new() -> CMsgSOCacheSubscriptionRefresh {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscriptionRefresh| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscriptionRefresh| { &mut m.owner_soid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscriptionRefresh>(
            "CMsgSOCacheSubscriptionRefresh",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscriptionRefresh {
    const NAME: &'static str = "CMsgSOCacheSubscriptionRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionRefresh {
        CMsgSOCacheSubscriptionRefresh::new()
    }

    fn clear(&mut self) {
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionRefresh {
        static instance: CMsgSOCacheSubscriptionRefresh = CMsgSOCacheSubscriptionRefresh {
            owner_soid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscriptionRefresh {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscriptionRefresh").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscriptionRefresh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscriptionRefresh {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSOCacheVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheVersion {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOCacheVersion.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOCacheVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheVersion {
    fn default() -> &'a CMsgSOCacheVersion {
        <CMsgSOCacheVersion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheVersion {
    pub fn new() -> CMsgSOCacheVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheVersion| { &m.version },
            |m: &mut CMsgSOCacheVersion| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheVersion>(
            "CMsgSOCacheVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheVersion {
    const NAME: &'static str = "CMsgSOCacheVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheVersion {
        CMsgSOCacheVersion::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheVersion {
        static instance: CMsgSOCacheVersion = CMsgSOCacheVersion {
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCMultiplexMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMultiplexMessage {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCMultiplexMessage.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCMultiplexMessage.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgGCMultiplexMessage.steamids)
    pub steamids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCMultiplexMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMultiplexMessage {
    fn default() -> &'a CMsgGCMultiplexMessage {
        <CMsgGCMultiplexMessage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMultiplexMessage {
    pub fn new() -> CMsgGCMultiplexMessage {
        ::std::default::Default::default()
    }

    // optional uint32 msgtype = 1;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgtype",
            |m: &CMsgGCMultiplexMessage| { &m.msgtype },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.msgtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CMsgGCMultiplexMessage| { &m.payload },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamids",
            |m: &CMsgGCMultiplexMessage| { &m.steamids },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.steamids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCMultiplexMessage>(
            "CMsgGCMultiplexMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCMultiplexMessage {
    const NAME: &'static str = "CMsgGCMultiplexMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamids)?;
                },
                25 => {
                    self.steamids.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msgtype {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += 9 * self.steamids.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msgtype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.steamids {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMultiplexMessage {
        CMsgGCMultiplexMessage::new()
    }

    fn clear(&mut self) {
        self.msgtype = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.steamids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMultiplexMessage {
        static instance: CMsgGCMultiplexMessage = CMsgGCMultiplexMessage {
            msgtype: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            steamids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCMultiplexMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCMultiplexMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCMultiplexMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMultiplexMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCSubGCStarting)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSubGCStarting {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSubGCStarting.dir_index)
    pub dir_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCSubGCStarting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSubGCStarting {
    fn default() -> &'a CMsgGCToGCSubGCStarting {
        <CMsgGCToGCSubGCStarting as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSubGCStarting {
    pub fn new() -> CMsgGCToGCSubGCStarting {
        ::std::default::Default::default()
    }

    // optional int32 dir_index = 1;

    pub fn dir_index(&self) -> i32 {
        self.dir_index.unwrap_or(0)
    }

    pub fn clear_dir_index(&mut self) {
        self.dir_index = ::std::option::Option::None;
    }

    pub fn has_dir_index(&self) -> bool {
        self.dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir_index(&mut self, v: i32) {
        self.dir_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dir_index",
            |m: &CMsgGCToGCSubGCStarting| { &m.dir_index },
            |m: &mut CMsgGCToGCSubGCStarting| { &mut m.dir_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCSubGCStarting>(
            "CMsgGCToGCSubGCStarting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCSubGCStarting {
    const NAME: &'static str = "CMsgGCToGCSubGCStarting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dir_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dir_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dir_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSubGCStarting {
        CMsgGCToGCSubGCStarting::new()
    }

    fn clear(&mut self) {
        self.dir_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSubGCStarting {
        static instance: CMsgGCToGCSubGCStarting = CMsgGCToGCSubGCStarting {
            dir_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCSubGCStarting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCSubGCStarting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCSubGCStarting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCSubGCStarting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CGCToGCMsgMasterAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck {
    // message fields
    // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterAck.dir_index)
    pub dir_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterAck.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterAck.process_name)
    pub process_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterAck.directory)
    pub directory: ::std::vec::Vec<cgcto_gcmsg_master_ack::Process>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGCToGCMsgMasterAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck {
    fn default() -> &'a CGCToGCMsgMasterAck {
        <CGCToGCMsgMasterAck as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck {
    pub fn new() -> CGCToGCMsgMasterAck {
        ::std::default::Default::default()
    }

    // optional int32 dir_index = 1;

    pub fn dir_index(&self) -> i32 {
        self.dir_index.unwrap_or(0)
    }

    pub fn clear_dir_index(&mut self) {
        self.dir_index = ::std::option::Option::None;
    }

    pub fn has_dir_index(&self) -> bool {
        self.dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir_index(&mut self, v: i32) {
        self.dir_index = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 3;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string process_name = 4;

    pub fn process_name(&self) -> &str {
        match self.process_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_process_name(&mut self) {
        self.process_name = ::std::option::Option::None;
    }

    pub fn has_process_name(&self) -> bool {
        self.process_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_name(&mut self, v: ::std::string::String) {
        self.process_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process_name(&mut self) -> &mut ::std::string::String {
        if self.process_name.is_none() {
            self.process_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.process_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_process_name(&mut self) -> ::std::string::String {
        self.process_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dir_index",
            |m: &CGCToGCMsgMasterAck| { &m.dir_index },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.dir_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_name",
            |m: &CGCToGCMsgMasterAck| { &m.machine_name },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.machine_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "process_name",
            |m: &CGCToGCMsgMasterAck| { &m.process_name },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.process_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "directory",
            |m: &CGCToGCMsgMasterAck| { &m.directory },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.directory },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgMasterAck>(
            "CGCToGCMsgMasterAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterAck {
    const NAME: &'static str = "CGCToGCMsgMasterAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dir_index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.process_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.directory.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dir_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.process_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.directory {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dir_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.process_name.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.directory {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck {
        CGCToGCMsgMasterAck::new()
    }

    fn clear(&mut self) {
        self.dir_index = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.process_name = ::std::option::Option::None;
        self.directory.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck {
        static instance: CGCToGCMsgMasterAck = CGCToGCMsgMasterAck {
            dir_index: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            process_name: ::std::option::Option::None,
            directory: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgMasterAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgMasterAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CGCToGCMsgMasterAck`
pub mod cgcto_gcmsg_master_ack {
    // @@protoc_insertion_point(message:dota.CGCToGCMsgMasterAck.Process)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Process {
        // message fields
        // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterAck.Process.dir_index)
        pub dir_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterAck.Process.type_instances)
        pub type_instances: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CGCToGCMsgMasterAck.Process.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Process {
        fn default() -> &'a Process {
            <Process as ::protobuf::Message>::default_instance()
        }
    }

    impl Process {
        pub fn new() -> Process {
            ::std::default::Default::default()
        }

        // optional int32 dir_index = 1;

        pub fn dir_index(&self) -> i32 {
            self.dir_index.unwrap_or(0)
        }

        pub fn clear_dir_index(&mut self) {
            self.dir_index = ::std::option::Option::None;
        }

        pub fn has_dir_index(&self) -> bool {
            self.dir_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dir_index(&mut self, v: i32) {
            self.dir_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dir_index",
                |m: &Process| { &m.dir_index },
                |m: &mut Process| { &mut m.dir_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type_instances",
                |m: &Process| { &m.type_instances },
                |m: &mut Process| { &mut m.type_instances },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Process>(
                "CGCToGCMsgMasterAck.Process",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Process {
        const NAME: &'static str = "Process";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.dir_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.type_instances)?;
                    },
                    16 => {
                        self.type_instances.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dir_index {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            for value in &self.type_instances {
                my_size += ::protobuf::rt::uint32_size(2, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.dir_index {
                os.write_int32(1, v)?;
            }
            for v in &self.type_instances {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Process {
            Process::new()
        }

        fn clear(&mut self) {
            self.dir_index = ::std::option::Option::None;
            self.type_instances.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Process {
            static instance: Process = Process {
                dir_index: ::std::option::Option::None,
                type_instances: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Process {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterAck.Process").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Process {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Process {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CGCToGCMsgMasterAck_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck_Response {
    // message fields
    // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterAck_Response.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGCToGCMsgMasterAck_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck_Response {
    fn default() -> &'a CGCToGCMsgMasterAck_Response {
        <CGCToGCMsgMasterAck_Response as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck_Response {
    pub fn new() -> CGCToGCMsgMasterAck_Response {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CGCToGCMsgMasterAck_Response| { &m.eresult },
            |m: &mut CGCToGCMsgMasterAck_Response| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgMasterAck_Response>(
            "CGCToGCMsgMasterAck_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterAck_Response {
    const NAME: &'static str = "CGCToGCMsgMasterAck_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck_Response {
        CGCToGCMsgMasterAck_Response::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck_Response {
        static instance: CGCToGCMsgMasterAck_Response = CGCToGCMsgMasterAck_Response {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgMasterAck_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterAck_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgMasterAck_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterAck_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCUniverseStartup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUniverseStartup {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUniverseStartup.is_initial_startup)
    pub is_initial_startup: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCUniverseStartup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUniverseStartup {
    fn default() -> &'a CMsgGCToGCUniverseStartup {
        <CMsgGCToGCUniverseStartup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUniverseStartup {
    pub fn new() -> CMsgGCToGCUniverseStartup {
        ::std::default::Default::default()
    }

    // optional bool is_initial_startup = 1;

    pub fn is_initial_startup(&self) -> bool {
        self.is_initial_startup.unwrap_or(false)
    }

    pub fn clear_is_initial_startup(&mut self) {
        self.is_initial_startup = ::std::option::Option::None;
    }

    pub fn has_is_initial_startup(&self) -> bool {
        self.is_initial_startup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_initial_startup(&mut self, v: bool) {
        self.is_initial_startup = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_initial_startup",
            |m: &CMsgGCToGCUniverseStartup| { &m.is_initial_startup },
            |m: &mut CMsgGCToGCUniverseStartup| { &mut m.is_initial_startup },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCUniverseStartup>(
            "CMsgGCToGCUniverseStartup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCUniverseStartup {
    const NAME: &'static str = "CMsgGCToGCUniverseStartup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_initial_startup = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_initial_startup {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_initial_startup {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUniverseStartup {
        CMsgGCToGCUniverseStartup::new()
    }

    fn clear(&mut self) {
        self.is_initial_startup = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUniverseStartup {
        static instance: CMsgGCToGCUniverseStartup = CMsgGCToGCUniverseStartup {
            is_initial_startup: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCUniverseStartup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCUniverseStartup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCUniverseStartup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCUniverseStartup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCUniverseStartupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUniverseStartupResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUniverseStartupResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCUniverseStartupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUniverseStartupResponse {
    fn default() -> &'a CMsgGCToGCUniverseStartupResponse {
        <CMsgGCToGCUniverseStartupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUniverseStartupResponse {
    pub fn new() -> CMsgGCToGCUniverseStartupResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgGCToGCUniverseStartupResponse| { &m.eresult },
            |m: &mut CMsgGCToGCUniverseStartupResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCUniverseStartupResponse>(
            "CMsgGCToGCUniverseStartupResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCUniverseStartupResponse {
    const NAME: &'static str = "CMsgGCToGCUniverseStartupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUniverseStartupResponse {
        CMsgGCToGCUniverseStartupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUniverseStartupResponse {
        static instance: CMsgGCToGCUniverseStartupResponse = CMsgGCToGCUniverseStartupResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCUniverseStartupResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCUniverseStartupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCUniverseStartupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCUniverseStartupResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CGCToGCMsgMasterStartupComplete)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterStartupComplete {
    // message fields
    // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterStartupComplete.gc_info)
    pub gc_info: ::std::vec::Vec<cgcto_gcmsg_master_startup_complete::GCInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGCToGCMsgMasterStartupComplete.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterStartupComplete {
    fn default() -> &'a CGCToGCMsgMasterStartupComplete {
        <CGCToGCMsgMasterStartupComplete as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterStartupComplete {
    pub fn new() -> CGCToGCMsgMasterStartupComplete {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gc_info",
            |m: &CGCToGCMsgMasterStartupComplete| { &m.gc_info },
            |m: &mut CGCToGCMsgMasterStartupComplete| { &mut m.gc_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgMasterStartupComplete>(
            "CGCToGCMsgMasterStartupComplete",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterStartupComplete {
    const NAME: &'static str = "CGCToGCMsgMasterStartupComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gc_info.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.gc_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.gc_info {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterStartupComplete {
        CGCToGCMsgMasterStartupComplete::new()
    }

    fn clear(&mut self) {
        self.gc_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterStartupComplete {
        static instance: CGCToGCMsgMasterStartupComplete = CGCToGCMsgMasterStartupComplete {
            gc_info: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgMasterStartupComplete {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterStartupComplete").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgMasterStartupComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterStartupComplete {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CGCToGCMsgMasterStartupComplete`
pub mod cgcto_gcmsg_master_startup_complete {
    // @@protoc_insertion_point(message:dota.CGCToGCMsgMasterStartupComplete.GCInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GCInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterStartupComplete.GCInfo.dir_index)
        pub dir_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CGCToGCMsgMasterStartupComplete.GCInfo.machine_name)
        pub machine_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CGCToGCMsgMasterStartupComplete.GCInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GCInfo {
        fn default() -> &'a GCInfo {
            <GCInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl GCInfo {
        pub fn new() -> GCInfo {
            ::std::default::Default::default()
        }

        // optional int32 dir_index = 1;

        pub fn dir_index(&self) -> i32 {
            self.dir_index.unwrap_or(0)
        }

        pub fn clear_dir_index(&mut self) {
            self.dir_index = ::std::option::Option::None;
        }

        pub fn has_dir_index(&self) -> bool {
            self.dir_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dir_index(&mut self, v: i32) {
            self.dir_index = ::std::option::Option::Some(v);
        }

        // optional string machine_name = 2;

        pub fn machine_name(&self) -> &str {
            match self.machine_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_machine_name(&mut self) {
            self.machine_name = ::std::option::Option::None;
        }

        pub fn has_machine_name(&self) -> bool {
            self.machine_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_machine_name(&mut self, v: ::std::string::String) {
            self.machine_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
            if self.machine_name.is_none() {
                self.machine_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.machine_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_machine_name(&mut self) -> ::std::string::String {
            self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dir_index",
                |m: &GCInfo| { &m.dir_index },
                |m: &mut GCInfo| { &mut m.dir_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "machine_name",
                |m: &GCInfo| { &m.machine_name },
                |m: &mut GCInfo| { &mut m.machine_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GCInfo>(
                "CGCToGCMsgMasterStartupComplete.GCInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GCInfo {
        const NAME: &'static str = "GCInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.dir_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.machine_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dir_index {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.machine_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.dir_index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.machine_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GCInfo {
            GCInfo::new()
        }

        fn clear(&mut self) {
            self.dir_index = ::std::option::Option::None;
            self.machine_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GCInfo {
            static instance: GCInfo = GCInfo {
                dir_index: ::std::option::Option::None,
                machine_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GCInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterStartupComplete.GCInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GCInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GCInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CGCToGCMsgRouted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRouted {
    // message fields
    // @@protoc_insertion_point(field:dota.CGCToGCMsgRouted.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGCToGCMsgRouted.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CGCToGCMsgRouted.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGCToGCMsgRouted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRouted {
    fn default() -> &'a CGCToGCMsgRouted {
        <CGCToGCMsgRouted as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRouted {
    pub fn new() -> CGCToGCMsgRouted {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 3;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CGCToGCMsgRouted| { &m.msg_type },
            |m: &mut CGCToGCMsgRouted| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_id",
            |m: &CGCToGCMsgRouted| { &m.sender_id },
            |m: &mut CGCToGCMsgRouted| { &mut m.sender_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_message",
            |m: &CGCToGCMsgRouted| { &m.net_message },
            |m: &mut CGCToGCMsgRouted| { &mut m.net_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgRouted>(
            "CGCToGCMsgRouted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgRouted {
    const NAME: &'static str = "CGCToGCMsgRouted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRouted {
        CGCToGCMsgRouted::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRouted {
        static instance: CGCToGCMsgRouted = CGCToGCMsgRouted {
            msg_type: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgRouted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgRouted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgRouted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgRouted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CGCToGCMsgRoutedReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRoutedReply {
    // message fields
    // @@protoc_insertion_point(field:dota.CGCToGCMsgRoutedReply.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGCToGCMsgRoutedReply.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGCToGCMsgRoutedReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRoutedReply {
    fn default() -> &'a CGCToGCMsgRoutedReply {
        <CGCToGCMsgRoutedReply as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRoutedReply {
    pub fn new() -> CGCToGCMsgRoutedReply {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 2;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CGCToGCMsgRoutedReply| { &m.msg_type },
            |m: &mut CGCToGCMsgRoutedReply| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_message",
            |m: &CGCToGCMsgRoutedReply| { &m.net_message },
            |m: &mut CGCToGCMsgRoutedReply| { &mut m.net_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgRoutedReply>(
            "CGCToGCMsgRoutedReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgRoutedReply {
    const NAME: &'static str = "CGCToGCMsgRoutedReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRoutedReply {
        CGCToGCMsgRoutedReply::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRoutedReply {
        static instance: CGCToGCMsgRoutedReply = CGCToGCMsgRoutedReply {
            msg_type: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgRoutedReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgRoutedReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgRoutedReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgRoutedReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCUpdateSubGCSessionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCUpdateSubGCSessionInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCUpdateSubGCSessionInfo.updates)
    pub updates: ::std::vec::Vec<cmsg_gcupdate_sub_gcsession_info::CMsgUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCUpdateSubGCSessionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCUpdateSubGCSessionInfo {
    fn default() -> &'a CMsgGCUpdateSubGCSessionInfo {
        <CMsgGCUpdateSubGCSessionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCUpdateSubGCSessionInfo {
    pub fn new() -> CMsgGCUpdateSubGCSessionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "updates",
            |m: &CMsgGCUpdateSubGCSessionInfo| { &m.updates },
            |m: &mut CMsgGCUpdateSubGCSessionInfo| { &mut m.updates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCUpdateSubGCSessionInfo>(
            "CMsgGCUpdateSubGCSessionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCUpdateSubGCSessionInfo {
    const NAME: &'static str = "CMsgGCUpdateSubGCSessionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.updates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.updates {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCUpdateSubGCSessionInfo {
        CMsgGCUpdateSubGCSessionInfo::new()
    }

    fn clear(&mut self) {
        self.updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCUpdateSubGCSessionInfo {
        static instance: CMsgGCUpdateSubGCSessionInfo = CMsgGCUpdateSubGCSessionInfo {
            updates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCUpdateSubGCSessionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCUpdateSubGCSessionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCUpdateSubGCSessionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCUpdateSubGCSessionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCUpdateSubGCSessionInfo`
pub mod cmsg_gcupdate_sub_gcsession_info {
    // @@protoc_insertion_point(message:dota.CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgUpdate {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.ip)
        pub ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.trusted)
        pub trusted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgUpdate {
        fn default() -> &'a CMsgUpdate {
            <CMsgUpdate as ::protobuf::Message>::default_instance()
        }
    }

    impl CMsgUpdate {
        pub fn new() -> CMsgUpdate {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional fixed32 ip = 2;

        pub fn ip(&self) -> u32 {
            self.ip.unwrap_or(0)
        }

        pub fn clear_ip(&mut self) {
            self.ip = ::std::option::Option::None;
        }

        pub fn has_ip(&self) -> bool {
            self.ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ip(&mut self, v: u32) {
            self.ip = ::std::option::Option::Some(v);
        }

        // optional bool trusted = 3;

        pub fn trusted(&self) -> bool {
            self.trusted.unwrap_or(false)
        }

        pub fn clear_trusted(&mut self) {
            self.trusted = ::std::option::Option::None;
        }

        pub fn has_trusted(&self) -> bool {
            self.trusted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trusted(&mut self, v: bool) {
            self.trusted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &CMsgUpdate| { &m.steamid },
                |m: &mut CMsgUpdate| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ip",
                |m: &CMsgUpdate| { &m.ip },
                |m: &mut CMsgUpdate| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "trusted",
                |m: &CMsgUpdate| { &m.trusted },
                |m: &mut CMsgUpdate| { &mut m.trusted },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUpdate>(
                "CMsgGCUpdateSubGCSessionInfo.CMsgUpdate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CMsgUpdate {
        const NAME: &'static str = "CMsgUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.trusted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.ip {
                my_size += 1 + 4;
            }
            if let Some(v) = self.trusted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.ip {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.trusted {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgUpdate {
            CMsgUpdate::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.ip = ::std::option::Option::None;
            self.trusted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgUpdate {
            static instance: CMsgUpdate = CMsgUpdate {
                steamid: ::std::option::Option::None,
                ip: ::std::option::Option::None,
                trusted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CMsgUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCUpdateSubGCSessionInfo.CMsgUpdate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CMsgUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CMsgUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCRequestSubGCSessionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSubGCSessionInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCRequestSubGCSessionInfo.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCRequestSubGCSessionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSubGCSessionInfo {
    fn default() -> &'a CMsgGCRequestSubGCSessionInfo {
        <CMsgGCRequestSubGCSessionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSubGCSessionInfo {
    pub fn new() -> CMsgGCRequestSubGCSessionInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgGCRequestSubGCSessionInfo| { &m.steamid },
            |m: &mut CMsgGCRequestSubGCSessionInfo| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestSubGCSessionInfo>(
            "CMsgGCRequestSubGCSessionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestSubGCSessionInfo {
    const NAME: &'static str = "CMsgGCRequestSubGCSessionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSubGCSessionInfo {
        CMsgGCRequestSubGCSessionInfo::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSubGCSessionInfo {
        static instance: CMsgGCRequestSubGCSessionInfo = CMsgGCRequestSubGCSessionInfo {
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestSubGCSessionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestSubGCSessionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestSubGCSessionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestSubGCSessionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCRequestSubGCSessionInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSubGCSessionInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCRequestSubGCSessionInfoResponse.ip)
    pub ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCRequestSubGCSessionInfoResponse.trusted)
    pub trusted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCRequestSubGCSessionInfoResponse.port)
    pub port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCRequestSubGCSessionInfoResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCRequestSubGCSessionInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSubGCSessionInfoResponse {
    fn default() -> &'a CMsgGCRequestSubGCSessionInfoResponse {
        <CMsgGCRequestSubGCSessionInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSubGCSessionInfoResponse {
    pub fn new() -> CMsgGCRequestSubGCSessionInfoResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 ip = 1;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional bool trusted = 2;

    pub fn trusted(&self) -> bool {
        self.trusted.unwrap_or(false)
    }

    pub fn clear_trusted(&mut self) {
        self.trusted = ::std::option::Option::None;
    }

    pub fn has_trusted(&self) -> bool {
        self.trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted(&mut self, v: bool) {
        self.trusted = ::std::option::Option::Some(v);
    }

    // optional uint32 port = 3;

    pub fn port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional bool success = 4;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &CMsgGCRequestSubGCSessionInfoResponse| { &m.ip },
            |m: &mut CMsgGCRequestSubGCSessionInfoResponse| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trusted",
            |m: &CMsgGCRequestSubGCSessionInfoResponse| { &m.trusted },
            |m: &mut CMsgGCRequestSubGCSessionInfoResponse| { &mut m.trusted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &CMsgGCRequestSubGCSessionInfoResponse| { &m.port },
            |m: &mut CMsgGCRequestSubGCSessionInfoResponse| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgGCRequestSubGCSessionInfoResponse| { &m.success },
            |m: &mut CMsgGCRequestSubGCSessionInfoResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestSubGCSessionInfoResponse>(
            "CMsgGCRequestSubGCSessionInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestSubGCSessionInfoResponse {
    const NAME: &'static str = "CMsgGCRequestSubGCSessionInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.trusted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.trusted {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.success {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSubGCSessionInfoResponse {
        CMsgGCRequestSubGCSessionInfoResponse::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.trusted = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSubGCSessionInfoResponse {
        static instance: CMsgGCRequestSubGCSessionInfoResponse = CMsgGCRequestSubGCSessionInfoResponse {
            ip: ::std::option::Option::None,
            trusted: ::std::option::Option::None,
            port: ::std::option::Option::None,
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestSubGCSessionInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestSubGCSessionInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestSubGCSessionInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestSubGCSessionInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSOCacheHaveVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheHaveVersion {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSOCacheHaveVersion.soid)
    pub soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheHaveVersion.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheHaveVersion.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSOCacheHaveVersion.cached_file_version)
    pub cached_file_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSOCacheHaveVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheHaveVersion {
    fn default() -> &'a CMsgSOCacheHaveVersion {
        <CMsgSOCacheHaveVersion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheHaveVersion {
    pub fn new() -> CMsgSOCacheHaveVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 3;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cached_file_version = 4;

    pub fn cached_file_version(&self) -> u32 {
        self.cached_file_version.unwrap_or(0)
    }

    pub fn clear_cached_file_version(&mut self) {
        self.cached_file_version = ::std::option::Option::None;
    }

    pub fn has_cached_file_version(&self) -> bool {
        self.cached_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cached_file_version(&mut self, v: u32) {
        self.cached_file_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "soid",
            |m: &CMsgSOCacheHaveVersion| { &m.soid },
            |m: &mut CMsgSOCacheHaveVersion| { &mut m.soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheHaveVersion| { &m.version },
            |m: &mut CMsgSOCacheHaveVersion| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &CMsgSOCacheHaveVersion| { &m.service_id },
            |m: &mut CMsgSOCacheHaveVersion| { &mut m.service_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cached_file_version",
            |m: &CMsgSOCacheHaveVersion| { &m.cached_file_version },
            |m: &mut CMsgSOCacheHaveVersion| { &mut m.cached_file_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheHaveVersion>(
            "CMsgSOCacheHaveVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheHaveVersion {
    const NAME: &'static str = "CMsgSOCacheHaveVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.soid)?;
                },
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.cached_file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.cached_file_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.cached_file_version {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheHaveVersion {
        CMsgSOCacheHaveVersion::new()
    }

    fn clear(&mut self) {
        self.soid.clear();
        self.version = ::std::option::Option::None;
        self.service_id = ::std::option::Option::None;
        self.cached_file_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheHaveVersion {
        static instance: CMsgSOCacheHaveVersion = CMsgSOCacheHaveVersion {
            soid: ::protobuf::MessageField::none(),
            version: ::std::option::Option::None,
            service_id: ::std::option::Option::None,
            cached_file_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheHaveVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheHaveVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheHaveVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheHaveVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientHello {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientHello.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.socache_have_versions)
    pub socache_have_versions: ::std::vec::Vec<CMsgSOCacheHaveVersion>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.client_session_need)
    pub client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.client_launcher)
    pub client_launcher: ::std::option::Option<::protobuf::EnumOrUnknown<PartnerAccountType>>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.secret_key)
    pub secret_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.client_language)
    pub client_language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.engine)
    pub engine: ::std::option::Option<::protobuf::EnumOrUnknown<ESourceEngine>>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.steamdatagram_login)
    pub steamdatagram_login: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.platform_id)
    pub platform_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.game_msg)
    pub game_msg: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.os_type)
    pub os_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.render_system)
    pub render_system: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.render_system_req)
    pub render_system_req: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.screen_width)
    pub screen_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.screen_height)
    pub screen_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.screen_refresh)
    pub screen_refresh: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.render_width)
    pub render_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.render_height)
    pub render_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.swap_width)
    pub swap_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.swap_height)
    pub swap_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.is_steam_china)
    pub is_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.is_steam_china_client)
    pub is_steam_china_client: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgClientHello.platform_name)
    pub platform_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientHello {
    fn default() -> &'a CMsgClientHello {
        <CMsgClientHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHello {
    pub fn new() -> CMsgClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 client_session_need = 3;

    pub fn client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }

    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional .dota.PartnerAccountType client_launcher = 4;

    pub fn client_launcher(&self) -> PartnerAccountType {
        match self.client_launcher {
            Some(e) => e.enum_value_or(PartnerAccountType::PARTNER_NONE),
            None => PartnerAccountType::PARTNER_NONE,
        }
    }

    pub fn clear_client_launcher(&mut self) {
        self.client_launcher = ::std::option::Option::None;
    }

    pub fn has_client_launcher(&self) -> bool {
        self.client_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_launcher(&mut self, v: PartnerAccountType) {
        self.client_launcher = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string secret_key = 5;

    pub fn secret_key(&self) -> &str {
        match self.secret_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secret_key(&mut self) {
        self.secret_key = ::std::option::Option::None;
    }

    pub fn has_secret_key(&self) -> bool {
        self.secret_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret_key(&mut self, v: ::std::string::String) {
        self.secret_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret_key(&mut self) -> &mut ::std::string::String {
        if self.secret_key.is_none() {
            self.secret_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secret_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret_key(&mut self) -> ::std::string::String {
        self.secret_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_language = 6;

    pub fn client_language(&self) -> u32 {
        self.client_language.unwrap_or(0)
    }

    pub fn clear_client_language(&mut self) {
        self.client_language = ::std::option::Option::None;
    }

    pub fn has_client_language(&self) -> bool {
        self.client_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_language(&mut self, v: u32) {
        self.client_language = ::std::option::Option::Some(v);
    }

    // optional .dota.ESourceEngine engine = 7;

    pub fn engine(&self) -> ESourceEngine {
        match self.engine {
            Some(e) => e.enum_value_or(ESourceEngine::k_ESE_Source1),
            None => ESourceEngine::k_ESE_Source1,
        }
    }

    pub fn clear_engine(&mut self) {
        self.engine = ::std::option::Option::None;
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: ESourceEngine) {
        self.engine = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes steamdatagram_login = 8;

    pub fn steamdatagram_login(&self) -> &[u8] {
        match self.steamdatagram_login.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_steamdatagram_login(&mut self) {
        self.steamdatagram_login = ::std::option::Option::None;
    }

    pub fn has_steamdatagram_login(&self) -> bool {
        self.steamdatagram_login.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamdatagram_login(&mut self, v: ::std::vec::Vec<u8>) {
        self.steamdatagram_login = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steamdatagram_login(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.steamdatagram_login.is_none() {
            self.steamdatagram_login = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.steamdatagram_login.as_mut().unwrap()
    }

    // Take field
    pub fn take_steamdatagram_login(&mut self) -> ::std::vec::Vec<u8> {
        self.steamdatagram_login.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 platform_id = 9;

    pub fn platform_id(&self) -> u32 {
        self.platform_id.unwrap_or(0)
    }

    pub fn clear_platform_id(&mut self) {
        self.platform_id = ::std::option::Option::None;
    }

    pub fn has_platform_id(&self) -> bool {
        self.platform_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_id(&mut self, v: u32) {
        self.platform_id = ::std::option::Option::Some(v);
    }

    // optional bytes game_msg = 10;

    pub fn game_msg(&self) -> &[u8] {
        match self.game_msg.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_msg(&mut self) {
        self.game_msg = ::std::option::Option::None;
    }

    pub fn has_game_msg(&self) -> bool {
        self.game_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_msg.is_none() {
            self.game_msg = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_msg(&mut self) -> ::std::vec::Vec<u8> {
        self.game_msg.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 os_type = 11;

    pub fn os_type(&self) -> i32 {
        self.os_type.unwrap_or(0)
    }

    pub fn clear_os_type(&mut self) {
        self.os_type = ::std::option::Option::None;
    }

    pub fn has_os_type(&self) -> bool {
        self.os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_type(&mut self, v: i32) {
        self.os_type = ::std::option::Option::Some(v);
    }

    // optional uint32 render_system = 12;

    pub fn render_system(&self) -> u32 {
        self.render_system.unwrap_or(0)
    }

    pub fn clear_render_system(&mut self) {
        self.render_system = ::std::option::Option::None;
    }

    pub fn has_render_system(&self) -> bool {
        self.render_system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_system(&mut self, v: u32) {
        self.render_system = ::std::option::Option::Some(v);
    }

    // optional uint32 render_system_req = 13;

    pub fn render_system_req(&self) -> u32 {
        self.render_system_req.unwrap_or(0)
    }

    pub fn clear_render_system_req(&mut self) {
        self.render_system_req = ::std::option::Option::None;
    }

    pub fn has_render_system_req(&self) -> bool {
        self.render_system_req.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_system_req(&mut self, v: u32) {
        self.render_system_req = ::std::option::Option::Some(v);
    }

    // optional uint32 screen_width = 14;

    pub fn screen_width(&self) -> u32 {
        self.screen_width.unwrap_or(0)
    }

    pub fn clear_screen_width(&mut self) {
        self.screen_width = ::std::option::Option::None;
    }

    pub fn has_screen_width(&self) -> bool {
        self.screen_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_width(&mut self, v: u32) {
        self.screen_width = ::std::option::Option::Some(v);
    }

    // optional uint32 screen_height = 15;

    pub fn screen_height(&self) -> u32 {
        self.screen_height.unwrap_or(0)
    }

    pub fn clear_screen_height(&mut self) {
        self.screen_height = ::std::option::Option::None;
    }

    pub fn has_screen_height(&self) -> bool {
        self.screen_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_height(&mut self, v: u32) {
        self.screen_height = ::std::option::Option::Some(v);
    }

    // optional uint32 screen_refresh = 16;

    pub fn screen_refresh(&self) -> u32 {
        self.screen_refresh.unwrap_or(0)
    }

    pub fn clear_screen_refresh(&mut self) {
        self.screen_refresh = ::std::option::Option::None;
    }

    pub fn has_screen_refresh(&self) -> bool {
        self.screen_refresh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_refresh(&mut self, v: u32) {
        self.screen_refresh = ::std::option::Option::Some(v);
    }

    // optional uint32 render_width = 17;

    pub fn render_width(&self) -> u32 {
        self.render_width.unwrap_or(0)
    }

    pub fn clear_render_width(&mut self) {
        self.render_width = ::std::option::Option::None;
    }

    pub fn has_render_width(&self) -> bool {
        self.render_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_width(&mut self, v: u32) {
        self.render_width = ::std::option::Option::Some(v);
    }

    // optional uint32 render_height = 18;

    pub fn render_height(&self) -> u32 {
        self.render_height.unwrap_or(0)
    }

    pub fn clear_render_height(&mut self) {
        self.render_height = ::std::option::Option::None;
    }

    pub fn has_render_height(&self) -> bool {
        self.render_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_height(&mut self, v: u32) {
        self.render_height = ::std::option::Option::Some(v);
    }

    // optional uint32 swap_width = 19;

    pub fn swap_width(&self) -> u32 {
        self.swap_width.unwrap_or(0)
    }

    pub fn clear_swap_width(&mut self) {
        self.swap_width = ::std::option::Option::None;
    }

    pub fn has_swap_width(&self) -> bool {
        self.swap_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap_width(&mut self, v: u32) {
        self.swap_width = ::std::option::Option::Some(v);
    }

    // optional uint32 swap_height = 20;

    pub fn swap_height(&self) -> u32 {
        self.swap_height.unwrap_or(0)
    }

    pub fn clear_swap_height(&mut self) {
        self.swap_height = ::std::option::Option::None;
    }

    pub fn has_swap_height(&self) -> bool {
        self.swap_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap_height(&mut self, v: u32) {
        self.swap_height = ::std::option::Option::Some(v);
    }

    // optional bool is_steam_china = 22;

    pub fn is_steam_china(&self) -> bool {
        self.is_steam_china.unwrap_or(false)
    }

    pub fn clear_is_steam_china(&mut self) {
        self.is_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_steam_china(&self) -> bool {
        self.is_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steam_china(&mut self, v: bool) {
        self.is_steam_china = ::std::option::Option::Some(v);
    }

    // optional bool is_steam_china_client = 24;

    pub fn is_steam_china_client(&self) -> bool {
        self.is_steam_china_client.unwrap_or(false)
    }

    pub fn clear_is_steam_china_client(&mut self) {
        self.is_steam_china_client = ::std::option::Option::None;
    }

    pub fn has_is_steam_china_client(&self) -> bool {
        self.is_steam_china_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steam_china_client(&mut self, v: bool) {
        self.is_steam_china_client = ::std::option::Option::Some(v);
    }

    // optional string platform_name = 23;

    pub fn platform_name(&self) -> &str {
        match self.platform_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_platform_name(&mut self) {
        self.platform_name = ::std::option::Option::None;
    }

    pub fn has_platform_name(&self) -> bool {
        self.platform_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_name(&mut self, v: ::std::string::String) {
        self.platform_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_name(&mut self) -> &mut ::std::string::String {
        if self.platform_name.is_none() {
            self.platform_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.platform_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_name(&mut self) -> ::std::string::String {
        self.platform_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgClientHello| { &m.version },
            |m: &mut CMsgClientHello| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "socache_have_versions",
            |m: &CMsgClientHello| { &m.socache_have_versions },
            |m: &mut CMsgClientHello| { &mut m.socache_have_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_session_need",
            |m: &CMsgClientHello| { &m.client_session_need },
            |m: &mut CMsgClientHello| { &mut m.client_session_need },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_launcher",
            |m: &CMsgClientHello| { &m.client_launcher },
            |m: &mut CMsgClientHello| { &mut m.client_launcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secret_key",
            |m: &CMsgClientHello| { &m.secret_key },
            |m: &mut CMsgClientHello| { &mut m.secret_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_language",
            |m: &CMsgClientHello| { &m.client_language },
            |m: &mut CMsgClientHello| { &mut m.client_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engine",
            |m: &CMsgClientHello| { &m.engine },
            |m: &mut CMsgClientHello| { &mut m.engine },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamdatagram_login",
            |m: &CMsgClientHello| { &m.steamdatagram_login },
            |m: &mut CMsgClientHello| { &mut m.steamdatagram_login },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_id",
            |m: &CMsgClientHello| { &m.platform_id },
            |m: &mut CMsgClientHello| { &mut m.platform_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_msg",
            |m: &CMsgClientHello| { &m.game_msg },
            |m: &mut CMsgClientHello| { &mut m.game_msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_type",
            |m: &CMsgClientHello| { &m.os_type },
            |m: &mut CMsgClientHello| { &mut m.os_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "render_system",
            |m: &CMsgClientHello| { &m.render_system },
            |m: &mut CMsgClientHello| { &mut m.render_system },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "render_system_req",
            |m: &CMsgClientHello| { &m.render_system_req },
            |m: &mut CMsgClientHello| { &mut m.render_system_req },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "screen_width",
            |m: &CMsgClientHello| { &m.screen_width },
            |m: &mut CMsgClientHello| { &mut m.screen_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "screen_height",
            |m: &CMsgClientHello| { &m.screen_height },
            |m: &mut CMsgClientHello| { &mut m.screen_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "screen_refresh",
            |m: &CMsgClientHello| { &m.screen_refresh },
            |m: &mut CMsgClientHello| { &mut m.screen_refresh },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "render_width",
            |m: &CMsgClientHello| { &m.render_width },
            |m: &mut CMsgClientHello| { &mut m.render_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "render_height",
            |m: &CMsgClientHello| { &m.render_height },
            |m: &mut CMsgClientHello| { &mut m.render_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swap_width",
            |m: &CMsgClientHello| { &m.swap_width },
            |m: &mut CMsgClientHello| { &mut m.swap_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swap_height",
            |m: &CMsgClientHello| { &m.swap_height },
            |m: &mut CMsgClientHello| { &mut m.swap_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_steam_china",
            |m: &CMsgClientHello| { &m.is_steam_china },
            |m: &mut CMsgClientHello| { &mut m.is_steam_china },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_steam_china_client",
            |m: &CMsgClientHello| { &m.is_steam_china_client },
            |m: &mut CMsgClientHello| { &mut m.is_steam_china_client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_name",
            |m: &CMsgClientHello| { &m.platform_name },
            |m: &mut CMsgClientHello| { &mut m.platform_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientHello>(
            "CMsgClientHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientHello {
    const NAME: &'static str = "CMsgClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.socache_have_versions.push(is.read_message()?);
                },
                24 => {
                    self.client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.client_launcher = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.secret_key = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.client_language = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.engine = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                66 => {
                    self.steamdatagram_login = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.platform_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.game_msg = ::std::option::Option::Some(is.read_bytes()?);
                },
                88 => {
                    self.os_type = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.render_system = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.render_system_req = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.screen_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.screen_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.screen_refresh = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.render_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.render_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.swap_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.swap_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.is_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.is_steam_china_client = ::std::option::Option::Some(is.read_bool()?);
                },
                186 => {
                    self.platform_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.socache_have_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.client_session_need {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.client_launcher {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.secret_key.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.client_language {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.engine {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.steamdatagram_login.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.platform_id {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.game_msg.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.os_type {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.render_system {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.render_system_req {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.screen_width {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.screen_height {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.screen_refresh {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.render_width {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.render_height {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.swap_width {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.swap_height {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.is_steam_china {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_steam_china_client {
            my_size += 2 + 1;
        }
        if let Some(v) = self.platform_name.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.socache_have_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.client_session_need {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_launcher {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.secret_key.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.client_language {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.engine {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.steamdatagram_login.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.platform_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.game_msg.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.os_type {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.render_system {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.render_system_req {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.screen_width {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.screen_height {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.screen_refresh {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.render_width {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.render_height {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.swap_width {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.swap_height {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.is_steam_china {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.is_steam_china_client {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.platform_name.as_ref() {
            os.write_string(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientHello {
        CMsgClientHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.socache_have_versions.clear();
        self.client_session_need = ::std::option::Option::None;
        self.client_launcher = ::std::option::Option::None;
        self.secret_key = ::std::option::Option::None;
        self.client_language = ::std::option::Option::None;
        self.engine = ::std::option::Option::None;
        self.steamdatagram_login = ::std::option::Option::None;
        self.platform_id = ::std::option::Option::None;
        self.game_msg = ::std::option::Option::None;
        self.os_type = ::std::option::Option::None;
        self.render_system = ::std::option::Option::None;
        self.render_system_req = ::std::option::Option::None;
        self.screen_width = ::std::option::Option::None;
        self.screen_height = ::std::option::Option::None;
        self.screen_refresh = ::std::option::Option::None;
        self.render_width = ::std::option::Option::None;
        self.render_height = ::std::option::Option::None;
        self.swap_width = ::std::option::Option::None;
        self.swap_height = ::std::option::Option::None;
        self.is_steam_china = ::std::option::Option::None;
        self.is_steam_china_client = ::std::option::Option::None;
        self.platform_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientHello {
        static instance: CMsgClientHello = CMsgClientHello {
            version: ::std::option::Option::None,
            socache_have_versions: ::std::vec::Vec::new(),
            client_session_need: ::std::option::Option::None,
            client_launcher: ::std::option::Option::None,
            secret_key: ::std::option::Option::None,
            client_language: ::std::option::Option::None,
            engine: ::std::option::Option::None,
            steamdatagram_login: ::std::option::Option::None,
            platform_id: ::std::option::Option::None,
            game_msg: ::std::option::Option::None,
            os_type: ::std::option::Option::None,
            render_system: ::std::option::Option::None,
            render_system_req: ::std::option::Option::None,
            screen_width: ::std::option::Option::None,
            screen_height: ::std::option::Option::None,
            screen_refresh: ::std::option::Option::None,
            render_width: ::std::option::Option::None,
            render_height: ::std::option::Option::None,
            swap_width: ::std::option::Option::None,
            swap_height: ::std::option::Option::None,
            is_steam_china: ::std::option::Option::None,
            is_steam_china_client: ::std::option::Option::None,
            platform_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientWelcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWelcome {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.game_data)
    pub game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.outofdate_subscribed_caches)
    pub outofdate_subscribed_caches: ::std::vec::Vec<CMsgSOCacheSubscribed>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.uptodate_subscribed_caches)
    pub uptodate_subscribed_caches: ::std::vec::Vec<CMsgSOCacheSubscriptionCheck>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.location)
    pub location: ::protobuf::MessageField<cmsg_client_welcome::Location>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.save_game_key)
    pub save_game_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.gc_socache_file_version)
    pub gc_socache_file_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.txn_country_code)
    pub txn_country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.game_data2)
    pub game_data2: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.rtime32_gc_welcome_timestamp)
    pub rtime32_gc_welcome_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.currency)
    pub currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.balance)
    pub balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.balance_url)
    pub balance_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.has_accepted_china_ssa)
    pub has_accepted_china_ssa: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.is_banned_steam_china)
    pub is_banned_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.additional_welcome_msgs)
    pub additional_welcome_msgs: ::protobuf::MessageField<CExtraMsgBlock>,
    // @@protoc_insertion_point(field:dota.CMsgClientWelcome.steam_learn_hmac_keys)
    pub steam_learn_hmac_keys: ::protobuf::MessageField<super::steammessages_steamlearn_steamworkssdk::CMsgSteamLearnHMACKeys>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientWelcome.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWelcome {
    fn default() -> &'a CMsgClientWelcome {
        <CMsgClientWelcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWelcome {
    pub fn new() -> CMsgClientWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes game_data = 2;

    pub fn game_data(&self) -> &[u8] {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes save_game_key = 6;

    pub fn save_game_key(&self) -> &[u8] {
        match self.save_game_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_save_game_key(&mut self) {
        self.save_game_key = ::std::option::Option::None;
    }

    pub fn has_save_game_key(&self) -> bool {
        self.save_game_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_game_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.save_game_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_game_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.save_game_key.is_none() {
            self.save_game_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.save_game_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_game_key(&mut self) -> ::std::vec::Vec<u8> {
        self.save_game_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 gc_socache_file_version = 9;

    pub fn gc_socache_file_version(&self) -> u32 {
        self.gc_socache_file_version.unwrap_or(0)
    }

    pub fn clear_gc_socache_file_version(&mut self) {
        self.gc_socache_file_version = ::std::option::Option::None;
    }

    pub fn has_gc_socache_file_version(&self) -> bool {
        self.gc_socache_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_socache_file_version(&mut self, v: u32) {
        self.gc_socache_file_version = ::std::option::Option::Some(v);
    }

    // optional string txn_country_code = 10;

    pub fn txn_country_code(&self) -> &str {
        match self.txn_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_txn_country_code(&mut self) {
        self.txn_country_code = ::std::option::Option::None;
    }

    pub fn has_txn_country_code(&self) -> bool {
        self.txn_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_country_code(&mut self, v: ::std::string::String) {
        self.txn_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_country_code(&mut self) -> &mut ::std::string::String {
        if self.txn_country_code.is_none() {
            self.txn_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.txn_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_country_code(&mut self) -> ::std::string::String {
        self.txn_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes game_data2 = 11;

    pub fn game_data2(&self) -> &[u8] {
        match self.game_data2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data2(&mut self) {
        self.game_data2 = ::std::option::Option::None;
    }

    pub fn has_game_data2(&self) -> bool {
        self.game_data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data2.is_none() {
            self.game_data2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 rtime32_gc_welcome_timestamp = 12;

    pub fn rtime32_gc_welcome_timestamp(&self) -> u32 {
        self.rtime32_gc_welcome_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_gc_welcome_timestamp(&mut self) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_gc_welcome_timestamp(&self) -> bool {
        self.rtime32_gc_welcome_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_gc_welcome_timestamp(&mut self, v: u32) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 13;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional uint32 balance = 14;

    pub fn balance(&self) -> u32 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: u32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional string balance_url = 15;

    pub fn balance_url(&self) -> &str {
        match self.balance_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_balance_url(&mut self) {
        self.balance_url = ::std::option::Option::None;
    }

    pub fn has_balance_url(&self) -> bool {
        self.balance_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_url(&mut self, v: ::std::string::String) {
        self.balance_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance_url(&mut self) -> &mut ::std::string::String {
        if self.balance_url.is_none() {
            self.balance_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.balance_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_balance_url(&mut self) -> ::std::string::String {
        self.balance_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool has_accepted_china_ssa = 16;

    pub fn has_accepted_china_ssa(&self) -> bool {
        self.has_accepted_china_ssa.unwrap_or(false)
    }

    pub fn clear_has_accepted_china_ssa(&mut self) {
        self.has_accepted_china_ssa = ::std::option::Option::None;
    }

    pub fn has_has_accepted_china_ssa(&self) -> bool {
        self.has_accepted_china_ssa.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_accepted_china_ssa(&mut self, v: bool) {
        self.has_accepted_china_ssa = ::std::option::Option::Some(v);
    }

    // optional bool is_banned_steam_china = 17;

    pub fn is_banned_steam_china(&self) -> bool {
        self.is_banned_steam_china.unwrap_or(false)
    }

    pub fn clear_is_banned_steam_china(&mut self) {
        self.is_banned_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_banned_steam_china(&self) -> bool {
        self.is_banned_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_banned_steam_china(&mut self, v: bool) {
        self.is_banned_steam_china = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgClientWelcome| { &m.version },
            |m: &mut CMsgClientWelcome| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_data",
            |m: &CMsgClientWelcome| { &m.game_data },
            |m: &mut CMsgClientWelcome| { &mut m.game_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outofdate_subscribed_caches",
            |m: &CMsgClientWelcome| { &m.outofdate_subscribed_caches },
            |m: &mut CMsgClientWelcome| { &mut m.outofdate_subscribed_caches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uptodate_subscribed_caches",
            |m: &CMsgClientWelcome| { &m.uptodate_subscribed_caches },
            |m: &mut CMsgClientWelcome| { &mut m.uptodate_subscribed_caches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_welcome::Location>(
            "location",
            |m: &CMsgClientWelcome| { &m.location },
            |m: &mut CMsgClientWelcome| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "save_game_key",
            |m: &CMsgClientWelcome| { &m.save_game_key },
            |m: &mut CMsgClientWelcome| { &mut m.save_game_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gc_socache_file_version",
            |m: &CMsgClientWelcome| { &m.gc_socache_file_version },
            |m: &mut CMsgClientWelcome| { &mut m.gc_socache_file_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_country_code",
            |m: &CMsgClientWelcome| { &m.txn_country_code },
            |m: &mut CMsgClientWelcome| { &mut m.txn_country_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_data2",
            |m: &CMsgClientWelcome| { &m.game_data2 },
            |m: &mut CMsgClientWelcome| { &mut m.game_data2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_gc_welcome_timestamp",
            |m: &CMsgClientWelcome| { &m.rtime32_gc_welcome_timestamp },
            |m: &mut CMsgClientWelcome| { &mut m.rtime32_gc_welcome_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgClientWelcome| { &m.currency },
            |m: &mut CMsgClientWelcome| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance",
            |m: &CMsgClientWelcome| { &m.balance },
            |m: &mut CMsgClientWelcome| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_url",
            |m: &CMsgClientWelcome| { &m.balance_url },
            |m: &mut CMsgClientWelcome| { &mut m.balance_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_accepted_china_ssa",
            |m: &CMsgClientWelcome| { &m.has_accepted_china_ssa },
            |m: &mut CMsgClientWelcome| { &mut m.has_accepted_china_ssa },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_banned_steam_china",
            |m: &CMsgClientWelcome| { &m.is_banned_steam_china },
            |m: &mut CMsgClientWelcome| { &mut m.is_banned_steam_china },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CExtraMsgBlock>(
            "additional_welcome_msgs",
            |m: &CMsgClientWelcome| { &m.additional_welcome_msgs },
            |m: &mut CMsgClientWelcome| { &mut m.additional_welcome_msgs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_steamlearn_steamworkssdk::CMsgSteamLearnHMACKeys>(
            "steam_learn_hmac_keys",
            |m: &CMsgClientWelcome| { &m.steam_learn_hmac_keys },
            |m: &mut CMsgClientWelcome| { &mut m.steam_learn_hmac_keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWelcome>(
            "CMsgClientWelcome",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientWelcome {
    const NAME: &'static str = "CMsgClientWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.outofdate_subscribed_caches.push(is.read_message()?);
                },
                34 => {
                    self.uptodate_subscribed_caches.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                50 => {
                    self.save_game_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.gc_socache_file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.txn_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.game_data2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.balance_url = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.has_accepted_china_ssa = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.is_banned_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.additional_welcome_msgs)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.steam_learn_hmac_keys)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.outofdate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.uptodate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.save_game_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.gc_socache_file_version {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.game_data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.balance_url.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.has_accepted_china_ssa {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_banned_steam_china {
            my_size += 2 + 1;
        }
        if let Some(v) = self.additional_welcome_msgs.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.steam_learn_hmac_keys.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.outofdate_subscribed_caches {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.uptodate_subscribed_caches {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.location.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.save_game_key.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.gc_socache_file_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.game_data2.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.balance {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.balance_url.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.has_accepted_china_ssa {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.is_banned_steam_china {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.additional_welcome_msgs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.steam_learn_hmac_keys.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWelcome {
        CMsgClientWelcome::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.outofdate_subscribed_caches.clear();
        self.uptodate_subscribed_caches.clear();
        self.location.clear();
        self.save_game_key = ::std::option::Option::None;
        self.gc_socache_file_version = ::std::option::Option::None;
        self.txn_country_code = ::std::option::Option::None;
        self.game_data2 = ::std::option::Option::None;
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.balance_url = ::std::option::Option::None;
        self.has_accepted_china_ssa = ::std::option::Option::None;
        self.is_banned_steam_china = ::std::option::Option::None;
        self.additional_welcome_msgs.clear();
        self.steam_learn_hmac_keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWelcome {
        static instance: CMsgClientWelcome = CMsgClientWelcome {
            version: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            outofdate_subscribed_caches: ::std::vec::Vec::new(),
            uptodate_subscribed_caches: ::std::vec::Vec::new(),
            location: ::protobuf::MessageField::none(),
            save_game_key: ::std::option::Option::None,
            gc_socache_file_version: ::std::option::Option::None,
            txn_country_code: ::std::option::Option::None,
            game_data2: ::std::option::Option::None,
            rtime32_gc_welcome_timestamp: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            balance_url: ::std::option::Option::None,
            has_accepted_china_ssa: ::std::option::Option::None,
            is_banned_steam_china: ::std::option::Option::None,
            additional_welcome_msgs: ::protobuf::MessageField::none(),
            steam_learn_hmac_keys: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientWelcome {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWelcome").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWelcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWelcome {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientWelcome`
pub mod cmsg_client_welcome {
    // @@protoc_insertion_point(message:dota.CMsgClientWelcome.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientWelcome.Location.latitude)
        pub latitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgClientWelcome.Location.longitude)
        pub longitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgClientWelcome.Location.country)
        pub country: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientWelcome.Location.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional float latitude = 1;

        pub fn latitude(&self) -> f32 {
            self.latitude.unwrap_or(0.)
        }

        pub fn clear_latitude(&mut self) {
            self.latitude = ::std::option::Option::None;
        }

        pub fn has_latitude(&self) -> bool {
            self.latitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_latitude(&mut self, v: f32) {
            self.latitude = ::std::option::Option::Some(v);
        }

        // optional float longitude = 2;

        pub fn longitude(&self) -> f32 {
            self.longitude.unwrap_or(0.)
        }

        pub fn clear_longitude(&mut self) {
            self.longitude = ::std::option::Option::None;
        }

        pub fn has_longitude(&self) -> bool {
            self.longitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_longitude(&mut self, v: f32) {
            self.longitude = ::std::option::Option::Some(v);
        }

        // optional string country = 3;

        pub fn country(&self) -> &str {
            match self.country.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country(&mut self) {
            self.country = ::std::option::Option::None;
        }

        pub fn has_country(&self) -> bool {
            self.country.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country(&mut self, v: ::std::string::String) {
            self.country = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country(&mut self) -> &mut ::std::string::String {
            if self.country.is_none() {
                self.country = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country.as_mut().unwrap()
        }

        // Take field
        pub fn take_country(&mut self) -> ::std::string::String {
            self.country.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "latitude",
                |m: &Location| { &m.latitude },
                |m: &mut Location| { &mut m.latitude },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "longitude",
                |m: &Location| { &m.longitude },
                |m: &mut Location| { &mut m.longitude },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "country",
                |m: &Location| { &m.country },
                |m: &mut Location| { &mut m.country },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
                "CMsgClientWelcome.Location",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.latitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.longitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.country = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.latitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.longitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.country.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.latitude {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.longitude {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.country.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.latitude = ::std::option::Option::None;
            self.longitude = ::std::option::Option::None;
            self.country = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                latitude: ::std::option::Option::None,
                longitude: ::std::option::Option::None,
                country: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Location {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientWelcome.Location").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Location {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Location {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgConnectionStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConnectionStatus {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgConnectionStatus.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<GCConnectionStatus>>,
    // @@protoc_insertion_point(field:dota.CMsgConnectionStatus.client_session_need)
    pub client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgConnectionStatus.queue_position)
    pub queue_position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgConnectionStatus.queue_size)
    pub queue_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgConnectionStatus.wait_seconds)
    pub wait_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgConnectionStatus.estimated_wait_seconds_remaining)
    pub estimated_wait_seconds_remaining: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgConnectionStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConnectionStatus {
    fn default() -> &'a CMsgConnectionStatus {
        <CMsgConnectionStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConnectionStatus {
    pub fn new() -> CMsgConnectionStatus {
        ::std::default::Default::default()
    }

    // optional .dota.GCConnectionStatus status = 1;

    pub fn status(&self) -> GCConnectionStatus {
        match self.status {
            Some(e) => e.enum_value_or(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            None => GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: GCConnectionStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 client_session_need = 2;

    pub fn client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }

    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;

    pub fn queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }

    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 queue_size = 4;

    pub fn queue_size(&self) -> i32 {
        self.queue_size.unwrap_or(0)
    }

    pub fn clear_queue_size(&mut self) {
        self.queue_size = ::std::option::Option::None;
    }

    pub fn has_queue_size(&self) -> bool {
        self.queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_size(&mut self, v: i32) {
        self.queue_size = ::std::option::Option::Some(v);
    }

    // optional int32 wait_seconds = 5;

    pub fn wait_seconds(&self) -> i32 {
        self.wait_seconds.unwrap_or(0)
    }

    pub fn clear_wait_seconds(&mut self) {
        self.wait_seconds = ::std::option::Option::None;
    }

    pub fn has_wait_seconds(&self) -> bool {
        self.wait_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wait_seconds(&mut self, v: i32) {
        self.wait_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 estimated_wait_seconds_remaining = 6;

    pub fn estimated_wait_seconds_remaining(&self) -> i32 {
        self.estimated_wait_seconds_remaining.unwrap_or(0)
    }

    pub fn clear_estimated_wait_seconds_remaining(&mut self) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_estimated_wait_seconds_remaining(&self) -> bool {
        self.estimated_wait_seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimated_wait_seconds_remaining(&mut self, v: i32) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CMsgConnectionStatus| { &m.status },
            |m: &mut CMsgConnectionStatus| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_session_need",
            |m: &CMsgConnectionStatus| { &m.client_session_need },
            |m: &mut CMsgConnectionStatus| { &mut m.client_session_need },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_position",
            |m: &CMsgConnectionStatus| { &m.queue_position },
            |m: &mut CMsgConnectionStatus| { &mut m.queue_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_size",
            |m: &CMsgConnectionStatus| { &m.queue_size },
            |m: &mut CMsgConnectionStatus| { &mut m.queue_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wait_seconds",
            |m: &CMsgConnectionStatus| { &m.wait_seconds },
            |m: &mut CMsgConnectionStatus| { &mut m.wait_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "estimated_wait_seconds_remaining",
            |m: &CMsgConnectionStatus| { &m.estimated_wait_seconds_remaining },
            |m: &mut CMsgConnectionStatus| { &mut m.estimated_wait_seconds_remaining },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConnectionStatus>(
            "CMsgConnectionStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConnectionStatus {
    const NAME: &'static str = "CMsgConnectionStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.queue_size = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.wait_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.estimated_wait_seconds_remaining = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.client_session_need {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.queue_position {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.queue_size {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.wait_seconds {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.client_session_need {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wait_seconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConnectionStatus {
        CMsgConnectionStatus::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.client_session_need = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.queue_size = ::std::option::Option::None;
        self.wait_seconds = ::std::option::Option::None;
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConnectionStatus {
        static instance: CMsgConnectionStatus = CMsgConnectionStatus {
            status: ::std::option::Option::None,
            client_session_need: ::std::option::Option::None,
            queue_position: ::std::option::Option::None,
            queue_size: ::std::option::Option::None,
            wait_seconds: ::std::option::Option::None,
            estimated_wait_seconds_remaining: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConnectionStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConnectionStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConnectionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConnectionStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCSOCacheSubscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSOCacheSubscribe {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheSubscribe.subscriber)
    pub subscriber: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheSubscribe.subscribe_to_id)
    pub subscribe_to_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheSubscribe.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheSubscribe.have_versions)
    pub have_versions: ::std::vec::Vec<cmsg_gcto_gcsocache_subscribe::CMsgHaveVersions>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheSubscribe.subscribe_to_type)
    pub subscribe_to_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCSOCacheSubscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSOCacheSubscribe {
    fn default() -> &'a CMsgGCToGCSOCacheSubscribe {
        <CMsgGCToGCSOCacheSubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSOCacheSubscribe {
    pub fn new() -> CMsgGCToGCSOCacheSubscribe {
        ::std::default::Default::default()
    }

    // optional fixed64 subscriber = 1;

    pub fn subscriber(&self) -> u64 {
        self.subscriber.unwrap_or(0)
    }

    pub fn clear_subscriber(&mut self) {
        self.subscriber = ::std::option::Option::None;
    }

    pub fn has_subscriber(&self) -> bool {
        self.subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber(&mut self, v: u64) {
        self.subscriber = ::std::option::Option::Some(v);
    }

    // optional fixed64 subscribe_to_id = 2;

    pub fn subscribe_to_id(&self) -> u64 {
        self.subscribe_to_id.unwrap_or(0)
    }

    pub fn clear_subscribe_to_id(&mut self) {
        self.subscribe_to_id = ::std::option::Option::None;
    }

    pub fn has_subscribe_to_id(&self) -> bool {
        self.subscribe_to_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe_to_id(&mut self, v: u64) {
        self.subscribe_to_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 3;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    // optional uint32 subscribe_to_type = 5;

    pub fn subscribe_to_type(&self) -> u32 {
        self.subscribe_to_type.unwrap_or(0)
    }

    pub fn clear_subscribe_to_type(&mut self) {
        self.subscribe_to_type = ::std::option::Option::None;
    }

    pub fn has_subscribe_to_type(&self) -> bool {
        self.subscribe_to_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe_to_type(&mut self, v: u32) {
        self.subscribe_to_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscriber",
            |m: &CMsgGCToGCSOCacheSubscribe| { &m.subscriber },
            |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.subscriber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscribe_to_id",
            |m: &CMsgGCToGCSOCacheSubscribe| { &m.subscribe_to_id },
            |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.subscribe_to_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sync_version",
            |m: &CMsgGCToGCSOCacheSubscribe| { &m.sync_version },
            |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.sync_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "have_versions",
            |m: &CMsgGCToGCSOCacheSubscribe| { &m.have_versions },
            |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.have_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscribe_to_type",
            |m: &CMsgGCToGCSOCacheSubscribe| { &m.subscribe_to_type },
            |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.subscribe_to_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCSOCacheSubscribe>(
            "CMsgGCToGCSOCacheSubscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCSOCacheSubscribe {
    const NAME: &'static str = "CMsgGCToGCSOCacheSubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.subscriber = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.subscribe_to_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.have_versions.push(is.read_message()?);
                },
                40 => {
                    self.subscribe_to_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subscriber {
            my_size += 1 + 8;
        }
        if let Some(v) = self.subscribe_to_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        for value in &self.have_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.subscribe_to_type {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subscriber {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.subscribe_to_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.sync_version {
            os.write_fixed64(3, v)?;
        }
        for v in &self.have_versions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.subscribe_to_type {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSOCacheSubscribe {
        CMsgGCToGCSOCacheSubscribe::new()
    }

    fn clear(&mut self) {
        self.subscriber = ::std::option::Option::None;
        self.subscribe_to_id = ::std::option::Option::None;
        self.sync_version = ::std::option::Option::None;
        self.have_versions.clear();
        self.subscribe_to_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSOCacheSubscribe {
        static instance: CMsgGCToGCSOCacheSubscribe = CMsgGCToGCSOCacheSubscribe {
            subscriber: ::std::option::Option::None,
            subscribe_to_id: ::std::option::Option::None,
            sync_version: ::std::option::Option::None,
            have_versions: ::std::vec::Vec::new(),
            subscribe_to_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCSOCacheSubscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCSOCacheSubscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCSOCacheSubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCSOCacheSubscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCToGCSOCacheSubscribe`
pub mod cmsg_gcto_gcsocache_subscribe {
    // @@protoc_insertion_point(message:dota.CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgHaveVersions {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions.service_id)
        pub service_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions.version)
        pub version: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgHaveVersions {
        fn default() -> &'a CMsgHaveVersions {
            <CMsgHaveVersions as ::protobuf::Message>::default_instance()
        }
    }

    impl CMsgHaveVersions {
        pub fn new() -> CMsgHaveVersions {
            ::std::default::Default::default()
        }

        // optional uint32 service_id = 1;

        pub fn service_id(&self) -> u32 {
            self.service_id.unwrap_or(0)
        }

        pub fn clear_service_id(&mut self) {
            self.service_id = ::std::option::Option::None;
        }

        pub fn has_service_id(&self) -> bool {
            self.service_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_service_id(&mut self, v: u32) {
            self.service_id = ::std::option::Option::Some(v);
        }

        // optional uint64 version = 2;

        pub fn version(&self) -> u64 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: u64) {
            self.version = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "service_id",
                |m: &CMsgHaveVersions| { &m.service_id },
                |m: &mut CMsgHaveVersions| { &mut m.service_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &CMsgHaveVersions| { &m.version },
                |m: &mut CMsgHaveVersions| { &mut m.version },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHaveVersions>(
                "CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CMsgHaveVersions {
        const NAME: &'static str = "CMsgHaveVersions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.version = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.service_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.version {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.service_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.version {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgHaveVersions {
            CMsgHaveVersions::new()
        }

        fn clear(&mut self) {
            self.service_id = ::std::option::Option::None;
            self.version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgHaveVersions {
            static instance: CMsgHaveVersions = CMsgHaveVersions {
                service_id: ::std::option::Option::None,
                version: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CMsgHaveVersions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CMsgHaveVersions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CMsgHaveVersions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCSOCacheUnsubscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSOCacheUnsubscribe {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheUnsubscribe.subscriber)
    pub subscriber: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheUnsubscribe.unsubscribe_from_id)
    pub unsubscribe_from_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCSOCacheUnsubscribe.unsubscribe_from_type)
    pub unsubscribe_from_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCSOCacheUnsubscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSOCacheUnsubscribe {
    fn default() -> &'a CMsgGCToGCSOCacheUnsubscribe {
        <CMsgGCToGCSOCacheUnsubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSOCacheUnsubscribe {
    pub fn new() -> CMsgGCToGCSOCacheUnsubscribe {
        ::std::default::Default::default()
    }

    // optional fixed64 subscriber = 1;

    pub fn subscriber(&self) -> u64 {
        self.subscriber.unwrap_or(0)
    }

    pub fn clear_subscriber(&mut self) {
        self.subscriber = ::std::option::Option::None;
    }

    pub fn has_subscriber(&self) -> bool {
        self.subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber(&mut self, v: u64) {
        self.subscriber = ::std::option::Option::Some(v);
    }

    // optional fixed64 unsubscribe_from_id = 2;

    pub fn unsubscribe_from_id(&self) -> u64 {
        self.unsubscribe_from_id.unwrap_or(0)
    }

    pub fn clear_unsubscribe_from_id(&mut self) {
        self.unsubscribe_from_id = ::std::option::Option::None;
    }

    pub fn has_unsubscribe_from_id(&self) -> bool {
        self.unsubscribe_from_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe_from_id(&mut self, v: u64) {
        self.unsubscribe_from_id = ::std::option::Option::Some(v);
    }

    // optional uint32 unsubscribe_from_type = 3;

    pub fn unsubscribe_from_type(&self) -> u32 {
        self.unsubscribe_from_type.unwrap_or(0)
    }

    pub fn clear_unsubscribe_from_type(&mut self) {
        self.unsubscribe_from_type = ::std::option::Option::None;
    }

    pub fn has_unsubscribe_from_type(&self) -> bool {
        self.unsubscribe_from_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe_from_type(&mut self, v: u32) {
        self.unsubscribe_from_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscriber",
            |m: &CMsgGCToGCSOCacheUnsubscribe| { &m.subscriber },
            |m: &mut CMsgGCToGCSOCacheUnsubscribe| { &mut m.subscriber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unsubscribe_from_id",
            |m: &CMsgGCToGCSOCacheUnsubscribe| { &m.unsubscribe_from_id },
            |m: &mut CMsgGCToGCSOCacheUnsubscribe| { &mut m.unsubscribe_from_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unsubscribe_from_type",
            |m: &CMsgGCToGCSOCacheUnsubscribe| { &m.unsubscribe_from_type },
            |m: &mut CMsgGCToGCSOCacheUnsubscribe| { &mut m.unsubscribe_from_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCSOCacheUnsubscribe>(
            "CMsgGCToGCSOCacheUnsubscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCSOCacheUnsubscribe {
    const NAME: &'static str = "CMsgGCToGCSOCacheUnsubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.subscriber = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.unsubscribe_from_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.unsubscribe_from_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subscriber {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unsubscribe_from_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unsubscribe_from_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subscriber {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unsubscribe_from_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.unsubscribe_from_type {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSOCacheUnsubscribe {
        CMsgGCToGCSOCacheUnsubscribe::new()
    }

    fn clear(&mut self) {
        self.subscriber = ::std::option::Option::None;
        self.unsubscribe_from_id = ::std::option::Option::None;
        self.unsubscribe_from_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSOCacheUnsubscribe {
        static instance: CMsgGCToGCSOCacheUnsubscribe = CMsgGCToGCSOCacheUnsubscribe {
            subscriber: ::std::option::Option::None,
            unsubscribe_from_id: ::std::option::Option::None,
            unsubscribe_from_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCSOCacheUnsubscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCSOCacheUnsubscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCSOCacheUnsubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCSOCacheUnsubscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCClientPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClientPing {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCClientPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientPing {
    fn default() -> &'a CMsgGCClientPing {
        <CMsgGCClientPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientPing {
    pub fn new() -> CMsgGCClientPing {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClientPing>(
            "CMsgGCClientPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClientPing {
    const NAME: &'static str = "CMsgGCClientPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientPing {
        CMsgGCClientPing::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientPing {
        static instance: CMsgGCClientPing = CMsgGCClientPing {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClientPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClientPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClientPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCForwardAccountDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCForwardAccountDetails {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCForwardAccountDetails.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCForwardAccountDetails.account_details)
    pub account_details: ::protobuf::MessageField<super::steammessages::CGCSystemMsg_GetAccountDetails_Response>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCForwardAccountDetails.age_seconds)
    pub age_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCForwardAccountDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCForwardAccountDetails {
    fn default() -> &'a CMsgGCToGCForwardAccountDetails {
        <CMsgGCToGCForwardAccountDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCForwardAccountDetails {
    pub fn new() -> CMsgGCToGCForwardAccountDetails {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 age_seconds = 3;

    pub fn age_seconds(&self) -> u32 {
        self.age_seconds.unwrap_or(0)
    }

    pub fn clear_age_seconds(&mut self) {
        self.age_seconds = ::std::option::Option::None;
    }

    pub fn has_age_seconds(&self) -> bool {
        self.age_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_age_seconds(&mut self, v: u32) {
        self.age_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgGCToGCForwardAccountDetails| { &m.steamid },
            |m: &mut CMsgGCToGCForwardAccountDetails| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages::CGCSystemMsg_GetAccountDetails_Response>(
            "account_details",
            |m: &CMsgGCToGCForwardAccountDetails| { &m.account_details },
            |m: &mut CMsgGCToGCForwardAccountDetails| { &mut m.account_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "age_seconds",
            |m: &CMsgGCToGCForwardAccountDetails| { &m.age_seconds },
            |m: &mut CMsgGCToGCForwardAccountDetails| { &mut m.age_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCForwardAccountDetails>(
            "CMsgGCToGCForwardAccountDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCForwardAccountDetails {
    const NAME: &'static str = "CMsgGCToGCForwardAccountDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_details)?;
                },
                24 => {
                    self.age_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.account_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.age_seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.account_details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.age_seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCForwardAccountDetails {
        CMsgGCToGCForwardAccountDetails::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.account_details.clear();
        self.age_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCForwardAccountDetails {
        static instance: CMsgGCToGCForwardAccountDetails = CMsgGCToGCForwardAccountDetails {
            steamid: ::std::option::Option::None,
            account_details: ::protobuf::MessageField::none(),
            age_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCForwardAccountDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCForwardAccountDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCForwardAccountDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCForwardAccountDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCLoadSessionSOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCLoadSessionSOCache {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCLoadSessionSOCache.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCLoadSessionSOCache.forward_account_details)
    pub forward_account_details: ::protobuf::MessageField<CMsgGCToGCForwardAccountDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCLoadSessionSOCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCLoadSessionSOCache {
    fn default() -> &'a CMsgGCToGCLoadSessionSOCache {
        <CMsgGCToGCLoadSessionSOCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCLoadSessionSOCache {
    pub fn new() -> CMsgGCToGCLoadSessionSOCache {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCLoadSessionSOCache| { &m.account_id },
            |m: &mut CMsgGCToGCLoadSessionSOCache| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCToGCForwardAccountDetails>(
            "forward_account_details",
            |m: &CMsgGCToGCLoadSessionSOCache| { &m.forward_account_details },
            |m: &mut CMsgGCToGCLoadSessionSOCache| { &mut m.forward_account_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCLoadSessionSOCache>(
            "CMsgGCToGCLoadSessionSOCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCLoadSessionSOCache {
    const NAME: &'static str = "CMsgGCToGCLoadSessionSOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.forward_account_details)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.forward_account_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.forward_account_details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCLoadSessionSOCache {
        CMsgGCToGCLoadSessionSOCache::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.forward_account_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCLoadSessionSOCache {
        static instance: CMsgGCToGCLoadSessionSOCache = CMsgGCToGCLoadSessionSOCache {
            account_id: ::std::option::Option::None,
            forward_account_details: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCLoadSessionSOCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCLoadSessionSOCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCLoadSessionSOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCLoadSessionSOCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCLoadSessionSOCacheResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCLoadSessionSOCacheResponse {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCLoadSessionSOCacheResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCLoadSessionSOCacheResponse {
    fn default() -> &'a CMsgGCToGCLoadSessionSOCacheResponse {
        <CMsgGCToGCLoadSessionSOCacheResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCLoadSessionSOCacheResponse {
    pub fn new() -> CMsgGCToGCLoadSessionSOCacheResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCLoadSessionSOCacheResponse>(
            "CMsgGCToGCLoadSessionSOCacheResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCLoadSessionSOCacheResponse {
    const NAME: &'static str = "CMsgGCToGCLoadSessionSOCacheResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCLoadSessionSOCacheResponse {
        CMsgGCToGCLoadSessionSOCacheResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCLoadSessionSOCacheResponse {
        static instance: CMsgGCToGCLoadSessionSOCacheResponse = CMsgGCToGCLoadSessionSOCacheResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCLoadSessionSOCacheResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCLoadSessionSOCacheResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCLoadSessionSOCacheResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCLoadSessionSOCacheResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCUpdateSessionStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUpdateSessionStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUpdateSessionStats.user_sessions)
    pub user_sessions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUpdateSessionStats.server_sessions)
    pub server_sessions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCUpdateSessionStats.in_logon_surge)
    pub in_logon_surge: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCUpdateSessionStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateSessionStats {
    fn default() -> &'a CMsgGCToGCUpdateSessionStats {
        <CMsgGCToGCUpdateSessionStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateSessionStats {
    pub fn new() -> CMsgGCToGCUpdateSessionStats {
        ::std::default::Default::default()
    }

    // optional uint32 user_sessions = 1;

    pub fn user_sessions(&self) -> u32 {
        self.user_sessions.unwrap_or(0)
    }

    pub fn clear_user_sessions(&mut self) {
        self.user_sessions = ::std::option::Option::None;
    }

    pub fn has_user_sessions(&self) -> bool {
        self.user_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_sessions(&mut self, v: u32) {
        self.user_sessions = ::std::option::Option::Some(v);
    }

    // optional uint32 server_sessions = 2;

    pub fn server_sessions(&self) -> u32 {
        self.server_sessions.unwrap_or(0)
    }

    pub fn clear_server_sessions(&mut self) {
        self.server_sessions = ::std::option::Option::None;
    }

    pub fn has_server_sessions(&self) -> bool {
        self.server_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_sessions(&mut self, v: u32) {
        self.server_sessions = ::std::option::Option::Some(v);
    }

    // optional bool in_logon_surge = 3;

    pub fn in_logon_surge(&self) -> bool {
        self.in_logon_surge.unwrap_or(false)
    }

    pub fn clear_in_logon_surge(&mut self) {
        self.in_logon_surge = ::std::option::Option::None;
    }

    pub fn has_in_logon_surge(&self) -> bool {
        self.in_logon_surge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_logon_surge(&mut self, v: bool) {
        self.in_logon_surge = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_sessions",
            |m: &CMsgGCToGCUpdateSessionStats| { &m.user_sessions },
            |m: &mut CMsgGCToGCUpdateSessionStats| { &mut m.user_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_sessions",
            |m: &CMsgGCToGCUpdateSessionStats| { &m.server_sessions },
            |m: &mut CMsgGCToGCUpdateSessionStats| { &mut m.server_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_logon_surge",
            |m: &CMsgGCToGCUpdateSessionStats| { &m.in_logon_surge },
            |m: &mut CMsgGCToGCUpdateSessionStats| { &mut m.in_logon_surge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCUpdateSessionStats>(
            "CMsgGCToGCUpdateSessionStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCUpdateSessionStats {
    const NAME: &'static str = "CMsgGCToGCUpdateSessionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.user_sessions = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.server_sessions = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.in_logon_surge = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_sessions {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.server_sessions {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.in_logon_surge {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_sessions {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.server_sessions {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.in_logon_surge {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUpdateSessionStats {
        CMsgGCToGCUpdateSessionStats::new()
    }

    fn clear(&mut self) {
        self.user_sessions = ::std::option::Option::None;
        self.server_sessions = ::std::option::Option::None;
        self.in_logon_surge = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateSessionStats {
        static instance: CMsgGCToGCUpdateSessionStats = CMsgGCToGCUpdateSessionStats {
            user_sessions: ::std::option::Option::None,
            server_sessions: ::std::option::Option::None,
            in_logon_surge: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCUpdateSessionStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCUpdateSessionStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCUpdateSessionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCUpdateSessionStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientRequestDropped)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRequestDropped {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientRequestDropped.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRequestDropped {
    fn default() -> &'a CMsgGCToClientRequestDropped {
        <CMsgGCToClientRequestDropped as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRequestDropped {
    pub fn new() -> CMsgGCToClientRequestDropped {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientRequestDropped>(
            "CMsgGCToClientRequestDropped",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientRequestDropped {
    const NAME: &'static str = "CMsgGCToClientRequestDropped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRequestDropped {
        CMsgGCToClientRequestDropped::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRequestDropped {
        static instance: CMsgGCToClientRequestDropped = CMsgGCToClientRequestDropped {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientRequestDropped {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientRequestDropped").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientRequestDropped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientRequestDropped {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CWorkshop_PopulateItemDescriptions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_PopulateItemDescriptions_Request {
    // message fields
    // @@protoc_insertion_point(field:dota.CWorkshop_PopulateItemDescriptions_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CWorkshop_PopulateItemDescriptions_Request.languages)
    pub languages: ::std::vec::Vec<cworkshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CWorkshop_PopulateItemDescriptions_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_PopulateItemDescriptions_Request {
    fn default() -> &'a CWorkshop_PopulateItemDescriptions_Request {
        <CWorkshop_PopulateItemDescriptions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_PopulateItemDescriptions_Request {
    pub fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_PopulateItemDescriptions_Request| { &m.appid },
            |m: &mut CWorkshop_PopulateItemDescriptions_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &CWorkshop_PopulateItemDescriptions_Request| { &m.languages },
            |m: &mut CWorkshop_PopulateItemDescriptions_Request| { &mut m.languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_PopulateItemDescriptions_Request>(
            "CWorkshop_PopulateItemDescriptions_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_PopulateItemDescriptions_Request {
    const NAME: &'static str = "CWorkshop_PopulateItemDescriptions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.languages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.languages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        CWorkshop_PopulateItemDescriptions_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_PopulateItemDescriptions_Request {
        static instance: CWorkshop_PopulateItemDescriptions_Request = CWorkshop_PopulateItemDescriptions_Request {
            appid: ::std::option::Option::None,
            languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_PopulateItemDescriptions_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_PopulateItemDescriptions_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_PopulateItemDescriptions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_PopulateItemDescriptions_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CWorkshop_PopulateItemDescriptions_Request`
pub mod cworkshop_populate_item_descriptions_request {
    // @@protoc_insertion_point(message:dota.CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleItemDescription {
        // message fields
        // @@protoc_insertion_point(field:dota.CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.gameitemid)
        pub gameitemid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.item_description)
        pub item_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleItemDescription {
        fn default() -> &'a SingleItemDescription {
            <SingleItemDescription as ::protobuf::Message>::default_instance()
        }
    }

    impl SingleItemDescription {
        pub fn new() -> SingleItemDescription {
            ::std::default::Default::default()
        }

        // optional uint32 gameitemid = 1;

        pub fn gameitemid(&self) -> u32 {
            self.gameitemid.unwrap_or(0)
        }

        pub fn clear_gameitemid(&mut self) {
            self.gameitemid = ::std::option::Option::None;
        }

        pub fn has_gameitemid(&self) -> bool {
            self.gameitemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gameitemid(&mut self, v: u32) {
            self.gameitemid = ::std::option::Option::Some(v);
        }

        // optional string item_description = 2;

        pub fn item_description(&self) -> &str {
            match self.item_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_item_description(&mut self) {
            self.item_description = ::std::option::Option::None;
        }

        pub fn has_item_description(&self) -> bool {
            self.item_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_description(&mut self, v: ::std::string::String) {
            self.item_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_item_description(&mut self) -> &mut ::std::string::String {
            if self.item_description.is_none() {
                self.item_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.item_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_item_description(&mut self) -> ::std::string::String {
            self.item_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gameitemid",
                |m: &SingleItemDescription| { &m.gameitemid },
                |m: &mut SingleItemDescription| { &mut m.gameitemid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_description",
                |m: &SingleItemDescription| { &m.item_description },
                |m: &mut SingleItemDescription| { &mut m.item_description },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleItemDescription>(
                "CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SingleItemDescription {
        const NAME: &'static str = "SingleItemDescription";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.item_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.gameitemid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_description.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.gameitemid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_description.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleItemDescription {
            SingleItemDescription::new()
        }

        fn clear(&mut self) {
            self.gameitemid = ::std::option::Option::None;
            self.item_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleItemDescription {
            static instance: SingleItemDescription = SingleItemDescription {
                gameitemid: ::std::option::Option::None,
                item_description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SingleItemDescription {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SingleItemDescription {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SingleItemDescription {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemDescriptionsLanguageBlock {
        // message fields
        // @@protoc_insertion_point(field:dota.CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.language)
        pub language: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.descriptions)
        pub descriptions: ::std::vec::Vec<SingleItemDescription>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDescriptionsLanguageBlock {
        fn default() -> &'a ItemDescriptionsLanguageBlock {
            <ItemDescriptionsLanguageBlock as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemDescriptionsLanguageBlock {
        pub fn new() -> ItemDescriptionsLanguageBlock {
            ::std::default::Default::default()
        }

        // optional string language = 1;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language",
                |m: &ItemDescriptionsLanguageBlock| { &m.language },
                |m: &mut ItemDescriptionsLanguageBlock| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "descriptions",
                |m: &ItemDescriptionsLanguageBlock| { &m.descriptions },
                |m: &mut ItemDescriptionsLanguageBlock| { &mut m.descriptions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemDescriptionsLanguageBlock>(
                "CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemDescriptionsLanguageBlock {
        const NAME: &'static str = "ItemDescriptionsLanguageBlock";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.descriptions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.language.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.descriptions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.language.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.descriptions {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDescriptionsLanguageBlock {
            ItemDescriptionsLanguageBlock::new()
        }

        fn clear(&mut self) {
            self.language = ::std::option::Option::None;
            self.descriptions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDescriptionsLanguageBlock {
            static instance: ItemDescriptionsLanguageBlock = ItemDescriptionsLanguageBlock {
                language: ::std::option::Option::None,
                descriptions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemDescriptionsLanguageBlock {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemDescriptionsLanguageBlock {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemDescriptionsLanguageBlock {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CWorkshop_GetContributors_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Request {
    // message fields
    // @@protoc_insertion_point(field:dota.CWorkshop_GetContributors_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CWorkshop_GetContributors_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CWorkshop_GetContributors_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Request {
    fn default() -> &'a CWorkshop_GetContributors_Request {
        <CWorkshop_GetContributors_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Request {
    pub fn new() -> CWorkshop_GetContributors_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_GetContributors_Request| { &m.appid },
            |m: &mut CWorkshop_GetContributors_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameitemid",
            |m: &CWorkshop_GetContributors_Request| { &m.gameitemid },
            |m: &mut CWorkshop_GetContributors_Request| { &mut m.gameitemid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetContributors_Request>(
            "CWorkshop_GetContributors_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetContributors_Request {
    const NAME: &'static str = "CWorkshop_GetContributors_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Request {
        CWorkshop_GetContributors_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Request {
        static instance: CWorkshop_GetContributors_Request = CWorkshop_GetContributors_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetContributors_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetContributors_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetContributors_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetContributors_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CWorkshop_GetContributors_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Response {
    // message fields
    // @@protoc_insertion_point(field:dota.CWorkshop_GetContributors_Response.contributors)
    pub contributors: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CWorkshop_GetContributors_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Response {
    fn default() -> &'a CWorkshop_GetContributors_Response {
        <CWorkshop_GetContributors_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Response {
    pub fn new() -> CWorkshop_GetContributors_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contributors",
            |m: &CWorkshop_GetContributors_Response| { &m.contributors },
            |m: &mut CWorkshop_GetContributors_Response| { &mut m.contributors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetContributors_Response>(
            "CWorkshop_GetContributors_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetContributors_Response {
    const NAME: &'static str = "CWorkshop_GetContributors_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.contributors)?;
                },
                9 => {
                    self.contributors.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.contributors.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.contributors {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Response {
        CWorkshop_GetContributors_Response::new()
    }

    fn clear(&mut self) {
        self.contributors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Response {
        static instance: CWorkshop_GetContributors_Response = CWorkshop_GetContributors_Response {
            contributors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetContributors_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetContributors_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetContributors_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetContributors_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CWorkshop_SetItemPaymentRules_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Request {
    // message fields
    // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.associated_workshop_files)
    pub associated_workshop_files: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::WorkshopItemPaymentRule>,
    // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.partner_accounts)
    pub partner_accounts: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::PartnerItemPaymentRule>,
    // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.validate_only)
    pub validate_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.make_workshop_files_subscribable)
    pub make_workshop_files_subscribable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.associated_workshop_file_for_direct_payments)
    pub associated_workshop_file_for_direct_payments: ::protobuf::MessageField<cworkshop_set_item_payment_rules_request::WorkshopDirectPaymentRule>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CWorkshop_SetItemPaymentRules_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Request {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Request {
        <CWorkshop_SetItemPaymentRules_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Request {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    // optional bool validate_only = 5;

    pub fn validate_only(&self) -> bool {
        self.validate_only.unwrap_or(false)
    }

    pub fn clear_validate_only(&mut self) {
        self.validate_only = ::std::option::Option::None;
    }

    pub fn has_validate_only(&self) -> bool {
        self.validate_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validate_only(&mut self, v: bool) {
        self.validate_only = ::std::option::Option::Some(v);
    }

    // optional bool make_workshop_files_subscribable = 6;

    pub fn make_workshop_files_subscribable(&self) -> bool {
        self.make_workshop_files_subscribable.unwrap_or(false)
    }

    pub fn clear_make_workshop_files_subscribable(&mut self) {
        self.make_workshop_files_subscribable = ::std::option::Option::None;
    }

    pub fn has_make_workshop_files_subscribable(&self) -> bool {
        self.make_workshop_files_subscribable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_make_workshop_files_subscribable(&mut self, v: bool) {
        self.make_workshop_files_subscribable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.appid },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameitemid",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.gameitemid },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.gameitemid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "associated_workshop_files",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.associated_workshop_files },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.associated_workshop_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "partner_accounts",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.partner_accounts },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.partner_accounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "validate_only",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.validate_only },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.validate_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "make_workshop_files_subscribable",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.make_workshop_files_subscribable },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.make_workshop_files_subscribable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cworkshop_set_item_payment_rules_request::WorkshopDirectPaymentRule>(
            "associated_workshop_file_for_direct_payments",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.associated_workshop_file_for_direct_payments },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.associated_workshop_file_for_direct_payments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_SetItemPaymentRules_Request>(
            "CWorkshop_SetItemPaymentRules_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Request {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.associated_workshop_files.push(is.read_message()?);
                },
                34 => {
                    self.partner_accounts.push(is.read_message()?);
                },
                40 => {
                    self.validate_only = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.make_workshop_files_subscribable = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.associated_workshop_file_for_direct_payments)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.associated_workshop_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.partner_accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.validate_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.make_workshop_files_subscribable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.associated_workshop_file_for_direct_payments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        for v in &self.associated_workshop_files {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.partner_accounts {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.validate_only {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.make_workshop_files_subscribable {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.associated_workshop_file_for_direct_payments.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Request {
        CWorkshop_SetItemPaymentRules_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.associated_workshop_files.clear();
        self.partner_accounts.clear();
        self.validate_only = ::std::option::Option::None;
        self.make_workshop_files_subscribable = ::std::option::Option::None;
        self.associated_workshop_file_for_direct_payments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Request {
        static instance: CWorkshop_SetItemPaymentRules_Request = CWorkshop_SetItemPaymentRules_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            associated_workshop_files: ::std::vec::Vec::new(),
            partner_accounts: ::std::vec::Vec::new(),
            validate_only: ::std::option::Option::None,
            make_workshop_files_subscribable: ::std::option::Option::None,
            associated_workshop_file_for_direct_payments: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_SetItemPaymentRules_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_SetItemPaymentRules_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CWorkshop_SetItemPaymentRules_Request`
pub mod cworkshop_set_item_payment_rules_request {
    // @@protoc_insertion_point(message:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_type)
        pub rule_type: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemPaymentRule {
        fn default() -> &'a WorkshopItemPaymentRule {
            <WorkshopItemPaymentRule as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemPaymentRule {
        pub fn new() -> WorkshopItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 rule_type = 4;

        pub fn rule_type(&self) -> u32 {
            self.rule_type.unwrap_or(0)
        }

        pub fn clear_rule_type(&mut self) {
            self.rule_type = ::std::option::Option::None;
        }

        pub fn has_rule_type(&self) -> bool {
            self.rule_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_type(&mut self, v: u32) {
            self.rule_type = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "workshop_file_id",
                |m: &WorkshopItemPaymentRule| { &m.workshop_file_id },
                |m: &mut WorkshopItemPaymentRule| { &mut m.workshop_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_percentage",
                |m: &WorkshopItemPaymentRule| { &m.revenue_percentage },
                |m: &mut WorkshopItemPaymentRule| { &mut m.revenue_percentage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_description",
                |m: &WorkshopItemPaymentRule| { &m.rule_description },
                |m: &mut WorkshopItemPaymentRule| { &mut m.rule_description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_type",
                |m: &WorkshopItemPaymentRule| { &m.rule_type },
                |m: &mut WorkshopItemPaymentRule| { &mut m.rule_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkshopItemPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkshopItemPaymentRule {
        const NAME: &'static str = "WorkshopItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.rule_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.rule_type {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.rule_type {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemPaymentRule {
            WorkshopItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.rule_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemPaymentRule {
            static instance: WorkshopItemPaymentRule = WorkshopItemPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                rule_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkshopItemPaymentRule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkshopItemPaymentRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItemPaymentRule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopDirectPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopDirectPaymentRule {
        fn default() -> &'a WorkshopDirectPaymentRule {
            <WorkshopDirectPaymentRule as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopDirectPaymentRule {
        pub fn new() -> WorkshopDirectPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 2;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "workshop_file_id",
                |m: &WorkshopDirectPaymentRule| { &m.workshop_file_id },
                |m: &mut WorkshopDirectPaymentRule| { &mut m.workshop_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_description",
                |m: &WorkshopDirectPaymentRule| { &m.rule_description },
                |m: &mut WorkshopDirectPaymentRule| { &mut m.rule_description },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkshopDirectPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkshopDirectPaymentRule {
        const NAME: &'static str = "WorkshopDirectPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopDirectPaymentRule {
            WorkshopDirectPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopDirectPaymentRule {
            static instance: WorkshopDirectPaymentRule = WorkshopDirectPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkshopDirectPaymentRule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkshopDirectPaymentRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopDirectPaymentRule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartnerItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartnerItemPaymentRule {
        fn default() -> &'a PartnerItemPaymentRule {
            <PartnerItemPaymentRule as ::protobuf::Message>::default_instance()
        }
    }

    impl PartnerItemPaymentRule {
        pub fn new() -> PartnerItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PartnerItemPaymentRule| { &m.account_id },
                |m: &mut PartnerItemPaymentRule| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_percentage",
                |m: &PartnerItemPaymentRule| { &m.revenue_percentage },
                |m: &mut PartnerItemPaymentRule| { &mut m.revenue_percentage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_description",
                |m: &PartnerItemPaymentRule| { &m.rule_description },
                |m: &mut PartnerItemPaymentRule| { &mut m.rule_description },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartnerItemPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PartnerItemPaymentRule {
        const NAME: &'static str = "PartnerItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartnerItemPaymentRule {
            PartnerItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartnerItemPaymentRule {
            static instance: PartnerItemPaymentRule = PartnerItemPaymentRule {
                account_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PartnerItemPaymentRule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PartnerItemPaymentRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PartnerItemPaymentRule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CWorkshop_SetItemPaymentRules_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Response {
    // message fields
    // @@protoc_insertion_point(field:dota.CWorkshop_SetItemPaymentRules_Response.validation_errors)
    pub validation_errors: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CWorkshop_SetItemPaymentRules_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Response {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Response {
        <CWorkshop_SetItemPaymentRules_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Response {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validation_errors",
            |m: &CWorkshop_SetItemPaymentRules_Response| { &m.validation_errors },
            |m: &mut CWorkshop_SetItemPaymentRules_Response| { &mut m.validation_errors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_SetItemPaymentRules_Response>(
            "CWorkshop_SetItemPaymentRules_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Response {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validation_errors.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.validation_errors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.validation_errors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Response {
        CWorkshop_SetItemPaymentRules_Response::new()
    }

    fn clear(&mut self) {
        self.validation_errors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Response {
        static instance: CWorkshop_SetItemPaymentRules_Response = CWorkshop_SetItemPaymentRules_Response {
            validation_errors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_SetItemPaymentRules_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_SetItemPaymentRules_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CCommunity_ClanAnnouncementInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_ClanAnnouncementInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.clanid)
    pub clanid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.posterid)
    pub posterid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.posttime)
    pub posttime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.updatetime)
    pub updatetime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.commentcount)
    pub commentcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CCommunity_ClanAnnouncementInfo.forum_topic_id)
    pub forum_topic_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CCommunity_ClanAnnouncementInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClanAnnouncementInfo {
    fn default() -> &'a CCommunity_ClanAnnouncementInfo {
        <CCommunity_ClanAnnouncementInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCommunity_ClanAnnouncementInfo {
    pub fn new() -> CCommunity_ClanAnnouncementInfo {
        ::std::default::Default::default()
    }

    // optional uint64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint64 clanid = 2;

    pub fn clanid(&self) -> u64 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u64) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint64 posterid = 3;

    pub fn posterid(&self) -> u64 {
        self.posterid.unwrap_or(0)
    }

    pub fn clear_posterid(&mut self) {
        self.posterid = ::std::option::Option::None;
    }

    pub fn has_posterid(&self) -> bool {
        self.posterid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posterid(&mut self, v: u64) {
        self.posterid = ::std::option::Option::Some(v);
    }

    // optional string headline = 4;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 posttime = 5;

    pub fn posttime(&self) -> u32 {
        self.posttime.unwrap_or(0)
    }

    pub fn clear_posttime(&mut self) {
        self.posttime = ::std::option::Option::None;
    }

    pub fn has_posttime(&self) -> bool {
        self.posttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posttime(&mut self, v: u32) {
        self.posttime = ::std::option::Option::Some(v);
    }

    // optional uint32 updatetime = 6;

    pub fn updatetime(&self) -> u32 {
        self.updatetime.unwrap_or(0)
    }

    pub fn clear_updatetime(&mut self) {
        self.updatetime = ::std::option::Option::None;
    }

    pub fn has_updatetime(&self) -> bool {
        self.updatetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatetime(&mut self, v: u32) {
        self.updatetime = ::std::option::Option::Some(v);
    }

    // optional string body = 7;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 commentcount = 8;

    pub fn commentcount(&self) -> i32 {
        self.commentcount.unwrap_or(0)
    }

    pub fn clear_commentcount(&mut self) {
        self.commentcount = ::std::option::Option::None;
    }

    pub fn has_commentcount(&self) -> bool {
        self.commentcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentcount(&mut self, v: i32) {
        self.commentcount = ::std::option::Option::Some(v);
    }

    // optional int32 language = 10;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 11;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 12;

    pub fn forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }

    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.gid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clanid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.clanid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.clanid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "posterid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.posterid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.posterid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "headline",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.headline },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.headline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "posttime",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.posttime },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.posttime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatetime",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.updatetime },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.updatetime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.body },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commentcount",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.commentcount },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.commentcount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.tags },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.language },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.hidden },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forum_topic_id",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.forum_topic_id },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.forum_topic_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCommunity_ClanAnnouncementInfo>(
            "CCommunity_ClanAnnouncementInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCommunity_ClanAnnouncementInfo {
    const NAME: &'static str = "CCommunity_ClanAnnouncementInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.posterid = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.posttime = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.updatetime = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.commentcount = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.tags.push(is.read_string()?);
                },
                80 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                97 => {
                    self.forum_topic_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.posterid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.posttime {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.updatetime {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.commentcount {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.posterid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.posttime {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.updatetime {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.commentcount {
            os.write_int32(8, v)?;
        }
        for v in &self.tags {
            os.write_string(9, &v)?;
        };
        if let Some(v) = self.language {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_ClanAnnouncementInfo {
        CCommunity_ClanAnnouncementInfo::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clanid = ::std::option::Option::None;
        self.posterid = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.posttime = ::std::option::Option::None;
        self.updatetime = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.commentcount = ::std::option::Option::None;
        self.tags.clear();
        self.language = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_ClanAnnouncementInfo {
        static instance: CCommunity_ClanAnnouncementInfo = CCommunity_ClanAnnouncementInfo {
            gid: ::std::option::Option::None,
            clanid: ::std::option::Option::None,
            posterid: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            posttime: ::std::option::Option::None,
            updatetime: ::std::option::Option::None,
            body: ::std::option::Option::None,
            commentcount: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            language: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            forum_topic_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCommunity_ClanAnnouncementInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCommunity_ClanAnnouncementInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCommunity_ClanAnnouncementInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCommunity_ClanAnnouncementInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CCommunity_GetClanAnnouncements_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetClanAnnouncements_Request {
    // message fields
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.maxchars)
    pub maxchars: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.strip_html)
    pub strip_html: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.required_tags)
    pub required_tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.require_no_tags)
    pub require_no_tags: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.language_preference)
    pub language_preference: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.hidden_only)
    pub hidden_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.only_gid)
    pub only_gid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.rtime_oldest_date)
    pub rtime_oldest_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.include_hidden)
    pub include_hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Request.include_partner_events)
    pub include_partner_events: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CCommunity_GetClanAnnouncements_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetClanAnnouncements_Request {
    fn default() -> &'a CCommunity_GetClanAnnouncements_Request {
        <CCommunity_GetClanAnnouncements_Request as ::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetClanAnnouncements_Request {
    pub fn new() -> CCommunity_GetClanAnnouncements_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 maxchars = 4;

    pub fn maxchars(&self) -> u32 {
        self.maxchars.unwrap_or(0)
    }

    pub fn clear_maxchars(&mut self) {
        self.maxchars = ::std::option::Option::None;
    }

    pub fn has_maxchars(&self) -> bool {
        self.maxchars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxchars(&mut self, v: u32) {
        self.maxchars = ::std::option::Option::Some(v);
    }

    // optional bool strip_html = 5;

    pub fn strip_html(&self) -> bool {
        self.strip_html.unwrap_or(false)
    }

    pub fn clear_strip_html(&mut self) {
        self.strip_html = ::std::option::Option::None;
    }

    pub fn has_strip_html(&self) -> bool {
        self.strip_html.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_html(&mut self, v: bool) {
        self.strip_html = ::std::option::Option::Some(v);
    }

    // optional bool require_no_tags = 7;

    pub fn require_no_tags(&self) -> bool {
        self.require_no_tags.unwrap_or(false)
    }

    pub fn clear_require_no_tags(&mut self) {
        self.require_no_tags = ::std::option::Option::None;
    }

    pub fn has_require_no_tags(&self) -> bool {
        self.require_no_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_no_tags(&mut self, v: bool) {
        self.require_no_tags = ::std::option::Option::Some(v);
    }

    // optional bool hidden_only = 9;

    pub fn hidden_only(&self) -> bool {
        self.hidden_only.unwrap_or(false)
    }

    pub fn clear_hidden_only(&mut self) {
        self.hidden_only = ::std::option::Option::None;
    }

    pub fn has_hidden_only(&self) -> bool {
        self.hidden_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden_only(&mut self, v: bool) {
        self.hidden_only = ::std::option::Option::Some(v);
    }

    // optional bool only_gid = 10;

    pub fn only_gid(&self) -> bool {
        self.only_gid.unwrap_or(false)
    }

    pub fn clear_only_gid(&mut self) {
        self.only_gid = ::std::option::Option::None;
    }

    pub fn has_only_gid(&self) -> bool {
        self.only_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_gid(&mut self, v: bool) {
        self.only_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_oldest_date = 11;

    pub fn rtime_oldest_date(&self) -> u32 {
        self.rtime_oldest_date.unwrap_or(0)
    }

    pub fn clear_rtime_oldest_date(&mut self) {
        self.rtime_oldest_date = ::std::option::Option::None;
    }

    pub fn has_rtime_oldest_date(&self) -> bool {
        self.rtime_oldest_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_oldest_date(&mut self, v: u32) {
        self.rtime_oldest_date = ::std::option::Option::Some(v);
    }

    // optional bool include_hidden = 12;

    pub fn include_hidden(&self) -> bool {
        self.include_hidden.unwrap_or(false)
    }

    pub fn clear_include_hidden(&mut self) {
        self.include_hidden = ::std::option::Option::None;
    }

    pub fn has_include_hidden(&self) -> bool {
        self.include_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_hidden(&mut self, v: bool) {
        self.include_hidden = ::std::option::Option::Some(v);
    }

    // optional bool include_partner_events = 13;

    pub fn include_partner_events(&self) -> bool {
        self.include_partner_events.unwrap_or(false)
    }

    pub fn clear_include_partner_events(&mut self) {
        self.include_partner_events = ::std::option::Option::None;
    }

    pub fn has_include_partner_events(&self) -> bool {
        self.include_partner_events.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_partner_events(&mut self, v: bool) {
        self.include_partner_events = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.steamid },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.offset },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.count },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxchars",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.maxchars },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.maxchars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strip_html",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.strip_html },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.strip_html },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "required_tags",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.required_tags },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.required_tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "require_no_tags",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.require_no_tags },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.require_no_tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "language_preference",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.language_preference },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.language_preference },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden_only",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.hidden_only },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.hidden_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_gid",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.only_gid },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.only_gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_oldest_date",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.rtime_oldest_date },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.rtime_oldest_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_hidden",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.include_hidden },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.include_hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_partner_events",
            |m: &CCommunity_GetClanAnnouncements_Request| { &m.include_partner_events },
            |m: &mut CCommunity_GetClanAnnouncements_Request| { &mut m.include_partner_events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCommunity_GetClanAnnouncements_Request>(
            "CCommunity_GetClanAnnouncements_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCommunity_GetClanAnnouncements_Request {
    const NAME: &'static str = "CCommunity_GetClanAnnouncements_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.maxchars = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.strip_html = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.required_tags.push(is.read_string()?);
                },
                56 => {
                    self.require_no_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.language_preference)?;
                },
                64 => {
                    self.language_preference.push(is.read_uint32()?);
                },
                72 => {
                    self.hidden_only = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.only_gid = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.rtime_oldest_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.include_hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.include_partner_events = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.maxchars {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.strip_html {
            my_size += 1 + 1;
        }
        for value in &self.required_tags {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.require_no_tags {
            my_size += 1 + 1;
        }
        for value in &self.language_preference {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        if let Some(v) = self.hidden_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.only_gid {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rtime_oldest_date {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.include_hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_partner_events {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.maxchars {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.strip_html {
            os.write_bool(5, v)?;
        }
        for v in &self.required_tags {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.require_no_tags {
            os.write_bool(7, v)?;
        }
        for v in &self.language_preference {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.hidden_only {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.only_gid {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.rtime_oldest_date {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.include_hidden {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.include_partner_events {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetClanAnnouncements_Request {
        CCommunity_GetClanAnnouncements_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.maxchars = ::std::option::Option::None;
        self.strip_html = ::std::option::Option::None;
        self.required_tags.clear();
        self.require_no_tags = ::std::option::Option::None;
        self.language_preference.clear();
        self.hidden_only = ::std::option::Option::None;
        self.only_gid = ::std::option::Option::None;
        self.rtime_oldest_date = ::std::option::Option::None;
        self.include_hidden = ::std::option::Option::None;
        self.include_partner_events = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetClanAnnouncements_Request {
        static instance: CCommunity_GetClanAnnouncements_Request = CCommunity_GetClanAnnouncements_Request {
            steamid: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            count: ::std::option::Option::None,
            maxchars: ::std::option::Option::None,
            strip_html: ::std::option::Option::None,
            required_tags: ::std::vec::Vec::new(),
            require_no_tags: ::std::option::Option::None,
            language_preference: ::std::vec::Vec::new(),
            hidden_only: ::std::option::Option::None,
            only_gid: ::std::option::Option::None,
            rtime_oldest_date: ::std::option::Option::None,
            include_hidden: ::std::option::Option::None,
            include_partner_events: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCommunity_GetClanAnnouncements_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCommunity_GetClanAnnouncements_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCommunity_GetClanAnnouncements_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCommunity_GetClanAnnouncements_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CCommunity_GetClanAnnouncements_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetClanAnnouncements_Response {
    // message fields
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Response.maxchars)
    pub maxchars: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Response.strip_html)
    pub strip_html: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CCommunity_GetClanAnnouncements_Response.announcements)
    pub announcements: ::std::vec::Vec<CCommunity_ClanAnnouncementInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CCommunity_GetClanAnnouncements_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetClanAnnouncements_Response {
    fn default() -> &'a CCommunity_GetClanAnnouncements_Response {
        <CCommunity_GetClanAnnouncements_Response as ::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetClanAnnouncements_Response {
    pub fn new() -> CCommunity_GetClanAnnouncements_Response {
        ::std::default::Default::default()
    }

    // optional uint32 maxchars = 1;

    pub fn maxchars(&self) -> u32 {
        self.maxchars.unwrap_or(0)
    }

    pub fn clear_maxchars(&mut self) {
        self.maxchars = ::std::option::Option::None;
    }

    pub fn has_maxchars(&self) -> bool {
        self.maxchars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxchars(&mut self, v: u32) {
        self.maxchars = ::std::option::Option::Some(v);
    }

    // optional bool strip_html = 2;

    pub fn strip_html(&self) -> bool {
        self.strip_html.unwrap_or(false)
    }

    pub fn clear_strip_html(&mut self) {
        self.strip_html = ::std::option::Option::None;
    }

    pub fn has_strip_html(&self) -> bool {
        self.strip_html.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_html(&mut self, v: bool) {
        self.strip_html = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxchars",
            |m: &CCommunity_GetClanAnnouncements_Response| { &m.maxchars },
            |m: &mut CCommunity_GetClanAnnouncements_Response| { &mut m.maxchars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strip_html",
            |m: &CCommunity_GetClanAnnouncements_Response| { &m.strip_html },
            |m: &mut CCommunity_GetClanAnnouncements_Response| { &mut m.strip_html },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "announcements",
            |m: &CCommunity_GetClanAnnouncements_Response| { &m.announcements },
            |m: &mut CCommunity_GetClanAnnouncements_Response| { &mut m.announcements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCommunity_GetClanAnnouncements_Response>(
            "CCommunity_GetClanAnnouncements_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCommunity_GetClanAnnouncements_Response {
    const NAME: &'static str = "CCommunity_GetClanAnnouncements_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.maxchars = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.strip_html = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.announcements.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxchars {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.strip_html {
            my_size += 1 + 1;
        }
        for value in &self.announcements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maxchars {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.strip_html {
            os.write_bool(2, v)?;
        }
        for v in &self.announcements {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetClanAnnouncements_Response {
        CCommunity_GetClanAnnouncements_Response::new()
    }

    fn clear(&mut self) {
        self.maxchars = ::std::option::Option::None;
        self.strip_html = ::std::option::Option::None;
        self.announcements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetClanAnnouncements_Response {
        static instance: CCommunity_GetClanAnnouncements_Response = CCommunity_GetClanAnnouncements_Response {
            maxchars: ::std::option::Option::None,
            strip_html: ::std::option::Option::None,
            announcements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCommunity_GetClanAnnouncements_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCommunity_GetClanAnnouncements_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCommunity_GetClanAnnouncements_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCommunity_GetClanAnnouncements_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CBroadcast_PostGameDataFrame_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_PostGameDataFrame_Request {
    // message fields
    // @@protoc_insertion_point(field:dota.CBroadcast_PostGameDataFrame_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CBroadcast_PostGameDataFrame_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CBroadcast_PostGameDataFrame_Request.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CBroadcast_PostGameDataFrame_Request.frame_data)
    pub frame_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CBroadcast_PostGameDataFrame_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_PostGameDataFrame_Request {
    fn default() -> &'a CBroadcast_PostGameDataFrame_Request {
        <CBroadcast_PostGameDataFrame_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_PostGameDataFrame_Request {
    pub fn new() -> CBroadcast_PostGameDataFrame_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 3;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional bytes frame_data = 4;

    pub fn frame_data(&self) -> &[u8] {
        match self.frame_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_frame_data(&mut self) {
        self.frame_data = ::std::option::Option::None;
    }

    pub fn has_frame_data(&self) -> bool {
        self.frame_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.frame_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frame_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.frame_data.is_none() {
            self.frame_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.frame_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_frame_data(&mut self) -> ::std::vec::Vec<u8> {
        self.frame_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CBroadcast_PostGameDataFrame_Request| { &m.appid },
            |m: &mut CBroadcast_PostGameDataFrame_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CBroadcast_PostGameDataFrame_Request| { &m.steamid },
            |m: &mut CBroadcast_PostGameDataFrame_Request| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_id",
            |m: &CBroadcast_PostGameDataFrame_Request| { &m.broadcast_id },
            |m: &mut CBroadcast_PostGameDataFrame_Request| { &mut m.broadcast_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_data",
            |m: &CBroadcast_PostGameDataFrame_Request| { &m.frame_data },
            |m: &mut CBroadcast_PostGameDataFrame_Request| { &mut m.frame_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBroadcast_PostGameDataFrame_Request>(
            "CBroadcast_PostGameDataFrame_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CBroadcast_PostGameDataFrame_Request {
    const NAME: &'static str = "CBroadcast_PostGameDataFrame_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.frame_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.frame_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.frame_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_PostGameDataFrame_Request {
        CBroadcast_PostGameDataFrame_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.frame_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_PostGameDataFrame_Request {
        static instance: CBroadcast_PostGameDataFrame_Request = CBroadcast_PostGameDataFrame_Request {
            appid: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            broadcast_id: ::std::option::Option::None,
            frame_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CBroadcast_PostGameDataFrame_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBroadcast_PostGameDataFrame_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBroadcast_PostGameDataFrame_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_PostGameDataFrame_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgSerializedSOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSerializedSOCache {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.file_version)
    pub file_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.caches)
    pub caches: ::std::vec::Vec<cmsg_serialized_socache::Cache>,
    // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.gc_socache_file_version)
    pub gc_socache_file_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgSerializedSOCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSerializedSOCache {
    fn default() -> &'a CMsgSerializedSOCache {
        <CMsgSerializedSOCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSerializedSOCache {
    pub fn new() -> CMsgSerializedSOCache {
        ::std::default::Default::default()
    }

    // optional uint32 file_version = 1;

    pub fn file_version(&self) -> u32 {
        self.file_version.unwrap_or(0)
    }

    pub fn clear_file_version(&mut self) {
        self.file_version = ::std::option::Option::None;
    }

    pub fn has_file_version(&self) -> bool {
        self.file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_version(&mut self, v: u32) {
        self.file_version = ::std::option::Option::Some(v);
    }

    // optional uint32 gc_socache_file_version = 3;

    pub fn gc_socache_file_version(&self) -> u32 {
        self.gc_socache_file_version.unwrap_or(0)
    }

    pub fn clear_gc_socache_file_version(&mut self) {
        self.gc_socache_file_version = ::std::option::Option::None;
    }

    pub fn has_gc_socache_file_version(&self) -> bool {
        self.gc_socache_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_socache_file_version(&mut self, v: u32) {
        self.gc_socache_file_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_version",
            |m: &CMsgSerializedSOCache| { &m.file_version },
            |m: &mut CMsgSerializedSOCache| { &mut m.file_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "caches",
            |m: &CMsgSerializedSOCache| { &m.caches },
            |m: &mut CMsgSerializedSOCache| { &mut m.caches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gc_socache_file_version",
            |m: &CMsgSerializedSOCache| { &m.gc_socache_file_version },
            |m: &mut CMsgSerializedSOCache| { &mut m.gc_socache_file_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSerializedSOCache>(
            "CMsgSerializedSOCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSerializedSOCache {
    const NAME: &'static str = "CMsgSerializedSOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.caches.push(is.read_message()?);
                },
                24 => {
                    self.gc_socache_file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.caches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gc_socache_file_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file_version {
            os.write_uint32(1, v)?;
        }
        for v in &self.caches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.gc_socache_file_version {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSerializedSOCache {
        CMsgSerializedSOCache::new()
    }

    fn clear(&mut self) {
        self.file_version = ::std::option::Option::None;
        self.caches.clear();
        self.gc_socache_file_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSerializedSOCache {
        static instance: CMsgSerializedSOCache = CMsgSerializedSOCache {
            file_version: ::std::option::Option::None,
            caches: ::std::vec::Vec::new(),
            gc_socache_file_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSerializedSOCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSerializedSOCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSerializedSOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSerializedSOCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSerializedSOCache`
pub mod cmsg_serialized_socache {
    // @@protoc_insertion_point(message:dota.CMsgSerializedSOCache.TypeCache)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TypeCache {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.TypeCache.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.TypeCache.objects)
        pub objects: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.TypeCache.service_id)
        pub service_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSerializedSOCache.TypeCache.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TypeCache {
        fn default() -> &'a TypeCache {
            <TypeCache as ::protobuf::Message>::default_instance()
        }
    }

    impl TypeCache {
        pub fn new() -> TypeCache {
            ::std::default::Default::default()
        }

        // optional uint32 type = 1;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint32 service_id = 3;

        pub fn service_id(&self) -> u32 {
            self.service_id.unwrap_or(0)
        }

        pub fn clear_service_id(&mut self) {
            self.service_id = ::std::option::Option::None;
        }

        pub fn has_service_id(&self) -> bool {
            self.service_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_service_id(&mut self, v: u32) {
            self.service_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &TypeCache| { &m.type_ },
                |m: &mut TypeCache| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "objects",
                |m: &TypeCache| { &m.objects },
                |m: &mut TypeCache| { &mut m.objects },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "service_id",
                |m: &TypeCache| { &m.service_id },
                |m: &mut TypeCache| { &mut m.service_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeCache>(
                "CMsgSerializedSOCache.TypeCache",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TypeCache {
        const NAME: &'static str = "TypeCache";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.objects.push(is.read_bytes()?);
                    },
                    24 => {
                        self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.objects {
                my_size += ::protobuf::rt::bytes_size(2, &value);
            };
            if let Some(v) = self.service_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_uint32(1, v)?;
            }
            for v in &self.objects {
                os.write_bytes(2, &v)?;
            };
            if let Some(v) = self.service_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TypeCache {
            TypeCache::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.objects.clear();
            self.service_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TypeCache {
            static instance: TypeCache = TypeCache {
                type_: ::std::option::Option::None,
                objects: ::std::vec::Vec::new(),
                service_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TypeCache {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSerializedSOCache.TypeCache").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TypeCache {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TypeCache {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgSerializedSOCache.Cache)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Cache {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.Cache.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.Cache.id)
        pub id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.Cache.versions)
        pub versions: ::std::vec::Vec<cache::Version>,
        // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.Cache.type_caches)
        pub type_caches: ::std::vec::Vec<TypeCache>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgSerializedSOCache.Cache.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Cache {
        fn default() -> &'a Cache {
            <Cache as ::protobuf::Message>::default_instance()
        }
    }

    impl Cache {
        pub fn new() -> Cache {
            ::std::default::Default::default()
        }

        // optional uint32 type = 1;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint64 id = 2;

        pub fn id(&self) -> u64 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u64) {
            self.id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Cache| { &m.type_ },
                |m: &mut Cache| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &Cache| { &m.id },
                |m: &mut Cache| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "versions",
                |m: &Cache| { &m.versions },
                |m: &mut Cache| { &mut m.versions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type_caches",
                |m: &Cache| { &m.type_caches },
                |m: &mut Cache| { &mut m.type_caches },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cache>(
                "CMsgSerializedSOCache.Cache",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Cache {
        const NAME: &'static str = "Cache";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.versions.push(is.read_message()?);
                    },
                    34 => {
                        self.type_caches.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            for value in &self.versions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.type_caches {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.id {
                os.write_uint64(2, v)?;
            }
            for v in &self.versions {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.type_caches {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Cache {
            Cache::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.id = ::std::option::Option::None;
            self.versions.clear();
            self.type_caches.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Cache {
            static instance: Cache = Cache {
                type_: ::std::option::Option::None,
                id: ::std::option::Option::None,
                versions: ::std::vec::Vec::new(),
                type_caches: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Cache {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSerializedSOCache.Cache").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Cache {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Cache {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Cache`
    pub mod cache {
        // @@protoc_insertion_point(message:dota.CMsgSerializedSOCache.Cache.Version)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Version {
            // message fields
            // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.Cache.Version.service)
            pub service: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:dota.CMsgSerializedSOCache.Cache.Version.version)
            pub version: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:dota.CMsgSerializedSOCache.Cache.Version.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Version {
            fn default() -> &'a Version {
                <Version as ::protobuf::Message>::default_instance()
            }
        }

        impl Version {
            pub fn new() -> Version {
                ::std::default::Default::default()
            }

            // optional uint32 service = 1;

            pub fn service(&self) -> u32 {
                self.service.unwrap_or(0)
            }

            pub fn clear_service(&mut self) {
                self.service = ::std::option::Option::None;
            }

            pub fn has_service(&self) -> bool {
                self.service.is_some()
            }

            // Param is passed by value, moved
            pub fn set_service(&mut self, v: u32) {
                self.service = ::std::option::Option::Some(v);
            }

            // optional uint64 version = 2;

            pub fn version(&self) -> u64 {
                self.version.unwrap_or(0)
            }

            pub fn clear_version(&mut self) {
                self.version = ::std::option::Option::None;
            }

            pub fn has_version(&self) -> bool {
                self.version.is_some()
            }

            // Param is passed by value, moved
            pub fn set_version(&mut self, v: u64) {
                self.version = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "service",
                    |m: &Version| { &m.service },
                    |m: &mut Version| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "version",
                    |m: &Version| { &m.version },
                    |m: &mut Version| { &mut m.version },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Version>(
                    "CMsgSerializedSOCache.Cache.Version",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Version {
            const NAME: &'static str = "Version";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.service = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.version = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.service {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.version {
                    my_size += ::protobuf::rt::uint64_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.service {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.version {
                    os.write_uint64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Version {
                Version::new()
            }

            fn clear(&mut self) {
                self.service = ::std::option::Option::None;
                self.version = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Version {
                static instance: Version = Version {
                    service: ::std::option::Option::None,
                    version: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Version {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgSerializedSOCache.Cache.Version").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Version {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Version {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientPollConvarRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPollConvarRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollConvarRequest.convar_name)
    pub convar_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollConvarRequest.poll_id)
    pub poll_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientPollConvarRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPollConvarRequest {
    fn default() -> &'a CMsgGCToClientPollConvarRequest {
        <CMsgGCToClientPollConvarRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPollConvarRequest {
    pub fn new() -> CMsgGCToClientPollConvarRequest {
        ::std::default::Default::default()
    }

    // optional string convar_name = 1;

    pub fn convar_name(&self) -> &str {
        match self.convar_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_convar_name(&mut self) {
        self.convar_name = ::std::option::Option::None;
    }

    pub fn has_convar_name(&self) -> bool {
        self.convar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_convar_name(&mut self, v: ::std::string::String) {
        self.convar_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_convar_name(&mut self) -> &mut ::std::string::String {
        if self.convar_name.is_none() {
            self.convar_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.convar_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_convar_name(&mut self) -> ::std::string::String {
        self.convar_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 poll_id = 2;

    pub fn poll_id(&self) -> u32 {
        self.poll_id.unwrap_or(0)
    }

    pub fn clear_poll_id(&mut self) {
        self.poll_id = ::std::option::Option::None;
    }

    pub fn has_poll_id(&self) -> bool {
        self.poll_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poll_id(&mut self, v: u32) {
        self.poll_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "convar_name",
            |m: &CMsgGCToClientPollConvarRequest| { &m.convar_name },
            |m: &mut CMsgGCToClientPollConvarRequest| { &mut m.convar_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "poll_id",
            |m: &CMsgGCToClientPollConvarRequest| { &m.poll_id },
            |m: &mut CMsgGCToClientPollConvarRequest| { &mut m.poll_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientPollConvarRequest>(
            "CMsgGCToClientPollConvarRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientPollConvarRequest {
    const NAME: &'static str = "CMsgGCToClientPollConvarRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.convar_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.poll_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.convar_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.poll_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.convar_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.poll_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPollConvarRequest {
        CMsgGCToClientPollConvarRequest::new()
    }

    fn clear(&mut self) {
        self.convar_name = ::std::option::Option::None;
        self.poll_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPollConvarRequest {
        static instance: CMsgGCToClientPollConvarRequest = CMsgGCToClientPollConvarRequest {
            convar_name: ::std::option::Option::None,
            poll_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientPollConvarRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientPollConvarRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientPollConvarRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientPollConvarRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientPollConvarResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPollConvarResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollConvarResponse.poll_id)
    pub poll_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientPollConvarResponse.convar_value)
    pub convar_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientPollConvarResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPollConvarResponse {
    fn default() -> &'a CMsgGCToClientPollConvarResponse {
        <CMsgGCToClientPollConvarResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPollConvarResponse {
    pub fn new() -> CMsgGCToClientPollConvarResponse {
        ::std::default::Default::default()
    }

    // optional uint32 poll_id = 1;

    pub fn poll_id(&self) -> u32 {
        self.poll_id.unwrap_or(0)
    }

    pub fn clear_poll_id(&mut self) {
        self.poll_id = ::std::option::Option::None;
    }

    pub fn has_poll_id(&self) -> bool {
        self.poll_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poll_id(&mut self, v: u32) {
        self.poll_id = ::std::option::Option::Some(v);
    }

    // optional string convar_value = 2;

    pub fn convar_value(&self) -> &str {
        match self.convar_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_convar_value(&mut self) {
        self.convar_value = ::std::option::Option::None;
    }

    pub fn has_convar_value(&self) -> bool {
        self.convar_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_convar_value(&mut self, v: ::std::string::String) {
        self.convar_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_convar_value(&mut self) -> &mut ::std::string::String {
        if self.convar_value.is_none() {
            self.convar_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.convar_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_convar_value(&mut self) -> ::std::string::String {
        self.convar_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "poll_id",
            |m: &CMsgGCToClientPollConvarResponse| { &m.poll_id },
            |m: &mut CMsgGCToClientPollConvarResponse| { &mut m.poll_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "convar_value",
            |m: &CMsgGCToClientPollConvarResponse| { &m.convar_value },
            |m: &mut CMsgGCToClientPollConvarResponse| { &mut m.convar_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientPollConvarResponse>(
            "CMsgGCToClientPollConvarResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientPollConvarResponse {
    const NAME: &'static str = "CMsgGCToClientPollConvarResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.poll_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.convar_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.poll_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.convar_value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.poll_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.convar_value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPollConvarResponse {
        CMsgGCToClientPollConvarResponse::new()
    }

    fn clear(&mut self) {
        self.poll_id = ::std::option::Option::None;
        self.convar_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPollConvarResponse {
        static instance: CMsgGCToClientPollConvarResponse = CMsgGCToClientPollConvarResponse {
            poll_id: ::std::option::Option::None,
            convar_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientPollConvarResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientPollConvarResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientPollConvarResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientPollConvarResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CGCMsgCompressedMsgToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgCompressedMsgToClient {
    // message fields
    // @@protoc_insertion_point(field:dota.CGCMsgCompressedMsgToClient.msg_id)
    pub msg_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CGCMsgCompressedMsgToClient.compressed_msg)
    pub compressed_msg: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CGCMsgCompressedMsgToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgCompressedMsgToClient {
    fn default() -> &'a CGCMsgCompressedMsgToClient {
        <CGCMsgCompressedMsgToClient as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgCompressedMsgToClient {
    pub fn new() -> CGCMsgCompressedMsgToClient {
        ::std::default::Default::default()
    }

    // optional uint32 msg_id = 1;

    pub fn msg_id(&self) -> u32 {
        self.msg_id.unwrap_or(0)
    }

    pub fn clear_msg_id(&mut self) {
        self.msg_id = ::std::option::Option::None;
    }

    pub fn has_msg_id(&self) -> bool {
        self.msg_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_id(&mut self, v: u32) {
        self.msg_id = ::std::option::Option::Some(v);
    }

    // optional bytes compressed_msg = 2;

    pub fn compressed_msg(&self) -> &[u8] {
        match self.compressed_msg.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_compressed_msg(&mut self) {
        self.compressed_msg = ::std::option::Option::None;
    }

    pub fn has_compressed_msg(&self) -> bool {
        self.compressed_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressed_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.compressed_msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compressed_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.compressed_msg.is_none() {
            self.compressed_msg = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.compressed_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_compressed_msg(&mut self) -> ::std::vec::Vec<u8> {
        self.compressed_msg.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_id",
            |m: &CGCMsgCompressedMsgToClient| { &m.msg_id },
            |m: &mut CGCMsgCompressedMsgToClient| { &mut m.msg_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "compressed_msg",
            |m: &CGCMsgCompressedMsgToClient| { &m.compressed_msg },
            |m: &mut CGCMsgCompressedMsgToClient| { &mut m.compressed_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCMsgCompressedMsgToClient>(
            "CGCMsgCompressedMsgToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCMsgCompressedMsgToClient {
    const NAME: &'static str = "CGCMsgCompressedMsgToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.compressed_msg = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.compressed_msg.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.compressed_msg.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgCompressedMsgToClient {
        CGCMsgCompressedMsgToClient::new()
    }

    fn clear(&mut self) {
        self.msg_id = ::std::option::Option::None;
        self.compressed_msg = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgCompressedMsgToClient {
        static instance: CGCMsgCompressedMsgToClient = CGCMsgCompressedMsgToClient {
            msg_id: ::std::option::Option::None,
            compressed_msg: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCMsgCompressedMsgToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCMsgCompressedMsgToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCMsgCompressedMsgToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgCompressedMsgToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCMasterBroadcastMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterBroadcastMessage {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterBroadcastMessage.users_per_second)
    pub users_per_second: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterBroadcastMessage.send_to_users)
    pub send_to_users: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterBroadcastMessage.send_to_servers)
    pub send_to_servers: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterBroadcastMessage.msg_id)
    pub msg_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterBroadcastMessage.msg_data)
    pub msg_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCMasterBroadcastMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterBroadcastMessage {
    fn default() -> &'a CMsgGCToGCMasterBroadcastMessage {
        <CMsgGCToGCMasterBroadcastMessage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterBroadcastMessage {
    pub fn new() -> CMsgGCToGCMasterBroadcastMessage {
        ::std::default::Default::default()
    }

    // optional uint32 users_per_second = 1;

    pub fn users_per_second(&self) -> u32 {
        self.users_per_second.unwrap_or(0)
    }

    pub fn clear_users_per_second(&mut self) {
        self.users_per_second = ::std::option::Option::None;
    }

    pub fn has_users_per_second(&self) -> bool {
        self.users_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_users_per_second(&mut self, v: u32) {
        self.users_per_second = ::std::option::Option::Some(v);
    }

    // optional bool send_to_users = 2;

    pub fn send_to_users(&self) -> bool {
        self.send_to_users.unwrap_or(false)
    }

    pub fn clear_send_to_users(&mut self) {
        self.send_to_users = ::std::option::Option::None;
    }

    pub fn has_send_to_users(&self) -> bool {
        self.send_to_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_to_users(&mut self, v: bool) {
        self.send_to_users = ::std::option::Option::Some(v);
    }

    // optional bool send_to_servers = 3;

    pub fn send_to_servers(&self) -> bool {
        self.send_to_servers.unwrap_or(false)
    }

    pub fn clear_send_to_servers(&mut self) {
        self.send_to_servers = ::std::option::Option::None;
    }

    pub fn has_send_to_servers(&self) -> bool {
        self.send_to_servers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_to_servers(&mut self, v: bool) {
        self.send_to_servers = ::std::option::Option::Some(v);
    }

    // optional uint32 msg_id = 4;

    pub fn msg_id(&self) -> u32 {
        self.msg_id.unwrap_or(0)
    }

    pub fn clear_msg_id(&mut self) {
        self.msg_id = ::std::option::Option::None;
    }

    pub fn has_msg_id(&self) -> bool {
        self.msg_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_id(&mut self, v: u32) {
        self.msg_id = ::std::option::Option::Some(v);
    }

    // optional bytes msg_data = 5;

    pub fn msg_data(&self) -> &[u8] {
        match self.msg_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_msg_data(&mut self) {
        self.msg_data = ::std::option::Option::None;
    }

    pub fn has_msg_data(&self) -> bool {
        self.msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.msg_data.is_none() {
            self.msg_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.msg_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_data(&mut self) -> ::std::vec::Vec<u8> {
        self.msg_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "users_per_second",
            |m: &CMsgGCToGCMasterBroadcastMessage| { &m.users_per_second },
            |m: &mut CMsgGCToGCMasterBroadcastMessage| { &mut m.users_per_second },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_to_users",
            |m: &CMsgGCToGCMasterBroadcastMessage| { &m.send_to_users },
            |m: &mut CMsgGCToGCMasterBroadcastMessage| { &mut m.send_to_users },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_to_servers",
            |m: &CMsgGCToGCMasterBroadcastMessage| { &m.send_to_servers },
            |m: &mut CMsgGCToGCMasterBroadcastMessage| { &mut m.send_to_servers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_id",
            |m: &CMsgGCToGCMasterBroadcastMessage| { &m.msg_id },
            |m: &mut CMsgGCToGCMasterBroadcastMessage| { &mut m.msg_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_data",
            |m: &CMsgGCToGCMasterBroadcastMessage| { &m.msg_data },
            |m: &mut CMsgGCToGCMasterBroadcastMessage| { &mut m.msg_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCMasterBroadcastMessage>(
            "CMsgGCToGCMasterBroadcastMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCMasterBroadcastMessage {
    const NAME: &'static str = "CMsgGCToGCMasterBroadcastMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.users_per_second = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.send_to_users = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.send_to_servers = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.msg_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.msg_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.users_per_second {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.send_to_users {
            my_size += 1 + 1;
        }
        if let Some(v) = self.send_to_servers {
            my_size += 1 + 1;
        }
        if let Some(v) = self.msg_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.msg_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.users_per_second {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.send_to_users {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.send_to_servers {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.msg_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.msg_data.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterBroadcastMessage {
        CMsgGCToGCMasterBroadcastMessage::new()
    }

    fn clear(&mut self) {
        self.users_per_second = ::std::option::Option::None;
        self.send_to_users = ::std::option::Option::None;
        self.send_to_servers = ::std::option::Option::None;
        self.msg_id = ::std::option::Option::None;
        self.msg_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterBroadcastMessage {
        static instance: CMsgGCToGCMasterBroadcastMessage = CMsgGCToGCMasterBroadcastMessage {
            users_per_second: ::std::option::Option::None,
            send_to_users: ::std::option::Option::None,
            send_to_servers: ::std::option::Option::None,
            msg_id: ::std::option::Option::None,
            msg_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCMasterBroadcastMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCMasterBroadcastMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCMasterBroadcastMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCMasterBroadcastMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCMasterSubscribeToCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterSubscribeToCache {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterSubscribeToCache.soid_type)
    pub soid_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterSubscribeToCache.soid_id)
    pub soid_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterSubscribeToCache.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterSubscribeToCache.steam_ids)
    pub steam_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCMasterSubscribeToCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterSubscribeToCache {
    fn default() -> &'a CMsgGCToGCMasterSubscribeToCache {
        <CMsgGCToGCMasterSubscribeToCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterSubscribeToCache {
    pub fn new() -> CMsgGCToGCMasterSubscribeToCache {
        ::std::default::Default::default()
    }

    // optional uint32 soid_type = 1;

    pub fn soid_type(&self) -> u32 {
        self.soid_type.unwrap_or(0)
    }

    pub fn clear_soid_type(&mut self) {
        self.soid_type = ::std::option::Option::None;
    }

    pub fn has_soid_type(&self) -> bool {
        self.soid_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_type(&mut self, v: u32) {
        self.soid_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 soid_id = 2;

    pub fn soid_id(&self) -> u64 {
        self.soid_id.unwrap_or(0)
    }

    pub fn clear_soid_id(&mut self) {
        self.soid_id = ::std::option::Option::None;
    }

    pub fn has_soid_id(&self) -> bool {
        self.soid_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_id(&mut self, v: u64) {
        self.soid_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soid_type",
            |m: &CMsgGCToGCMasterSubscribeToCache| { &m.soid_type },
            |m: &mut CMsgGCToGCMasterSubscribeToCache| { &mut m.soid_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soid_id",
            |m: &CMsgGCToGCMasterSubscribeToCache| { &m.soid_id },
            |m: &mut CMsgGCToGCMasterSubscribeToCache| { &mut m.soid_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCToGCMasterSubscribeToCache| { &m.account_ids },
            |m: &mut CMsgGCToGCMasterSubscribeToCache| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steam_ids",
            |m: &CMsgGCToGCMasterSubscribeToCache| { &m.steam_ids },
            |m: &mut CMsgGCToGCMasterSubscribeToCache| { &mut m.steam_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCMasterSubscribeToCache>(
            "CMsgGCToGCMasterSubscribeToCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCMasterSubscribeToCache {
    const NAME: &'static str = "CMsgGCToGCMasterSubscribeToCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soid_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.soid_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                24 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steam_ids)?;
                },
                33 => {
                    self.steam_ids.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.soid_id {
            my_size += 1 + 8;
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += 9 * self.steam_ids.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soid_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.soid_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(3, *v)?;
        };
        for v in &self.steam_ids {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterSubscribeToCache {
        CMsgGCToGCMasterSubscribeToCache::new()
    }

    fn clear(&mut self) {
        self.soid_type = ::std::option::Option::None;
        self.soid_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.steam_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterSubscribeToCache {
        static instance: CMsgGCToGCMasterSubscribeToCache = CMsgGCToGCMasterSubscribeToCache {
            soid_type: ::std::option::Option::None,
            soid_id: ::std::option::Option::None,
            account_ids: ::std::vec::Vec::new(),
            steam_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCMasterSubscribeToCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCMasterSubscribeToCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCMasterSubscribeToCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCMasterSubscribeToCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCMasterSubscribeToCacheResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterSubscribeToCacheResponse {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCMasterSubscribeToCacheResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterSubscribeToCacheResponse {
    fn default() -> &'a CMsgGCToGCMasterSubscribeToCacheResponse {
        <CMsgGCToGCMasterSubscribeToCacheResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterSubscribeToCacheResponse {
    pub fn new() -> CMsgGCToGCMasterSubscribeToCacheResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCMasterSubscribeToCacheResponse>(
            "CMsgGCToGCMasterSubscribeToCacheResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCMasterSubscribeToCacheResponse {
    const NAME: &'static str = "CMsgGCToGCMasterSubscribeToCacheResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterSubscribeToCacheResponse {
        CMsgGCToGCMasterSubscribeToCacheResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterSubscribeToCacheResponse {
        static instance: CMsgGCToGCMasterSubscribeToCacheResponse = CMsgGCToGCMasterSubscribeToCacheResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCMasterSubscribeToCacheResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCMasterSubscribeToCacheResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCMasterSubscribeToCacheResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCMasterSubscribeToCacheResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCMasterSubscribeToCacheAsync)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterSubscribeToCacheAsync {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterSubscribeToCacheAsync.subscribe_msg)
    pub subscribe_msg: ::protobuf::MessageField<CMsgGCToGCMasterSubscribeToCache>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCMasterSubscribeToCacheAsync.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterSubscribeToCacheAsync {
    fn default() -> &'a CMsgGCToGCMasterSubscribeToCacheAsync {
        <CMsgGCToGCMasterSubscribeToCacheAsync as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterSubscribeToCacheAsync {
    pub fn new() -> CMsgGCToGCMasterSubscribeToCacheAsync {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCToGCMasterSubscribeToCache>(
            "subscribe_msg",
            |m: &CMsgGCToGCMasterSubscribeToCacheAsync| { &m.subscribe_msg },
            |m: &mut CMsgGCToGCMasterSubscribeToCacheAsync| { &mut m.subscribe_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCMasterSubscribeToCacheAsync>(
            "CMsgGCToGCMasterSubscribeToCacheAsync",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCMasterSubscribeToCacheAsync {
    const NAME: &'static str = "CMsgGCToGCMasterSubscribeToCacheAsync";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subscribe_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subscribe_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subscribe_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterSubscribeToCacheAsync {
        CMsgGCToGCMasterSubscribeToCacheAsync::new()
    }

    fn clear(&mut self) {
        self.subscribe_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterSubscribeToCacheAsync {
        static instance: CMsgGCToGCMasterSubscribeToCacheAsync = CMsgGCToGCMasterSubscribeToCacheAsync {
            subscribe_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCMasterSubscribeToCacheAsync {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCMasterSubscribeToCacheAsync").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCMasterSubscribeToCacheAsync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCMasterSubscribeToCacheAsync {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCMasterUnsubscribeFromCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterUnsubscribeFromCache {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterUnsubscribeFromCache.soid_type)
    pub soid_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterUnsubscribeFromCache.soid_id)
    pub soid_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterUnsubscribeFromCache.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterUnsubscribeFromCache.steam_ids)
    pub steam_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCMasterUnsubscribeFromCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterUnsubscribeFromCache {
    fn default() -> &'a CMsgGCToGCMasterUnsubscribeFromCache {
        <CMsgGCToGCMasterUnsubscribeFromCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterUnsubscribeFromCache {
    pub fn new() -> CMsgGCToGCMasterUnsubscribeFromCache {
        ::std::default::Default::default()
    }

    // optional uint32 soid_type = 1;

    pub fn soid_type(&self) -> u32 {
        self.soid_type.unwrap_or(0)
    }

    pub fn clear_soid_type(&mut self) {
        self.soid_type = ::std::option::Option::None;
    }

    pub fn has_soid_type(&self) -> bool {
        self.soid_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_type(&mut self, v: u32) {
        self.soid_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 soid_id = 2;

    pub fn soid_id(&self) -> u64 {
        self.soid_id.unwrap_or(0)
    }

    pub fn clear_soid_id(&mut self) {
        self.soid_id = ::std::option::Option::None;
    }

    pub fn has_soid_id(&self) -> bool {
        self.soid_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_id(&mut self, v: u64) {
        self.soid_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soid_type",
            |m: &CMsgGCToGCMasterUnsubscribeFromCache| { &m.soid_type },
            |m: &mut CMsgGCToGCMasterUnsubscribeFromCache| { &mut m.soid_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soid_id",
            |m: &CMsgGCToGCMasterUnsubscribeFromCache| { &m.soid_id },
            |m: &mut CMsgGCToGCMasterUnsubscribeFromCache| { &mut m.soid_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCToGCMasterUnsubscribeFromCache| { &m.account_ids },
            |m: &mut CMsgGCToGCMasterUnsubscribeFromCache| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steam_ids",
            |m: &CMsgGCToGCMasterUnsubscribeFromCache| { &m.steam_ids },
            |m: &mut CMsgGCToGCMasterUnsubscribeFromCache| { &mut m.steam_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCMasterUnsubscribeFromCache>(
            "CMsgGCToGCMasterUnsubscribeFromCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCMasterUnsubscribeFromCache {
    const NAME: &'static str = "CMsgGCToGCMasterUnsubscribeFromCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soid_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.soid_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                24 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steam_ids)?;
                },
                33 => {
                    self.steam_ids.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.soid_id {
            my_size += 1 + 8;
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += 9 * self.steam_ids.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soid_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.soid_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(3, *v)?;
        };
        for v in &self.steam_ids {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterUnsubscribeFromCache {
        CMsgGCToGCMasterUnsubscribeFromCache::new()
    }

    fn clear(&mut self) {
        self.soid_type = ::std::option::Option::None;
        self.soid_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.steam_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterUnsubscribeFromCache {
        static instance: CMsgGCToGCMasterUnsubscribeFromCache = CMsgGCToGCMasterUnsubscribeFromCache {
            soid_type: ::std::option::Option::None,
            soid_id: ::std::option::Option::None,
            account_ids: ::std::vec::Vec::new(),
            steam_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCMasterUnsubscribeFromCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCMasterUnsubscribeFromCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCMasterUnsubscribeFromCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCMasterUnsubscribeFromCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGCToGCMasterDestroyCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterDestroyCache {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterDestroyCache.soid_type)
    pub soid_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToGCMasterDestroyCache.soid_id)
    pub soid_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToGCMasterDestroyCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterDestroyCache {
    fn default() -> &'a CMsgGCToGCMasterDestroyCache {
        <CMsgGCToGCMasterDestroyCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterDestroyCache {
    pub fn new() -> CMsgGCToGCMasterDestroyCache {
        ::std::default::Default::default()
    }

    // optional uint32 soid_type = 1;

    pub fn soid_type(&self) -> u32 {
        self.soid_type.unwrap_or(0)
    }

    pub fn clear_soid_type(&mut self) {
        self.soid_type = ::std::option::Option::None;
    }

    pub fn has_soid_type(&self) -> bool {
        self.soid_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_type(&mut self, v: u32) {
        self.soid_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 soid_id = 2;

    pub fn soid_id(&self) -> u64 {
        self.soid_id.unwrap_or(0)
    }

    pub fn clear_soid_id(&mut self) {
        self.soid_id = ::std::option::Option::None;
    }

    pub fn has_soid_id(&self) -> bool {
        self.soid_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_id(&mut self, v: u64) {
        self.soid_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soid_type",
            |m: &CMsgGCToGCMasterDestroyCache| { &m.soid_type },
            |m: &mut CMsgGCToGCMasterDestroyCache| { &mut m.soid_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soid_id",
            |m: &CMsgGCToGCMasterDestroyCache| { &m.soid_id },
            |m: &mut CMsgGCToGCMasterDestroyCache| { &mut m.soid_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCMasterDestroyCache>(
            "CMsgGCToGCMasterDestroyCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCMasterDestroyCache {
    const NAME: &'static str = "CMsgGCToGCMasterDestroyCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soid_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.soid_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.soid_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soid_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.soid_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterDestroyCache {
        CMsgGCToGCMasterDestroyCache::new()
    }

    fn clear(&mut self) {
        self.soid_type = ::std::option::Option::None;
        self.soid_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterDestroyCache {
        static instance: CMsgGCToGCMasterDestroyCache = CMsgGCToGCMasterDestroyCache {
            soid_type: ::std::option::Option::None,
            soid_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCMasterDestroyCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCMasterDestroyCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCMasterDestroyCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCMasterDestroyCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ESourceEngine)
pub enum ESourceEngine {
    // @@protoc_insertion_point(enum_value:dota.ESourceEngine.k_ESE_Source1)
    k_ESE_Source1 = 0,
    // @@protoc_insertion_point(enum_value:dota.ESourceEngine.k_ESE_Source2)
    k_ESE_Source2 = 1,
}

impl ::protobuf::Enum for ESourceEngine {
    const NAME: &'static str = "ESourceEngine";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESourceEngine> {
        match value {
            0 => ::std::option::Option::Some(ESourceEngine::k_ESE_Source1),
            1 => ::std::option::Option::Some(ESourceEngine::k_ESE_Source2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESourceEngine> {
        match str {
            "k_ESE_Source1" => ::std::option::Option::Some(ESourceEngine::k_ESE_Source1),
            "k_ESE_Source2" => ::std::option::Option::Some(ESourceEngine::k_ESE_Source2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESourceEngine] = &[
        ESourceEngine::k_ESE_Source1,
        ESourceEngine::k_ESE_Source2,
    ];
}

impl ::protobuf::EnumFull for ESourceEngine {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESourceEngine").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESourceEngine {
    fn default() -> Self {
        ESourceEngine::k_ESE_Source1
    }
}

impl ESourceEngine {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESourceEngine>("ESourceEngine")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.PartnerAccountType)
pub enum PartnerAccountType {
    // @@protoc_insertion_point(enum_value:dota.PartnerAccountType.PARTNER_NONE)
    PARTNER_NONE = 0,
    // @@protoc_insertion_point(enum_value:dota.PartnerAccountType.PARTNER_PERFECT_WORLD)
    PARTNER_PERFECT_WORLD = 1,
    // @@protoc_insertion_point(enum_value:dota.PartnerAccountType.PARTNER_INVALID)
    PARTNER_INVALID = 3,
}

impl ::protobuf::Enum for PartnerAccountType {
    const NAME: &'static str = "PartnerAccountType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartnerAccountType> {
        match value {
            0 => ::std::option::Option::Some(PartnerAccountType::PARTNER_NONE),
            1 => ::std::option::Option::Some(PartnerAccountType::PARTNER_PERFECT_WORLD),
            3 => ::std::option::Option::Some(PartnerAccountType::PARTNER_INVALID),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PartnerAccountType> {
        match str {
            "PARTNER_NONE" => ::std::option::Option::Some(PartnerAccountType::PARTNER_NONE),
            "PARTNER_PERFECT_WORLD" => ::std::option::Option::Some(PartnerAccountType::PARTNER_PERFECT_WORLD),
            "PARTNER_INVALID" => ::std::option::Option::Some(PartnerAccountType::PARTNER_INVALID),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PartnerAccountType] = &[
        PartnerAccountType::PARTNER_NONE,
        PartnerAccountType::PARTNER_PERFECT_WORLD,
        PartnerAccountType::PARTNER_INVALID,
    ];
}

impl ::protobuf::EnumFull for PartnerAccountType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PartnerAccountType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            PartnerAccountType::PARTNER_NONE => 0,
            PartnerAccountType::PARTNER_PERFECT_WORLD => 1,
            PartnerAccountType::PARTNER_INVALID => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PartnerAccountType {
    fn default() -> Self {
        PartnerAccountType::PARTNER_NONE
    }
}

impl PartnerAccountType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PartnerAccountType>("PartnerAccountType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.GCConnectionStatus)
pub enum GCConnectionStatus {
    // @@protoc_insertion_point(enum_value:dota.GCConnectionStatus.GCConnectionStatus_HAVE_SESSION)
    GCConnectionStatus_HAVE_SESSION = 0,
    // @@protoc_insertion_point(enum_value:dota.GCConnectionStatus.GCConnectionStatus_GC_GOING_DOWN)
    GCConnectionStatus_GC_GOING_DOWN = 1,
    // @@protoc_insertion_point(enum_value:dota.GCConnectionStatus.GCConnectionStatus_NO_SESSION)
    GCConnectionStatus_NO_SESSION = 2,
    // @@protoc_insertion_point(enum_value:dota.GCConnectionStatus.GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE)
    GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3,
    // @@protoc_insertion_point(enum_value:dota.GCConnectionStatus.GCConnectionStatus_NO_STEAM)
    GCConnectionStatus_NO_STEAM = 4,
    // @@protoc_insertion_point(enum_value:dota.GCConnectionStatus.GCConnectionStatus_SUSPENDED)
    GCConnectionStatus_SUSPENDED = 5,
    // @@protoc_insertion_point(enum_value:dota.GCConnectionStatus.GCConnectionStatus_STEAM_GOING_DOWN)
    GCConnectionStatus_STEAM_GOING_DOWN = 6,
}

impl ::protobuf::Enum for GCConnectionStatus {
    const NAME: &'static str = "GCConnectionStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCConnectionStatus> {
        match value {
            0 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            1 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            2 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            3 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            4 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            5 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_SUSPENDED),
            6 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_STEAM_GOING_DOWN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GCConnectionStatus> {
        match str {
            "GCConnectionStatus_HAVE_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            "GCConnectionStatus_GC_GOING_DOWN" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            "GCConnectionStatus_NO_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            "GCConnectionStatus_NO_STEAM" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            "GCConnectionStatus_SUSPENDED" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_SUSPENDED),
            "GCConnectionStatus_STEAM_GOING_DOWN" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_STEAM_GOING_DOWN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GCConnectionStatus] = &[
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE,
        GCConnectionStatus::GCConnectionStatus_NO_STEAM,
        GCConnectionStatus::GCConnectionStatus_SUSPENDED,
        GCConnectionStatus::GCConnectionStatus_STEAM_GOING_DOWN,
    ];
}

impl ::protobuf::EnumFull for GCConnectionStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GCConnectionStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GCConnectionStatus {
    fn default() -> Self {
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION
    }
}

impl GCConnectionStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GCConnectionStatus>("GCConnectionStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16gcsdk_gcmessages.proto\x12\x04dota\x1a\x13steammessages.proto\x1a,\
    steammessages_steamlearn.steamworkssdk.proto\"\x85\x01\n\x0eCExtraMsgBlo\
    ck\x12\x19\n\x08msg_type\x18\x01\x20\x01(\rR\x07msgType\x12\x1a\n\x08con\
    tents\x18\x02\x20\x01(\x0cR\x08contents\x12\x17\n\x07msg_key\x18\x03\x20\
    \x01(\x04R\x06msgKey\x12#\n\ris_compressed\x18\x04\x20\x01(\x08R\x0cisCo\
    mpressed\"[\n\x13CMsgGCAssertJobData\x12!\n\x0cmessage_type\x18\x01\x20\
    \x01(\tR\x0bmessageType\x12!\n\x0cmessage_data\x18\x02\x20\x01(\x0cR\x0b\
    messageData\",\n\x10CMsgGCConCommand\x12\x18\n\x07command\x18\x01\x20\
    \x01(\tR\x07command\"\xa7\x01\n\rCMsgSDOAssert\x12\x19\n\x08sdo_type\x18\
    \x01\x20\x01(\x05R\x07sdoType\x127\n\x08requests\x18\x02\x20\x03(\x0b2\
    \x1b.dota.CMsgSDOAssert.RequestR\x08requests\x1aB\n\x07Request\x12\x10\n\
    \x03key\x18\x01\x20\x03(\x04R\x03key\x12%\n\x0erequesting_job\x18\x02\
    \x20\x01(\tR\rrequestingJob\"3\n\rCMsgSOIDOwner\x12\x12\n\x04type\x18\
    \x01\x20\x01(\rR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\x04R\x02id\"\
    \xbb\x01\n\x12CMsgSOSingleObject\x12\x17\n\x07type_id\x18\x02\x20\x01(\
    \x05R\x06typeId\x12\x1f\n\x0bobject_data\x18\x03\x20\x01(\x0cR\nobjectDa\
    ta\x12\x18\n\x07version\x18\x04\x20\x01(\x06R\x07version\x122\n\nowner_s\
    oid\x18\x05\x20\x01(\x0b2\x13.dota.CMsgSOIDOwnerR\townerSoid\x12\x1d\n\n\
    service_id\x18\x06\x20\x01(\rR\tserviceId\"\xd1\x03\n\x15CMsgSOMultipleO\
    bjects\x12S\n\x10objects_modified\x18\x02\x20\x03(\x0b2(.dota.CMsgSOMult\
    ipleObjects.SingleObjectR\x0fobjectsModified\x12\x18\n\x07version\x18\
    \x03\x20\x01(\x06R\x07version\x12M\n\robjects_added\x18\x04\x20\x03(\x0b\
    2(.dota.CMsgSOMultipleObjects.SingleObjectR\x0cobjectsAdded\x12Q\n\x0fob\
    jects_removed\x18\x05\x20\x03(\x0b2(.dota.CMsgSOMultipleObjects.SingleOb\
    jectR\x0eobjectsRemoved\x122\n\nowner_soid\x18\x06\x20\x01(\x0b2\x13.dot\
    a.CMsgSOIDOwnerR\townerSoid\x12\x1d\n\nservice_id\x18\x07\x20\x01(\rR\ts\
    erviceId\x1aT\n\x0cSingleObject\x12\x17\n\x07type_id\x18\x01\x20\x01(\
    \x05R\x06typeId\x12\x1f\n\x0bobject_data\x18\x02\x20\x01(\x0cR\nobjectDa\
    ta:\n\x80\xa6\x1d\x80\x02\x88\xa6\x1d\x80\x08\"\xdc\x02\n\x15CMsgSOCache\
    Subscribed\x12D\n\x07objects\x18\x02\x20\x03(\x0b2*.dota.CMsgSOCacheSubs\
    cribed.SubscribedTypeR\x07objects\x12\x18\n\x07version\x18\x03\x20\x01(\
    \x06R\x07version\x122\n\nowner_soid\x18\x04\x20\x01(\x0b2\x13.dota.CMsgS\
    OIDOwnerR\townerSoid\x12\x1d\n\nservice_id\x18\x05\x20\x01(\rR\tserviceI\
    d\x12!\n\x0cservice_list\x18\x06\x20\x03(\rR\x0bserviceList\x12!\n\x0csy\
    nc_version\x18\x07\x20\x01(\x06R\x0bsyncVersion\x1aJ\n\x0eSubscribedType\
    \x12\x17\n\x07type_id\x18\x01\x20\x01(\x05R\x06typeId\x12\x1f\n\x0bobjec\
    t_data\x18\x02\x20\x03(\x0cR\nobjectData\"\xd2\x01\n\x1dCMsgSOCacheSubsc\
    ribedUpToDate\x12\x18\n\x07version\x18\x01\x20\x01(\x06R\x07version\x122\
    \n\nowner_soid\x18\x02\x20\x01(\x0b2\x13.dota.CMsgSOIDOwnerR\townerSoid\
    \x12\x1d\n\nservice_id\x18\x03\x20\x01(\rR\tserviceId\x12!\n\x0cservice_\
    list\x18\x04\x20\x03(\rR\x0bserviceList\x12!\n\x0csync_version\x18\x05\
    \x20\x01(\x06R\x0bsyncVersion\"M\n\x17CMsgSOCacheUnsubscribed\x122\n\now\
    ner_soid\x18\x02\x20\x01(\x0b2\x13.dota.CMsgSOIDOwnerR\townerSoid\"\xd1\
    \x01\n\x1cCMsgSOCacheSubscriptionCheck\x12\x18\n\x07version\x18\x02\x20\
    \x01(\x06R\x07version\x122\n\nowner_soid\x18\x03\x20\x01(\x0b2\x13.dota.\
    CMsgSOIDOwnerR\townerSoid\x12\x1d\n\nservice_id\x18\x04\x20\x01(\rR\tser\
    viceId\x12!\n\x0cservice_list\x18\x05\x20\x03(\rR\x0bserviceList\x12!\n\
    \x0csync_version\x18\x06\x20\x01(\x06R\x0bsyncVersion\"T\n\x1eCMsgSOCach\
    eSubscriptionRefresh\x122\n\nowner_soid\x18\x02\x20\x01(\x0b2\x13.dota.C\
    MsgSOIDOwnerR\townerSoid\".\n\x12CMsgSOCacheVersion\x12\x18\n\x07version\
    \x18\x01\x20\x01(\x06R\x07version\"h\n\x16CMsgGCMultiplexMessage\x12\x18\
    \n\x07msgtype\x18\x01\x20\x01(\rR\x07msgtype\x12\x18\n\x07payload\x18\
    \x02\x20\x01(\x0cR\x07payload\x12\x1a\n\x08steamids\x18\x03\x20\x03(\x06\
    R\x08steamids\"6\n\x17CMsgGCToGCSubGCStarting\x12\x1b\n\tdir_index\x18\
    \x01\x20\x01(\x05R\x08dirIndex\"\x88\x02\n\x13CGCToGCMsgMasterAck\x12\
    \x1b\n\tdir_index\x18\x01\x20\x01(\x05R\x08dirIndex\x12!\n\x0cmachine_na\
    me\x18\x03\x20\x01(\tR\x0bmachineName\x12!\n\x0cprocess_name\x18\x04\x20\
    \x01(\tR\x0bprocessName\x12?\n\tdirectory\x18\x06\x20\x03(\x0b2!.dota.CG\
    CToGCMsgMasterAck.ProcessR\tdirectory\x1aM\n\x07Process\x12\x1b\n\tdir_i\
    ndex\x18\x01\x20\x01(\x05R\x08dirIndex\x12%\n\x0etype_instances\x18\x02\
    \x20\x03(\rR\rtypeInstances\"8\n\x1cCGCToGCMsgMasterAck_Response\x12\x18\
    \n\x07eresult\x18\x01\x20\x01(\x05R\x07eresult\"I\n\x19CMsgGCToGCUnivers\
    eStartup\x12,\n\x12is_initial_startup\x18\x01\x20\x01(\x08R\x10isInitial\
    Startup\"=\n!CMsgGCToGCUniverseStartupResponse\x12\x18\n\x07eresult\x18\
    \x01\x20\x01(\x05R\x07eresult\"\xb2\x01\n\x1fCGCToGCMsgMasterStartupComp\
    lete\x12E\n\x07gc_info\x18\x01\x20\x03(\x0b2,.dota.CGCToGCMsgMasterStart\
    upComplete.GCInfoR\x06gcInfo\x1aH\n\x06GCInfo\x12\x1b\n\tdir_index\x18\
    \x01\x20\x01(\x05R\x08dirIndex\x12!\n\x0cmachine_name\x18\x02\x20\x01(\t\
    R\x0bmachineName\"k\n\x10CGCToGCMsgRouted\x12\x19\n\x08msg_type\x18\x01\
    \x20\x01(\rR\x07msgType\x12\x1b\n\tsender_id\x18\x02\x20\x01(\x06R\x08se\
    nderId\x12\x1f\n\x0bnet_message\x18\x03\x20\x01(\x0cR\nnetMessage\"S\n\
    \x15CGCToGCMsgRoutedReply\x12\x19\n\x08msg_type\x18\x01\x20\x01(\rR\x07m\
    sgType\x12\x1f\n\x0bnet_message\x18\x02\x20\x01(\x0cR\nnetMessage\"\xb9\
    \x01\n\x1cCMsgGCUpdateSubGCSessionInfo\x12G\n\x07updates\x18\x01\x20\x03\
    (\x0b2-.dota.CMsgGCUpdateSubGCSessionInfo.CMsgUpdateR\x07updates\x1aP\n\
    \nCMsgUpdate\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\
    \x0e\n\x02ip\x18\x02\x20\x01(\x07R\x02ip\x12\x18\n\x07trusted\x18\x03\
    \x20\x01(\x08R\x07trusted\"9\n\x1dCMsgGCRequestSubGCSessionInfo\x12\x18\
    \n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"\x7f\n%CMsgGCRequestSubG\
    CSessionInfoResponse\x12\x0e\n\x02ip\x18\x01\x20\x01(\x07R\x02ip\x12\x18\
    \n\x07trusted\x18\x02\x20\x01(\x08R\x07trusted\x12\x12\n\x04port\x18\x03\
    \x20\x01(\rR\x04port\x12\x18\n\x07success\x18\x04\x20\x01(\x08R\x07succe\
    ss\"\xaa\x01\n\x16CMsgSOCacheHaveVersion\x12'\n\x04soid\x18\x01\x20\x01(\
    \x0b2\x13.dota.CMsgSOIDOwnerR\x04soid\x12\x18\n\x07version\x18\x02\x20\
    \x01(\x06R\x07version\x12\x1d\n\nservice_id\x18\x03\x20\x01(\rR\tservice\
    Id\x12.\n\x13cached_file_version\x18\x04\x20\x01(\rR\x11cachedFileVersio\
    n\"\xb1\x07\n\x0fCMsgClientHello\x12\x18\n\x07version\x18\x01\x20\x01(\r\
    R\x07version\x12P\n\x15socache_have_versions\x18\x02\x20\x03(\x0b2\x1c.d\
    ota.CMsgSOCacheHaveVersionR\x13socacheHaveVersions\x12.\n\x13client_sess\
    ion_need\x18\x03\x20\x01(\rR\x11clientSessionNeed\x12A\n\x0fclient_launc\
    her\x18\x04\x20\x01(\x0e2\x18.dota.PartnerAccountTypeR\x0eclientLauncher\
    \x12\x1d\n\nsecret_key\x18\x05\x20\x01(\tR\tsecretKey\x12'\n\x0fclient_l\
    anguage\x18\x06\x20\x01(\rR\x0eclientLanguage\x12+\n\x06engine\x18\x07\
    \x20\x01(\x0e2\x13.dota.ESourceEngineR\x06engine\x12/\n\x13steamdatagram\
    _login\x18\x08\x20\x01(\x0cR\x12steamdatagramLogin\x12\x1f\n\x0bplatform\
    _id\x18\t\x20\x01(\rR\nplatformId\x12\x19\n\x08game_msg\x18\n\x20\x01(\
    \x0cR\x07gameMsg\x12\x17\n\x07os_type\x18\x0b\x20\x01(\x05R\x06osType\
    \x12#\n\rrender_system\x18\x0c\x20\x01(\rR\x0crenderSystem\x12*\n\x11ren\
    der_system_req\x18\r\x20\x01(\rR\x0frenderSystemReq\x12!\n\x0cscreen_wid\
    th\x18\x0e\x20\x01(\rR\x0bscreenWidth\x12#\n\rscreen_height\x18\x0f\x20\
    \x01(\rR\x0cscreenHeight\x12%\n\x0escreen_refresh\x18\x10\x20\x01(\rR\rs\
    creenRefresh\x12!\n\x0crender_width\x18\x11\x20\x01(\rR\x0brenderWidth\
    \x12#\n\rrender_height\x18\x12\x20\x01(\rR\x0crenderHeight\x12\x1d\n\nsw\
    ap_width\x18\x13\x20\x01(\rR\tswapWidth\x12\x1f\n\x0bswap_height\x18\x14\
    \x20\x01(\rR\nswapHeight\x12$\n\x0eis_steam_china\x18\x16\x20\x01(\x08R\
    \x0cisSteamChina\x121\n\x15is_steam_china_client\x18\x18\x20\x01(\x08R\
    \x12isSteamChinaClient\x12#\n\rplatform_name\x18\x17\x20\x01(\tR\x0cplat\
    formName\"\xea\x07\n\x11CMsgClientWelcome\x12\x18\n\x07version\x18\x01\
    \x20\x01(\rR\x07version\x12\x1b\n\tgame_data\x18\x02\x20\x01(\x0cR\x08ga\
    meData\x12[\n\x1boutofdate_subscribed_caches\x18\x03\x20\x03(\x0b2\x1b.d\
    ota.CMsgSOCacheSubscribedR\x19outofdateSubscribedCaches\x12`\n\x1auptoda\
    te_subscribed_caches\x18\x04\x20\x03(\x0b2\".dota.CMsgSOCacheSubscriptio\
    nCheckR\x18uptodateSubscribedCaches\x12<\n\x08location\x18\x05\x20\x01(\
    \x0b2\x20.dota.CMsgClientWelcome.LocationR\x08location\x12\"\n\rsave_gam\
    e_key\x18\x06\x20\x01(\x0cR\x0bsaveGameKey\x125\n\x17gc_socache_file_ver\
    sion\x18\t\x20\x01(\rR\x14gcSocacheFileVersion\x12(\n\x10txn_country_cod\
    e\x18\n\x20\x01(\tR\x0etxnCountryCode\x12\x1d\n\ngame_data2\x18\x0b\x20\
    \x01(\x0cR\tgameData2\x12?\n\x1crtime32_gc_welcome_timestamp\x18\x0c\x20\
    \x01(\rR\x19rtime32GcWelcomeTimestamp\x12\x1a\n\x08currency\x18\r\x20\
    \x01(\rR\x08currency\x12\x18\n\x07balance\x18\x0e\x20\x01(\rR\x07balance\
    \x12\x1f\n\x0bbalance_url\x18\x0f\x20\x01(\tR\nbalanceUrl\x123\n\x16has_\
    accepted_china_ssa\x18\x10\x20\x01(\x08R\x13hasAcceptedChinaSsa\x121\n\
    \x15is_banned_steam_china\x18\x11\x20\x01(\x08R\x12isBannedSteamChina\
    \x12L\n\x17additional_welcome_msgs\x18\x12\x20\x01(\x0b2\x14.dota.CExtra\
    MsgBlockR\x15additionalWelcomeMsgs\x12O\n\x15steam_learn_hmac_keys\x18\
    \x13\x20\x01(\x0b2\x1c.dota.CMsgSteamLearnHMACKeysR\x12steamLearnHmacKey\
    s\x1a^\n\x08Location\x12\x1a\n\x08latitude\x18\x01\x20\x01(\x02R\x08lati\
    tude\x12\x1c\n\tlongitude\x18\x02\x20\x01(\x02R\tlongitude\x12\x18\n\x07\
    country\x18\x03\x20\x01(\tR\x07country\"\xaa\x02\n\x14CMsgConnectionStat\
    us\x120\n\x06status\x18\x01\x20\x01(\x0e2\x18.dota.GCConnectionStatusR\
    \x06status\x12.\n\x13client_session_need\x18\x02\x20\x01(\rR\x11clientSe\
    ssionNeed\x12%\n\x0equeue_position\x18\x03\x20\x01(\x05R\rqueuePosition\
    \x12\x1d\n\nqueue_size\x18\x04\x20\x01(\x05R\tqueueSize\x12!\n\x0cwait_s\
    econds\x18\x05\x20\x01(\x05R\x0bwaitSeconds\x12G\n\x20estimated_wait_sec\
    onds_remaining\x18\x06\x20\x01(\x05R\x1destimatedWaitSecondsRemaining\"\
    \xd8\x02\n\x1aCMsgGCToGCSOCacheSubscribe\x12\x1e\n\nsubscriber\x18\x01\
    \x20\x01(\x06R\nsubscriber\x12&\n\x0fsubscribe_to_id\x18\x02\x20\x01(\
    \x06R\rsubscribeToId\x12!\n\x0csync_version\x18\x03\x20\x01(\x06R\x0bsyn\
    cVersion\x12V\n\rhave_versions\x18\x04\x20\x03(\x0b21.dota.CMsgGCToGCSOC\
    acheSubscribe.CMsgHaveVersionsR\x0chaveVersions\x12*\n\x11subscribe_to_t\
    ype\x18\x05\x20\x01(\rR\x0fsubscribeToType\x1aK\n\x10CMsgHaveVersions\
    \x12\x1d\n\nservice_id\x18\x01\x20\x01(\rR\tserviceId\x12\x18\n\x07versi\
    on\x18\x02\x20\x01(\x04R\x07version\"\xa2\x01\n\x1cCMsgGCToGCSOCacheUnsu\
    bscribe\x12\x1e\n\nsubscriber\x18\x01\x20\x01(\x06R\nsubscriber\x12.\n\
    \x13unsubscribe_from_id\x18\x02\x20\x01(\x06R\x11unsubscribeFromId\x122\
    \n\x15unsubscribe_from_type\x18\x03\x20\x01(\rR\x13unsubscribeFromType\"\
    \x12\n\x10CMsgGCClientPing\"\xb4\x01\n\x1fCMsgGCToGCForwardAccountDetail\
    s\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12V\n\x0faccoun\
    t_details\x18\x02\x20\x01(\x0b2-.dota.CGCSystemMsg_GetAccountDetails_Res\
    ponseR\x0eaccountDetails\x12\x1f\n\x0bage_seconds\x18\x03\x20\x01(\rR\na\
    geSeconds\"\x9c\x01\n\x1cCMsgGCToGCLoadSessionSOCache\x12\x1d\n\naccount\
    _id\x18\x01\x20\x01(\rR\taccountId\x12]\n\x17forward_account_details\x18\
    \x02\x20\x01(\x0b2%.dota.CMsgGCToGCForwardAccountDetailsR\x15forwardAcco\
    untDetails\"&\n$CMsgGCToGCLoadSessionSOCacheResponse\"\x92\x01\n\x1cCMsg\
    GCToGCUpdateSessionStats\x12#\n\ruser_sessions\x18\x01\x20\x01(\rR\x0cus\
    erSessions\x12'\n\x0fserver_sessions\x18\x02\x20\x01(\rR\x0eserverSessio\
    ns\x12$\n\x0ein_logon_surge\x18\x03\x20\x01(\x08R\x0cinLogonSurge\"\x1e\
    \n\x1cCMsgGCToClientRequestDropped\"\xbe\x03\n*CWorkshop_PopulateItemDes\
    criptions_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12l\n\
    \tlanguages\x18\x02\x20\x03(\x0b2N.dota.CWorkshop_PopulateItemDescriptio\
    ns_Request.ItemDescriptionsLanguageBlockR\tlanguages\x1ab\n\x15SingleIte\
    mDescription\x12\x1e\n\ngameitemid\x18\x01\x20\x01(\rR\ngameitemid\x12)\
    \n\x10item_description\x18\x02\x20\x01(\tR\x0fitemDescription\x1a\xa7\
    \x01\n\x1dItemDescriptionsLanguageBlock\x12\x1a\n\x08language\x18\x01\
    \x20\x01(\tR\x08language\x12j\n\x0cdescriptions\x18\x02\x20\x03(\x0b2F.d\
    ota.CWorkshop_PopulateItemDescriptions_Request.SingleItemDescriptionR\
    \x0cdescriptions\"Y\n!CWorkshop_GetContributors_Request\x12\x14\n\x05app\
    id\x18\x01\x20\x01(\rR\x05appid\x12\x1e\n\ngameitemid\x18\x02\x20\x01(\r\
    R\ngameitemid\"H\n\"CWorkshop_GetContributors_Response\x12\"\n\x0ccontri\
    butors\x18\x01\x20\x03(\x06R\x0ccontributors\"\xa5\x08\n%CWorkshop_SetIt\
    emPaymentRules_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12\x1e\n\ngameitemid\x18\x02\x20\x01(\rR\ngameitemid\x12\x7f\n\x19asso\
    ciated_workshop_files\x18\x03\x20\x03(\x0b2C.dota.CWorkshop_SetItemPayme\
    ntRules_Request.WorkshopItemPaymentRuleR\x17associatedWorkshopFiles\x12m\
    \n\x10partner_accounts\x18\x04\x20\x03(\x0b2B.dota.CWorkshop_SetItemPaym\
    entRules_Request.PartnerItemPaymentRuleR\x0fpartnerAccounts\x12#\n\rvali\
    date_only\x18\x05\x20\x01(\x08R\x0cvalidateOnly\x12G\n\x20make_workshop_\
    files_subscribable\x18\x06\x20\x01(\x08R\x1dmakeWorkshopFilesSubscribabl\
    e\x12\xa4\x01\n,associated_workshop_file_for_direct_payments\x18\x07\x20\
    \x01(\x0b2E.dota.CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPay\
    mentRuleR'associatedWorkshopFileForDirectPayments\x1a\xba\x01\n\x17Works\
    hopItemPaymentRule\x12(\n\x10workshop_file_id\x18\x01\x20\x01(\x04R\x0ew\
    orkshopFileId\x12-\n\x12revenue_percentage\x18\x02\x20\x01(\x02R\x11reve\
    nuePercentage\x12)\n\x10rule_description\x18\x03\x20\x01(\tR\x0fruleDesc\
    ription\x12\x1b\n\trule_type\x18\x04\x20\x01(\rR\x08ruleType\x1ap\n\x19W\
    orkshopDirectPaymentRule\x12(\n\x10workshop_file_id\x18\x01\x20\x01(\x04\
    R\x0eworkshopFileId\x12)\n\x10rule_description\x18\x02\x20\x01(\tR\x0fru\
    leDescription\x1a\x91\x01\n\x16PartnerItemPaymentRule\x12\x1d\n\naccount\
    _id\x18\x01\x20\x01(\rR\taccountId\x12-\n\x12revenue_percentage\x18\x02\
    \x20\x01(\x02R\x11revenuePercentage\x12)\n\x10rule_description\x18\x03\
    \x20\x01(\tR\x0fruleDescription\"U\n&CWorkshop_SetItemPaymentRules_Respo\
    nse\x12+\n\x11validation_errors\x18\x01\x20\x03(\tR\x10validationErrors\
    \"\xe5\x02\n\x1fCCommunity_ClanAnnouncementInfo\x12\x10\n\x03gid\x18\x01\
    \x20\x01(\x04R\x03gid\x12\x16\n\x06clanid\x18\x02\x20\x01(\x04R\x06clani\
    d\x12\x1a\n\x08posterid\x18\x03\x20\x01(\x04R\x08posterid\x12\x1a\n\x08h\
    eadline\x18\x04\x20\x01(\tR\x08headline\x12\x1a\n\x08posttime\x18\x05\
    \x20\x01(\rR\x08posttime\x12\x1e\n\nupdatetime\x18\x06\x20\x01(\rR\nupda\
    tetime\x12\x12\n\x04body\x18\x07\x20\x01(\tR\x04body\x12\"\n\x0ccommentc\
    ount\x18\x08\x20\x01(\x05R\x0ccommentcount\x12\x12\n\x04tags\x18\t\x20\
    \x03(\tR\x04tags\x12\x1a\n\x08language\x18\n\x20\x01(\x05R\x08language\
    \x12\x16\n\x06hidden\x18\x0b\x20\x01(\x08R\x06hidden\x12$\n\x0eforum_top\
    ic_id\x18\x0c\x20\x01(\x06R\x0cforumTopicId\"\xef\x03\n'CCommunity_GetCl\
    anAnnouncements_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\x04R\x07st\
    eamid\x12\x16\n\x06offset\x18\x02\x20\x01(\rR\x06offset\x12\x14\n\x05cou\
    nt\x18\x03\x20\x01(\rR\x05count\x12\x1a\n\x08maxchars\x18\x04\x20\x01(\r\
    R\x08maxchars\x12\x1d\n\nstrip_html\x18\x05\x20\x01(\x08R\tstripHtml\x12\
    #\n\rrequired_tags\x18\x06\x20\x03(\tR\x0crequiredTags\x12&\n\x0frequire\
    _no_tags\x18\x07\x20\x01(\x08R\rrequireNoTags\x12/\n\x13language_prefere\
    nce\x18\x08\x20\x03(\rR\x12languagePreference\x12\x1f\n\x0bhidden_only\
    \x18\t\x20\x01(\x08R\nhiddenOnly\x12\x19\n\x08only_gid\x18\n\x20\x01(\
    \x08R\x07onlyGid\x12*\n\x11rtime_oldest_date\x18\x0b\x20\x01(\rR\x0frtim\
    eOldestDate\x12%\n\x0einclude_hidden\x18\x0c\x20\x01(\x08R\rincludeHidde\
    n\x124\n\x16include_partner_events\x18\r\x20\x01(\x08R\x14includePartner\
    Events\"\xb2\x01\n(CCommunity_GetClanAnnouncements_Response\x12\x1a\n\
    \x08maxchars\x18\x01\x20\x01(\rR\x08maxchars\x12\x1d\n\nstrip_html\x18\
    \x02\x20\x01(\x08R\tstripHtml\x12K\n\rannouncements\x18\x03\x20\x03(\x0b\
    2%.dota.CCommunity_ClanAnnouncementInfoR\rannouncements\"\x98\x01\n$CBro\
    adcast_PostGameDataFrame_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\x12!\n\
    \x0cbroadcast_id\x18\x03\x20\x01(\x06R\x0bbroadcastId\x12\x1d\n\nframe_d\
    ata\x18\x04\x20\x01(\x0cR\tframeData\"\x82\x04\n\x15CMsgSerializedSOCach\
    e\x12!\n\x0cfile_version\x18\x01\x20\x01(\rR\x0bfileVersion\x129\n\x06ca\
    ches\x18\x02\x20\x03(\x0b2!.dota.CMsgSerializedSOCache.CacheR\x06caches\
    \x125\n\x17gc_socache_file_version\x18\x03\x20\x01(\rR\x14gcSocacheFileV\
    ersion\x1aX\n\tTypeCache\x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\
    \x12\x18\n\x07objects\x18\x02\x20\x03(\x0cR\x07objects\x12\x1d\n\nservic\
    e_id\x18\x03\x20\x01(\rR\tserviceId\x1a\xf9\x01\n\x05Cache\x12\x12\n\x04\
    type\x18\x01\x20\x01(\rR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\x04R\
    \x02id\x12E\n\x08versions\x18\x03\x20\x03(\x0b2).dota.CMsgSerializedSOCa\
    che.Cache.VersionR\x08versions\x12F\n\x0btype_caches\x18\x04\x20\x03(\
    \x0b2%.dota.CMsgSerializedSOCache.TypeCacheR\ntypeCaches\x1a=\n\x07Versi\
    on\x12\x18\n\x07service\x18\x01\x20\x01(\rR\x07service\x12\x18\n\x07vers\
    ion\x18\x02\x20\x01(\x04R\x07version\"[\n\x1fCMsgGCToClientPollConvarReq\
    uest\x12\x1f\n\x0bconvar_name\x18\x01\x20\x01(\tR\nconvarName\x12\x17\n\
    \x07poll_id\x18\x02\x20\x01(\rR\x06pollId\"^\n\x20CMsgGCToClientPollConv\
    arResponse\x12\x17\n\x07poll_id\x18\x01\x20\x01(\rR\x06pollId\x12!\n\x0c\
    convar_value\x18\x02\x20\x01(\tR\x0bconvarValue\"[\n\x1bCGCMsgCompressed\
    MsgToClient\x12\x15\n\x06msg_id\x18\x01\x20\x01(\rR\x05msgId\x12%\n\x0ec\
    ompressed_msg\x18\x02\x20\x01(\x0cR\rcompressedMsg\"\xca\x01\n\x20CMsgGC\
    ToGCMasterBroadcastMessage\x12(\n\x10users_per_second\x18\x01\x20\x01(\r\
    R\x0eusersPerSecond\x12\"\n\rsend_to_users\x18\x02\x20\x01(\x08R\x0bsend\
    ToUsers\x12&\n\x0fsend_to_servers\x18\x03\x20\x01(\x08R\rsendToServers\
    \x12\x15\n\x06msg_id\x18\x04\x20\x01(\rR\x05msgId\x12\x19\n\x08msg_data\
    \x18\x05\x20\x01(\x0cR\x07msgData\"\x96\x01\n\x20CMsgGCToGCMasterSubscri\
    beToCache\x12\x1b\n\tsoid_type\x18\x01\x20\x01(\rR\x08soidType\x12\x17\n\
    \x07soid_id\x18\x02\x20\x01(\x06R\x06soidId\x12\x1f\n\x0baccount_ids\x18\
    \x03\x20\x03(\rR\naccountIds\x12\x1b\n\tsteam_ids\x18\x04\x20\x03(\x06R\
    \x08steamIds\"*\n(CMsgGCToGCMasterSubscribeToCacheResponse\"t\n%CMsgGCTo\
    GCMasterSubscribeToCacheAsync\x12K\n\rsubscribe_msg\x18\x01\x20\x01(\x0b\
    2&.dota.CMsgGCToGCMasterSubscribeToCacheR\x0csubscribeMsg\"\x9a\x01\n$CM\
    sgGCToGCMasterUnsubscribeFromCache\x12\x1b\n\tsoid_type\x18\x01\x20\x01(\
    \rR\x08soidType\x12\x17\n\x07soid_id\x18\x02\x20\x01(\x06R\x06soidId\x12\
    \x1f\n\x0baccount_ids\x18\x03\x20\x03(\rR\naccountIds\x12\x1b\n\tsteam_i\
    ds\x18\x04\x20\x03(\x06R\x08steamIds\"T\n\x1cCMsgGCToGCMasterDestroyCach\
    e\x12\x1b\n\tsoid_type\x18\x01\x20\x01(\rR\x08soidType\x12\x17\n\x07soid\
    _id\x18\x02\x20\x01(\x06R\x06soidId*5\n\rESourceEngine\x12\x11\n\rk_ESE_\
    Source1\x10\0\x12\x11\n\rk_ESE_Source2\x10\x01*V\n\x12PartnerAccountType\
    \x12\x10\n\x0cPARTNER_NONE\x10\0\x12\x19\n\x15PARTNER_PERFECT_WORLD\x10\
    \x01\x12\x13\n\x0fPARTNER_INVALID\x10\x03*\xa0\x02\n\x12GCConnectionStat\
    us\x12#\n\x1fGCConnectionStatus_HAVE_SESSION\x10\0\x12$\n\x20GCConnectio\
    nStatus_GC_GOING_DOWN\x10\x01\x12!\n\x1dGCConnectionStatus_NO_SESSION\
    \x10\x02\x120\n,GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE\x10\x03\x12\
    \x1f\n\x1bGCConnectionStatus_NO_STEAM\x10\x04\x12\x20\n\x1cGCConnectionS\
    tatus_SUSPENDED\x10\x05\x12'\n#GCConnectionStatus_STEAM_GOING_DOWN\x10\
    \x06B%Z#github.com/dotabuff/manta/dota;dotaJ\x80\xa1\x01\n\x07\x12\x05\0\
    \0\xe6\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\
    \x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\x0b\x12\x03\
    \x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x1c\n\t\n\x02\x03\x01\x12\x03\
    \x06\x075\n\n\n\x02\x05\0\x12\x04\x08\0\x0b\x01\n\n\n\x03\x05\0\x01\x12\
    \x03\x08\x05\x12\n\x0b\n\x04\x05\0\x02\0\x12\x03\t\x08\x1a\n\x0c\n\x05\
    \x05\0\x02\0\x01\x12\x03\t\x08\x15\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\t\
    \x18\x19\n\x0b\n\x04\x05\0\x02\x01\x12\x03\n\x08\x1a\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\n\x08\x15\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\n\
    \x18\x19\n\n\n\x02\x05\x01\x12\x04\r\0\x11\x01\n\n\n\x03\x05\x01\x01\x12\
    \x03\r\x05\x17\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x0e\x08\x19\n\x0c\n\x05\
    \x05\x01\x02\0\x01\x12\x03\x0e\x08\x14\n\x0c\n\x05\x05\x01\x02\0\x02\x12\
    \x03\x0e\x17\x18\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x0f\x08\"\n\x0c\n\
    \x05\x05\x01\x02\x01\x01\x12\x03\x0f\x08\x1d\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03\x0f\x20!\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\x10\x08\x1c\n\
    \x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x10\x08\x17\n\x0c\n\x05\x05\x01\
    \x02\x02\x02\x12\x03\x10\x1a\x1b\n\n\n\x02\x05\x02\x12\x04\x13\0\x1b\x01\
    \n\n\n\x03\x05\x02\x01\x12\x03\x13\x05\x17\n\x0b\n\x04\x05\x02\x02\0\x12\
    \x03\x14\x08,\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03\x14\x08'\n\x0c\n\x05\
    \x05\x02\x02\0\x02\x12\x03\x14*+\n\x0b\n\x04\x05\x02\x02\x01\x12\x03\x15\
    \x08-\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03\x15\x08(\n\x0c\n\x05\x05\
    \x02\x02\x01\x02\x12\x03\x15+,\n\x0b\n\x04\x05\x02\x02\x02\x12\x03\x16\
    \x08*\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03\x16\x08%\n\x0c\n\x05\x05\
    \x02\x02\x02\x02\x12\x03\x16()\n\x0b\n\x04\x05\x02\x02\x03\x12\x03\x17\
    \x089\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03\x17\x084\n\x0c\n\x05\x05\
    \x02\x02\x03\x02\x12\x03\x1778\n\x0b\n\x04\x05\x02\x02\x04\x12\x03\x18\
    \x08(\n\x0c\n\x05\x05\x02\x02\x04\x01\x12\x03\x18\x08#\n\x0c\n\x05\x05\
    \x02\x02\x04\x02\x12\x03\x18&'\n\x0b\n\x04\x05\x02\x02\x05\x12\x03\x19\
    \x08)\n\x0c\n\x05\x05\x02\x02\x05\x01\x12\x03\x19\x08$\n\x0c\n\x05\x05\
    \x02\x02\x05\x02\x12\x03\x19'(\n\x0b\n\x04\x05\x02\x02\x06\x12\x03\x1a\
    \x080\n\x0c\n\x05\x05\x02\x02\x06\x01\x12\x03\x1a\x08+\n\x0c\n\x05\x05\
    \x02\x02\x06\x02\x12\x03\x1a./\n\n\n\x02\x04\0\x12\x04\x1d\0\"\x01\n\n\n\
    \x03\x04\0\x01\x12\x03\x1d\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\x03\x1e\
    \x08%\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x1e\x08\x10\n\x0c\n\x05\x04\0\
    \x02\0\x05\x12\x03\x1e\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1e\
    \x18\x20\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1e#$\n\x0b\n\x04\x04\0\x02\
    \x01\x12\x03\x1f\x08$\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x1f\x08\x10\
    \n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x1f\x11\x16\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\x1f\x17\x1f\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1f\"\
    #\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x20\x08$\n\x0c\n\x05\x04\0\x02\x02\
    \x04\x12\x03\x20\x08\x10\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x20\x11\
    \x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x20\x18\x1f\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03\x20\"#\n\x0b\n\x04\x04\0\x02\x03\x12\x03!\x08(\n\
    \x0c\n\x05\x04\0\x02\x03\x04\x12\x03!\x08\x10\n\x0c\n\x05\x04\0\x02\x03\
    \x05\x12\x03!\x11\x15\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03!\x16#\n\x0c\
    \n\x05\x04\0\x02\x03\x03\x12\x03!&'\n\n\n\x02\x04\x01\x12\x04$\0'\x01\n\
    \n\n\x03\x04\x01\x01\x12\x03$\x08\x1b\n\x0b\n\x04\x04\x01\x02\0\x12\x03%\
    \x08)\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03%\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03%\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03%\x18$\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03%'(\n\x0b\n\x04\x04\x01\x02\x01\
    \x12\x03&\x08(\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03&\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x01\x05\x12\x03&\x11\x16\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03&\x17#\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03&&'\n\n\n\x02\
    \x04\x02\x12\x04)\0+\x01\n\n\n\x03\x04\x02\x01\x12\x03)\x08\x18\n\x0b\n\
    \x04\x04\x02\x02\0\x12\x03*\x08$\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03*\
    \x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03*\x11\x17\n\x0c\n\x05\x04\
    \x02\x02\0\x01\x12\x03*\x18\x1f\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03*\"\
    #\n\n\n\x02\x04\x03\x12\x04-\05\x01\n\n\n\x03\x04\x03\x01\x12\x03-\x08\
    \x15\n\x0c\n\x04\x04\x03\x03\0\x12\x04.\x081\t\n\x0c\n\x05\x04\x03\x03\0\
    \x01\x12\x03.\x10\x17\n\r\n\x06\x04\x03\x03\0\x02\0\x12\x03/\x10(\n\x0e\
    \n\x07\x04\x03\x03\0\x02\0\x04\x12\x03/\x10\x18\n\x0e\n\x07\x04\x03\x03\
    \0\x02\0\x05\x12\x03/\x19\x1f\n\x0e\n\x07\x04\x03\x03\0\x02\0\x01\x12\
    \x03/\x20#\n\x0e\n\x07\x04\x03\x03\0\x02\0\x03\x12\x03/&'\n\r\n\x06\x04\
    \x03\x03\0\x02\x01\x12\x030\x103\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x04\
    \x12\x030\x10\x18\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x05\x12\x030\x19\x1f\
    \n\x0e\n\x07\x04\x03\x03\0\x02\x01\x01\x12\x030\x20.\n\x0e\n\x07\x04\x03\
    \x03\0\x02\x01\x03\x12\x03012\n\x0b\n\x04\x04\x03\x02\0\x12\x033\x08$\n\
    \x0c\n\x05\x04\x03\x02\0\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\x03\x02\0\
    \x05\x12\x033\x11\x16\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x033\x17\x1f\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x033\"#\n\x0b\n\x04\x04\x03\x02\x01\x12\
    \x034\x084\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x034\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\x01\x06\x12\x034\x11&\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\
    \x034'/\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03423\n\n\n\x02\x04\x04\x12\
    \x047\0:\x01\n\n\n\x03\x04\x04\x01\x12\x037\x08\x15\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x038\x08!\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x038\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x038\x11\x17\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x038\x18\x1c\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x038\x1f\x20\n\
    \x0b\n\x04\x04\x04\x02\x01\x12\x039\x08\x1f\n\x0c\n\x05\x04\x04\x02\x01\
    \x04\x12\x039\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x039\x11\x17\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x039\x18\x1a\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x039\x1d\x1e\n\n\n\x02\x04\x05\x12\x04<\0B\x01\n\n\n\x03\
    \x04\x05\x01\x12\x03<\x08\x1a\n\x0b\n\x04\x04\x05\x02\0\x12\x03=\x08#\n\
    \x0c\n\x05\x04\x05\x02\0\x04\x12\x03=\x08\x10\n\x0c\n\x05\x04\x05\x02\0\
    \x05\x12\x03=\x11\x16\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03=\x17\x1e\n\
    \x0c\n\x05\x04\x05\x02\0\x03\x12\x03=!\"\n\x0b\n\x04\x04\x05\x02\x01\x12\
    \x03>\x08'\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03>\x08\x10\n\x0c\n\x05\
    \x04\x05\x02\x01\x05\x12\x03>\x11\x16\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x03>\x17\"\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03>%&\n\x0b\n\x04\
    \x04\x05\x02\x02\x12\x03?\x08%\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03?\
    \x08\x10\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03?\x11\x18\n\x0c\n\x05\
    \x04\x05\x02\x02\x01\x12\x03?\x19\x20\n\x0c\n\x05\x04\x05\x02\x02\x03\
    \x12\x03?#$\n\x0b\n\x04\x04\x05\x02\x03\x12\x03@\x08.\n\x0c\n\x05\x04\
    \x05\x02\x03\x04\x12\x03@\x08\x10\n\x0c\n\x05\x04\x05\x02\x03\x06\x12\
    \x03@\x11\x1e\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03@\x1f)\n\x0c\n\x05\
    \x04\x05\x02\x03\x03\x12\x03@,-\n\x0b\n\x04\x04\x05\x02\x04\x12\x03A\x08\
    '\n\x0c\n\x05\x04\x05\x02\x04\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x04\x05\x12\x03A\x11\x17\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03A\
    \x18\"\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03A%&\n\n\n\x02\x04\x06\x12\
    \x04D\0S\x01\n\n\n\x03\x04\x06\x01\x12\x03D\x08\x1d\n\x0c\n\x04\x04\x06\
    \x03\0\x12\x04E\x08K\t\n\x0c\n\x05\x04\x06\x03\0\x01\x12\x03E\x10\x1c\n\
    \x0c\n\x05\x04\x06\x03\0\x07\x12\x03F\x102\n\x0f\n\x08\x04\x06\x03\0\x07\
    \xe0\xd4\x03\x12\x03F\x102\n\x0c\n\x05\x04\x06\x03\0\x07\x12\x03G\x103\n\
    \x0f\n\x08\x04\x06\x03\0\x07\xe1\xd4\x03\x12\x03G\x103\n\r\n\x06\x04\x06\
    \x03\0\x02\0\x12\x03I\x10+\n\x0e\n\x07\x04\x06\x03\0\x02\0\x04\x12\x03I\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\0\x05\x12\x03I\x19\x1e\n\x0e\n\
    \x07\x04\x06\x03\0\x02\0\x01\x12\x03I\x1f&\n\x0e\n\x07\x04\x06\x03\0\x02\
    \0\x03\x12\x03I)*\n\r\n\x06\x04\x06\x03\0\x02\x01\x12\x03J\x10/\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x01\x04\x12\x03J\x10\x18\n\x0e\n\x07\x04\x06\x03\
    \0\x02\x01\x05\x12\x03J\x19\x1e\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x01\
    \x12\x03J\x1f*\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x03\x12\x03J-.\n\x0b\n\
    \x04\x04\x06\x02\0\x12\x03M\x08I\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03M\
    \x08\x10\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03M\x113\n\x0c\n\x05\x04\x06\
    \x02\0\x01\x12\x03M4D\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03MGH\n\x0b\n\
    \x04\x04\x06\x02\x01\x12\x03N\x08%\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\
    \x03N\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03N\x11\x18\n\x0c\n\
    \x05\x04\x06\x02\x01\x01\x12\x03N\x19\x20\n\x0c\n\x05\x04\x06\x02\x01\
    \x03\x12\x03N#$\n\x0b\n\x04\x04\x06\x02\x02\x12\x03O\x08F\n\x0c\n\x05\
    \x04\x06\x02\x02\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x06\
    \x12\x03O\x113\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03O4A\n\x0c\n\x05\
    \x04\x06\x02\x02\x03\x12\x03ODE\n\x0b\n\x04\x04\x06\x02\x03\x12\x03P\x08\
    H\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03P\x08\x10\n\x0c\n\x05\x04\x06\
    \x02\x03\x06\x12\x03P\x113\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03P4C\n\
    \x0c\n\x05\x04\x06\x02\x03\x03\x12\x03PFG\n\x0b\n\x04\x04\x06\x02\x04\
    \x12\x03Q\x08.\n\x0c\n\x05\x04\x06\x02\x04\x04\x12\x03Q\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\x04\x06\x12\x03Q\x11\x1e\n\x0c\n\x05\x04\x06\x02\x04\
    \x01\x12\x03Q\x1f)\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03Q,-\n\x0b\n\
    \x04\x04\x06\x02\x05\x12\x03R\x08'\n\x0c\n\x05\x04\x06\x02\x05\x04\x12\
    \x03R\x08\x10\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\x03R\x11\x17\n\x0c\n\
    \x05\x04\x06\x02\x05\x01\x12\x03R\x18\"\n\x0c\n\x05\x04\x06\x02\x05\x03\
    \x12\x03R%&\n\n\n\x02\x04\x07\x12\x04U\0a\x01\n\n\n\x03\x04\x07\x01\x12\
    \x03U\x08\x1d\n\x0c\n\x04\x04\x07\x03\0\x12\x04V\x08Y\t\n\x0c\n\x05\x04\
    \x07\x03\0\x01\x12\x03V\x10\x1e\n\r\n\x06\x04\x07\x03\0\x02\0\x12\x03W\
    \x10+\n\x0e\n\x07\x04\x07\x03\0\x02\0\x04\x12\x03W\x10\x18\n\x0e\n\x07\
    \x04\x07\x03\0\x02\0\x05\x12\x03W\x19\x1e\n\x0e\n\x07\x04\x07\x03\0\x02\
    \0\x01\x12\x03W\x1f&\n\x0e\n\x07\x04\x07\x03\0\x02\0\x03\x12\x03W)*\n\r\
    \n\x06\x04\x07\x03\0\x02\x01\x12\x03X\x10/\n\x0e\n\x07\x04\x07\x03\0\x02\
    \x01\x04\x12\x03X\x10\x18\n\x0e\n\x07\x04\x07\x03\0\x02\x01\x05\x12\x03X\
    \x19\x1e\n\x0e\n\x07\x04\x07\x03\0\x02\x01\x01\x12\x03X\x1f*\n\x0e\n\x07\
    \x04\x07\x03\0\x02\x01\x03\x12\x03X-.\n\x0b\n\x04\x04\x07\x02\0\x12\x03[\
    \x08B\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\x07\
    \x02\0\x06\x12\x03[\x115\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03[6=\n\x0c\
    \n\x05\x04\x07\x02\0\x03\x12\x03[@A\n\x0b\n\x04\x04\x07\x02\x01\x12\x03\
    \\\x08%\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03\\\x08\x10\n\x0c\n\x05\
    \x04\x07\x02\x01\x05\x12\x03\\\x11\x18\n\x0c\n\x05\x04\x07\x02\x01\x01\
    \x12\x03\\\x19\x20\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03\\#$\n\x0b\n\
    \x04\x04\x07\x02\x02\x12\x03]\x08.\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\
    \x03]\x08\x10\n\x0c\n\x05\x04\x07\x02\x02\x06\x12\x03]\x11\x1e\n\x0c\n\
    \x05\x04\x07\x02\x02\x01\x12\x03]\x1f)\n\x0c\n\x05\x04\x07\x02\x02\x03\
    \x12\x03],-\n\x0b\n\x04\x04\x07\x02\x03\x12\x03^\x08'\n\x0c\n\x05\x04\
    \x07\x02\x03\x04\x12\x03^\x08\x10\n\x0c\n\x05\x04\x07\x02\x03\x05\x12\
    \x03^\x11\x17\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03^\x18\"\n\x0c\n\x05\
    \x04\x07\x02\x03\x03\x12\x03^%&\n\x0b\n\x04\x04\x07\x02\x04\x12\x03_\x08\
    )\n\x0c\n\x05\x04\x07\x02\x04\x04\x12\x03_\x08\x10\n\x0c\n\x05\x04\x07\
    \x02\x04\x05\x12\x03_\x11\x17\n\x0c\n\x05\x04\x07\x02\x04\x01\x12\x03_\
    \x18$\n\x0c\n\x05\x04\x07\x02\x04\x03\x12\x03_'(\n\x0b\n\x04\x04\x07\x02\
    \x05\x12\x03`\x08*\n\x0c\n\x05\x04\x07\x02\x05\x04\x12\x03`\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\x05\x05\x12\x03`\x11\x18\n\x0c\n\x05\x04\x07\x02\
    \x05\x01\x12\x03`\x19%\n\x0c\n\x05\x04\x07\x02\x05\x03\x12\x03`()\n\n\n\
    \x02\x04\x08\x12\x04c\0i\x01\n\n\n\x03\x04\x08\x01\x12\x03c\x08%\n\x0b\n\
    \x04\x04\x08\x02\0\x12\x03d\x08%\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03d\
    \x08\x10\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03d\x11\x18\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x03d\x19\x20\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03d#$\
    \n\x0b\n\x04\x04\x08\x02\x01\x12\x03e\x08.\n\x0c\n\x05\x04\x08\x02\x01\
    \x04\x12\x03e\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\x06\x12\x03e\x11\x1e\n\
    \x0c\n\x05\x04\x08\x02\x01\x01\x12\x03e\x1f)\n\x0c\n\x05\x04\x08\x02\x01\
    \x03\x12\x03e,-\n\x0b\n\x04\x04\x08\x02\x02\x12\x03f\x08'\n\x0c\n\x05\
    \x04\x08\x02\x02\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\x08\x02\x02\x05\
    \x12\x03f\x11\x17\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03f\x18\"\n\x0c\n\
    \x05\x04\x08\x02\x02\x03\x12\x03f%&\n\x0b\n\x04\x04\x08\x02\x03\x12\x03g\
    \x08)\n\x0c\n\x05\x04\x08\x02\x03\x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\
    \x08\x02\x03\x05\x12\x03g\x11\x17\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\
    \x03g\x18$\n\x0c\n\x05\x04\x08\x02\x03\x03\x12\x03g'(\n\x0b\n\x04\x04\
    \x08\x02\x04\x12\x03h\x08*\n\x0c\n\x05\x04\x08\x02\x04\x04\x12\x03h\x08\
    \x10\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\x03h\x11\x18\n\x0c\n\x05\x04\
    \x08\x02\x04\x01\x12\x03h\x19%\n\x0c\n\x05\x04\x08\x02\x04\x03\x12\x03h(\
    )\n\n\n\x02\x04\t\x12\x04k\0m\x01\n\n\n\x03\x04\t\x01\x12\x03k\x08\x1f\n\
    \x0b\n\x04\x04\t\x02\0\x12\x03l\x08.\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03\
    l\x08\x10\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03l\x11\x1e\n\x0c\n\x05\x04\t\
    \x02\0\x01\x12\x03l\x1f)\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03l,-\n\n\n\
    \x02\x04\n\x12\x04o\0u\x01\n\n\n\x03\x04\n\x01\x12\x03o\x08$\n\x0b\n\x04\
    \x04\n\x02\0\x12\x03p\x08%\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03p\x08\x10\
    \n\x0c\n\x05\x04\n\x02\0\x05\x12\x03p\x11\x18\n\x0c\n\x05\x04\n\x02\0\
    \x01\x12\x03p\x19\x20\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03p#$\n\x0b\n\x04\
    \x04\n\x02\x01\x12\x03q\x08.\n\x0c\n\x05\x04\n\x02\x01\x04\x12\x03q\x08\
    \x10\n\x0c\n\x05\x04\n\x02\x01\x06\x12\x03q\x11\x1e\n\x0c\n\x05\x04\n\
    \x02\x01\x01\x12\x03q\x1f)\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03q,-\n\
    \x0b\n\x04\x04\n\x02\x02\x12\x03r\x08'\n\x0c\n\x05\x04\n\x02\x02\x04\x12\
    \x03r\x08\x10\n\x0c\n\x05\x04\n\x02\x02\x05\x12\x03r\x11\x17\n\x0c\n\x05\
    \x04\n\x02\x02\x01\x12\x03r\x18\"\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03r\
    %&\n\x0b\n\x04\x04\n\x02\x03\x12\x03s\x08)\n\x0c\n\x05\x04\n\x02\x03\x04\
    \x12\x03s\x08\x10\n\x0c\n\x05\x04\n\x02\x03\x05\x12\x03s\x11\x17\n\x0c\n\
    \x05\x04\n\x02\x03\x01\x12\x03s\x18$\n\x0c\n\x05\x04\n\x02\x03\x03\x12\
    \x03s'(\n\x0b\n\x04\x04\n\x02\x04\x12\x03t\x08*\n\x0c\n\x05\x04\n\x02\
    \x04\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\n\x02\x04\x05\x12\x03t\x11\x18\
    \n\x0c\n\x05\x04\n\x02\x04\x01\x12\x03t\x19%\n\x0c\n\x05\x04\n\x02\x04\
    \x03\x12\x03t()\n\n\n\x02\x04\x0b\x12\x04w\0y\x01\n\n\n\x03\x04\x0b\x01\
    \x12\x03w\x08&\n\x0b\n\x04\x04\x0b\x02\0\x12\x03x\x08.\n\x0c\n\x05\x04\
    \x0b\x02\0\x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\x0b\x02\0\x06\x12\x03x\
    \x11\x1e\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03x\x1f)\n\x0c\n\x05\x04\x0b\
    \x02\0\x03\x12\x03x,-\n\n\n\x02\x04\x0c\x12\x04{\0}\x01\n\n\n\x03\x04\
    \x0c\x01\x12\x03{\x08\x1a\n\x0b\n\x04\x04\x0c\x02\0\x12\x03|\x08%\n\x0c\
    \n\x05\x04\x0c\x02\0\x04\x12\x03|\x08\x10\n\x0c\n\x05\x04\x0c\x02\0\x05\
    \x12\x03|\x11\x18\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03|\x19\x20\n\x0c\n\
    \x05\x04\x0c\x02\0\x03\x12\x03|#$\n\x0b\n\x02\x04\r\x12\x05\x7f\0\x83\
    \x01\x01\n\n\n\x03\x04\r\x01\x12\x03\x7f\x08\x1e\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\x80\x01\x08$\n\r\n\x05\x04\r\x02\0\x04\x12\x04\x80\x01\x08\x10\
    \n\r\n\x05\x04\r\x02\0\x05\x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\r\x02\0\
    \x01\x12\x04\x80\x01\x18\x1f\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x80\x01\"\
    #\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x81\x01\x08#\n\r\n\x05\x04\r\x02\x01\
    \x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x81\x01\
    \x11\x16\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x81\x01\x17\x1e\n\r\n\x05\
    \x04\r\x02\x01\x03\x12\x04\x81\x01!\"\n\x0c\n\x04\x04\r\x02\x02\x12\x04\
    \x82\x01\x08&\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\x82\x01\x08\x10\n\r\n\
    \x05\x04\r\x02\x02\x05\x12\x04\x82\x01\x11\x18\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\x82\x01\x19!\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\x82\x01$%\
    \n\x0c\n\x02\x04\x0e\x12\x06\x85\x01\0\x87\x01\x01\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\x85\x01\x08\x1f\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x86\x01\
    \x08%\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\x86\x01\x11\x16\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\x86\x01\x17\x20\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x86\x01#$\n\x0c\
    \n\x02\x04\x0f\x12\x06\x89\x01\0\x93\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\x89\x01\x08\x1b\n\x0e\n\x04\x04\x0f\x03\0\x12\x06\x8a\x01\x08\x8d\
    \x01\t\n\r\n\x05\x04\x0f\x03\0\x01\x12\x04\x8a\x01\x10\x17\n\x0e\n\x06\
    \x04\x0f\x03\0\x02\0\x12\x04\x8b\x01\x10-\n\x0f\n\x07\x04\x0f\x03\0\x02\
    \0\x04\x12\x04\x8b\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x05\x12\
    \x04\x8b\x01\x19\x1e\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x01\x12\x04\x8b\x01\
    \x1f(\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x03\x12\x04\x8b\x01+,\n\x0e\n\x06\
    \x04\x0f\x03\0\x02\x01\x12\x04\x8c\x01\x103\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\x01\x04\x12\x04\x8c\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\
    \x05\x12\x04\x8c\x01\x19\x1f\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x01\x12\
    \x04\x8c\x01\x20.\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x03\x12\x04\x8c\x011\
    2\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x8f\x01\x08%\n\r\n\x05\x04\x0f\x02\0\
    \x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x8f\x01\
    \x11\x16\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x8f\x01\x17\x20\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\x8f\x01#$\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\
    \x90\x01\x08)\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\x90\x01\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x01\x05\x12\x04\x90\x01\x11\x17\n\r\n\x05\x04\x0f\x02\
    \x01\x01\x12\x04\x90\x01\x18$\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x90\
    \x01'(\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\x91\x01\x08)\n\r\n\x05\x04\
    \x0f\x02\x02\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x02\x05\
    \x12\x04\x91\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x91\x01\
    \x18$\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x91\x01'(\n\x0c\n\x04\x04\
    \x0f\x02\x03\x12\x04\x92\x01\x08;\n\r\n\x05\x04\x0f\x02\x03\x04\x12\x04\
    \x92\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x06\x12\x04\x92\x01\x11,\n\r\
    \n\x05\x04\x0f\x02\x03\x01\x12\x04\x92\x01-6\n\r\n\x05\x04\x0f\x02\x03\
    \x03\x12\x04\x92\x019:\n\x0c\n\x02\x04\x10\x12\x06\x95\x01\0\x97\x01\x01\
    \n\x0b\n\x03\x04\x10\x01\x12\x04\x95\x01\x08$\n\x0c\n\x04\x04\x10\x02\0\
    \x12\x04\x96\x01\x08#\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x96\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x96\x01\x11\x16\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\x96\x01\x17\x1e\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\x96\x01!\"\n\x0c\n\x02\x04\x11\x12\x06\x99\x01\0\x9b\x01\x01\n\x0b\
    \n\x03\x04\x11\x01\x12\x04\x99\x01\x08!\n\x0c\n\x04\x04\x11\x02\0\x12\
    \x04\x9a\x01\x08-\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\x9a\x01\x08\x10\n\
    \r\n\x05\x04\x11\x02\0\x05\x12\x04\x9a\x01\x11\x15\n\r\n\x05\x04\x11\x02\
    \0\x01\x12\x04\x9a\x01\x16(\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x9a\x01+\
    ,\n\x0c\n\x02\x04\x12\x12\x06\x9d\x01\0\x9f\x01\x01\n\x0b\n\x03\x04\x12\
    \x01\x12\x04\x9d\x01\x08)\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x9e\x01\x08#\
    \n\r\n\x05\x04\x12\x02\0\x04\x12\x04\x9e\x01\x08\x10\n\r\n\x05\x04\x12\
    \x02\0\x05\x12\x04\x9e\x01\x11\x16\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \x9e\x01\x17\x1e\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x9e\x01!\"\n\x0c\n\
    \x02\x04\x13\x12\x06\xa1\x01\0\xa8\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\
    \x04\xa1\x01\x08'\n\x0e\n\x04\x04\x13\x03\0\x12\x06\xa2\x01\x08\xa5\x01\
    \t\n\r\n\x05\x04\x13\x03\0\x01\x12\x04\xa2\x01\x10\x16\n\x0e\n\x06\x04\
    \x13\x03\0\x02\0\x12\x04\xa3\x01\x10-\n\x0f\n\x07\x04\x13\x03\0\x02\0\
    \x04\x12\x04\xa3\x01\x10\x18\n\x0f\n\x07\x04\x13\x03\0\x02\0\x05\x12\x04\
    \xa3\x01\x19\x1e\n\x0f\n\x07\x04\x13\x03\0\x02\0\x01\x12\x04\xa3\x01\x1f\
    (\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\x04\xa3\x01+,\n\x0e\n\x06\x04\
    \x13\x03\0\x02\x01\x12\x04\xa4\x01\x101\n\x0f\n\x07\x04\x13\x03\0\x02\
    \x01\x04\x12\x04\xa4\x01\x10\x18\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x05\
    \x12\x04\xa4\x01\x19\x1f\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x01\x12\x04\
    \xa4\x01\x20,\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x03\x12\x04\xa4\x01/0\n\
    \x0c\n\x04\x04\x13\x02\0\x12\x04\xa7\x01\x08D\n\r\n\x05\x04\x13\x02\0\
    \x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xa7\x01\
    \x117\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xa7\x018?\n\r\n\x05\x04\x13\
    \x02\0\x03\x12\x04\xa7\x01BC\n\x0c\n\x02\x04\x14\x12\x06\xaa\x01\0\xae\
    \x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xaa\x01\x08\x18\n\x0c\n\x04\x04\
    \x14\x02\0\x12\x04\xab\x01\x08%\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xab\
    \x01\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xab\x01\x11\x17\n\r\n\
    \x05\x04\x14\x02\0\x01\x12\x04\xab\x01\x18\x20\n\r\n\x05\x04\x14\x02\0\
    \x03\x12\x04\xab\x01#$\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xac\x01\x08'\
    \n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xac\x01\x08\x10\n\r\n\x05\x04\x14\
    \x02\x01\x05\x12\x04\xac\x01\x11\x18\n\r\n\x05\x04\x14\x02\x01\x01\x12\
    \x04\xac\x01\x19\"\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xac\x01%&\n\x0c\
    \n\x04\x04\x14\x02\x02\x12\x04\xad\x01\x08'\n\r\n\x05\x04\x14\x02\x02\
    \x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xad\
    \x01\x11\x16\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xad\x01\x17\"\n\r\n\
    \x05\x04\x14\x02\x02\x03\x12\x04\xad\x01%&\n\x0c\n\x02\x04\x15\x12\x06\
    \xb0\x01\0\xb3\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xb0\x01\x08\x1d\n\
    \x0c\n\x04\x04\x15\x02\0\x12\x04\xb1\x01\x08%\n\r\n\x05\x04\x15\x02\0\
    \x04\x12\x04\xb1\x01\x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xb1\x01\
    \x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xb1\x01\x18\x20\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\xb1\x01#$\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\
    \xb2\x01\x08'\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xb2\x01\x08\x10\n\r\
    \n\x05\x04\x15\x02\x01\x05\x12\x04\xb2\x01\x11\x16\n\r\n\x05\x04\x15\x02\
    \x01\x01\x12\x04\xb2\x01\x17\"\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xb2\
    \x01%&\n\x0c\n\x02\x04\x16\x12\x06\xb5\x01\0\xbd\x01\x01\n\x0b\n\x03\x04\
    \x16\x01\x12\x04\xb5\x01\x08$\n\x0e\n\x04\x04\x16\x03\0\x12\x06\xb6\x01\
    \x08\xba\x01\t\n\r\n\x05\x04\x16\x03\0\x01\x12\x04\xb6\x01\x10\x1a\n\x0e\
    \n\x06\x04\x16\x03\0\x02\0\x12\x04\xb7\x01\x10-\n\x0f\n\x07\x04\x16\x03\
    \0\x02\0\x04\x12\x04\xb7\x01\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\0\x05\
    \x12\x04\xb7\x01\x19\x20\n\x0f\n\x07\x04\x16\x03\0\x02\0\x01\x12\x04\xb7\
    \x01!(\n\x0f\n\x07\x04\x16\x03\0\x02\0\x03\x12\x04\xb7\x01+,\n\x0e\n\x06\
    \x04\x16\x03\0\x02\x01\x12\x04\xb8\x01\x10(\n\x0f\n\x07\x04\x16\x03\0\
    \x02\x01\x04\x12\x04\xb8\x01\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\x01\
    \x05\x12\x04\xb8\x01\x19\x20\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x01\x12\
    \x04\xb8\x01!#\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x03\x12\x04\xb8\x01&'\n\
    \x0e\n\x06\x04\x16\x03\0\x02\x02\x12\x04\xb9\x01\x10*\n\x0f\n\x07\x04\
    \x16\x03\0\x02\x02\x04\x12\x04\xb9\x01\x10\x18\n\x0f\n\x07\x04\x16\x03\0\
    \x02\x02\x05\x12\x04\xb9\x01\x19\x1d\n\x0f\n\x07\x04\x16\x03\0\x02\x02\
    \x01\x12\x04\xb9\x01\x1e%\n\x0f\n\x07\x04\x16\x03\0\x02\x02\x03\x12\x04\
    \xb9\x01()\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xbc\x01\x08E\n\r\n\x05\x04\
    \x16\x02\0\x04\x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\x06\x12\
    \x04\xbc\x01\x118\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xbc\x019@\n\r\n\
    \x05\x04\x16\x02\0\x03\x12\x04\xbc\x01CD\n\x0c\n\x02\x04\x17\x12\x06\xbf\
    \x01\0\xc1\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xbf\x01\x08%\n\x0c\n\
    \x04\x04\x17\x02\0\x12\x04\xc0\x01\x08%\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xc0\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xc0\x01\x11\x18\
    \n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xc0\x01\x19\x20\n\r\n\x05\x04\x17\
    \x02\0\x03\x12\x04\xc0\x01#$\n\x0c\n\x02\x04\x18\x12\x06\xc3\x01\0\xc8\
    \x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xc3\x01\x08-\n\x0c\n\x04\x04\
    \x18\x02\0\x12\x04\xc4\x01\x08\x20\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\
    \xc4\x01\x08\x10\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xc4\x01\x11\x18\n\r\
    \n\x05\x04\x18\x02\0\x01\x12\x04\xc4\x01\x19\x1b\n\r\n\x05\x04\x18\x02\0\
    \x03\x12\x04\xc4\x01\x1e\x1f\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xc5\x01\
    \x08\"\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xc5\x01\x08\x10\n\r\n\x05\
    \x04\x18\x02\x01\x05\x12\x04\xc5\x01\x11\x15\n\r\n\x05\x04\x18\x02\x01\
    \x01\x12\x04\xc5\x01\x16\x1d\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xc5\
    \x01\x20!\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xc6\x01\x08!\n\r\n\x05\x04\
    \x18\x02\x02\x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\x18\x02\x02\x05\
    \x12\x04\xc6\x01\x11\x17\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xc6\x01\
    \x18\x1c\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xc6\x01\x1f\x20\n\x0c\n\
    \x04\x04\x18\x02\x03\x12\x04\xc7\x01\x08\"\n\r\n\x05\x04\x18\x02\x03\x04\
    \x12\x04\xc7\x01\x08\x10\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xc7\x01\
    \x11\x15\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xc7\x01\x16\x1d\n\r\n\x05\
    \x04\x18\x02\x03\x03\x12\x04\xc7\x01\x20!\n\x0c\n\x02\x04\x19\x12\x06\
    \xca\x01\0\xcf\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xca\x01\x08\x1e\n\
    \x0c\n\x04\x04\x19\x02\0\x12\x04\xcb\x01\x08(\n\r\n\x05\x04\x19\x02\0\
    \x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xcb\x01\
    \x11\x1e\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xcb\x01\x1f#\n\r\n\x05\x04\
    \x19\x02\0\x03\x12\x04\xcb\x01&'\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xcc\
    \x01\x08%\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xcc\x01\x08\x10\n\r\n\
    \x05\x04\x19\x02\x01\x05\x12\x04\xcc\x01\x11\x18\n\r\n\x05\x04\x19\x02\
    \x01\x01\x12\x04\xcc\x01\x19\x20\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\
    \xcc\x01#$\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xcd\x01\x08'\n\r\n\x05\
    \x04\x19\x02\x02\x04\x12\x04\xcd\x01\x08\x10\n\r\n\x05\x04\x19\x02\x02\
    \x05\x12\x04\xcd\x01\x11\x17\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xcd\
    \x01\x18\"\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xcd\x01%&\n\x0c\n\x04\
    \x04\x19\x02\x03\x12\x04\xce\x01\x080\n\r\n\x05\x04\x19\x02\x03\x04\x12\
    \x04\xce\x01\x08\x10\n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\xce\x01\x11\
    \x17\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\xce\x01\x18+\n\r\n\x05\x04\
    \x19\x02\x03\x03\x12\x04\xce\x01./\n\x0c\n\x02\x04\x1a\x12\x06\xd1\x01\0\
    \xe9\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xd1\x01\x08\x17\n\x0c\n\x04\
    \x04\x1a\x02\0\x12\x04\xd2\x01\x08$\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\
    \xd2\x01\x08\x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xd2\x01\x11\x17\n\r\
    \n\x05\x04\x1a\x02\0\x01\x12\x04\xd2\x01\x18\x1f\n\r\n\x05\x04\x1a\x02\0\
    \x03\x12\x04\xd2\x01\"#\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xd3\x01\x08B\
    \n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xd3\x01\x08\x10\n\r\n\x05\x04\x1a\
    \x02\x01\x06\x12\x04\xd3\x01\x11'\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\
    \xd3\x01(=\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xd3\x01@A\n\x0c\n\x04\
    \x04\x1a\x02\x02\x12\x04\xd4\x01\x080\n\r\n\x05\x04\x1a\x02\x02\x04\x12\
    \x04\xd4\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xd4\x01\x11\
    \x17\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xd4\x01\x18+\n\r\n\x05\x04\
    \x1a\x02\x02\x03\x12\x04\xd4\x01./\n\x0c\n\x04\x04\x1a\x02\x03\x12\x04\
    \xd5\x01\x088\n\r\n\x05\x04\x1a\x02\x03\x04\x12\x04\xd5\x01\x08\x10\n\r\
    \n\x05\x04\x1a\x02\x03\x06\x12\x04\xd5\x01\x11#\n\r\n\x05\x04\x1a\x02\
    \x03\x01\x12\x04\xd5\x01$3\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xd5\x01\
    67\n\x0c\n\x04\x04\x1a\x02\x04\x12\x04\xd6\x01\x08'\n\r\n\x05\x04\x1a\
    \x02\x04\x04\x12\x04\xd6\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x04\x05\x12\
    \x04\xd6\x01\x11\x17\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\xd6\x01\x18\"\
    \n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\xd6\x01%&\n\x0c\n\x04\x04\x1a\x02\
    \x05\x12\x04\xd7\x01\x08,\n\r\n\x05\x04\x1a\x02\x05\x04\x12\x04\xd7\x01\
    \x08\x10\n\r\n\x05\x04\x1a\x02\x05\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\
    \x04\x1a\x02\x05\x01\x12\x04\xd7\x01\x18'\n\r\n\x05\x04\x1a\x02\x05\x03\
    \x12\x04\xd7\x01*+\n\x0c\n\x04\x04\x1a\x02\x06\x12\x04\xd8\x01\x08*\n\r\
    \n\x05\x04\x1a\x02\x06\x04\x12\x04\xd8\x01\x08\x10\n\r\n\x05\x04\x1a\x02\
    \x06\x06\x12\x04\xd8\x01\x11\x1e\n\r\n\x05\x04\x1a\x02\x06\x01\x12\x04\
    \xd8\x01\x1f%\n\r\n\x05\x04\x1a\x02\x06\x03\x12\x04\xd8\x01()\n\x0c\n\
    \x04\x04\x1a\x02\x07\x12\x04\xd9\x01\x08/\n\r\n\x05\x04\x1a\x02\x07\x04\
    \x12\x04\xd9\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x07\x05\x12\x04\xd9\x01\
    \x11\x16\n\r\n\x05\x04\x1a\x02\x07\x01\x12\x04\xd9\x01\x17*\n\r\n\x05\
    \x04\x1a\x02\x07\x03\x12\x04\xd9\x01-.\n\x0c\n\x04\x04\x1a\x02\x08\x12\
    \x04\xda\x01\x08(\n\r\n\x05\x04\x1a\x02\x08\x04\x12\x04\xda\x01\x08\x10\
    \n\r\n\x05\x04\x1a\x02\x08\x05\x12\x04\xda\x01\x11\x17\n\r\n\x05\x04\x1a\
    \x02\x08\x01\x12\x04\xda\x01\x18#\n\r\n\x05\x04\x1a\x02\x08\x03\x12\x04\
    \xda\x01&'\n\x0c\n\x04\x04\x1a\x02\t\x12\x04\xdb\x01\x08%\n\r\n\x05\x04\
    \x1a\x02\t\x04\x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x1a\x02\t\x05\x12\
    \x04\xdb\x01\x11\x16\n\r\n\x05\x04\x1a\x02\t\x01\x12\x04\xdb\x01\x17\x1f\
    \n\r\n\x05\x04\x1a\x02\t\x03\x12\x04\xdb\x01\"$\n\x0c\n\x04\x04\x1a\x02\
    \n\x12\x04\xdc\x01\x08$\n\r\n\x05\x04\x1a\x02\n\x04\x12\x04\xdc\x01\x08\
    \x10\n\r\n\x05\x04\x1a\x02\n\x05\x12\x04\xdc\x01\x11\x16\n\r\n\x05\x04\
    \x1a\x02\n\x01\x12\x04\xdc\x01\x17\x1e\n\r\n\x05\x04\x1a\x02\n\x03\x12\
    \x04\xdc\x01!#\n\x0c\n\x04\x04\x1a\x02\x0b\x12\x04\xdd\x01\x08+\n\r\n\
    \x05\x04\x1a\x02\x0b\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\x04\x1a\x02\
    \x0b\x05\x12\x04\xdd\x01\x11\x17\n\r\n\x05\x04\x1a\x02\x0b\x01\x12\x04\
    \xdd\x01\x18%\n\r\n\x05\x04\x1a\x02\x0b\x03\x12\x04\xdd\x01(*\n\x0c\n\
    \x04\x04\x1a\x02\x0c\x12\x04\xde\x01\x08/\n\r\n\x05\x04\x1a\x02\x0c\x04\
    \x12\x04\xde\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x0c\x05\x12\x04\xde\x01\
    \x11\x17\n\r\n\x05\x04\x1a\x02\x0c\x01\x12\x04\xde\x01\x18)\n\r\n\x05\
    \x04\x1a\x02\x0c\x03\x12\x04\xde\x01,.\n\x0c\n\x04\x04\x1a\x02\r\x12\x04\
    \xdf\x01\x08*\n\r\n\x05\x04\x1a\x02\r\x04\x12\x04\xdf\x01\x08\x10\n\r\n\
    \x05\x04\x1a\x02\r\x05\x12\x04\xdf\x01\x11\x17\n\r\n\x05\x04\x1a\x02\r\
    \x01\x12\x04\xdf\x01\x18$\n\r\n\x05\x04\x1a\x02\r\x03\x12\x04\xdf\x01')\
    \n\x0c\n\x04\x04\x1a\x02\x0e\x12\x04\xe0\x01\x08+\n\r\n\x05\x04\x1a\x02\
    \x0e\x04\x12\x04\xe0\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x0e\x05\x12\x04\
    \xe0\x01\x11\x17\n\r\n\x05\x04\x1a\x02\x0e\x01\x12\x04\xe0\x01\x18%\n\r\
    \n\x05\x04\x1a\x02\x0e\x03\x12\x04\xe0\x01(*\n\x0c\n\x04\x04\x1a\x02\x0f\
    \x12\x04\xe1\x01\x08,\n\r\n\x05\x04\x1a\x02\x0f\x04\x12\x04\xe1\x01\x08\
    \x10\n\r\n\x05\x04\x1a\x02\x0f\x05\x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\
    \x1a\x02\x0f\x01\x12\x04\xe1\x01\x18&\n\r\n\x05\x04\x1a\x02\x0f\x03\x12\
    \x04\xe1\x01)+\n\x0c\n\x04\x04\x1a\x02\x10\x12\x04\xe2\x01\x08*\n\r\n\
    \x05\x04\x1a\x02\x10\x04\x12\x04\xe2\x01\x08\x10\n\r\n\x05\x04\x1a\x02\
    \x10\x05\x12\x04\xe2\x01\x11\x17\n\r\n\x05\x04\x1a\x02\x10\x01\x12\x04\
    \xe2\x01\x18$\n\r\n\x05\x04\x1a\x02\x10\x03\x12\x04\xe2\x01')\n\x0c\n\
    \x04\x04\x1a\x02\x11\x12\x04\xe3\x01\x08+\n\r\n\x05\x04\x1a\x02\x11\x04\
    \x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x11\x05\x12\x04\xe3\x01\
    \x11\x17\n\r\n\x05\x04\x1a\x02\x11\x01\x12\x04\xe3\x01\x18%\n\r\n\x05\
    \x04\x1a\x02\x11\x03\x12\x04\xe3\x01(*\n\x0c\n\x04\x04\x1a\x02\x12\x12\
    \x04\xe4\x01\x08(\n\r\n\x05\x04\x1a\x02\x12\x04\x12\x04\xe4\x01\x08\x10\
    \n\r\n\x05\x04\x1a\x02\x12\x05\x12\x04\xe4\x01\x11\x17\n\r\n\x05\x04\x1a\
    \x02\x12\x01\x12\x04\xe4\x01\x18\"\n\r\n\x05\x04\x1a\x02\x12\x03\x12\x04\
    \xe4\x01%'\n\x0c\n\x04\x04\x1a\x02\x13\x12\x04\xe5\x01\x08)\n\r\n\x05\
    \x04\x1a\x02\x13\x04\x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x13\
    \x05\x12\x04\xe5\x01\x11\x17\n\r\n\x05\x04\x1a\x02\x13\x01\x12\x04\xe5\
    \x01\x18#\n\r\n\x05\x04\x1a\x02\x13\x03\x12\x04\xe5\x01&(\n\x0c\n\x04\
    \x04\x1a\x02\x14\x12\x04\xe6\x01\x08*\n\r\n\x05\x04\x1a\x02\x14\x04\x12\
    \x04\xe6\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x14\x05\x12\x04\xe6\x01\x11\
    \x15\n\r\n\x05\x04\x1a\x02\x14\x01\x12\x04\xe6\x01\x16$\n\r\n\x05\x04\
    \x1a\x02\x14\x03\x12\x04\xe6\x01')\n\x0c\n\x04\x04\x1a\x02\x15\x12\x04\
    \xe7\x01\x081\n\r\n\x05\x04\x1a\x02\x15\x04\x12\x04\xe7\x01\x08\x10\n\r\
    \n\x05\x04\x1a\x02\x15\x05\x12\x04\xe7\x01\x11\x15\n\r\n\x05\x04\x1a\x02\
    \x15\x01\x12\x04\xe7\x01\x16+\n\r\n\x05\x04\x1a\x02\x15\x03\x12\x04\xe7\
    \x01.0\n\x0c\n\x04\x04\x1a\x02\x16\x12\x04\xe8\x01\x08+\n\r\n\x05\x04\
    \x1a\x02\x16\x04\x12\x04\xe8\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x16\x05\
    \x12\x04\xe8\x01\x11\x17\n\r\n\x05\x04\x1a\x02\x16\x01\x12\x04\xe8\x01\
    \x18%\n\r\n\x05\x04\x1a\x02\x16\x03\x12\x04\xe8\x01(*\n\x0c\n\x02\x04\
    \x1b\x12\x06\xeb\x01\0\x83\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xeb\
    \x01\x08\x19\n\x0e\n\x04\x04\x1b\x03\0\x12\x06\xec\x01\x08\xf0\x01\t\n\r\
    \n\x05\x04\x1b\x03\0\x01\x12\x04\xec\x01\x10\x18\n\x0e\n\x06\x04\x1b\x03\
    \0\x02\0\x12\x04\xed\x01\x10,\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x04\x12\
    \x04\xed\x01\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x05\x12\x04\xed\x01\
    \x19\x1e\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x01\x12\x04\xed\x01\x1f'\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\0\x03\x12\x04\xed\x01*+\n\x0e\n\x06\x04\x1b\x03\
    \0\x02\x01\x12\x04\xee\x01\x10-\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x04\
    \x12\x04\xee\x01\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x05\x12\x04\
    \xee\x01\x19\x1e\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x01\x12\x04\xee\x01\
    \x1f(\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x03\x12\x04\xee\x01+,\n\x0e\n\
    \x06\x04\x1b\x03\0\x02\x02\x12\x04\xef\x01\x10,\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\x02\x04\x12\x04\xef\x01\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\
    \x05\x12\x04\xef\x01\x19\x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x01\x12\
    \x04\xef\x01\x20'\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x03\x12\x04\xef\x01*\
    +\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xf2\x01\x08$\n\r\n\x05\x04\x1b\x02\0\
    \x04\x12\x04\xf2\x01\x08\x10\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xf2\x01\
    \x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xf2\x01\x18\x1f\n\r\n\x05\
    \x04\x1b\x02\0\x03\x12\x04\xf2\x01\"#\n\x0c\n\x04\x04\x1b\x02\x01\x12\
    \x04\xf3\x01\x08%\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\xf3\x01\x08\x10\
    \n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xf3\x01\x11\x16\n\r\n\x05\x04\x1b\
    \x02\x01\x01\x12\x04\xf3\x01\x17\x20\n\r\n\x05\x04\x1b\x02\x01\x03\x12\
    \x04\xf3\x01#$\n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\xf4\x01\x08G\n\r\n\
    \x05\x04\x1b\x02\x02\x04\x12\x04\xf4\x01\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x02\x06\x12\x04\xf4\x01\x11&\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xf4\
    \x01'B\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xf4\x01EF\n\x0c\n\x04\x04\
    \x1b\x02\x03\x12\x04\xf5\x01\x08M\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\
    \xf5\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x03\x06\x12\x04\xf5\x01\x11-\n\r\
    \n\x05\x04\x1b\x02\x03\x01\x12\x04\xf5\x01.H\n\r\n\x05\x04\x1b\x02\x03\
    \x03\x12\x04\xf5\x01KL\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xf6\x01\x089\
    \n\r\n\x05\x04\x1b\x02\x04\x04\x12\x04\xf6\x01\x08\x10\n\r\n\x05\x04\x1b\
    \x02\x04\x06\x12\x04\xf6\x01\x11+\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\
    \xf6\x01,4\n\r\n\x05\x04\x1b\x02\x04\x03\x12\x04\xf6\x0178\n\x0c\n\x04\
    \x04\x1b\x02\x05\x12\x04\xf7\x01\x08)\n\r\n\x05\x04\x1b\x02\x05\x04\x12\
    \x04\xf7\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x05\x05\x12\x04\xf7\x01\x11\
    \x16\n\r\n\x05\x04\x1b\x02\x05\x01\x12\x04\xf7\x01\x17$\n\r\n\x05\x04\
    \x1b\x02\x05\x03\x12\x04\xf7\x01'(\n\x0c\n\x04\x04\x1b\x02\x06\x12\x04\
    \xf8\x01\x084\n\r\n\x05\x04\x1b\x02\x06\x04\x12\x04\xf8\x01\x08\x10\n\r\
    \n\x05\x04\x1b\x02\x06\x05\x12\x04\xf8\x01\x11\x17\n\r\n\x05\x04\x1b\x02\
    \x06\x01\x12\x04\xf8\x01\x18/\n\r\n\x05\x04\x1b\x02\x06\x03\x12\x04\xf8\
    \x0123\n\x0c\n\x04\x04\x1b\x02\x07\x12\x04\xf9\x01\x08.\n\r\n\x05\x04\
    \x1b\x02\x07\x04\x12\x04\xf9\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x07\x05\
    \x12\x04\xf9\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x07\x01\x12\x04\xf9\x01\
    \x18(\n\r\n\x05\x04\x1b\x02\x07\x03\x12\x04\xf9\x01+-\n\x0c\n\x04\x04\
    \x1b\x02\x08\x12\x04\xfa\x01\x08'\n\r\n\x05\x04\x1b\x02\x08\x04\x12\x04\
    \xfa\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x08\x05\x12\x04\xfa\x01\x11\x16\n\
    \r\n\x05\x04\x1b\x02\x08\x01\x12\x04\xfa\x01\x17!\n\r\n\x05\x04\x1b\x02\
    \x08\x03\x12\x04\xfa\x01$&\n\x0c\n\x04\x04\x1b\x02\t\x12\x04\xfb\x01\x08\
    :\n\r\n\x05\x04\x1b\x02\t\x04\x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04\x1b\
    \x02\t\x05\x12\x04\xfb\x01\x11\x17\n\r\n\x05\x04\x1b\x02\t\x01\x12\x04\
    \xfb\x01\x184\n\r\n\x05\x04\x1b\x02\t\x03\x12\x04\xfb\x0179\n\x0c\n\x04\
    \x04\x1b\x02\n\x12\x04\xfc\x01\x08&\n\r\n\x05\x04\x1b\x02\n\x04\x12\x04\
    \xfc\x01\x08\x10\n\r\n\x05\x04\x1b\x02\n\x05\x12\x04\xfc\x01\x11\x17\n\r\
    \n\x05\x04\x1b\x02\n\x01\x12\x04\xfc\x01\x18\x20\n\r\n\x05\x04\x1b\x02\n\
    \x03\x12\x04\xfc\x01#%\n\x0c\n\x04\x04\x1b\x02\x0b\x12\x04\xfd\x01\x08%\
    \n\r\n\x05\x04\x1b\x02\x0b\x04\x12\x04\xfd\x01\x08\x10\n\r\n\x05\x04\x1b\
    \x02\x0b\x05\x12\x04\xfd\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x0b\x01\x12\
    \x04\xfd\x01\x18\x1f\n\r\n\x05\x04\x1b\x02\x0b\x03\x12\x04\xfd\x01\"$\n\
    \x0c\n\x04\x04\x1b\x02\x0c\x12\x04\xfe\x01\x08)\n\r\n\x05\x04\x1b\x02\
    \x0c\x04\x12\x04\xfe\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0c\x05\x12\x04\
    \xfe\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x0c\x01\x12\x04\xfe\x01\x18#\n\r\
    \n\x05\x04\x1b\x02\x0c\x03\x12\x04\xfe\x01&(\n\x0c\n\x04\x04\x1b\x02\r\
    \x12\x04\xff\x01\x082\n\r\n\x05\x04\x1b\x02\r\x04\x12\x04\xff\x01\x08\
    \x10\n\r\n\x05\x04\x1b\x02\r\x05\x12\x04\xff\x01\x11\x15\n\r\n\x05\x04\
    \x1b\x02\r\x01\x12\x04\xff\x01\x16,\n\r\n\x05\x04\x1b\x02\r\x03\x12\x04\
    \xff\x01/1\n\x0c\n\x04\x04\x1b\x02\x0e\x12\x04\x80\x02\x081\n\r\n\x05\
    \x04\x1b\x02\x0e\x04\x12\x04\x80\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x0e\
    \x05\x12\x04\x80\x02\x11\x15\n\r\n\x05\x04\x1b\x02\x0e\x01\x12\x04\x80\
    \x02\x16+\n\r\n\x05\x04\x1b\x02\x0e\x03\x12\x04\x80\x02.0\n\x0c\n\x04\
    \x04\x1b\x02\x0f\x12\x04\x81\x02\x08=\n\r\n\x05\x04\x1b\x02\x0f\x04\x12\
    \x04\x81\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x0f\x06\x12\x04\x81\x02\x11\
    \x1f\n\r\n\x05\x04\x1b\x02\x0f\x01\x12\x04\x81\x02\x207\n\r\n\x05\x04\
    \x1b\x02\x0f\x03\x12\x04\x81\x02:<\n\x0c\n\x04\x04\x1b\x02\x10\x12\x04\
    \x82\x02\x08C\n\r\n\x05\x04\x1b\x02\x10\x04\x12\x04\x82\x02\x08\x10\n\r\
    \n\x05\x04\x1b\x02\x10\x06\x12\x04\x82\x02\x11'\n\r\n\x05\x04\x1b\x02\
    \x10\x01\x12\x04\x82\x02(=\n\r\n\x05\x04\x1b\x02\x10\x03\x12\x04\x82\x02\
    @B\n\x0c\n\x02\x04\x1c\x12\x06\x85\x02\0\x8c\x02\x01\n\x0b\n\x03\x04\x1c\
    \x01\x12\x04\x85\x02\x08\x1c\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\x86\x02\
    \x08/\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\x86\x02\x08\x10\n\r\n\x05\x04\
    \x1c\x02\0\x06\x12\x04\x86\x02\x11#\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\
    \x86\x02$*\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\x86\x02-.\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\x87\x02\x080\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\
    \x87\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\x87\x02\x11\x17\n\
    \r\n\x05\x04\x1c\x02\x01\x01\x12\x04\x87\x02\x18+\n\r\n\x05\x04\x1c\x02\
    \x01\x03\x12\x04\x87\x02./\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\x88\x02\
    \x08*\n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\x88\x02\x08\x10\n\r\n\x05\
    \x04\x1c\x02\x02\x05\x12\x04\x88\x02\x11\x16\n\r\n\x05\x04\x1c\x02\x02\
    \x01\x12\x04\x88\x02\x17%\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\x88\x02(\
    )\n\x0c\n\x04\x04\x1c\x02\x03\x12\x04\x89\x02\x08&\n\r\n\x05\x04\x1c\x02\
    \x03\x04\x12\x04\x89\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\
    \x89\x02\x11\x16\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\x89\x02\x17!\n\r\
    \n\x05\x04\x1c\x02\x03\x03\x12\x04\x89\x02$%\n\x0c\n\x04\x04\x1c\x02\x04\
    \x12\x04\x8a\x02\x08(\n\r\n\x05\x04\x1c\x02\x04\x04\x12\x04\x8a\x02\x08\
    \x10\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\x8a\x02\x11\x16\n\r\n\x05\x04\
    \x1c\x02\x04\x01\x12\x04\x8a\x02\x17#\n\r\n\x05\x04\x1c\x02\x04\x03\x12\
    \x04\x8a\x02&'\n\x0c\n\x04\x04\x1c\x02\x05\x12\x04\x8b\x02\x08<\n\r\n\
    \x05\x04\x1c\x02\x05\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\x1c\x02\
    \x05\x05\x12\x04\x8b\x02\x11\x16\n\r\n\x05\x04\x1c\x02\x05\x01\x12\x04\
    \x8b\x02\x177\n\r\n\x05\x04\x1c\x02\x05\x03\x12\x04\x8b\x02:;\n\x0c\n\
    \x02\x04\x1d\x12\x06\x8e\x02\0\x99\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\
    \x04\x8e\x02\x08\"\n\x0e\n\x04\x04\x1d\x03\0\x12\x06\x8f\x02\x08\x92\x02\
    \t\n\r\n\x05\x04\x1d\x03\0\x01\x12\x04\x8f\x02\x10\x20\n\x0e\n\x06\x04\
    \x1d\x03\0\x02\0\x12\x04\x90\x02\x10/\n\x0f\n\x07\x04\x1d\x03\0\x02\0\
    \x04\x12\x04\x90\x02\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\x04\
    \x90\x02\x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x01\x12\x04\x90\x02\x20\
    *\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x03\x12\x04\x90\x02-.\n\x0e\n\x06\x04\
    \x1d\x03\0\x02\x01\x12\x04\x91\x02\x10,\n\x0f\n\x07\x04\x1d\x03\0\x02\
    \x01\x04\x12\x04\x91\x02\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x05\
    \x12\x04\x91\x02\x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x01\x12\x04\
    \x91\x02\x20'\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x03\x12\x04\x91\x02*+\n\
    \x0c\n\x04\x04\x1d\x02\0\x12\x04\x94\x02\x08(\n\r\n\x05\x04\x1d\x02\0\
    \x04\x12\x04\x94\x02\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\x94\x02\
    \x11\x18\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x94\x02\x19#\n\r\n\x05\x04\
    \x1d\x02\0\x03\x12\x04\x94\x02&'\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\x95\
    \x02\x08-\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\x95\x02\x08\x10\n\r\n\
    \x05\x04\x1d\x02\x01\x05\x12\x04\x95\x02\x11\x18\n\r\n\x05\x04\x1d\x02\
    \x01\x01\x12\x04\x95\x02\x19(\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\x95\
    \x02+,\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\x96\x02\x08*\n\r\n\x05\x04\
    \x1d\x02\x02\x04\x12\x04\x96\x02\x08\x10\n\r\n\x05\x04\x1d\x02\x02\x05\
    \x12\x04\x96\x02\x11\x18\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\x96\x02\
    \x19%\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\x96\x02()\n\x0c\n\x04\x04\
    \x1d\x02\x03\x12\x04\x97\x02\x08O\n\r\n\x05\x04\x1d\x02\x03\x04\x12\x04\
    \x97\x02\x08\x10\n\r\n\x05\x04\x1d\x02\x03\x06\x12\x04\x97\x02\x11<\n\r\
    \n\x05\x04\x1d\x02\x03\x01\x12\x04\x97\x02=J\n\r\n\x05\x04\x1d\x02\x03\
    \x03\x12\x04\x97\x02MN\n\x0c\n\x04\x04\x1d\x02\x04\x12\x04\x98\x02\x08.\
    \n\r\n\x05\x04\x1d\x02\x04\x04\x12\x04\x98\x02\x08\x10\n\r\n\x05\x04\x1d\
    \x02\x04\x05\x12\x04\x98\x02\x11\x17\n\r\n\x05\x04\x1d\x02\x04\x01\x12\
    \x04\x98\x02\x18)\n\r\n\x05\x04\x1d\x02\x04\x03\x12\x04\x98\x02,-\n\x0c\
    \n\x02\x04\x1e\x12\x06\x9b\x02\0\x9f\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\
    \x04\x9b\x02\x08$\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\x9c\x02\x08(\n\r\n\
    \x05\x04\x1e\x02\0\x04\x12\x04\x9c\x02\x08\x10\n\r\n\x05\x04\x1e\x02\0\
    \x05\x12\x04\x9c\x02\x11\x18\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x9c\x02\
    \x19#\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\x9c\x02&'\n\x0c\n\x04\x04\x1e\
    \x02\x01\x12\x04\x9d\x02\x081\n\r\n\x05\x04\x1e\x02\x01\x04\x12\x04\x9d\
    \x02\x08\x10\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\x9d\x02\x11\x18\n\r\n\
    \x05\x04\x1e\x02\x01\x01\x12\x04\x9d\x02\x19,\n\r\n\x05\x04\x1e\x02\x01\
    \x03\x12\x04\x9d\x02/0\n\x0c\n\x04\x04\x1e\x02\x02\x12\x04\x9e\x02\x082\
    \n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\x1e\
    \x02\x02\x05\x12\x04\x9e\x02\x11\x17\n\r\n\x05\x04\x1e\x02\x02\x01\x12\
    \x04\x9e\x02\x18-\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\x9e\x0201\n\x0c\
    \n\x02\x04\x1f\x12\x06\xa1\x02\0\xa2\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\
    \x04\xa1\x02\x08\x18\n\x0c\n\x02\x04\x20\x12\x06\xa4\x02\0\xa8\x02\x01\n\
    \x0b\n\x03\x04\x20\x01\x12\x04\xa4\x02\x08'\n\x0c\n\x04\x04\x20\x02\0\
    \x12\x04\xa5\x02\x08%\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\xa5\x02\x08\
    \x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xa5\x02\x11\x18\n\r\n\x05\x04\
    \x20\x02\0\x01\x12\x04\xa5\x02\x19\x20\n\r\n\x05\x04\x20\x02\0\x03\x12\
    \x04\xa5\x02#$\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\xa6\x02\x08M\n\r\n\
    \x05\x04\x20\x02\x01\x04\x12\x04\xa6\x02\x08\x10\n\r\n\x05\x04\x20\x02\
    \x01\x06\x12\x04\xa6\x02\x118\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xa6\
    \x029H\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xa6\x02KL\n\x0c\n\x04\x04\
    \x20\x02\x02\x12\x04\xa7\x02\x08(\n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\
    \xa7\x02\x08\x10\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\xa7\x02\x11\x17\n\
    \r\n\x05\x04\x20\x02\x02\x01\x12\x04\xa7\x02\x18#\n\r\n\x05\x04\x20\x02\
    \x02\x03\x12\x04\xa7\x02&'\n\x0c\n\x02\x04!\x12\x06\xaa\x02\0\xad\x02\
    \x01\n\x0b\n\x03\x04!\x01\x12\x04\xaa\x02\x08$\n\x0c\n\x04\x04!\x02\0\
    \x12\x04\xab\x02\x08'\n\r\n\x05\x04!\x02\0\x04\x12\x04\xab\x02\x08\x10\n\
    \r\n\x05\x04!\x02\0\x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04!\x02\0\x01\
    \x12\x04\xab\x02\x18\"\n\r\n\x05\x04!\x02\0\x03\x12\x04\xab\x02%&\n\x0c\
    \n\x04\x04!\x02\x01\x12\x04\xac\x02\x08M\n\r\n\x05\x04!\x02\x01\x04\x12\
    \x04\xac\x02\x08\x10\n\r\n\x05\x04!\x02\x01\x06\x12\x04\xac\x02\x110\n\r\
    \n\x05\x04!\x02\x01\x01\x12\x04\xac\x021H\n\r\n\x05\x04!\x02\x01\x03\x12\
    \x04\xac\x02KL\n\x0c\n\x02\x04\"\x12\x06\xaf\x02\0\xb0\x02\x01\n\x0b\n\
    \x03\x04\"\x01\x12\x04\xaf\x02\x08,\n\x0c\n\x02\x04#\x12\x06\xb2\x02\0\
    \xb6\x02\x01\n\x0b\n\x03\x04#\x01\x12\x04\xb2\x02\x08$\n\x0c\n\x04\x04#\
    \x02\0\x12\x04\xb3\x02\x08*\n\r\n\x05\x04#\x02\0\x04\x12\x04\xb3\x02\x08\
    \x10\n\r\n\x05\x04#\x02\0\x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\x04#\x02\
    \0\x01\x12\x04\xb3\x02\x18%\n\r\n\x05\x04#\x02\0\x03\x12\x04\xb3\x02()\n\
    \x0c\n\x04\x04#\x02\x01\x12\x04\xb4\x02\x08,\n\r\n\x05\x04#\x02\x01\x04\
    \x12\x04\xb4\x02\x08\x10\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xb4\x02\x11\
    \x17\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xb4\x02\x18'\n\r\n\x05\x04#\x02\
    \x01\x03\x12\x04\xb4\x02*+\n\x0c\n\x04\x04#\x02\x02\x12\x04\xb5\x02\x08)\
    \n\r\n\x05\x04#\x02\x02\x04\x12\x04\xb5\x02\x08\x10\n\r\n\x05\x04#\x02\
    \x02\x05\x12\x04\xb5\x02\x11\x15\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xb5\
    \x02\x16$\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xb5\x02'(\n\x0c\n\x02\x04$\
    \x12\x06\xb8\x02\0\xb9\x02\x01\n\x0b\n\x03\x04$\x01\x12\x04\xb8\x02\x08$\
    \n\x0c\n\x02\x04%\x12\x06\xbb\x02\0\xc8\x02\x01\n\x0b\n\x03\x04%\x01\x12\
    \x04\xbb\x02\x082\n\x0e\n\x04\x04%\x03\0\x12\x06\xbc\x02\x08\xbf\x02\t\n\
    \r\n\x05\x04%\x03\0\x01\x12\x04\xbc\x02\x10%\n\x0e\n\x06\x04%\x03\0\x02\
    \0\x12\x04\xbd\x02\x10/\n\x0f\n\x07\x04%\x03\0\x02\0\x04\x12\x04\xbd\x02\
    \x10\x18\n\x0f\n\x07\x04%\x03\0\x02\0\x05\x12\x04\xbd\x02\x19\x1f\n\x0f\
    \n\x07\x04%\x03\0\x02\0\x01\x12\x04\xbd\x02\x20*\n\x0f\n\x07\x04%\x03\0\
    \x02\0\x03\x12\x04\xbd\x02-.\n\x0e\n\x06\x04%\x03\0\x02\x01\x12\x04\xbe\
    \x02\x105\n\x0f\n\x07\x04%\x03\0\x02\x01\x04\x12\x04\xbe\x02\x10\x18\n\
    \x0f\n\x07\x04%\x03\0\x02\x01\x05\x12\x04\xbe\x02\x19\x1f\n\x0f\n\x07\
    \x04%\x03\0\x02\x01\x01\x12\x04\xbe\x02\x200\n\x0f\n\x07\x04%\x03\0\x02\
    \x01\x03\x12\x04\xbe\x0234\n\x0e\n\x04\x04%\x03\x01\x12\x06\xc1\x02\x08\
    \xc4\x02\t\n\r\n\x05\x04%\x03\x01\x01\x12\x04\xc1\x02\x10-\n\x0e\n\x06\
    \x04%\x03\x01\x02\0\x12\x04\xc2\x02\x10-\n\x0f\n\x07\x04%\x03\x01\x02\0\
    \x04\x12\x04\xc2\x02\x10\x18\n\x0f\n\x07\x04%\x03\x01\x02\0\x05\x12\x04\
    \xc2\x02\x19\x1f\n\x0f\n\x07\x04%\x03\x01\x02\0\x01\x12\x04\xc2\x02\x20(\
    \n\x0f\n\x07\x04%\x03\x01\x02\0\x03\x12\x04\xc2\x02+,\n\x0e\n\x06\x04%\
    \x03\x01\x02\x01\x12\x04\xc3\x02\x10k\n\x0f\n\x07\x04%\x03\x01\x02\x01\
    \x04\x12\x04\xc3\x02\x10\x18\n\x0f\n\x07\x04%\x03\x01\x02\x01\x06\x12\
    \x04\xc3\x02\x19Y\n\x0f\n\x07\x04%\x03\x01\x02\x01\x01\x12\x04\xc3\x02Zf\
    \n\x0f\n\x07\x04%\x03\x01\x02\x01\x03\x12\x04\xc3\x02ij\n\x0c\n\x04\x04%\
    \x02\0\x12\x04\xc6\x02\x08\"\n\r\n\x05\x04%\x02\0\x04\x12\x04\xc6\x02\
    \x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\xc6\x02\x11\x17\n\r\n\x05\x04%\
    \x02\0\x01\x12\x04\xc6\x02\x18\x1d\n\r\n\x05\x04%\x02\0\x03\x12\x04\xc6\
    \x02\x20!\n\x0c\n\x04\x04%\x02\x01\x12\x04\xc7\x02\x08h\n\r\n\x05\x04%\
    \x02\x01\x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04%\x02\x01\x06\x12\x04\
    \xc7\x02\x11Y\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xc7\x02Zc\n\r\n\x05\x04\
    %\x02\x01\x03\x12\x04\xc7\x02fg\n\x0c\n\x02\x04&\x12\x06\xca\x02\0\xcd\
    \x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\xca\x02\x08)\n\x0c\n\x04\x04&\x02\
    \0\x12\x04\xcb\x02\x08\"\n\r\n\x05\x04&\x02\0\x04\x12\x04\xcb\x02\x08\
    \x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\xcb\x02\x11\x17\n\r\n\x05\x04&\x02\
    \0\x01\x12\x04\xcb\x02\x18\x1d\n\r\n\x05\x04&\x02\0\x03\x12\x04\xcb\x02\
    \x20!\n\x0c\n\x04\x04&\x02\x01\x12\x04\xcc\x02\x08'\n\r\n\x05\x04&\x02\
    \x01\x04\x12\x04\xcc\x02\x08\x10\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xcc\
    \x02\x11\x17\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xcc\x02\x18\"\n\r\n\x05\
    \x04&\x02\x01\x03\x12\x04\xcc\x02%&\n\x0c\n\x02\x04'\x12\x06\xcf\x02\0\
    \xd1\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\xcf\x02\x08*\n\x0c\n\x04\x04'\
    \x02\0\x12\x04\xd0\x02\x08*\n\r\n\x05\x04'\x02\0\x04\x12\x04\xd0\x02\x08\
    \x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xd0\x02\x11\x18\n\r\n\x05\x04'\x02\
    \0\x01\x12\x04\xd0\x02\x19%\n\r\n\x05\x04'\x02\0\x03\x12\x04\xd0\x02()\n\
    \x0c\n\x02\x04(\x12\x06\xd3\x02\0\xed\x02\x01\n\x0b\n\x03\x04(\x01\x12\
    \x04\xd3\x02\x08-\n\x0e\n\x04\x04(\x03\0\x12\x06\xd4\x02\x08\xd9\x02\t\n\
    \r\n\x05\x04(\x03\0\x01\x12\x04\xd4\x02\x10'\n\x0e\n\x06\x04(\x03\0\x02\
    \0\x12\x04\xd5\x02\x105\n\x0f\n\x07\x04(\x03\0\x02\0\x04\x12\x04\xd5\x02\
    \x10\x18\n\x0f\n\x07\x04(\x03\0\x02\0\x05\x12\x04\xd5\x02\x19\x1f\n\x0f\
    \n\x07\x04(\x03\0\x02\0\x01\x12\x04\xd5\x02\x200\n\x0f\n\x07\x04(\x03\0\
    \x02\0\x03\x12\x04\xd5\x0234\n\x0e\n\x06\x04(\x03\0\x02\x01\x12\x04\xd6\
    \x02\x106\n\x0f\n\x07\x04(\x03\0\x02\x01\x04\x12\x04\xd6\x02\x10\x18\n\
    \x0f\n\x07\x04(\x03\0\x02\x01\x05\x12\x04\xd6\x02\x19\x1e\n\x0f\n\x07\
    \x04(\x03\0\x02\x01\x01\x12\x04\xd6\x02\x1f1\n\x0f\n\x07\x04(\x03\0\x02\
    \x01\x03\x12\x04\xd6\x0245\n\x0e\n\x06\x04(\x03\0\x02\x02\x12\x04\xd7\
    \x02\x105\n\x0f\n\x07\x04(\x03\0\x02\x02\x04\x12\x04\xd7\x02\x10\x18\n\
    \x0f\n\x07\x04(\x03\0\x02\x02\x05\x12\x04\xd7\x02\x19\x1f\n\x0f\n\x07\
    \x04(\x03\0\x02\x02\x01\x12\x04\xd7\x02\x200\n\x0f\n\x07\x04(\x03\0\x02\
    \x02\x03\x12\x04\xd7\x0234\n\x0e\n\x06\x04(\x03\0\x02\x03\x12\x04\xd8\
    \x02\x10.\n\x0f\n\x07\x04(\x03\0\x02\x03\x04\x12\x04\xd8\x02\x10\x18\n\
    \x0f\n\x07\x04(\x03\0\x02\x03\x05\x12\x04\xd8\x02\x19\x1f\n\x0f\n\x07\
    \x04(\x03\0\x02\x03\x01\x12\x04\xd8\x02\x20)\n\x0f\n\x07\x04(\x03\0\x02\
    \x03\x03\x12\x04\xd8\x02,-\n\x0e\n\x04\x04(\x03\x01\x12\x06\xdb\x02\x08\
    \xde\x02\t\n\r\n\x05\x04(\x03\x01\x01\x12\x04\xdb\x02\x10)\n\x0e\n\x06\
    \x04(\x03\x01\x02\0\x12\x04\xdc\x02\x105\n\x0f\n\x07\x04(\x03\x01\x02\0\
    \x04\x12\x04\xdc\x02\x10\x18\n\x0f\n\x07\x04(\x03\x01\x02\0\x05\x12\x04\
    \xdc\x02\x19\x1f\n\x0f\n\x07\x04(\x03\x01\x02\0\x01\x12\x04\xdc\x02\x200\
    \n\x0f\n\x07\x04(\x03\x01\x02\0\x03\x12\x04\xdc\x0234\n\x0e\n\x06\x04(\
    \x03\x01\x02\x01\x12\x04\xdd\x02\x105\n\x0f\n\x07\x04(\x03\x01\x02\x01\
    \x04\x12\x04\xdd\x02\x10\x18\n\x0f\n\x07\x04(\x03\x01\x02\x01\x05\x12\
    \x04\xdd\x02\x19\x1f\n\x0f\n\x07\x04(\x03\x01\x02\x01\x01\x12\x04\xdd\
    \x02\x200\n\x0f\n\x07\x04(\x03\x01\x02\x01\x03\x12\x04\xdd\x0234\n\x0e\n\
    \x04\x04(\x03\x02\x12\x06\xe0\x02\x08\xe4\x02\t\n\r\n\x05\x04(\x03\x02\
    \x01\x12\x04\xe0\x02\x10&\n\x0e\n\x06\x04(\x03\x02\x02\0\x12\x04\xe1\x02\
    \x10/\n\x0f\n\x07\x04(\x03\x02\x02\0\x04\x12\x04\xe1\x02\x10\x18\n\x0f\n\
    \x07\x04(\x03\x02\x02\0\x05\x12\x04\xe1\x02\x19\x1f\n\x0f\n\x07\x04(\x03\
    \x02\x02\0\x01\x12\x04\xe1\x02\x20*\n\x0f\n\x07\x04(\x03\x02\x02\0\x03\
    \x12\x04\xe1\x02-.\n\x0e\n\x06\x04(\x03\x02\x02\x01\x12\x04\xe2\x02\x106\
    \n\x0f\n\x07\x04(\x03\x02\x02\x01\x04\x12\x04\xe2\x02\x10\x18\n\x0f\n\
    \x07\x04(\x03\x02\x02\x01\x05\x12\x04\xe2\x02\x19\x1e\n\x0f\n\x07\x04(\
    \x03\x02\x02\x01\x01\x12\x04\xe2\x02\x1f1\n\x0f\n\x07\x04(\x03\x02\x02\
    \x01\x03\x12\x04\xe2\x0245\n\x0e\n\x06\x04(\x03\x02\x02\x02\x12\x04\xe3\
    \x02\x105\n\x0f\n\x07\x04(\x03\x02\x02\x02\x04\x12\x04\xe3\x02\x10\x18\n\
    \x0f\n\x07\x04(\x03\x02\x02\x02\x05\x12\x04\xe3\x02\x19\x1f\n\x0f\n\x07\
    \x04(\x03\x02\x02\x02\x01\x12\x04\xe3\x02\x200\n\x0f\n\x07\x04(\x03\x02\
    \x02\x02\x03\x12\x04\xe3\x0234\n\x0c\n\x04\x04(\x02\0\x12\x04\xe6\x02\
    \x08\"\n\r\n\x05\x04(\x02\0\x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04(\
    \x02\0\x05\x12\x04\xe6\x02\x11\x17\n\r\n\x05\x04(\x02\0\x01\x12\x04\xe6\
    \x02\x18\x1d\n\r\n\x05\x04(\x02\0\x03\x12\x04\xe6\x02\x20!\n\x0c\n\x04\
    \x04(\x02\x01\x12\x04\xe7\x02\x08'\n\r\n\x05\x04(\x02\x01\x04\x12\x04\
    \xe7\x02\x08\x10\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xe7\x02\x11\x17\n\r\
    \n\x05\x04(\x02\x01\x01\x12\x04\xe7\x02\x18\"\n\r\n\x05\x04(\x02\x01\x03\
    \x12\x04\xe7\x02%&\n\x0c\n\x04\x04(\x02\x02\x12\x04\xe8\x02\x08m\n\r\n\
    \x05\x04(\x02\x02\x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\x04(\x02\x02\x06\
    \x12\x04\xe8\x02\x11N\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xe8\x02Oh\n\r\n\
    \x05\x04(\x02\x02\x03\x12\x04\xe8\x02kl\n\x0c\n\x04\x04(\x02\x03\x12\x04\
    \xe9\x02\x08c\n\r\n\x05\x04(\x02\x03\x04\x12\x04\xe9\x02\x08\x10\n\r\n\
    \x05\x04(\x02\x03\x06\x12\x04\xe9\x02\x11M\n\r\n\x05\x04(\x02\x03\x01\
    \x12\x04\xe9\x02N^\n\r\n\x05\x04(\x02\x03\x03\x12\x04\xe9\x02ab\n\x0c\n\
    \x04\x04(\x02\x04\x12\x04\xea\x02\x08(\n\r\n\x05\x04(\x02\x04\x04\x12\
    \x04\xea\x02\x08\x10\n\r\n\x05\x04(\x02\x04\x05\x12\x04\xea\x02\x11\x15\
    \n\r\n\x05\x04(\x02\x04\x01\x12\x04\xea\x02\x16#\n\r\n\x05\x04(\x02\x04\
    \x03\x12\x04\xea\x02&'\n\x0c\n\x04\x04(\x02\x05\x12\x04\xeb\x02\x08;\n\r\
    \n\x05\x04(\x02\x05\x04\x12\x04\xeb\x02\x08\x10\n\r\n\x05\x04(\x02\x05\
    \x05\x12\x04\xeb\x02\x11\x15\n\r\n\x05\x04(\x02\x05\x01\x12\x04\xeb\x02\
    \x166\n\r\n\x05\x04(\x02\x05\x03\x12\x04\xeb\x029:\n\r\n\x04\x04(\x02\
    \x06\x12\x05\xec\x02\x08\x82\x01\n\r\n\x05\x04(\x02\x06\x04\x12\x04\xec\
    \x02\x08\x10\n\r\n\x05\x04(\x02\x06\x06\x12\x04\xec\x02\x11P\n\r\n\x05\
    \x04(\x02\x06\x01\x12\x04\xec\x02Q}\n\x0f\n\x05\x04(\x02\x06\x03\x12\x06\
    \xec\x02\x80\x01\x81\x01\n\x0c\n\x02\x04)\x12\x06\xef\x02\0\xf1\x02\x01\
    \n\x0b\n\x03\x04)\x01\x12\x04\xef\x02\x08.\n\x0c\n\x04\x04)\x02\0\x12\
    \x04\xf0\x02\x08.\n\r\n\x05\x04)\x02\0\x04\x12\x04\xf0\x02\x08\x10\n\r\n\
    \x05\x04)\x02\0\x05\x12\x04\xf0\x02\x11\x17\n\r\n\x05\x04)\x02\0\x01\x12\
    \x04\xf0\x02\x18)\n\r\n\x05\x04)\x02\0\x03\x12\x04\xf0\x02,-\n\x0c\n\x02\
    \x04*\x12\x06\xf3\x02\0\x80\x03\x01\n\x0b\n\x03\x04*\x01\x12\x04\xf3\x02\
    \x08'\n\x0c\n\x04\x04*\x02\0\x12\x04\xf4\x02\x08\x20\n\r\n\x05\x04*\x02\
    \0\x04\x12\x04\xf4\x02\x08\x10\n\r\n\x05\x04*\x02\0\x05\x12\x04\xf4\x02\
    \x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\xf4\x02\x18\x1b\n\r\n\x05\x04*\
    \x02\0\x03\x12\x04\xf4\x02\x1e\x1f\n\x0c\n\x04\x04*\x02\x01\x12\x04\xf5\
    \x02\x08#\n\r\n\x05\x04*\x02\x01\x04\x12\x04\xf5\x02\x08\x10\n\r\n\x05\
    \x04*\x02\x01\x05\x12\x04\xf5\x02\x11\x17\n\r\n\x05\x04*\x02\x01\x01\x12\
    \x04\xf5\x02\x18\x1e\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xf5\x02!\"\n\x0c\
    \n\x04\x04*\x02\x02\x12\x04\xf6\x02\x08%\n\r\n\x05\x04*\x02\x02\x04\x12\
    \x04\xf6\x02\x08\x10\n\r\n\x05\x04*\x02\x02\x05\x12\x04\xf6\x02\x11\x17\
    \n\r\n\x05\x04*\x02\x02\x01\x12\x04\xf6\x02\x18\x20\n\r\n\x05\x04*\x02\
    \x02\x03\x12\x04\xf6\x02#$\n\x0c\n\x04\x04*\x02\x03\x12\x04\xf7\x02\x08%\
    \n\r\n\x05\x04*\x02\x03\x04\x12\x04\xf7\x02\x08\x10\n\r\n\x05\x04*\x02\
    \x03\x05\x12\x04\xf7\x02\x11\x17\n\r\n\x05\x04*\x02\x03\x01\x12\x04\xf7\
    \x02\x18\x20\n\r\n\x05\x04*\x02\x03\x03\x12\x04\xf7\x02#$\n\x0c\n\x04\
    \x04*\x02\x04\x12\x04\xf8\x02\x08%\n\r\n\x05\x04*\x02\x04\x04\x12\x04\
    \xf8\x02\x08\x10\n\r\n\x05\x04*\x02\x04\x05\x12\x04\xf8\x02\x11\x17\n\r\
    \n\x05\x04*\x02\x04\x01\x12\x04\xf8\x02\x18\x20\n\r\n\x05\x04*\x02\x04\
    \x03\x12\x04\xf8\x02#$\n\x0c\n\x04\x04*\x02\x05\x12\x04\xf9\x02\x08'\n\r\
    \n\x05\x04*\x02\x05\x04\x12\x04\xf9\x02\x08\x10\n\r\n\x05\x04*\x02\x05\
    \x05\x12\x04\xf9\x02\x11\x17\n\r\n\x05\x04*\x02\x05\x01\x12\x04\xf9\x02\
    \x18\"\n\r\n\x05\x04*\x02\x05\x03\x12\x04\xf9\x02%&\n\x0c\n\x04\x04*\x02\
    \x06\x12\x04\xfa\x02\x08!\n\r\n\x05\x04*\x02\x06\x04\x12\x04\xfa\x02\x08\
    \x10\n\r\n\x05\x04*\x02\x06\x05\x12\x04\xfa\x02\x11\x17\n\r\n\x05\x04*\
    \x02\x06\x01\x12\x04\xfa\x02\x18\x1c\n\r\n\x05\x04*\x02\x06\x03\x12\x04\
    \xfa\x02\x1f\x20\n\x0c\n\x04\x04*\x02\x07\x12\x04\xfb\x02\x08(\n\r\n\x05\
    \x04*\x02\x07\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\x04*\x02\x07\x05\x12\
    \x04\xfb\x02\x11\x16\n\r\n\x05\x04*\x02\x07\x01\x12\x04\xfb\x02\x17#\n\r\
    \n\x05\x04*\x02\x07\x03\x12\x04\xfb\x02&'\n\x0c\n\x04\x04*\x02\x08\x12\
    \x04\xfc\x02\x08!\n\r\n\x05\x04*\x02\x08\x04\x12\x04\xfc\x02\x08\x10\n\r\
    \n\x05\x04*\x02\x08\x05\x12\x04\xfc\x02\x11\x17\n\r\n\x05\x04*\x02\x08\
    \x01\x12\x04\xfc\x02\x18\x1c\n\r\n\x05\x04*\x02\x08\x03\x12\x04\xfc\x02\
    \x1f\x20\n\x0c\n\x04\x04*\x02\t\x12\x04\xfd\x02\x08%\n\r\n\x05\x04*\x02\
    \t\x04\x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04*\x02\t\x05\x12\x04\xfd\x02\
    \x11\x16\n\r\n\x05\x04*\x02\t\x01\x12\x04\xfd\x02\x17\x1f\n\r\n\x05\x04*\
    \x02\t\x03\x12\x04\xfd\x02\"$\n\x0c\n\x04\x04*\x02\n\x12\x04\xfe\x02\x08\
    \"\n\r\n\x05\x04*\x02\n\x04\x12\x04\xfe\x02\x08\x10\n\r\n\x05\x04*\x02\n\
    \x05\x12\x04\xfe\x02\x11\x15\n\r\n\x05\x04*\x02\n\x01\x12\x04\xfe\x02\
    \x16\x1c\n\r\n\x05\x04*\x02\n\x03\x12\x04\xfe\x02\x1f!\n\x0c\n\x04\x04*\
    \x02\x0b\x12\x04\xff\x02\x08-\n\r\n\x05\x04*\x02\x0b\x04\x12\x04\xff\x02\
    \x08\x10\n\r\n\x05\x04*\x02\x0b\x05\x12\x04\xff\x02\x11\x18\n\r\n\x05\
    \x04*\x02\x0b\x01\x12\x04\xff\x02\x19'\n\r\n\x05\x04*\x02\x0b\x03\x12\
    \x04\xff\x02*,\n\x0c\n\x02\x04+\x12\x06\x82\x03\0\x90\x03\x01\n\x0b\n\
    \x03\x04+\x01\x12\x04\x82\x03\x08/\n\x0c\n\x04\x04+\x02\0\x12\x04\x83\
    \x03\x08$\n\r\n\x05\x04+\x02\0\x04\x12\x04\x83\x03\x08\x10\n\r\n\x05\x04\
    +\x02\0\x05\x12\x04\x83\x03\x11\x17\n\r\n\x05\x04+\x02\0\x01\x12\x04\x83\
    \x03\x18\x1f\n\r\n\x05\x04+\x02\0\x03\x12\x04\x83\x03\"#\n\x0c\n\x04\x04\
    +\x02\x01\x12\x04\x84\x03\x08#\n\r\n\x05\x04+\x02\x01\x04\x12\x04\x84\
    \x03\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\x84\x03\x11\x17\n\r\n\
    \x05\x04+\x02\x01\x01\x12\x04\x84\x03\x18\x1e\n\r\n\x05\x04+\x02\x01\x03\
    \x12\x04\x84\x03!\"\n\x0c\n\x04\x04+\x02\x02\x12\x04\x85\x03\x08\"\n\r\n\
    \x05\x04+\x02\x02\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04+\x02\x02\x05\
    \x12\x04\x85\x03\x11\x17\n\r\n\x05\x04+\x02\x02\x01\x12\x04\x85\x03\x18\
    \x1d\n\r\n\x05\x04+\x02\x02\x03\x12\x04\x85\x03\x20!\n\x0c\n\x04\x04+\
    \x02\x03\x12\x04\x86\x03\x08%\n\r\n\x05\x04+\x02\x03\x04\x12\x04\x86\x03\
    \x08\x10\n\r\n\x05\x04+\x02\x03\x05\x12\x04\x86\x03\x11\x17\n\r\n\x05\
    \x04+\x02\x03\x01\x12\x04\x86\x03\x18\x20\n\r\n\x05\x04+\x02\x03\x03\x12\
    \x04\x86\x03#$\n\x0c\n\x04\x04+\x02\x04\x12\x04\x87\x03\x08%\n\r\n\x05\
    \x04+\x02\x04\x04\x12\x04\x87\x03\x08\x10\n\r\n\x05\x04+\x02\x04\x05\x12\
    \x04\x87\x03\x11\x15\n\r\n\x05\x04+\x02\x04\x01\x12\x04\x87\x03\x16\x20\
    \n\r\n\x05\x04+\x02\x04\x03\x12\x04\x87\x03#$\n\x0c\n\x04\x04+\x02\x05\
    \x12\x04\x88\x03\x08*\n\r\n\x05\x04+\x02\x05\x04\x12\x04\x88\x03\x08\x10\
    \n\r\n\x05\x04+\x02\x05\x05\x12\x04\x88\x03\x11\x17\n\r\n\x05\x04+\x02\
    \x05\x01\x12\x04\x88\x03\x18%\n\r\n\x05\x04+\x02\x05\x03\x12\x04\x88\x03\
    ()\n\x0c\n\x04\x04+\x02\x06\x12\x04\x89\x03\x08*\n\r\n\x05\x04+\x02\x06\
    \x04\x12\x04\x89\x03\x08\x10\n\r\n\x05\x04+\x02\x06\x05\x12\x04\x89\x03\
    \x11\x15\n\r\n\x05\x04+\x02\x06\x01\x12\x04\x89\x03\x16%\n\r\n\x05\x04+\
    \x02\x06\x03\x12\x04\x89\x03()\n\x0c\n\x04\x04+\x02\x07\x12\x04\x8a\x03\
    \x080\n\r\n\x05\x04+\x02\x07\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04+\
    \x02\x07\x05\x12\x04\x8a\x03\x11\x17\n\r\n\x05\x04+\x02\x07\x01\x12\x04\
    \x8a\x03\x18+\n\r\n\x05\x04+\x02\x07\x03\x12\x04\x8a\x03./\n\x0c\n\x04\
    \x04+\x02\x08\x12\x04\x8b\x03\x08&\n\r\n\x05\x04+\x02\x08\x04\x12\x04\
    \x8b\x03\x08\x10\n\r\n\x05\x04+\x02\x08\x05\x12\x04\x8b\x03\x11\x15\n\r\
    \n\x05\x04+\x02\x08\x01\x12\x04\x8b\x03\x16!\n\r\n\x05\x04+\x02\x08\x03\
    \x12\x04\x8b\x03$%\n\x0c\n\x04\x04+\x02\t\x12\x04\x8c\x03\x08$\n\r\n\x05\
    \x04+\x02\t\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x04+\x02\t\x05\x12\x04\
    \x8c\x03\x11\x15\n\r\n\x05\x04+\x02\t\x01\x12\x04\x8c\x03\x16\x1e\n\r\n\
    \x05\x04+\x02\t\x03\x12\x04\x8c\x03!#\n\x0c\n\x04\x04+\x02\n\x12\x04\x8d\
    \x03\x08/\n\r\n\x05\x04+\x02\n\x04\x12\x04\x8d\x03\x08\x10\n\r\n\x05\x04\
    +\x02\n\x05\x12\x04\x8d\x03\x11\x17\n\r\n\x05\x04+\x02\n\x01\x12\x04\x8d\
    \x03\x18)\n\r\n\x05\x04+\x02\n\x03\x12\x04\x8d\x03,.\n\x0c\n\x04\x04+\
    \x02\x0b\x12\x04\x8e\x03\x08*\n\r\n\x05\x04+\x02\x0b\x04\x12\x04\x8e\x03\
    \x08\x10\n\r\n\x05\x04+\x02\x0b\x05\x12\x04\x8e\x03\x11\x15\n\r\n\x05\
    \x04+\x02\x0b\x01\x12\x04\x8e\x03\x16$\n\r\n\x05\x04+\x02\x0b\x03\x12\
    \x04\x8e\x03')\n\x0c\n\x04\x04+\x02\x0c\x12\x04\x8f\x03\x082\n\r\n\x05\
    \x04+\x02\x0c\x04\x12\x04\x8f\x03\x08\x10\n\r\n\x05\x04+\x02\x0c\x05\x12\
    \x04\x8f\x03\x11\x15\n\r\n\x05\x04+\x02\x0c\x01\x12\x04\x8f\x03\x16,\n\r\
    \n\x05\x04+\x02\x0c\x03\x12\x04\x8f\x03/1\n\x0c\n\x02\x04,\x12\x06\x92\
    \x03\0\x96\x03\x01\n\x0b\n\x03\x04,\x01\x12\x04\x92\x03\x080\n\x0c\n\x04\
    \x04,\x02\0\x12\x04\x93\x03\x08%\n\r\n\x05\x04,\x02\0\x04\x12\x04\x93\
    \x03\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\x93\x03\x11\x17\n\r\n\x05\
    \x04,\x02\0\x01\x12\x04\x93\x03\x18\x20\n\r\n\x05\x04,\x02\0\x03\x12\x04\
    \x93\x03#$\n\x0c\n\x04\x04,\x02\x01\x12\x04\x94\x03\x08%\n\r\n\x05\x04,\
    \x02\x01\x04\x12\x04\x94\x03\x08\x10\n\r\n\x05\x04,\x02\x01\x05\x12\x04\
    \x94\x03\x11\x15\n\r\n\x05\x04,\x02\x01\x01\x12\x04\x94\x03\x16\x20\n\r\
    \n\x05\x04,\x02\x01\x03\x12\x04\x94\x03#$\n\x0c\n\x04\x04,\x02\x02\x12\
    \x04\x95\x03\x08C\n\r\n\x05\x04,\x02\x02\x04\x12\x04\x95\x03\x08\x10\n\r\
    \n\x05\x04,\x02\x02\x06\x12\x04\x95\x03\x110\n\r\n\x05\x04,\x02\x02\x01\
    \x12\x04\x95\x031>\n\r\n\x05\x04,\x02\x02\x03\x12\x04\x95\x03AB\n\x0c\n\
    \x02\x04-\x12\x06\x98\x03\0\x9d\x03\x01\n\x0b\n\x03\x04-\x01\x12\x04\x98\
    \x03\x08,\n\x0c\n\x04\x04-\x02\0\x12\x04\x99\x03\x08\"\n\r\n\x05\x04-\
    \x02\0\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\x99\
    \x03\x11\x17\n\r\n\x05\x04-\x02\0\x01\x12\x04\x99\x03\x18\x1d\n\r\n\x05\
    \x04-\x02\0\x03\x12\x04\x99\x03\x20!\n\x0c\n\x04\x04-\x02\x01\x12\x04\
    \x9a\x03\x08%\n\r\n\x05\x04-\x02\x01\x04\x12\x04\x9a\x03\x08\x10\n\r\n\
    \x05\x04-\x02\x01\x05\x12\x04\x9a\x03\x11\x18\n\r\n\x05\x04-\x02\x01\x01\
    \x12\x04\x9a\x03\x19\x20\n\r\n\x05\x04-\x02\x01\x03\x12\x04\x9a\x03#$\n\
    \x0c\n\x04\x04-\x02\x02\x12\x04\x9b\x03\x08*\n\r\n\x05\x04-\x02\x02\x04\
    \x12\x04\x9b\x03\x08\x10\n\r\n\x05\x04-\x02\x02\x05\x12\x04\x9b\x03\x11\
    \x18\n\r\n\x05\x04-\x02\x02\x01\x12\x04\x9b\x03\x19%\n\r\n\x05\x04-\x02\
    \x02\x03\x12\x04\x9b\x03()\n\x0c\n\x04\x04-\x02\x03\x12\x04\x9c\x03\x08&\
    \n\r\n\x05\x04-\x02\x03\x04\x12\x04\x9c\x03\x08\x10\n\r\n\x05\x04-\x02\
    \x03\x05\x12\x04\x9c\x03\x11\x16\n\r\n\x05\x04-\x02\x03\x01\x12\x04\x9c\
    \x03\x17!\n\r\n\x05\x04-\x02\x03\x03\x12\x04\x9c\x03$%\n\x0c\n\x02\x04.\
    \x12\x06\x9f\x03\0\xb5\x03\x01\n\x0b\n\x03\x04.\x01\x12\x04\x9f\x03\x08\
    \x1d\n\x0e\n\x04\x04.\x03\0\x12\x06\xa0\x03\x08\xa4\x03\t\n\r\n\x05\x04.\
    \x03\0\x01\x12\x04\xa0\x03\x10\x19\n\x0e\n\x06\x04.\x03\0\x02\0\x12\x04\
    \xa1\x03\x10)\n\x0f\n\x07\x04.\x03\0\x02\0\x04\x12\x04\xa1\x03\x10\x18\n\
    \x0f\n\x07\x04.\x03\0\x02\0\x05\x12\x04\xa1\x03\x19\x1f\n\x0f\n\x07\x04.\
    \x03\0\x02\0\x01\x12\x04\xa1\x03\x20$\n\x0f\n\x07\x04.\x03\0\x02\0\x03\
    \x12\x04\xa1\x03'(\n\x0e\n\x06\x04.\x03\0\x02\x01\x12\x04\xa2\x03\x10+\n\
    \x0f\n\x07\x04.\x03\0\x02\x01\x04\x12\x04\xa2\x03\x10\x18\n\x0f\n\x07\
    \x04.\x03\0\x02\x01\x05\x12\x04\xa2\x03\x19\x1e\n\x0f\n\x07\x04.\x03\0\
    \x02\x01\x01\x12\x04\xa2\x03\x1f&\n\x0f\n\x07\x04.\x03\0\x02\x01\x03\x12\
    \x04\xa2\x03)*\n\x0e\n\x06\x04.\x03\0\x02\x02\x12\x04\xa3\x03\x10/\n\x0f\
    \n\x07\x04.\x03\0\x02\x02\x04\x12\x04\xa3\x03\x10\x18\n\x0f\n\x07\x04.\
    \x03\0\x02\x02\x05\x12\x04\xa3\x03\x19\x1f\n\x0f\n\x07\x04.\x03\0\x02\
    \x02\x01\x12\x04\xa3\x03\x20*\n\x0f\n\x07\x04.\x03\0\x02\x02\x03\x12\x04\
    \xa3\x03-.\n\x0e\n\x04\x04.\x03\x01\x12\x06\xa6\x03\x08\xb0\x03\t\n\r\n\
    \x05\x04.\x03\x01\x01\x12\x04\xa6\x03\x10\x15\n\x10\n\x06\x04.\x03\x01\
    \x03\0\x12\x06\xa7\x03\x10\xaa\x03\x11\n\x0f\n\x07\x04.\x03\x01\x03\0\
    \x01\x12\x04\xa7\x03\x18\x1f\n\x10\n\x08\x04.\x03\x01\x03\0\x02\0\x12\
    \x04\xa8\x03\x184\n\x11\n\t\x04.\x03\x01\x03\0\x02\0\x04\x12\x04\xa8\x03\
    \x18\x20\n\x11\n\t\x04.\x03\x01\x03\0\x02\0\x05\x12\x04\xa8\x03!'\n\x11\
    \n\t\x04.\x03\x01\x03\0\x02\0\x01\x12\x04\xa8\x03(/\n\x11\n\t\x04.\x03\
    \x01\x03\0\x02\0\x03\x12\x04\xa8\x0323\n\x10\n\x08\x04.\x03\x01\x03\0\
    \x02\x01\x12\x04\xa9\x03\x184\n\x11\n\t\x04.\x03\x01\x03\0\x02\x01\x04\
    \x12\x04\xa9\x03\x18\x20\n\x11\n\t\x04.\x03\x01\x03\0\x02\x01\x05\x12\
    \x04\xa9\x03!'\n\x11\n\t\x04.\x03\x01\x03\0\x02\x01\x01\x12\x04\xa9\x03(\
    /\n\x11\n\t\x04.\x03\x01\x03\0\x02\x01\x03\x12\x04\xa9\x0323\n\x0e\n\x06\
    \x04.\x03\x01\x02\0\x12\x04\xac\x03\x10)\n\x0f\n\x07\x04.\x03\x01\x02\0\
    \x04\x12\x04\xac\x03\x10\x18\n\x0f\n\x07\x04.\x03\x01\x02\0\x05\x12\x04\
    \xac\x03\x19\x1f\n\x0f\n\x07\x04.\x03\x01\x02\0\x01\x12\x04\xac\x03\x20$\
    \n\x0f\n\x07\x04.\x03\x01\x02\0\x03\x12\x04\xac\x03'(\n\x0e\n\x06\x04.\
    \x03\x01\x02\x01\x12\x04\xad\x03\x10'\n\x0f\n\x07\x04.\x03\x01\x02\x01\
    \x04\x12\x04\xad\x03\x10\x18\n\x0f\n\x07\x04.\x03\x01\x02\x01\x05\x12\
    \x04\xad\x03\x19\x1f\n\x0f\n\x07\x04.\x03\x01\x02\x01\x01\x12\x04\xad\
    \x03\x20\"\n\x0f\n\x07\x04.\x03\x01\x02\x01\x03\x12\x04\xad\x03%&\n\x0e\
    \n\x06\x04.\x03\x01\x02\x02\x12\x04\xae\x03\x10J\n\x0f\n\x07\x04.\x03\
    \x01\x02\x02\x04\x12\x04\xae\x03\x10\x18\n\x0f\n\x07\x04.\x03\x01\x02\
    \x02\x06\x12\x04\xae\x03\x19<\n\x0f\n\x07\x04.\x03\x01\x02\x02\x01\x12\
    \x04\xae\x03=E\n\x0f\n\x07\x04.\x03\x01\x02\x02\x03\x12\x04\xae\x03HI\n\
    \x0e\n\x06\x04.\x03\x01\x02\x03\x12\x04\xaf\x03\x10I\n\x0f\n\x07\x04.\
    \x03\x01\x02\x03\x04\x12\x04\xaf\x03\x10\x18\n\x0f\n\x07\x04.\x03\x01\
    \x02\x03\x06\x12\x04\xaf\x03\x198\n\x0f\n\x07\x04.\x03\x01\x02\x03\x01\
    \x12\x04\xaf\x039D\n\x0f\n\x07\x04.\x03\x01\x02\x03\x03\x12\x04\xaf\x03G\
    H\n\x0c\n\x04\x04.\x02\0\x12\x04\xb2\x03\x08)\n\r\n\x05\x04.\x02\0\x04\
    \x12\x04\xb2\x03\x08\x10\n\r\n\x05\x04.\x02\0\x05\x12\x04\xb2\x03\x11\
    \x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\xb2\x03\x18$\n\r\n\x05\x04.\x02\0\
    \x03\x12\x04\xb2\x03'(\n\x0c\n\x04\x04.\x02\x01\x12\x04\xb3\x03\x088\n\r\
    \n\x05\x04.\x02\x01\x04\x12\x04\xb3\x03\x08\x10\n\r\n\x05\x04.\x02\x01\
    \x06\x12\x04\xb3\x03\x11,\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xb3\x03-3\n\
    \r\n\x05\x04.\x02\x01\x03\x12\x04\xb3\x0367\n\x0c\n\x04\x04.\x02\x02\x12\
    \x04\xb4\x03\x084\n\r\n\x05\x04.\x02\x02\x04\x12\x04\xb4\x03\x08\x10\n\r\
    \n\x05\x04.\x02\x02\x05\x12\x04\xb4\x03\x11\x17\n\r\n\x05\x04.\x02\x02\
    \x01\x12\x04\xb4\x03\x18/\n\r\n\x05\x04.\x02\x02\x03\x12\x04\xb4\x0323\n\
    \x0c\n\x02\x04/\x12\x06\xb7\x03\0\xba\x03\x01\n\x0b\n\x03\x04/\x01\x12\
    \x04\xb7\x03\x08'\n\x0c\n\x04\x04/\x02\0\x12\x04\xb8\x03\x08(\n\r\n\x05\
    \x04/\x02\0\x04\x12\x04\xb8\x03\x08\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\
    \xb8\x03\x11\x17\n\r\n\x05\x04/\x02\0\x01\x12\x04\xb8\x03\x18#\n\r\n\x05\
    \x04/\x02\0\x03\x12\x04\xb8\x03&'\n\x0c\n\x04\x04/\x02\x01\x12\x04\xb9\
    \x03\x08$\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\
    \x04/\x02\x01\x05\x12\x04\xb9\x03\x11\x17\n\r\n\x05\x04/\x02\x01\x01\x12\
    \x04\xb9\x03\x18\x1f\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xb9\x03\"#\n\x0c\
    \n\x02\x040\x12\x06\xbc\x03\0\xbf\x03\x01\n\x0b\n\x03\x040\x01\x12\x04\
    \xbc\x03\x08(\n\x0c\n\x04\x040\x02\0\x12\x04\xbd\x03\x08$\n\r\n\x05\x040\
    \x02\0\x04\x12\x04\xbd\x03\x08\x10\n\r\n\x05\x040\x02\0\x05\x12\x04\xbd\
    \x03\x11\x17\n\r\n\x05\x040\x02\0\x01\x12\x04\xbd\x03\x18\x1f\n\r\n\x05\
    \x040\x02\0\x03\x12\x04\xbd\x03\"#\n\x0c\n\x04\x040\x02\x01\x12\x04\xbe\
    \x03\x08)\n\r\n\x05\x040\x02\x01\x04\x12\x04\xbe\x03\x08\x10\n\r\n\x05\
    \x040\x02\x01\x05\x12\x04\xbe\x03\x11\x17\n\r\n\x05\x040\x02\x01\x01\x12\
    \x04\xbe\x03\x18$\n\r\n\x05\x040\x02\x01\x03\x12\x04\xbe\x03'(\n\x0c\n\
    \x02\x041\x12\x06\xc1\x03\0\xc4\x03\x01\n\x0b\n\x03\x041\x01\x12\x04\xc1\
    \x03\x08#\n\x0c\n\x04\x041\x02\0\x12\x04\xc2\x03\x08#\n\r\n\x05\x041\x02\
    \0\x04\x12\x04\xc2\x03\x08\x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xc2\x03\
    \x11\x17\n\r\n\x05\x041\x02\0\x01\x12\x04\xc2\x03\x18\x1e\n\r\n\x05\x041\
    \x02\0\x03\x12\x04\xc2\x03!\"\n\x0c\n\x04\x041\x02\x01\x12\x04\xc3\x03\
    \x08*\n\r\n\x05\x041\x02\x01\x04\x12\x04\xc3\x03\x08\x10\n\r\n\x05\x041\
    \x02\x01\x05\x12\x04\xc3\x03\x11\x16\n\r\n\x05\x041\x02\x01\x01\x12\x04\
    \xc3\x03\x17%\n\r\n\x05\x041\x02\x01\x03\x12\x04\xc3\x03()\n\x0c\n\x02\
    \x042\x12\x06\xc6\x03\0\xcc\x03\x01\n\x0b\n\x03\x042\x01\x12\x04\xc6\x03\
    \x08(\n\x0c\n\x04\x042\x02\0\x12\x04\xc7\x03\x08-\n\r\n\x05\x042\x02\0\
    \x04\x12\x04\xc7\x03\x08\x10\n\r\n\x05\x042\x02\0\x05\x12\x04\xc7\x03\
    \x11\x17\n\r\n\x05\x042\x02\0\x01\x12\x04\xc7\x03\x18(\n\r\n\x05\x042\
    \x02\0\x03\x12\x04\xc7\x03+,\n\x0c\n\x04\x042\x02\x01\x12\x04\xc8\x03\
    \x08(\n\r\n\x05\x042\x02\x01\x04\x12\x04\xc8\x03\x08\x10\n\r\n\x05\x042\
    \x02\x01\x05\x12\x04\xc8\x03\x11\x15\n\r\n\x05\x042\x02\x01\x01\x12\x04\
    \xc8\x03\x16#\n\r\n\x05\x042\x02\x01\x03\x12\x04\xc8\x03&'\n\x0c\n\x04\
    \x042\x02\x02\x12\x04\xc9\x03\x08*\n\r\n\x05\x042\x02\x02\x04\x12\x04\
    \xc9\x03\x08\x10\n\r\n\x05\x042\x02\x02\x05\x12\x04\xc9\x03\x11\x15\n\r\
    \n\x05\x042\x02\x02\x01\x12\x04\xc9\x03\x16%\n\r\n\x05\x042\x02\x02\x03\
    \x12\x04\xc9\x03()\n\x0c\n\x04\x042\x02\x03\x12\x04\xca\x03\x08#\n\r\n\
    \x05\x042\x02\x03\x04\x12\x04\xca\x03\x08\x10\n\r\n\x05\x042\x02\x03\x05\
    \x12\x04\xca\x03\x11\x17\n\r\n\x05\x042\x02\x03\x01\x12\x04\xca\x03\x18\
    \x1e\n\r\n\x05\x042\x02\x03\x03\x12\x04\xca\x03!\"\n\x0c\n\x04\x042\x02\
    \x04\x12\x04\xcb\x03\x08$\n\r\n\x05\x042\x02\x04\x04\x12\x04\xcb\x03\x08\
    \x10\n\r\n\x05\x042\x02\x04\x05\x12\x04\xcb\x03\x11\x16\n\r\n\x05\x042\
    \x02\x04\x01\x12\x04\xcb\x03\x17\x1f\n\r\n\x05\x042\x02\x04\x03\x12\x04\
    \xcb\x03\"#\n\x0c\n\x02\x043\x12\x06\xce\x03\0\xd3\x03\x01\n\x0b\n\x03\
    \x043\x01\x12\x04\xce\x03\x08(\n\x0c\n\x04\x043\x02\0\x12\x04\xcf\x03\
    \x08&\n\r\n\x05\x043\x02\0\x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x043\
    \x02\0\x05\x12\x04\xcf\x03\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\xcf\
    \x03\x18!\n\r\n\x05\x043\x02\0\x03\x12\x04\xcf\x03$%\n\x0c\n\x04\x043\
    \x02\x01\x12\x04\xd0\x03\x08%\n\r\n\x05\x043\x02\x01\x04\x12\x04\xd0\x03\
    \x08\x10\n\r\n\x05\x043\x02\x01\x05\x12\x04\xd0\x03\x11\x18\n\r\n\x05\
    \x043\x02\x01\x01\x12\x04\xd0\x03\x19\x20\n\r\n\x05\x043\x02\x01\x03\x12\
    \x04\xd0\x03#$\n\x0c\n\x04\x043\x02\x02\x12\x04\xd1\x03\x08(\n\r\n\x05\
    \x043\x02\x02\x04\x12\x04\xd1\x03\x08\x10\n\r\n\x05\x043\x02\x02\x05\x12\
    \x04\xd1\x03\x11\x17\n\r\n\x05\x043\x02\x02\x01\x12\x04\xd1\x03\x18#\n\r\
    \n\x05\x043\x02\x02\x03\x12\x04\xd1\x03&'\n\x0c\n\x04\x043\x02\x03\x12\
    \x04\xd2\x03\x08'\n\r\n\x05\x043\x02\x03\x04\x12\x04\xd2\x03\x08\x10\n\r\
    \n\x05\x043\x02\x03\x05\x12\x04\xd2\x03\x11\x18\n\r\n\x05\x043\x02\x03\
    \x01\x12\x04\xd2\x03\x19\"\n\r\n\x05\x043\x02\x03\x03\x12\x04\xd2\x03%&\
    \n\x0c\n\x02\x044\x12\x06\xd5\x03\0\xd6\x03\x01\n\x0b\n\x03\x044\x01\x12\
    \x04\xd5\x03\x080\n\x0c\n\x02\x045\x12\x06\xd8\x03\0\xda\x03\x01\n\x0b\n\
    \x03\x045\x01\x12\x04\xd8\x03\x08-\n\x0c\n\x04\x045\x02\0\x12\x04\xd9\
    \x03\x08D\n\r\n\x05\x045\x02\0\x04\x12\x04\xd9\x03\x08\x10\n\r\n\x05\x04\
    5\x02\0\x06\x12\x04\xd9\x03\x111\n\r\n\x05\x045\x02\0\x01\x12\x04\xd9\
    \x032?\n\r\n\x05\x045\x02\0\x03\x12\x04\xd9\x03BC\n\x0c\n\x02\x046\x12\
    \x06\xdc\x03\0\xe1\x03\x01\n\x0b\n\x03\x046\x01\x12\x04\xdc\x03\x08,\n\
    \x0c\n\x04\x046\x02\0\x12\x04\xdd\x03\x08&\n\r\n\x05\x046\x02\0\x04\x12\
    \x04\xdd\x03\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\xdd\x03\x11\x17\n\
    \r\n\x05\x046\x02\0\x01\x12\x04\xdd\x03\x18!\n\r\n\x05\x046\x02\0\x03\
    \x12\x04\xdd\x03$%\n\x0c\n\x04\x046\x02\x01\x12\x04\xde\x03\x08%\n\r\n\
    \x05\x046\x02\x01\x04\x12\x04\xde\x03\x08\x10\n\r\n\x05\x046\x02\x01\x05\
    \x12\x04\xde\x03\x11\x18\n\r\n\x05\x046\x02\x01\x01\x12\x04\xde\x03\x19\
    \x20\n\r\n\x05\x046\x02\x01\x03\x12\x04\xde\x03#$\n\x0c\n\x04\x046\x02\
    \x02\x12\x04\xdf\x03\x08(\n\r\n\x05\x046\x02\x02\x04\x12\x04\xdf\x03\x08\
    \x10\n\r\n\x05\x046\x02\x02\x05\x12\x04\xdf\x03\x11\x17\n\r\n\x05\x046\
    \x02\x02\x01\x12\x04\xdf\x03\x18#\n\r\n\x05\x046\x02\x02\x03\x12\x04\xdf\
    \x03&'\n\x0c\n\x04\x046\x02\x03\x12\x04\xe0\x03\x08'\n\r\n\x05\x046\x02\
    \x03\x04\x12\x04\xe0\x03\x08\x10\n\r\n\x05\x046\x02\x03\x05\x12\x04\xe0\
    \x03\x11\x18\n\r\n\x05\x046\x02\x03\x01\x12\x04\xe0\x03\x19\"\n\r\n\x05\
    \x046\x02\x03\x03\x12\x04\xe0\x03%&\n\x0c\n\x02\x047\x12\x06\xe3\x03\0\
    \xe6\x03\x01\n\x0b\n\x03\x047\x01\x12\x04\xe3\x03\x08$\n\x0c\n\x04\x047\
    \x02\0\x12\x04\xe4\x03\x08&\n\r\n\x05\x047\x02\0\x04\x12\x04\xe4\x03\x08\
    \x10\n\r\n\x05\x047\x02\0\x05\x12\x04\xe4\x03\x11\x17\n\r\n\x05\x047\x02\
    \0\x01\x12\x04\xe4\x03\x18!\n\r\n\x05\x047\x02\0\x03\x12\x04\xe4\x03$%\n\
    \x0c\n\x04\x047\x02\x01\x12\x04\xe5\x03\x08%\n\r\n\x05\x047\x02\x01\x04\
    \x12\x04\xe5\x03\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\x04\xe5\x03\x11\
    \x18\n\r\n\x05\x047\x02\x01\x01\x12\x04\xe5\x03\x19\x20\n\r\n\x05\x047\
    \x02\x01\x03\x12\x04\xe5\x03#$\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::steammessages_steamlearn_steamworkssdk::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(72);
            messages.push(CExtraMsgBlock::generated_message_descriptor_data());
            messages.push(CMsgGCAssertJobData::generated_message_descriptor_data());
            messages.push(CMsgGCConCommand::generated_message_descriptor_data());
            messages.push(CMsgSDOAssert::generated_message_descriptor_data());
            messages.push(CMsgSOIDOwner::generated_message_descriptor_data());
            messages.push(CMsgSOSingleObject::generated_message_descriptor_data());
            messages.push(CMsgSOMultipleObjects::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscribed::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscribedUpToDate::generated_message_descriptor_data());
            messages.push(CMsgSOCacheUnsubscribed::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscriptionCheck::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscriptionRefresh::generated_message_descriptor_data());
            messages.push(CMsgSOCacheVersion::generated_message_descriptor_data());
            messages.push(CMsgGCMultiplexMessage::generated_message_descriptor_data());
            messages.push(CMsgGCToGCSubGCStarting::generated_message_descriptor_data());
            messages.push(CGCToGCMsgMasterAck::generated_message_descriptor_data());
            messages.push(CGCToGCMsgMasterAck_Response::generated_message_descriptor_data());
            messages.push(CMsgGCToGCUniverseStartup::generated_message_descriptor_data());
            messages.push(CMsgGCToGCUniverseStartupResponse::generated_message_descriptor_data());
            messages.push(CGCToGCMsgMasterStartupComplete::generated_message_descriptor_data());
            messages.push(CGCToGCMsgRouted::generated_message_descriptor_data());
            messages.push(CGCToGCMsgRoutedReply::generated_message_descriptor_data());
            messages.push(CMsgGCUpdateSubGCSessionInfo::generated_message_descriptor_data());
            messages.push(CMsgGCRequestSubGCSessionInfo::generated_message_descriptor_data());
            messages.push(CMsgGCRequestSubGCSessionInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgSOCacheHaveVersion::generated_message_descriptor_data());
            messages.push(CMsgClientHello::generated_message_descriptor_data());
            messages.push(CMsgClientWelcome::generated_message_descriptor_data());
            messages.push(CMsgConnectionStatus::generated_message_descriptor_data());
            messages.push(CMsgGCToGCSOCacheSubscribe::generated_message_descriptor_data());
            messages.push(CMsgGCToGCSOCacheUnsubscribe::generated_message_descriptor_data());
            messages.push(CMsgGCClientPing::generated_message_descriptor_data());
            messages.push(CMsgGCToGCForwardAccountDetails::generated_message_descriptor_data());
            messages.push(CMsgGCToGCLoadSessionSOCache::generated_message_descriptor_data());
            messages.push(CMsgGCToGCLoadSessionSOCacheResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCUpdateSessionStats::generated_message_descriptor_data());
            messages.push(CMsgGCToClientRequestDropped::generated_message_descriptor_data());
            messages.push(CWorkshop_PopulateItemDescriptions_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_GetContributors_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_GetContributors_Response::generated_message_descriptor_data());
            messages.push(CWorkshop_SetItemPaymentRules_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_SetItemPaymentRules_Response::generated_message_descriptor_data());
            messages.push(CCommunity_ClanAnnouncementInfo::generated_message_descriptor_data());
            messages.push(CCommunity_GetClanAnnouncements_Request::generated_message_descriptor_data());
            messages.push(CCommunity_GetClanAnnouncements_Response::generated_message_descriptor_data());
            messages.push(CBroadcast_PostGameDataFrame_Request::generated_message_descriptor_data());
            messages.push(CMsgSerializedSOCache::generated_message_descriptor_data());
            messages.push(CMsgGCToClientPollConvarRequest::generated_message_descriptor_data());
            messages.push(CMsgGCToClientPollConvarResponse::generated_message_descriptor_data());
            messages.push(CGCMsgCompressedMsgToClient::generated_message_descriptor_data());
            messages.push(CMsgGCToGCMasterBroadcastMessage::generated_message_descriptor_data());
            messages.push(CMsgGCToGCMasterSubscribeToCache::generated_message_descriptor_data());
            messages.push(CMsgGCToGCMasterSubscribeToCacheResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCMasterSubscribeToCacheAsync::generated_message_descriptor_data());
            messages.push(CMsgGCToGCMasterUnsubscribeFromCache::generated_message_descriptor_data());
            messages.push(CMsgGCToGCMasterDestroyCache::generated_message_descriptor_data());
            messages.push(cmsg_sdoassert::Request::generated_message_descriptor_data());
            messages.push(cmsg_somultiple_objects::SingleObject::generated_message_descriptor_data());
            messages.push(cmsg_socache_subscribed::SubscribedType::generated_message_descriptor_data());
            messages.push(cgcto_gcmsg_master_ack::Process::generated_message_descriptor_data());
            messages.push(cgcto_gcmsg_master_startup_complete::GCInfo::generated_message_descriptor_data());
            messages.push(cmsg_gcupdate_sub_gcsession_info::CMsgUpdate::generated_message_descriptor_data());
            messages.push(cmsg_client_welcome::Location::generated_message_descriptor_data());
            messages.push(cmsg_gcto_gcsocache_subscribe::CMsgHaveVersions::generated_message_descriptor_data());
            messages.push(cworkshop_populate_item_descriptions_request::SingleItemDescription::generated_message_descriptor_data());
            messages.push(cworkshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock::generated_message_descriptor_data());
            messages.push(cworkshop_set_item_payment_rules_request::WorkshopItemPaymentRule::generated_message_descriptor_data());
            messages.push(cworkshop_set_item_payment_rules_request::WorkshopDirectPaymentRule::generated_message_descriptor_data());
            messages.push(cworkshop_set_item_payment_rules_request::PartnerItemPaymentRule::generated_message_descriptor_data());
            messages.push(cmsg_serialized_socache::TypeCache::generated_message_descriptor_data());
            messages.push(cmsg_serialized_socache::Cache::generated_message_descriptor_data());
            messages.push(cmsg_serialized_socache::cache::Version::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(ESourceEngine::generated_enum_descriptor_data());
            enums.push(PartnerAccountType::generated_enum_descriptor_data());
            enums.push(GCConnectionStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
