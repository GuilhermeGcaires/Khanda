// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_battle_report.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetBattleReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReport {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReport.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReport.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReport.duration)
    pub duration: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetBattleReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReport {
    fn default() -> &'a CMsgClientToGCGetBattleReport {
        <CMsgClientToGCGetBattleReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReport {
    pub fn new() -> CMsgClientToGCGetBattleReport {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgClientToGCGetBattleReport| { &m.account_id },
            |m: &mut CMsgClientToGCGetBattleReport| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgClientToGCGetBattleReport| { &m.timestamp },
            |m: &mut CMsgClientToGCGetBattleReport| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgClientToGCGetBattleReport| { &m.duration },
            |m: &mut CMsgClientToGCGetBattleReport| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetBattleReport>(
            "CMsgClientToGCGetBattleReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetBattleReport {
    const NAME: &'static str = "CMsgClientToGCGetBattleReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReport {
        CMsgClientToGCGetBattleReport::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReport {
        static instance: CMsgClientToGCGetBattleReport = CMsgClientToGCGetBattleReport {
            account_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetBattleReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetBattleReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetBattleReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetBattleReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgBattleReport_Game)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReport_Game {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.hero_id)
    pub hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.assists)
    pub assists: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.rank_change)
    pub rank_change: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.denies)
    pub denies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.gpm)
    pub gpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.xpm)
    pub xpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.role)
    pub role: ::std::option::Option<::protobuf::EnumOrUnknown<CMsgBattleReport_Role>>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.outcome)
    pub outcome: ::std::option::Option<::protobuf::EnumOrUnknown<CMsgBattleReport_EOutcome>>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.lane_outcome)
    pub lane_outcome: ::std::option::Option<::protobuf::EnumOrUnknown<CMsgBattleReport_ELaneOutcome>>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.ranked)
    pub ranked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.predicted_position)
    pub predicted_position: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.seconds_dead)
    pub seconds_dead: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.winning_team)
    pub winning_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.player_slot)
    pub player_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.party_game)
    pub party_game: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.bounty_runes)
    pub bounty_runes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.water_runes)
    pub water_runes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.power_runes)
    pub power_runes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.time_enemy_t1_tower_destroyed)
    pub time_enemy_t1_tower_destroyed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.time_friendly_t1_tower_destroyed)
    pub time_friendly_t1_tower_destroyed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.enemy_roshan_kills)
    pub enemy_roshan_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.teleports_used)
    pub teleports_used: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.dewards)
    pub dewards: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.camps_stacked)
    pub camps_stacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.support_gold)
    pub support_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.hero_damage)
    pub hero_damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.hero_healing)
    pub hero_healing: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.tower_damage)
    pub tower_damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.successful_smokes)
    pub successful_smokes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.stun_duration)
    pub stun_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.friendly_roshan_kills)
    pub friendly_roshan_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.previous_rank)
    pub previous_rank: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.time_purchased_shard)
    pub time_purchased_shard: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.time_purchased_scepter)
    pub time_purchased_scepter: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.item0)
    pub item0: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.item1)
    pub item1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.item2)
    pub item2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.item3)
    pub item3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.item4)
    pub item4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_Game.item5)
    pub item5: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBattleReport_Game.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReport_Game {
    fn default() -> &'a CMsgBattleReport_Game {
        <CMsgBattleReport_Game as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReport_Game {
    pub fn new() -> CMsgBattleReport_Game {
        ::std::default::Default::default()
    }

    // optional uint32 hero_id = 1;

    pub fn hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 2;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 3;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 4;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional int32 rank_change = 5;

    pub fn rank_change(&self) -> i32 {
        self.rank_change.unwrap_or(0)
    }

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: i32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional uint32 last_hits = 6;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 denies = 21;

    pub fn denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    // optional uint32 gpm = 7;

    pub fn gpm(&self) -> u32 {
        self.gpm.unwrap_or(0)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: u32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional uint32 xpm = 8;

    pub fn xpm(&self) -> u32 {
        self.xpm.unwrap_or(0)
    }

    pub fn clear_xpm(&mut self) {
        self.xpm = ::std::option::Option::None;
    }

    pub fn has_xpm(&self) -> bool {
        self.xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpm(&mut self, v: u32) {
        self.xpm = ::std::option::Option::Some(v);
    }

    // optional .dota.CMsgBattleReport_Role role = 9;

    pub fn role(&self) -> CMsgBattleReport_Role {
        match self.role {
            Some(e) => e.enum_value_or(CMsgBattleReport_Role::k_eUnknownRole),
            None => CMsgBattleReport_Role::k_eUnknownRole,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: CMsgBattleReport_Role) {
        self.role = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.CMsgBattleReport_EOutcome outcome = 10;

    pub fn outcome(&self) -> CMsgBattleReport_EOutcome {
        match self.outcome {
            Some(e) => e.enum_value_or(CMsgBattleReport_EOutcome::k_eWin),
            None => CMsgBattleReport_EOutcome::k_eWin,
        }
    }

    pub fn clear_outcome(&mut self) {
        self.outcome = ::std::option::Option::None;
    }

    pub fn has_outcome(&self) -> bool {
        self.outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outcome(&mut self, v: CMsgBattleReport_EOutcome) {
        self.outcome = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.CMsgBattleReport_ELaneOutcome lane_outcome = 11;

    pub fn lane_outcome(&self) -> CMsgBattleReport_ELaneOutcome {
        match self.lane_outcome {
            Some(e) => e.enum_value_or(CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome),
            None => CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome,
        }
    }

    pub fn clear_lane_outcome(&mut self) {
        self.lane_outcome = ::std::option::Option::None;
    }

    pub fn has_lane_outcome(&self) -> bool {
        self.lane_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_outcome(&mut self, v: CMsgBattleReport_ELaneOutcome) {
        self.lane_outcome = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool ranked = 12;

    pub fn ranked(&self) -> bool {
        self.ranked.unwrap_or(false)
    }

    pub fn clear_ranked(&mut self) {
        self.ranked = ::std::option::Option::None;
    }

    pub fn has_ranked(&self) -> bool {
        self.ranked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked(&mut self, v: bool) {
        self.ranked = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 13;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 lane_selection_flags = 14;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 predicted_position = 15;

    pub fn predicted_position(&self) -> u32 {
        self.predicted_position.unwrap_or(0)
    }

    pub fn clear_predicted_position(&mut self) {
        self.predicted_position = ::std::option::Option::None;
    }

    pub fn has_predicted_position(&self) -> bool {
        self.predicted_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predicted_position(&mut self, v: u32) {
        self.predicted_position = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_dead = 16;

    pub fn seconds_dead(&self) -> u32 {
        self.seconds_dead.unwrap_or(0)
    }

    pub fn clear_seconds_dead(&mut self) {
        self.seconds_dead = ::std::option::Option::None;
    }

    pub fn has_seconds_dead(&self) -> bool {
        self.seconds_dead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_dead(&mut self, v: u32) {
        self.seconds_dead = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 17;

    pub fn winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }

    // optional uint32 player_slot = 28;

    pub fn player_slot(&self) -> u32 {
        self.player_slot.unwrap_or(0)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: u32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional bool party_game = 19;

    pub fn party_game(&self) -> bool {
        self.party_game.unwrap_or(false)
    }

    pub fn clear_party_game(&mut self) {
        self.party_game = ::std::option::Option::None;
    }

    pub fn has_party_game(&self) -> bool {
        self.party_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_game(&mut self, v: bool) {
        self.party_game = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 20;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 bounty_runes = 22;

    pub fn bounty_runes(&self) -> u32 {
        self.bounty_runes.unwrap_or(0)
    }

    pub fn clear_bounty_runes(&mut self) {
        self.bounty_runes = ::std::option::Option::None;
    }

    pub fn has_bounty_runes(&self) -> bool {
        self.bounty_runes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounty_runes(&mut self, v: u32) {
        self.bounty_runes = ::std::option::Option::Some(v);
    }

    // optional uint32 water_runes = 23;

    pub fn water_runes(&self) -> u32 {
        self.water_runes.unwrap_or(0)
    }

    pub fn clear_water_runes(&mut self) {
        self.water_runes = ::std::option::Option::None;
    }

    pub fn has_water_runes(&self) -> bool {
        self.water_runes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_water_runes(&mut self, v: u32) {
        self.water_runes = ::std::option::Option::Some(v);
    }

    // optional uint32 power_runes = 24;

    pub fn power_runes(&self) -> u32 {
        self.power_runes.unwrap_or(0)
    }

    pub fn clear_power_runes(&mut self) {
        self.power_runes = ::std::option::Option::None;
    }

    pub fn has_power_runes(&self) -> bool {
        self.power_runes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_power_runes(&mut self, v: u32) {
        self.power_runes = ::std::option::Option::Some(v);
    }

    // optional uint32 time_enemy_t1_tower_destroyed = 25;

    pub fn time_enemy_t1_tower_destroyed(&self) -> u32 {
        self.time_enemy_t1_tower_destroyed.unwrap_or(0)
    }

    pub fn clear_time_enemy_t1_tower_destroyed(&mut self) {
        self.time_enemy_t1_tower_destroyed = ::std::option::Option::None;
    }

    pub fn has_time_enemy_t1_tower_destroyed(&self) -> bool {
        self.time_enemy_t1_tower_destroyed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_enemy_t1_tower_destroyed(&mut self, v: u32) {
        self.time_enemy_t1_tower_destroyed = ::std::option::Option::Some(v);
    }

    // optional uint32 time_friendly_t1_tower_destroyed = 26;

    pub fn time_friendly_t1_tower_destroyed(&self) -> u32 {
        self.time_friendly_t1_tower_destroyed.unwrap_or(0)
    }

    pub fn clear_time_friendly_t1_tower_destroyed(&mut self) {
        self.time_friendly_t1_tower_destroyed = ::std::option::Option::None;
    }

    pub fn has_time_friendly_t1_tower_destroyed(&self) -> bool {
        self.time_friendly_t1_tower_destroyed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_friendly_t1_tower_destroyed(&mut self, v: u32) {
        self.time_friendly_t1_tower_destroyed = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_roshan_kills = 27;

    pub fn enemy_roshan_kills(&self) -> u32 {
        self.enemy_roshan_kills.unwrap_or(0)
    }

    pub fn clear_enemy_roshan_kills(&mut self) {
        self.enemy_roshan_kills = ::std::option::Option::None;
    }

    pub fn has_enemy_roshan_kills(&self) -> bool {
        self.enemy_roshan_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_roshan_kills(&mut self, v: u32) {
        self.enemy_roshan_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 teleports_used = 29;

    pub fn teleports_used(&self) -> u32 {
        self.teleports_used.unwrap_or(0)
    }

    pub fn clear_teleports_used(&mut self) {
        self.teleports_used = ::std::option::Option::None;
    }

    pub fn has_teleports_used(&self) -> bool {
        self.teleports_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teleports_used(&mut self, v: u32) {
        self.teleports_used = ::std::option::Option::Some(v);
    }

    // optional uint32 dewards = 30;

    pub fn dewards(&self) -> u32 {
        self.dewards.unwrap_or(0)
    }

    pub fn clear_dewards(&mut self) {
        self.dewards = ::std::option::Option::None;
    }

    pub fn has_dewards(&self) -> bool {
        self.dewards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dewards(&mut self, v: u32) {
        self.dewards = ::std::option::Option::Some(v);
    }

    // optional uint32 camps_stacked = 31;

    pub fn camps_stacked(&self) -> u32 {
        self.camps_stacked.unwrap_or(0)
    }

    pub fn clear_camps_stacked(&mut self) {
        self.camps_stacked = ::std::option::Option::None;
    }

    pub fn has_camps_stacked(&self) -> bool {
        self.camps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camps_stacked(&mut self, v: u32) {
        self.camps_stacked = ::std::option::Option::Some(v);
    }

    // optional uint32 support_gold = 32;

    pub fn support_gold(&self) -> u32 {
        self.support_gold.unwrap_or(0)
    }

    pub fn clear_support_gold(&mut self) {
        self.support_gold = ::std::option::Option::None;
    }

    pub fn has_support_gold(&self) -> bool {
        self.support_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold(&mut self, v: u32) {
        self.support_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_damage = 33;

    pub fn hero_damage(&self) -> u32 {
        self.hero_damage.unwrap_or(0)
    }

    pub fn clear_hero_damage(&mut self) {
        self.hero_damage = ::std::option::Option::None;
    }

    pub fn has_hero_damage(&self) -> bool {
        self.hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_damage(&mut self, v: u32) {
        self.hero_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_healing = 34;

    pub fn hero_healing(&self) -> u32 {
        self.hero_healing.unwrap_or(0)
    }

    pub fn clear_hero_healing(&mut self) {
        self.hero_healing = ::std::option::Option::None;
    }

    pub fn has_hero_healing(&self) -> bool {
        self.hero_healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_healing(&mut self, v: u32) {
        self.hero_healing = ::std::option::Option::Some(v);
    }

    // optional uint32 tower_damage = 35;

    pub fn tower_damage(&self) -> u32 {
        self.tower_damage.unwrap_or(0)
    }

    pub fn clear_tower_damage(&mut self) {
        self.tower_damage = ::std::option::Option::None;
    }

    pub fn has_tower_damage(&self) -> bool {
        self.tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_damage(&mut self, v: u32) {
        self.tower_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 successful_smokes = 36;

    pub fn successful_smokes(&self) -> u32 {
        self.successful_smokes.unwrap_or(0)
    }

    pub fn clear_successful_smokes(&mut self) {
        self.successful_smokes = ::std::option::Option::None;
    }

    pub fn has_successful_smokes(&self) -> bool {
        self.successful_smokes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_successful_smokes(&mut self, v: u32) {
        self.successful_smokes = ::std::option::Option::Some(v);
    }

    // optional uint32 stun_duration = 37;

    pub fn stun_duration(&self) -> u32 {
        self.stun_duration.unwrap_or(0)
    }

    pub fn clear_stun_duration(&mut self) {
        self.stun_duration = ::std::option::Option::None;
    }

    pub fn has_stun_duration(&self) -> bool {
        self.stun_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stun_duration(&mut self, v: u32) {
        self.stun_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 38;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 friendly_roshan_kills = 39;

    pub fn friendly_roshan_kills(&self) -> u32 {
        self.friendly_roshan_kills.unwrap_or(0)
    }

    pub fn clear_friendly_roshan_kills(&mut self) {
        self.friendly_roshan_kills = ::std::option::Option::None;
    }

    pub fn has_friendly_roshan_kills(&self) -> bool {
        self.friendly_roshan_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendly_roshan_kills(&mut self, v: u32) {
        self.friendly_roshan_kills = ::std::option::Option::Some(v);
    }

    // optional int32 previous_rank = 40;

    pub fn previous_rank(&self) -> i32 {
        self.previous_rank.unwrap_or(0)
    }

    pub fn clear_previous_rank(&mut self) {
        self.previous_rank = ::std::option::Option::None;
    }

    pub fn has_previous_rank(&self) -> bool {
        self.previous_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous_rank(&mut self, v: i32) {
        self.previous_rank = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 41;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 42;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional float time_purchased_shard = 43;

    pub fn time_purchased_shard(&self) -> f32 {
        self.time_purchased_shard.unwrap_or(0.)
    }

    pub fn clear_time_purchased_shard(&mut self) {
        self.time_purchased_shard = ::std::option::Option::None;
    }

    pub fn has_time_purchased_shard(&self) -> bool {
        self.time_purchased_shard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_purchased_shard(&mut self, v: f32) {
        self.time_purchased_shard = ::std::option::Option::Some(v);
    }

    // optional float time_purchased_scepter = 44;

    pub fn time_purchased_scepter(&self) -> f32 {
        self.time_purchased_scepter.unwrap_or(0.)
    }

    pub fn clear_time_purchased_scepter(&mut self) {
        self.time_purchased_scepter = ::std::option::Option::None;
    }

    pub fn has_time_purchased_scepter(&self) -> bool {
        self.time_purchased_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_purchased_scepter(&mut self, v: f32) {
        self.time_purchased_scepter = ::std::option::Option::Some(v);
    }

    // optional int32 item0 = 45;

    pub fn item0(&self) -> i32 {
        self.item0.unwrap_or(0)
    }

    pub fn clear_item0(&mut self) {
        self.item0 = ::std::option::Option::None;
    }

    pub fn has_item0(&self) -> bool {
        self.item0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item0(&mut self, v: i32) {
        self.item0 = ::std::option::Option::Some(v);
    }

    // optional int32 item1 = 46;

    pub fn item1(&self) -> i32 {
        self.item1.unwrap_or(0)
    }

    pub fn clear_item1(&mut self) {
        self.item1 = ::std::option::Option::None;
    }

    pub fn has_item1(&self) -> bool {
        self.item1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item1(&mut self, v: i32) {
        self.item1 = ::std::option::Option::Some(v);
    }

    // optional int32 item2 = 47;

    pub fn item2(&self) -> i32 {
        self.item2.unwrap_or(0)
    }

    pub fn clear_item2(&mut self) {
        self.item2 = ::std::option::Option::None;
    }

    pub fn has_item2(&self) -> bool {
        self.item2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item2(&mut self, v: i32) {
        self.item2 = ::std::option::Option::Some(v);
    }

    // optional int32 item3 = 48;

    pub fn item3(&self) -> i32 {
        self.item3.unwrap_or(0)
    }

    pub fn clear_item3(&mut self) {
        self.item3 = ::std::option::Option::None;
    }

    pub fn has_item3(&self) -> bool {
        self.item3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item3(&mut self, v: i32) {
        self.item3 = ::std::option::Option::Some(v);
    }

    // optional int32 item4 = 49;

    pub fn item4(&self) -> i32 {
        self.item4.unwrap_or(0)
    }

    pub fn clear_item4(&mut self) {
        self.item4 = ::std::option::Option::None;
    }

    pub fn has_item4(&self) -> bool {
        self.item4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item4(&mut self, v: i32) {
        self.item4 = ::std::option::Option::Some(v);
    }

    // optional int32 item5 = 50;

    pub fn item5(&self) -> i32 {
        self.item5.unwrap_or(0)
    }

    pub fn clear_item5(&mut self) {
        self.item5 = ::std::option::Option::None;
    }

    pub fn has_item5(&self) -> bool {
        self.item5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item5(&mut self, v: i32) {
        self.item5 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(49);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_id",
            |m: &CMsgBattleReport_Game| { &m.hero_id },
            |m: &mut CMsgBattleReport_Game| { &mut m.hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kills",
            |m: &CMsgBattleReport_Game| { &m.kills },
            |m: &mut CMsgBattleReport_Game| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaths",
            |m: &CMsgBattleReport_Game| { &m.deaths },
            |m: &mut CMsgBattleReport_Game| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assists",
            |m: &CMsgBattleReport_Game| { &m.assists },
            |m: &mut CMsgBattleReport_Game| { &mut m.assists },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_change",
            |m: &CMsgBattleReport_Game| { &m.rank_change },
            |m: &mut CMsgBattleReport_Game| { &mut m.rank_change },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_hits",
            |m: &CMsgBattleReport_Game| { &m.last_hits },
            |m: &mut CMsgBattleReport_Game| { &mut m.last_hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "denies",
            |m: &CMsgBattleReport_Game| { &m.denies },
            |m: &mut CMsgBattleReport_Game| { &mut m.denies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpm",
            |m: &CMsgBattleReport_Game| { &m.gpm },
            |m: &mut CMsgBattleReport_Game| { &mut m.gpm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xpm",
            |m: &CMsgBattleReport_Game| { &m.xpm },
            |m: &mut CMsgBattleReport_Game| { &mut m.xpm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role",
            |m: &CMsgBattleReport_Game| { &m.role },
            |m: &mut CMsgBattleReport_Game| { &mut m.role },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "outcome",
            |m: &CMsgBattleReport_Game| { &m.outcome },
            |m: &mut CMsgBattleReport_Game| { &mut m.outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane_outcome",
            |m: &CMsgBattleReport_Game| { &m.lane_outcome },
            |m: &mut CMsgBattleReport_Game| { &mut m.lane_outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ranked",
            |m: &CMsgBattleReport_Game| { &m.ranked },
            |m: &mut CMsgBattleReport_Game| { &mut m.ranked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgBattleReport_Game| { &m.match_id },
            |m: &mut CMsgBattleReport_Game| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lane_selection_flags",
            |m: &CMsgBattleReport_Game| { &m.lane_selection_flags },
            |m: &mut CMsgBattleReport_Game| { &mut m.lane_selection_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "predicted_position",
            |m: &CMsgBattleReport_Game| { &m.predicted_position },
            |m: &mut CMsgBattleReport_Game| { &mut m.predicted_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_dead",
            |m: &CMsgBattleReport_Game| { &m.seconds_dead },
            |m: &mut CMsgBattleReport_Game| { &mut m.seconds_dead },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "winning_team",
            |m: &CMsgBattleReport_Game| { &m.winning_team },
            |m: &mut CMsgBattleReport_Game| { &mut m.winning_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CMsgBattleReport_Game| { &m.player_slot },
            |m: &mut CMsgBattleReport_Game| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_game",
            |m: &CMsgBattleReport_Game| { &m.party_game },
            |m: &mut CMsgBattleReport_Game| { &mut m.party_game },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgBattleReport_Game| { &m.start_time },
            |m: &mut CMsgBattleReport_Game| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bounty_runes",
            |m: &CMsgBattleReport_Game| { &m.bounty_runes },
            |m: &mut CMsgBattleReport_Game| { &mut m.bounty_runes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "water_runes",
            |m: &CMsgBattleReport_Game| { &m.water_runes },
            |m: &mut CMsgBattleReport_Game| { &mut m.water_runes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "power_runes",
            |m: &CMsgBattleReport_Game| { &m.power_runes },
            |m: &mut CMsgBattleReport_Game| { &mut m.power_runes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_enemy_t1_tower_destroyed",
            |m: &CMsgBattleReport_Game| { &m.time_enemy_t1_tower_destroyed },
            |m: &mut CMsgBattleReport_Game| { &mut m.time_enemy_t1_tower_destroyed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_friendly_t1_tower_destroyed",
            |m: &CMsgBattleReport_Game| { &m.time_friendly_t1_tower_destroyed },
            |m: &mut CMsgBattleReport_Game| { &mut m.time_friendly_t1_tower_destroyed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_roshan_kills",
            |m: &CMsgBattleReport_Game| { &m.enemy_roshan_kills },
            |m: &mut CMsgBattleReport_Game| { &mut m.enemy_roshan_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "teleports_used",
            |m: &CMsgBattleReport_Game| { &m.teleports_used },
            |m: &mut CMsgBattleReport_Game| { &mut m.teleports_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dewards",
            |m: &CMsgBattleReport_Game| { &m.dewards },
            |m: &mut CMsgBattleReport_Game| { &mut m.dewards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "camps_stacked",
            |m: &CMsgBattleReport_Game| { &m.camps_stacked },
            |m: &mut CMsgBattleReport_Game| { &mut m.camps_stacked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support_gold",
            |m: &CMsgBattleReport_Game| { &m.support_gold },
            |m: &mut CMsgBattleReport_Game| { &mut m.support_gold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_damage",
            |m: &CMsgBattleReport_Game| { &m.hero_damage },
            |m: &mut CMsgBattleReport_Game| { &mut m.hero_damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hero_healing",
            |m: &CMsgBattleReport_Game| { &m.hero_healing },
            |m: &mut CMsgBattleReport_Game| { &mut m.hero_healing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tower_damage",
            |m: &CMsgBattleReport_Game| { &m.tower_damage },
            |m: &mut CMsgBattleReport_Game| { &mut m.tower_damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "successful_smokes",
            |m: &CMsgBattleReport_Game| { &m.successful_smokes },
            |m: &mut CMsgBattleReport_Game| { &mut m.successful_smokes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stun_duration",
            |m: &CMsgBattleReport_Game| { &m.stun_duration },
            |m: &mut CMsgBattleReport_Game| { &mut m.stun_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgBattleReport_Game| { &m.duration },
            |m: &mut CMsgBattleReport_Game| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friendly_roshan_kills",
            |m: &CMsgBattleReport_Game| { &m.friendly_roshan_kills },
            |m: &mut CMsgBattleReport_Game| { &mut m.friendly_roshan_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "previous_rank",
            |m: &CMsgBattleReport_Game| { &m.previous_rank },
            |m: &mut CMsgBattleReport_Game| { &mut m.previous_rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CMsgBattleReport_Game| { &m.game_mode },
            |m: &mut CMsgBattleReport_Game| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgBattleReport_Game| { &m.lobby_type },
            |m: &mut CMsgBattleReport_Game| { &mut m.lobby_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_purchased_shard",
            |m: &CMsgBattleReport_Game| { &m.time_purchased_shard },
            |m: &mut CMsgBattleReport_Game| { &mut m.time_purchased_shard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_purchased_scepter",
            |m: &CMsgBattleReport_Game| { &m.time_purchased_scepter },
            |m: &mut CMsgBattleReport_Game| { &mut m.time_purchased_scepter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item0",
            |m: &CMsgBattleReport_Game| { &m.item0 },
            |m: &mut CMsgBattleReport_Game| { &mut m.item0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item1",
            |m: &CMsgBattleReport_Game| { &m.item1 },
            |m: &mut CMsgBattleReport_Game| { &mut m.item1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item2",
            |m: &CMsgBattleReport_Game| { &m.item2 },
            |m: &mut CMsgBattleReport_Game| { &mut m.item2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item3",
            |m: &CMsgBattleReport_Game| { &m.item3 },
            |m: &mut CMsgBattleReport_Game| { &mut m.item3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item4",
            |m: &CMsgBattleReport_Game| { &m.item4 },
            |m: &mut CMsgBattleReport_Game| { &mut m.item4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item5",
            |m: &CMsgBattleReport_Game| { &m.item5 },
            |m: &mut CMsgBattleReport_Game| { &mut m.item5 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReport_Game>(
            "CMsgBattleReport_Game",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBattleReport_Game {
    const NAME: &'static str = "CMsgBattleReport_Game";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rank_change = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.denies = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.gpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.xpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.lane_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.ranked = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.predicted_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.seconds_dead = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.winning_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.party_game = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.bounty_runes = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.water_runes = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.power_runes = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.time_enemy_t1_tower_destroyed = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.time_friendly_t1_tower_destroyed = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.enemy_roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.teleports_used = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.dewards = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.support_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                },
                280 => {
                    self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.successful_smokes = ::std::option::Option::Some(is.read_uint32()?);
                },
                296 => {
                    self.stun_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                304 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.friendly_roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                320 => {
                    self.previous_rank = ::std::option::Option::Some(is.read_int32()?);
                },
                328 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                336 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                349 => {
                    self.time_purchased_shard = ::std::option::Option::Some(is.read_float()?);
                },
                357 => {
                    self.time_purchased_scepter = ::std::option::Option::Some(is.read_float()?);
                },
                360 => {
                    self.item0 = ::std::option::Option::Some(is.read_int32()?);
                },
                368 => {
                    self.item1 = ::std::option::Option::Some(is.read_int32()?);
                },
                376 => {
                    self.item2 = ::std::option::Option::Some(is.read_int32()?);
                },
                384 => {
                    self.item3 = ::std::option::Option::Some(is.read_int32()?);
                },
                392 => {
                    self.item4 = ::std::option::Option::Some(is.read_int32()?);
                },
                400 => {
                    self.item5 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rank_change {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.denies {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.gpm {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.xpm {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.role {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.outcome {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.lane_outcome {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.ranked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        if let Some(v) = self.lane_selection_flags {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.predicted_position {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.seconds_dead {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.winning_team {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.party_game {
            my_size += 2 + 1;
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.bounty_runes {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.water_runes {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.power_runes {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.time_enemy_t1_tower_destroyed {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.time_friendly_t1_tower_destroyed {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.enemy_roshan_kills {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.teleports_used {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.dewards {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.camps_stacked {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.support_gold {
            my_size += ::protobuf::rt::uint32_size(32, v);
        }
        if let Some(v) = self.hero_damage {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.hero_healing {
            my_size += ::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.tower_damage {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.successful_smokes {
            my_size += ::protobuf::rt::uint32_size(36, v);
        }
        if let Some(v) = self.stun_duration {
            my_size += ::protobuf::rt::uint32_size(37, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.friendly_roshan_kills {
            my_size += ::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.previous_rank {
            my_size += ::protobuf::rt::int32_size(40, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.time_purchased_shard {
            my_size += 2 + 4;
        }
        if let Some(v) = self.time_purchased_scepter {
            my_size += 2 + 4;
        }
        if let Some(v) = self.item0 {
            my_size += ::protobuf::rt::int32_size(45, v);
        }
        if let Some(v) = self.item1 {
            my_size += ::protobuf::rt::int32_size(46, v);
        }
        if let Some(v) = self.item2 {
            my_size += ::protobuf::rt::int32_size(47, v);
        }
        if let Some(v) = self.item3 {
            my_size += ::protobuf::rt::int32_size(48, v);
        }
        if let Some(v) = self.item4 {
            my_size += ::protobuf::rt::int32_size(49, v);
        }
        if let Some(v) = self.item5 {
            my_size += ::protobuf::rt::int32_size(50, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.xpm {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.outcome {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.lane_outcome {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ranked {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.predicted_position {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.seconds_dead {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.party_game {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.bounty_runes {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.water_runes {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.power_runes {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.time_enemy_t1_tower_destroyed {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.time_friendly_t1_tower_destroyed {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.enemy_roshan_kills {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.teleports_used {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.dewards {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.camps_stacked {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.support_gold {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.hero_damage {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.hero_healing {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.tower_damage {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.successful_smokes {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.stun_duration {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.friendly_roshan_kills {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.previous_rank {
            os.write_int32(40, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.time_purchased_shard {
            os.write_float(43, v)?;
        }
        if let Some(v) = self.time_purchased_scepter {
            os.write_float(44, v)?;
        }
        if let Some(v) = self.item0 {
            os.write_int32(45, v)?;
        }
        if let Some(v) = self.item1 {
            os.write_int32(46, v)?;
        }
        if let Some(v) = self.item2 {
            os.write_int32(47, v)?;
        }
        if let Some(v) = self.item3 {
            os.write_int32(48, v)?;
        }
        if let Some(v) = self.item4 {
            os.write_int32(49, v)?;
        }
        if let Some(v) = self.item5 {
            os.write_int32(50, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReport_Game {
        CMsgBattleReport_Game::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.rank_change = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.denies = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.xpm = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.outcome = ::std::option::Option::None;
        self.lane_outcome = ::std::option::Option::None;
        self.ranked = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.lane_selection_flags = ::std::option::Option::None;
        self.predicted_position = ::std::option::Option::None;
        self.seconds_dead = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.party_game = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.bounty_runes = ::std::option::Option::None;
        self.water_runes = ::std::option::Option::None;
        self.power_runes = ::std::option::Option::None;
        self.time_enemy_t1_tower_destroyed = ::std::option::Option::None;
        self.time_friendly_t1_tower_destroyed = ::std::option::Option::None;
        self.enemy_roshan_kills = ::std::option::Option::None;
        self.teleports_used = ::std::option::Option::None;
        self.dewards = ::std::option::Option::None;
        self.camps_stacked = ::std::option::Option::None;
        self.support_gold = ::std::option::Option::None;
        self.hero_damage = ::std::option::Option::None;
        self.hero_healing = ::std::option::Option::None;
        self.tower_damage = ::std::option::Option::None;
        self.successful_smokes = ::std::option::Option::None;
        self.stun_duration = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.friendly_roshan_kills = ::std::option::Option::None;
        self.previous_rank = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.time_purchased_shard = ::std::option::Option::None;
        self.time_purchased_scepter = ::std::option::Option::None;
        self.item0 = ::std::option::Option::None;
        self.item1 = ::std::option::Option::None;
        self.item2 = ::std::option::Option::None;
        self.item3 = ::std::option::Option::None;
        self.item4 = ::std::option::Option::None;
        self.item5 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReport_Game {
        static instance: CMsgBattleReport_Game = CMsgBattleReport_Game {
            hero_id: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            rank_change: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            denies: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            xpm: ::std::option::Option::None,
            role: ::std::option::Option::None,
            outcome: ::std::option::Option::None,
            lane_outcome: ::std::option::Option::None,
            ranked: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            lane_selection_flags: ::std::option::Option::None,
            predicted_position: ::std::option::Option::None,
            seconds_dead: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            party_game: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            bounty_runes: ::std::option::Option::None,
            water_runes: ::std::option::Option::None,
            power_runes: ::std::option::Option::None,
            time_enemy_t1_tower_destroyed: ::std::option::Option::None,
            time_friendly_t1_tower_destroyed: ::std::option::Option::None,
            enemy_roshan_kills: ::std::option::Option::None,
            teleports_used: ::std::option::Option::None,
            dewards: ::std::option::Option::None,
            camps_stacked: ::std::option::Option::None,
            support_gold: ::std::option::Option::None,
            hero_damage: ::std::option::Option::None,
            hero_healing: ::std::option::Option::None,
            tower_damage: ::std::option::Option::None,
            successful_smokes: ::std::option::Option::None,
            stun_duration: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            friendly_roshan_kills: ::std::option::Option::None,
            previous_rank: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            time_purchased_shard: ::std::option::Option::None,
            time_purchased_scepter: ::std::option::Option::None,
            item0: ::std::option::Option::None,
            item1: ::std::option::Option::None,
            item2: ::std::option::Option::None,
            item3: ::std::option::Option::None,
            item4: ::std::option::Option::None,
            item5: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBattleReport_Game {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBattleReport_Game").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBattleReport_Game {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleReport_Game {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgBattleReport_GameList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReport_GameList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBattleReport_GameList.games)
    pub games: ::std::vec::Vec<CMsgBattleReport_Game>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBattleReport_GameList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReport_GameList {
    fn default() -> &'a CMsgBattleReport_GameList {
        <CMsgBattleReport_GameList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReport_GameList {
    pub fn new() -> CMsgBattleReport_GameList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "games",
            |m: &CMsgBattleReport_GameList| { &m.games },
            |m: &mut CMsgBattleReport_GameList| { &mut m.games },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReport_GameList>(
            "CMsgBattleReport_GameList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBattleReport_GameList {
    const NAME: &'static str = "CMsgBattleReport_GameList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.games.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.games {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReport_GameList {
        CMsgBattleReport_GameList::new()
    }

    fn clear(&mut self) {
        self.games.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReport_GameList {
        static instance: CMsgBattleReport_GameList = CMsgBattleReport_GameList {
            games: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBattleReport_GameList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBattleReport_GameList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBattleReport_GameList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleReport_GameList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgBattleReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReport {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBattleReport.games)
    pub games: ::std::vec::Vec<CMsgBattleReport_Game>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReport.highlights)
    pub highlights: ::protobuf::MessageField<CMsgBattleReportHighlights>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBattleReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReport {
    fn default() -> &'a CMsgBattleReport {
        <CMsgBattleReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReport {
    pub fn new() -> CMsgBattleReport {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "games",
            |m: &CMsgBattleReport| { &m.games },
            |m: &mut CMsgBattleReport| { &mut m.games },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportHighlights>(
            "highlights",
            |m: &CMsgBattleReport| { &m.highlights },
            |m: &mut CMsgBattleReport| { &mut m.highlights },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReport>(
            "CMsgBattleReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBattleReport {
    const NAME: &'static str = "CMsgBattleReport";

    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.highlights {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.games.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.highlights)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.highlights.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.games {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.highlights.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReport {
        CMsgBattleReport::new()
    }

    fn clear(&mut self) {
        self.games.clear();
        self.highlights.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReport {
        static instance: CMsgBattleReport = CMsgBattleReport {
            games: ::std::vec::Vec::new(),
            highlights: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBattleReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBattleReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBattleReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgBattleReport`
pub mod cmsg_battle_report {
    // @@protoc_insertion_point(message:dota.CMsgBattleReport.HighlightGeneral)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HighlightGeneral {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.HighlightGeneral.win_loss_window)
        pub win_loss_window: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.HighlightGeneral.win_percent)
        pub win_percent: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.HighlightGeneral.mmr_delta)
        pub mmr_delta: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.HighlightGeneral.highlight_score)
        pub highlight_score: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgBattleReport.HighlightGeneral.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HighlightGeneral {
        fn default() -> &'a HighlightGeneral {
            <HighlightGeneral as ::protobuf::Message>::default_instance()
        }
    }

    impl HighlightGeneral {
        pub fn new() -> HighlightGeneral {
            ::std::default::Default::default()
        }

        // optional int32 win_loss_window = 1;

        pub fn win_loss_window(&self) -> i32 {
            self.win_loss_window.unwrap_or(0)
        }

        pub fn clear_win_loss_window(&mut self) {
            self.win_loss_window = ::std::option::Option::None;
        }

        pub fn has_win_loss_window(&self) -> bool {
            self.win_loss_window.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_loss_window(&mut self, v: i32) {
            self.win_loss_window = ::std::option::Option::Some(v);
        }

        // optional float win_percent = 2;

        pub fn win_percent(&self) -> f32 {
            self.win_percent.unwrap_or(0.)
        }

        pub fn clear_win_percent(&mut self) {
            self.win_percent = ::std::option::Option::None;
        }

        pub fn has_win_percent(&self) -> bool {
            self.win_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_percent(&mut self, v: f32) {
            self.win_percent = ::std::option::Option::Some(v);
        }

        // optional int32 mmr_delta = 3;

        pub fn mmr_delta(&self) -> i32 {
            self.mmr_delta.unwrap_or(0)
        }

        pub fn clear_mmr_delta(&mut self) {
            self.mmr_delta = ::std::option::Option::None;
        }

        pub fn has_mmr_delta(&self) -> bool {
            self.mmr_delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mmr_delta(&mut self, v: i32) {
            self.mmr_delta = ::std::option::Option::Some(v);
        }

        // optional float highlight_score = 4;

        pub fn highlight_score(&self) -> f32 {
            self.highlight_score.unwrap_or(0.)
        }

        pub fn clear_highlight_score(&mut self) {
            self.highlight_score = ::std::option::Option::None;
        }

        pub fn has_highlight_score(&self) -> bool {
            self.highlight_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_highlight_score(&mut self, v: f32) {
            self.highlight_score = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "win_loss_window",
                |m: &HighlightGeneral| { &m.win_loss_window },
                |m: &mut HighlightGeneral| { &mut m.win_loss_window },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "win_percent",
                |m: &HighlightGeneral| { &m.win_percent },
                |m: &mut HighlightGeneral| { &mut m.win_percent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mmr_delta",
                |m: &HighlightGeneral| { &m.mmr_delta },
                |m: &mut HighlightGeneral| { &mut m.mmr_delta },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "highlight_score",
                |m: &HighlightGeneral| { &m.highlight_score },
                |m: &mut HighlightGeneral| { &mut m.highlight_score },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HighlightGeneral>(
                "CMsgBattleReport.HighlightGeneral",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HighlightGeneral {
        const NAME: &'static str = "HighlightGeneral";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.win_loss_window = ::std::option::Option::Some(is.read_int32()?);
                    },
                    21 => {
                        self.win_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.mmr_delta = ::std::option::Option::Some(is.read_int32()?);
                    },
                    37 => {
                        self.highlight_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.win_loss_window {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.win_percent {
                my_size += 1 + 4;
            }
            if let Some(v) = self.mmr_delta {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.highlight_score {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.win_loss_window {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.win_percent {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.mmr_delta {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.highlight_score {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HighlightGeneral {
            HighlightGeneral::new()
        }

        fn clear(&mut self) {
            self.win_loss_window = ::std::option::Option::None;
            self.win_percent = ::std::option::Option::None;
            self.mmr_delta = ::std::option::Option::None;
            self.highlight_score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HighlightGeneral {
            static instance: HighlightGeneral = HighlightGeneral {
                win_loss_window: ::std::option::Option::None,
                win_percent: ::std::option::Option::None,
                mmr_delta: ::std::option::Option::None,
                highlight_score: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HighlightGeneral {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBattleReport.HighlightGeneral").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HighlightGeneral {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HighlightGeneral {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgBattleReport.Highlight)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Highlight {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.highlight_id)
        pub highlight_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.category)
        pub category: ::std::option::Option<::protobuf::EnumOrUnknown<super::CMsgBattleReport_HighlightCategory>>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.tier)
        pub tier: ::std::option::Option<::protobuf::EnumOrUnknown<super::CMsgBattleReport_HighlightTier>>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.rarity)
        pub rarity: ::std::option::Option<::protobuf::EnumOrUnknown<super::CMsgBattleReport_HighlightRarity>>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.score)
        pub score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.confidence)
        pub confidence: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.role)
        pub role: ::std::option::Option<::protobuf::EnumOrUnknown<super::CMsgBattleReport_Role>>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.comparison_delta_value)
        pub comparison_delta_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReport.Highlight.context)
        pub context: ::std::option::Option<::protobuf::EnumOrUnknown<super::CMsgBattleReport_CompareContext>>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgBattleReport.Highlight.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Highlight {
        fn default() -> &'a Highlight {
            <Highlight as ::protobuf::Message>::default_instance()
        }
    }

    impl Highlight {
        pub fn new() -> Highlight {
            ::std::default::Default::default()
        }

        // required uint32 highlight_id = 1;

        pub fn highlight_id(&self) -> u32 {
            self.highlight_id.unwrap_or(0)
        }

        pub fn clear_highlight_id(&mut self) {
            self.highlight_id = ::std::option::Option::None;
        }

        pub fn has_highlight_id(&self) -> bool {
            self.highlight_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_highlight_id(&mut self, v: u32) {
            self.highlight_id = ::std::option::Option::Some(v);
        }

        // required .dota.CMsgBattleReport_HighlightCategory category = 2;

        pub fn category(&self) -> super::CMsgBattleReport_HighlightCategory {
            match self.category {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_HighlightCategory::k_eHighlightGeneral),
                None => super::CMsgBattleReport_HighlightCategory::k_eHighlightGeneral,
            }
        }

        pub fn clear_category(&mut self) {
            self.category = ::std::option::Option::None;
        }

        pub fn has_category(&self) -> bool {
            self.category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category(&mut self, v: super::CMsgBattleReport_HighlightCategory) {
            self.category = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .dota.CMsgBattleReport_HighlightTier tier = 3;

        pub fn tier(&self) -> super::CMsgBattleReport_HighlightTier {
            match self.tier {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_HighlightTier::k_eHighlightTierLow),
                None => super::CMsgBattleReport_HighlightTier::k_eHighlightTierLow,
            }
        }

        pub fn clear_tier(&mut self) {
            self.tier = ::std::option::Option::None;
        }

        pub fn has_tier(&self) -> bool {
            self.tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tier(&mut self, v: super::CMsgBattleReport_HighlightTier) {
            self.tier = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .dota.CMsgBattleReport_HighlightRarity rarity = 4;

        pub fn rarity(&self) -> super::CMsgBattleReport_HighlightRarity {
            match self.rarity {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_HighlightRarity::k_eHighlightCommon),
                None => super::CMsgBattleReport_HighlightRarity::k_eHighlightCommon,
            }
        }

        pub fn clear_rarity(&mut self) {
            self.rarity = ::std::option::Option::None;
        }

        pub fn has_rarity(&self) -> bool {
            self.rarity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rarity(&mut self, v: super::CMsgBattleReport_HighlightRarity) {
            self.rarity = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional float score = 5;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional float confidence = 6;

        pub fn confidence(&self) -> f32 {
            self.confidence.unwrap_or(0.)
        }

        pub fn clear_confidence(&mut self) {
            self.confidence = ::std::option::Option::None;
        }

        pub fn has_confidence(&self) -> bool {
            self.confidence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_confidence(&mut self, v: f32) {
            self.confidence = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_id = 7;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional .dota.CMsgBattleReport_Role role = 8;

        pub fn role(&self) -> super::CMsgBattleReport_Role {
            match self.role {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_Role::k_eUnknownRole),
                None => super::CMsgBattleReport_Role::k_eUnknownRole,
            }
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: super::CMsgBattleReport_Role) {
            self.role = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional float comparison_delta_value = 9;

        pub fn comparison_delta_value(&self) -> f32 {
            self.comparison_delta_value.unwrap_or(0.)
        }

        pub fn clear_comparison_delta_value(&mut self) {
            self.comparison_delta_value = ::std::option::Option::None;
        }

        pub fn has_comparison_delta_value(&self) -> bool {
            self.comparison_delta_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comparison_delta_value(&mut self, v: f32) {
            self.comparison_delta_value = ::std::option::Option::Some(v);
        }

        // optional .dota.CMsgBattleReport_CompareContext context = 10;

        pub fn context(&self) -> super::CMsgBattleReport_CompareContext {
            match self.context {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_CompareContext::k_eCompareContextInvalid),
                None => super::CMsgBattleReport_CompareContext::k_eCompareContextInvalid,
            }
        }

        pub fn clear_context(&mut self) {
            self.context = ::std::option::Option::None;
        }

        pub fn has_context(&self) -> bool {
            self.context.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context(&mut self, v: super::CMsgBattleReport_CompareContext) {
            self.context = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "highlight_id",
                |m: &Highlight| { &m.highlight_id },
                |m: &mut Highlight| { &mut m.highlight_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "category",
                |m: &Highlight| { &m.category },
                |m: &mut Highlight| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tier",
                |m: &Highlight| { &m.tier },
                |m: &mut Highlight| { &mut m.tier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rarity",
                |m: &Highlight| { &m.rarity },
                |m: &mut Highlight| { &mut m.rarity },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &Highlight| { &m.score },
                |m: &mut Highlight| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "confidence",
                |m: &Highlight| { &m.confidence },
                |m: &mut Highlight| { &mut m.confidence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &Highlight| { &m.hero_id },
                |m: &mut Highlight| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "role",
                |m: &Highlight| { &m.role },
                |m: &mut Highlight| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "comparison_delta_value",
                |m: &Highlight| { &m.comparison_delta_value },
                |m: &mut Highlight| { &mut m.comparison_delta_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "context",
                |m: &Highlight| { &m.context },
                |m: &mut Highlight| { &mut m.context },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Highlight>(
                "CMsgBattleReport.Highlight",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Highlight {
        const NAME: &'static str = "Highlight";

        fn is_initialized(&self) -> bool {
            if self.highlight_id.is_none() {
                return false;
            }
            if self.category.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.highlight_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.category = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.tier = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.rarity = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    45 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    53 => {
                        self.confidence = ::std::option::Option::Some(is.read_float()?);
                    },
                    56 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    77 => {
                        self.comparison_delta_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    80 => {
                        self.context = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.highlight_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.category {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.tier {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.rarity {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.confidence {
                my_size += 1 + 4;
            }
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.role {
                my_size += ::protobuf::rt::int32_size(8, v.value());
            }
            if let Some(v) = self.comparison_delta_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.context {
                my_size += ::protobuf::rt::int32_size(10, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.highlight_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.category {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.tier {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.rarity {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.score {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.confidence {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.role {
                os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.comparison_delta_value {
                os.write_float(9, v)?;
            }
            if let Some(v) = self.context {
                os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Highlight {
            Highlight::new()
        }

        fn clear(&mut self) {
            self.highlight_id = ::std::option::Option::None;
            self.category = ::std::option::Option::None;
            self.tier = ::std::option::Option::None;
            self.rarity = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.confidence = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.comparison_delta_value = ::std::option::Option::None;
            self.context = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Highlight {
            static instance: Highlight = Highlight {
                highlight_id: ::std::option::Option::None,
                category: ::std::option::Option::None,
                tier: ::std::option::Option::None,
                rarity: ::std::option::Option::None,
                score: ::std::option::Option::None,
                confidence: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                role: ::std::option::Option::None,
                comparison_delta_value: ::std::option::Option::None,
                context: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Highlight {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBattleReport.Highlight").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Highlight {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Highlight {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgBattleReportInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBattleReportInfo.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReportInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReportInfo.acknowledged)
    pub acknowledged: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReportInfo.featured_hero_id)
    pub featured_hero_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReportInfo.featured_position)
    pub featured_position: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReportInfo.games_played)
    pub games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgBattleReportInfo.medal_counts)
    pub medal_counts: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBattleReportInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportInfo {
    fn default() -> &'a CMsgBattleReportInfo {
        <CMsgBattleReportInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportInfo {
    pub fn new() -> CMsgBattleReportInfo {
        ::std::default::Default::default()
    }

    // optional uint32 timestamp = 1;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 2;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool acknowledged = 3;

    pub fn acknowledged(&self) -> bool {
        self.acknowledged.unwrap_or(false)
    }

    pub fn clear_acknowledged(&mut self) {
        self.acknowledged = ::std::option::Option::None;
    }

    pub fn has_acknowledged(&self) -> bool {
        self.acknowledged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acknowledged(&mut self, v: bool) {
        self.acknowledged = ::std::option::Option::Some(v);
    }

    // optional uint32 featured_hero_id = 4;

    pub fn featured_hero_id(&self) -> u32 {
        self.featured_hero_id.unwrap_or(0)
    }

    pub fn clear_featured_hero_id(&mut self) {
        self.featured_hero_id = ::std::option::Option::None;
    }

    pub fn has_featured_hero_id(&self) -> bool {
        self.featured_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_hero_id(&mut self, v: u32) {
        self.featured_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 featured_position = 5;

    pub fn featured_position(&self) -> u32 {
        self.featured_position.unwrap_or(0)
    }

    pub fn clear_featured_position(&mut self) {
        self.featured_position = ::std::option::Option::None;
    }

    pub fn has_featured_position(&self) -> bool {
        self.featured_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_position(&mut self, v: u32) {
        self.featured_position = ::std::option::Option::Some(v);
    }

    // optional uint32 games_played = 6;

    pub fn games_played(&self) -> u32 {
        self.games_played.unwrap_or(0)
    }

    pub fn clear_games_played(&mut self) {
        self.games_played = ::std::option::Option::None;
    }

    pub fn has_games_played(&self) -> bool {
        self.games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_played(&mut self, v: u32) {
        self.games_played = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgBattleReportInfo| { &m.timestamp },
            |m: &mut CMsgBattleReportInfo| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgBattleReportInfo| { &m.duration },
            |m: &mut CMsgBattleReportInfo| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "acknowledged",
            |m: &CMsgBattleReportInfo| { &m.acknowledged },
            |m: &mut CMsgBattleReportInfo| { &mut m.acknowledged },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "featured_hero_id",
            |m: &CMsgBattleReportInfo| { &m.featured_hero_id },
            |m: &mut CMsgBattleReportInfo| { &mut m.featured_hero_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "featured_position",
            |m: &CMsgBattleReportInfo| { &m.featured_position },
            |m: &mut CMsgBattleReportInfo| { &mut m.featured_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "games_played",
            |m: &CMsgBattleReportInfo| { &m.games_played },
            |m: &mut CMsgBattleReportInfo| { &mut m.games_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "medal_counts",
            |m: &CMsgBattleReportInfo| { &m.medal_counts },
            |m: &mut CMsgBattleReportInfo| { &mut m.medal_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReportInfo>(
            "CMsgBattleReportInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBattleReportInfo {
    const NAME: &'static str = "CMsgBattleReportInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.acknowledged = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.featured_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.featured_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.medal_counts)?;
                },
                56 => {
                    self.medal_counts.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.acknowledged {
            my_size += 1 + 1;
        }
        if let Some(v) = self.featured_hero_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.featured_position {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.games_played {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.medal_counts {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.acknowledged {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.featured_hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.featured_position {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.games_played {
            os.write_uint32(6, v)?;
        }
        for v in &self.medal_counts {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportInfo {
        CMsgBattleReportInfo::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.acknowledged = ::std::option::Option::None;
        self.featured_hero_id = ::std::option::Option::None;
        self.featured_position = ::std::option::Option::None;
        self.games_played = ::std::option::Option::None;
        self.medal_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportInfo {
        static instance: CMsgBattleReportInfo = CMsgBattleReportInfo {
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            acknowledged: ::std::option::Option::None,
            featured_hero_id: ::std::option::Option::None,
            featured_position: ::std::option::Option::None,
            games_played: ::std::option::Option::None,
            medal_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBattleReportInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBattleReportInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBattleReportInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleReportInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgBattleReportInfoList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportInfoList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBattleReportInfoList.battle_report_info)
    pub battle_report_info: ::std::vec::Vec<CMsgBattleReportInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBattleReportInfoList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportInfoList {
    fn default() -> &'a CMsgBattleReportInfoList {
        <CMsgBattleReportInfoList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportInfoList {
    pub fn new() -> CMsgBattleReportInfoList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "battle_report_info",
            |m: &CMsgBattleReportInfoList| { &m.battle_report_info },
            |m: &mut CMsgBattleReportInfoList| { &mut m.battle_report_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReportInfoList>(
            "CMsgBattleReportInfoList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBattleReportInfoList {
    const NAME: &'static str = "CMsgBattleReportInfoList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.battle_report_info.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.battle_report_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.battle_report_info {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportInfoList {
        CMsgBattleReportInfoList::new()
    }

    fn clear(&mut self) {
        self.battle_report_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportInfoList {
        static instance: CMsgBattleReportInfoList = CMsgBattleReportInfoList {
            battle_report_info: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBattleReportInfoList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBattleReportInfoList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBattleReportInfoList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleReportInfoList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgBattleReportHighlights)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportHighlights {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBattleReportHighlights.highlights)
    pub highlights: ::std::vec::Vec<cmsg_battle_report::Highlight>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBattleReportHighlights.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportHighlights {
    fn default() -> &'a CMsgBattleReportHighlights {
        <CMsgBattleReportHighlights as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportHighlights {
    pub fn new() -> CMsgBattleReportHighlights {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "highlights",
            |m: &CMsgBattleReportHighlights| { &m.highlights },
            |m: &mut CMsgBattleReportHighlights| { &mut m.highlights },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReportHighlights>(
            "CMsgBattleReportHighlights",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBattleReportHighlights {
    const NAME: &'static str = "CMsgBattleReportHighlights";

    fn is_initialized(&self) -> bool {
        for v in &self.highlights {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.highlights.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.highlights {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.highlights {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportHighlights {
        CMsgBattleReportHighlights::new()
    }

    fn clear(&mut self) {
        self.highlights.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportHighlights {
        static instance: CMsgBattleReportHighlights = CMsgBattleReportHighlights {
            highlights: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBattleReportHighlights {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBattleReportHighlights").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBattleReportHighlights {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleReportHighlights {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgBattleReportAggregateStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportAggregateStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.result)
    pub result: ::std::vec::Vec<cmsg_battle_report_aggregate_stats::CMsgBattleReportAggregate>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBattleReportAggregateStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportAggregateStats {
    fn default() -> &'a CMsgBattleReportAggregateStats {
        <CMsgBattleReportAggregateStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportAggregateStats {
    pub fn new() -> CMsgBattleReportAggregateStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "result",
            |m: &CMsgBattleReportAggregateStats| { &m.result },
            |m: &mut CMsgBattleReportAggregateStats| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReportAggregateStats>(
            "CMsgBattleReportAggregateStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBattleReportAggregateStats {
    const NAME: &'static str = "CMsgBattleReportAggregateStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.result.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.result {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportAggregateStats {
        CMsgBattleReportAggregateStats::new()
    }

    fn clear(&mut self) {
        self.result.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportAggregateStats {
        static instance: CMsgBattleReportAggregateStats = CMsgBattleReportAggregateStats {
            result: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBattleReportAggregateStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBattleReportAggregateStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBattleReportAggregateStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleReportAggregateStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgBattleReportAggregateStats`
pub mod cmsg_battle_report_aggregate_stats {
    // @@protoc_insertion_point(message:dota.CMsgBattleReportAggregateStats.CMsgBattleReportStat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgBattleReportStat {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportStat.mean)
        pub mean: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportStat.stdev)
        pub stdev: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportStat.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgBattleReportStat {
        fn default() -> &'a CMsgBattleReportStat {
            <CMsgBattleReportStat as ::protobuf::Message>::default_instance()
        }
    }

    impl CMsgBattleReportStat {
        pub fn new() -> CMsgBattleReportStat {
            ::std::default::Default::default()
        }

        // optional float mean = 1;

        pub fn mean(&self) -> f32 {
            self.mean.unwrap_or(0.)
        }

        pub fn clear_mean(&mut self) {
            self.mean = ::std::option::Option::None;
        }

        pub fn has_mean(&self) -> bool {
            self.mean.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mean(&mut self, v: f32) {
            self.mean = ::std::option::Option::Some(v);
        }

        // optional float stdev = 2;

        pub fn stdev(&self) -> f32 {
            self.stdev.unwrap_or(0.)
        }

        pub fn clear_stdev(&mut self) {
            self.stdev = ::std::option::Option::None;
        }

        pub fn has_stdev(&self) -> bool {
            self.stdev.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev(&mut self, v: f32) {
            self.stdev = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mean",
                |m: &CMsgBattleReportStat| { &m.mean },
                |m: &mut CMsgBattleReportStat| { &mut m.mean },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stdev",
                |m: &CMsgBattleReportStat| { &m.stdev },
                |m: &mut CMsgBattleReportStat| { &mut m.stdev },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReportStat>(
                "CMsgBattleReportAggregateStats.CMsgBattleReportStat",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CMsgBattleReportStat {
        const NAME: &'static str = "CMsgBattleReportStat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.mean = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.stdev = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.mean {
                my_size += 1 + 4;
            }
            if let Some(v) = self.stdev {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.mean {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.stdev {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgBattleReportStat {
            CMsgBattleReportStat::new()
        }

        fn clear(&mut self) {
            self.mean = ::std::option::Option::None;
            self.stdev = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgBattleReportStat {
            static instance: CMsgBattleReportStat = CMsgBattleReportStat {
                mean: ::std::option::Option::None,
                stdev: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CMsgBattleReportStat {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBattleReportAggregateStats.CMsgBattleReportStat").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CMsgBattleReportStat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CMsgBattleReportStat {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgBattleReportAggregate {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.predicted_position)
        pub predicted_position: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.game_count)
        pub game_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.win_count)
        pub win_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.lane_win_count)
        pub lane_win_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.kills)
        pub kills: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.deaths)
        pub deaths: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.assists)
        pub assists: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.rank_change)
        pub rank_change: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.last_hits)
        pub last_hits: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.denies)
        pub denies: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.gpm)
        pub gpm: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.xpm)
        pub xpm: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.seconds_dead)
        pub seconds_dead: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.bounty_runes)
        pub bounty_runes: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.water_runes)
        pub water_runes: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.power_runes)
        pub power_runes: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.time_enemy_t1_tower_destroyed)
        pub time_enemy_t1_tower_destroyed: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.time_friendly_t1_tower_destroyed)
        pub time_friendly_t1_tower_destroyed: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.enemy_roshan_kills)
        pub enemy_roshan_kills: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.teleports_used)
        pub teleports_used: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.dewards)
        pub dewards: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.camps_stacked)
        pub camps_stacked: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.support_gold)
        pub support_gold: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.hero_damage)
        pub hero_damage: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.hero_healing)
        pub hero_healing: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.tower_damage)
        pub tower_damage: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.successful_smokes)
        pub successful_smokes: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.stun_duration)
        pub stun_duration: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.duration)
        pub duration: ::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.friendly_roshan_kills)
        pub friendly_roshan_kills: ::protobuf::MessageField<CMsgBattleReportStat>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgBattleReportAggregate {
        fn default() -> &'a CMsgBattleReportAggregate {
            <CMsgBattleReportAggregate as ::protobuf::Message>::default_instance()
        }
    }

    impl CMsgBattleReportAggregate {
        pub fn new() -> CMsgBattleReportAggregate {
            ::std::default::Default::default()
        }

        // optional uint32 hero_id = 1;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 predicted_position = 2;

        pub fn predicted_position(&self) -> u32 {
            self.predicted_position.unwrap_or(0)
        }

        pub fn clear_predicted_position(&mut self) {
            self.predicted_position = ::std::option::Option::None;
        }

        pub fn has_predicted_position(&self) -> bool {
            self.predicted_position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_predicted_position(&mut self, v: u32) {
            self.predicted_position = ::std::option::Option::Some(v);
        }

        // optional uint32 game_count = 3;

        pub fn game_count(&self) -> u32 {
            self.game_count.unwrap_or(0)
        }

        pub fn clear_game_count(&mut self) {
            self.game_count = ::std::option::Option::None;
        }

        pub fn has_game_count(&self) -> bool {
            self.game_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_count(&mut self, v: u32) {
            self.game_count = ::std::option::Option::Some(v);
        }

        // optional uint32 win_count = 4;

        pub fn win_count(&self) -> u32 {
            self.win_count.unwrap_or(0)
        }

        pub fn clear_win_count(&mut self) {
            self.win_count = ::std::option::Option::None;
        }

        pub fn has_win_count(&self) -> bool {
            self.win_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_count(&mut self, v: u32) {
            self.win_count = ::std::option::Option::Some(v);
        }

        // optional uint32 lane_win_count = 5;

        pub fn lane_win_count(&self) -> u32 {
            self.lane_win_count.unwrap_or(0)
        }

        pub fn clear_lane_win_count(&mut self) {
            self.lane_win_count = ::std::option::Option::None;
        }

        pub fn has_lane_win_count(&self) -> bool {
            self.lane_win_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane_win_count(&mut self, v: u32) {
            self.lane_win_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(31);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &CMsgBattleReportAggregate| { &m.hero_id },
                |m: &mut CMsgBattleReportAggregate| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "predicted_position",
                |m: &CMsgBattleReportAggregate| { &m.predicted_position },
                |m: &mut CMsgBattleReportAggregate| { &mut m.predicted_position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_count",
                |m: &CMsgBattleReportAggregate| { &m.game_count },
                |m: &mut CMsgBattleReportAggregate| { &mut m.game_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "win_count",
                |m: &CMsgBattleReportAggregate| { &m.win_count },
                |m: &mut CMsgBattleReportAggregate| { &mut m.win_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lane_win_count",
                |m: &CMsgBattleReportAggregate| { &m.lane_win_count },
                |m: &mut CMsgBattleReportAggregate| { &mut m.lane_win_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "kills",
                |m: &CMsgBattleReportAggregate| { &m.kills },
                |m: &mut CMsgBattleReportAggregate| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "deaths",
                |m: &CMsgBattleReportAggregate| { &m.deaths },
                |m: &mut CMsgBattleReportAggregate| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "assists",
                |m: &CMsgBattleReportAggregate| { &m.assists },
                |m: &mut CMsgBattleReportAggregate| { &mut m.assists },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "rank_change",
                |m: &CMsgBattleReportAggregate| { &m.rank_change },
                |m: &mut CMsgBattleReportAggregate| { &mut m.rank_change },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "last_hits",
                |m: &CMsgBattleReportAggregate| { &m.last_hits },
                |m: &mut CMsgBattleReportAggregate| { &mut m.last_hits },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "denies",
                |m: &CMsgBattleReportAggregate| { &m.denies },
                |m: &mut CMsgBattleReportAggregate| { &mut m.denies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "gpm",
                |m: &CMsgBattleReportAggregate| { &m.gpm },
                |m: &mut CMsgBattleReportAggregate| { &mut m.gpm },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "xpm",
                |m: &CMsgBattleReportAggregate| { &m.xpm },
                |m: &mut CMsgBattleReportAggregate| { &mut m.xpm },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "seconds_dead",
                |m: &CMsgBattleReportAggregate| { &m.seconds_dead },
                |m: &mut CMsgBattleReportAggregate| { &mut m.seconds_dead },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "bounty_runes",
                |m: &CMsgBattleReportAggregate| { &m.bounty_runes },
                |m: &mut CMsgBattleReportAggregate| { &mut m.bounty_runes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "water_runes",
                |m: &CMsgBattleReportAggregate| { &m.water_runes },
                |m: &mut CMsgBattleReportAggregate| { &mut m.water_runes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "power_runes",
                |m: &CMsgBattleReportAggregate| { &m.power_runes },
                |m: &mut CMsgBattleReportAggregate| { &mut m.power_runes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "time_enemy_t1_tower_destroyed",
                |m: &CMsgBattleReportAggregate| { &m.time_enemy_t1_tower_destroyed },
                |m: &mut CMsgBattleReportAggregate| { &mut m.time_enemy_t1_tower_destroyed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "time_friendly_t1_tower_destroyed",
                |m: &CMsgBattleReportAggregate| { &m.time_friendly_t1_tower_destroyed },
                |m: &mut CMsgBattleReportAggregate| { &mut m.time_friendly_t1_tower_destroyed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "enemy_roshan_kills",
                |m: &CMsgBattleReportAggregate| { &m.enemy_roshan_kills },
                |m: &mut CMsgBattleReportAggregate| { &mut m.enemy_roshan_kills },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "teleports_used",
                |m: &CMsgBattleReportAggregate| { &m.teleports_used },
                |m: &mut CMsgBattleReportAggregate| { &mut m.teleports_used },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "dewards",
                |m: &CMsgBattleReportAggregate| { &m.dewards },
                |m: &mut CMsgBattleReportAggregate| { &mut m.dewards },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "camps_stacked",
                |m: &CMsgBattleReportAggregate| { &m.camps_stacked },
                |m: &mut CMsgBattleReportAggregate| { &mut m.camps_stacked },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "support_gold",
                |m: &CMsgBattleReportAggregate| { &m.support_gold },
                |m: &mut CMsgBattleReportAggregate| { &mut m.support_gold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "hero_damage",
                |m: &CMsgBattleReportAggregate| { &m.hero_damage },
                |m: &mut CMsgBattleReportAggregate| { &mut m.hero_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "hero_healing",
                |m: &CMsgBattleReportAggregate| { &m.hero_healing },
                |m: &mut CMsgBattleReportAggregate| { &mut m.hero_healing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "tower_damage",
                |m: &CMsgBattleReportAggregate| { &m.tower_damage },
                |m: &mut CMsgBattleReportAggregate| { &mut m.tower_damage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "successful_smokes",
                |m: &CMsgBattleReportAggregate| { &m.successful_smokes },
                |m: &mut CMsgBattleReportAggregate| { &mut m.successful_smokes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "stun_duration",
                |m: &CMsgBattleReportAggregate| { &m.stun_duration },
                |m: &mut CMsgBattleReportAggregate| { &mut m.stun_duration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "duration",
                |m: &CMsgBattleReportAggregate| { &m.duration },
                |m: &mut CMsgBattleReportAggregate| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportStat>(
                "friendly_roshan_kills",
                |m: &CMsgBattleReportAggregate| { &m.friendly_roshan_kills },
                |m: &mut CMsgBattleReportAggregate| { &mut m.friendly_roshan_kills },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReportAggregate>(
                "CMsgBattleReportAggregateStats.CMsgBattleReportAggregate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CMsgBattleReportAggregate {
        const NAME: &'static str = "CMsgBattleReportAggregate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.predicted_position = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.game_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.win_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.lane_win_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.kills)?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.deaths)?;
                    },
                    66 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.assists)?;
                    },
                    74 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rank_change)?;
                    },
                    82 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_hits)?;
                    },
                    90 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.denies)?;
                    },
                    98 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.gpm)?;
                    },
                    106 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.xpm)?;
                    },
                    114 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.seconds_dead)?;
                    },
                    122 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.bounty_runes)?;
                    },
                    130 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.water_runes)?;
                    },
                    138 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.power_runes)?;
                    },
                    146 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.time_enemy_t1_tower_destroyed)?;
                    },
                    154 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.time_friendly_t1_tower_destroyed)?;
                    },
                    162 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.enemy_roshan_kills)?;
                    },
                    170 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.teleports_used)?;
                    },
                    178 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.dewards)?;
                    },
                    186 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.camps_stacked)?;
                    },
                    194 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.support_gold)?;
                    },
                    202 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_damage)?;
                    },
                    210 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_healing)?;
                    },
                    218 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.tower_damage)?;
                    },
                    226 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.successful_smokes)?;
                    },
                    234 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stun_duration)?;
                    },
                    242 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.duration)?;
                    },
                    250 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.friendly_roshan_kills)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.predicted_position {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.game_count {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.win_count {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.lane_win_count {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.kills.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.deaths.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.assists.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.rank_change.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.last_hits.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.denies.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.gpm.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.xpm.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.seconds_dead.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.bounty_runes.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.water_runes.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.power_runes.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.time_enemy_t1_tower_destroyed.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.time_friendly_t1_tower_destroyed.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.enemy_roshan_kills.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.teleports_used.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.dewards.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.camps_stacked.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.support_gold.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.hero_damage.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.hero_healing.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.tower_damage.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.successful_smokes.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.stun_duration.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.duration.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.friendly_roshan_kills.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.predicted_position {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.game_count {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.win_count {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.lane_win_count {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.kills.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.deaths.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.assists.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            if let Some(v) = self.rank_change.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            if let Some(v) = self.last_hits.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            }
            if let Some(v) = self.denies.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            }
            if let Some(v) = self.gpm.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            if let Some(v) = self.xpm.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
            }
            if let Some(v) = self.seconds_dead.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
            }
            if let Some(v) = self.bounty_runes.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
            }
            if let Some(v) = self.water_runes.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
            }
            if let Some(v) = self.power_runes.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
            }
            if let Some(v) = self.time_enemy_t1_tower_destroyed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
            }
            if let Some(v) = self.time_friendly_t1_tower_destroyed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
            }
            if let Some(v) = self.enemy_roshan_kills.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
            }
            if let Some(v) = self.teleports_used.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
            }
            if let Some(v) = self.dewards.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
            }
            if let Some(v) = self.camps_stacked.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
            }
            if let Some(v) = self.support_gold.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
            }
            if let Some(v) = self.hero_damage.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
            }
            if let Some(v) = self.hero_healing.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
            }
            if let Some(v) = self.tower_damage.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
            }
            if let Some(v) = self.successful_smokes.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
            }
            if let Some(v) = self.stun_duration.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
            }
            if let Some(v) = self.duration.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
            }
            if let Some(v) = self.friendly_roshan_kills.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgBattleReportAggregate {
            CMsgBattleReportAggregate::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.predicted_position = ::std::option::Option::None;
            self.game_count = ::std::option::Option::None;
            self.win_count = ::std::option::Option::None;
            self.lane_win_count = ::std::option::Option::None;
            self.kills.clear();
            self.deaths.clear();
            self.assists.clear();
            self.rank_change.clear();
            self.last_hits.clear();
            self.denies.clear();
            self.gpm.clear();
            self.xpm.clear();
            self.seconds_dead.clear();
            self.bounty_runes.clear();
            self.water_runes.clear();
            self.power_runes.clear();
            self.time_enemy_t1_tower_destroyed.clear();
            self.time_friendly_t1_tower_destroyed.clear();
            self.enemy_roshan_kills.clear();
            self.teleports_used.clear();
            self.dewards.clear();
            self.camps_stacked.clear();
            self.support_gold.clear();
            self.hero_damage.clear();
            self.hero_healing.clear();
            self.tower_damage.clear();
            self.successful_smokes.clear();
            self.stun_duration.clear();
            self.duration.clear();
            self.friendly_roshan_kills.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgBattleReportAggregate {
            static instance: CMsgBattleReportAggregate = CMsgBattleReportAggregate {
                hero_id: ::std::option::Option::None,
                predicted_position: ::std::option::Option::None,
                game_count: ::std::option::Option::None,
                win_count: ::std::option::Option::None,
                lane_win_count: ::std::option::Option::None,
                kills: ::protobuf::MessageField::none(),
                deaths: ::protobuf::MessageField::none(),
                assists: ::protobuf::MessageField::none(),
                rank_change: ::protobuf::MessageField::none(),
                last_hits: ::protobuf::MessageField::none(),
                denies: ::protobuf::MessageField::none(),
                gpm: ::protobuf::MessageField::none(),
                xpm: ::protobuf::MessageField::none(),
                seconds_dead: ::protobuf::MessageField::none(),
                bounty_runes: ::protobuf::MessageField::none(),
                water_runes: ::protobuf::MessageField::none(),
                power_runes: ::protobuf::MessageField::none(),
                time_enemy_t1_tower_destroyed: ::protobuf::MessageField::none(),
                time_friendly_t1_tower_destroyed: ::protobuf::MessageField::none(),
                enemy_roshan_kills: ::protobuf::MessageField::none(),
                teleports_used: ::protobuf::MessageField::none(),
                dewards: ::protobuf::MessageField::none(),
                camps_stacked: ::protobuf::MessageField::none(),
                support_gold: ::protobuf::MessageField::none(),
                hero_damage: ::protobuf::MessageField::none(),
                hero_healing: ::protobuf::MessageField::none(),
                tower_damage: ::protobuf::MessageField::none(),
                successful_smokes: ::protobuf::MessageField::none(),
                stun_duration: ::protobuf::MessageField::none(),
                duration: ::protobuf::MessageField::none(),
                friendly_roshan_kills: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CMsgBattleReportAggregate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBattleReportAggregateStats.CMsgBattleReportAggregate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CMsgBattleReportAggregate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CMsgBattleReportAggregate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgBattleReportAggregatedGeneralStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportAggregatedGeneralStats {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgBattleReportAggregatedGeneralStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportAggregatedGeneralStats {
    fn default() -> &'a CMsgBattleReportAggregatedGeneralStats {
        <CMsgBattleReportAggregatedGeneralStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportAggregatedGeneralStats {
    pub fn new() -> CMsgBattleReportAggregatedGeneralStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReportAggregatedGeneralStats>(
            "CMsgBattleReportAggregatedGeneralStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBattleReportAggregatedGeneralStats {
    const NAME: &'static str = "CMsgBattleReportAggregatedGeneralStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportAggregatedGeneralStats {
        CMsgBattleReportAggregatedGeneralStats::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportAggregatedGeneralStats {
        static instance: CMsgBattleReportAggregatedGeneralStats = CMsgBattleReportAggregatedGeneralStats {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBattleReportAggregatedGeneralStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBattleReportAggregatedGeneralStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBattleReportAggregatedGeneralStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleReportAggregatedGeneralStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetBattleReportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportResponse.report)
    pub report: ::protobuf::MessageField<CMsgBattleReport>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcget_battle_report_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportResponse.aggregate_stats)
    pub aggregate_stats: ::protobuf::MessageField<CMsgBattleReportAggregateStats>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportResponse.info)
    pub info: ::protobuf::MessageField<CMsgBattleReportInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetBattleReportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportResponse {
    fn default() -> &'a CMsgClientToGCGetBattleReportResponse {
        <CMsgClientToGCGetBattleReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportResponse {
    pub fn new() -> CMsgClientToGCGetBattleReportResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCGetBattleReportResponse.EResponse response = 2;

    pub fn response(&self) -> cmsg_client_to_gcget_battle_report_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_battle_report_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_battle_report_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_battle_report_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReport>(
            "report",
            |m: &CMsgClientToGCGetBattleReportResponse| { &m.report },
            |m: &mut CMsgClientToGCGetBattleReportResponse| { &mut m.report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCGetBattleReportResponse| { &m.response },
            |m: &mut CMsgClientToGCGetBattleReportResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportAggregateStats>(
            "aggregate_stats",
            |m: &CMsgClientToGCGetBattleReportResponse| { &m.aggregate_stats },
            |m: &mut CMsgClientToGCGetBattleReportResponse| { &mut m.aggregate_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportInfo>(
            "info",
            |m: &CMsgClientToGCGetBattleReportResponse| { &m.info },
            |m: &mut CMsgClientToGCGetBattleReportResponse| { &mut m.info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetBattleReportResponse>(
            "CMsgClientToGCGetBattleReportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetBattleReportResponse {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportResponse";

    fn is_initialized(&self) -> bool {
        for v in &self.report {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregate_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.report)?;
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.aggregate_stats)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.report.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.aggregate_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.report.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.aggregate_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportResponse {
        CMsgClientToGCGetBattleReportResponse::new()
    }

    fn clear(&mut self) {
        self.report.clear();
        self.response = ::std::option::Option::None;
        self.aggregate_stats.clear();
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportResponse {
        static instance: CMsgClientToGCGetBattleReportResponse = CMsgClientToGCGetBattleReportResponse {
            report: ::protobuf::MessageField::none(),
            response: ::std::option::Option::None,
            aggregate_stats: ::protobuf::MessageField::none(),
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetBattleReportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetBattleReportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetBattleReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetBattleReportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportResponse`
pub mod cmsg_client_to_gcget_battle_report_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCGetBattleReportResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eInvalidParameters)
        k_eInvalidParameters = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eUnableToGetPlusSubInfo)
        k_eUnableToGetPlusSubInfo = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eUnableToLoadBattleReport)
        k_eUnableToLoadBattleReport = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eUnableToSaveBattleReport)
        k_eUnableToSaveBattleReport = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eUnableToGetAggregates)
        k_eUnableToGetAggregates = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportResponse.EResponse.k_eNotEnoughGamesPlayed)
        k_eNotEnoughGamesPlayed = 11,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                5 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidParameters),
                7 => ::std::option::Option::Some(EResponse::k_eUnableToGetPlusSubInfo),
                8 => ::std::option::Option::Some(EResponse::k_eUnableToLoadBattleReport),
                9 => ::std::option::Option::Some(EResponse::k_eUnableToSaveBattleReport),
                10 => ::std::option::Option::Some(EResponse::k_eUnableToGetAggregates),
                11 => ::std::option::Option::Some(EResponse::k_eNotEnoughGamesPlayed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                "k_eInvalidParameters" => ::std::option::Option::Some(EResponse::k_eInvalidParameters),
                "k_eUnableToGetPlusSubInfo" => ::std::option::Option::Some(EResponse::k_eUnableToGetPlusSubInfo),
                "k_eUnableToLoadBattleReport" => ::std::option::Option::Some(EResponse::k_eUnableToLoadBattleReport),
                "k_eUnableToSaveBattleReport" => ::std::option::Option::Some(EResponse::k_eUnableToSaveBattleReport),
                "k_eUnableToGetAggregates" => ::std::option::Option::Some(EResponse::k_eUnableToGetAggregates),
                "k_eNotEnoughGamesPlayed" => ::std::option::Option::Some(EResponse::k_eNotEnoughGamesPlayed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_ePermissionDenied,
            EResponse::k_eNotSubscribedToDotaPlus,
            EResponse::k_eInvalidParameters,
            EResponse::k_eUnableToGetPlusSubInfo,
            EResponse::k_eUnableToLoadBattleReport,
            EResponse::k_eUnableToSaveBattleReport,
            EResponse::k_eUnableToGetAggregates,
            EResponse::k_eNotEnoughGamesPlayed,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCGetBattleReportResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCGetBattleReportResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetBattleReportAggregateStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportAggregateStats {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportAggregateStats.aggregate_keys)
    pub aggregate_keys: ::std::vec::Vec<cmsg_client_to_gcget_battle_report_aggregate_stats::CMsgBattleReportAggregateKey>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportAggregateStats.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportAggregateStats.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportAggregateStats.rank)
    pub rank: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetBattleReportAggregateStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportAggregateStats {
    fn default() -> &'a CMsgClientToGCGetBattleReportAggregateStats {
        <CMsgClientToGCGetBattleReportAggregateStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportAggregateStats {
    pub fn new() -> CMsgClientToGCGetBattleReportAggregateStats {
        ::std::default::Default::default()
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 4;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "aggregate_keys",
            |m: &CMsgClientToGCGetBattleReportAggregateStats| { &m.aggregate_keys },
            |m: &mut CMsgClientToGCGetBattleReportAggregateStats| { &mut m.aggregate_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgClientToGCGetBattleReportAggregateStats| { &m.timestamp },
            |m: &mut CMsgClientToGCGetBattleReportAggregateStats| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgClientToGCGetBattleReportAggregateStats| { &m.duration },
            |m: &mut CMsgClientToGCGetBattleReportAggregateStats| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &CMsgClientToGCGetBattleReportAggregateStats| { &m.rank },
            |m: &mut CMsgClientToGCGetBattleReportAggregateStats| { &mut m.rank },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetBattleReportAggregateStats>(
            "CMsgClientToGCGetBattleReportAggregateStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetBattleReportAggregateStats {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportAggregateStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.aggregate_keys.push(is.read_message()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.aggregate_keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.aggregate_keys {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportAggregateStats {
        CMsgClientToGCGetBattleReportAggregateStats::new()
    }

    fn clear(&mut self) {
        self.aggregate_keys.clear();
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportAggregateStats {
        static instance: CMsgClientToGCGetBattleReportAggregateStats = CMsgClientToGCGetBattleReportAggregateStats {
            aggregate_keys: ::std::vec::Vec::new(),
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetBattleReportAggregateStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetBattleReportAggregateStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetBattleReportAggregateStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetBattleReportAggregateStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportAggregateStats`
pub mod cmsg_client_to_gcget_battle_report_aggregate_stats {
    // @@protoc_insertion_point(message:dota.CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgBattleReportAggregateKey {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey.hero_id)
        pub hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey.predicted_position)
        pub predicted_position: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgBattleReportAggregateKey {
        fn default() -> &'a CMsgBattleReportAggregateKey {
            <CMsgBattleReportAggregateKey as ::protobuf::Message>::default_instance()
        }
    }

    impl CMsgBattleReportAggregateKey {
        pub fn new() -> CMsgBattleReportAggregateKey {
            ::std::default::Default::default()
        }

        // optional uint32 hero_id = 1;

        pub fn hero_id(&self) -> u32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: u32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 predicted_position = 2;

        pub fn predicted_position(&self) -> u32 {
            self.predicted_position.unwrap_or(0)
        }

        pub fn clear_predicted_position(&mut self) {
            self.predicted_position = ::std::option::Option::None;
        }

        pub fn has_predicted_position(&self) -> bool {
            self.predicted_position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_predicted_position(&mut self, v: u32) {
            self.predicted_position = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_id",
                |m: &CMsgBattleReportAggregateKey| { &m.hero_id },
                |m: &mut CMsgBattleReportAggregateKey| { &mut m.hero_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "predicted_position",
                |m: &CMsgBattleReportAggregateKey| { &m.predicted_position },
                |m: &mut CMsgBattleReportAggregateKey| { &mut m.predicted_position },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBattleReportAggregateKey>(
                "CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CMsgBattleReportAggregateKey {
        const NAME: &'static str = "CMsgBattleReportAggregateKey";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.predicted_position = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.predicted_position {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.predicted_position {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgBattleReportAggregateKey {
            CMsgBattleReportAggregateKey::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.predicted_position = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgBattleReportAggregateKey {
            static instance: CMsgBattleReportAggregateKey = CMsgBattleReportAggregateKey {
                hero_id: ::std::option::Option::None,
                predicted_position: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CMsgBattleReportAggregateKey {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CMsgBattleReportAggregateKey {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CMsgBattleReportAggregateKey {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportAggregateStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.aggregate_stats)
    pub aggregate_stats: ::protobuf::MessageField<CMsgBattleReportAggregateStats>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportAggregateStatsResponse {
    fn default() -> &'a CMsgClientToGCGetBattleReportAggregateStatsResponse {
        <CMsgClientToGCGetBattleReportAggregateStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportAggregateStatsResponse {
    pub fn new() -> CMsgClientToGCGetBattleReportAggregateStatsResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse response = 2;

    pub fn response(&self) -> cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportAggregateStats>(
            "aggregate_stats",
            |m: &CMsgClientToGCGetBattleReportAggregateStatsResponse| { &m.aggregate_stats },
            |m: &mut CMsgClientToGCGetBattleReportAggregateStatsResponse| { &mut m.aggregate_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCGetBattleReportAggregateStatsResponse| { &m.response },
            |m: &mut CMsgClientToGCGetBattleReportAggregateStatsResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetBattleReportAggregateStatsResponse>(
            "CMsgClientToGCGetBattleReportAggregateStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetBattleReportAggregateStatsResponse {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportAggregateStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.aggregate_stats)?;
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.aggregate_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.aggregate_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportAggregateStatsResponse {
        CMsgClientToGCGetBattleReportAggregateStatsResponse::new()
    }

    fn clear(&mut self) {
        self.aggregate_stats.clear();
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportAggregateStatsResponse {
        static instance: CMsgClientToGCGetBattleReportAggregateStatsResponse = CMsgClientToGCGetBattleReportAggregateStatsResponse {
            aggregate_stats: ::protobuf::MessageField::none(),
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetBattleReportAggregateStatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetBattleReportAggregateStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetBattleReportAggregateStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetBattleReportAggregateStatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportAggregateStatsResponse`
pub mod cmsg_client_to_gcget_battle_report_aggregate_stats_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eInvalidParams)
        k_eInvalidParams = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidParams),
                6 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eInvalidParams" => ::std::option::Option::Some(EResponse::k_eInvalidParams),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_ePermissionDenied,
            EResponse::k_eInvalidParams,
            EResponse::k_eNotSubscribedToDotaPlus,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetBattleReportInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetBattleReportInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportInfo {
    fn default() -> &'a CMsgClientToGCGetBattleReportInfo {
        <CMsgClientToGCGetBattleReportInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportInfo {
    pub fn new() -> CMsgClientToGCGetBattleReportInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgClientToGCGetBattleReportInfo| { &m.account_id },
            |m: &mut CMsgClientToGCGetBattleReportInfo| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetBattleReportInfo>(
            "CMsgClientToGCGetBattleReportInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetBattleReportInfo {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportInfo {
        CMsgClientToGCGetBattleReportInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportInfo {
        static instance: CMsgClientToGCGetBattleReportInfo = CMsgClientToGCGetBattleReportInfo {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetBattleReportInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetBattleReportInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetBattleReportInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetBattleReportInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetBattleReportInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportInfoResponse.battle_report_info_list)
    pub battle_report_info_list: ::protobuf::MessageField<CMsgBattleReportInfoList>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportInfoResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcget_battle_report_info_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetBattleReportInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportInfoResponse {
    fn default() -> &'a CMsgClientToGCGetBattleReportInfoResponse {
        <CMsgClientToGCGetBattleReportInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportInfoResponse {
    pub fn new() -> CMsgClientToGCGetBattleReportInfoResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCGetBattleReportInfoResponse.EResponse response = 2;

    pub fn response(&self) -> cmsg_client_to_gcget_battle_report_info_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_battle_report_info_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_battle_report_info_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_battle_report_info_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReportInfoList>(
            "battle_report_info_list",
            |m: &CMsgClientToGCGetBattleReportInfoResponse| { &m.battle_report_info_list },
            |m: &mut CMsgClientToGCGetBattleReportInfoResponse| { &mut m.battle_report_info_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCGetBattleReportInfoResponse| { &m.response },
            |m: &mut CMsgClientToGCGetBattleReportInfoResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetBattleReportInfoResponse>(
            "CMsgClientToGCGetBattleReportInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetBattleReportInfoResponse {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.battle_report_info_list)?;
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_report_info_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.battle_report_info_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportInfoResponse {
        CMsgClientToGCGetBattleReportInfoResponse::new()
    }

    fn clear(&mut self) {
        self.battle_report_info_list.clear();
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportInfoResponse {
        static instance: CMsgClientToGCGetBattleReportInfoResponse = CMsgClientToGCGetBattleReportInfoResponse {
            battle_report_info_list: ::protobuf::MessageField::none(),
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetBattleReportInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetBattleReportInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetBattleReportInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetBattleReportInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportInfoResponse`
pub mod cmsg_client_to_gcget_battle_report_info_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCGetBattleReportInfoResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 5,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                5 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_ePermissionDenied,
            EResponse::k_eNotSubscribedToDotaPlus,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCGetBattleReportInfoResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCGetBattleReportInfoResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAcknowledgeBattleReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcknowledgeBattleReport {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcknowledgeBattleReport.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcknowledgeBattleReport.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcknowledgeBattleReport.duration)
    pub duration: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAcknowledgeBattleReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcknowledgeBattleReport {
    fn default() -> &'a CMsgClientToGCAcknowledgeBattleReport {
        <CMsgClientToGCAcknowledgeBattleReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcknowledgeBattleReport {
    pub fn new() -> CMsgClientToGCAcknowledgeBattleReport {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgClientToGCAcknowledgeBattleReport| { &m.account_id },
            |m: &mut CMsgClientToGCAcknowledgeBattleReport| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgClientToGCAcknowledgeBattleReport| { &m.timestamp },
            |m: &mut CMsgClientToGCAcknowledgeBattleReport| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgClientToGCAcknowledgeBattleReport| { &m.duration },
            |m: &mut CMsgClientToGCAcknowledgeBattleReport| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAcknowledgeBattleReport>(
            "CMsgClientToGCAcknowledgeBattleReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAcknowledgeBattleReport {
    const NAME: &'static str = "CMsgClientToGCAcknowledgeBattleReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcknowledgeBattleReport {
        CMsgClientToGCAcknowledgeBattleReport::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcknowledgeBattleReport {
        static instance: CMsgClientToGCAcknowledgeBattleReport = CMsgClientToGCAcknowledgeBattleReport {
            account_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAcknowledgeBattleReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAcknowledgeBattleReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAcknowledgeBattleReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAcknowledgeBattleReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCAcknowledgeBattleReportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcknowledgeBattleReportResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcknowledgeBattleReportResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcacknowledge_battle_report_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCAcknowledgeBattleReportResponse.shards_awarded)
    pub shards_awarded: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCAcknowledgeBattleReportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcknowledgeBattleReportResponse {
    fn default() -> &'a CMsgClientToGCAcknowledgeBattleReportResponse {
        <CMsgClientToGCAcknowledgeBattleReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcknowledgeBattleReportResponse {
    pub fn new() -> CMsgClientToGCAcknowledgeBattleReportResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcacknowledge_battle_report_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcacknowledge_battle_report_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcacknowledge_battle_report_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcacknowledge_battle_report_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 shards_awarded = 2;

    pub fn shards_awarded(&self) -> u32 {
        self.shards_awarded.unwrap_or(0)
    }

    pub fn clear_shards_awarded(&mut self) {
        self.shards_awarded = ::std::option::Option::None;
    }

    pub fn has_shards_awarded(&self) -> bool {
        self.shards_awarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shards_awarded(&mut self, v: u32) {
        self.shards_awarded = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCAcknowledgeBattleReportResponse| { &m.response },
            |m: &mut CMsgClientToGCAcknowledgeBattleReportResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shards_awarded",
            |m: &CMsgClientToGCAcknowledgeBattleReportResponse| { &m.shards_awarded },
            |m: &mut CMsgClientToGCAcknowledgeBattleReportResponse| { &mut m.shards_awarded },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCAcknowledgeBattleReportResponse>(
            "CMsgClientToGCAcknowledgeBattleReportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCAcknowledgeBattleReportResponse {
    const NAME: &'static str = "CMsgClientToGCAcknowledgeBattleReportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.shards_awarded = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.shards_awarded {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.shards_awarded {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcknowledgeBattleReportResponse {
        CMsgClientToGCAcknowledgeBattleReportResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.shards_awarded = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcknowledgeBattleReportResponse {
        static instance: CMsgClientToGCAcknowledgeBattleReportResponse = CMsgClientToGCAcknowledgeBattleReportResponse {
            response: ::std::option::Option::None,
            shards_awarded: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCAcknowledgeBattleReportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCAcknowledgeBattleReportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCAcknowledgeBattleReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAcknowledgeBattleReportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCAcknowledgeBattleReportResponse`
pub mod cmsg_client_to_gcacknowledge_battle_report_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eUnableToLoadBattleReport)
        k_eUnableToLoadBattleReport = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eAlreadyAcknowledged)
        k_eAlreadyAcknowledged = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eUnknownReport)
        k_eUnknownReport = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eNotEnoughGamesPlayed)
        k_eNotEnoughGamesPlayed = 10,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                6 => ::std::option::Option::Some(EResponse::k_eUnableToLoadBattleReport),
                7 => ::std::option::Option::Some(EResponse::k_eAlreadyAcknowledged),
                8 => ::std::option::Option::Some(EResponse::k_eUnknownReport),
                9 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                10 => ::std::option::Option::Some(EResponse::k_eNotEnoughGamesPlayed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eUnableToLoadBattleReport" => ::std::option::Option::Some(EResponse::k_eUnableToLoadBattleReport),
                "k_eAlreadyAcknowledged" => ::std::option::Option::Some(EResponse::k_eAlreadyAcknowledged),
                "k_eUnknownReport" => ::std::option::Option::Some(EResponse::k_eUnknownReport),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                "k_eNotEnoughGamesPlayed" => ::std::option::Option::Some(EResponse::k_eNotEnoughGamesPlayed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_ePermissionDenied,
            EResponse::k_eUnableToLoadBattleReport,
            EResponse::k_eAlreadyAcknowledged,
            EResponse::k_eUnknownReport,
            EResponse::k_eNotSubscribedToDotaPlus,
            EResponse::k_eNotEnoughGamesPlayed,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCAcknowledgeBattleReportResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCAcknowledgeBattleReportResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetBattleReportMatchHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportMatchHistory {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportMatchHistory.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportMatchHistory.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportMatchHistory.duration)
    pub duration: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetBattleReportMatchHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportMatchHistory {
    fn default() -> &'a CMsgClientToGCGetBattleReportMatchHistory {
        <CMsgClientToGCGetBattleReportMatchHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportMatchHistory {
    pub fn new() -> CMsgClientToGCGetBattleReportMatchHistory {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgClientToGCGetBattleReportMatchHistory| { &m.account_id },
            |m: &mut CMsgClientToGCGetBattleReportMatchHistory| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgClientToGCGetBattleReportMatchHistory| { &m.timestamp },
            |m: &mut CMsgClientToGCGetBattleReportMatchHistory| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgClientToGCGetBattleReportMatchHistory| { &m.duration },
            |m: &mut CMsgClientToGCGetBattleReportMatchHistory| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetBattleReportMatchHistory>(
            "CMsgClientToGCGetBattleReportMatchHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetBattleReportMatchHistory {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportMatchHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportMatchHistory {
        CMsgClientToGCGetBattleReportMatchHistory::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportMatchHistory {
        static instance: CMsgClientToGCGetBattleReportMatchHistory = CMsgClientToGCGetBattleReportMatchHistory {
            account_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetBattleReportMatchHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetBattleReportMatchHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetBattleReportMatchHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetBattleReportMatchHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportMatchHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcget_battle_report_match_history_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.games)
    pub games: ::protobuf::MessageField<CMsgBattleReport_GameList>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportMatchHistoryResponse {
    fn default() -> &'a CMsgClientToGCGetBattleReportMatchHistoryResponse {
        <CMsgClientToGCGetBattleReportMatchHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportMatchHistoryResponse {
    pub fn new() -> CMsgClientToGCGetBattleReportMatchHistoryResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcget_battle_report_match_history_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_battle_report_match_history_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_battle_report_match_history_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_battle_report_match_history_response::EResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgClientToGCGetBattleReportMatchHistoryResponse| { &m.response },
            |m: &mut CMsgClientToGCGetBattleReportMatchHistoryResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBattleReport_GameList>(
            "games",
            |m: &CMsgClientToGCGetBattleReportMatchHistoryResponse| { &m.games },
            |m: &mut CMsgClientToGCGetBattleReportMatchHistoryResponse| { &mut m.games },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCGetBattleReportMatchHistoryResponse>(
            "CMsgClientToGCGetBattleReportMatchHistoryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCGetBattleReportMatchHistoryResponse {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportMatchHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.games)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.games.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.games.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportMatchHistoryResponse {
        CMsgClientToGCGetBattleReportMatchHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.games.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportMatchHistoryResponse {
        static instance: CMsgClientToGCGetBattleReportMatchHistoryResponse = CMsgClientToGCGetBattleReportMatchHistoryResponse {
            response: ::std::option::Option::None,
            games: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCGetBattleReportMatchHistoryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCGetBattleReportMatchHistoryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCGetBattleReportMatchHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetBattleReportMatchHistoryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportMatchHistoryResponse`
pub mod cmsg_client_to_gcget_battle_report_match_history_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 6,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                6 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_ePermissionDenied,
            EResponse::k_eNotSubscribedToDotaPlus,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.CMsgBattleReport_HighlightType)
pub enum CMsgBattleReport_HighlightType {
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eHighlightTypeInvalid)
    k_eHighlightTypeInvalid = -1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eGameWinrate)
    k_eGameWinrate = 0,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eLaneWinrate)
    k_eLaneWinrate = 1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMMRDelta)
    k_eMMRDelta = 2,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eNumHeroesPlayed)
    k_eNumHeroesPlayed = 3,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eNumGamesPlayed)
    k_eNumGamesPlayed = 4,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAveragePowerRunesTaken)
    k_eAveragePowerRunesTaken = 5,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageBountyRunesTaken)
    k_eAverageBountyRunesTaken = 6,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalKillEnemyT1First)
    k_eTotalKillEnemyT1First = 7,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalRoshanKills)
    k_eTotalRoshanKills = 8,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalDewards)
    k_eTotalDewards = 9,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalCampsStacked)
    k_eTotalCampsStacked = 10,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxWinstreak)
    k_eMaxWinstreak = 11,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageDewards)
    k_eAverageDewards = 12,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageKills)
    k_eAverageKills = 13,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxKills)
    k_eMaxKills = 14,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageAssists)
    k_eAverageAssists = 15,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxAssists)
    k_eMaxAssists = 16,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageDeaths)
    k_eAverageDeaths = 17,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMinDeaths)
    k_eMinDeaths = 18,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageCampsStacked)
    k_eAverageCampsStacked = 19,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalLastHits)
    k_eTotalLastHits = 20,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageLastHits)
    k_eAverageLastHits = 21,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalDenies)
    k_eTotalDenies = 22,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageDenies)
    k_eAverageDenies = 23,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalGamesWithRoshanAdvantage)
    k_eTotalGamesWithRoshanAdvantage = 24,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_ePercentGamesWithRoshanAdvantage)
    k_ePercentGamesWithRoshanAdvantage = 25,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageStunDuration)
    k_eAverageStunDuration = 26,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalStunDuration)
    k_eTotalStunDuration = 27,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageTeleportsUsed)
    k_eAverageTeleportsUsed = 28,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalTeleportsUsed)
    k_eTotalTeleportsUsed = 29,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageHeroDamage)
    k_eAverageHeroDamage = 30,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalHeroDamage)
    k_eTotalHeroDamage = 31,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageHeroHealing)
    k_eAverageHeroHealing = 32,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalHeroHealing)
    k_eTotalHeroHealing = 33,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageTowerDamage)
    k_eAverageTowerDamage = 34,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eTotalTowerDamage)
    k_eTotalTowerDamage = 35,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxLossStreak)
    k_eMaxLossStreak = 36,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageGameDuration)
    k_eAverageGameDuration = 37,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxGameDuration)
    k_eMaxGameDuration = 38,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMinGameDuration)
    k_eMinGameDuration = 39,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageWinDuration)
    k_eAverageWinDuration = 40,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxWinDuration)
    k_eMaxWinDuration = 41,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMinWinDuration)
    k_eMinWinDuration = 42,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageLossDuration)
    k_eAverageLossDuration = 43,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxLossDuration)
    k_eMaxLossDuration = 44,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMinLossDuration)
    k_eMinLossDuration = 45,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_ePctGamesEnemyT1TakenFirst)
    k_ePctGamesEnemyT1TakenFirst = 46,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxCampsStacked)
    k_eMaxCampsStacked = 47,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxDewards)
    k_eMaxDewards = 48,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxRoshanKills)
    k_eMaxRoshanKills = 49,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxBountyRunesTaken)
    k_eMaxBountyRunesTaken = 50,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxPowerRunesTaken)
    k_eMaxPowerRunesTaken = 51,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxDeaths)
    k_eMaxDeaths = 52,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxLastHits)
    k_eMaxLastHits = 53,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxDenies)
    k_eMaxDenies = 54,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eRadiantWinRate)
    k_eRadiantWinRate = 55,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eDireWinRate)
    k_eDireWinRate = 56,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eRadiantGameCount)
    k_eRadiantGameCount = 57,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eDireGameCount)
    k_eDireGameCount = 58,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxDamage)
    k_eMaxDamage = 59,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxHealing)
    k_eMaxHealing = 60,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxTowerDamage)
    k_eMaxTowerDamage = 61,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageGPM)
    k_eAverageGPM = 62,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxGPM)
    k_eMaxGPM = 63,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eAverageXPM)
    k_eAverageXPM = 64,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightType.k_eMaxXPM)
    k_eMaxXPM = 65,
}

impl ::protobuf::Enum for CMsgBattleReport_HighlightType {
    const NAME: &'static str = "CMsgBattleReport_HighlightType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_HighlightType> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eHighlightTypeInvalid),
            0 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eGameWinrate),
            1 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eLaneWinrate),
            2 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMMRDelta),
            3 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eNumHeroesPlayed),
            4 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eNumGamesPlayed),
            5 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAveragePowerRunesTaken),
            6 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageBountyRunesTaken),
            7 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalKillEnemyT1First),
            8 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalRoshanKills),
            9 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalDewards),
            10 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalCampsStacked),
            11 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxWinstreak),
            12 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDewards),
            13 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageKills),
            14 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxKills),
            15 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageAssists),
            16 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxAssists),
            17 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDeaths),
            18 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinDeaths),
            19 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageCampsStacked),
            20 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalLastHits),
            21 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageLastHits),
            22 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalDenies),
            23 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDenies),
            24 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalGamesWithRoshanAdvantage),
            25 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_ePercentGamesWithRoshanAdvantage),
            26 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageStunDuration),
            27 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalStunDuration),
            28 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageTeleportsUsed),
            29 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalTeleportsUsed),
            30 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageHeroDamage),
            31 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalHeroDamage),
            32 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageHeroHealing),
            33 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalHeroHealing),
            34 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageTowerDamage),
            35 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalTowerDamage),
            36 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLossStreak),
            37 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageGameDuration),
            38 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxGameDuration),
            39 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinGameDuration),
            40 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageWinDuration),
            41 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxWinDuration),
            42 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinWinDuration),
            43 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageLossDuration),
            44 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLossDuration),
            45 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinLossDuration),
            46 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_ePctGamesEnemyT1TakenFirst),
            47 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxCampsStacked),
            48 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDewards),
            49 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxRoshanKills),
            50 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxBountyRunesTaken),
            51 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxPowerRunesTaken),
            52 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDeaths),
            53 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLastHits),
            54 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDenies),
            55 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eRadiantWinRate),
            56 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eDireWinRate),
            57 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eRadiantGameCount),
            58 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eDireGameCount),
            59 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDamage),
            60 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxHealing),
            61 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxTowerDamage),
            62 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageGPM),
            63 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxGPM),
            64 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageXPM),
            65 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxXPM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_HighlightType> {
        match str {
            "k_eHighlightTypeInvalid" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eHighlightTypeInvalid),
            "k_eGameWinrate" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eGameWinrate),
            "k_eLaneWinrate" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eLaneWinrate),
            "k_eMMRDelta" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMMRDelta),
            "k_eNumHeroesPlayed" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eNumHeroesPlayed),
            "k_eNumGamesPlayed" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eNumGamesPlayed),
            "k_eAveragePowerRunesTaken" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAveragePowerRunesTaken),
            "k_eAverageBountyRunesTaken" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageBountyRunesTaken),
            "k_eTotalKillEnemyT1First" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalKillEnemyT1First),
            "k_eTotalRoshanKills" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalRoshanKills),
            "k_eTotalDewards" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalDewards),
            "k_eTotalCampsStacked" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalCampsStacked),
            "k_eMaxWinstreak" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxWinstreak),
            "k_eAverageDewards" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDewards),
            "k_eAverageKills" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageKills),
            "k_eMaxKills" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxKills),
            "k_eAverageAssists" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageAssists),
            "k_eMaxAssists" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxAssists),
            "k_eAverageDeaths" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDeaths),
            "k_eMinDeaths" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinDeaths),
            "k_eAverageCampsStacked" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageCampsStacked),
            "k_eTotalLastHits" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalLastHits),
            "k_eAverageLastHits" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageLastHits),
            "k_eTotalDenies" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalDenies),
            "k_eAverageDenies" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDenies),
            "k_eTotalGamesWithRoshanAdvantage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalGamesWithRoshanAdvantage),
            "k_ePercentGamesWithRoshanAdvantage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_ePercentGamesWithRoshanAdvantage),
            "k_eAverageStunDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageStunDuration),
            "k_eTotalStunDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalStunDuration),
            "k_eAverageTeleportsUsed" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageTeleportsUsed),
            "k_eTotalTeleportsUsed" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalTeleportsUsed),
            "k_eAverageHeroDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageHeroDamage),
            "k_eTotalHeroDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalHeroDamage),
            "k_eAverageHeroHealing" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageHeroHealing),
            "k_eTotalHeroHealing" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalHeroHealing),
            "k_eAverageTowerDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageTowerDamage),
            "k_eTotalTowerDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalTowerDamage),
            "k_eMaxLossStreak" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLossStreak),
            "k_eAverageGameDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageGameDuration),
            "k_eMaxGameDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxGameDuration),
            "k_eMinGameDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinGameDuration),
            "k_eAverageWinDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageWinDuration),
            "k_eMaxWinDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxWinDuration),
            "k_eMinWinDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinWinDuration),
            "k_eAverageLossDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageLossDuration),
            "k_eMaxLossDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLossDuration),
            "k_eMinLossDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinLossDuration),
            "k_ePctGamesEnemyT1TakenFirst" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_ePctGamesEnemyT1TakenFirst),
            "k_eMaxCampsStacked" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxCampsStacked),
            "k_eMaxDewards" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDewards),
            "k_eMaxRoshanKills" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxRoshanKills),
            "k_eMaxBountyRunesTaken" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxBountyRunesTaken),
            "k_eMaxPowerRunesTaken" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxPowerRunesTaken),
            "k_eMaxDeaths" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDeaths),
            "k_eMaxLastHits" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLastHits),
            "k_eMaxDenies" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDenies),
            "k_eRadiantWinRate" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eRadiantWinRate),
            "k_eDireWinRate" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eDireWinRate),
            "k_eRadiantGameCount" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eRadiantGameCount),
            "k_eDireGameCount" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eDireGameCount),
            "k_eMaxDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDamage),
            "k_eMaxHealing" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxHealing),
            "k_eMaxTowerDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxTowerDamage),
            "k_eAverageGPM" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageGPM),
            "k_eMaxGPM" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxGPM),
            "k_eAverageXPM" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageXPM),
            "k_eMaxXPM" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxXPM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_HighlightType] = &[
        CMsgBattleReport_HighlightType::k_eHighlightTypeInvalid,
        CMsgBattleReport_HighlightType::k_eGameWinrate,
        CMsgBattleReport_HighlightType::k_eLaneWinrate,
        CMsgBattleReport_HighlightType::k_eMMRDelta,
        CMsgBattleReport_HighlightType::k_eNumHeroesPlayed,
        CMsgBattleReport_HighlightType::k_eNumGamesPlayed,
        CMsgBattleReport_HighlightType::k_eAveragePowerRunesTaken,
        CMsgBattleReport_HighlightType::k_eAverageBountyRunesTaken,
        CMsgBattleReport_HighlightType::k_eTotalKillEnemyT1First,
        CMsgBattleReport_HighlightType::k_eTotalRoshanKills,
        CMsgBattleReport_HighlightType::k_eTotalDewards,
        CMsgBattleReport_HighlightType::k_eTotalCampsStacked,
        CMsgBattleReport_HighlightType::k_eMaxWinstreak,
        CMsgBattleReport_HighlightType::k_eAverageDewards,
        CMsgBattleReport_HighlightType::k_eAverageKills,
        CMsgBattleReport_HighlightType::k_eMaxKills,
        CMsgBattleReport_HighlightType::k_eAverageAssists,
        CMsgBattleReport_HighlightType::k_eMaxAssists,
        CMsgBattleReport_HighlightType::k_eAverageDeaths,
        CMsgBattleReport_HighlightType::k_eMinDeaths,
        CMsgBattleReport_HighlightType::k_eAverageCampsStacked,
        CMsgBattleReport_HighlightType::k_eTotalLastHits,
        CMsgBattleReport_HighlightType::k_eAverageLastHits,
        CMsgBattleReport_HighlightType::k_eTotalDenies,
        CMsgBattleReport_HighlightType::k_eAverageDenies,
        CMsgBattleReport_HighlightType::k_eTotalGamesWithRoshanAdvantage,
        CMsgBattleReport_HighlightType::k_ePercentGamesWithRoshanAdvantage,
        CMsgBattleReport_HighlightType::k_eAverageStunDuration,
        CMsgBattleReport_HighlightType::k_eTotalStunDuration,
        CMsgBattleReport_HighlightType::k_eAverageTeleportsUsed,
        CMsgBattleReport_HighlightType::k_eTotalTeleportsUsed,
        CMsgBattleReport_HighlightType::k_eAverageHeroDamage,
        CMsgBattleReport_HighlightType::k_eTotalHeroDamage,
        CMsgBattleReport_HighlightType::k_eAverageHeroHealing,
        CMsgBattleReport_HighlightType::k_eTotalHeroHealing,
        CMsgBattleReport_HighlightType::k_eAverageTowerDamage,
        CMsgBattleReport_HighlightType::k_eTotalTowerDamage,
        CMsgBattleReport_HighlightType::k_eMaxLossStreak,
        CMsgBattleReport_HighlightType::k_eAverageGameDuration,
        CMsgBattleReport_HighlightType::k_eMaxGameDuration,
        CMsgBattleReport_HighlightType::k_eMinGameDuration,
        CMsgBattleReport_HighlightType::k_eAverageWinDuration,
        CMsgBattleReport_HighlightType::k_eMaxWinDuration,
        CMsgBattleReport_HighlightType::k_eMinWinDuration,
        CMsgBattleReport_HighlightType::k_eAverageLossDuration,
        CMsgBattleReport_HighlightType::k_eMaxLossDuration,
        CMsgBattleReport_HighlightType::k_eMinLossDuration,
        CMsgBattleReport_HighlightType::k_ePctGamesEnemyT1TakenFirst,
        CMsgBattleReport_HighlightType::k_eMaxCampsStacked,
        CMsgBattleReport_HighlightType::k_eMaxDewards,
        CMsgBattleReport_HighlightType::k_eMaxRoshanKills,
        CMsgBattleReport_HighlightType::k_eMaxBountyRunesTaken,
        CMsgBattleReport_HighlightType::k_eMaxPowerRunesTaken,
        CMsgBattleReport_HighlightType::k_eMaxDeaths,
        CMsgBattleReport_HighlightType::k_eMaxLastHits,
        CMsgBattleReport_HighlightType::k_eMaxDenies,
        CMsgBattleReport_HighlightType::k_eRadiantWinRate,
        CMsgBattleReport_HighlightType::k_eDireWinRate,
        CMsgBattleReport_HighlightType::k_eRadiantGameCount,
        CMsgBattleReport_HighlightType::k_eDireGameCount,
        CMsgBattleReport_HighlightType::k_eMaxDamage,
        CMsgBattleReport_HighlightType::k_eMaxHealing,
        CMsgBattleReport_HighlightType::k_eMaxTowerDamage,
        CMsgBattleReport_HighlightType::k_eAverageGPM,
        CMsgBattleReport_HighlightType::k_eMaxGPM,
        CMsgBattleReport_HighlightType::k_eAverageXPM,
        CMsgBattleReport_HighlightType::k_eMaxXPM,
    ];
}

impl ::protobuf::EnumFull for CMsgBattleReport_HighlightType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CMsgBattleReport_HighlightType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CMsgBattleReport_HighlightType::k_eHighlightTypeInvalid => 0,
            CMsgBattleReport_HighlightType::k_eGameWinrate => 1,
            CMsgBattleReport_HighlightType::k_eLaneWinrate => 2,
            CMsgBattleReport_HighlightType::k_eMMRDelta => 3,
            CMsgBattleReport_HighlightType::k_eNumHeroesPlayed => 4,
            CMsgBattleReport_HighlightType::k_eNumGamesPlayed => 5,
            CMsgBattleReport_HighlightType::k_eAveragePowerRunesTaken => 6,
            CMsgBattleReport_HighlightType::k_eAverageBountyRunesTaken => 7,
            CMsgBattleReport_HighlightType::k_eTotalKillEnemyT1First => 8,
            CMsgBattleReport_HighlightType::k_eTotalRoshanKills => 9,
            CMsgBattleReport_HighlightType::k_eTotalDewards => 10,
            CMsgBattleReport_HighlightType::k_eTotalCampsStacked => 11,
            CMsgBattleReport_HighlightType::k_eMaxWinstreak => 12,
            CMsgBattleReport_HighlightType::k_eAverageDewards => 13,
            CMsgBattleReport_HighlightType::k_eAverageKills => 14,
            CMsgBattleReport_HighlightType::k_eMaxKills => 15,
            CMsgBattleReport_HighlightType::k_eAverageAssists => 16,
            CMsgBattleReport_HighlightType::k_eMaxAssists => 17,
            CMsgBattleReport_HighlightType::k_eAverageDeaths => 18,
            CMsgBattleReport_HighlightType::k_eMinDeaths => 19,
            CMsgBattleReport_HighlightType::k_eAverageCampsStacked => 20,
            CMsgBattleReport_HighlightType::k_eTotalLastHits => 21,
            CMsgBattleReport_HighlightType::k_eAverageLastHits => 22,
            CMsgBattleReport_HighlightType::k_eTotalDenies => 23,
            CMsgBattleReport_HighlightType::k_eAverageDenies => 24,
            CMsgBattleReport_HighlightType::k_eTotalGamesWithRoshanAdvantage => 25,
            CMsgBattleReport_HighlightType::k_ePercentGamesWithRoshanAdvantage => 26,
            CMsgBattleReport_HighlightType::k_eAverageStunDuration => 27,
            CMsgBattleReport_HighlightType::k_eTotalStunDuration => 28,
            CMsgBattleReport_HighlightType::k_eAverageTeleportsUsed => 29,
            CMsgBattleReport_HighlightType::k_eTotalTeleportsUsed => 30,
            CMsgBattleReport_HighlightType::k_eAverageHeroDamage => 31,
            CMsgBattleReport_HighlightType::k_eTotalHeroDamage => 32,
            CMsgBattleReport_HighlightType::k_eAverageHeroHealing => 33,
            CMsgBattleReport_HighlightType::k_eTotalHeroHealing => 34,
            CMsgBattleReport_HighlightType::k_eAverageTowerDamage => 35,
            CMsgBattleReport_HighlightType::k_eTotalTowerDamage => 36,
            CMsgBattleReport_HighlightType::k_eMaxLossStreak => 37,
            CMsgBattleReport_HighlightType::k_eAverageGameDuration => 38,
            CMsgBattleReport_HighlightType::k_eMaxGameDuration => 39,
            CMsgBattleReport_HighlightType::k_eMinGameDuration => 40,
            CMsgBattleReport_HighlightType::k_eAverageWinDuration => 41,
            CMsgBattleReport_HighlightType::k_eMaxWinDuration => 42,
            CMsgBattleReport_HighlightType::k_eMinWinDuration => 43,
            CMsgBattleReport_HighlightType::k_eAverageLossDuration => 44,
            CMsgBattleReport_HighlightType::k_eMaxLossDuration => 45,
            CMsgBattleReport_HighlightType::k_eMinLossDuration => 46,
            CMsgBattleReport_HighlightType::k_ePctGamesEnemyT1TakenFirst => 47,
            CMsgBattleReport_HighlightType::k_eMaxCampsStacked => 48,
            CMsgBattleReport_HighlightType::k_eMaxDewards => 49,
            CMsgBattleReport_HighlightType::k_eMaxRoshanKills => 50,
            CMsgBattleReport_HighlightType::k_eMaxBountyRunesTaken => 51,
            CMsgBattleReport_HighlightType::k_eMaxPowerRunesTaken => 52,
            CMsgBattleReport_HighlightType::k_eMaxDeaths => 53,
            CMsgBattleReport_HighlightType::k_eMaxLastHits => 54,
            CMsgBattleReport_HighlightType::k_eMaxDenies => 55,
            CMsgBattleReport_HighlightType::k_eRadiantWinRate => 56,
            CMsgBattleReport_HighlightType::k_eDireWinRate => 57,
            CMsgBattleReport_HighlightType::k_eRadiantGameCount => 58,
            CMsgBattleReport_HighlightType::k_eDireGameCount => 59,
            CMsgBattleReport_HighlightType::k_eMaxDamage => 60,
            CMsgBattleReport_HighlightType::k_eMaxHealing => 61,
            CMsgBattleReport_HighlightType::k_eMaxTowerDamage => 62,
            CMsgBattleReport_HighlightType::k_eAverageGPM => 63,
            CMsgBattleReport_HighlightType::k_eMaxGPM => 64,
            CMsgBattleReport_HighlightType::k_eAverageXPM => 65,
            CMsgBattleReport_HighlightType::k_eMaxXPM => 66,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_HighlightType {
    fn default() -> Self {
        CMsgBattleReport_HighlightType::k_eHighlightTypeInvalid
    }
}

impl CMsgBattleReport_HighlightType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CMsgBattleReport_HighlightType>("CMsgBattleReport_HighlightType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.CMsgBattleReport_HighlightCategory)
pub enum CMsgBattleReport_HighlightCategory {
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightCategory.k_eHighlightGeneral)
    k_eHighlightGeneral = 0,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightCategory.k_eHighlightHero)
    k_eHighlightHero = 1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightCategory.k_eHighlightRole)
    k_eHighlightRole = 2,
}

impl ::protobuf::Enum for CMsgBattleReport_HighlightCategory {
    const NAME: &'static str = "CMsgBattleReport_HighlightCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_HighlightCategory> {
        match value {
            0 => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightGeneral),
            1 => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightHero),
            2 => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightRole),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_HighlightCategory> {
        match str {
            "k_eHighlightGeneral" => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightGeneral),
            "k_eHighlightHero" => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightHero),
            "k_eHighlightRole" => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightRole),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_HighlightCategory] = &[
        CMsgBattleReport_HighlightCategory::k_eHighlightGeneral,
        CMsgBattleReport_HighlightCategory::k_eHighlightHero,
        CMsgBattleReport_HighlightCategory::k_eHighlightRole,
    ];
}

impl ::protobuf::EnumFull for CMsgBattleReport_HighlightCategory {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CMsgBattleReport_HighlightCategory").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CMsgBattleReport_HighlightCategory {
    fn default() -> Self {
        CMsgBattleReport_HighlightCategory::k_eHighlightGeneral
    }
}

impl CMsgBattleReport_HighlightCategory {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CMsgBattleReport_HighlightCategory>("CMsgBattleReport_HighlightCategory")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.CMsgBattleReport_Role)
pub enum CMsgBattleReport_Role {
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_Role.k_eUnknownRole)
    k_eUnknownRole = -1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_Role.k_eSafelane)
    k_eSafelane = 0,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_Role.k_eMidlane)
    k_eMidlane = 1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_Role.k_eOfflane)
    k_eOfflane = 2,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_Role.k_eSoftSupport)
    k_eSoftSupport = 3,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_Role.k_eHardSupport)
    k_eHardSupport = 4,
}

impl ::protobuf::Enum for CMsgBattleReport_Role {
    const NAME: &'static str = "CMsgBattleReport_Role";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_Role> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eUnknownRole),
            0 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eSafelane),
            1 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eMidlane),
            2 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eOfflane),
            3 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eSoftSupport),
            4 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eHardSupport),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_Role> {
        match str {
            "k_eUnknownRole" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eUnknownRole),
            "k_eSafelane" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eSafelane),
            "k_eMidlane" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eMidlane),
            "k_eOfflane" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eOfflane),
            "k_eSoftSupport" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eSoftSupport),
            "k_eHardSupport" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eHardSupport),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_Role] = &[
        CMsgBattleReport_Role::k_eUnknownRole,
        CMsgBattleReport_Role::k_eSafelane,
        CMsgBattleReport_Role::k_eMidlane,
        CMsgBattleReport_Role::k_eOfflane,
        CMsgBattleReport_Role::k_eSoftSupport,
        CMsgBattleReport_Role::k_eHardSupport,
    ];
}

impl ::protobuf::EnumFull for CMsgBattleReport_Role {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CMsgBattleReport_Role").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CMsgBattleReport_Role::k_eUnknownRole => 0,
            CMsgBattleReport_Role::k_eSafelane => 1,
            CMsgBattleReport_Role::k_eMidlane => 2,
            CMsgBattleReport_Role::k_eOfflane => 3,
            CMsgBattleReport_Role::k_eSoftSupport => 4,
            CMsgBattleReport_Role::k_eHardSupport => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_Role {
    fn default() -> Self {
        CMsgBattleReport_Role::k_eUnknownRole
    }
}

impl CMsgBattleReport_Role {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CMsgBattleReport_Role>("CMsgBattleReport_Role")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.CMsgBattleReport_CompareContext)
pub enum CMsgBattleReport_CompareContext {
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_CompareContext.k_eCompareContextInvalid)
    k_eCompareContextInvalid = -1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_CompareContext.k_eAbsoluteValue)
    k_eAbsoluteValue = 0,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_CompareContext.k_ePlayersOfSimilarRank)
    k_ePlayersOfSimilarRank = 1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_CompareContext.k_eAllPlayers)
    k_eAllPlayers = 2,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_CompareContext.k_ePlayersPersonalHistory)
    k_ePlayersPersonalHistory = 3,
}

impl ::protobuf::Enum for CMsgBattleReport_CompareContext {
    const NAME: &'static str = "CMsgBattleReport_CompareContext";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_CompareContext> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eCompareContextInvalid),
            0 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eAbsoluteValue),
            1 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_ePlayersOfSimilarRank),
            2 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eAllPlayers),
            3 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_ePlayersPersonalHistory),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_CompareContext> {
        match str {
            "k_eCompareContextInvalid" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eCompareContextInvalid),
            "k_eAbsoluteValue" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eAbsoluteValue),
            "k_ePlayersOfSimilarRank" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_ePlayersOfSimilarRank),
            "k_eAllPlayers" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eAllPlayers),
            "k_ePlayersPersonalHistory" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_ePlayersPersonalHistory),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_CompareContext] = &[
        CMsgBattleReport_CompareContext::k_eCompareContextInvalid,
        CMsgBattleReport_CompareContext::k_eAbsoluteValue,
        CMsgBattleReport_CompareContext::k_ePlayersOfSimilarRank,
        CMsgBattleReport_CompareContext::k_eAllPlayers,
        CMsgBattleReport_CompareContext::k_ePlayersPersonalHistory,
    ];
}

impl ::protobuf::EnumFull for CMsgBattleReport_CompareContext {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CMsgBattleReport_CompareContext").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CMsgBattleReport_CompareContext::k_eCompareContextInvalid => 0,
            CMsgBattleReport_CompareContext::k_eAbsoluteValue => 1,
            CMsgBattleReport_CompareContext::k_ePlayersOfSimilarRank => 2,
            CMsgBattleReport_CompareContext::k_eAllPlayers => 3,
            CMsgBattleReport_CompareContext::k_ePlayersPersonalHistory => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_CompareContext {
    fn default() -> Self {
        CMsgBattleReport_CompareContext::k_eCompareContextInvalid
    }
}

impl CMsgBattleReport_CompareContext {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CMsgBattleReport_CompareContext>("CMsgBattleReport_CompareContext")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.CMsgBattleReport_HighlightTier)
pub enum CMsgBattleReport_HighlightTier {
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightTier.k_eHighlightTierLow)
    k_eHighlightTierLow = -1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightTier.k_eHighlightTierNone)
    k_eHighlightTierNone = 0,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightTier.k_eHighlightTier1)
    k_eHighlightTier1 = 1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightTier.k_eHighlightTier2)
    k_eHighlightTier2 = 2,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightTier.k_eHighlightTier3)
    k_eHighlightTier3 = 3,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightTier.k_eHighlightTierCustom)
    k_eHighlightTierCustom = 4,
}

impl ::protobuf::Enum for CMsgBattleReport_HighlightTier {
    const NAME: &'static str = "CMsgBattleReport_HighlightTier";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_HighlightTier> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierLow),
            0 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierNone),
            1 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier1),
            2 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier2),
            3 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier3),
            4 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierCustom),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_HighlightTier> {
        match str {
            "k_eHighlightTierLow" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierLow),
            "k_eHighlightTierNone" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierNone),
            "k_eHighlightTier1" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier1),
            "k_eHighlightTier2" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier2),
            "k_eHighlightTier3" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier3),
            "k_eHighlightTierCustom" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierCustom),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_HighlightTier] = &[
        CMsgBattleReport_HighlightTier::k_eHighlightTierLow,
        CMsgBattleReport_HighlightTier::k_eHighlightTierNone,
        CMsgBattleReport_HighlightTier::k_eHighlightTier1,
        CMsgBattleReport_HighlightTier::k_eHighlightTier2,
        CMsgBattleReport_HighlightTier::k_eHighlightTier3,
        CMsgBattleReport_HighlightTier::k_eHighlightTierCustom,
    ];
}

impl ::protobuf::EnumFull for CMsgBattleReport_HighlightTier {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CMsgBattleReport_HighlightTier").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CMsgBattleReport_HighlightTier::k_eHighlightTierLow => 0,
            CMsgBattleReport_HighlightTier::k_eHighlightTierNone => 1,
            CMsgBattleReport_HighlightTier::k_eHighlightTier1 => 2,
            CMsgBattleReport_HighlightTier::k_eHighlightTier2 => 3,
            CMsgBattleReport_HighlightTier::k_eHighlightTier3 => 4,
            CMsgBattleReport_HighlightTier::k_eHighlightTierCustom => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_HighlightTier {
    fn default() -> Self {
        CMsgBattleReport_HighlightTier::k_eHighlightTierLow
    }
}

impl CMsgBattleReport_HighlightTier {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CMsgBattleReport_HighlightTier>("CMsgBattleReport_HighlightTier")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.CMsgBattleReport_HighlightRarity)
pub enum CMsgBattleReport_HighlightRarity {
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightRarity.k_eHighlightCommon)
    k_eHighlightCommon = 0,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightRarity.k_eHighlightUncommon)
    k_eHighlightUncommon = 1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_HighlightRarity.k_eHighlightRare)
    k_eHighlightRare = 2,
}

impl ::protobuf::Enum for CMsgBattleReport_HighlightRarity {
    const NAME: &'static str = "CMsgBattleReport_HighlightRarity";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_HighlightRarity> {
        match value {
            0 => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightCommon),
            1 => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightUncommon),
            2 => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightRare),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_HighlightRarity> {
        match str {
            "k_eHighlightCommon" => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightCommon),
            "k_eHighlightUncommon" => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightUncommon),
            "k_eHighlightRare" => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightRare),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_HighlightRarity] = &[
        CMsgBattleReport_HighlightRarity::k_eHighlightCommon,
        CMsgBattleReport_HighlightRarity::k_eHighlightUncommon,
        CMsgBattleReport_HighlightRarity::k_eHighlightRare,
    ];
}

impl ::protobuf::EnumFull for CMsgBattleReport_HighlightRarity {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CMsgBattleReport_HighlightRarity").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CMsgBattleReport_HighlightRarity {
    fn default() -> Self {
        CMsgBattleReport_HighlightRarity::k_eHighlightCommon
    }
}

impl CMsgBattleReport_HighlightRarity {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CMsgBattleReport_HighlightRarity>("CMsgBattleReport_HighlightRarity")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.CMsgBattleReport_EOutcome)
pub enum CMsgBattleReport_EOutcome {
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_EOutcome.k_eWin)
    k_eWin = 0,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_EOutcome.k_eLoss)
    k_eLoss = 1,
}

impl ::protobuf::Enum for CMsgBattleReport_EOutcome {
    const NAME: &'static str = "CMsgBattleReport_EOutcome";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_EOutcome> {
        match value {
            0 => ::std::option::Option::Some(CMsgBattleReport_EOutcome::k_eWin),
            1 => ::std::option::Option::Some(CMsgBattleReport_EOutcome::k_eLoss),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_EOutcome> {
        match str {
            "k_eWin" => ::std::option::Option::Some(CMsgBattleReport_EOutcome::k_eWin),
            "k_eLoss" => ::std::option::Option::Some(CMsgBattleReport_EOutcome::k_eLoss),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_EOutcome] = &[
        CMsgBattleReport_EOutcome::k_eWin,
        CMsgBattleReport_EOutcome::k_eLoss,
    ];
}

impl ::protobuf::EnumFull for CMsgBattleReport_EOutcome {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CMsgBattleReport_EOutcome").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CMsgBattleReport_EOutcome {
    fn default() -> Self {
        CMsgBattleReport_EOutcome::k_eWin
    }
}

impl CMsgBattleReport_EOutcome {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CMsgBattleReport_EOutcome>("CMsgBattleReport_EOutcome")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.CMsgBattleReport_ELaneOutcome)
pub enum CMsgBattleReport_ELaneOutcome {
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_ELaneOutcome.k_eUnknownLaneOutcome)
    k_eUnknownLaneOutcome = -1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_ELaneOutcome.k_eWonLane)
    k_eWonLane = 0,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_ELaneOutcome.k_eLostLane)
    k_eLostLane = 1,
    // @@protoc_insertion_point(enum_value:dota.CMsgBattleReport_ELaneOutcome.k_eEvenLane)
    k_eEvenLane = 2,
}

impl ::protobuf::Enum for CMsgBattleReport_ELaneOutcome {
    const NAME: &'static str = "CMsgBattleReport_ELaneOutcome";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_ELaneOutcome> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome),
            0 => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eWonLane),
            1 => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eLostLane),
            2 => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eEvenLane),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_ELaneOutcome> {
        match str {
            "k_eUnknownLaneOutcome" => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome),
            "k_eWonLane" => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eWonLane),
            "k_eLostLane" => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eLostLane),
            "k_eEvenLane" => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eEvenLane),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_ELaneOutcome] = &[
        CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome,
        CMsgBattleReport_ELaneOutcome::k_eWonLane,
        CMsgBattleReport_ELaneOutcome::k_eLostLane,
        CMsgBattleReport_ELaneOutcome::k_eEvenLane,
    ];
}

impl ::protobuf::EnumFull for CMsgBattleReport_ELaneOutcome {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CMsgBattleReport_ELaneOutcome").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome => 0,
            CMsgBattleReport_ELaneOutcome::k_eWonLane => 1,
            CMsgBattleReport_ELaneOutcome::k_eLostLane => 2,
            CMsgBattleReport_ELaneOutcome::k_eEvenLane => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_ELaneOutcome {
    fn default() -> Self {
        CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome
    }
}

impl CMsgBattleReport_ELaneOutcome {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CMsgBattleReport_ELaneOutcome>("CMsgBattleReport_ELaneOutcome")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n*dota_gcmessages_client_battle_report.proto\x12\x04dota\x1a\x13steamme\
    ssages.proto\x1a\x17dota_shared_enums.proto\x1a\x1cdota_gcmessages_commo\
    n.proto\x1a\x1cdota_gcmessages_webapi.proto\x1a\x16gcsdk_gcmessages.prot\
    o\x1a\x15base_gcmessages.proto\x1a\x15econ_gcmessages.proto\x1a\x1cdota_\
    gcmessages_client.proto\x1a\x15valveextensions.proto\"x\n\x1dCMsgClientT\
    oGCGetBattleReport\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x1a\n\x08durati\
    on\x18\x03\x20\x01(\rR\x08duration\"\xdb\r\n\x15CMsgBattleReport_Game\
    \x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\x14\n\x05kills\
    \x18\x02\x20\x01(\rR\x05kills\x12\x16\n\x06deaths\x18\x03\x20\x01(\rR\
    \x06deaths\x12\x18\n\x07assists\x18\x04\x20\x01(\rR\x07assists\x12\x1f\n\
    \x0brank_change\x18\x05\x20\x01(\x05R\nrankChange\x12\x1b\n\tlast_hits\
    \x18\x06\x20\x01(\rR\x08lastHits\x12\x16\n\x06denies\x18\x15\x20\x01(\rR\
    \x06denies\x12\x10\n\x03gpm\x18\x07\x20\x01(\rR\x03gpm\x12\x10\n\x03xpm\
    \x18\x08\x20\x01(\rR\x03xpm\x12/\n\x04role\x18\t\x20\x01(\x0e2\x1b.dota.\
    CMsgBattleReport_RoleR\x04role\x129\n\x07outcome\x18\n\x20\x01(\x0e2\x1f\
    .dota.CMsgBattleReport_EOutcomeR\x07outcome\x12F\n\x0clane_outcome\x18\
    \x0b\x20\x01(\x0e2#.dota.CMsgBattleReport_ELaneOutcomeR\x0blaneOutcome\
    \x12\x16\n\x06ranked\x18\x0c\x20\x01(\x08R\x06ranked\x12\x19\n\x08match_\
    id\x18\r\x20\x01(\x04R\x07matchId\x120\n\x14lane_selection_flags\x18\x0e\
    \x20\x01(\rR\x12laneSelectionFlags\x12-\n\x12predicted_position\x18\x0f\
    \x20\x01(\rR\x11predictedPosition\x12!\n\x0cseconds_dead\x18\x10\x20\x01\
    (\rR\x0bsecondsDead\x12!\n\x0cwinning_team\x18\x11\x20\x01(\rR\x0bwinnin\
    gTeam\x12\x1f\n\x0bplayer_slot\x18\x1c\x20\x01(\rR\nplayerSlot\x12\x1d\n\
    \nparty_game\x18\x13\x20\x01(\x08R\tpartyGame\x12\x1d\n\nstart_time\x18\
    \x14\x20\x01(\rR\tstartTime\x12!\n\x0cbounty_runes\x18\x16\x20\x01(\rR\
    \x0bbountyRunes\x12\x1f\n\x0bwater_runes\x18\x17\x20\x01(\rR\nwaterRunes\
    \x12\x1f\n\x0bpower_runes\x18\x18\x20\x01(\rR\npowerRunes\x12@\n\x1dtime\
    _enemy_t1_tower_destroyed\x18\x19\x20\x01(\rR\x19timeEnemyT1TowerDestroy\
    ed\x12F\n\x20time_friendly_t1_tower_destroyed\x18\x1a\x20\x01(\rR\x1ctim\
    eFriendlyT1TowerDestroyed\x12,\n\x12enemy_roshan_kills\x18\x1b\x20\x01(\
    \rR\x10enemyRoshanKills\x12%\n\x0eteleports_used\x18\x1d\x20\x01(\rR\rte\
    leportsUsed\x12\x18\n\x07dewards\x18\x1e\x20\x01(\rR\x07dewards\x12#\n\r\
    camps_stacked\x18\x1f\x20\x01(\rR\x0ccampsStacked\x12!\n\x0csupport_gold\
    \x18\x20\x20\x01(\rR\x0bsupportGold\x12\x1f\n\x0bhero_damage\x18!\x20\
    \x01(\rR\nheroDamage\x12!\n\x0chero_healing\x18\"\x20\x01(\rR\x0bheroHea\
    ling\x12!\n\x0ctower_damage\x18#\x20\x01(\rR\x0btowerDamage\x12+\n\x11su\
    ccessful_smokes\x18$\x20\x01(\rR\x10successfulSmokes\x12#\n\rstun_durati\
    on\x18%\x20\x01(\rR\x0cstunDuration\x12\x1a\n\x08duration\x18&\x20\x01(\
    \rR\x08duration\x122\n\x15friendly_roshan_kills\x18'\x20\x01(\rR\x13frie\
    ndlyRoshanKills\x12#\n\rprevious_rank\x18(\x20\x01(\x05R\x0cpreviousRank\
    \x12\x1b\n\tgame_mode\x18)\x20\x01(\rR\x08gameMode\x12\x1d\n\nlobby_type\
    \x18*\x20\x01(\rR\tlobbyType\x120\n\x14time_purchased_shard\x18+\x20\x01\
    (\x02R\x12timePurchasedShard\x124\n\x16time_purchased_scepter\x18,\x20\
    \x01(\x02R\x14timePurchasedScepter\x12\x14\n\x05item0\x18-\x20\x01(\x05R\
    \x05item0\x12\x14\n\x05item1\x18.\x20\x01(\x05R\x05item1\x12\x14\n\x05it\
    em2\x18/\x20\x01(\x05R\x05item2\x12\x14\n\x05item3\x180\x20\x01(\x05R\
    \x05item3\x12\x14\n\x05item4\x181\x20\x01(\x05R\x05item4\x12\x14\n\x05it\
    em5\x182\x20\x01(\x05R\x05item5\"N\n\x19CMsgBattleReport_GameList\x121\n\
    \x05games\x18\x01\x20\x03(\x0b2\x1b.dota.CMsgBattleReport_GameR\x05games\
    \"\x93\x06\n\x10CMsgBattleReport\x121\n\x05games\x18\x01\x20\x03(\x0b2\
    \x1b.dota.CMsgBattleReport_GameR\x05games\x12@\n\nhighlights\x18\x03\x20\
    \x01(\x0b2\x20.dota.CMsgBattleReportHighlightsR\nhighlights\x1a\xa1\x01\
    \n\x10HighlightGeneral\x12&\n\x0fwin_loss_window\x18\x01\x20\x01(\x05R\r\
    winLossWindow\x12\x1f\n\x0bwin_percent\x18\x02\x20\x01(\x02R\nwinPercent\
    \x12\x1b\n\tmmr_delta\x18\x03\x20\x01(\x05R\x08mmrDelta\x12'\n\x0fhighli\
    ght_score\x18\x04\x20\x01(\x02R\x0ehighlightScore\x1a\xe5\x03\n\tHighlig\
    ht\x12!\n\x0chighlight_id\x18\x01\x20\x02(\rR\x0bhighlightId\x12D\n\x08c\
    ategory\x18\x02\x20\x02(\x0e2(.dota.CMsgBattleReport_HighlightCategoryR\
    \x08category\x128\n\x04tier\x18\x03\x20\x01(\x0e2$.dota.CMsgBattleReport\
    _HighlightTierR\x04tier\x12>\n\x06rarity\x18\x04\x20\x01(\x0e2&.dota.CMs\
    gBattleReport_HighlightRarityR\x06rarity\x12\x14\n\x05score\x18\x05\x20\
    \x01(\x02R\x05score\x12\x1e\n\nconfidence\x18\x06\x20\x01(\x02R\nconfide\
    nce\x12\x17\n\x07hero_id\x18\x07\x20\x01(\rR\x06heroId\x12/\n\x04role\
    \x18\x08\x20\x01(\x0e2\x1b.dota.CMsgBattleReport_RoleR\x04role\x124\n\
    \x16comparison_delta_value\x18\t\x20\x01(\x02R\x14comparisonDeltaValue\
    \x12?\n\x07context\x18\n\x20\x01(\x0e2%.dota.CMsgBattleReport_CompareCon\
    textR\x07context\"\x91\x02\n\x14CMsgBattleReportInfo\x12\x1c\n\ttimestam\
    p\x18\x01\x20\x01(\rR\ttimestamp\x12\x1a\n\x08duration\x18\x02\x20\x01(\
    \rR\x08duration\x12\"\n\x0cacknowledged\x18\x03\x20\x01(\x08R\x0cacknowl\
    edged\x12(\n\x10featured_hero_id\x18\x04\x20\x01(\rR\x0efeaturedHeroId\
    \x12+\n\x11featured_position\x18\x05\x20\x01(\rR\x10featuredPosition\x12\
    !\n\x0cgames_played\x18\x06\x20\x01(\rR\x0bgamesPlayed\x12!\n\x0cmedal_c\
    ounts\x18\x07\x20\x03(\rR\x0bmedalCounts\"d\n\x18CMsgBattleReportInfoLis\
    t\x12H\n\x12battle_report_info\x18\x01\x20\x03(\x0b2\x1a.dota.CMsgBattle\
    ReportInfoR\x10battleReportInfo\"^\n\x1aCMsgBattleReportHighlights\x12@\
    \n\nhighlights\x18\x01\x20\x03(\x0b2\x20.dota.CMsgBattleReport.Highlight\
    R\nhighlights\"\x95\x16\n\x1eCMsgBattleReportAggregateStats\x12V\n\x06re\
    sult\x18\x01\x20\x03(\x0b2>.dota.CMsgBattleReportAggregateStats.CMsgBatt\
    leReportAggregateR\x06result\x1a@\n\x14CMsgBattleReportStat\x12\x12\n\
    \x04mean\x18\x01\x20\x01(\x02R\x04mean\x12\x14\n\x05stdev\x18\x02\x20\
    \x01(\x02R\x05stdev\x1a\xd8\x14\n\x19CMsgBattleReportAggregate\x12\x17\n\
    \x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12-\n\x12predicted_position\
    \x18\x02\x20\x01(\rR\x11predictedPosition\x12\x1d\n\ngame_count\x18\x03\
    \x20\x01(\rR\tgameCount\x12\x1b\n\twin_count\x18\x04\x20\x01(\rR\x08winC\
    ount\x12$\n\x0elane_win_count\x18\x05\x20\x01(\rR\x0claneWinCount\x12O\n\
    \x05kills\x18\x06\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStats.CMs\
    gBattleReportStatR\x05kills\x12Q\n\x06deaths\x18\x07\x20\x01(\x0b29.dota\
    .CMsgBattleReportAggregateStats.CMsgBattleReportStatR\x06deaths\x12S\n\
    \x07assists\x18\x08\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStats.C\
    MsgBattleReportStatR\x07assists\x12Z\n\x0brank_change\x18\t\x20\x01(\x0b\
    29.dota.CMsgBattleReportAggregateStats.CMsgBattleReportStatR\nrankChange\
    \x12V\n\tlast_hits\x18\n\x20\x01(\x0b29.dota.CMsgBattleReportAggregateSt\
    ats.CMsgBattleReportStatR\x08lastHits\x12Q\n\x06denies\x18\x0b\x20\x01(\
    \x0b29.dota.CMsgBattleReportAggregateStats.CMsgBattleReportStatR\x06deni\
    es\x12K\n\x03gpm\x18\x0c\x20\x01(\x0b29.dota.CMsgBattleReportAggregateSt\
    ats.CMsgBattleReportStatR\x03gpm\x12K\n\x03xpm\x18\r\x20\x01(\x0b29.dota\
    .CMsgBattleReportAggregateStats.CMsgBattleReportStatR\x03xpm\x12\\\n\x0c\
    seconds_dead\x18\x0e\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStats.\
    CMsgBattleReportStatR\x0bsecondsDead\x12\\\n\x0cbounty_runes\x18\x0f\x20\
    \x01(\x0b29.dota.CMsgBattleReportAggregateStats.CMsgBattleReportStatR\
    \x0bbountyRunes\x12Z\n\x0bwater_runes\x18\x10\x20\x01(\x0b29.dota.CMsgBa\
    ttleReportAggregateStats.CMsgBattleReportStatR\nwaterRunes\x12Z\n\x0bpow\
    er_runes\x18\x11\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStats.CMsg\
    BattleReportStatR\npowerRunes\x12{\n\x1dtime_enemy_t1_tower_destroyed\
    \x18\x12\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStats.CMsgBattleRe\
    portStatR\x19timeEnemyT1TowerDestroyed\x12\x81\x01\n\x20time_friendly_t1\
    _tower_destroyed\x18\x13\x20\x01(\x0b29.dota.CMsgBattleReportAggregateSt\
    ats.CMsgBattleReportStatR\x1ctimeFriendlyT1TowerDestroyed\x12g\n\x12enem\
    y_roshan_kills\x18\x14\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStat\
    s.CMsgBattleReportStatR\x10enemyRoshanKills\x12`\n\x0eteleports_used\x18\
    \x15\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStats.CMsgBattleReport\
    StatR\rteleportsUsed\x12S\n\x07dewards\x18\x16\x20\x01(\x0b29.dota.CMsgB\
    attleReportAggregateStats.CMsgBattleReportStatR\x07dewards\x12^\n\rcamps\
    _stacked\x18\x17\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStats.CMsg\
    BattleReportStatR\x0ccampsStacked\x12\\\n\x0csupport_gold\x18\x18\x20\
    \x01(\x0b29.dota.CMsgBattleReportAggregateStats.CMsgBattleReportStatR\
    \x0bsupportGold\x12Z\n\x0bhero_damage\x18\x19\x20\x01(\x0b29.dota.CMsgBa\
    ttleReportAggregateStats.CMsgBattleReportStatR\nheroDamage\x12\\\n\x0che\
    ro_healing\x18\x1a\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStats.CM\
    sgBattleReportStatR\x0bheroHealing\x12\\\n\x0ctower_damage\x18\x1b\x20\
    \x01(\x0b29.dota.CMsgBattleReportAggregateStats.CMsgBattleReportStatR\
    \x0btowerDamage\x12f\n\x11successful_smokes\x18\x1c\x20\x01(\x0b29.dota.\
    CMsgBattleReportAggregateStats.CMsgBattleReportStatR\x10successfulSmokes\
    \x12^\n\rstun_duration\x18\x1d\x20\x01(\x0b29.dota.CMsgBattleReportAggre\
    gateStats.CMsgBattleReportStatR\x0cstunDuration\x12U\n\x08duration\x18\
    \x1e\x20\x01(\x0b29.dota.CMsgBattleReportAggregateStats.CMsgBattleReport\
    StatR\x08duration\x12m\n\x15friendly_roshan_kills\x18\x1f\x20\x01(\x0b29\
    .dota.CMsgBattleReportAggregateStats.CMsgBattleReportStatR\x13friendlyRo\
    shanKills\"(\n&CMsgBattleReportAggregatedGeneralStats\"\xed\x04\n%CMsgCl\
    ientToGCGetBattleReportResponse\x12.\n\x06report\x18\x01\x20\x01(\x0b2\
    \x16.dota.CMsgBattleReportR\x06report\x12Q\n\x08response\x18\x02\x20\x01\
    (\x0e25.dota.CMsgClientToGCGetBattleReportResponse.EResponseR\x08respons\
    e\x12M\n\x0faggregate_stats\x18\x03\x20\x01(\x0b2$.dota.CMsgBattleReport\
    AggregateStatsR\x0eaggregateStats\x12.\n\x04info\x18\x04\x20\x01(\x0b2\
    \x1a.dota.CMsgBattleReportInfoR\x04info\"\xc1\x02\n\tEResponse\x12\x14\n\
    \x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eT\
    ooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x17\n\x13k_ePermissi\
    onDenied\x10\x04\x12\x1e\n\x1ak_eNotSubscribedToDotaPlus\x10\x05\x12\x18\
    \n\x14k_eInvalidParameters\x10\x06\x12\x1d\n\x19k_eUnableToGetPlusSubInf\
    o\x10\x07\x12\x1f\n\x1bk_eUnableToLoadBattleReport\x10\x08\x12\x1f\n\x1b\
    k_eUnableToSaveBattleReport\x10\t\x12\x1c\n\x18k_eUnableToGetAggregates\
    \x10\n\x12\x1b\n\x17k_eNotEnoughGamesPlayed\x10\x0b\"\xda\x02\n+CMsgClie\
    ntToGCGetBattleReportAggregateStats\x12u\n\x0eaggregate_keys\x18\x01\x20\
    \x03(\x0b2N.dota.CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleR\
    eportAggregateKeyR\raggregateKeys\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\
    \rR\ttimestamp\x12\x1a\n\x08duration\x18\x03\x20\x01(\rR\x08duration\x12\
    \x12\n\x04rank\x18\x04\x20\x01(\rR\x04rank\x1af\n\x1cCMsgBattleReportAgg\
    regateKey\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12-\n\x12p\
    redicted_position\x18\x02\x20\x01(\rR\x11predictedPosition\"\x89\x03\n3C\
    MsgClientToGCGetBattleReportAggregateStatsResponse\x12M\n\x0faggregate_s\
    tats\x18\x01\x20\x01(\x0b2$.dota.CMsgBattleReportAggregateStatsR\x0eaggr\
    egateStats\x12_\n\x08response\x18\x02\x20\x01(\x0e2C.dota.CMsgClientToGC\
    GetBattleReportAggregateStatsResponse.EResponseR\x08response\"\xa1\x01\n\
    \tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\
    \x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\
    \x12\x17\n\x13k_ePermissionDenied\x10\x04\x12\x14\n\x10k_eInvalidParams\
    \x10\x05\x12\x1e\n\x1ak_eNotSubscribedToDotaPlus\x10\x06\"B\n!CMsgClient\
    ToGCGetBattleReportInfo\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccou\
    ntId\"\xe7\x02\n)CMsgClientToGCGetBattleReportInfoResponse\x12U\n\x17bat\
    tle_report_info_list\x18\x01\x20\x01(\x0b2\x1e.dota.CMsgBattleReportInfo\
    ListR\x14battleReportInfoList\x12U\n\x08response\x18\x02\x20\x01(\x0e29.\
    dota.CMsgClientToGCGetBattleReportInfoResponse.EResponseR\x08response\"\
    \x8b\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_e\
    Success\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\
    \x10\x03\x12\x17\n\x13k_ePermissionDenied\x10\x04\x12\x1e\n\x1ak_eNotSub\
    scribedToDotaPlus\x10\x05\"\x80\x01\n%CMsgClientToGCAcknowledgeBattleRep\
    ort\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1c\n\ttime\
    stamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x1a\n\x08duration\x18\x03\x20\
    \x01(\rR\x08duration\"\xbf\x03\n-CMsgClientToGCAcknowledgeBattleReportRe\
    sponse\x12Y\n\x08response\x18\x01\x20\x01(\x0e2=.dota.CMsgClientToGCAckn\
    owledgeBattleReportResponse.EResponseR\x08response\x12%\n\x0eshards_awar\
    ded\x18\x02\x20\x01(\rR\rshardsAwarded\"\x8b\x02\n\tEResponse\x12\x14\n\
    \x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eT\
    ooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\
    \x10\x04\x12\x17\n\x13k_ePermissionDenied\x10\x05\x12\x1f\n\x1bk_eUnable\
    ToLoadBattleReport\x10\x06\x12\x1a\n\x16k_eAlreadyAcknowledged\x10\x07\
    \x12\x14\n\x10k_eUnknownReport\x10\x08\x12\x1e\n\x1ak_eNotSubscribedToDo\
    taPlus\x10\t\x12\x1b\n\x17k_eNotEnoughGamesPlayed\x10\n\"\x84\x01\n)CMsg\
    ClientToGCGetBattleReportMatchHistory\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\
    \x12\x1a\n\x08duration\x18\x03\x20\x01(\rR\x08duration\"\xe7\x02\n1CMsgC\
    lientToGCGetBattleReportMatchHistoryResponse\x12]\n\x08response\x18\x01\
    \x20\x01(\x0e2A.dota.CMsgClientToGCGetBattleReportMatchHistoryResponse.E\
    ResponseR\x08response\x125\n\x05games\x18\x02\x20\x01(\x0b2\x1f.dota.CMs\
    gBattleReport_GameListR\x05games\"\x9b\x01\n\tEResponse\x12\x14\n\x10k_e\
    InternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\
    \x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\
    \x12\x17\n\x13k_ePermissionDenied\x10\x05\x12\x1e\n\x1ak_eNotSubscribedT\
    oDotaPlus\x10\x06*\xe5\x0c\n\x1eCMsgBattleReport_HighlightType\x12$\n\
    \x17k_eHighlightTypeInvalid\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\
    \x12\x12\n\x0ek_eGameWinrate\x10\0\x12\x12\n\x0ek_eLaneWinrate\x10\x01\
    \x12\x0f\n\x0bk_eMMRDelta\x10\x02\x12\x16\n\x12k_eNumHeroesPlayed\x10\
    \x03\x12\x15\n\x11k_eNumGamesPlayed\x10\x04\x12\x1d\n\x19k_eAveragePower\
    RunesTaken\x10\x05\x12\x1e\n\x1ak_eAverageBountyRunesTaken\x10\x06\x12\
    \x1c\n\x18k_eTotalKillEnemyT1First\x10\x07\x12\x17\n\x13k_eTotalRoshanKi\
    lls\x10\x08\x12\x13\n\x0fk_eTotalDewards\x10\t\x12\x18\n\x14k_eTotalCamp\
    sStacked\x10\n\x12\x13\n\x0fk_eMaxWinstreak\x10\x0b\x12\x15\n\x11k_eAver\
    ageDewards\x10\x0c\x12\x13\n\x0fk_eAverageKills\x10\r\x12\x0f\n\x0bk_eMa\
    xKills\x10\x0e\x12\x15\n\x11k_eAverageAssists\x10\x0f\x12\x11\n\rk_eMaxA\
    ssists\x10\x10\x12\x14\n\x10k_eAverageDeaths\x10\x11\x12\x10\n\x0ck_eMin\
    Deaths\x10\x12\x12\x1a\n\x16k_eAverageCampsStacked\x10\x13\x12\x14\n\x10\
    k_eTotalLastHits\x10\x14\x12\x16\n\x12k_eAverageLastHits\x10\x15\x12\x12\
    \n\x0ek_eTotalDenies\x10\x16\x12\x14\n\x10k_eAverageDenies\x10\x17\x12$\
    \n\x20k_eTotalGamesWithRoshanAdvantage\x10\x18\x12&\n\"k_ePercentGamesWi\
    thRoshanAdvantage\x10\x19\x12\x1a\n\x16k_eAverageStunDuration\x10\x1a\
    \x12\x18\n\x14k_eTotalStunDuration\x10\x1b\x12\x1b\n\x17k_eAverageTelepo\
    rtsUsed\x10\x1c\x12\x19\n\x15k_eTotalTeleportsUsed\x10\x1d\x12\x18\n\x14\
    k_eAverageHeroDamage\x10\x1e\x12\x16\n\x12k_eTotalHeroDamage\x10\x1f\x12\
    \x19\n\x15k_eAverageHeroHealing\x10\x20\x12\x17\n\x13k_eTotalHeroHealing\
    \x10!\x12\x19\n\x15k_eAverageTowerDamage\x10\"\x12\x17\n\x13k_eTotalTowe\
    rDamage\x10#\x12\x14\n\x10k_eMaxLossStreak\x10$\x12\x1a\n\x16k_eAverageG\
    ameDuration\x10%\x12\x16\n\x12k_eMaxGameDuration\x10&\x12\x16\n\x12k_eMi\
    nGameDuration\x10'\x12\x19\n\x15k_eAverageWinDuration\x10(\x12\x15\n\x11\
    k_eMaxWinDuration\x10)\x12\x15\n\x11k_eMinWinDuration\x10*\x12\x1a\n\x16\
    k_eAverageLossDuration\x10+\x12\x16\n\x12k_eMaxLossDuration\x10,\x12\x16\
    \n\x12k_eMinLossDuration\x10-\x12\x20\n\x1ck_ePctGamesEnemyT1TakenFirst\
    \x10.\x12\x16\n\x12k_eMaxCampsStacked\x10/\x12\x11\n\rk_eMaxDewards\x100\
    \x12\x15\n\x11k_eMaxRoshanKills\x101\x12\x1a\n\x16k_eMaxBountyRunesTaken\
    \x102\x12\x19\n\x15k_eMaxPowerRunesTaken\x103\x12\x10\n\x0ck_eMaxDeaths\
    \x104\x12\x12\n\x0ek_eMaxLastHits\x105\x12\x10\n\x0ck_eMaxDenies\x106\
    \x12\x15\n\x11k_eRadiantWinRate\x107\x12\x12\n\x0ek_eDireWinRate\x108\
    \x12\x17\n\x13k_eRadiantGameCount\x109\x12\x14\n\x10k_eDireGameCount\x10\
    :\x12\x10\n\x0ck_eMaxDamage\x10;\x12\x11\n\rk_eMaxHealing\x10<\x12\x15\n\
    \x11k_eMaxTowerDamage\x10=\x12\x11\n\rk_eAverageGPM\x10>\x12\r\n\tk_eMax\
    GPM\x10?\x12\x11\n\rk_eAverageXPM\x10@\x12\r\n\tk_eMaxXPM\x10A*i\n\"CMsg\
    BattleReport_HighlightCategory\x12\x17\n\x13k_eHighlightGeneral\x10\0\
    \x12\x14\n\x10k_eHighlightHero\x10\x01\x12\x14\n\x10k_eHighlightRole\x10\
    \x02*\x8d\x01\n\x15CMsgBattleReport_Role\x12\x1b\n\x0ek_eUnknownRole\x10\
    \xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x0f\n\x0bk_eSafelane\x10\0\
    \x12\x0e\n\nk_eMidlane\x10\x01\x12\x0e\n\nk_eOfflane\x10\x02\x12\x12\n\
    \x0ek_eSoftSupport\x10\x03\x12\x12\n\x0ek_eHardSupport\x10\x04*\xad\x01\
    \n\x1fCMsgBattleReport_CompareContext\x12%\n\x18k_eCompareContextInvalid\
    \x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x14\n\x10k_eAbsoluteVal\
    ue\x10\0\x12\x1b\n\x17k_ePlayersOfSimilarRank\x10\x01\x12\x11\n\rk_eAllP\
    layers\x10\x02\x12\x1d\n\x19k_ePlayersPersonalHistory\x10\x03*\xbd\x01\n\
    \x1eCMsgBattleReport_HighlightTier\x12\x20\n\x13k_eHighlightTierLow\x10\
    \xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x18\n\x14k_eHighlightTierNo\
    ne\x10\0\x12\x15\n\x11k_eHighlightTier1\x10\x01\x12\x15\n\x11k_eHighligh\
    tTier2\x10\x02\x12\x15\n\x11k_eHighlightTier3\x10\x03\x12\x1a\n\x16k_eHi\
    ghlightTierCustom\x10\x04*j\n\x20CMsgBattleReport_HighlightRarity\x12\
    \x16\n\x12k_eHighlightCommon\x10\0\x12\x18\n\x14k_eHighlightUncommon\x10\
    \x01\x12\x14\n\x10k_eHighlightRare\x10\x02*4\n\x19CMsgBattleReport_EOutc\
    ome\x12\n\n\x06k_eWin\x10\0\x12\x0b\n\x07k_eLoss\x10\x01*u\n\x1dCMsgBatt\
    leReport_ELaneOutcome\x12\"\n\x15k_eUnknownLaneOutcome\x10\xff\xff\xff\
    \xff\xff\xff\xff\xff\xff\x01\x12\x0e\n\nk_eWonLane\x10\0\x12\x0f\n\x0bk_\
    eLostLane\x10\x01\x12\x0f\n\x0bk_eEvenLane\x10\x02B%Z#github.com/dotabuf\
    f/manta/dota;dotaJ\xca\x8b\x01\n\x07\x12\x05\0\0\x8d\x03\x01\n\x08\n\x01\
    \x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\
    \x12\x03\x03\0:\n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\
    \x05\x07\x1c\n\t\n\x02\x03\x01\x12\x03\x06\x07\x20\n\t\n\x02\x03\x02\x12\
    \x03\x07\x07%\n\t\n\x02\x03\x03\x12\x03\x08\x07%\n\t\n\x02\x03\x04\x12\
    \x03\t\x07\x1f\n\t\n\x02\x03\x05\x12\x03\n\x07\x1e\n\t\n\x02\x03\x06\x12\
    \x03\x0b\x07\x1e\n\t\n\x02\x03\x07\x12\x03\x0c\x07%\n\t\n\x02\x03\x08\
    \x12\x03\r\x07\x1e\n\n\n\x02\x05\0\x12\x04\x0f\0S\x01\n\n\n\x03\x05\0\
    \x01\x12\x03\x0f\x05#\n\x0b\n\x04\x05\0\x02\0\x12\x03\x10\x08%\n\x0c\n\
    \x05\x05\0\x02\0\x01\x12\x03\x10\x08\x1f\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03\x10\"$\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x11\x08\x1b\n\x0c\n\x05\
    \x05\0\x02\x01\x01\x12\x03\x11\x08\x16\n\x0c\n\x05\x05\0\x02\x01\x02\x12\
    \x03\x11\x19\x1a\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x12\x08\x1b\n\x0c\n\
    \x05\x05\0\x02\x02\x01\x12\x03\x12\x08\x16\n\x0c\n\x05\x05\0\x02\x02\x02\
    \x12\x03\x12\x19\x1a\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x13\x08\x18\n\x0c\
    \n\x05\x05\0\x02\x03\x01\x12\x03\x13\x08\x13\n\x0c\n\x05\x05\0\x02\x03\
    \x02\x12\x03\x13\x16\x17\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x14\x08\x1f\n\
    \x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x14\x08\x1a\n\x0c\n\x05\x05\0\x02\
    \x04\x02\x12\x03\x14\x1d\x1e\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x15\x08\
    \x1e\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x15\x08\x19\n\x0c\n\x05\x05\0\
    \x02\x05\x02\x12\x03\x15\x1c\x1d\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x16\
    \x08&\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x16\x08!\n\x0c\n\x05\x05\0\
    \x02\x06\x02\x12\x03\x16$%\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x17\x08'\n\
    \x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x17\x08\"\n\x0c\n\x05\x05\0\x02\x07\
    \x02\x12\x03\x17%&\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x18\x08%\n\x0c\n\
    \x05\x05\0\x02\x08\x01\x12\x03\x18\x08\x20\n\x0c\n\x05\x05\0\x02\x08\x02\
    \x12\x03\x18#$\n\x0b\n\x04\x05\0\x02\t\x12\x03\x19\x08\x20\n\x0c\n\x05\
    \x05\0\x02\t\x01\x12\x03\x19\x08\x1b\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\
    \x19\x1e\x1f\n\x0b\n\x04\x05\0\x02\n\x12\x03\x1a\x08\x1c\n\x0c\n\x05\x05\
    \0\x02\n\x01\x12\x03\x1a\x08\x17\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x1a\
    \x1a\x1b\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x1b\x08\"\n\x0c\n\x05\x05\0\
    \x02\x0b\x01\x12\x03\x1b\x08\x1c\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\
    \x1b\x1f!\n\x0b\n\x04\x05\0\x02\x0c\x12\x03\x1c\x08\x1d\n\x0c\n\x05\x05\
    \0\x02\x0c\x01\x12\x03\x1c\x08\x17\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\
    \x1c\x1a\x1c\n\x0b\n\x04\x05\0\x02\r\x12\x03\x1d\x08\x1f\n\x0c\n\x05\x05\
    \0\x02\r\x01\x12\x03\x1d\x08\x19\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x1d\
    \x1c\x1e\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x1e\x08\x1d\n\x0c\n\x05\x05\0\
    \x02\x0e\x01\x12\x03\x1e\x08\x17\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\
    \x1e\x1a\x1c\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x1f\x08\x19\n\x0c\n\x05\
    \x05\0\x02\x0f\x01\x12\x03\x1f\x08\x13\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\
    \x03\x1f\x16\x18\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x20\x08\x1f\n\x0c\n\
    \x05\x05\0\x02\x10\x01\x12\x03\x20\x08\x19\n\x0c\n\x05\x05\0\x02\x10\x02\
    \x12\x03\x20\x1c\x1e\n\x0b\n\x04\x05\0\x02\x11\x12\x03!\x08\x1b\n\x0c\n\
    \x05\x05\0\x02\x11\x01\x12\x03!\x08\x15\n\x0c\n\x05\x05\0\x02\x11\x02\
    \x12\x03!\x18\x1a\n\x0b\n\x04\x05\0\x02\x12\x12\x03\"\x08\x1e\n\x0c\n\
    \x05\x05\0\x02\x12\x01\x12\x03\"\x08\x18\n\x0c\n\x05\x05\0\x02\x12\x02\
    \x12\x03\"\x1b\x1d\n\x0b\n\x04\x05\0\x02\x13\x12\x03#\x08\x1a\n\x0c\n\
    \x05\x05\0\x02\x13\x01\x12\x03#\x08\x14\n\x0c\n\x05\x05\0\x02\x13\x02\
    \x12\x03#\x17\x19\n\x0b\n\x04\x05\0\x02\x14\x12\x03$\x08$\n\x0c\n\x05\
    \x05\0\x02\x14\x01\x12\x03$\x08\x1e\n\x0c\n\x05\x05\0\x02\x14\x02\x12\
    \x03$!#\n\x0b\n\x04\x05\0\x02\x15\x12\x03%\x08\x1e\n\x0c\n\x05\x05\0\x02\
    \x15\x01\x12\x03%\x08\x18\n\x0c\n\x05\x05\0\x02\x15\x02\x12\x03%\x1b\x1d\
    \n\x0b\n\x04\x05\0\x02\x16\x12\x03&\x08\x20\n\x0c\n\x05\x05\0\x02\x16\
    \x01\x12\x03&\x08\x1a\n\x0c\n\x05\x05\0\x02\x16\x02\x12\x03&\x1d\x1f\n\
    \x0b\n\x04\x05\0\x02\x17\x12\x03'\x08\x1c\n\x0c\n\x05\x05\0\x02\x17\x01\
    \x12\x03'\x08\x16\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03'\x19\x1b\n\x0b\n\
    \x04\x05\0\x02\x18\x12\x03(\x08\x1e\n\x0c\n\x05\x05\0\x02\x18\x01\x12\
    \x03(\x08\x18\n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03(\x1b\x1d\n\x0b\n\x04\
    \x05\0\x02\x19\x12\x03)\x08.\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03)\x08(\
    \n\x0c\n\x05\x05\0\x02\x19\x02\x12\x03)+-\n\x0b\n\x04\x05\0\x02\x1a\x12\
    \x03*\x080\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03*\x08*\n\x0c\n\x05\x05\0\
    \x02\x1a\x02\x12\x03*-/\n\x0b\n\x04\x05\0\x02\x1b\x12\x03+\x08$\n\x0c\n\
    \x05\x05\0\x02\x1b\x01\x12\x03+\x08\x1e\n\x0c\n\x05\x05\0\x02\x1b\x02\
    \x12\x03+!#\n\x0b\n\x04\x05\0\x02\x1c\x12\x03,\x08\"\n\x0c\n\x05\x05\0\
    \x02\x1c\x01\x12\x03,\x08\x1c\n\x0c\n\x05\x05\0\x02\x1c\x02\x12\x03,\x1f\
    !\n\x0b\n\x04\x05\0\x02\x1d\x12\x03-\x08%\n\x0c\n\x05\x05\0\x02\x1d\x01\
    \x12\x03-\x08\x1f\n\x0c\n\x05\x05\0\x02\x1d\x02\x12\x03-\"$\n\x0b\n\x04\
    \x05\0\x02\x1e\x12\x03.\x08#\n\x0c\n\x05\x05\0\x02\x1e\x01\x12\x03.\x08\
    \x1d\n\x0c\n\x05\x05\0\x02\x1e\x02\x12\x03.\x20\"\n\x0b\n\x04\x05\0\x02\
    \x1f\x12\x03/\x08\"\n\x0c\n\x05\x05\0\x02\x1f\x01\x12\x03/\x08\x1c\n\x0c\
    \n\x05\x05\0\x02\x1f\x02\x12\x03/\x1f!\n\x0b\n\x04\x05\0\x02\x20\x12\x03\
    0\x08\x20\n\x0c\n\x05\x05\0\x02\x20\x01\x12\x030\x08\x1a\n\x0c\n\x05\x05\
    \0\x02\x20\x02\x12\x030\x1d\x1f\n\x0b\n\x04\x05\0\x02!\x12\x031\x08#\n\
    \x0c\n\x05\x05\0\x02!\x01\x12\x031\x08\x1d\n\x0c\n\x05\x05\0\x02!\x02\
    \x12\x031\x20\"\n\x0b\n\x04\x05\0\x02\"\x12\x032\x08!\n\x0c\n\x05\x05\0\
    \x02\"\x01\x12\x032\x08\x1b\n\x0c\n\x05\x05\0\x02\"\x02\x12\x032\x1e\x20\
    \n\x0b\n\x04\x05\0\x02#\x12\x033\x08#\n\x0c\n\x05\x05\0\x02#\x01\x12\x03\
    3\x08\x1d\n\x0c\n\x05\x05\0\x02#\x02\x12\x033\x20\"\n\x0b\n\x04\x05\0\
    \x02$\x12\x034\x08!\n\x0c\n\x05\x05\0\x02$\x01\x12\x034\x08\x1b\n\x0c\n\
    \x05\x05\0\x02$\x02\x12\x034\x1e\x20\n\x0b\n\x04\x05\0\x02%\x12\x035\x08\
    \x1e\n\x0c\n\x05\x05\0\x02%\x01\x12\x035\x08\x18\n\x0c\n\x05\x05\0\x02%\
    \x02\x12\x035\x1b\x1d\n\x0b\n\x04\x05\0\x02&\x12\x036\x08$\n\x0c\n\x05\
    \x05\0\x02&\x01\x12\x036\x08\x1e\n\x0c\n\x05\x05\0\x02&\x02\x12\x036!#\n\
    \x0b\n\x04\x05\0\x02'\x12\x037\x08\x20\n\x0c\n\x05\x05\0\x02'\x01\x12\
    \x037\x08\x1a\n\x0c\n\x05\x05\0\x02'\x02\x12\x037\x1d\x1f\n\x0b\n\x04\
    \x05\0\x02(\x12\x038\x08\x20\n\x0c\n\x05\x05\0\x02(\x01\x12\x038\x08\x1a\
    \n\x0c\n\x05\x05\0\x02(\x02\x12\x038\x1d\x1f\n\x0b\n\x04\x05\0\x02)\x12\
    \x039\x08#\n\x0c\n\x05\x05\0\x02)\x01\x12\x039\x08\x1d\n\x0c\n\x05\x05\0\
    \x02)\x02\x12\x039\x20\"\n\x0b\n\x04\x05\0\x02*\x12\x03:\x08\x1f\n\x0c\n\
    \x05\x05\0\x02*\x01\x12\x03:\x08\x19\n\x0c\n\x05\x05\0\x02*\x02\x12\x03:\
    \x1c\x1e\n\x0b\n\x04\x05\0\x02+\x12\x03;\x08\x1f\n\x0c\n\x05\x05\0\x02+\
    \x01\x12\x03;\x08\x19\n\x0c\n\x05\x05\0\x02+\x02\x12\x03;\x1c\x1e\n\x0b\
    \n\x04\x05\0\x02,\x12\x03<\x08$\n\x0c\n\x05\x05\0\x02,\x01\x12\x03<\x08\
    \x1e\n\x0c\n\x05\x05\0\x02,\x02\x12\x03<!#\n\x0b\n\x04\x05\0\x02-\x12\
    \x03=\x08\x20\n\x0c\n\x05\x05\0\x02-\x01\x12\x03=\x08\x1a\n\x0c\n\x05\
    \x05\0\x02-\x02\x12\x03=\x1d\x1f\n\x0b\n\x04\x05\0\x02.\x12\x03>\x08\x20\
    \n\x0c\n\x05\x05\0\x02.\x01\x12\x03>\x08\x1a\n\x0c\n\x05\x05\0\x02.\x02\
    \x12\x03>\x1d\x1f\n\x0b\n\x04\x05\0\x02/\x12\x03?\x08*\n\x0c\n\x05\x05\0\
    \x02/\x01\x12\x03?\x08$\n\x0c\n\x05\x05\0\x02/\x02\x12\x03?')\n\x0b\n\
    \x04\x05\0\x020\x12\x03@\x08\x20\n\x0c\n\x05\x05\0\x020\x01\x12\x03@\x08\
    \x1a\n\x0c\n\x05\x05\0\x020\x02\x12\x03@\x1d\x1f\n\x0b\n\x04\x05\0\x021\
    \x12\x03A\x08\x1b\n\x0c\n\x05\x05\0\x021\x01\x12\x03A\x08\x15\n\x0c\n\
    \x05\x05\0\x021\x02\x12\x03A\x18\x1a\n\x0b\n\x04\x05\0\x022\x12\x03B\x08\
    \x1f\n\x0c\n\x05\x05\0\x022\x01\x12\x03B\x08\x19\n\x0c\n\x05\x05\0\x022\
    \x02\x12\x03B\x1c\x1e\n\x0b\n\x04\x05\0\x023\x12\x03C\x08$\n\x0c\n\x05\
    \x05\0\x023\x01\x12\x03C\x08\x1e\n\x0c\n\x05\x05\0\x023\x02\x12\x03C!#\n\
    \x0b\n\x04\x05\0\x024\x12\x03D\x08#\n\x0c\n\x05\x05\0\x024\x01\x12\x03D\
    \x08\x1d\n\x0c\n\x05\x05\0\x024\x02\x12\x03D\x20\"\n\x0b\n\x04\x05\0\x02\
    5\x12\x03E\x08\x1a\n\x0c\n\x05\x05\0\x025\x01\x12\x03E\x08\x14\n\x0c\n\
    \x05\x05\0\x025\x02\x12\x03E\x17\x19\n\x0b\n\x04\x05\0\x026\x12\x03F\x08\
    \x1c\n\x0c\n\x05\x05\0\x026\x01\x12\x03F\x08\x16\n\x0c\n\x05\x05\0\x026\
    \x02\x12\x03F\x19\x1b\n\x0b\n\x04\x05\0\x027\x12\x03G\x08\x1a\n\x0c\n\
    \x05\x05\0\x027\x01\x12\x03G\x08\x14\n\x0c\n\x05\x05\0\x027\x02\x12\x03G\
    \x17\x19\n\x0b\n\x04\x05\0\x028\x12\x03H\x08\x1f\n\x0c\n\x05\x05\0\x028\
    \x01\x12\x03H\x08\x19\n\x0c\n\x05\x05\0\x028\x02\x12\x03H\x1c\x1e\n\x0b\
    \n\x04\x05\0\x029\x12\x03I\x08\x1c\n\x0c\n\x05\x05\0\x029\x01\x12\x03I\
    \x08\x16\n\x0c\n\x05\x05\0\x029\x02\x12\x03I\x19\x1b\n\x0b\n\x04\x05\0\
    \x02:\x12\x03J\x08!\n\x0c\n\x05\x05\0\x02:\x01\x12\x03J\x08\x1b\n\x0c\n\
    \x05\x05\0\x02:\x02\x12\x03J\x1e\x20\n\x0b\n\x04\x05\0\x02;\x12\x03K\x08\
    \x1e\n\x0c\n\x05\x05\0\x02;\x01\x12\x03K\x08\x18\n\x0c\n\x05\x05\0\x02;\
    \x02\x12\x03K\x1b\x1d\n\x0b\n\x04\x05\0\x02<\x12\x03L\x08\x1a\n\x0c\n\
    \x05\x05\0\x02<\x01\x12\x03L\x08\x14\n\x0c\n\x05\x05\0\x02<\x02\x12\x03L\
    \x17\x19\n\x0b\n\x04\x05\0\x02=\x12\x03M\x08\x1b\n\x0c\n\x05\x05\0\x02=\
    \x01\x12\x03M\x08\x15\n\x0c\n\x05\x05\0\x02=\x02\x12\x03M\x18\x1a\n\x0b\
    \n\x04\x05\0\x02>\x12\x03N\x08\x1f\n\x0c\n\x05\x05\0\x02>\x01\x12\x03N\
    \x08\x19\n\x0c\n\x05\x05\0\x02>\x02\x12\x03N\x1c\x1e\n\x0b\n\x04\x05\0\
    \x02?\x12\x03O\x08\x1b\n\x0c\n\x05\x05\0\x02?\x01\x12\x03O\x08\x15\n\x0c\
    \n\x05\x05\0\x02?\x02\x12\x03O\x18\x1a\n\x0b\n\x04\x05\0\x02@\x12\x03P\
    \x08\x17\n\x0c\n\x05\x05\0\x02@\x01\x12\x03P\x08\x11\n\x0c\n\x05\x05\0\
    \x02@\x02\x12\x03P\x14\x16\n\x0b\n\x04\x05\0\x02A\x12\x03Q\x08\x1b\n\x0c\
    \n\x05\x05\0\x02A\x01\x12\x03Q\x08\x15\n\x0c\n\x05\x05\0\x02A\x02\x12\
    \x03Q\x18\x1a\n\x0b\n\x04\x05\0\x02B\x12\x03R\x08\x17\n\x0c\n\x05\x05\0\
    \x02B\x01\x12\x03R\x08\x11\n\x0c\n\x05\x05\0\x02B\x02\x12\x03R\x14\x16\n\
    \n\n\x02\x05\x01\x12\x04U\0Y\x01\n\n\n\x03\x05\x01\x01\x12\x03U\x05'\n\
    \x0b\n\x04\x05\x01\x02\0\x12\x03V\x08\x20\n\x0c\n\x05\x05\x01\x02\0\x01\
    \x12\x03V\x08\x1b\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03V\x1e\x1f\n\x0b\n\
    \x04\x05\x01\x02\x01\x12\x03W\x08\x1d\n\x0c\n\x05\x05\x01\x02\x01\x01\
    \x12\x03W\x08\x18\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03W\x1b\x1c\n\x0b\
    \n\x04\x05\x01\x02\x02\x12\x03X\x08\x1d\n\x0c\n\x05\x05\x01\x02\x02\x01\
    \x12\x03X\x08\x18\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03X\x1b\x1c\n\n\n\
    \x02\x05\x02\x12\x04[\0b\x01\n\n\n\x03\x05\x02\x01\x12\x03[\x05\x1a\n\
    \x0b\n\x04\x05\x02\x02\0\x12\x03\\\x08\x1c\n\x0c\n\x05\x05\x02\x02\0\x01\
    \x12\x03\\\x08\x16\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\\\x19\x1b\n\x0b\
    \n\x04\x05\x02\x02\x01\x12\x03]\x08\x18\n\x0c\n\x05\x05\x02\x02\x01\x01\
    \x12\x03]\x08\x13\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03]\x16\x17\n\x0b\
    \n\x04\x05\x02\x02\x02\x12\x03^\x08\x17\n\x0c\n\x05\x05\x02\x02\x02\x01\
    \x12\x03^\x08\x12\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03^\x15\x16\n\x0b\
    \n\x04\x05\x02\x02\x03\x12\x03_\x08\x17\n\x0c\n\x05\x05\x02\x02\x03\x01\
    \x12\x03_\x08\x12\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03_\x15\x16\n\x0b\
    \n\x04\x05\x02\x02\x04\x12\x03`\x08\x1b\n\x0c\n\x05\x05\x02\x02\x04\x01\
    \x12\x03`\x08\x16\n\x0c\n\x05\x05\x02\x02\x04\x02\x12\x03`\x19\x1a\n\x0b\
    \n\x04\x05\x02\x02\x05\x12\x03a\x08\x1b\n\x0c\n\x05\x05\x02\x02\x05\x01\
    \x12\x03a\x08\x16\n\x0c\n\x05\x05\x02\x02\x05\x02\x12\x03a\x19\x1a\n\n\n\
    \x02\x05\x03\x12\x04d\0j\x01\n\n\n\x03\x05\x03\x01\x12\x03d\x05$\n\x0b\n\
    \x04\x05\x03\x02\0\x12\x03e\x08&\n\x0c\n\x05\x05\x03\x02\0\x01\x12\x03e\
    \x08\x20\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03e#%\n\x0b\n\x04\x05\x03\
    \x02\x01\x12\x03f\x08\x1d\n\x0c\n\x05\x05\x03\x02\x01\x01\x12\x03f\x08\
    \x18\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03f\x1b\x1c\n\x0b\n\x04\x05\
    \x03\x02\x02\x12\x03g\x08$\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\x03g\x08\
    \x1f\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\x03g\"#\n\x0b\n\x04\x05\x03\x02\
    \x03\x12\x03h\x08\x1a\n\x0c\n\x05\x05\x03\x02\x03\x01\x12\x03h\x08\x15\n\
    \x0c\n\x05\x05\x03\x02\x03\x02\x12\x03h\x18\x19\n\x0b\n\x04\x05\x03\x02\
    \x04\x12\x03i\x08&\n\x0c\n\x05\x05\x03\x02\x04\x01\x12\x03i\x08!\n\x0c\n\
    \x05\x05\x03\x02\x04\x02\x12\x03i$%\n\n\n\x02\x05\x04\x12\x04l\0s\x01\n\
    \n\n\x03\x05\x04\x01\x12\x03l\x05#\n\x0b\n\x04\x05\x04\x02\0\x12\x03m\
    \x08!\n\x0c\n\x05\x05\x04\x02\0\x01\x12\x03m\x08\x1b\n\x0c\n\x05\x05\x04\
    \x02\0\x02\x12\x03m\x1e\x20\n\x0b\n\x04\x05\x04\x02\x01\x12\x03n\x08!\n\
    \x0c\n\x05\x05\x04\x02\x01\x01\x12\x03n\x08\x1c\n\x0c\n\x05\x05\x04\x02\
    \x01\x02\x12\x03n\x1f\x20\n\x0b\n\x04\x05\x04\x02\x02\x12\x03o\x08\x1e\n\
    \x0c\n\x05\x05\x04\x02\x02\x01\x12\x03o\x08\x19\n\x0c\n\x05\x05\x04\x02\
    \x02\x02\x12\x03o\x1c\x1d\n\x0b\n\x04\x05\x04\x02\x03\x12\x03p\x08\x1e\n\
    \x0c\n\x05\x05\x04\x02\x03\x01\x12\x03p\x08\x19\n\x0c\n\x05\x05\x04\x02\
    \x03\x02\x12\x03p\x1c\x1d\n\x0b\n\x04\x05\x04\x02\x04\x12\x03q\x08\x1e\n\
    \x0c\n\x05\x05\x04\x02\x04\x01\x12\x03q\x08\x19\n\x0c\n\x05\x05\x04\x02\
    \x04\x02\x12\x03q\x1c\x1d\n\x0b\n\x04\x05\x04\x02\x05\x12\x03r\x08#\n\
    \x0c\n\x05\x05\x04\x02\x05\x01\x12\x03r\x08\x1e\n\x0c\n\x05\x05\x04\x02\
    \x05\x02\x12\x03r!\"\n\n\n\x02\x05\x05\x12\x04u\0y\x01\n\n\n\x03\x05\x05\
    \x01\x12\x03u\x05%\n\x0b\n\x04\x05\x05\x02\0\x12\x03v\x08\x1f\n\x0c\n\
    \x05\x05\x05\x02\0\x01\x12\x03v\x08\x1a\n\x0c\n\x05\x05\x05\x02\0\x02\
    \x12\x03v\x1d\x1e\n\x0b\n\x04\x05\x05\x02\x01\x12\x03w\x08!\n\x0c\n\x05\
    \x05\x05\x02\x01\x01\x12\x03w\x08\x1c\n\x0c\n\x05\x05\x05\x02\x01\x02\
    \x12\x03w\x1f\x20\n\x0b\n\x04\x05\x05\x02\x02\x12\x03x\x08\x1d\n\x0c\n\
    \x05\x05\x05\x02\x02\x01\x12\x03x\x08\x18\n\x0c\n\x05\x05\x05\x02\x02\
    \x02\x12\x03x\x1b\x1c\n\n\n\x02\x05\x06\x12\x04{\0~\x01\n\n\n\x03\x05\
    \x06\x01\x12\x03{\x05\x1e\n\x0b\n\x04\x05\x06\x02\0\x12\x03|\x08\x13\n\
    \x0c\n\x05\x05\x06\x02\0\x01\x12\x03|\x08\x0e\n\x0c\n\x05\x05\x06\x02\0\
    \x02\x12\x03|\x11\x12\n\x0b\n\x04\x05\x06\x02\x01\x12\x03}\x08\x14\n\x0c\
    \n\x05\x05\x06\x02\x01\x01\x12\x03}\x08\x0f\n\x0c\n\x05\x05\x06\x02\x01\
    \x02\x12\x03}\x12\x13\n\x0c\n\x02\x05\x07\x12\x06\x80\x01\0\x85\x01\x01\
    \n\x0b\n\x03\x05\x07\x01\x12\x04\x80\x01\x05\"\n\x0c\n\x04\x05\x07\x02\0\
    \x12\x04\x81\x01\x08#\n\r\n\x05\x05\x07\x02\0\x01\x12\x04\x81\x01\x08\
    \x1d\n\r\n\x05\x05\x07\x02\0\x02\x12\x04\x81\x01\x20\"\n\x0c\n\x04\x05\
    \x07\x02\x01\x12\x04\x82\x01\x08\x17\n\r\n\x05\x05\x07\x02\x01\x01\x12\
    \x04\x82\x01\x08\x12\n\r\n\x05\x05\x07\x02\x01\x02\x12\x04\x82\x01\x15\
    \x16\n\x0c\n\x04\x05\x07\x02\x02\x12\x04\x83\x01\x08\x18\n\r\n\x05\x05\
    \x07\x02\x02\x01\x12\x04\x83\x01\x08\x13\n\r\n\x05\x05\x07\x02\x02\x02\
    \x12\x04\x83\x01\x16\x17\n\x0c\n\x04\x05\x07\x02\x03\x12\x04\x84\x01\x08\
    \x18\n\r\n\x05\x05\x07\x02\x03\x01\x12\x04\x84\x01\x08\x13\n\r\n\x05\x05\
    \x07\x02\x03\x02\x12\x04\x84\x01\x16\x17\n\x0c\n\x02\x04\0\x12\x06\x87\
    \x01\0\x8b\x01\x01\n\x0b\n\x03\x04\0\x01\x12\x04\x87\x01\x08%\n\x0c\n\
    \x04\x04\0\x02\0\x12\x04\x88\x01\x08'\n\r\n\x05\x04\0\x02\0\x04\x12\x04\
    \x88\x01\x08\x10\n\r\n\x05\x04\0\x02\0\x05\x12\x04\x88\x01\x11\x17\n\r\n\
    \x05\x04\0\x02\0\x01\x12\x04\x88\x01\x18\"\n\r\n\x05\x04\0\x02\0\x03\x12\
    \x04\x88\x01%&\n\x0c\n\x04\x04\0\x02\x01\x12\x04\x89\x01\x08&\n\r\n\x05\
    \x04\0\x02\x01\x04\x12\x04\x89\x01\x08\x10\n\r\n\x05\x04\0\x02\x01\x05\
    \x12\x04\x89\x01\x11\x17\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\x89\x01\x18\
    !\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x89\x01$%\n\x0c\n\x04\x04\0\x02\
    \x02\x12\x04\x8a\x01\x08%\n\r\n\x05\x04\0\x02\x02\x04\x12\x04\x8a\x01\
    \x08\x10\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\x8a\x01\x11\x17\n\r\n\x05\
    \x04\0\x02\x02\x01\x12\x04\x8a\x01\x18\x20\n\r\n\x05\x04\0\x02\x02\x03\
    \x12\x04\x8a\x01#$\n\x0c\n\x02\x04\x01\x12\x06\x8d\x01\0\xbf\x01\x01\n\
    \x0b\n\x03\x04\x01\x01\x12\x04\x8d\x01\x08\x1d\n\x0c\n\x04\x04\x01\x02\0\
    \x12\x04\x8e\x01\x08$\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x8e\x01\x08\
    \x10\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\x8e\x01\x11\x17\n\r\n\x05\x04\
    \x01\x02\0\x01\x12\x04\x8e\x01\x18\x1f\n\r\n\x05\x04\x01\x02\0\x03\x12\
    \x04\x8e\x01\"#\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\x8f\x01\x08\"\n\r\n\
    \x05\x04\x01\x02\x01\x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x01\x02\
    \x01\x05\x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\
    \x8f\x01\x18\x1d\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\x8f\x01\x20!\n\
    \x0c\n\x04\x04\x01\x02\x02\x12\x04\x90\x01\x08#\n\r\n\x05\x04\x01\x02\
    \x02\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\
    \x90\x01\x11\x17\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\x90\x01\x18\x1e\n\
    \r\n\x05\x04\x01\x02\x02\x03\x12\x04\x90\x01!\"\n\x0c\n\x04\x04\x01\x02\
    \x03\x12\x04\x91\x01\x08$\n\r\n\x05\x04\x01\x02\x03\x04\x12\x04\x91\x01\
    \x08\x10\n\r\n\x05\x04\x01\x02\x03\x05\x12\x04\x91\x01\x11\x17\n\r\n\x05\
    \x04\x01\x02\x03\x01\x12\x04\x91\x01\x18\x1f\n\r\n\x05\x04\x01\x02\x03\
    \x03\x12\x04\x91\x01\"#\n\x0c\n\x04\x04\x01\x02\x04\x12\x04\x92\x01\x08'\
    \n\r\n\x05\x04\x01\x02\x04\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\x01\
    \x02\x04\x05\x12\x04\x92\x01\x11\x16\n\r\n\x05\x04\x01\x02\x04\x01\x12\
    \x04\x92\x01\x17\"\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\x92\x01%&\n\x0c\
    \n\x04\x04\x01\x02\x05\x12\x04\x93\x01\x08&\n\r\n\x05\x04\x01\x02\x05\
    \x04\x12\x04\x93\x01\x08\x10\n\r\n\x05\x04\x01\x02\x05\x05\x12\x04\x93\
    \x01\x11\x17\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\x93\x01\x18!\n\r\n\
    \x05\x04\x01\x02\x05\x03\x12\x04\x93\x01$%\n\x0c\n\x04\x04\x01\x02\x06\
    \x12\x04\x94\x01\x08$\n\r\n\x05\x04\x01\x02\x06\x04\x12\x04\x94\x01\x08\
    \x10\n\r\n\x05\x04\x01\x02\x06\x05\x12\x04\x94\x01\x11\x17\n\r\n\x05\x04\
    \x01\x02\x06\x01\x12\x04\x94\x01\x18\x1e\n\r\n\x05\x04\x01\x02\x06\x03\
    \x12\x04\x94\x01!#\n\x0c\n\x04\x04\x01\x02\x07\x12\x04\x95\x01\x08\x20\n\
    \r\n\x05\x04\x01\x02\x07\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x01\
    \x02\x07\x05\x12\x04\x95\x01\x11\x17\n\r\n\x05\x04\x01\x02\x07\x01\x12\
    \x04\x95\x01\x18\x1b\n\r\n\x05\x04\x01\x02\x07\x03\x12\x04\x95\x01\x1e\
    \x1f\n\x0c\n\x04\x04\x01\x02\x08\x12\x04\x96\x01\x08\x20\n\r\n\x05\x04\
    \x01\x02\x08\x04\x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\x01\x02\x08\x05\
    \x12\x04\x96\x01\x11\x17\n\r\n\x05\x04\x01\x02\x08\x01\x12\x04\x96\x01\
    \x18\x1b\n\r\n\x05\x04\x01\x02\x08\x03\x12\x04\x96\x01\x1e\x1f\n\x0c\n\
    \x04\x04\x01\x02\t\x12\x04\x97\x01\x080\n\r\n\x05\x04\x01\x02\t\x04\x12\
    \x04\x97\x01\x08\x10\n\r\n\x05\x04\x01\x02\t\x06\x12\x04\x97\x01\x11&\n\
    \r\n\x05\x04\x01\x02\t\x01\x12\x04\x97\x01'+\n\r\n\x05\x04\x01\x02\t\x03\
    \x12\x04\x97\x01./\n\x0c\n\x04\x04\x01\x02\n\x12\x04\x98\x01\x088\n\r\n\
    \x05\x04\x01\x02\n\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\x01\x02\n\
    \x06\x12\x04\x98\x01\x11*\n\r\n\x05\x04\x01\x02\n\x01\x12\x04\x98\x01+2\
    \n\r\n\x05\x04\x01\x02\n\x03\x12\x04\x98\x0157\n\x0c\n\x04\x04\x01\x02\
    \x0b\x12\x04\x99\x01\x08A\n\r\n\x05\x04\x01\x02\x0b\x04\x12\x04\x99\x01\
    \x08\x10\n\r\n\x05\x04\x01\x02\x0b\x06\x12\x04\x99\x01\x11.\n\r\n\x05\
    \x04\x01\x02\x0b\x01\x12\x04\x99\x01/;\n\r\n\x05\x04\x01\x02\x0b\x03\x12\
    \x04\x99\x01>@\n\x0c\n\x04\x04\x01\x02\x0c\x12\x04\x9a\x01\x08\"\n\r\n\
    \x05\x04\x01\x02\x0c\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\x01\x02\
    \x0c\x05\x12\x04\x9a\x01\x11\x15\n\r\n\x05\x04\x01\x02\x0c\x01\x12\x04\
    \x9a\x01\x16\x1c\n\r\n\x05\x04\x01\x02\x0c\x03\x12\x04\x9a\x01\x1f!\n\
    \x0c\n\x04\x04\x01\x02\r\x12\x04\x9b\x01\x08&\n\r\n\x05\x04\x01\x02\r\
    \x04\x12\x04\x9b\x01\x08\x10\n\r\n\x05\x04\x01\x02\r\x05\x12\x04\x9b\x01\
    \x11\x17\n\r\n\x05\x04\x01\x02\r\x01\x12\x04\x9b\x01\x18\x20\n\r\n\x05\
    \x04\x01\x02\r\x03\x12\x04\x9b\x01#%\n\x0c\n\x04\x04\x01\x02\x0e\x12\x04\
    \x9c\x01\x082\n\r\n\x05\x04\x01\x02\x0e\x04\x12\x04\x9c\x01\x08\x10\n\r\
    \n\x05\x04\x01\x02\x0e\x05\x12\x04\x9c\x01\x11\x17\n\r\n\x05\x04\x01\x02\
    \x0e\x01\x12\x04\x9c\x01\x18,\n\r\n\x05\x04\x01\x02\x0e\x03\x12\x04\x9c\
    \x01/1\n\x0c\n\x04\x04\x01\x02\x0f\x12\x04\x9d\x01\x080\n\r\n\x05\x04\
    \x01\x02\x0f\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\x01\x02\x0f\x05\
    \x12\x04\x9d\x01\x11\x17\n\r\n\x05\x04\x01\x02\x0f\x01\x12\x04\x9d\x01\
    \x18*\n\r\n\x05\x04\x01\x02\x0f\x03\x12\x04\x9d\x01-/\n\x0c\n\x04\x04\
    \x01\x02\x10\x12\x04\x9e\x01\x08*\n\r\n\x05\x04\x01\x02\x10\x04\x12\x04\
    \x9e\x01\x08\x10\n\r\n\x05\x04\x01\x02\x10\x05\x12\x04\x9e\x01\x11\x17\n\
    \r\n\x05\x04\x01\x02\x10\x01\x12\x04\x9e\x01\x18$\n\r\n\x05\x04\x01\x02\
    \x10\x03\x12\x04\x9e\x01')\n\x0c\n\x04\x04\x01\x02\x11\x12\x04\x9f\x01\
    \x08*\n\r\n\x05\x04\x01\x02\x11\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\
    \x04\x01\x02\x11\x05\x12\x04\x9f\x01\x11\x17\n\r\n\x05\x04\x01\x02\x11\
    \x01\x12\x04\x9f\x01\x18$\n\r\n\x05\x04\x01\x02\x11\x03\x12\x04\x9f\x01'\
    )\n\x0c\n\x04\x04\x01\x02\x12\x12\x04\xa0\x01\x08)\n\r\n\x05\x04\x01\x02\
    \x12\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x01\x02\x12\x05\x12\x04\
    \xa0\x01\x11\x17\n\r\n\x05\x04\x01\x02\x12\x01\x12\x04\xa0\x01\x18#\n\r\
    \n\x05\x04\x01\x02\x12\x03\x12\x04\xa0\x01&(\n\x0c\n\x04\x04\x01\x02\x13\
    \x12\x04\xa1\x01\x08&\n\r\n\x05\x04\x01\x02\x13\x04\x12\x04\xa1\x01\x08\
    \x10\n\r\n\x05\x04\x01\x02\x13\x05\x12\x04\xa1\x01\x11\x15\n\r\n\x05\x04\
    \x01\x02\x13\x01\x12\x04\xa1\x01\x16\x20\n\r\n\x05\x04\x01\x02\x13\x03\
    \x12\x04\xa1\x01#%\n\x0c\n\x04\x04\x01\x02\x14\x12\x04\xa2\x01\x08(\n\r\
    \n\x05\x04\x01\x02\x14\x04\x12\x04\xa2\x01\x08\x10\n\r\n\x05\x04\x01\x02\
    \x14\x05\x12\x04\xa2\x01\x11\x17\n\r\n\x05\x04\x01\x02\x14\x01\x12\x04\
    \xa2\x01\x18\"\n\r\n\x05\x04\x01\x02\x14\x03\x12\x04\xa2\x01%'\n\x0c\n\
    \x04\x04\x01\x02\x15\x12\x04\xa3\x01\x08*\n\r\n\x05\x04\x01\x02\x15\x04\
    \x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\x01\x02\x15\x05\x12\x04\xa3\x01\
    \x11\x17\n\r\n\x05\x04\x01\x02\x15\x01\x12\x04\xa3\x01\x18$\n\r\n\x05\
    \x04\x01\x02\x15\x03\x12\x04\xa3\x01')\n\x0c\n\x04\x04\x01\x02\x16\x12\
    \x04\xa4\x01\x08)\n\r\n\x05\x04\x01\x02\x16\x04\x12\x04\xa4\x01\x08\x10\
    \n\r\n\x05\x04\x01\x02\x16\x05\x12\x04\xa4\x01\x11\x17\n\r\n\x05\x04\x01\
    \x02\x16\x01\x12\x04\xa4\x01\x18#\n\r\n\x05\x04\x01\x02\x16\x03\x12\x04\
    \xa4\x01&(\n\x0c\n\x04\x04\x01\x02\x17\x12\x04\xa5\x01\x08)\n\r\n\x05\
    \x04\x01\x02\x17\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\x04\x01\x02\x17\
    \x05\x12\x04\xa5\x01\x11\x17\n\r\n\x05\x04\x01\x02\x17\x01\x12\x04\xa5\
    \x01\x18#\n\r\n\x05\x04\x01\x02\x17\x03\x12\x04\xa5\x01&(\n\x0c\n\x04\
    \x04\x01\x02\x18\x12\x04\xa6\x01\x08;\n\r\n\x05\x04\x01\x02\x18\x04\x12\
    \x04\xa6\x01\x08\x10\n\r\n\x05\x04\x01\x02\x18\x05\x12\x04\xa6\x01\x11\
    \x17\n\r\n\x05\x04\x01\x02\x18\x01\x12\x04\xa6\x01\x185\n\r\n\x05\x04\
    \x01\x02\x18\x03\x12\x04\xa6\x018:\n\x0c\n\x04\x04\x01\x02\x19\x12\x04\
    \xa7\x01\x08>\n\r\n\x05\x04\x01\x02\x19\x04\x12\x04\xa7\x01\x08\x10\n\r\
    \n\x05\x04\x01\x02\x19\x05\x12\x04\xa7\x01\x11\x17\n\r\n\x05\x04\x01\x02\
    \x19\x01\x12\x04\xa7\x01\x188\n\r\n\x05\x04\x01\x02\x19\x03\x12\x04\xa7\
    \x01;=\n\x0c\n\x04\x04\x01\x02\x1a\x12\x04\xa8\x01\x080\n\r\n\x05\x04\
    \x01\x02\x1a\x04\x12\x04\xa8\x01\x08\x10\n\r\n\x05\x04\x01\x02\x1a\x05\
    \x12\x04\xa8\x01\x11\x17\n\r\n\x05\x04\x01\x02\x1a\x01\x12\x04\xa8\x01\
    \x18*\n\r\n\x05\x04\x01\x02\x1a\x03\x12\x04\xa8\x01-/\n\x0c\n\x04\x04\
    \x01\x02\x1b\x12\x04\xa9\x01\x08,\n\r\n\x05\x04\x01\x02\x1b\x04\x12\x04\
    \xa9\x01\x08\x10\n\r\n\x05\x04\x01\x02\x1b\x05\x12\x04\xa9\x01\x11\x17\n\
    \r\n\x05\x04\x01\x02\x1b\x01\x12\x04\xa9\x01\x18&\n\r\n\x05\x04\x01\x02\
    \x1b\x03\x12\x04\xa9\x01)+\n\x0c\n\x04\x04\x01\x02\x1c\x12\x04\xaa\x01\
    \x08%\n\r\n\x05\x04\x01\x02\x1c\x04\x12\x04\xaa\x01\x08\x10\n\r\n\x05\
    \x04\x01\x02\x1c\x05\x12\x04\xaa\x01\x11\x17\n\r\n\x05\x04\x01\x02\x1c\
    \x01\x12\x04\xaa\x01\x18\x1f\n\r\n\x05\x04\x01\x02\x1c\x03\x12\x04\xaa\
    \x01\"$\n\x0c\n\x04\x04\x01\x02\x1d\x12\x04\xab\x01\x08+\n\r\n\x05\x04\
    \x01\x02\x1d\x04\x12\x04\xab\x01\x08\x10\n\r\n\x05\x04\x01\x02\x1d\x05\
    \x12\x04\xab\x01\x11\x17\n\r\n\x05\x04\x01\x02\x1d\x01\x12\x04\xab\x01\
    \x18%\n\r\n\x05\x04\x01\x02\x1d\x03\x12\x04\xab\x01(*\n\x0c\n\x04\x04\
    \x01\x02\x1e\x12\x04\xac\x01\x08*\n\r\n\x05\x04\x01\x02\x1e\x04\x12\x04\
    \xac\x01\x08\x10\n\r\n\x05\x04\x01\x02\x1e\x05\x12\x04\xac\x01\x11\x17\n\
    \r\n\x05\x04\x01\x02\x1e\x01\x12\x04\xac\x01\x18$\n\r\n\x05\x04\x01\x02\
    \x1e\x03\x12\x04\xac\x01')\n\x0c\n\x04\x04\x01\x02\x1f\x12\x04\xad\x01\
    \x08)\n\r\n\x05\x04\x01\x02\x1f\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\
    \x04\x01\x02\x1f\x05\x12\x04\xad\x01\x11\x17\n\r\n\x05\x04\x01\x02\x1f\
    \x01\x12\x04\xad\x01\x18#\n\r\n\x05\x04\x01\x02\x1f\x03\x12\x04\xad\x01&\
    (\n\x0c\n\x04\x04\x01\x02\x20\x12\x04\xae\x01\x08*\n\r\n\x05\x04\x01\x02\
    \x20\x04\x12\x04\xae\x01\x08\x10\n\r\n\x05\x04\x01\x02\x20\x05\x12\x04\
    \xae\x01\x11\x17\n\r\n\x05\x04\x01\x02\x20\x01\x12\x04\xae\x01\x18$\n\r\
    \n\x05\x04\x01\x02\x20\x03\x12\x04\xae\x01')\n\x0c\n\x04\x04\x01\x02!\
    \x12\x04\xaf\x01\x08*\n\r\n\x05\x04\x01\x02!\x04\x12\x04\xaf\x01\x08\x10\
    \n\r\n\x05\x04\x01\x02!\x05\x12\x04\xaf\x01\x11\x17\n\r\n\x05\x04\x01\
    \x02!\x01\x12\x04\xaf\x01\x18$\n\r\n\x05\x04\x01\x02!\x03\x12\x04\xaf\
    \x01')\n\x0c\n\x04\x04\x01\x02\"\x12\x04\xb0\x01\x08/\n\r\n\x05\x04\x01\
    \x02\"\x04\x12\x04\xb0\x01\x08\x10\n\r\n\x05\x04\x01\x02\"\x05\x12\x04\
    \xb0\x01\x11\x17\n\r\n\x05\x04\x01\x02\"\x01\x12\x04\xb0\x01\x18)\n\r\n\
    \x05\x04\x01\x02\"\x03\x12\x04\xb0\x01,.\n\x0c\n\x04\x04\x01\x02#\x12\
    \x04\xb1\x01\x08+\n\r\n\x05\x04\x01\x02#\x04\x12\x04\xb1\x01\x08\x10\n\r\
    \n\x05\x04\x01\x02#\x05\x12\x04\xb1\x01\x11\x17\n\r\n\x05\x04\x01\x02#\
    \x01\x12\x04\xb1\x01\x18%\n\r\n\x05\x04\x01\x02#\x03\x12\x04\xb1\x01(*\n\
    \x0c\n\x04\x04\x01\x02$\x12\x04\xb2\x01\x08&\n\r\n\x05\x04\x01\x02$\x04\
    \x12\x04\xb2\x01\x08\x10\n\r\n\x05\x04\x01\x02$\x05\x12\x04\xb2\x01\x11\
    \x17\n\r\n\x05\x04\x01\x02$\x01\x12\x04\xb2\x01\x18\x20\n\r\n\x05\x04\
    \x01\x02$\x03\x12\x04\xb2\x01#%\n\x0c\n\x04\x04\x01\x02%\x12\x04\xb3\x01\
    \x083\n\r\n\x05\x04\x01\x02%\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\
    \x01\x02%\x05\x12\x04\xb3\x01\x11\x17\n\r\n\x05\x04\x01\x02%\x01\x12\x04\
    \xb3\x01\x18-\n\r\n\x05\x04\x01\x02%\x03\x12\x04\xb3\x0102\n\x0c\n\x04\
    \x04\x01\x02&\x12\x04\xb4\x01\x08*\n\r\n\x05\x04\x01\x02&\x04\x12\x04\
    \xb4\x01\x08\x10\n\r\n\x05\x04\x01\x02&\x05\x12\x04\xb4\x01\x11\x16\n\r\
    \n\x05\x04\x01\x02&\x01\x12\x04\xb4\x01\x17$\n\r\n\x05\x04\x01\x02&\x03\
    \x12\x04\xb4\x01')\n\x0c\n\x04\x04\x01\x02'\x12\x04\xb5\x01\x08'\n\r\n\
    \x05\x04\x01\x02'\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x01\x02'\x05\
    \x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\x01\x02'\x01\x12\x04\xb5\x01\x18!\
    \n\r\n\x05\x04\x01\x02'\x03\x12\x04\xb5\x01$&\n\x0c\n\x04\x04\x01\x02(\
    \x12\x04\xb6\x01\x08(\n\r\n\x05\x04\x01\x02(\x04\x12\x04\xb6\x01\x08\x10\
    \n\r\n\x05\x04\x01\x02(\x05\x12\x04\xb6\x01\x11\x17\n\r\n\x05\x04\x01\
    \x02(\x01\x12\x04\xb6\x01\x18\"\n\r\n\x05\x04\x01\x02(\x03\x12\x04\xb6\
    \x01%'\n\x0c\n\x04\x04\x01\x02)\x12\x04\xb7\x01\x081\n\r\n\x05\x04\x01\
    \x02)\x04\x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\x01\x02)\x05\x12\x04\xb7\
    \x01\x11\x16\n\r\n\x05\x04\x01\x02)\x01\x12\x04\xb7\x01\x17+\n\r\n\x05\
    \x04\x01\x02)\x03\x12\x04\xb7\x01.0\n\x0c\n\x04\x04\x01\x02*\x12\x04\xb8\
    \x01\x083\n\r\n\x05\x04\x01\x02*\x04\x12\x04\xb8\x01\x08\x10\n\r\n\x05\
    \x04\x01\x02*\x05\x12\x04\xb8\x01\x11\x16\n\r\n\x05\x04\x01\x02*\x01\x12\
    \x04\xb8\x01\x17-\n\r\n\x05\x04\x01\x02*\x03\x12\x04\xb8\x0102\n\x0c\n\
    \x04\x04\x01\x02+\x12\x04\xb9\x01\x08\"\n\r\n\x05\x04\x01\x02+\x04\x12\
    \x04\xb9\x01\x08\x10\n\r\n\x05\x04\x01\x02+\x05\x12\x04\xb9\x01\x11\x16\
    \n\r\n\x05\x04\x01\x02+\x01\x12\x04\xb9\x01\x17\x1c\n\r\n\x05\x04\x01\
    \x02+\x03\x12\x04\xb9\x01\x1f!\n\x0c\n\x04\x04\x01\x02,\x12\x04\xba\x01\
    \x08\"\n\r\n\x05\x04\x01\x02,\x04\x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\
    \x01\x02,\x05\x12\x04\xba\x01\x11\x16\n\r\n\x05\x04\x01\x02,\x01\x12\x04\
    \xba\x01\x17\x1c\n\r\n\x05\x04\x01\x02,\x03\x12\x04\xba\x01\x1f!\n\x0c\n\
    \x04\x04\x01\x02-\x12\x04\xbb\x01\x08\"\n\r\n\x05\x04\x01\x02-\x04\x12\
    \x04\xbb\x01\x08\x10\n\r\n\x05\x04\x01\x02-\x05\x12\x04\xbb\x01\x11\x16\
    \n\r\n\x05\x04\x01\x02-\x01\x12\x04\xbb\x01\x17\x1c\n\r\n\x05\x04\x01\
    \x02-\x03\x12\x04\xbb\x01\x1f!\n\x0c\n\x04\x04\x01\x02.\x12\x04\xbc\x01\
    \x08\"\n\r\n\x05\x04\x01\x02.\x04\x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\
    \x01\x02.\x05\x12\x04\xbc\x01\x11\x16\n\r\n\x05\x04\x01\x02.\x01\x12\x04\
    \xbc\x01\x17\x1c\n\r\n\x05\x04\x01\x02.\x03\x12\x04\xbc\x01\x1f!\n\x0c\n\
    \x04\x04\x01\x02/\x12\x04\xbd\x01\x08\"\n\r\n\x05\x04\x01\x02/\x04\x12\
    \x04\xbd\x01\x08\x10\n\r\n\x05\x04\x01\x02/\x05\x12\x04\xbd\x01\x11\x16\
    \n\r\n\x05\x04\x01\x02/\x01\x12\x04\xbd\x01\x17\x1c\n\r\n\x05\x04\x01\
    \x02/\x03\x12\x04\xbd\x01\x1f!\n\x0c\n\x04\x04\x01\x020\x12\x04\xbe\x01\
    \x08\"\n\r\n\x05\x04\x01\x020\x04\x12\x04\xbe\x01\x08\x10\n\r\n\x05\x04\
    \x01\x020\x05\x12\x04\xbe\x01\x11\x16\n\r\n\x05\x04\x01\x020\x01\x12\x04\
    \xbe\x01\x17\x1c\n\r\n\x05\x04\x01\x020\x03\x12\x04\xbe\x01\x1f!\n\x0c\n\
    \x02\x04\x02\x12\x06\xc1\x01\0\xc3\x01\x01\n\x0b\n\x03\x04\x02\x01\x12\
    \x04\xc1\x01\x08!\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xc2\x01\x081\n\r\n\
    \x05\x04\x02\x02\0\x04\x12\x04\xc2\x01\x08\x10\n\r\n\x05\x04\x02\x02\0\
    \x06\x12\x04\xc2\x01\x11&\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xc2\x01',\
    \n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xc2\x01/0\n\x0c\n\x02\x04\x03\x12\
    \x06\xc5\x01\0\xdc\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xc5\x01\x08\
    \x18\n\x0e\n\x04\x04\x03\x03\0\x12\x06\xc6\x01\x08\xcb\x01\t\n\r\n\x05\
    \x04\x03\x03\0\x01\x12\x04\xc6\x01\x10\x20\n\x0e\n\x06\x04\x03\x03\0\x02\
    \0\x12\x04\xc7\x01\x103\n\x0f\n\x07\x04\x03\x03\0\x02\0\x04\x12\x04\xc7\
    \x01\x10\x18\n\x0f\n\x07\x04\x03\x03\0\x02\0\x05\x12\x04\xc7\x01\x19\x1e\
    \n\x0f\n\x07\x04\x03\x03\0\x02\0\x01\x12\x04\xc7\x01\x1f.\n\x0f\n\x07\
    \x04\x03\x03\0\x02\0\x03\x12\x04\xc7\x0112\n\x0e\n\x06\x04\x03\x03\0\x02\
    \x01\x12\x04\xc8\x01\x10/\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x04\x12\x04\
    \xc8\x01\x10\x18\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x05\x12\x04\xc8\x01\
    \x19\x1e\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x01\x12\x04\xc8\x01\x1f*\n\
    \x0f\n\x07\x04\x03\x03\0\x02\x01\x03\x12\x04\xc8\x01-.\n\x0e\n\x06\x04\
    \x03\x03\0\x02\x02\x12\x04\xc9\x01\x10-\n\x0f\n\x07\x04\x03\x03\0\x02\
    \x02\x04\x12\x04\xc9\x01\x10\x18\n\x0f\n\x07\x04\x03\x03\0\x02\x02\x05\
    \x12\x04\xc9\x01\x19\x1e\n\x0f\n\x07\x04\x03\x03\0\x02\x02\x01\x12\x04\
    \xc9\x01\x1f(\n\x0f\n\x07\x04\x03\x03\0\x02\x02\x03\x12\x04\xc9\x01+,\n\
    \x0e\n\x06\x04\x03\x03\0\x02\x03\x12\x04\xca\x01\x103\n\x0f\n\x07\x04\
    \x03\x03\0\x02\x03\x04\x12\x04\xca\x01\x10\x18\n\x0f\n\x07\x04\x03\x03\0\
    \x02\x03\x05\x12\x04\xca\x01\x19\x1e\n\x0f\n\x07\x04\x03\x03\0\x02\x03\
    \x01\x12\x04\xca\x01\x1f.\n\x0f\n\x07\x04\x03\x03\0\x02\x03\x03\x12\x04\
    \xca\x0112\n\x0e\n\x04\x04\x03\x03\x01\x12\x06\xcd\x01\x08\xd8\x01\t\n\r\
    \n\x05\x04\x03\x03\x01\x01\x12\x04\xcd\x01\x10\x19\n\x0e\n\x06\x04\x03\
    \x03\x01\x02\0\x12\x04\xce\x01\x101\n\x0f\n\x07\x04\x03\x03\x01\x02\0\
    \x04\x12\x04\xce\x01\x10\x18\n\x0f\n\x07\x04\x03\x03\x01\x02\0\x05\x12\
    \x04\xce\x01\x19\x1f\n\x0f\n\x07\x04\x03\x03\x01\x02\0\x01\x12\x04\xce\
    \x01\x20,\n\x0f\n\x07\x04\x03\x03\x01\x02\0\x03\x12\x04\xce\x01/0\n\x0e\
    \n\x06\x04\x03\x03\x01\x02\x01\x12\x04\xcf\x01\x10I\n\x0f\n\x07\x04\x03\
    \x03\x01\x02\x01\x04\x12\x04\xcf\x01\x10\x18\n\x0f\n\x07\x04\x03\x03\x01\
    \x02\x01\x06\x12\x04\xcf\x01\x19;\n\x0f\n\x07\x04\x03\x03\x01\x02\x01\
    \x01\x12\x04\xcf\x01<D\n\x0f\n\x07\x04\x03\x03\x01\x02\x01\x03\x12\x04\
    \xcf\x01GH\n\x0e\n\x06\x04\x03\x03\x01\x02\x02\x12\x04\xd0\x01\x10A\n\
    \x0f\n\x07\x04\x03\x03\x01\x02\x02\x04\x12\x04\xd0\x01\x10\x18\n\x0f\n\
    \x07\x04\x03\x03\x01\x02\x02\x06\x12\x04\xd0\x01\x197\n\x0f\n\x07\x04\
    \x03\x03\x01\x02\x02\x01\x12\x04\xd0\x018<\n\x0f\n\x07\x04\x03\x03\x01\
    \x02\x02\x03\x12\x04\xd0\x01?@\n\x0e\n\x06\x04\x03\x03\x01\x02\x03\x12\
    \x04\xd1\x01\x10E\n\x0f\n\x07\x04\x03\x03\x01\x02\x03\x04\x12\x04\xd1\
    \x01\x10\x18\n\x0f\n\x07\x04\x03\x03\x01\x02\x03\x06\x12\x04\xd1\x01\x19\
    9\n\x0f\n\x07\x04\x03\x03\x01\x02\x03\x01\x12\x04\xd1\x01:@\n\x0f\n\x07\
    \x04\x03\x03\x01\x02\x03\x03\x12\x04\xd1\x01CD\n\x0e\n\x06\x04\x03\x03\
    \x01\x02\x04\x12\x04\xd2\x01\x10)\n\x0f\n\x07\x04\x03\x03\x01\x02\x04\
    \x04\x12\x04\xd2\x01\x10\x18\n\x0f\n\x07\x04\x03\x03\x01\x02\x04\x05\x12\
    \x04\xd2\x01\x19\x1e\n\x0f\n\x07\x04\x03\x03\x01\x02\x04\x01\x12\x04\xd2\
    \x01\x1f$\n\x0f\n\x07\x04\x03\x03\x01\x02\x04\x03\x12\x04\xd2\x01'(\n\
    \x0e\n\x06\x04\x03\x03\x01\x02\x05\x12\x04\xd3\x01\x10.\n\x0f\n\x07\x04\
    \x03\x03\x01\x02\x05\x04\x12\x04\xd3\x01\x10\x18\n\x0f\n\x07\x04\x03\x03\
    \x01\x02\x05\x05\x12\x04\xd3\x01\x19\x1e\n\x0f\n\x07\x04\x03\x03\x01\x02\
    \x05\x01\x12\x04\xd3\x01\x1f)\n\x0f\n\x07\x04\x03\x03\x01\x02\x05\x03\
    \x12\x04\xd3\x01,-\n\x0e\n\x06\x04\x03\x03\x01\x02\x06\x12\x04\xd4\x01\
    \x10,\n\x0f\n\x07\x04\x03\x03\x01\x02\x06\x04\x12\x04\xd4\x01\x10\x18\n\
    \x0f\n\x07\x04\x03\x03\x01\x02\x06\x05\x12\x04\xd4\x01\x19\x1f\n\x0f\n\
    \x07\x04\x03\x03\x01\x02\x06\x01\x12\x04\xd4\x01\x20'\n\x0f\n\x07\x04\
    \x03\x03\x01\x02\x06\x03\x12\x04\xd4\x01*+\n\x0e\n\x06\x04\x03\x03\x01\
    \x02\x07\x12\x04\xd5\x01\x108\n\x0f\n\x07\x04\x03\x03\x01\x02\x07\x04\
    \x12\x04\xd5\x01\x10\x18\n\x0f\n\x07\x04\x03\x03\x01\x02\x07\x06\x12\x04\
    \xd5\x01\x19.\n\x0f\n\x07\x04\x03\x03\x01\x02\x07\x01\x12\x04\xd5\x01/3\
    \n\x0f\n\x07\x04\x03\x03\x01\x02\x07\x03\x12\x04\xd5\x0167\n\x0e\n\x06\
    \x04\x03\x03\x01\x02\x08\x12\x04\xd6\x01\x10:\n\x0f\n\x07\x04\x03\x03\
    \x01\x02\x08\x04\x12\x04\xd6\x01\x10\x18\n\x0f\n\x07\x04\x03\x03\x01\x02\
    \x08\x05\x12\x04\xd6\x01\x19\x1e\n\x0f\n\x07\x04\x03\x03\x01\x02\x08\x01\
    \x12\x04\xd6\x01\x1f5\n\x0f\n\x07\x04\x03\x03\x01\x02\x08\x03\x12\x04\
    \xd6\x0189\n\x0e\n\x06\x04\x03\x03\x01\x02\t\x12\x04\xd7\x01\x10F\n\x0f\
    \n\x07\x04\x03\x03\x01\x02\t\x04\x12\x04\xd7\x01\x10\x18\n\x0f\n\x07\x04\
    \x03\x03\x01\x02\t\x06\x12\x04\xd7\x01\x198\n\x0f\n\x07\x04\x03\x03\x01\
    \x02\t\x01\x12\x04\xd7\x019@\n\x0f\n\x07\x04\x03\x03\x01\x02\t\x03\x12\
    \x04\xd7\x01CE\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xda\x01\x081\n\r\n\x05\
    \x04\x03\x02\0\x04\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x03\x02\0\x06\
    \x12\x04\xda\x01\x11&\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xda\x01',\n\r\
    \n\x05\x04\x03\x02\0\x03\x12\x04\xda\x01/0\n\x0c\n\x04\x04\x03\x02\x01\
    \x12\x04\xdb\x01\x08;\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04\xdb\x01\x08\
    \x10\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\xdb\x01\x11+\n\r\n\x05\x04\
    \x03\x02\x01\x01\x12\x04\xdb\x01,6\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\
    \xdb\x019:\n\x0c\n\x02\x04\x04\x12\x06\xde\x01\0\xe6\x01\x01\n\x0b\n\x03\
    \x04\x04\x01\x12\x04\xde\x01\x08\x1c\n\x0c\n\x04\x04\x04\x02\0\x12\x04\
    \xdf\x01\x08&\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\xdf\x01\x08\x10\n\r\n\
    \x05\x04\x04\x02\0\x05\x12\x04\xdf\x01\x11\x17\n\r\n\x05\x04\x04\x02\0\
    \x01\x12\x04\xdf\x01\x18!\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xdf\x01$%\
    \n\x0c\n\x04\x04\x04\x02\x01\x12\x04\xe0\x01\x08%\n\r\n\x05\x04\x04\x02\
    \x01\x04\x12\x04\xe0\x01\x08\x10\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\
    \xe0\x01\x11\x17\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xe0\x01\x18\x20\n\
    \r\n\x05\x04\x04\x02\x01\x03\x12\x04\xe0\x01#$\n\x0c\n\x04\x04\x04\x02\
    \x02\x12\x04\xe1\x01\x08'\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\xe1\x01\
    \x08\x10\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xe1\x01\x11\x15\n\r\n\x05\
    \x04\x04\x02\x02\x01\x12\x04\xe1\x01\x16\"\n\r\n\x05\x04\x04\x02\x02\x03\
    \x12\x04\xe1\x01%&\n\x0c\n\x04\x04\x04\x02\x03\x12\x04\xe2\x01\x08-\n\r\
    \n\x05\x04\x04\x02\x03\x04\x12\x04\xe2\x01\x08\x10\n\r\n\x05\x04\x04\x02\
    \x03\x05\x12\x04\xe2\x01\x11\x17\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\
    \xe2\x01\x18(\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xe2\x01+,\n\x0c\n\
    \x04\x04\x04\x02\x04\x12\x04\xe3\x01\x08.\n\r\n\x05\x04\x04\x02\x04\x04\
    \x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\xe3\x01\
    \x11\x17\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\xe3\x01\x18)\n\r\n\x05\
    \x04\x04\x02\x04\x03\x12\x04\xe3\x01,-\n\x0c\n\x04\x04\x04\x02\x05\x12\
    \x04\xe4\x01\x08)\n\r\n\x05\x04\x04\x02\x05\x04\x12\x04\xe4\x01\x08\x10\
    \n\r\n\x05\x04\x04\x02\x05\x05\x12\x04\xe4\x01\x11\x17\n\r\n\x05\x04\x04\
    \x02\x05\x01\x12\x04\xe4\x01\x18$\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\
    \xe4\x01'(\n\x0c\n\x04\x04\x04\x02\x06\x12\x04\xe5\x01\x08)\n\r\n\x05\
    \x04\x04\x02\x06\x04\x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x04\x02\x06\
    \x05\x12\x04\xe5\x01\x11\x17\n\r\n\x05\x04\x04\x02\x06\x01\x12\x04\xe5\
    \x01\x18$\n\r\n\x05\x04\x04\x02\x06\x03\x12\x04\xe5\x01'(\n\x0c\n\x02\
    \x04\x05\x12\x06\xe8\x01\0\xea\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\
    \xe8\x01\x08\x20\n\x0c\n\x04\x04\x05\x02\0\x12\x04\xe9\x01\x08=\n\r\n\
    \x05\x04\x05\x02\0\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\
    \x06\x12\x04\xe9\x01\x11%\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xe9\x01&8\
    \n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xe9\x01;<\n\x0c\n\x02\x04\x06\x12\
    \x06\xec\x01\0\xee\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xec\x01\x08\"\
    \n\x0c\n\x04\x04\x06\x02\0\x12\x04\xed\x01\x08;\n\r\n\x05\x04\x06\x02\0\
    \x04\x12\x04\xed\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xed\x01\
    \x11+\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xed\x01,6\n\r\n\x05\x04\x06\
    \x02\0\x03\x12\x04\xed\x019:\n\x0c\n\x02\x04\x07\x12\x06\xf0\x01\0\x99\
    \x02\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xf0\x01\x08&\n\x0e\n\x04\x04\
    \x07\x03\0\x12\x06\xf1\x01\x08\xf4\x01\t\n\r\n\x05\x04\x07\x03\0\x01\x12\
    \x04\xf1\x01\x10$\n\x0e\n\x06\x04\x07\x03\0\x02\0\x12\x04\xf2\x01\x10(\n\
    \x0f\n\x07\x04\x07\x03\0\x02\0\x04\x12\x04\xf2\x01\x10\x18\n\x0f\n\x07\
    \x04\x07\x03\0\x02\0\x05\x12\x04\xf2\x01\x19\x1e\n\x0f\n\x07\x04\x07\x03\
    \0\x02\0\x01\x12\x04\xf2\x01\x1f#\n\x0f\n\x07\x04\x07\x03\0\x02\0\x03\
    \x12\x04\xf2\x01&'\n\x0e\n\x06\x04\x07\x03\0\x02\x01\x12\x04\xf3\x01\x10\
    )\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x04\x12\x04\xf3\x01\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x05\x12\x04\xf3\x01\x19\x1e\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x01\x01\x12\x04\xf3\x01\x1f$\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x01\x03\x12\x04\xf3\x01'(\n\x0e\n\x04\x04\x07\x03\x01\x12\x06\xf6\
    \x01\x08\x96\x02\t\n\r\n\x05\x04\x07\x03\x01\x01\x12\x04\xf6\x01\x10)\n\
    \x0e\n\x06\x04\x07\x03\x01\x02\0\x12\x04\xf7\x01\x10,\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\0\x04\x12\x04\xf7\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\0\x05\x12\x04\xf7\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\x01\x02\0\
    \x01\x12\x04\xf7\x01\x20'\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x03\x12\x04\
    \xf7\x01*+\n\x0e\n\x06\x04\x07\x03\x01\x02\x01\x12\x04\xf8\x01\x107\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x01\x04\x12\x04\xf8\x01\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x01\x05\x12\x04\xf8\x01\x19\x1f\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x01\x01\x12\x04\xf8\x01\x202\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x01\x03\x12\x04\xf8\x0156\n\x0e\n\x06\x04\x07\x03\x01\x02\x02\
    \x12\x04\xf9\x01\x10/\n\x0f\n\x07\x04\x07\x03\x01\x02\x02\x04\x12\x04\
    \xf9\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x02\x05\x12\x04\xf9\x01\
    \x19\x1f\n\x0f\n\x07\x04\x07\x03\x01\x02\x02\x01\x12\x04\xf9\x01\x20*\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x02\x03\x12\x04\xf9\x01-.\n\x0e\n\x06\x04\
    \x07\x03\x01\x02\x03\x12\x04\xfa\x01\x10.\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x03\x04\x12\x04\xfa\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x03\
    \x05\x12\x04\xfa\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\x01\x02\x03\x01\x12\
    \x04\xfa\x01\x20)\n\x0f\n\x07\x04\x07\x03\x01\x02\x03\x03\x12\x04\xfa\
    \x01,-\n\x0e\n\x06\x04\x07\x03\x01\x02\x04\x12\x04\xfb\x01\x103\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x04\x04\x12\x04\xfb\x01\x10\x18\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x04\x05\x12\x04\xfb\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x04\x01\x12\x04\xfb\x01\x20.\n\x0f\n\x07\x04\x07\x03\x01\x02\
    \x04\x03\x12\x04\xfb\x0112\n\x0e\n\x06\x04\x07\x03\x01\x02\x05\x12\x04\
    \xfc\x01\x10W\n\x0f\n\x07\x04\x07\x03\x01\x02\x05\x04\x12\x04\xfc\x01\
    \x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x05\x06\x12\x04\xfc\x01\x19L\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x05\x01\x12\x04\xfc\x01MR\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x05\x03\x12\x04\xfc\x01UV\n\x0e\n\x06\x04\x07\x03\x01\
    \x02\x06\x12\x04\xfd\x01\x10X\n\x0f\n\x07\x04\x07\x03\x01\x02\x06\x04\
    \x12\x04\xfd\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x06\x06\x12\x04\
    \xfd\x01\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x06\x01\x12\x04\xfd\x01MS\
    \n\x0f\n\x07\x04\x07\x03\x01\x02\x06\x03\x12\x04\xfd\x01VW\n\x0e\n\x06\
    \x04\x07\x03\x01\x02\x07\x12\x04\xfe\x01\x10Y\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x07\x04\x12\x04\xfe\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\
    \x07\x06\x12\x04\xfe\x01\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x07\x01\
    \x12\x04\xfe\x01MT\n\x0f\n\x07\x04\x07\x03\x01\x02\x07\x03\x12\x04\xfe\
    \x01WX\n\x0e\n\x06\x04\x07\x03\x01\x02\x08\x12\x04\xff\x01\x10]\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x08\x04\x12\x04\xff\x01\x10\x18\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x08\x06\x12\x04\xff\x01\x19L\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x08\x01\x12\x04\xff\x01MX\n\x0f\n\x07\x04\x07\x03\x01\x02\x08\
    \x03\x12\x04\xff\x01[\\\n\x0e\n\x06\x04\x07\x03\x01\x02\t\x12\x04\x80\
    \x02\x10\\\n\x0f\n\x07\x04\x07\x03\x01\x02\t\x04\x12\x04\x80\x02\x10\x18\
    \n\x0f\n\x07\x04\x07\x03\x01\x02\t\x06\x12\x04\x80\x02\x19L\n\x0f\n\x07\
    \x04\x07\x03\x01\x02\t\x01\x12\x04\x80\x02MV\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\t\x03\x12\x04\x80\x02Y[\n\x0e\n\x06\x04\x07\x03\x01\x02\n\x12\x04\
    \x81\x02\x10Y\n\x0f\n\x07\x04\x07\x03\x01\x02\n\x04\x12\x04\x81\x02\x10\
    \x18\n\x0f\n\x07\x04\x07\x03\x01\x02\n\x06\x12\x04\x81\x02\x19L\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\n\x01\x12\x04\x81\x02MS\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\n\x03\x12\x04\x81\x02VX\n\x0e\n\x06\x04\x07\x03\x01\x02\x0b\x12\
    \x04\x82\x02\x10V\n\x0f\n\x07\x04\x07\x03\x01\x02\x0b\x04\x12\x04\x82\
    \x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x0b\x06\x12\x04\x82\x02\x19\
    L\n\x0f\n\x07\x04\x07\x03\x01\x02\x0b\x01\x12\x04\x82\x02MP\n\x0f\n\x07\
    \x04\x07\x03\x01\x02\x0b\x03\x12\x04\x82\x02SU\n\x0e\n\x06\x04\x07\x03\
    \x01\x02\x0c\x12\x04\x83\x02\x10V\n\x0f\n\x07\x04\x07\x03\x01\x02\x0c\
    \x04\x12\x04\x83\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x0c\x06\x12\
    \x04\x83\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x0c\x01\x12\x04\x83\
    \x02MP\n\x0f\n\x07\x04\x07\x03\x01\x02\x0c\x03\x12\x04\x83\x02SU\n\x0e\n\
    \x06\x04\x07\x03\x01\x02\r\x12\x04\x84\x02\x10_\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\r\x04\x12\x04\x84\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\r\
    \x06\x12\x04\x84\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\r\x01\x12\x04\
    \x84\x02MY\n\x0f\n\x07\x04\x07\x03\x01\x02\r\x03\x12\x04\x84\x02\\^\n\
    \x0e\n\x06\x04\x07\x03\x01\x02\x0e\x12\x04\x85\x02\x10_\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x0e\x04\x12\x04\x85\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x0e\x06\x12\x04\x85\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\
    \x0e\x01\x12\x04\x85\x02MY\n\x0f\n\x07\x04\x07\x03\x01\x02\x0e\x03\x12\
    \x04\x85\x02\\^\n\x0e\n\x06\x04\x07\x03\x01\x02\x0f\x12\x04\x86\x02\x10^\
    \n\x0f\n\x07\x04\x07\x03\x01\x02\x0f\x04\x12\x04\x86\x02\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x0f\x06\x12\x04\x86\x02\x19L\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x0f\x01\x12\x04\x86\x02MX\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x0f\x03\x12\x04\x86\x02[]\n\x0e\n\x06\x04\x07\x03\x01\x02\x10\x12\
    \x04\x87\x02\x10^\n\x0f\n\x07\x04\x07\x03\x01\x02\x10\x04\x12\x04\x87\
    \x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x10\x06\x12\x04\x87\x02\x19\
    L\n\x0f\n\x07\x04\x07\x03\x01\x02\x10\x01\x12\x04\x87\x02MX\n\x0f\n\x07\
    \x04\x07\x03\x01\x02\x10\x03\x12\x04\x87\x02[]\n\x0e\n\x06\x04\x07\x03\
    \x01\x02\x11\x12\x04\x88\x02\x10p\n\x0f\n\x07\x04\x07\x03\x01\x02\x11\
    \x04\x12\x04\x88\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x11\x06\x12\
    \x04\x88\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x11\x01\x12\x04\x88\
    \x02Mj\n\x0f\n\x07\x04\x07\x03\x01\x02\x11\x03\x12\x04\x88\x02mo\n\x0e\n\
    \x06\x04\x07\x03\x01\x02\x12\x12\x04\x89\x02\x10s\n\x0f\n\x07\x04\x07\
    \x03\x01\x02\x12\x04\x12\x04\x89\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x12\x06\x12\x04\x89\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x12\
    \x01\x12\x04\x89\x02Mm\n\x0f\n\x07\x04\x07\x03\x01\x02\x12\x03\x12\x04\
    \x89\x02pr\n\x0e\n\x06\x04\x07\x03\x01\x02\x13\x12\x04\x8a\x02\x10e\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x13\x04\x12\x04\x8a\x02\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x13\x06\x12\x04\x8a\x02\x19L\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x13\x01\x12\x04\x8a\x02M_\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x13\x03\x12\x04\x8a\x02bd\n\x0e\n\x06\x04\x07\x03\x01\x02\x14\x12\
    \x04\x8b\x02\x10a\n\x0f\n\x07\x04\x07\x03\x01\x02\x14\x04\x12\x04\x8b\
    \x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x14\x06\x12\x04\x8b\x02\x19\
    L\n\x0f\n\x07\x04\x07\x03\x01\x02\x14\x01\x12\x04\x8b\x02M[\n\x0f\n\x07\
    \x04\x07\x03\x01\x02\x14\x03\x12\x04\x8b\x02^`\n\x0e\n\x06\x04\x07\x03\
    \x01\x02\x15\x12\x04\x8c\x02\x10Z\n\x0f\n\x07\x04\x07\x03\x01\x02\x15\
    \x04\x12\x04\x8c\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x15\x06\x12\
    \x04\x8c\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x15\x01\x12\x04\x8c\
    \x02MT\n\x0f\n\x07\x04\x07\x03\x01\x02\x15\x03\x12\x04\x8c\x02WY\n\x0e\n\
    \x06\x04\x07\x03\x01\x02\x16\x12\x04\x8d\x02\x10`\n\x0f\n\x07\x04\x07\
    \x03\x01\x02\x16\x04\x12\x04\x8d\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x16\x06\x12\x04\x8d\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x16\
    \x01\x12\x04\x8d\x02MZ\n\x0f\n\x07\x04\x07\x03\x01\x02\x16\x03\x12\x04\
    \x8d\x02]_\n\x0e\n\x06\x04\x07\x03\x01\x02\x17\x12\x04\x8e\x02\x10_\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x17\x04\x12\x04\x8e\x02\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x17\x06\x12\x04\x8e\x02\x19L\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x17\x01\x12\x04\x8e\x02MY\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x17\x03\x12\x04\x8e\x02\\^\n\x0e\n\x06\x04\x07\x03\x01\x02\x18\x12\
    \x04\x8f\x02\x10^\n\x0f\n\x07\x04\x07\x03\x01\x02\x18\x04\x12\x04\x8f\
    \x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x18\x06\x12\x04\x8f\x02\x19\
    L\n\x0f\n\x07\x04\x07\x03\x01\x02\x18\x01\x12\x04\x8f\x02MX\n\x0f\n\x07\
    \x04\x07\x03\x01\x02\x18\x03\x12\x04\x8f\x02[]\n\x0e\n\x06\x04\x07\x03\
    \x01\x02\x19\x12\x04\x90\x02\x10_\n\x0f\n\x07\x04\x07\x03\x01\x02\x19\
    \x04\x12\x04\x90\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x19\x06\x12\
    \x04\x90\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x19\x01\x12\x04\x90\
    \x02MY\n\x0f\n\x07\x04\x07\x03\x01\x02\x19\x03\x12\x04\x90\x02\\^\n\x0e\
    \n\x06\x04\x07\x03\x01\x02\x1a\x12\x04\x91\x02\x10_\n\x0f\n\x07\x04\x07\
    \x03\x01\x02\x1a\x04\x12\x04\x91\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x1a\x06\x12\x04\x91\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x1a\
    \x01\x12\x04\x91\x02MY\n\x0f\n\x07\x04\x07\x03\x01\x02\x1a\x03\x12\x04\
    \x91\x02\\^\n\x0e\n\x06\x04\x07\x03\x01\x02\x1b\x12\x04\x92\x02\x10d\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x1b\x04\x12\x04\x92\x02\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x1b\x06\x12\x04\x92\x02\x19L\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x1b\x01\x12\x04\x92\x02M^\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x1b\x03\x12\x04\x92\x02ac\n\x0e\n\x06\x04\x07\x03\x01\x02\x1c\x12\
    \x04\x93\x02\x10`\n\x0f\n\x07\x04\x07\x03\x01\x02\x1c\x04\x12\x04\x93\
    \x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x1c\x06\x12\x04\x93\x02\x19\
    L\n\x0f\n\x07\x04\x07\x03\x01\x02\x1c\x01\x12\x04\x93\x02MZ\n\x0f\n\x07\
    \x04\x07\x03\x01\x02\x1c\x03\x12\x04\x93\x02]_\n\x0e\n\x06\x04\x07\x03\
    \x01\x02\x1d\x12\x04\x94\x02\x10[\n\x0f\n\x07\x04\x07\x03\x01\x02\x1d\
    \x04\x12\x04\x94\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x1d\x06\x12\
    \x04\x94\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x1d\x01\x12\x04\x94\
    \x02MU\n\x0f\n\x07\x04\x07\x03\x01\x02\x1d\x03\x12\x04\x94\x02XZ\n\x0e\n\
    \x06\x04\x07\x03\x01\x02\x1e\x12\x04\x95\x02\x10h\n\x0f\n\x07\x04\x07\
    \x03\x01\x02\x1e\x04\x12\x04\x95\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x1e\x06\x12\x04\x95\x02\x19L\n\x0f\n\x07\x04\x07\x03\x01\x02\x1e\
    \x01\x12\x04\x95\x02Mb\n\x0f\n\x07\x04\x07\x03\x01\x02\x1e\x03\x12\x04\
    \x95\x02eg\n\x0c\n\x04\x04\x07\x02\0\x12\x04\x98\x02\x08U\n\r\n\x05\x04\
    \x07\x02\0\x04\x12\x04\x98\x02\x08\x10\n\r\n\x05\x04\x07\x02\0\x06\x12\
    \x04\x98\x02\x11I\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x98\x02JP\n\r\n\
    \x05\x04\x07\x02\0\x03\x12\x04\x98\x02ST\n\x0c\n\x02\x04\x08\x12\x06\x9b\
    \x02\0\x9c\x02\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\x9b\x02\x08.\n\x0c\n\
    \x02\x04\t\x12\x06\x9e\x02\0\xb2\x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\
    \x9e\x02\x08-\n\x0e\n\x04\x04\t\x04\0\x12\x06\x9f\x02\x08\xac\x02\t\n\r\
    \n\x05\x04\t\x04\0\x01\x12\x04\x9f\x02\r\x16\n\x0e\n\x06\x04\t\x04\0\x02\
    \0\x12\x04\xa0\x02\x10%\n\x0f\n\x07\x04\t\x04\0\x02\0\x01\x12\x04\xa0\
    \x02\x10\x20\n\x0f\n\x07\x04\t\x04\0\x02\0\x02\x12\x04\xa0\x02#$\n\x0e\n\
    \x06\x04\t\x04\0\x02\x01\x12\x04\xa1\x02\x10\x1f\n\x0f\n\x07\x04\t\x04\0\
    \x02\x01\x01\x12\x04\xa1\x02\x10\x1a\n\x0f\n\x07\x04\t\x04\0\x02\x01\x02\
    \x12\x04\xa1\x02\x1d\x1e\n\x0e\n\x06\x04\t\x04\0\x02\x02\x12\x04\xa2\x02\
    \x10\x1f\n\x0f\n\x07\x04\t\x04\0\x02\x02\x01\x12\x04\xa2\x02\x10\x1a\n\
    \x0f\n\x07\x04\t\x04\0\x02\x02\x02\x12\x04\xa2\x02\x1d\x1e\n\x0e\n\x06\
    \x04\t\x04\0\x02\x03\x12\x04\xa3\x02\x10\x20\n\x0f\n\x07\x04\t\x04\0\x02\
    \x03\x01\x12\x04\xa3\x02\x10\x1b\n\x0f\n\x07\x04\t\x04\0\x02\x03\x02\x12\
    \x04\xa3\x02\x1e\x1f\n\x0e\n\x06\x04\t\x04\0\x02\x04\x12\x04\xa4\x02\x10\
    (\n\x0f\n\x07\x04\t\x04\0\x02\x04\x01\x12\x04\xa4\x02\x10#\n\x0f\n\x07\
    \x04\t\x04\0\x02\x04\x02\x12\x04\xa4\x02&'\n\x0e\n\x06\x04\t\x04\0\x02\
    \x05\x12\x04\xa5\x02\x10/\n\x0f\n\x07\x04\t\x04\0\x02\x05\x01\x12\x04\
    \xa5\x02\x10*\n\x0f\n\x07\x04\t\x04\0\x02\x05\x02\x12\x04\xa5\x02-.\n\
    \x0e\n\x06\x04\t\x04\0\x02\x06\x12\x04\xa6\x02\x10)\n\x0f\n\x07\x04\t\
    \x04\0\x02\x06\x01\x12\x04\xa6\x02\x10$\n\x0f\n\x07\x04\t\x04\0\x02\x06\
    \x02\x12\x04\xa6\x02'(\n\x0e\n\x06\x04\t\x04\0\x02\x07\x12\x04\xa7\x02\
    \x10.\n\x0f\n\x07\x04\t\x04\0\x02\x07\x01\x12\x04\xa7\x02\x10)\n\x0f\n\
    \x07\x04\t\x04\0\x02\x07\x02\x12\x04\xa7\x02,-\n\x0e\n\x06\x04\t\x04\0\
    \x02\x08\x12\x04\xa8\x02\x100\n\x0f\n\x07\x04\t\x04\0\x02\x08\x01\x12\
    \x04\xa8\x02\x10+\n\x0f\n\x07\x04\t\x04\0\x02\x08\x02\x12\x04\xa8\x02./\
    \n\x0e\n\x06\x04\t\x04\0\x02\t\x12\x04\xa9\x02\x100\n\x0f\n\x07\x04\t\
    \x04\0\x02\t\x01\x12\x04\xa9\x02\x10+\n\x0f\n\x07\x04\t\x04\0\x02\t\x02\
    \x12\x04\xa9\x02./\n\x0e\n\x06\x04\t\x04\0\x02\n\x12\x04\xaa\x02\x10.\n\
    \x0f\n\x07\x04\t\x04\0\x02\n\x01\x12\x04\xaa\x02\x10(\n\x0f\n\x07\x04\t\
    \x04\0\x02\n\x02\x12\x04\xaa\x02+-\n\x0e\n\x06\x04\t\x04\0\x02\x0b\x12\
    \x04\xab\x02\x10-\n\x0f\n\x07\x04\t\x04\0\x02\x0b\x01\x12\x04\xab\x02\
    \x10'\n\x0f\n\x07\x04\t\x04\0\x02\x0b\x02\x12\x04\xab\x02*,\n\x0c\n\x04\
    \x04\t\x02\0\x12\x04\xae\x02\x08-\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xae\
    \x02\x08\x10\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xae\x02\x11!\n\r\n\x05\
    \x04\t\x02\0\x01\x12\x04\xae\x02\"(\n\r\n\x05\x04\t\x02\0\x03\x12\x04\
    \xae\x02+,\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xaf\x02\x08N\n\r\n\x05\x04\
    \t\x02\x01\x04\x12\x04\xaf\x02\x08\x10\n\r\n\x05\x04\t\x02\x01\x06\x12\
    \x04\xaf\x02\x11@\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xaf\x02AI\n\r\n\
    \x05\x04\t\x02\x01\x03\x12\x04\xaf\x02LM\n\x0c\n\x04\x04\t\x02\x02\x12\
    \x04\xb0\x02\x08D\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xb0\x02\x08\x10\n\
    \r\n\x05\x04\t\x02\x02\x06\x12\x04\xb0\x02\x11/\n\r\n\x05\x04\t\x02\x02\
    \x01\x12\x04\xb0\x020?\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xb0\x02BC\n\
    \x0c\n\x04\x04\t\x02\x03\x12\x04\xb1\x02\x08/\n\r\n\x05\x04\t\x02\x03\
    \x04\x12\x04\xb1\x02\x08\x10\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\xb1\x02\
    \x11%\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xb1\x02&*\n\r\n\x05\x04\t\x02\
    \x03\x03\x12\x04\xb1\x02-.\n\x0c\n\x02\x04\n\x12\x06\xb4\x02\0\xbe\x02\
    \x01\n\x0b\n\x03\x04\n\x01\x12\x04\xb4\x02\x083\n\x0e\n\x04\x04\n\x03\0\
    \x12\x06\xb5\x02\x08\xb8\x02\t\n\r\n\x05\x04\n\x03\0\x01\x12\x04\xb5\x02\
    \x10,\n\x0e\n\x06\x04\n\x03\0\x02\0\x12\x04\xb6\x02\x10,\n\x0f\n\x07\x04\
    \n\x03\0\x02\0\x04\x12\x04\xb6\x02\x10\x18\n\x0f\n\x07\x04\n\x03\0\x02\0\
    \x05\x12\x04\xb6\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\0\x02\0\x01\x12\x04\
    \xb6\x02\x20'\n\x0f\n\x07\x04\n\x03\0\x02\0\x03\x12\x04\xb6\x02*+\n\x0e\
    \n\x06\x04\n\x03\0\x02\x01\x12\x04\xb7\x02\x107\n\x0f\n\x07\x04\n\x03\0\
    \x02\x01\x04\x12\x04\xb7\x02\x10\x18\n\x0f\n\x07\x04\n\x03\0\x02\x01\x05\
    \x12\x04\xb7\x02\x19\x1f\n\x0f\n\x07\x04\n\x03\0\x02\x01\x01\x12\x04\xb7\
    \x02\x202\n\x0f\n\x07\x04\n\x03\0\x02\x01\x03\x12\x04\xb7\x0256\n\x0c\n\
    \x04\x04\n\x02\0\x12\x04\xba\x02\x08m\n\r\n\x05\x04\n\x02\0\x04\x12\x04\
    \xba\x02\x08\x10\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xba\x02\x11Y\n\r\n\
    \x05\x04\n\x02\0\x01\x12\x04\xba\x02Zh\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \xba\x02kl\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xbb\x02\x08&\n\r\n\x05\x04\
    \n\x02\x01\x04\x12\x04\xbb\x02\x08\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\
    \x04\xbb\x02\x11\x17\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xbb\x02\x18!\n\
    \r\n\x05\x04\n\x02\x01\x03\x12\x04\xbb\x02$%\n\x0c\n\x04\x04\n\x02\x02\
    \x12\x04\xbc\x02\x08%\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\xbc\x02\x08\
    \x10\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xbc\x02\x11\x17\n\r\n\x05\x04\n\
    \x02\x02\x01\x12\x04\xbc\x02\x18\x20\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\
    \xbc\x02#$\n\x0c\n\x04\x04\n\x02\x03\x12\x04\xbd\x02\x08!\n\r\n\x05\x04\
    \n\x02\x03\x04\x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04\n\x02\x03\x05\x12\
    \x04\xbd\x02\x11\x17\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xbd\x02\x18\x1c\
    \n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xbd\x02\x1f\x20\n\x0c\n\x02\x04\x0b\
    \x12\x06\xc0\x02\0\xcd\x02\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xc0\x02\
    \x08;\n\x0e\n\x04\x04\x0b\x04\0\x12\x06\xc1\x02\x08\xc9\x02\t\n\r\n\x05\
    \x04\x0b\x04\0\x01\x12\x04\xc1\x02\r\x16\n\x0e\n\x06\x04\x0b\x04\0\x02\0\
    \x12\x04\xc2\x02\x10%\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x01\x12\x04\xc2\
    \x02\x10\x20\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x02\x12\x04\xc2\x02#$\n\x0e\
    \n\x06\x04\x0b\x04\0\x02\x01\x12\x04\xc3\x02\x10\x1f\n\x0f\n\x07\x04\x0b\
    \x04\0\x02\x01\x01\x12\x04\xc3\x02\x10\x1a\n\x0f\n\x07\x04\x0b\x04\0\x02\
    \x01\x02\x12\x04\xc3\x02\x1d\x1e\n\x0e\n\x06\x04\x0b\x04\0\x02\x02\x12\
    \x04\xc4\x02\x10\x1f\n\x0f\n\x07\x04\x0b\x04\0\x02\x02\x01\x12\x04\xc4\
    \x02\x10\x1a\n\x0f\n\x07\x04\x0b\x04\0\x02\x02\x02\x12\x04\xc4\x02\x1d\
    \x1e\n\x0e\n\x06\x04\x0b\x04\0\x02\x03\x12\x04\xc5\x02\x10\x20\n\x0f\n\
    \x07\x04\x0b\x04\0\x02\x03\x01\x12\x04\xc5\x02\x10\x1b\n\x0f\n\x07\x04\
    \x0b\x04\0\x02\x03\x02\x12\x04\xc5\x02\x1e\x1f\n\x0e\n\x06\x04\x0b\x04\0\
    \x02\x04\x12\x04\xc6\x02\x10(\n\x0f\n\x07\x04\x0b\x04\0\x02\x04\x01\x12\
    \x04\xc6\x02\x10#\n\x0f\n\x07\x04\x0b\x04\0\x02\x04\x02\x12\x04\xc6\x02&\
    '\n\x0e\n\x06\x04\x0b\x04\0\x02\x05\x12\x04\xc7\x02\x10%\n\x0f\n\x07\x04\
    \x0b\x04\0\x02\x05\x01\x12\x04\xc7\x02\x10\x20\n\x0f\n\x07\x04\x0b\x04\0\
    \x02\x05\x02\x12\x04\xc7\x02#$\n\x0e\n\x06\x04\x0b\x04\0\x02\x06\x12\x04\
    \xc8\x02\x10/\n\x0f\n\x07\x04\x0b\x04\0\x02\x06\x01\x12\x04\xc8\x02\x10*\
    \n\x0f\n\x07\x04\x0b\x04\0\x02\x06\x02\x12\x04\xc8\x02-.\n\x0c\n\x04\x04\
    \x0b\x02\0\x12\x04\xcb\x02\x08D\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xcb\
    \x02\x08\x10\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xcb\x02\x11/\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\xcb\x020?\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\
    \xcb\x02BC\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xcc\x02\x08\\\n\r\n\x05\
    \x04\x0b\x02\x01\x04\x12\x04\xcc\x02\x08\x10\n\r\n\x05\x04\x0b\x02\x01\
    \x06\x12\x04\xcc\x02\x11N\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xcc\x02O\
    W\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xcc\x02Z[\n\x0c\n\x02\x04\x0c\
    \x12\x06\xcf\x02\0\xd1\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xcf\x02\
    \x08)\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xd0\x02\x08'\n\r\n\x05\x04\x0c\
    \x02\0\x04\x12\x04\xd0\x02\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\
    \xd0\x02\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xd0\x02\x18\"\n\r\n\
    \x05\x04\x0c\x02\0\x03\x12\x04\xd0\x02%&\n\x0c\n\x02\x04\r\x12\x06\xd3\
    \x02\0\xdf\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xd3\x02\x081\n\x0e\n\
    \x04\x04\r\x04\0\x12\x06\xd4\x02\x08\xdb\x02\t\n\r\n\x05\x04\r\x04\0\x01\
    \x12\x04\xd4\x02\r\x16\n\x0e\n\x06\x04\r\x04\0\x02\0\x12\x04\xd5\x02\x10\
    %\n\x0f\n\x07\x04\r\x04\0\x02\0\x01\x12\x04\xd5\x02\x10\x20\n\x0f\n\x07\
    \x04\r\x04\0\x02\0\x02\x12\x04\xd5\x02#$\n\x0e\n\x06\x04\r\x04\0\x02\x01\
    \x12\x04\xd6\x02\x10\x1f\n\x0f\n\x07\x04\r\x04\0\x02\x01\x01\x12\x04\xd6\
    \x02\x10\x1a\n\x0f\n\x07\x04\r\x04\0\x02\x01\x02\x12\x04\xd6\x02\x1d\x1e\
    \n\x0e\n\x06\x04\r\x04\0\x02\x02\x12\x04\xd7\x02\x10\x1f\n\x0f\n\x07\x04\
    \r\x04\0\x02\x02\x01\x12\x04\xd7\x02\x10\x1a\n\x0f\n\x07\x04\r\x04\0\x02\
    \x02\x02\x12\x04\xd7\x02\x1d\x1e\n\x0e\n\x06\x04\r\x04\0\x02\x03\x12\x04\
    \xd8\x02\x10\x20\n\x0f\n\x07\x04\r\x04\0\x02\x03\x01\x12\x04\xd8\x02\x10\
    \x1b\n\x0f\n\x07\x04\r\x04\0\x02\x03\x02\x12\x04\xd8\x02\x1e\x1f\n\x0e\n\
    \x06\x04\r\x04\0\x02\x04\x12\x04\xd9\x02\x10(\n\x0f\n\x07\x04\r\x04\0\
    \x02\x04\x01\x12\x04\xd9\x02\x10#\n\x0f\n\x07\x04\r\x04\0\x02\x04\x02\
    \x12\x04\xd9\x02&'\n\x0e\n\x06\x04\r\x04\0\x02\x05\x12\x04\xda\x02\x10/\
    \n\x0f\n\x07\x04\r\x04\0\x02\x05\x01\x12\x04\xda\x02\x10*\n\x0f\n\x07\
    \x04\r\x04\0\x02\x05\x02\x12\x04\xda\x02-.\n\x0c\n\x04\x04\r\x02\0\x12\
    \x04\xdd\x02\x08F\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xdd\x02\x08\x10\n\r\
    \n\x05\x04\r\x02\0\x06\x12\x04\xdd\x02\x11)\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xdd\x02*A\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xdd\x02DE\n\x0c\n\
    \x04\x04\r\x02\x01\x12\x04\xde\x02\x08R\n\r\n\x05\x04\r\x02\x01\x04\x12\
    \x04\xde\x02\x08\x10\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xde\x02\x11D\n\
    \r\n\x05\x04\r\x02\x01\x01\x12\x04\xde\x02EM\n\r\n\x05\x04\r\x02\x01\x03\
    \x12\x04\xde\x02PQ\n\x0c\n\x02\x04\x0e\x12\x06\xe1\x02\0\xe5\x02\x01\n\
    \x0b\n\x03\x04\x0e\x01\x12\x04\xe1\x02\x08-\n\x0c\n\x04\x04\x0e\x02\0\
    \x12\x04\xe2\x02\x08'\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xe2\x02\x08\
    \x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xe2\x02\x11\x17\n\r\n\x05\x04\
    \x0e\x02\0\x01\x12\x04\xe2\x02\x18\"\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\
    \xe2\x02%&\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xe3\x02\x08&\n\r\n\x05\
    \x04\x0e\x02\x01\x04\x12\x04\xe3\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x01\
    \x05\x12\x04\xe3\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xe3\
    \x02\x18!\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xe3\x02$%\n\x0c\n\x04\
    \x04\x0e\x02\x02\x12\x04\xe4\x02\x08%\n\r\n\x05\x04\x0e\x02\x02\x04\x12\
    \x04\xe4\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xe4\x02\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xe4\x02\x18\x20\n\r\n\x05\x04\
    \x0e\x02\x02\x03\x12\x04\xe4\x02#$\n\x0c\n\x02\x04\x0f\x12\x06\xe7\x02\0\
    \xf8\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xe7\x02\x085\n\x0e\n\x04\
    \x04\x0f\x04\0\x12\x06\xe8\x02\x08\xf4\x02\t\n\r\n\x05\x04\x0f\x04\0\x01\
    \x12\x04\xe8\x02\r\x16\n\x0e\n\x06\x04\x0f\x04\0\x02\0\x12\x04\xe9\x02\
    \x10%\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x01\x12\x04\xe9\x02\x10\x20\n\x0f\
    \n\x07\x04\x0f\x04\0\x02\0\x02\x12\x04\xe9\x02#$\n\x0e\n\x06\x04\x0f\x04\
    \0\x02\x01\x12\x04\xea\x02\x10\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x01\x01\
    \x12\x04\xea\x02\x10\x1a\n\x0f\n\x07\x04\x0f\x04\0\x02\x01\x02\x12\x04\
    \xea\x02\x1d\x1e\n\x0e\n\x06\x04\x0f\x04\0\x02\x02\x12\x04\xeb\x02\x10\
    \x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x02\x01\x12\x04\xeb\x02\x10\x1a\n\x0f\
    \n\x07\x04\x0f\x04\0\x02\x02\x02\x12\x04\xeb\x02\x1d\x1e\n\x0e\n\x06\x04\
    \x0f\x04\0\x02\x03\x12\x04\xec\x02\x10\x20\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x03\x01\x12\x04\xec\x02\x10\x1b\n\x0f\n\x07\x04\x0f\x04\0\x02\x03\x02\
    \x12\x04\xec\x02\x1e\x1f\n\x0e\n\x06\x04\x0f\x04\0\x02\x04\x12\x04\xed\
    \x02\x10\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x04\x01\x12\x04\xed\x02\x10\
    \x1a\n\x0f\n\x07\x04\x0f\x04\0\x02\x04\x02\x12\x04\xed\x02\x1d\x1e\n\x0e\
    \n\x06\x04\x0f\x04\0\x02\x05\x12\x04\xee\x02\x10(\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\x05\x01\x12\x04\xee\x02\x10#\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x05\x02\x12\x04\xee\x02&'\n\x0e\n\x06\x04\x0f\x04\0\x02\x06\x12\x04\xef\
    \x02\x100\n\x0f\n\x07\x04\x0f\x04\0\x02\x06\x01\x12\x04\xef\x02\x10+\n\
    \x0f\n\x07\x04\x0f\x04\0\x02\x06\x02\x12\x04\xef\x02./\n\x0e\n\x06\x04\
    \x0f\x04\0\x02\x07\x12\x04\xf0\x02\x10+\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x07\x01\x12\x04\xf0\x02\x10&\n\x0f\n\x07\x04\x0f\x04\0\x02\x07\x02\x12\
    \x04\xf0\x02)*\n\x0e\n\x06\x04\x0f\x04\0\x02\x08\x12\x04\xf1\x02\x10%\n\
    \x0f\n\x07\x04\x0f\x04\0\x02\x08\x01\x12\x04\xf1\x02\x10\x20\n\x0f\n\x07\
    \x04\x0f\x04\0\x02\x08\x02\x12\x04\xf1\x02#$\n\x0e\n\x06\x04\x0f\x04\0\
    \x02\t\x12\x04\xf2\x02\x10/\n\x0f\n\x07\x04\x0f\x04\0\x02\t\x01\x12\x04\
    \xf2\x02\x10*\n\x0f\n\x07\x04\x0f\x04\0\x02\t\x02\x12\x04\xf2\x02-.\n\
    \x0e\n\x06\x04\x0f\x04\0\x02\n\x12\x04\xf3\x02\x10-\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\n\x01\x12\x04\xf3\x02\x10'\n\x0f\n\x07\x04\x0f\x04\0\x02\n\
    \x02\x12\x04\xf3\x02*,\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xf6\x02\x08V\n\
    \r\n\x05\x04\x0f\x02\0\x04\x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04\x0f\x02\
    \0\x06\x12\x04\xf6\x02\x11H\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xf6\x02I\
    Q\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xf6\x02TU\n\x0c\n\x04\x04\x0f\x02\
    \x01\x12\x04\xf7\x02\x08+\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xf7\x02\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xf7\x02\x11\x17\n\r\n\x05\
    \x04\x0f\x02\x01\x01\x12\x04\xf7\x02\x18&\n\r\n\x05\x04\x0f\x02\x01\x03\
    \x12\x04\xf7\x02)*\n\x0c\n\x02\x04\x10\x12\x06\xfa\x02\0\xfe\x02\x01\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\xfa\x02\x081\n\x0c\n\x04\x04\x10\x02\0\
    \x12\x04\xfb\x02\x08'\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xfb\x02\x08\
    \x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xfb\x02\x11\x17\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\xfb\x02\x18\"\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \xfb\x02%&\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xfc\x02\x08&\n\r\n\x05\
    \x04\x10\x02\x01\x04\x12\x04\xfc\x02\x08\x10\n\r\n\x05\x04\x10\x02\x01\
    \x05\x12\x04\xfc\x02\x11\x17\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xfc\
    \x02\x18!\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xfc\x02$%\n\x0c\n\x04\
    \x04\x10\x02\x02\x12\x04\xfd\x02\x08%\n\r\n\x05\x04\x10\x02\x02\x04\x12\
    \x04\xfd\x02\x08\x10\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xfd\x02\x11\
    \x17\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xfd\x02\x18\x20\n\r\n\x05\x04\
    \x10\x02\x02\x03\x12\x04\xfd\x02#$\n\x0c\n\x02\x04\x11\x12\x06\x80\x03\0\
    \x8d\x03\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\x80\x03\x089\n\x0e\n\x04\
    \x04\x11\x04\0\x12\x06\x81\x03\x08\x89\x03\t\n\r\n\x05\x04\x11\x04\0\x01\
    \x12\x04\x81\x03\r\x16\n\x0e\n\x06\x04\x11\x04\0\x02\0\x12\x04\x82\x03\
    \x10%\n\x0f\n\x07\x04\x11\x04\0\x02\0\x01\x12\x04\x82\x03\x10\x20\n\x0f\
    \n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\x82\x03#$\n\x0e\n\x06\x04\x11\x04\
    \0\x02\x01\x12\x04\x83\x03\x10\x1f\n\x0f\n\x07\x04\x11\x04\0\x02\x01\x01\
    \x12\x04\x83\x03\x10\x1a\n\x0f\n\x07\x04\x11\x04\0\x02\x01\x02\x12\x04\
    \x83\x03\x1d\x1e\n\x0e\n\x06\x04\x11\x04\0\x02\x02\x12\x04\x84\x03\x10\
    \x1f\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x01\x12\x04\x84\x03\x10\x1a\n\x0f\
    \n\x07\x04\x11\x04\0\x02\x02\x02\x12\x04\x84\x03\x1d\x1e\n\x0e\n\x06\x04\
    \x11\x04\0\x02\x03\x12\x04\x85\x03\x10\x20\n\x0f\n\x07\x04\x11\x04\0\x02\
    \x03\x01\x12\x04\x85\x03\x10\x1b\n\x0f\n\x07\x04\x11\x04\0\x02\x03\x02\
    \x12\x04\x85\x03\x1e\x1f\n\x0e\n\x06\x04\x11\x04\0\x02\x04\x12\x04\x86\
    \x03\x10\x1f\n\x0f\n\x07\x04\x11\x04\0\x02\x04\x01\x12\x04\x86\x03\x10\
    \x1a\n\x0f\n\x07\x04\x11\x04\0\x02\x04\x02\x12\x04\x86\x03\x1d\x1e\n\x0e\
    \n\x06\x04\x11\x04\0\x02\x05\x12\x04\x87\x03\x10(\n\x0f\n\x07\x04\x11\
    \x04\0\x02\x05\x01\x12\x04\x87\x03\x10#\n\x0f\n\x07\x04\x11\x04\0\x02\
    \x05\x02\x12\x04\x87\x03&'\n\x0e\n\x06\x04\x11\x04\0\x02\x06\x12\x04\x88\
    \x03\x10/\n\x0f\n\x07\x04\x11\x04\0\x02\x06\x01\x12\x04\x88\x03\x10*\n\
    \x0f\n\x07\x04\x11\x04\0\x02\x06\x02\x12\x04\x88\x03-.\n\x0c\n\x04\x04\
    \x11\x02\0\x12\x04\x8b\x03\x08Z\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\x8b\
    \x03\x08\x10\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\x8b\x03\x11L\n\r\n\x05\
    \x04\x11\x02\0\x01\x12\x04\x8b\x03MU\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\
    \x8b\x03XY\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\x8c\x03\x085\n\r\n\x05\
    \x04\x11\x02\x01\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x04\x11\x02\x01\
    \x06\x12\x04\x8c\x03\x11*\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\x8c\x03+\
    0\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x8c\x0334\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(9);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            deps.push(super::dota_gcmessages_common::file_descriptor().clone());
            deps.push(super::dota_gcmessages_webapi::file_descriptor().clone());
            deps.push(super::gcsdk_gcmessages::file_descriptor().clone());
            deps.push(super::base_gcmessages::file_descriptor().clone());
            deps.push(super::econ_gcmessages::file_descriptor().clone());
            deps.push(super::dota_gcmessages_client::file_descriptor().clone());
            deps.push(super::valveextensions::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(CMsgClientToGCGetBattleReport::generated_message_descriptor_data());
            messages.push(CMsgBattleReport_Game::generated_message_descriptor_data());
            messages.push(CMsgBattleReport_GameList::generated_message_descriptor_data());
            messages.push(CMsgBattleReport::generated_message_descriptor_data());
            messages.push(CMsgBattleReportInfo::generated_message_descriptor_data());
            messages.push(CMsgBattleReportInfoList::generated_message_descriptor_data());
            messages.push(CMsgBattleReportHighlights::generated_message_descriptor_data());
            messages.push(CMsgBattleReportAggregateStats::generated_message_descriptor_data());
            messages.push(CMsgBattleReportAggregatedGeneralStats::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetBattleReportResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetBattleReportAggregateStats::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetBattleReportAggregateStatsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetBattleReportInfo::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetBattleReportInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAcknowledgeBattleReport::generated_message_descriptor_data());
            messages.push(CMsgClientToGCAcknowledgeBattleReportResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetBattleReportMatchHistory::generated_message_descriptor_data());
            messages.push(CMsgClientToGCGetBattleReportMatchHistoryResponse::generated_message_descriptor_data());
            messages.push(cmsg_battle_report::HighlightGeneral::generated_message_descriptor_data());
            messages.push(cmsg_battle_report::Highlight::generated_message_descriptor_data());
            messages.push(cmsg_battle_report_aggregate_stats::CMsgBattleReportStat::generated_message_descriptor_data());
            messages.push(cmsg_battle_report_aggregate_stats::CMsgBattleReportAggregate::generated_message_descriptor_data());
            messages.push(cmsg_client_to_gcget_battle_report_aggregate_stats::CMsgBattleReportAggregateKey::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(13);
            enums.push(CMsgBattleReport_HighlightType::generated_enum_descriptor_data());
            enums.push(CMsgBattleReport_HighlightCategory::generated_enum_descriptor_data());
            enums.push(CMsgBattleReport_Role::generated_enum_descriptor_data());
            enums.push(CMsgBattleReport_CompareContext::generated_enum_descriptor_data());
            enums.push(CMsgBattleReport_HighlightTier::generated_enum_descriptor_data());
            enums.push(CMsgBattleReport_HighlightRarity::generated_enum_descriptor_data());
            enums.push(CMsgBattleReport_EOutcome::generated_enum_descriptor_data());
            enums.push(CMsgBattleReport_ELaneOutcome::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcget_battle_report_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcget_battle_report_info_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcacknowledge_battle_report_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcget_battle_report_match_history_response::EResponse::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
