// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_guild_events.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgGuildContract)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildContract {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildContract.contract_id)
    pub contract_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgGuildContract.challenge_instance_id)
    pub challenge_instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildContract.challenge_parameter)
    pub challenge_parameter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildContract.challenge_timestamp)
    pub challenge_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildContract.assigned_account_id)
    pub assigned_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildContract.contract_flags)
    pub contract_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildContract.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildContract {
    fn default() -> &'a CMsgGuildContract {
        <CMsgGuildContract as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildContract {
    pub fn new() -> CMsgGuildContract {
        ::std::default::Default::default()
    }

    // optional uint64 contract_id = 1;

    pub fn contract_id(&self) -> u64 {
        self.contract_id.unwrap_or(0)
    }

    pub fn clear_contract_id(&mut self) {
        self.contract_id = ::std::option::Option::None;
    }

    pub fn has_contract_id(&self) -> bool {
        self.contract_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_id(&mut self, v: u64) {
        self.contract_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_instance_id = 2;

    pub fn challenge_instance_id(&self) -> u32 {
        self.challenge_instance_id.unwrap_or(0)
    }

    pub fn clear_challenge_instance_id(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
    }

    pub fn has_challenge_instance_id(&self) -> bool {
        self.challenge_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_instance_id(&mut self, v: u32) {
        self.challenge_instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_parameter = 3;

    pub fn challenge_parameter(&self) -> u32 {
        self.challenge_parameter.unwrap_or(0)
    }

    pub fn clear_challenge_parameter(&mut self) {
        self.challenge_parameter = ::std::option::Option::None;
    }

    pub fn has_challenge_parameter(&self) -> bool {
        self.challenge_parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_parameter(&mut self, v: u32) {
        self.challenge_parameter = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_timestamp = 4;

    pub fn challenge_timestamp(&self) -> u32 {
        self.challenge_timestamp.unwrap_or(0)
    }

    pub fn clear_challenge_timestamp(&mut self) {
        self.challenge_timestamp = ::std::option::Option::None;
    }

    pub fn has_challenge_timestamp(&self) -> bool {
        self.challenge_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_timestamp(&mut self, v: u32) {
        self.challenge_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 assigned_account_id = 5;

    pub fn assigned_account_id(&self) -> u32 {
        self.assigned_account_id.unwrap_or(0)
    }

    pub fn clear_assigned_account_id(&mut self) {
        self.assigned_account_id = ::std::option::Option::None;
    }

    pub fn has_assigned_account_id(&self) -> bool {
        self.assigned_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigned_account_id(&mut self, v: u32) {
        self.assigned_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 contract_flags = 6;

    pub fn contract_flags(&self) -> u32 {
        self.contract_flags.unwrap_or(0)
    }

    pub fn clear_contract_flags(&mut self) {
        self.contract_flags = ::std::option::Option::None;
    }

    pub fn has_contract_flags(&self) -> bool {
        self.contract_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_flags(&mut self, v: u32) {
        self.contract_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contract_id",
            |m: &CMsgGuildContract| { &m.contract_id },
            |m: &mut CMsgGuildContract| { &mut m.contract_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_instance_id",
            |m: &CMsgGuildContract| { &m.challenge_instance_id },
            |m: &mut CMsgGuildContract| { &mut m.challenge_instance_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_parameter",
            |m: &CMsgGuildContract| { &m.challenge_parameter },
            |m: &mut CMsgGuildContract| { &mut m.challenge_parameter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_timestamp",
            |m: &CMsgGuildContract| { &m.challenge_timestamp },
            |m: &mut CMsgGuildContract| { &mut m.challenge_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assigned_account_id",
            |m: &CMsgGuildContract| { &m.assigned_account_id },
            |m: &mut CMsgGuildContract| { &mut m.assigned_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contract_flags",
            |m: &CMsgGuildContract| { &m.contract_flags },
            |m: &mut CMsgGuildContract| { &mut m.contract_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildContract>(
            "CMsgGuildContract",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildContract {
    const NAME: &'static str = "CMsgGuildContract";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.contract_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.challenge_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.assigned_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.contract_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contract_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.challenge_instance_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.challenge_parameter {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.challenge_timestamp {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.assigned_account_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.contract_flags {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.contract_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.challenge_instance_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.challenge_parameter {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.challenge_timestamp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.assigned_account_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.contract_flags {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildContract {
        CMsgGuildContract::new()
    }

    fn clear(&mut self) {
        self.contract_id = ::std::option::Option::None;
        self.challenge_instance_id = ::std::option::Option::None;
        self.challenge_parameter = ::std::option::Option::None;
        self.challenge_timestamp = ::std::option::Option::None;
        self.assigned_account_id = ::std::option::Option::None;
        self.contract_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildContract {
        static instance: CMsgGuildContract = CMsgGuildContract {
            contract_id: ::std::option::Option::None,
            challenge_instance_id: ::std::option::Option::None,
            challenge_parameter: ::std::option::Option::None,
            challenge_timestamp: ::std::option::Option::None,
            assigned_account_id: ::std::option::Option::None,
            contract_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildContract {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildContract").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildContract {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildContractSlot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildContractSlot {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildContractSlot.contract)
    pub contract: ::protobuf::MessageField<CMsgGuildContract>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildContractSlot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildContractSlot {
    fn default() -> &'a CMsgGuildContractSlot {
        <CMsgGuildContractSlot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildContractSlot {
    pub fn new() -> CMsgGuildContractSlot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildContract>(
            "contract",
            |m: &CMsgGuildContractSlot| { &m.contract },
            |m: &mut CMsgGuildContractSlot| { &mut m.contract },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildContractSlot>(
            "CMsgGuildContractSlot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildContractSlot {
    const NAME: &'static str = "CMsgGuildContractSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contract)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contract.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.contract.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildContractSlot {
        CMsgGuildContractSlot::new()
    }

    fn clear(&mut self) {
        self.contract.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildContractSlot {
        static instance: CMsgGuildContractSlot = CMsgGuildContractSlot {
            contract: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildContractSlot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildContractSlot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildContractSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildContractSlot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgAccountGuildEventData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountGuildEventData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildEventData.guild_points)
    pub guild_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildEventData.contracts_refreshed_timestamp)
    pub contracts_refreshed_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildEventData.contract_slots)
    pub contract_slots: ::std::vec::Vec<CMsgGuildContractSlot>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildEventData.completed_challenge_count)
    pub completed_challenge_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildEventData.challenges_refresh_timestamp)
    pub challenges_refresh_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildEventData.guild_weekly_percentile)
    pub guild_weekly_percentile: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildEventData.guild_weekly_last_timestamp)
    pub guild_weekly_last_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildEventData.last_weekly_claim_time)
    pub last_weekly_claim_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgAccountGuildEventData.guild_current_percentile)
    pub guild_current_percentile: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgAccountGuildEventData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountGuildEventData {
    fn default() -> &'a CMsgAccountGuildEventData {
        <CMsgAccountGuildEventData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountGuildEventData {
    pub fn new() -> CMsgAccountGuildEventData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_points = 1;

    pub fn guild_points(&self) -> u32 {
        self.guild_points.unwrap_or(0)
    }

    pub fn clear_guild_points(&mut self) {
        self.guild_points = ::std::option::Option::None;
    }

    pub fn has_guild_points(&self) -> bool {
        self.guild_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_points(&mut self, v: u32) {
        self.guild_points = ::std::option::Option::Some(v);
    }

    // optional uint32 contracts_refreshed_timestamp = 2;

    pub fn contracts_refreshed_timestamp(&self) -> u32 {
        self.contracts_refreshed_timestamp.unwrap_or(0)
    }

    pub fn clear_contracts_refreshed_timestamp(&mut self) {
        self.contracts_refreshed_timestamp = ::std::option::Option::None;
    }

    pub fn has_contracts_refreshed_timestamp(&self) -> bool {
        self.contracts_refreshed_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contracts_refreshed_timestamp(&mut self, v: u32) {
        self.contracts_refreshed_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 completed_challenge_count = 4;

    pub fn completed_challenge_count(&self) -> u32 {
        self.completed_challenge_count.unwrap_or(0)
    }

    pub fn clear_completed_challenge_count(&mut self) {
        self.completed_challenge_count = ::std::option::Option::None;
    }

    pub fn has_completed_challenge_count(&self) -> bool {
        self.completed_challenge_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_challenge_count(&mut self, v: u32) {
        self.completed_challenge_count = ::std::option::Option::Some(v);
    }

    // optional uint32 challenges_refresh_timestamp = 5;

    pub fn challenges_refresh_timestamp(&self) -> u32 {
        self.challenges_refresh_timestamp.unwrap_or(0)
    }

    pub fn clear_challenges_refresh_timestamp(&mut self) {
        self.challenges_refresh_timestamp = ::std::option::Option::None;
    }

    pub fn has_challenges_refresh_timestamp(&self) -> bool {
        self.challenges_refresh_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenges_refresh_timestamp(&mut self, v: u32) {
        self.challenges_refresh_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_weekly_percentile = 6;

    pub fn guild_weekly_percentile(&self) -> u32 {
        self.guild_weekly_percentile.unwrap_or(0)
    }

    pub fn clear_guild_weekly_percentile(&mut self) {
        self.guild_weekly_percentile = ::std::option::Option::None;
    }

    pub fn has_guild_weekly_percentile(&self) -> bool {
        self.guild_weekly_percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_weekly_percentile(&mut self, v: u32) {
        self.guild_weekly_percentile = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_weekly_last_timestamp = 7;

    pub fn guild_weekly_last_timestamp(&self) -> u32 {
        self.guild_weekly_last_timestamp.unwrap_or(0)
    }

    pub fn clear_guild_weekly_last_timestamp(&mut self) {
        self.guild_weekly_last_timestamp = ::std::option::Option::None;
    }

    pub fn has_guild_weekly_last_timestamp(&self) -> bool {
        self.guild_weekly_last_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_weekly_last_timestamp(&mut self, v: u32) {
        self.guild_weekly_last_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 last_weekly_claim_time = 8;

    pub fn last_weekly_claim_time(&self) -> u32 {
        self.last_weekly_claim_time.unwrap_or(0)
    }

    pub fn clear_last_weekly_claim_time(&mut self) {
        self.last_weekly_claim_time = ::std::option::Option::None;
    }

    pub fn has_last_weekly_claim_time(&self) -> bool {
        self.last_weekly_claim_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_weekly_claim_time(&mut self, v: u32) {
        self.last_weekly_claim_time = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_current_percentile = 9;

    pub fn guild_current_percentile(&self) -> u32 {
        self.guild_current_percentile.unwrap_or(0)
    }

    pub fn clear_guild_current_percentile(&mut self) {
        self.guild_current_percentile = ::std::option::Option::None;
    }

    pub fn has_guild_current_percentile(&self) -> bool {
        self.guild_current_percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_current_percentile(&mut self, v: u32) {
        self.guild_current_percentile = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_points",
            |m: &CMsgAccountGuildEventData| { &m.guild_points },
            |m: &mut CMsgAccountGuildEventData| { &mut m.guild_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contracts_refreshed_timestamp",
            |m: &CMsgAccountGuildEventData| { &m.contracts_refreshed_timestamp },
            |m: &mut CMsgAccountGuildEventData| { &mut m.contracts_refreshed_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contract_slots",
            |m: &CMsgAccountGuildEventData| { &m.contract_slots },
            |m: &mut CMsgAccountGuildEventData| { &mut m.contract_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "completed_challenge_count",
            |m: &CMsgAccountGuildEventData| { &m.completed_challenge_count },
            |m: &mut CMsgAccountGuildEventData| { &mut m.completed_challenge_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenges_refresh_timestamp",
            |m: &CMsgAccountGuildEventData| { &m.challenges_refresh_timestamp },
            |m: &mut CMsgAccountGuildEventData| { &mut m.challenges_refresh_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_weekly_percentile",
            |m: &CMsgAccountGuildEventData| { &m.guild_weekly_percentile },
            |m: &mut CMsgAccountGuildEventData| { &mut m.guild_weekly_percentile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_weekly_last_timestamp",
            |m: &CMsgAccountGuildEventData| { &m.guild_weekly_last_timestamp },
            |m: &mut CMsgAccountGuildEventData| { &mut m.guild_weekly_last_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_weekly_claim_time",
            |m: &CMsgAccountGuildEventData| { &m.last_weekly_claim_time },
            |m: &mut CMsgAccountGuildEventData| { &mut m.last_weekly_claim_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_current_percentile",
            |m: &CMsgAccountGuildEventData| { &m.guild_current_percentile },
            |m: &mut CMsgAccountGuildEventData| { &mut m.guild_current_percentile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAccountGuildEventData>(
            "CMsgAccountGuildEventData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAccountGuildEventData {
    const NAME: &'static str = "CMsgAccountGuildEventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.contracts_refreshed_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.contract_slots.push(is.read_message()?);
                },
                32 => {
                    self.completed_challenge_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenges_refresh_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.guild_weekly_percentile = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.guild_weekly_last_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.last_weekly_claim_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.guild_current_percentile = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_points {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.contracts_refreshed_timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.contract_slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.completed_challenge_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenges_refresh_timestamp {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.guild_weekly_percentile {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.guild_weekly_last_timestamp {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.last_weekly_claim_time {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.guild_current_percentile {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_points {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.contracts_refreshed_timestamp {
            os.write_uint32(2, v)?;
        }
        for v in &self.contract_slots {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.completed_challenge_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenges_refresh_timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.guild_weekly_percentile {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.guild_weekly_last_timestamp {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.last_weekly_claim_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.guild_current_percentile {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountGuildEventData {
        CMsgAccountGuildEventData::new()
    }

    fn clear(&mut self) {
        self.guild_points = ::std::option::Option::None;
        self.contracts_refreshed_timestamp = ::std::option::Option::None;
        self.contract_slots.clear();
        self.completed_challenge_count = ::std::option::Option::None;
        self.challenges_refresh_timestamp = ::std::option::Option::None;
        self.guild_weekly_percentile = ::std::option::Option::None;
        self.guild_weekly_last_timestamp = ::std::option::Option::None;
        self.last_weekly_claim_time = ::std::option::Option::None;
        self.guild_current_percentile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountGuildEventData {
        static instance: CMsgAccountGuildEventData = CMsgAccountGuildEventData {
            guild_points: ::std::option::Option::None,
            contracts_refreshed_timestamp: ::std::option::Option::None,
            contract_slots: ::std::vec::Vec::new(),
            completed_challenge_count: ::std::option::Option::None,
            challenges_refresh_timestamp: ::std::option::Option::None,
            guild_weekly_percentile: ::std::option::Option::None,
            guild_weekly_last_timestamp: ::std::option::Option::None,
            last_weekly_claim_time: ::std::option::Option::None,
            guild_current_percentile: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAccountGuildEventData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAccountGuildEventData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAccountGuildEventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAccountGuildEventData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildActiveContracts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildActiveContracts {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildActiveContracts.contracts_refreshed_timestamp)
    pub contracts_refreshed_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildActiveContracts.contracts)
    pub contracts: ::std::vec::Vec<CMsgGuildContract>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildActiveContracts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildActiveContracts {
    fn default() -> &'a CMsgGuildActiveContracts {
        <CMsgGuildActiveContracts as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildActiveContracts {
    pub fn new() -> CMsgGuildActiveContracts {
        ::std::default::Default::default()
    }

    // optional uint32 contracts_refreshed_timestamp = 1;

    pub fn contracts_refreshed_timestamp(&self) -> u32 {
        self.contracts_refreshed_timestamp.unwrap_or(0)
    }

    pub fn clear_contracts_refreshed_timestamp(&mut self) {
        self.contracts_refreshed_timestamp = ::std::option::Option::None;
    }

    pub fn has_contracts_refreshed_timestamp(&self) -> bool {
        self.contracts_refreshed_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contracts_refreshed_timestamp(&mut self, v: u32) {
        self.contracts_refreshed_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contracts_refreshed_timestamp",
            |m: &CMsgGuildActiveContracts| { &m.contracts_refreshed_timestamp },
            |m: &mut CMsgGuildActiveContracts| { &mut m.contracts_refreshed_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contracts",
            |m: &CMsgGuildActiveContracts| { &m.contracts },
            |m: &mut CMsgGuildActiveContracts| { &mut m.contracts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildActiveContracts>(
            "CMsgGuildActiveContracts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildActiveContracts {
    const NAME: &'static str = "CMsgGuildActiveContracts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.contracts_refreshed_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.contracts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contracts_refreshed_timestamp {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.contracts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.contracts_refreshed_timestamp {
            os.write_uint32(1, v)?;
        }
        for v in &self.contracts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildActiveContracts {
        CMsgGuildActiveContracts::new()
    }

    fn clear(&mut self) {
        self.contracts_refreshed_timestamp = ::std::option::Option::None;
        self.contracts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildActiveContracts {
        static instance: CMsgGuildActiveContracts = CMsgGuildActiveContracts {
            contracts_refreshed_timestamp: ::std::option::Option::None,
            contracts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildActiveContracts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildActiveContracts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildActiveContracts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildActiveContracts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildChallenge {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildChallenge.challenge_instance_id)
    pub challenge_instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildChallenge.challenge_parameter)
    pub challenge_parameter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildChallenge.challenge_timestamp)
    pub challenge_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildChallenge.challenge_progress)
    pub challenge_progress: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildChallenge.challenge_flags)
    pub challenge_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildChallenge {
    fn default() -> &'a CMsgGuildChallenge {
        <CMsgGuildChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildChallenge {
    pub fn new() -> CMsgGuildChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 challenge_instance_id = 1;

    pub fn challenge_instance_id(&self) -> u32 {
        self.challenge_instance_id.unwrap_or(0)
    }

    pub fn clear_challenge_instance_id(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
    }

    pub fn has_challenge_instance_id(&self) -> bool {
        self.challenge_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_instance_id(&mut self, v: u32) {
        self.challenge_instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_parameter = 2;

    pub fn challenge_parameter(&self) -> u32 {
        self.challenge_parameter.unwrap_or(0)
    }

    pub fn clear_challenge_parameter(&mut self) {
        self.challenge_parameter = ::std::option::Option::None;
    }

    pub fn has_challenge_parameter(&self) -> bool {
        self.challenge_parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_parameter(&mut self, v: u32) {
        self.challenge_parameter = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_timestamp = 3;

    pub fn challenge_timestamp(&self) -> u32 {
        self.challenge_timestamp.unwrap_or(0)
    }

    pub fn clear_challenge_timestamp(&mut self) {
        self.challenge_timestamp = ::std::option::Option::None;
    }

    pub fn has_challenge_timestamp(&self) -> bool {
        self.challenge_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_timestamp(&mut self, v: u32) {
        self.challenge_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_progress = 4;

    pub fn challenge_progress(&self) -> u32 {
        self.challenge_progress.unwrap_or(0)
    }

    pub fn clear_challenge_progress(&mut self) {
        self.challenge_progress = ::std::option::Option::None;
    }

    pub fn has_challenge_progress(&self) -> bool {
        self.challenge_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_progress(&mut self, v: u32) {
        self.challenge_progress = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_flags = 5;

    pub fn challenge_flags(&self) -> u32 {
        self.challenge_flags.unwrap_or(0)
    }

    pub fn clear_challenge_flags(&mut self) {
        self.challenge_flags = ::std::option::Option::None;
    }

    pub fn has_challenge_flags(&self) -> bool {
        self.challenge_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_flags(&mut self, v: u32) {
        self.challenge_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_instance_id",
            |m: &CMsgGuildChallenge| { &m.challenge_instance_id },
            |m: &mut CMsgGuildChallenge| { &mut m.challenge_instance_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_parameter",
            |m: &CMsgGuildChallenge| { &m.challenge_parameter },
            |m: &mut CMsgGuildChallenge| { &mut m.challenge_parameter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_timestamp",
            |m: &CMsgGuildChallenge| { &m.challenge_timestamp },
            |m: &mut CMsgGuildChallenge| { &mut m.challenge_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_progress",
            |m: &CMsgGuildChallenge| { &m.challenge_progress },
            |m: &mut CMsgGuildChallenge| { &mut m.challenge_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_flags",
            |m: &CMsgGuildChallenge| { &m.challenge_flags },
            |m: &mut CMsgGuildChallenge| { &mut m.challenge_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildChallenge>(
            "CMsgGuildChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildChallenge {
    const NAME: &'static str = "CMsgGuildChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.challenge_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.challenge_progress = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenge_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_instance_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.challenge_parameter {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.challenge_timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.challenge_progress {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenge_flags {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge_instance_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.challenge_parameter {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.challenge_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.challenge_progress {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_flags {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildChallenge {
        CMsgGuildChallenge::new()
    }

    fn clear(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
        self.challenge_parameter = ::std::option::Option::None;
        self.challenge_timestamp = ::std::option::Option::None;
        self.challenge_progress = ::std::option::Option::None;
        self.challenge_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildChallenge {
        static instance: CMsgGuildChallenge = CMsgGuildChallenge {
            challenge_instance_id: ::std::option::Option::None,
            challenge_parameter: ::std::option::Option::None,
            challenge_timestamp: ::std::option::Option::None,
            challenge_progress: ::std::option::Option::None,
            challenge_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgGuildEventMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildEventMember {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildEventMember.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildEventMember.guild_points_earned)
    pub guild_points_earned: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildEventMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildEventMember {
    fn default() -> &'a CMsgGuildEventMember {
        <CMsgGuildEventMember as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildEventMember {
    pub fn new() -> CMsgGuildEventMember {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_points_earned = 2;

    pub fn guild_points_earned(&self) -> u32 {
        self.guild_points_earned.unwrap_or(0)
    }

    pub fn clear_guild_points_earned(&mut self) {
        self.guild_points_earned = ::std::option::Option::None;
    }

    pub fn has_guild_points_earned(&self) -> bool {
        self.guild_points_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_points_earned(&mut self, v: u32) {
        self.guild_points_earned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGuildEventMember| { &m.account_id },
            |m: &mut CMsgGuildEventMember| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_points_earned",
            |m: &CMsgGuildEventMember| { &m.guild_points_earned },
            |m: &mut CMsgGuildEventMember| { &mut m.guild_points_earned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildEventMember>(
            "CMsgGuildEventMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildEventMember {
    const NAME: &'static str = "CMsgGuildEventMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.guild_points_earned = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_points_earned {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_points_earned {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildEventMember {
        CMsgGuildEventMember::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.guild_points_earned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildEventMember {
        static instance: CMsgGuildEventMember = CMsgGuildEventMember {
            account_id: ::std::option::Option::None,
            guild_points_earned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildEventMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildEventMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildEventMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildEventMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestAccountGuildEventData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildEventData {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildEventData.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildEventData.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestAccountGuildEventData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildEventData {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildEventData {
        <CMsgClientToGCRequestAccountGuildEventData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildEventData {
    pub fn new() -> CMsgClientToGCRequestAccountGuildEventData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCRequestAccountGuildEventData| { &m.guild_id },
            |m: &mut CMsgClientToGCRequestAccountGuildEventData| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgClientToGCRequestAccountGuildEventData| { &m.event_id },
            |m: &mut CMsgClientToGCRequestAccountGuildEventData| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestAccountGuildEventData>(
            "CMsgClientToGCRequestAccountGuildEventData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestAccountGuildEventData {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildEventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildEventData {
        CMsgClientToGCRequestAccountGuildEventData::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildEventData {
        static instance: CMsgClientToGCRequestAccountGuildEventData = CMsgClientToGCRequestAccountGuildEventData {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestAccountGuildEventData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestAccountGuildEventData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestAccountGuildEventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestAccountGuildEventData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestAccountGuildEventDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildEventDataResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.event_data)
    pub event_data: ::protobuf::MessageField<CMsgAccountGuildEventData>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildEventDataResponse {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildEventDataResponse {
        <CMsgClientToGCRequestAccountGuildEventDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildEventDataResponse {
    pub fn new() -> CMsgClientToGCRequestAccountGuildEventDataResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestAccountGuildEventDataResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestAccountGuildEventDataResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgClientToGCRequestAccountGuildEventDataResponse| { &m.event_id },
            |m: &mut CMsgClientToGCRequestAccountGuildEventDataResponse| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgAccountGuildEventData>(
            "event_data",
            |m: &CMsgClientToGCRequestAccountGuildEventDataResponse| { &m.event_data },
            |m: &mut CMsgClientToGCRequestAccountGuildEventDataResponse| { &mut m.event_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestAccountGuildEventDataResponse>(
            "CMsgClientToGCRequestAccountGuildEventDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestAccountGuildEventDataResponse {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildEventDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.event_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.event_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildEventDataResponse {
        CMsgClientToGCRequestAccountGuildEventDataResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.event_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildEventDataResponse {
        static instance: CMsgClientToGCRequestAccountGuildEventDataResponse = CMsgClientToGCRequestAccountGuildEventDataResponse {
            result: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            event_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestAccountGuildEventDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestAccountGuildEventDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestAccountGuildEventDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestAccountGuildEventDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestAccountGuildEventDataResponse`
pub mod cmsg_client_to_gcrequest_account_guild_event_data_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientAccountGuildEventDataUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientAccountGuildEventDataUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientAccountGuildEventDataUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientAccountGuildEventDataUpdated.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientAccountGuildEventDataUpdated.update_flags)
    pub update_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientAccountGuildEventDataUpdated.guild_event_data)
    pub guild_event_data: ::protobuf::MessageField<CMsgAccountGuildEventData>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientAccountGuildEventDataUpdated.contracts_updated)
    pub contracts_updated: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientAccountGuildEventDataUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientAccountGuildEventDataUpdated {
    fn default() -> &'a CMsgGCToClientAccountGuildEventDataUpdated {
        <CMsgGCToClientAccountGuildEventDataUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientAccountGuildEventDataUpdated {
    pub fn new() -> CMsgGCToClientAccountGuildEventDataUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 update_flags = 3;

    pub fn update_flags(&self) -> u32 {
        self.update_flags.unwrap_or(0)
    }

    pub fn clear_update_flags(&mut self) {
        self.update_flags = ::std::option::Option::None;
    }

    pub fn has_update_flags(&self) -> bool {
        self.update_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_flags(&mut self, v: u32) {
        self.update_flags = ::std::option::Option::Some(v);
    }

    // optional bool contracts_updated = 5;

    pub fn contracts_updated(&self) -> bool {
        self.contracts_updated.unwrap_or(false)
    }

    pub fn clear_contracts_updated(&mut self) {
        self.contracts_updated = ::std::option::Option::None;
    }

    pub fn has_contracts_updated(&self) -> bool {
        self.contracts_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contracts_updated(&mut self, v: bool) {
        self.contracts_updated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgGCToClientAccountGuildEventDataUpdated| { &m.guild_id },
            |m: &mut CMsgGCToClientAccountGuildEventDataUpdated| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgGCToClientAccountGuildEventDataUpdated| { &m.event_id },
            |m: &mut CMsgGCToClientAccountGuildEventDataUpdated| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_flags",
            |m: &CMsgGCToClientAccountGuildEventDataUpdated| { &m.update_flags },
            |m: &mut CMsgGCToClientAccountGuildEventDataUpdated| { &mut m.update_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgAccountGuildEventData>(
            "guild_event_data",
            |m: &CMsgGCToClientAccountGuildEventDataUpdated| { &m.guild_event_data },
            |m: &mut CMsgGCToClientAccountGuildEventDataUpdated| { &mut m.guild_event_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contracts_updated",
            |m: &CMsgGCToClientAccountGuildEventDataUpdated| { &m.contracts_updated },
            |m: &mut CMsgGCToClientAccountGuildEventDataUpdated| { &mut m.contracts_updated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientAccountGuildEventDataUpdated>(
            "CMsgGCToClientAccountGuildEventDataUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientAccountGuildEventDataUpdated {
    const NAME: &'static str = "CMsgGCToClientAccountGuildEventDataUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.update_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_event_data)?;
                },
                40 => {
                    self.contracts_updated = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.update_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.guild_event_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contracts_updated {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.update_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.guild_event_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.contracts_updated {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientAccountGuildEventDataUpdated {
        CMsgGCToClientAccountGuildEventDataUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.update_flags = ::std::option::Option::None;
        self.guild_event_data.clear();
        self.contracts_updated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientAccountGuildEventDataUpdated {
        static instance: CMsgGCToClientAccountGuildEventDataUpdated = CMsgGCToClientAccountGuildEventDataUpdated {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            update_flags: ::std::option::Option::None,
            guild_event_data: ::protobuf::MessageField::none(),
            contracts_updated: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientAccountGuildEventDataUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientAccountGuildEventDataUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientAccountGuildEventDataUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientAccountGuildEventDataUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestActiveGuildContracts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestActiveGuildContracts {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestActiveGuildContracts.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestActiveGuildContracts.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestActiveGuildContracts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestActiveGuildContracts {
    fn default() -> &'a CMsgClientToGCRequestActiveGuildContracts {
        <CMsgClientToGCRequestActiveGuildContracts as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestActiveGuildContracts {
    pub fn new() -> CMsgClientToGCRequestActiveGuildContracts {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCRequestActiveGuildContracts| { &m.guild_id },
            |m: &mut CMsgClientToGCRequestActiveGuildContracts| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgClientToGCRequestActiveGuildContracts| { &m.event_id },
            |m: &mut CMsgClientToGCRequestActiveGuildContracts| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestActiveGuildContracts>(
            "CMsgClientToGCRequestActiveGuildContracts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestActiveGuildContracts {
    const NAME: &'static str = "CMsgClientToGCRequestActiveGuildContracts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestActiveGuildContracts {
        CMsgClientToGCRequestActiveGuildContracts::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestActiveGuildContracts {
        static instance: CMsgClientToGCRequestActiveGuildContracts = CMsgClientToGCRequestActiveGuildContracts {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestActiveGuildContracts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestActiveGuildContracts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestActiveGuildContracts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestActiveGuildContracts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestActiveGuildContractsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestActiveGuildContractsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestActiveGuildContractsResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestActiveGuildContractsResponse.active_contracts)
    pub active_contracts: ::protobuf::MessageField<CMsgGuildActiveContracts>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestActiveGuildContractsResponse.active_challenges)
    pub active_challenges: ::protobuf::MessageField<CMsgGuildChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestActiveGuildContractsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestActiveGuildContractsResponse {
    fn default() -> &'a CMsgClientToGCRequestActiveGuildContractsResponse {
        <CMsgClientToGCRequestActiveGuildContractsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestActiveGuildContractsResponse {
    pub fn new() -> CMsgClientToGCRequestActiveGuildContractsResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestActiveGuildContractsResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestActiveGuildContractsResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildActiveContracts>(
            "active_contracts",
            |m: &CMsgClientToGCRequestActiveGuildContractsResponse| { &m.active_contracts },
            |m: &mut CMsgClientToGCRequestActiveGuildContractsResponse| { &mut m.active_contracts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildChallenge>(
            "active_challenges",
            |m: &CMsgClientToGCRequestActiveGuildContractsResponse| { &m.active_challenges },
            |m: &mut CMsgClientToGCRequestActiveGuildContractsResponse| { &mut m.active_challenges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestActiveGuildContractsResponse>(
            "CMsgClientToGCRequestActiveGuildContractsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestActiveGuildContractsResponse {
    const NAME: &'static str = "CMsgClientToGCRequestActiveGuildContractsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.active_contracts)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.active_challenges)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.active_contracts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.active_challenges.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.active_contracts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.active_challenges.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestActiveGuildContractsResponse {
        CMsgClientToGCRequestActiveGuildContractsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.active_contracts.clear();
        self.active_challenges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestActiveGuildContractsResponse {
        static instance: CMsgClientToGCRequestActiveGuildContractsResponse = CMsgClientToGCRequestActiveGuildContractsResponse {
            result: ::std::option::Option::None,
            active_contracts: ::protobuf::MessageField::none(),
            active_challenges: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestActiveGuildContractsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestActiveGuildContractsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestActiveGuildContractsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestActiveGuildContractsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestActiveGuildContractsResponse`
pub mod cmsg_client_to_gcrequest_active_guild_contracts_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestActiveGuildContractsResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestActiveGuildContractsResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientActiveGuildContractsUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientActiveGuildContractsUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientActiveGuildContractsUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientActiveGuildContractsUpdated.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientActiveGuildContractsUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientActiveGuildContractsUpdated {
    fn default() -> &'a CMsgGCToClientActiveGuildContractsUpdated {
        <CMsgGCToClientActiveGuildContractsUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientActiveGuildContractsUpdated {
    pub fn new() -> CMsgGCToClientActiveGuildContractsUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgGCToClientActiveGuildContractsUpdated| { &m.guild_id },
            |m: &mut CMsgGCToClientActiveGuildContractsUpdated| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgGCToClientActiveGuildContractsUpdated| { &m.event_id },
            |m: &mut CMsgGCToClientActiveGuildContractsUpdated| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientActiveGuildContractsUpdated>(
            "CMsgGCToClientActiveGuildContractsUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientActiveGuildContractsUpdated {
    const NAME: &'static str = "CMsgGCToClientActiveGuildContractsUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientActiveGuildContractsUpdated {
        CMsgGCToClientActiveGuildContractsUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientActiveGuildContractsUpdated {
        static instance: CMsgGCToClientActiveGuildContractsUpdated = CMsgGCToClientActiveGuildContractsUpdated {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientActiveGuildContractsUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientActiveGuildContractsUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientActiveGuildContractsUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientActiveGuildContractsUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSelectGuildContract)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSelectGuildContract {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSelectGuildContract.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSelectGuildContract.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSelectGuildContract.contract_id)
    pub contract_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSelectGuildContract.contract_slot)
    pub contract_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSelectGuildContract.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSelectGuildContract {
    fn default() -> &'a CMsgClientToGCSelectGuildContract {
        <CMsgClientToGCSelectGuildContract as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSelectGuildContract {
    pub fn new() -> CMsgClientToGCSelectGuildContract {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 contract_id = 3;

    pub fn contract_id(&self) -> u64 {
        self.contract_id.unwrap_or(0)
    }

    pub fn clear_contract_id(&mut self) {
        self.contract_id = ::std::option::Option::None;
    }

    pub fn has_contract_id(&self) -> bool {
        self.contract_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_id(&mut self, v: u64) {
        self.contract_id = ::std::option::Option::Some(v);
    }

    // optional uint32 contract_slot = 4;

    pub fn contract_slot(&self) -> u32 {
        self.contract_slot.unwrap_or(0)
    }

    pub fn clear_contract_slot(&mut self) {
        self.contract_slot = ::std::option::Option::None;
    }

    pub fn has_contract_slot(&self) -> bool {
        self.contract_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_slot(&mut self, v: u32) {
        self.contract_slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCSelectGuildContract| { &m.guild_id },
            |m: &mut CMsgClientToGCSelectGuildContract| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgClientToGCSelectGuildContract| { &m.event_id },
            |m: &mut CMsgClientToGCSelectGuildContract| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contract_id",
            |m: &CMsgClientToGCSelectGuildContract| { &m.contract_id },
            |m: &mut CMsgClientToGCSelectGuildContract| { &mut m.contract_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contract_slot",
            |m: &CMsgClientToGCSelectGuildContract| { &m.contract_slot },
            |m: &mut CMsgClientToGCSelectGuildContract| { &mut m.contract_slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSelectGuildContract>(
            "CMsgClientToGCSelectGuildContract",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSelectGuildContract {
    const NAME: &'static str = "CMsgClientToGCSelectGuildContract";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.contract_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.contract_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.contract_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.contract_slot {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.contract_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.contract_slot {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSelectGuildContract {
        CMsgClientToGCSelectGuildContract::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.contract_id = ::std::option::Option::None;
        self.contract_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSelectGuildContract {
        static instance: CMsgClientToGCSelectGuildContract = CMsgClientToGCSelectGuildContract {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            contract_id: ::std::option::Option::None,
            contract_slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSelectGuildContract {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSelectGuildContract").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSelectGuildContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSelectGuildContract {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCSelectGuildContractResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSelectGuildContractResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCSelectGuildContractResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcselect_guild_contract_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCSelectGuildContractResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSelectGuildContractResponse {
    fn default() -> &'a CMsgClientToGCSelectGuildContractResponse {
        <CMsgClientToGCSelectGuildContractResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSelectGuildContractResponse {
    pub fn new() -> CMsgClientToGCSelectGuildContractResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCSelectGuildContractResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcselect_guild_contract_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcselect_guild_contract_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcselect_guild_contract_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcselect_guild_contract_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCSelectGuildContractResponse| { &m.result },
            |m: &mut CMsgClientToGCSelectGuildContractResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCSelectGuildContractResponse>(
            "CMsgClientToGCSelectGuildContractResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCSelectGuildContractResponse {
    const NAME: &'static str = "CMsgClientToGCSelectGuildContractResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSelectGuildContractResponse {
        CMsgClientToGCSelectGuildContractResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSelectGuildContractResponse {
        static instance: CMsgClientToGCSelectGuildContractResponse = CMsgClientToGCSelectGuildContractResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCSelectGuildContractResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCSelectGuildContractResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCSelectGuildContractResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSelectGuildContractResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCSelectGuildContractResponse`
pub mod cmsg_client_to_gcselect_guild_contract_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCSelectGuildContractResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidContractID)
        k_eInvalidContractID = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eAlreadyAssigned)
        k_eAlreadyAssigned = 10,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidContractSlot)
        k_eInvalidContractSlot = 11,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractSlotLockedGuild)
        k_eContractSlotLockedGuild = 12,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractSlotCooldown)
        k_eContractSlotCooldown = 13,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractDuplicate)
        k_eContractDuplicate = 14,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractSlotTimeError)
        k_eContractSlotTimeError = 15,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractSlotLockedDotaPlus)
        k_eContractSlotLockedDotaPlus = 16,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidContractID),
                10 => ::std::option::Option::Some(EResponse::k_eAlreadyAssigned),
                11 => ::std::option::Option::Some(EResponse::k_eInvalidContractSlot),
                12 => ::std::option::Option::Some(EResponse::k_eContractSlotLockedGuild),
                13 => ::std::option::Option::Some(EResponse::k_eContractSlotCooldown),
                14 => ::std::option::Option::Some(EResponse::k_eContractDuplicate),
                15 => ::std::option::Option::Some(EResponse::k_eContractSlotTimeError),
                16 => ::std::option::Option::Some(EResponse::k_eContractSlotLockedDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                "k_eInvalidContractID" => ::std::option::Option::Some(EResponse::k_eInvalidContractID),
                "k_eAlreadyAssigned" => ::std::option::Option::Some(EResponse::k_eAlreadyAssigned),
                "k_eInvalidContractSlot" => ::std::option::Option::Some(EResponse::k_eInvalidContractSlot),
                "k_eContractSlotLockedGuild" => ::std::option::Option::Some(EResponse::k_eContractSlotLockedGuild),
                "k_eContractSlotCooldown" => ::std::option::Option::Some(EResponse::k_eContractSlotCooldown),
                "k_eContractDuplicate" => ::std::option::Option::Some(EResponse::k_eContractDuplicate),
                "k_eContractSlotTimeError" => ::std::option::Option::Some(EResponse::k_eContractSlotTimeError),
                "k_eContractSlotLockedDotaPlus" => ::std::option::Option::Some(EResponse::k_eContractSlotLockedDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
            EResponse::k_eInvalidContractID,
            EResponse::k_eAlreadyAssigned,
            EResponse::k_eInvalidContractSlot,
            EResponse::k_eContractSlotLockedGuild,
            EResponse::k_eContractSlotCooldown,
            EResponse::k_eContractDuplicate,
            EResponse::k_eContractSlotTimeError,
            EResponse::k_eContractSlotLockedDotaPlus,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCSelectGuildContractResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCSelectGuildContractResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestActiveGuildChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestActiveGuildChallenge {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestActiveGuildChallenge.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestActiveGuildChallenge.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestActiveGuildChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestActiveGuildChallenge {
    fn default() -> &'a CMsgClientToGCRequestActiveGuildChallenge {
        <CMsgClientToGCRequestActiveGuildChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestActiveGuildChallenge {
    pub fn new() -> CMsgClientToGCRequestActiveGuildChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCRequestActiveGuildChallenge| { &m.guild_id },
            |m: &mut CMsgClientToGCRequestActiveGuildChallenge| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgClientToGCRequestActiveGuildChallenge| { &m.event_id },
            |m: &mut CMsgClientToGCRequestActiveGuildChallenge| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestActiveGuildChallenge>(
            "CMsgClientToGCRequestActiveGuildChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestActiveGuildChallenge {
    const NAME: &'static str = "CMsgClientToGCRequestActiveGuildChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestActiveGuildChallenge {
        CMsgClientToGCRequestActiveGuildChallenge::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestActiveGuildChallenge {
        static instance: CMsgClientToGCRequestActiveGuildChallenge = CMsgClientToGCRequestActiveGuildChallenge {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestActiveGuildChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestActiveGuildChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestActiveGuildChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestActiveGuildChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestActiveGuildChallengeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestActiveGuildChallengeResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.active_challenge)
    pub active_challenge: ::protobuf::MessageField<CMsgGuildChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestActiveGuildChallengeResponse {
    fn default() -> &'a CMsgClientToGCRequestActiveGuildChallengeResponse {
        <CMsgClientToGCRequestActiveGuildChallengeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestActiveGuildChallengeResponse {
    pub fn new() -> CMsgClientToGCRequestActiveGuildChallengeResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestActiveGuildChallengeResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestActiveGuildChallengeResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildChallenge>(
            "active_challenge",
            |m: &CMsgClientToGCRequestActiveGuildChallengeResponse| { &m.active_challenge },
            |m: &mut CMsgClientToGCRequestActiveGuildChallengeResponse| { &mut m.active_challenge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestActiveGuildChallengeResponse>(
            "CMsgClientToGCRequestActiveGuildChallengeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestActiveGuildChallengeResponse {
    const NAME: &'static str = "CMsgClientToGCRequestActiveGuildChallengeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.active_challenge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.active_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.active_challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestActiveGuildChallengeResponse {
        CMsgClientToGCRequestActiveGuildChallengeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.active_challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestActiveGuildChallengeResponse {
        static instance: CMsgClientToGCRequestActiveGuildChallengeResponse = CMsgClientToGCRequestActiveGuildChallengeResponse {
            result: ::std::option::Option::None,
            active_challenge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestActiveGuildChallengeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestActiveGuildChallengeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestActiveGuildChallengeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestActiveGuildChallengeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestActiveGuildChallengeResponse`
pub mod cmsg_client_to_gcrequest_active_guild_challenge_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGCToClientActiveGuildChallengeUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientActiveGuildChallengeUpdated {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGCToClientActiveGuildChallengeUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientActiveGuildChallengeUpdated.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgGCToClientActiveGuildChallengeUpdated.active_challenge)
    pub active_challenge: ::protobuf::MessageField<CMsgGuildChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGCToClientActiveGuildChallengeUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientActiveGuildChallengeUpdated {
    fn default() -> &'a CMsgGCToClientActiveGuildChallengeUpdated {
        <CMsgGCToClientActiveGuildChallengeUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientActiveGuildChallengeUpdated {
    pub fn new() -> CMsgGCToClientActiveGuildChallengeUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgGCToClientActiveGuildChallengeUpdated| { &m.guild_id },
            |m: &mut CMsgGCToClientActiveGuildChallengeUpdated| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgGCToClientActiveGuildChallengeUpdated| { &m.event_id },
            |m: &mut CMsgGCToClientActiveGuildChallengeUpdated| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGuildChallenge>(
            "active_challenge",
            |m: &CMsgGCToClientActiveGuildChallengeUpdated| { &m.active_challenge },
            |m: &mut CMsgGCToClientActiveGuildChallengeUpdated| { &mut m.active_challenge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientActiveGuildChallengeUpdated>(
            "CMsgGCToClientActiveGuildChallengeUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientActiveGuildChallengeUpdated {
    const NAME: &'static str = "CMsgGCToClientActiveGuildChallengeUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.active_challenge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.active_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.active_challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientActiveGuildChallengeUpdated {
        CMsgGCToClientActiveGuildChallengeUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.active_challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientActiveGuildChallengeUpdated {
        static instance: CMsgGCToClientActiveGuildChallengeUpdated = CMsgGCToClientActiveGuildChallengeUpdated {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            active_challenge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientActiveGuildChallengeUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientActiveGuildChallengeUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientActiveGuildChallengeUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientActiveGuildChallengeUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestGuildEventMembers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildEventMembers {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildEventMembers.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildEventMembers.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestGuildEventMembers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildEventMembers {
    fn default() -> &'a CMsgClientToGCRequestGuildEventMembers {
        <CMsgClientToGCRequestGuildEventMembers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildEventMembers {
    pub fn new() -> CMsgClientToGCRequestGuildEventMembers {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCRequestGuildEventMembers| { &m.guild_id },
            |m: &mut CMsgClientToGCRequestGuildEventMembers| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgClientToGCRequestGuildEventMembers| { &m.event_id },
            |m: &mut CMsgClientToGCRequestGuildEventMembers| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestGuildEventMembers>(
            "CMsgClientToGCRequestGuildEventMembers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestGuildEventMembers {
    const NAME: &'static str = "CMsgClientToGCRequestGuildEventMembers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildEventMembers {
        CMsgClientToGCRequestGuildEventMembers::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildEventMembers {
        static instance: CMsgClientToGCRequestGuildEventMembers = CMsgClientToGCRequestGuildEventMembers {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestGuildEventMembers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestGuildEventMembers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestGuildEventMembers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestGuildEventMembers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCRequestGuildEventMembersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildEventMembersResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildEventMembersResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_guild_event_members_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCRequestGuildEventMembersResponse.members)
    pub members: ::std::vec::Vec<CMsgGuildEventMember>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCRequestGuildEventMembersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildEventMembersResponse {
    fn default() -> &'a CMsgClientToGCRequestGuildEventMembersResponse {
        <CMsgClientToGCRequestGuildEventMembersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildEventMembersResponse {
    pub fn new() -> CMsgClientToGCRequestGuildEventMembersResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_guild_event_members_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_guild_event_members_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_guild_event_members_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_guild_event_members_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCRequestGuildEventMembersResponse| { &m.result },
            |m: &mut CMsgClientToGCRequestGuildEventMembersResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CMsgClientToGCRequestGuildEventMembersResponse| { &m.members },
            |m: &mut CMsgClientToGCRequestGuildEventMembersResponse| { &mut m.members },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCRequestGuildEventMembersResponse>(
            "CMsgClientToGCRequestGuildEventMembersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestGuildEventMembersResponse {
    const NAME: &'static str = "CMsgClientToGCRequestGuildEventMembersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.members.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildEventMembersResponse {
        CMsgClientToGCRequestGuildEventMembersResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildEventMembersResponse {
        static instance: CMsgClientToGCRequestGuildEventMembersResponse = CMsgClientToGCRequestGuildEventMembersResponse {
            result: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCRequestGuildEventMembersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCRequestGuildEventMembersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCRequestGuildEventMembersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestGuildEventMembersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCRequestGuildEventMembersResponse`
pub mod cmsg_client_to_gcrequest_guild_event_members_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCRequestGuildEventMembersResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCRequestGuildEventMembersResponse.EResponse")
        }
    }
}

// @@protoc_insertion_point(message:dota.CMsgGuildLeaderboardCombinedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildLeaderboardCombinedResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgGuildLeaderboardCombinedResponse.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:dota.CMsgGuildLeaderboardCombinedResponse.region)
    pub region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildLeaderboardCombinedResponse.last_updated)
    pub last_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildLeaderboardCombinedResponse.guild_id)
    pub guild_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildLeaderboardCombinedResponse.rank)
    pub rank: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildLeaderboardCombinedResponse.current_percentile)
    pub current_percentile: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildLeaderboardCombinedResponse.weekly_percentile)
    pub weekly_percentile: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgGuildLeaderboardCombinedResponse.points)
    pub points: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgGuildLeaderboardCombinedResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildLeaderboardCombinedResponse {
    fn default() -> &'a CMsgGuildLeaderboardCombinedResponse {
        <CMsgGuildLeaderboardCombinedResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildLeaderboardCombinedResponse {
    pub fn new() -> CMsgGuildLeaderboardCombinedResponse {
        ::std::default::Default::default()
    }

    // optional .dota.EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 region = 2;

    pub fn region(&self) -> u32 {
        self.region.unwrap_or(0)
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: u32) {
        self.region = ::std::option::Option::Some(v);
    }

    // optional uint32 last_updated = 3;

    pub fn last_updated(&self) -> u32 {
        self.last_updated.unwrap_or(0)
    }

    pub fn clear_last_updated(&mut self) {
        self.last_updated = ::std::option::Option::None;
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: u32) {
        self.last_updated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgGuildLeaderboardCombinedResponse| { &m.event_id },
            |m: &mut CMsgGuildLeaderboardCombinedResponse| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region",
            |m: &CMsgGuildLeaderboardCombinedResponse| { &m.region },
            |m: &mut CMsgGuildLeaderboardCombinedResponse| { &mut m.region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_updated",
            |m: &CMsgGuildLeaderboardCombinedResponse| { &m.last_updated },
            |m: &mut CMsgGuildLeaderboardCombinedResponse| { &mut m.last_updated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guild_id",
            |m: &CMsgGuildLeaderboardCombinedResponse| { &m.guild_id },
            |m: &mut CMsgGuildLeaderboardCombinedResponse| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rank",
            |m: &CMsgGuildLeaderboardCombinedResponse| { &m.rank },
            |m: &mut CMsgGuildLeaderboardCombinedResponse| { &mut m.rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "current_percentile",
            |m: &CMsgGuildLeaderboardCombinedResponse| { &m.current_percentile },
            |m: &mut CMsgGuildLeaderboardCombinedResponse| { &mut m.current_percentile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weekly_percentile",
            |m: &CMsgGuildLeaderboardCombinedResponse| { &m.weekly_percentile },
            |m: &mut CMsgGuildLeaderboardCombinedResponse| { &mut m.weekly_percentile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "points",
            |m: &CMsgGuildLeaderboardCombinedResponse| { &m.points },
            |m: &mut CMsgGuildLeaderboardCombinedResponse| { &mut m.points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGuildLeaderboardCombinedResponse>(
            "CMsgGuildLeaderboardCombinedResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGuildLeaderboardCombinedResponse {
    const NAME: &'static str = "CMsgGuildLeaderboardCombinedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.region = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.last_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.guild_id)?;
                },
                32 => {
                    self.guild_id.push(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.rank)?;
                },
                40 => {
                    self.rank.push(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.current_percentile)?;
                },
                48 => {
                    self.current_percentile.push(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.weekly_percentile)?;
                },
                56 => {
                    self.weekly_percentile.push(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.points)?;
                },
                64 => {
                    self.points.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.region {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.last_updated {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.guild_id {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        for value in &self.rank {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        for value in &self.current_percentile {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        for value in &self.weekly_percentile {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        for value in &self.points {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.region {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_updated {
            os.write_uint32(3, v)?;
        }
        for v in &self.guild_id {
            os.write_uint32(4, *v)?;
        };
        for v in &self.rank {
            os.write_uint32(5, *v)?;
        };
        for v in &self.current_percentile {
            os.write_uint32(6, *v)?;
        };
        for v in &self.weekly_percentile {
            os.write_uint32(7, *v)?;
        };
        for v in &self.points {
            os.write_uint32(8, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildLeaderboardCombinedResponse {
        CMsgGuildLeaderboardCombinedResponse::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.last_updated = ::std::option::Option::None;
        self.guild_id.clear();
        self.rank.clear();
        self.current_percentile.clear();
        self.weekly_percentile.clear();
        self.points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildLeaderboardCombinedResponse {
        static instance: CMsgGuildLeaderboardCombinedResponse = CMsgGuildLeaderboardCombinedResponse {
            event_id: ::std::option::Option::None,
            region: ::std::option::Option::None,
            last_updated: ::std::option::Option::None,
            guild_id: ::std::vec::Vec::new(),
            rank: ::std::vec::Vec::new(),
            current_percentile: ::std::vec::Vec::new(),
            weekly_percentile: ::std::vec::Vec::new(),
            points: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGuildLeaderboardCombinedResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGuildLeaderboardCombinedResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGuildLeaderboardCombinedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGuildLeaderboardCombinedResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCClaimLeaderboardRewards)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCClaimLeaderboardRewards {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCClaimLeaderboardRewards.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCClaimLeaderboardRewards.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCClaimLeaderboardRewards.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCClaimLeaderboardRewards {
    fn default() -> &'a CMsgClientToGCClaimLeaderboardRewards {
        <CMsgClientToGCClaimLeaderboardRewards as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCClaimLeaderboardRewards {
    pub fn new() -> CMsgClientToGCClaimLeaderboardRewards {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .dota.EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guild_id",
            |m: &CMsgClientToGCClaimLeaderboardRewards| { &m.guild_id },
            |m: &mut CMsgClientToGCClaimLeaderboardRewards| { &mut m.guild_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgClientToGCClaimLeaderboardRewards| { &m.event_id },
            |m: &mut CMsgClientToGCClaimLeaderboardRewards| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCClaimLeaderboardRewards>(
            "CMsgClientToGCClaimLeaderboardRewards",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCClaimLeaderboardRewards {
    const NAME: &'static str = "CMsgClientToGCClaimLeaderboardRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCClaimLeaderboardRewards {
        CMsgClientToGCClaimLeaderboardRewards::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCClaimLeaderboardRewards {
        static instance: CMsgClientToGCClaimLeaderboardRewards = CMsgClientToGCClaimLeaderboardRewards {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCClaimLeaderboardRewards {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCClaimLeaderboardRewards").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCClaimLeaderboardRewards {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCClaimLeaderboardRewards {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgClientToGCClaimLeaderboardRewardsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCClaimLeaderboardRewardsResponse {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse>>,
    // @@protoc_insertion_point(field:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.event_points)
    pub event_points: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCClaimLeaderboardRewardsResponse {
    fn default() -> &'a CMsgClientToGCClaimLeaderboardRewardsResponse {
        <CMsgClientToGCClaimLeaderboardRewardsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCClaimLeaderboardRewardsResponse {
    pub fn new() -> CMsgClientToGCClaimLeaderboardRewardsResponse {
        ::std::default::Default::default()
    }

    // optional .dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 event_points = 2;

    pub fn event_points(&self) -> u32 {
        self.event_points.unwrap_or(0)
    }

    pub fn clear_event_points(&mut self) {
        self.event_points = ::std::option::Option::None;
    }

    pub fn has_event_points(&self) -> bool {
        self.event_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_points(&mut self, v: u32) {
        self.event_points = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientToGCClaimLeaderboardRewardsResponse| { &m.result },
            |m: &mut CMsgClientToGCClaimLeaderboardRewardsResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_points",
            |m: &CMsgClientToGCClaimLeaderboardRewardsResponse| { &m.event_points },
            |m: &mut CMsgClientToGCClaimLeaderboardRewardsResponse| { &mut m.event_points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientToGCClaimLeaderboardRewardsResponse>(
            "CMsgClientToGCClaimLeaderboardRewardsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientToGCClaimLeaderboardRewardsResponse {
    const NAME: &'static str = "CMsgClientToGCClaimLeaderboardRewardsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_points {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_points {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCClaimLeaderboardRewardsResponse {
        CMsgClientToGCClaimLeaderboardRewardsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event_points = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCClaimLeaderboardRewardsResponse {
        static instance: CMsgClientToGCClaimLeaderboardRewardsResponse = CMsgClientToGCClaimLeaderboardRewardsResponse {
            result: ::std::option::Option::None,
            event_points: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientToGCClaimLeaderboardRewardsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientToGCClaimLeaderboardRewardsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientToGCClaimLeaderboardRewardsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCClaimLeaderboardRewardsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientToGCClaimLeaderboardRewardsResponse`
pub mod cmsg_client_to_gcclaim_leaderboard_rewards_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eDoesNotQualify)
        k_eDoesNotQualify = 9,
        // @@protoc_insertion_point(enum_value:dota.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eAlreadyClaimed)
        k_eAlreadyClaimed = 10,
    }

    impl ::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                9 => ::std::option::Option::Some(EResponse::k_eDoesNotQualify),
                10 => ::std::option::Option::Some(EResponse::k_eAlreadyClaimed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                "k_eDoesNotQualify" => ::std::option::Option::Some(EResponse::k_eDoesNotQualify),
                "k_eAlreadyClaimed" => ::std::option::Option::Some(EResponse::k_eAlreadyClaimed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
            EResponse::k_eDoesNotQualify,
            EResponse::k_eAlreadyClaimed,
        ];
    }

    impl ::protobuf::EnumFull for EResponse {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

    impl EResponse {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EResponse>("CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.EGuildEventAuditAction)
pub enum EGuildEventAuditAction {
    // @@protoc_insertion_point(enum_value:dota.EGuildEventAuditAction.k_EGuildEventAuditAction_Invalid)
    k_EGuildEventAuditAction_Invalid = 0,
    // @@protoc_insertion_point(enum_value:dota.EGuildEventAuditAction.k_EGuildEventAuditAction_DevGrant)
    k_EGuildEventAuditAction_DevGrant = 1,
    // @@protoc_insertion_point(enum_value:dota.EGuildEventAuditAction.k_EGuildEventAuditAction_CompleteContract)
    k_EGuildEventAuditAction_CompleteContract = 2,
    // @@protoc_insertion_point(enum_value:dota.EGuildEventAuditAction.k_EGuildEventAuditAction_CompleteChallenge)
    k_EGuildEventAuditAction_CompleteChallenge = 3,
    // @@protoc_insertion_point(enum_value:dota.EGuildEventAuditAction.k_EGuildEventAuditAction_CompleteMatch_Winner)
    k_EGuildEventAuditAction_CompleteMatch_Winner = 4,
    // @@protoc_insertion_point(enum_value:dota.EGuildEventAuditAction.k_EGuildEventAuditAction_ChallengeProgress)
    k_EGuildEventAuditAction_ChallengeProgress = 5,
    // @@protoc_insertion_point(enum_value:dota.EGuildEventAuditAction.k_EGuildEventAuditAction_CompleteMatch_Loser)
    k_EGuildEventAuditAction_CompleteMatch_Loser = 6,
    // @@protoc_insertion_point(enum_value:dota.EGuildEventAuditAction.k_EGuildEventAuditAction_WeeklyLeaderboard)
    k_EGuildEventAuditAction_WeeklyLeaderboard = 7,
    // @@protoc_insertion_point(enum_value:dota.EGuildEventAuditAction.k_EGuildEventAuditAction_ManualGrant)
    k_EGuildEventAuditAction_ManualGrant = 8,
}

impl ::protobuf::Enum for EGuildEventAuditAction {
    const NAME: &'static str = "EGuildEventAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGuildEventAuditAction> {
        match value {
            0 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_Invalid),
            1 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_DevGrant),
            2 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteContract),
            3 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteChallenge),
            4 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Winner),
            5 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_ChallengeProgress),
            6 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Loser),
            7 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_WeeklyLeaderboard),
            8 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_ManualGrant),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGuildEventAuditAction> {
        match str {
            "k_EGuildEventAuditAction_Invalid" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_Invalid),
            "k_EGuildEventAuditAction_DevGrant" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_DevGrant),
            "k_EGuildEventAuditAction_CompleteContract" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteContract),
            "k_EGuildEventAuditAction_CompleteChallenge" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteChallenge),
            "k_EGuildEventAuditAction_CompleteMatch_Winner" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Winner),
            "k_EGuildEventAuditAction_ChallengeProgress" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_ChallengeProgress),
            "k_EGuildEventAuditAction_CompleteMatch_Loser" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Loser),
            "k_EGuildEventAuditAction_WeeklyLeaderboard" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_WeeklyLeaderboard),
            "k_EGuildEventAuditAction_ManualGrant" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_ManualGrant),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGuildEventAuditAction] = &[
        EGuildEventAuditAction::k_EGuildEventAuditAction_Invalid,
        EGuildEventAuditAction::k_EGuildEventAuditAction_DevGrant,
        EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteContract,
        EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteChallenge,
        EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Winner,
        EGuildEventAuditAction::k_EGuildEventAuditAction_ChallengeProgress,
        EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Loser,
        EGuildEventAuditAction::k_EGuildEventAuditAction_WeeklyLeaderboard,
        EGuildEventAuditAction::k_EGuildEventAuditAction_ManualGrant,
    ];
}

impl ::protobuf::EnumFull for EGuildEventAuditAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGuildEventAuditAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGuildEventAuditAction {
    fn default() -> Self {
        EGuildEventAuditAction::k_EGuildEventAuditAction_Invalid
    }
}

impl EGuildEventAuditAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGuildEventAuditAction>("EGuildEventAuditAction")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)dota_gcmessages_client_guild_events.proto\x12\x04dota\x1a\x17dota_sha\
    red_enums.proto\"\xa1\x02\n\x11CMsgGuildContract\x12\x1f\n\x0bcontract_i\
    d\x18\x01\x20\x01(\x04R\ncontractId\x122\n\x15challenge_instance_id\x18\
    \x02\x20\x01(\rR\x13challengeInstanceId\x12/\n\x13challenge_parameter\
    \x18\x03\x20\x01(\rR\x12challengeParameter\x12/\n\x13challenge_timestamp\
    \x18\x04\x20\x01(\rR\x12challengeTimestamp\x12.\n\x13assigned_account_id\
    \x18\x05\x20\x01(\rR\x11assignedAccountId\x12%\n\x0econtract_flags\x18\
    \x06\x20\x01(\rR\rcontractFlags\"L\n\x15CMsgGuildContractSlot\x123\n\x08\
    contract\x18\x01\x20\x01(\x0b2\x17.dota.CMsgGuildContractR\x08contract\"\
    \xaa\x04\n\x19CMsgAccountGuildEventData\x12!\n\x0cguild_points\x18\x01\
    \x20\x01(\rR\x0bguildPoints\x12B\n\x1dcontracts_refreshed_timestamp\x18\
    \x02\x20\x01(\rR\x1bcontractsRefreshedTimestamp\x12B\n\x0econtract_slots\
    \x18\x03\x20\x03(\x0b2\x1b.dota.CMsgGuildContractSlotR\rcontractSlots\
    \x12:\n\x19completed_challenge_count\x18\x04\x20\x01(\rR\x17completedCha\
    llengeCount\x12@\n\x1cchallenges_refresh_timestamp\x18\x05\x20\x01(\rR\
    \x1achallengesRefreshTimestamp\x126\n\x17guild_weekly_percentile\x18\x06\
    \x20\x01(\rR\x15guildWeeklyPercentile\x12=\n\x1bguild_weekly_last_timest\
    amp\x18\x07\x20\x01(\rR\x18guildWeeklyLastTimestamp\x123\n\x16last_weekl\
    y_claim_time\x18\x08\x20\x01(\rR\x13lastWeeklyClaimTime\x128\n\x18guild_\
    current_percentile\x18\t\x20\x01(\rR\x16guildCurrentPercentile\"\x95\x01\
    \n\x18CMsgGuildActiveContracts\x12B\n\x1dcontracts_refreshed_timestamp\
    \x18\x01\x20\x01(\rR\x1bcontractsRefreshedTimestamp\x125\n\tcontracts\
    \x18\x02\x20\x03(\x0b2\x17.dota.CMsgGuildContractR\tcontracts\"\x82\x02\
    \n\x12CMsgGuildChallenge\x122\n\x15challenge_instance_id\x18\x01\x20\x01\
    (\rR\x13challengeInstanceId\x12/\n\x13challenge_parameter\x18\x02\x20\
    \x01(\rR\x12challengeParameter\x12/\n\x13challenge_timestamp\x18\x03\x20\
    \x01(\rR\x12challengeTimestamp\x12-\n\x12challenge_progress\x18\x04\x20\
    \x01(\rR\x11challengeProgress\x12'\n\x0fchallenge_flags\x18\x05\x20\x01(\
    \rR\x0echallengeFlags\"e\n\x14CMsgGuildEventMember\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12.\n\x13guild_points_earned\x18\x02\
    \x20\x01(\rR\x11guildPointsEarned\"p\n*CMsgClientToGCRequestAccountGuild\
    EventData\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12'\n\
    \x08event_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\"\xb4\x03\
    \n2CMsgClientToGCRequestAccountGuildEventDataResponse\x12Z\n\x06result\
    \x18\x01\x20\x01(\x0e2B.dota.CMsgClientToGCRequestAccountGuildEventDataR\
    esponse.EResponseR\x06result\x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\
    \x0c.dota.EEventR\x07eventId\x12>\n\nevent_data\x18\x03\x20\x01(\x0b2\
    \x1f.dota.CMsgAccountGuildEventDataR\teventData\"\xb8\x01\n\tEResponse\
    \x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\
    \x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk\
    _eTimeout\x10\x04\x12\x13\n\x0fk_eInvalidEvent\x10\x05\x12\x13\n\x0fk_eI\
    nvalidGuild\x10\x06\x12\x10\n\x0ck_eNotMember\x10\x07\x12\x18\n\x14k_eIn\
    validGuildEvent\x10\x08\"\x8b\x02\n*CMsgGCToClientAccountGuildEventDataU\
    pdated\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12'\n\x08ev\
    ent_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x12!\n\x0cupdat\
    e_flags\x18\x03\x20\x01(\rR\x0bupdateFlags\x12I\n\x10guild_event_data\
    \x18\x04\x20\x01(\x0b2\x1f.dota.CMsgAccountGuildEventDataR\x0eguildEvent\
    Data\x12+\n\x11contracts_updated\x18\x05\x20\x01(\x08R\x10contractsUpdat\
    ed\"o\n)CMsgClientToGCRequestActiveGuildContracts\x12\x19\n\x08guild_id\
    \x18\x01\x20\x01(\rR\x07guildId\x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\
    \x0c.dota.EEventR\x07eventId\"\xdb\x03\n1CMsgClientToGCRequestActiveGuil\
    dContractsResponse\x12Y\n\x06result\x18\x01\x20\x01(\x0e2A.dota.CMsgClie\
    ntToGCRequestActiveGuildContractsResponse.EResponseR\x06result\x12I\n\
    \x10active_contracts\x18\x02\x20\x01(\x0b2\x1e.dota.CMsgGuildActiveContr\
    actsR\x0factiveContracts\x12E\n\x11active_challenges\x18\x03\x20\x01(\
    \x0b2\x18.dota.CMsgGuildChallengeR\x10activeChallenges\"\xb8\x01\n\tERes\
    ponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\
    \x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\
    \n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eInvalidEvent\x10\x05\x12\x13\n\
    \x0fk_eInvalidGuild\x10\x06\x12\x10\n\x0ck_eNotMember\x10\x07\x12\x18\n\
    \x14k_eInvalidGuildEvent\x10\x08\"o\n)CMsgGCToClientActiveGuildContracts\
    Updated\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12'\n\x08e\
    vent_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\"\xad\x01\n!CM\
    sgClientToGCSelectGuildContract\x12\x19\n\x08guild_id\x18\x01\x20\x01(\r\
    R\x07guildId\x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\
    \x07eventId\x12\x1f\n\x0bcontract_id\x18\x03\x20\x01(\x04R\ncontractId\
    \x12#\n\rcontract_slot\x18\x04\x20\x01(\rR\x0ccontractSlot\"\x9f\x04\n)C\
    MsgClientToGCSelectGuildContractResponse\x12Q\n\x06result\x18\x01\x20\
    \x01(\x0e29.dota.CMsgClientToGCSelectGuildContractResponse.EResponseR\
    \x06result\"\x9e\x03\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\
    \x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\
    \x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eIn\
    validEvent\x10\x05\x12\x13\n\x0fk_eInvalidGuild\x10\x06\x12\x10\n\x0ck_e\
    NotMember\x10\x07\x12\x18\n\x14k_eInvalidGuildEvent\x10\x08\x12\x18\n\
    \x14k_eInvalidContractID\x10\t\x12\x16\n\x12k_eAlreadyAssigned\x10\n\x12\
    \x1a\n\x16k_eInvalidContractSlot\x10\x0b\x12\x1e\n\x1ak_eContractSlotLoc\
    kedGuild\x10\x0c\x12\x1b\n\x17k_eContractSlotCooldown\x10\r\x12\x18\n\
    \x14k_eContractDuplicate\x10\x0e\x12\x1c\n\x18k_eContractSlotTimeError\
    \x10\x0f\x12!\n\x1dk_eContractSlotLockedDotaPlus\x10\x10\"o\n)CMsgClient\
    ToGCRequestActiveGuildChallenge\x12\x19\n\x08guild_id\x18\x01\x20\x01(\r\
    R\x07guildId\x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\
    \x07eventId\"\x8e\x03\n1CMsgClientToGCRequestActiveGuildChallengeRespons\
    e\x12Y\n\x06result\x18\x01\x20\x01(\x0e2A.dota.CMsgClientToGCRequestActi\
    veGuildChallengeResponse.EResponseR\x06result\x12C\n\x10active_challenge\
    \x18\x02\x20\x01(\x0b2\x18.dota.CMsgGuildChallengeR\x0factiveChallenge\"\
    \xb8\x01\n\tEResponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_e\
    Success\x10\x01\x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\
    \x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eInvalidEvent\x10\
    \x05\x12\x13\n\x0fk_eInvalidGuild\x10\x06\x12\x10\n\x0ck_eNotMember\x10\
    \x07\x12\x18\n\x14k_eInvalidGuildEvent\x10\x08\"\xb4\x01\n)CMsgGCToClien\
    tActiveGuildChallengeUpdated\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\
    \x07guildId\x12'\n\x08event_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\
    \x07eventId\x12C\n\x10active_challenge\x18\x03\x20\x01(\x0b2\x18.dota.CM\
    sgGuildChallengeR\x0factiveChallenge\"l\n&CMsgClientToGCRequestGuildEven\
    tMembers\x12\x19\n\x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12'\n\x08\
    event_id\x18\x02\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\"\xf9\x02\n.C\
    MsgClientToGCRequestGuildEventMembersResponse\x12V\n\x06result\x18\x01\
    \x20\x01(\x0e2>.dota.CMsgClientToGCRequestGuildEventMembersResponse.ERes\
    ponseR\x06result\x124\n\x07members\x18\x02\x20\x03(\x0b2\x1a.dota.CMsgGu\
    ildEventMemberR\x07members\"\xb8\x01\n\tEResponse\x12\x14\n\x10k_eIntern\
    alError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\x12\x0e\n\nk_eTooBusy\x10\
    \x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\n\nk_eTimeout\x10\x04\x12\
    \x13\n\x0fk_eInvalidEvent\x10\x05\x12\x13\n\x0fk_eInvalidGuild\x10\x06\
    \x12\x10\n\x0ck_eNotMember\x10\x07\x12\x18\n\x14k_eInvalidGuildEvent\x10\
    \x08\"\xad\x02\n$CMsgGuildLeaderboardCombinedResponse\x12'\n\x08event_id\
    \x18\x01\x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\x12\x16\n\x06region\
    \x18\x02\x20\x01(\rR\x06region\x12!\n\x0clast_updated\x18\x03\x20\x01(\r\
    R\x0blastUpdated\x12\x19\n\x08guild_id\x18\x04\x20\x03(\rR\x07guildId\
    \x12\x12\n\x04rank\x18\x05\x20\x03(\rR\x04rank\x12-\n\x12current_percent\
    ile\x18\x06\x20\x03(\rR\x11currentPercentile\x12+\n\x11weekly_percentile\
    \x18\x07\x20\x03(\rR\x10weeklyPercentile\x12\x16\n\x06points\x18\x08\x20\
    \x03(\rR\x06points\"k\n%CMsgClientToGCClaimLeaderboardRewards\x12\x19\n\
    \x08guild_id\x18\x01\x20\x01(\rR\x07guildId\x12'\n\x08event_id\x18\x02\
    \x20\x01(\x0e2\x0c.dota.EEventR\x07eventId\"\x92\x03\n-CMsgClientToGCCla\
    imLeaderboardRewardsResponse\x12U\n\x06result\x18\x01\x20\x01(\x0e2=.dot\
    a.CMsgClientToGCClaimLeaderboardRewardsResponse.EResponseR\x06result\x12\
    !\n\x0cevent_points\x18\x02\x20\x01(\rR\x0beventPoints\"\xe6\x01\n\tERes\
    ponse\x12\x14\n\x10k_eInternalError\x10\0\x12\x0e\n\nk_eSuccess\x10\x01\
    \x12\x0e\n\nk_eTooBusy\x10\x02\x12\x0f\n\x0bk_eDisabled\x10\x03\x12\x0e\
    \n\nk_eTimeout\x10\x04\x12\x13\n\x0fk_eInvalidEvent\x10\x05\x12\x13\n\
    \x0fk_eInvalidGuild\x10\x06\x12\x10\n\x0ck_eNotMember\x10\x07\x12\x18\n\
    \x14k_eInvalidGuildEvent\x10\x08\x12\x15\n\x11k_eDoesNotQualify\x10\t\
    \x12\x15\n\x11k_eAlreadyClaimed\x10\n*\xb3\x03\n\x16EGuildEventAuditActi\
    on\x12$\n\x20k_EGuildEventAuditAction_Invalid\x10\0\x12%\n!k_EGuildEvent\
    AuditAction_DevGrant\x10\x01\x12-\n)k_EGuildEventAuditAction_CompleteCon\
    tract\x10\x02\x12.\n*k_EGuildEventAuditAction_CompleteChallenge\x10\x03\
    \x121\n-k_EGuildEventAuditAction_CompleteMatch_Winner\x10\x04\x12.\n*k_E\
    GuildEventAuditAction_ChallengeProgress\x10\x05\x120\n,k_EGuildEventAudi\
    tAction_CompleteMatch_Loser\x10\x06\x12.\n*k_EGuildEventAuditAction_Week\
    lyLeaderboard\x10\x07\x12(\n$k_EGuildEventAuditAction_ManualGrant\x10\
    \x08B%Z#github.com/dotabuff/manta/dota;dotaJ\xc5H\n\x07\x12\x05\0\0\xeb\
    \x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\
    \x0c\n\x08\n\x01\x08\x12\x03\x03\0:\n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\
    \n\x02\x03\0\x12\x03\x05\x07\x20\n\n\n\x02\x05\0\x12\x04\x07\0\x11\x01\n\
    \n\n\x03\x05\0\x01\x12\x03\x07\x05\x1b\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \x08\x08-\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x08\x08(\n\x0c\n\x05\x05\0\
    \x02\0\x02\x12\x03\x08+,\n\x0b\n\x04\x05\0\x02\x01\x12\x03\t\x08.\n\x0c\
    \n\x05\x05\0\x02\x01\x01\x12\x03\t\x08)\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03\t,-\n\x0b\n\x04\x05\0\x02\x02\x12\x03\n\x086\n\x0c\n\x05\x05\0\
    \x02\x02\x01\x12\x03\n\x081\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\n45\n\
    \x0b\n\x04\x05\0\x02\x03\x12\x03\x0b\x087\n\x0c\n\x05\x05\0\x02\x03\x01\
    \x12\x03\x0b\x082\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x0b56\n\x0b\n\
    \x04\x05\0\x02\x04\x12\x03\x0c\x08:\n\x0c\n\x05\x05\0\x02\x04\x01\x12\
    \x03\x0c\x085\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0c89\n\x0b\n\x04\
    \x05\0\x02\x05\x12\x03\r\x087\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\r\
    \x082\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\r56\n\x0b\n\x04\x05\0\x02\
    \x06\x12\x03\x0e\x089\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x0e\x084\n\
    \x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0e78\n\x0b\n\x04\x05\0\x02\x07\x12\
    \x03\x0f\x087\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x0f\x082\n\x0c\n\x05\
    \x05\0\x02\x07\x02\x12\x03\x0f56\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x10\
    \x081\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x10\x08,\n\x0c\n\x05\x05\0\
    \x02\x08\x02\x12\x03\x10/0\n\n\n\x02\x04\0\x12\x04\x13\0\x1a\x01\n\n\n\
    \x03\x04\0\x01\x12\x03\x13\x08\x19\n\x0b\n\x04\x04\0\x02\0\x12\x03\x14\
    \x08(\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x14\x08\x10\n\x0c\n\x05\x04\0\
    \x02\0\x05\x12\x03\x14\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x14\
    \x18#\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x14&'\n\x0b\n\x04\x04\0\x02\
    \x01\x12\x03\x15\x082\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x15\x08\x10\
    \n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x15\x11\x17\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\x15\x18-\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1501\n\
    \x0b\n\x04\x04\0\x02\x02\x12\x03\x16\x080\n\x0c\n\x05\x04\0\x02\x02\x04\
    \x12\x03\x16\x08\x10\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x16\x11\x17\n\
    \x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x16\x18+\n\x0c\n\x05\x04\0\x02\x02\
    \x03\x12\x03\x16./\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x17\x080\n\x0c\n\
    \x05\x04\0\x02\x03\x04\x12\x03\x17\x08\x10\n\x0c\n\x05\x04\0\x02\x03\x05\
    \x12\x03\x17\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x17\x18+\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x17./\n\x0b\n\x04\x04\0\x02\x04\x12\
    \x03\x18\x080\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03\x18\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x04\x05\x12\x03\x18\x11\x17\n\x0c\n\x05\x04\0\x02\x04\x01\
    \x12\x03\x18\x18+\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x18./\n\x0b\n\
    \x04\x04\0\x02\x05\x12\x03\x19\x08+\n\x0c\n\x05\x04\0\x02\x05\x04\x12\
    \x03\x19\x08\x10\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03\x19\x11\x17\n\x0c\
    \n\x05\x04\0\x02\x05\x01\x12\x03\x19\x18&\n\x0c\n\x05\x04\0\x02\x05\x03\
    \x12\x03\x19)*\n\n\n\x02\x04\x01\x12\x04\x1c\0\x1e\x01\n\n\n\x03\x04\x01\
    \x01\x12\x03\x1c\x08\x1d\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x1d\x080\n\
    \x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x1d\x08\x10\n\x0c\n\x05\x04\x01\x02\
    \0\x06\x12\x03\x1d\x11\"\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1d#+\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1d./\n\n\n\x02\x04\x02\x12\x04\x20\
    \0*\x01\n\n\n\x03\x04\x02\x01\x12\x03\x20\x08!\n\x0b\n\x04\x04\x02\x02\0\
    \x12\x03!\x08)\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03!\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\0\x05\x12\x03!\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03!\x18$\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03!'(\n\x0b\n\x04\x04\
    \x02\x02\x01\x12\x03\"\x08:\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03\"\
    \x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\"\x11\x17\n\x0c\n\x05\
    \x04\x02\x02\x01\x01\x12\x03\"\x185\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\
    \x03\"89\n\x0b\n\x04\x04\x02\x02\x02\x12\x03#\x08:\n\x0c\n\x05\x04\x02\
    \x02\x02\x04\x12\x03#\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03#\
    \x11&\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03#'5\n\x0c\n\x05\x04\x02\x02\
    \x02\x03\x12\x03#89\n\x0b\n\x04\x04\x02\x02\x03\x12\x03$\x086\n\x0c\n\
    \x05\x04\x02\x02\x03\x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\
    \x05\x12\x03$\x11\x17\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03$\x181\n\
    \x0c\n\x05\x04\x02\x02\x03\x03\x12\x03$45\n\x0b\n\x04\x04\x02\x02\x04\
    \x12\x03%\x089\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03%\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x04\x05\x12\x03%\x11\x17\n\x0c\n\x05\x04\x02\x02\x04\
    \x01\x12\x03%\x184\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03%78\n\x0b\n\
    \x04\x04\x02\x02\x05\x12\x03&\x084\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\
    \x03&\x08\x10\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03&\x11\x17\n\x0c\n\
    \x05\x04\x02\x02\x05\x01\x12\x03&\x18/\n\x0c\n\x05\x04\x02\x02\x05\x03\
    \x12\x03&23\n\x0b\n\x04\x04\x02\x02\x06\x12\x03'\x088\n\x0c\n\x05\x04\
    \x02\x02\x06\x04\x12\x03'\x08\x10\n\x0c\n\x05\x04\x02\x02\x06\x05\x12\
    \x03'\x11\x17\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03'\x183\n\x0c\n\x05\
    \x04\x02\x02\x06\x03\x12\x03'67\n\x0b\n\x04\x04\x02\x02\x07\x12\x03(\x08\
    3\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x07\x05\x12\x03(\x11\x17\n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03(\
    \x18.\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03(12\n\x0b\n\x04\x04\x02\x02\
    \x08\x12\x03)\x085\n\x0c\n\x05\x04\x02\x02\x08\x04\x12\x03)\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x08\x05\x12\x03)\x11\x17\n\x0c\n\x05\x04\x02\x02\
    \x08\x01\x12\x03)\x180\n\x0c\n\x05\x04\x02\x02\x08\x03\x12\x03)34\n\n\n\
    \x02\x04\x03\x12\x04,\0/\x01\n\n\n\x03\x04\x03\x01\x12\x03,\x08\x20\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x03-\x08:\n\x0c\n\x05\x04\x03\x02\0\x04\x12\
    \x03-\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03-\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\0\x01\x12\x03-\x185\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03-8\
    9\n\x0b\n\x04\x04\x03\x02\x01\x12\x03.\x081\n\x0c\n\x05\x04\x03\x02\x01\
    \x04\x12\x03.\x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03.\x11\"\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03.#,\n\x0c\n\x05\x04\x03\x02\x01\
    \x03\x12\x03./0\n\n\n\x02\x04\x04\x12\x041\07\x01\n\n\n\x03\x04\x04\x01\
    \x12\x031\x08\x1a\n\x0b\n\x04\x04\x04\x02\0\x12\x032\x082\n\x0c\n\x05\
    \x04\x04\x02\0\x04\x12\x032\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\
    \x032\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x032\x18-\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x03201\n\x0b\n\x04\x04\x04\x02\x01\x12\x033\x080\
    \n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\x04\
    \x02\x01\x05\x12\x033\x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x033\
    \x18+\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x033./\n\x0b\n\x04\x04\x04\x02\
    \x02\x12\x034\x080\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x034\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\x02\x05\x12\x034\x11\x17\n\x0c\n\x05\x04\x04\x02\
    \x02\x01\x12\x034\x18+\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x034./\n\x0b\
    \n\x04\x04\x04\x02\x03\x12\x035\x08/\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\
    \x035\x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x035\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x03\x01\x12\x035\x18*\n\x0c\n\x05\x04\x04\x02\x03\x03\
    \x12\x035-.\n\x0b\n\x04\x04\x04\x02\x04\x12\x036\x08,\n\x0c\n\x05\x04\
    \x04\x02\x04\x04\x12\x036\x08\x10\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\
    \x036\x11\x17\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x036\x18'\n\x0c\n\x05\
    \x04\x04\x02\x04\x03\x12\x036*+\n\n\n\x02\x04\x05\x12\x049\0<\x01\n\n\n\
    \x03\x04\x05\x01\x12\x039\x08\x1c\n\x0b\n\x04\x04\x05\x02\0\x12\x03:\x08\
    '\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\x05\x02\
    \0\x05\x12\x03:\x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03:\x18\"\n\
    \x0c\n\x05\x04\x05\x02\0\x03\x12\x03:%&\n\x0b\n\x04\x04\x05\x02\x01\x12\
    \x03;\x080\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03;\x08\x10\n\x0c\n\x05\
    \x04\x05\x02\x01\x05\x12\x03;\x11\x17\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x03;\x18+\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03;./\n\n\n\x02\x04\
    \x06\x12\x04>\0A\x01\n\n\n\x03\x04\x06\x01\x12\x03>\x082\n\x0b\n\x04\x04\
    \x06\x02\0\x12\x03?\x08%\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03?\x08\x10\
    \n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03?\x11\x17\n\x0c\n\x05\x04\x06\x02\
    \0\x01\x12\x03?\x18\x20\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03?#$\n\x0b\n\
    \x04\x04\x06\x02\x01\x12\x03@\x08%\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\
    \x03@\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\x03@\x11\x17\n\x0c\n\
    \x05\x04\x06\x02\x01\x01\x12\x03@\x18\x20\n\x0c\n\x05\x04\x06\x02\x01\
    \x03\x12\x03@#$\n\n\n\x02\x04\x07\x12\x04C\0S\x01\n\n\n\x03\x04\x07\x01\
    \x12\x03C\x08:\n\x0c\n\x04\x04\x07\x04\0\x12\x04D\x08N\t\n\x0c\n\x05\x04\
    \x07\x04\0\x01\x12\x03D\r\x16\n\r\n\x06\x04\x07\x04\0\x02\0\x12\x03E\x10\
    %\n\x0e\n\x07\x04\x07\x04\0\x02\0\x01\x12\x03E\x10\x20\n\x0e\n\x07\x04\
    \x07\x04\0\x02\0\x02\x12\x03E#$\n\r\n\x06\x04\x07\x04\0\x02\x01\x12\x03F\
    \x10\x1f\n\x0e\n\x07\x04\x07\x04\0\x02\x01\x01\x12\x03F\x10\x1a\n\x0e\n\
    \x07\x04\x07\x04\0\x02\x01\x02\x12\x03F\x1d\x1e\n\r\n\x06\x04\x07\x04\0\
    \x02\x02\x12\x03G\x10\x1f\n\x0e\n\x07\x04\x07\x04\0\x02\x02\x01\x12\x03G\
    \x10\x1a\n\x0e\n\x07\x04\x07\x04\0\x02\x02\x02\x12\x03G\x1d\x1e\n\r\n\
    \x06\x04\x07\x04\0\x02\x03\x12\x03H\x10\x20\n\x0e\n\x07\x04\x07\x04\0\
    \x02\x03\x01\x12\x03H\x10\x1b\n\x0e\n\x07\x04\x07\x04\0\x02\x03\x02\x12\
    \x03H\x1e\x1f\n\r\n\x06\x04\x07\x04\0\x02\x04\x12\x03I\x10\x1f\n\x0e\n\
    \x07\x04\x07\x04\0\x02\x04\x01\x12\x03I\x10\x1a\n\x0e\n\x07\x04\x07\x04\
    \0\x02\x04\x02\x12\x03I\x1d\x1e\n\r\n\x06\x04\x07\x04\0\x02\x05\x12\x03J\
    \x10$\n\x0e\n\x07\x04\x07\x04\0\x02\x05\x01\x12\x03J\x10\x1f\n\x0e\n\x07\
    \x04\x07\x04\0\x02\x05\x02\x12\x03J\"#\n\r\n\x06\x04\x07\x04\0\x02\x06\
    \x12\x03K\x10$\n\x0e\n\x07\x04\x07\x04\0\x02\x06\x01\x12\x03K\x10\x1f\n\
    \x0e\n\x07\x04\x07\x04\0\x02\x06\x02\x12\x03K\"#\n\r\n\x06\x04\x07\x04\0\
    \x02\x07\x12\x03L\x10!\n\x0e\n\x07\x04\x07\x04\0\x02\x07\x01\x12\x03L\
    \x10\x1c\n\x0e\n\x07\x04\x07\x04\0\x02\x07\x02\x12\x03L\x1f\x20\n\r\n\
    \x06\x04\x07\x04\0\x02\x08\x12\x03M\x10)\n\x0e\n\x07\x04\x07\x04\0\x02\
    \x08\x01\x12\x03M\x10$\n\x0e\n\x07\x04\x07\x04\0\x02\x08\x02\x12\x03M'(\
    \n\x0b\n\x04\x04\x07\x02\0\x12\x03P\x08Y\n\x0c\n\x05\x04\x07\x02\0\x04\
    \x12\x03P\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03P\x11M\n\x0c\n\
    \x05\x04\x07\x02\0\x01\x12\x03PNT\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03P\
    WX\n\x0b\n\x04\x04\x07\x02\x01\x12\x03Q\x08%\n\x0c\n\x05\x04\x07\x02\x01\
    \x04\x12\x03Q\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\x06\x12\x03Q\x11\x17\n\
    \x0c\n\x05\x04\x07\x02\x01\x01\x12\x03Q\x18\x20\n\x0c\n\x05\x04\x07\x02\
    \x01\x03\x12\x03Q#$\n\x0b\n\x04\x04\x07\x02\x02\x12\x03R\x08:\n\x0c\n\
    \x05\x04\x07\x02\x02\x04\x12\x03R\x08\x10\n\x0c\n\x05\x04\x07\x02\x02\
    \x06\x12\x03R\x11*\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03R+5\n\x0c\n\
    \x05\x04\x07\x02\x02\x03\x12\x03R89\n\n\n\x02\x04\x08\x12\x04U\0[\x01\n\
    \n\n\x03\x04\x08\x01\x12\x03U\x082\n\x0b\n\x04\x04\x08\x02\0\x12\x03V\
    \x08%\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\x08\
    \x02\0\x05\x12\x03V\x11\x17\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03V\x18\
    \x20\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03V#$\n\x0b\n\x04\x04\x08\x02\
    \x01\x12\x03W\x08%\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03W\x08\x10\n\
    \x0c\n\x05\x04\x08\x02\x01\x06\x12\x03W\x11\x17\n\x0c\n\x05\x04\x08\x02\
    \x01\x01\x12\x03W\x18\x20\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03W#$\n\
    \x0b\n\x04\x04\x08\x02\x02\x12\x03X\x08)\n\x0c\n\x05\x04\x08\x02\x02\x04\
    \x12\x03X\x08\x10\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03X\x11\x17\n\x0c\
    \n\x05\x04\x08\x02\x02\x01\x12\x03X\x18$\n\x0c\n\x05\x04\x08\x02\x02\x03\
    \x12\x03X'(\n\x0b\n\x04\x04\x08\x02\x03\x12\x03Y\x08@\n\x0c\n\x05\x04\
    \x08\x02\x03\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\x08\x02\x03\x06\x12\
    \x03Y\x11*\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03Y+;\n\x0c\n\x05\x04\
    \x08\x02\x03\x03\x12\x03Y>?\n\x0b\n\x04\x04\x08\x02\x04\x12\x03Z\x08,\n\
    \x0c\n\x05\x04\x08\x02\x04\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\x08\x02\
    \x04\x05\x12\x03Z\x11\x15\n\x0c\n\x05\x04\x08\x02\x04\x01\x12\x03Z\x16'\
    \n\x0c\n\x05\x04\x08\x02\x04\x03\x12\x03Z*+\n\n\n\x02\x04\t\x12\x04]\0`\
    \x01\n\n\n\x03\x04\t\x01\x12\x03]\x081\n\x0b\n\x04\x04\t\x02\0\x12\x03^\
    \x08%\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03^\x08\x10\n\x0c\n\x05\x04\t\x02\
    \0\x05\x12\x03^\x11\x17\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03^\x18\x20\n\
    \x0c\n\x05\x04\t\x02\0\x03\x12\x03^#$\n\x0b\n\x04\x04\t\x02\x01\x12\x03_\
    \x08%\n\x0c\n\x05\x04\t\x02\x01\x04\x12\x03_\x08\x10\n\x0c\n\x05\x04\t\
    \x02\x01\x06\x12\x03_\x11\x17\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03_\x18\
    \x20\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03_#$\n\n\n\x02\x04\n\x12\x04b\0\
    r\x01\n\n\n\x03\x04\n\x01\x12\x03b\x089\n\x0c\n\x04\x04\n\x04\0\x12\x04c\
    \x08m\t\n\x0c\n\x05\x04\n\x04\0\x01\x12\x03c\r\x16\n\r\n\x06\x04\n\x04\0\
    \x02\0\x12\x03d\x10%\n\x0e\n\x07\x04\n\x04\0\x02\0\x01\x12\x03d\x10\x20\
    \n\x0e\n\x07\x04\n\x04\0\x02\0\x02\x12\x03d#$\n\r\n\x06\x04\n\x04\0\x02\
    \x01\x12\x03e\x10\x1f\n\x0e\n\x07\x04\n\x04\0\x02\x01\x01\x12\x03e\x10\
    \x1a\n\x0e\n\x07\x04\n\x04\0\x02\x01\x02\x12\x03e\x1d\x1e\n\r\n\x06\x04\
    \n\x04\0\x02\x02\x12\x03f\x10\x1f\n\x0e\n\x07\x04\n\x04\0\x02\x02\x01\
    \x12\x03f\x10\x1a\n\x0e\n\x07\x04\n\x04\0\x02\x02\x02\x12\x03f\x1d\x1e\n\
    \r\n\x06\x04\n\x04\0\x02\x03\x12\x03g\x10\x20\n\x0e\n\x07\x04\n\x04\0\
    \x02\x03\x01\x12\x03g\x10\x1b\n\x0e\n\x07\x04\n\x04\0\x02\x03\x02\x12\
    \x03g\x1e\x1f\n\r\n\x06\x04\n\x04\0\x02\x04\x12\x03h\x10\x1f\n\x0e\n\x07\
    \x04\n\x04\0\x02\x04\x01\x12\x03h\x10\x1a\n\x0e\n\x07\x04\n\x04\0\x02\
    \x04\x02\x12\x03h\x1d\x1e\n\r\n\x06\x04\n\x04\0\x02\x05\x12\x03i\x10$\n\
    \x0e\n\x07\x04\n\x04\0\x02\x05\x01\x12\x03i\x10\x1f\n\x0e\n\x07\x04\n\
    \x04\0\x02\x05\x02\x12\x03i\"#\n\r\n\x06\x04\n\x04\0\x02\x06\x12\x03j\
    \x10$\n\x0e\n\x07\x04\n\x04\0\x02\x06\x01\x12\x03j\x10\x1f\n\x0e\n\x07\
    \x04\n\x04\0\x02\x06\x02\x12\x03j\"#\n\r\n\x06\x04\n\x04\0\x02\x07\x12\
    \x03k\x10!\n\x0e\n\x07\x04\n\x04\0\x02\x07\x01\x12\x03k\x10\x1c\n\x0e\n\
    \x07\x04\n\x04\0\x02\x07\x02\x12\x03k\x1f\x20\n\r\n\x06\x04\n\x04\0\x02\
    \x08\x12\x03l\x10)\n\x0e\n\x07\x04\n\x04\0\x02\x08\x01\x12\x03l\x10$\n\
    \x0e\n\x07\x04\n\x04\0\x02\x08\x02\x12\x03l'(\n\x0b\n\x04\x04\n\x02\0\
    \x12\x03o\x08X\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03o\x08\x10\n\x0c\n\x05\
    \x04\n\x02\0\x06\x12\x03o\x11L\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03oMS\n\
    \x0c\n\x05\x04\n\x02\0\x03\x12\x03oVW\n\x0b\n\x04\x04\n\x02\x01\x12\x03p\
    \x08?\n\x0c\n\x05\x04\n\x02\x01\x04\x12\x03p\x08\x10\n\x0c\n\x05\x04\n\
    \x02\x01\x06\x12\x03p\x11)\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03p*:\n\
    \x0c\n\x05\x04\n\x02\x01\x03\x12\x03p=>\n\x0b\n\x04\x04\n\x02\x02\x12\
    \x03q\x08:\n\x0c\n\x05\x04\n\x02\x02\x04\x12\x03q\x08\x10\n\x0c\n\x05\
    \x04\n\x02\x02\x06\x12\x03q\x11#\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03q$\
    5\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03q89\n\n\n\x02\x04\x0b\x12\x04t\0w\
    \x01\n\n\n\x03\x04\x0b\x01\x12\x03t\x081\n\x0b\n\x04\x04\x0b\x02\0\x12\
    \x03u\x08%\n\x0c\n\x05\x04\x0b\x02\0\x04\x12\x03u\x08\x10\n\x0c\n\x05\
    \x04\x0b\x02\0\x05\x12\x03u\x11\x17\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\
    \x03u\x18\x20\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03u#$\n\x0b\n\x04\x04\
    \x0b\x02\x01\x12\x03v\x08%\n\x0c\n\x05\x04\x0b\x02\x01\x04\x12\x03v\x08\
    \x10\n\x0c\n\x05\x04\x0b\x02\x01\x06\x12\x03v\x11\x17\n\x0c\n\x05\x04\
    \x0b\x02\x01\x01\x12\x03v\x18\x20\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\
    \x03v#$\n\n\n\x02\x04\x0c\x12\x04y\0~\x01\n\n\n\x03\x04\x0c\x01\x12\x03y\
    \x08)\n\x0b\n\x04\x04\x0c\x02\0\x12\x03z\x08%\n\x0c\n\x05\x04\x0c\x02\0\
    \x04\x12\x03z\x08\x10\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03z\x11\x17\n\
    \x0c\n\x05\x04\x0c\x02\0\x01\x12\x03z\x18\x20\n\x0c\n\x05\x04\x0c\x02\0\
    \x03\x12\x03z#$\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03{\x08%\n\x0c\n\x05\
    \x04\x0c\x02\x01\x04\x12\x03{\x08\x10\n\x0c\n\x05\x04\x0c\x02\x01\x06\
    \x12\x03{\x11\x17\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03{\x18\x20\n\x0c\
    \n\x05\x04\x0c\x02\x01\x03\x12\x03{#$\n\x0b\n\x04\x04\x0c\x02\x02\x12\
    \x03|\x08(\n\x0c\n\x05\x04\x0c\x02\x02\x04\x12\x03|\x08\x10\n\x0c\n\x05\
    \x04\x0c\x02\x02\x05\x12\x03|\x11\x17\n\x0c\n\x05\x04\x0c\x02\x02\x01\
    \x12\x03|\x18#\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03|&'\n\x0b\n\x04\
    \x04\x0c\x02\x03\x12\x03}\x08*\n\x0c\n\x05\x04\x0c\x02\x03\x04\x12\x03}\
    \x08\x10\n\x0c\n\x05\x04\x0c\x02\x03\x05\x12\x03}\x11\x17\n\x0c\n\x05\
    \x04\x0c\x02\x03\x01\x12\x03}\x18%\n\x0c\n\x05\x04\x0c\x02\x03\x03\x12\
    \x03}()\n\x0c\n\x02\x04\r\x12\x06\x80\x01\0\x96\x01\x01\n\x0b\n\x03\x04\
    \r\x01\x12\x04\x80\x01\x081\n\x0e\n\x04\x04\r\x04\0\x12\x06\x81\x01\x08\
    \x93\x01\t\n\r\n\x05\x04\r\x04\0\x01\x12\x04\x81\x01\r\x16\n\x0e\n\x06\
    \x04\r\x04\0\x02\0\x12\x04\x82\x01\x10%\n\x0f\n\x07\x04\r\x04\0\x02\0\
    \x01\x12\x04\x82\x01\x10\x20\n\x0f\n\x07\x04\r\x04\0\x02\0\x02\x12\x04\
    \x82\x01#$\n\x0e\n\x06\x04\r\x04\0\x02\x01\x12\x04\x83\x01\x10\x1f\n\x0f\
    \n\x07\x04\r\x04\0\x02\x01\x01\x12\x04\x83\x01\x10\x1a\n\x0f\n\x07\x04\r\
    \x04\0\x02\x01\x02\x12\x04\x83\x01\x1d\x1e\n\x0e\n\x06\x04\r\x04\0\x02\
    \x02\x12\x04\x84\x01\x10\x1f\n\x0f\n\x07\x04\r\x04\0\x02\x02\x01\x12\x04\
    \x84\x01\x10\x1a\n\x0f\n\x07\x04\r\x04\0\x02\x02\x02\x12\x04\x84\x01\x1d\
    \x1e\n\x0e\n\x06\x04\r\x04\0\x02\x03\x12\x04\x85\x01\x10\x20\n\x0f\n\x07\
    \x04\r\x04\0\x02\x03\x01\x12\x04\x85\x01\x10\x1b\n\x0f\n\x07\x04\r\x04\0\
    \x02\x03\x02\x12\x04\x85\x01\x1e\x1f\n\x0e\n\x06\x04\r\x04\0\x02\x04\x12\
    \x04\x86\x01\x10\x1f\n\x0f\n\x07\x04\r\x04\0\x02\x04\x01\x12\x04\x86\x01\
    \x10\x1a\n\x0f\n\x07\x04\r\x04\0\x02\x04\x02\x12\x04\x86\x01\x1d\x1e\n\
    \x0e\n\x06\x04\r\x04\0\x02\x05\x12\x04\x87\x01\x10$\n\x0f\n\x07\x04\r\
    \x04\0\x02\x05\x01\x12\x04\x87\x01\x10\x1f\n\x0f\n\x07\x04\r\x04\0\x02\
    \x05\x02\x12\x04\x87\x01\"#\n\x0e\n\x06\x04\r\x04\0\x02\x06\x12\x04\x88\
    \x01\x10$\n\x0f\n\x07\x04\r\x04\0\x02\x06\x01\x12\x04\x88\x01\x10\x1f\n\
    \x0f\n\x07\x04\r\x04\0\x02\x06\x02\x12\x04\x88\x01\"#\n\x0e\n\x06\x04\r\
    \x04\0\x02\x07\x12\x04\x89\x01\x10!\n\x0f\n\x07\x04\r\x04\0\x02\x07\x01\
    \x12\x04\x89\x01\x10\x1c\n\x0f\n\x07\x04\r\x04\0\x02\x07\x02\x12\x04\x89\
    \x01\x1f\x20\n\x0e\n\x06\x04\r\x04\0\x02\x08\x12\x04\x8a\x01\x10)\n\x0f\
    \n\x07\x04\r\x04\0\x02\x08\x01\x12\x04\x8a\x01\x10$\n\x0f\n\x07\x04\r\
    \x04\0\x02\x08\x02\x12\x04\x8a\x01'(\n\x0e\n\x06\x04\r\x04\0\x02\t\x12\
    \x04\x8b\x01\x10)\n\x0f\n\x07\x04\r\x04\0\x02\t\x01\x12\x04\x8b\x01\x10$\
    \n\x0f\n\x07\x04\r\x04\0\x02\t\x02\x12\x04\x8b\x01'(\n\x0e\n\x06\x04\r\
    \x04\0\x02\n\x12\x04\x8c\x01\x10(\n\x0f\n\x07\x04\r\x04\0\x02\n\x01\x12\
    \x04\x8c\x01\x10\"\n\x0f\n\x07\x04\r\x04\0\x02\n\x02\x12\x04\x8c\x01%'\n\
    \x0e\n\x06\x04\r\x04\0\x02\x0b\x12\x04\x8d\x01\x10,\n\x0f\n\x07\x04\r\
    \x04\0\x02\x0b\x01\x12\x04\x8d\x01\x10&\n\x0f\n\x07\x04\r\x04\0\x02\x0b\
    \x02\x12\x04\x8d\x01)+\n\x0e\n\x06\x04\r\x04\0\x02\x0c\x12\x04\x8e\x01\
    \x100\n\x0f\n\x07\x04\r\x04\0\x02\x0c\x01\x12\x04\x8e\x01\x10*\n\x0f\n\
    \x07\x04\r\x04\0\x02\x0c\x02\x12\x04\x8e\x01-/\n\x0e\n\x06\x04\r\x04\0\
    \x02\r\x12\x04\x8f\x01\x10-\n\x0f\n\x07\x04\r\x04\0\x02\r\x01\x12\x04\
    \x8f\x01\x10'\n\x0f\n\x07\x04\r\x04\0\x02\r\x02\x12\x04\x8f\x01*,\n\x0e\
    \n\x06\x04\r\x04\0\x02\x0e\x12\x04\x90\x01\x10*\n\x0f\n\x07\x04\r\x04\0\
    \x02\x0e\x01\x12\x04\x90\x01\x10$\n\x0f\n\x07\x04\r\x04\0\x02\x0e\x02\
    \x12\x04\x90\x01')\n\x0e\n\x06\x04\r\x04\0\x02\x0f\x12\x04\x91\x01\x10.\
    \n\x0f\n\x07\x04\r\x04\0\x02\x0f\x01\x12\x04\x91\x01\x10(\n\x0f\n\x07\
    \x04\r\x04\0\x02\x0f\x02\x12\x04\x91\x01+-\n\x0e\n\x06\x04\r\x04\0\x02\
    \x10\x12\x04\x92\x01\x103\n\x0f\n\x07\x04\r\x04\0\x02\x10\x01\x12\x04\
    \x92\x01\x10-\n\x0f\n\x07\x04\r\x04\0\x02\x10\x02\x12\x04\x92\x0102\n\
    \x0c\n\x04\x04\r\x02\0\x12\x04\x95\x01\x08P\n\r\n\x05\x04\r\x02\0\x04\
    \x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\r\x02\0\x06\x12\x04\x95\x01\x11D\
    \n\r\n\x05\x04\r\x02\0\x01\x12\x04\x95\x01EK\n\r\n\x05\x04\r\x02\0\x03\
    \x12\x04\x95\x01NO\n\x0c\n\x02\x04\x0e\x12\x06\x98\x01\0\x9b\x01\x01\n\
    \x0b\n\x03\x04\x0e\x01\x12\x04\x98\x01\x081\n\x0c\n\x04\x04\x0e\x02\0\
    \x12\x04\x99\x01\x08%\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\x99\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x99\x01\x11\x17\n\r\n\x05\x04\
    \x0e\x02\0\x01\x12\x04\x99\x01\x18\x20\n\r\n\x05\x04\x0e\x02\0\x03\x12\
    \x04\x99\x01#$\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x9a\x01\x08%\n\r\n\
    \x05\x04\x0e\x02\x01\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x01\x06\x12\x04\x9a\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\
    \x9a\x01\x18\x20\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x9a\x01#$\n\x0c\n\
    \x02\x04\x0f\x12\x06\x9d\x01\0\xac\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\x9d\x01\x089\n\x0e\n\x04\x04\x0f\x04\0\x12\x06\x9e\x01\x08\xa8\x01\
    \t\n\r\n\x05\x04\x0f\x04\0\x01\x12\x04\x9e\x01\r\x16\n\x0e\n\x06\x04\x0f\
    \x04\0\x02\0\x12\x04\x9f\x01\x10%\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x01\
    \x12\x04\x9f\x01\x10\x20\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x02\x12\x04\x9f\
    \x01#$\n\x0e\n\x06\x04\x0f\x04\0\x02\x01\x12\x04\xa0\x01\x10\x1f\n\x0f\n\
    \x07\x04\x0f\x04\0\x02\x01\x01\x12\x04\xa0\x01\x10\x1a\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\x01\x02\x12\x04\xa0\x01\x1d\x1e\n\x0e\n\x06\x04\x0f\x04\0\
    \x02\x02\x12\x04\xa1\x01\x10\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x02\x01\
    \x12\x04\xa1\x01\x10\x1a\n\x0f\n\x07\x04\x0f\x04\0\x02\x02\x02\x12\x04\
    \xa1\x01\x1d\x1e\n\x0e\n\x06\x04\x0f\x04\0\x02\x03\x12\x04\xa2\x01\x10\
    \x20\n\x0f\n\x07\x04\x0f\x04\0\x02\x03\x01\x12\x04\xa2\x01\x10\x1b\n\x0f\
    \n\x07\x04\x0f\x04\0\x02\x03\x02\x12\x04\xa2\x01\x1e\x1f\n\x0e\n\x06\x04\
    \x0f\x04\0\x02\x04\x12\x04\xa3\x01\x10\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x04\x01\x12\x04\xa3\x01\x10\x1a\n\x0f\n\x07\x04\x0f\x04\0\x02\x04\x02\
    \x12\x04\xa3\x01\x1d\x1e\n\x0e\n\x06\x04\x0f\x04\0\x02\x05\x12\x04\xa4\
    \x01\x10$\n\x0f\n\x07\x04\x0f\x04\0\x02\x05\x01\x12\x04\xa4\x01\x10\x1f\
    \n\x0f\n\x07\x04\x0f\x04\0\x02\x05\x02\x12\x04\xa4\x01\"#\n\x0e\n\x06\
    \x04\x0f\x04\0\x02\x06\x12\x04\xa5\x01\x10$\n\x0f\n\x07\x04\x0f\x04\0\
    \x02\x06\x01\x12\x04\xa5\x01\x10\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x06\
    \x02\x12\x04\xa5\x01\"#\n\x0e\n\x06\x04\x0f\x04\0\x02\x07\x12\x04\xa6\
    \x01\x10!\n\x0f\n\x07\x04\x0f\x04\0\x02\x07\x01\x12\x04\xa6\x01\x10\x1c\
    \n\x0f\n\x07\x04\x0f\x04\0\x02\x07\x02\x12\x04\xa6\x01\x1f\x20\n\x0e\n\
    \x06\x04\x0f\x04\0\x02\x08\x12\x04\xa7\x01\x10)\n\x0f\n\x07\x04\x0f\x04\
    \0\x02\x08\x01\x12\x04\xa7\x01\x10$\n\x0f\n\x07\x04\x0f\x04\0\x02\x08\
    \x02\x12\x04\xa7\x01'(\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xaa\x01\x08X\n\
    \r\n\x05\x04\x0f\x02\0\x04\x12\x04\xaa\x01\x08\x10\n\r\n\x05\x04\x0f\x02\
    \0\x06\x12\x04\xaa\x01\x11L\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xaa\x01M\
    S\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xaa\x01VW\n\x0c\n\x04\x04\x0f\x02\
    \x01\x12\x04\xab\x01\x089\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xab\x01\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\xab\x01\x11#\n\r\n\x05\
    \x04\x0f\x02\x01\x01\x12\x04\xab\x01$4\n\r\n\x05\x04\x0f\x02\x01\x03\x12\
    \x04\xab\x0178\n\x0c\n\x02\x04\x10\x12\x06\xae\x01\0\xb2\x01\x01\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\xae\x01\x081\n\x0c\n\x04\x04\x10\x02\0\x12\x04\
    \xaf\x01\x08%\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xaf\x01\x08\x10\n\r\n\
    \x05\x04\x10\x02\0\x05\x12\x04\xaf\x01\x11\x17\n\r\n\x05\x04\x10\x02\0\
    \x01\x12\x04\xaf\x01\x18\x20\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xaf\x01\
    #$\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xb0\x01\x08%\n\r\n\x05\x04\x10\
    \x02\x01\x04\x12\x04\xb0\x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\x06\x12\
    \x04\xb0\x01\x11\x17\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xb0\x01\x18\
    \x20\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xb0\x01#$\n\x0c\n\x04\x04\x10\
    \x02\x02\x12\x04\xb1\x01\x089\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xb1\
    \x01\x08\x10\n\r\n\x05\x04\x10\x02\x02\x06\x12\x04\xb1\x01\x11#\n\r\n\
    \x05\x04\x10\x02\x02\x01\x12\x04\xb1\x01$4\n\r\n\x05\x04\x10\x02\x02\x03\
    \x12\x04\xb1\x0178\n\x0c\n\x02\x04\x11\x12\x06\xb4\x01\0\xb7\x01\x01\n\
    \x0b\n\x03\x04\x11\x01\x12\x04\xb4\x01\x08.\n\x0c\n\x04\x04\x11\x02\0\
    \x12\x04\xb5\x01\x08%\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xb5\x01\x08\
    \x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\
    \x11\x02\0\x01\x12\x04\xb5\x01\x18\x20\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\xb5\x01#$\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xb6\x01\x08%\n\r\n\
    \x05\x04\x11\x02\x01\x04\x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\x11\x02\
    \x01\x06\x12\x04\xb6\x01\x11\x17\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\
    \xb6\x01\x18\x20\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xb6\x01#$\n\x0c\n\
    \x02\x04\x12\x12\x06\xb9\x01\0\xc8\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xb9\x01\x086\n\x0e\n\x04\x04\x12\x04\0\x12\x06\xba\x01\x08\xc4\x01\
    \t\n\r\n\x05\x04\x12\x04\0\x01\x12\x04\xba\x01\r\x16\n\x0e\n\x06\x04\x12\
    \x04\0\x02\0\x12\x04\xbb\x01\x10%\n\x0f\n\x07\x04\x12\x04\0\x02\0\x01\
    \x12\x04\xbb\x01\x10\x20\n\x0f\n\x07\x04\x12\x04\0\x02\0\x02\x12\x04\xbb\
    \x01#$\n\x0e\n\x06\x04\x12\x04\0\x02\x01\x12\x04\xbc\x01\x10\x1f\n\x0f\n\
    \x07\x04\x12\x04\0\x02\x01\x01\x12\x04\xbc\x01\x10\x1a\n\x0f\n\x07\x04\
    \x12\x04\0\x02\x01\x02\x12\x04\xbc\x01\x1d\x1e\n\x0e\n\x06\x04\x12\x04\0\
    \x02\x02\x12\x04\xbd\x01\x10\x1f\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x01\
    \x12\x04\xbd\x01\x10\x1a\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x02\x12\x04\
    \xbd\x01\x1d\x1e\n\x0e\n\x06\x04\x12\x04\0\x02\x03\x12\x04\xbe\x01\x10\
    \x20\n\x0f\n\x07\x04\x12\x04\0\x02\x03\x01\x12\x04\xbe\x01\x10\x1b\n\x0f\
    \n\x07\x04\x12\x04\0\x02\x03\x02\x12\x04\xbe\x01\x1e\x1f\n\x0e\n\x06\x04\
    \x12\x04\0\x02\x04\x12\x04\xbf\x01\x10\x1f\n\x0f\n\x07\x04\x12\x04\0\x02\
    \x04\x01\x12\x04\xbf\x01\x10\x1a\n\x0f\n\x07\x04\x12\x04\0\x02\x04\x02\
    \x12\x04\xbf\x01\x1d\x1e\n\x0e\n\x06\x04\x12\x04\0\x02\x05\x12\x04\xc0\
    \x01\x10$\n\x0f\n\x07\x04\x12\x04\0\x02\x05\x01\x12\x04\xc0\x01\x10\x1f\
    \n\x0f\n\x07\x04\x12\x04\0\x02\x05\x02\x12\x04\xc0\x01\"#\n\x0e\n\x06\
    \x04\x12\x04\0\x02\x06\x12\x04\xc1\x01\x10$\n\x0f\n\x07\x04\x12\x04\0\
    \x02\x06\x01\x12\x04\xc1\x01\x10\x1f\n\x0f\n\x07\x04\x12\x04\0\x02\x06\
    \x02\x12\x04\xc1\x01\"#\n\x0e\n\x06\x04\x12\x04\0\x02\x07\x12\x04\xc2\
    \x01\x10!\n\x0f\n\x07\x04\x12\x04\0\x02\x07\x01\x12\x04\xc2\x01\x10\x1c\
    \n\x0f\n\x07\x04\x12\x04\0\x02\x07\x02\x12\x04\xc2\x01\x1f\x20\n\x0e\n\
    \x06\x04\x12\x04\0\x02\x08\x12\x04\xc3\x01\x10)\n\x0f\n\x07\x04\x12\x04\
    \0\x02\x08\x01\x12\x04\xc3\x01\x10$\n\x0f\n\x07\x04\x12\x04\0\x02\x08\
    \x02\x12\x04\xc3\x01'(\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xc6\x01\x08U\n\
    \r\n\x05\x04\x12\x02\0\x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\x12\x02\
    \0\x06\x12\x04\xc6\x01\x11I\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xc6\x01J\
    P\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xc6\x01ST\n\x0c\n\x04\x04\x12\x02\
    \x01\x12\x04\xc7\x01\x082\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xc7\x01\
    \x08\x10\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xc7\x01\x11%\n\r\n\x05\
    \x04\x12\x02\x01\x01\x12\x04\xc7\x01&-\n\r\n\x05\x04\x12\x02\x01\x03\x12\
    \x04\xc7\x0101\n\x0c\n\x02\x04\x13\x12\x06\xca\x01\0\xd3\x01\x01\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xca\x01\x08,\n\x0c\n\x04\x04\x13\x02\0\x12\x04\
    \xcb\x01\x08%\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xcb\x01\x08\x10\n\r\n\
    \x05\x04\x13\x02\0\x06\x12\x04\xcb\x01\x11\x17\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xcb\x01\x18\x20\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xcb\x01\
    #$\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xcc\x01\x08#\n\r\n\x05\x04\x13\
    \x02\x01\x04\x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\x13\x02\x01\x05\x12\
    \x04\xcc\x01\x11\x17\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xcc\x01\x18\
    \x1e\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xcc\x01!\"\n\x0c\n\x04\x04\
    \x13\x02\x02\x12\x04\xcd\x01\x08)\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\
    \xcd\x01\x08\x10\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xcd\x01\x11\x17\n\
    \r\n\x05\x04\x13\x02\x02\x01\x12\x04\xcd\x01\x18$\n\r\n\x05\x04\x13\x02\
    \x02\x03\x12\x04\xcd\x01'(\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\xce\x01\
    \x08%\n\r\n\x05\x04\x13\x02\x03\x04\x12\x04\xce\x01\x08\x10\n\r\n\x05\
    \x04\x13\x02\x03\x05\x12\x04\xce\x01\x11\x17\n\r\n\x05\x04\x13\x02\x03\
    \x01\x12\x04\xce\x01\x18\x20\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xce\
    \x01#$\n\x0c\n\x04\x04\x13\x02\x04\x12\x04\xcf\x01\x08!\n\r\n\x05\x04\
    \x13\x02\x04\x04\x12\x04\xcf\x01\x08\x10\n\r\n\x05\x04\x13\x02\x04\x05\
    \x12\x04\xcf\x01\x11\x17\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\xcf\x01\
    \x18\x1c\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xcf\x01\x1f\x20\n\x0c\n\
    \x04\x04\x13\x02\x05\x12\x04\xd0\x01\x08/\n\r\n\x05\x04\x13\x02\x05\x04\
    \x12\x04\xd0\x01\x08\x10\n\r\n\x05\x04\x13\x02\x05\x05\x12\x04\xd0\x01\
    \x11\x17\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\xd0\x01\x18*\n\r\n\x05\
    \x04\x13\x02\x05\x03\x12\x04\xd0\x01-.\n\x0c\n\x04\x04\x13\x02\x06\x12\
    \x04\xd1\x01\x08.\n\r\n\x05\x04\x13\x02\x06\x04\x12\x04\xd1\x01\x08\x10\
    \n\r\n\x05\x04\x13\x02\x06\x05\x12\x04\xd1\x01\x11\x17\n\r\n\x05\x04\x13\
    \x02\x06\x01\x12\x04\xd1\x01\x18)\n\r\n\x05\x04\x13\x02\x06\x03\x12\x04\
    \xd1\x01,-\n\x0c\n\x04\x04\x13\x02\x07\x12\x04\xd2\x01\x08#\n\r\n\x05\
    \x04\x13\x02\x07\x04\x12\x04\xd2\x01\x08\x10\n\r\n\x05\x04\x13\x02\x07\
    \x05\x12\x04\xd2\x01\x11\x17\n\r\n\x05\x04\x13\x02\x07\x01\x12\x04\xd2\
    \x01\x18\x1e\n\r\n\x05\x04\x13\x02\x07\x03\x12\x04\xd2\x01!\"\n\x0c\n\
    \x02\x04\x14\x12\x06\xd5\x01\0\xd8\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\
    \x04\xd5\x01\x08-\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xd6\x01\x08%\n\r\n\
    \x05\x04\x14\x02\0\x04\x12\x04\xd6\x01\x08\x10\n\r\n\x05\x04\x14\x02\0\
    \x05\x12\x04\xd6\x01\x11\x17\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xd6\x01\
    \x18\x20\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xd6\x01#$\n\x0c\n\x04\x04\
    \x14\x02\x01\x12\x04\xd7\x01\x08%\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\
    \xd7\x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\xd7\x01\x11\x17\n\
    \r\n\x05\x04\x14\x02\x01\x01\x12\x04\xd7\x01\x18\x20\n\r\n\x05\x04\x14\
    \x02\x01\x03\x12\x04\xd7\x01#$\n\x0c\n\x02\x04\x15\x12\x06\xda\x01\0\xeb\
    \x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xda\x01\x085\n\x0e\n\x04\x04\
    \x15\x04\0\x12\x06\xdb\x01\x08\xe7\x01\t\n\r\n\x05\x04\x15\x04\0\x01\x12\
    \x04\xdb\x01\r\x16\n\x0e\n\x06\x04\x15\x04\0\x02\0\x12\x04\xdc\x01\x10%\
    \n\x0f\n\x07\x04\x15\x04\0\x02\0\x01\x12\x04\xdc\x01\x10\x20\n\x0f\n\x07\
    \x04\x15\x04\0\x02\0\x02\x12\x04\xdc\x01#$\n\x0e\n\x06\x04\x15\x04\0\x02\
    \x01\x12\x04\xdd\x01\x10\x1f\n\x0f\n\x07\x04\x15\x04\0\x02\x01\x01\x12\
    \x04\xdd\x01\x10\x1a\n\x0f\n\x07\x04\x15\x04\0\x02\x01\x02\x12\x04\xdd\
    \x01\x1d\x1e\n\x0e\n\x06\x04\x15\x04\0\x02\x02\x12\x04\xde\x01\x10\x1f\n\
    \x0f\n\x07\x04\x15\x04\0\x02\x02\x01\x12\x04\xde\x01\x10\x1a\n\x0f\n\x07\
    \x04\x15\x04\0\x02\x02\x02\x12\x04\xde\x01\x1d\x1e\n\x0e\n\x06\x04\x15\
    \x04\0\x02\x03\x12\x04\xdf\x01\x10\x20\n\x0f\n\x07\x04\x15\x04\0\x02\x03\
    \x01\x12\x04\xdf\x01\x10\x1b\n\x0f\n\x07\x04\x15\x04\0\x02\x03\x02\x12\
    \x04\xdf\x01\x1e\x1f\n\x0e\n\x06\x04\x15\x04\0\x02\x04\x12\x04\xe0\x01\
    \x10\x1f\n\x0f\n\x07\x04\x15\x04\0\x02\x04\x01\x12\x04\xe0\x01\x10\x1a\n\
    \x0f\n\x07\x04\x15\x04\0\x02\x04\x02\x12\x04\xe0\x01\x1d\x1e\n\x0e\n\x06\
    \x04\x15\x04\0\x02\x05\x12\x04\xe1\x01\x10$\n\x0f\n\x07\x04\x15\x04\0\
    \x02\x05\x01\x12\x04\xe1\x01\x10\x1f\n\x0f\n\x07\x04\x15\x04\0\x02\x05\
    \x02\x12\x04\xe1\x01\"#\n\x0e\n\x06\x04\x15\x04\0\x02\x06\x12\x04\xe2\
    \x01\x10$\n\x0f\n\x07\x04\x15\x04\0\x02\x06\x01\x12\x04\xe2\x01\x10\x1f\
    \n\x0f\n\x07\x04\x15\x04\0\x02\x06\x02\x12\x04\xe2\x01\"#\n\x0e\n\x06\
    \x04\x15\x04\0\x02\x07\x12\x04\xe3\x01\x10!\n\x0f\n\x07\x04\x15\x04\0\
    \x02\x07\x01\x12\x04\xe3\x01\x10\x1c\n\x0f\n\x07\x04\x15\x04\0\x02\x07\
    \x02\x12\x04\xe3\x01\x1f\x20\n\x0e\n\x06\x04\x15\x04\0\x02\x08\x12\x04\
    \xe4\x01\x10)\n\x0f\n\x07\x04\x15\x04\0\x02\x08\x01\x12\x04\xe4\x01\x10$\
    \n\x0f\n\x07\x04\x15\x04\0\x02\x08\x02\x12\x04\xe4\x01'(\n\x0e\n\x06\x04\
    \x15\x04\0\x02\t\x12\x04\xe5\x01\x10&\n\x0f\n\x07\x04\x15\x04\0\x02\t\
    \x01\x12\x04\xe5\x01\x10!\n\x0f\n\x07\x04\x15\x04\0\x02\t\x02\x12\x04\
    \xe5\x01$%\n\x0e\n\x06\x04\x15\x04\0\x02\n\x12\x04\xe6\x01\x10'\n\x0f\n\
    \x07\x04\x15\x04\0\x02\n\x01\x12\x04\xe6\x01\x10!\n\x0f\n\x07\x04\x15\
    \x04\0\x02\n\x02\x12\x04\xe6\x01$&\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xe9\
    \x01\x08T\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\
    \x04\x15\x02\0\x06\x12\x04\xe9\x01\x11H\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\xe9\x01IO\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xe9\x01RS\n\x0c\n\x04\
    \x04\x15\x02\x01\x12\x04\xea\x01\x08)\n\r\n\x05\x04\x15\x02\x01\x04\x12\
    \x04\xea\x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xea\x01\x11\
    \x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xea\x01\x18$\n\r\n\x05\x04\
    \x15\x02\x01\x03\x12\x04\xea\x01'(\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(22);
            messages.push(CMsgGuildContract::generated_message_descriptor_data());
            messages.push(CMsgGuildContractSlot::generated_message_descriptor_data());
            messages.push(CMsgAccountGuildEventData::generated_message_descriptor_data());
            messages.push(CMsgGuildActiveContracts::generated_message_descriptor_data());
            messages.push(CMsgGuildChallenge::generated_message_descriptor_data());
            messages.push(CMsgGuildEventMember::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestAccountGuildEventData::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestAccountGuildEventDataResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientAccountGuildEventDataUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestActiveGuildContracts::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestActiveGuildContractsResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientActiveGuildContractsUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSelectGuildContract::generated_message_descriptor_data());
            messages.push(CMsgClientToGCSelectGuildContractResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestActiveGuildChallenge::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestActiveGuildChallengeResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToClientActiveGuildChallengeUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestGuildEventMembers::generated_message_descriptor_data());
            messages.push(CMsgClientToGCRequestGuildEventMembersResponse::generated_message_descriptor_data());
            messages.push(CMsgGuildLeaderboardCombinedResponse::generated_message_descriptor_data());
            messages.push(CMsgClientToGCClaimLeaderboardRewards::generated_message_descriptor_data());
            messages.push(CMsgClientToGCClaimLeaderboardRewardsResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(7);
            enums.push(EGuildEventAuditAction::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcselect_guild_contract_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcrequest_guild_event_members_response::EResponse::generated_enum_descriptor_data());
            enums.push(cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
