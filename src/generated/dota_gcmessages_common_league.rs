// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_common_league.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueNode {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.node_id)
    pub node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.node_group_id)
    pub node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.winning_node_id)
    pub winning_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.losing_node_id)
    pub losing_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.incoming_node_id_1)
    pub incoming_node_id_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.incoming_node_id_2)
    pub incoming_node_id_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.node_type)
    pub node_type: ::std::option::Option<::protobuf::EnumOrUnknown<ELeagueNodeType>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.scheduled_time)
    pub scheduled_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.actual_time)
    pub actual_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.series_id)
    pub series_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.team_id_1)
    pub team_id_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.team_id_2)
    pub team_id_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.matches)
    pub matches: ::std::vec::Vec<cmsg_dotaleague_node::MatchDetails>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.team_1_wins)
    pub team_1_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.team_2_wins)
    pub team_2_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.has_started)
    pub has_started: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.is_completed)
    pub is_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.stream_ids)
    pub stream_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.vods)
    pub vods: ::std::vec::Vec<cmsg_dotaleague_node::VOD>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueNode {
    fn default() -> &'a CMsgDOTALeagueNode {
        <CMsgDOTALeagueNode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueNode {
    pub fn new() -> CMsgDOTALeagueNode {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 node_id = 2;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 node_group_id = 3;

    pub fn node_group_id(&self) -> u32 {
        self.node_group_id.unwrap_or(0)
    }

    pub fn clear_node_group_id(&mut self) {
        self.node_group_id = ::std::option::Option::None;
    }

    pub fn has_node_group_id(&self) -> bool {
        self.node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_group_id(&mut self, v: u32) {
        self.node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_node_id = 4;

    pub fn winning_node_id(&self) -> u32 {
        self.winning_node_id.unwrap_or(0)
    }

    pub fn clear_winning_node_id(&mut self) {
        self.winning_node_id = ::std::option::Option::None;
    }

    pub fn has_winning_node_id(&self) -> bool {
        self.winning_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_node_id(&mut self, v: u32) {
        self.winning_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 losing_node_id = 5;

    pub fn losing_node_id(&self) -> u32 {
        self.losing_node_id.unwrap_or(0)
    }

    pub fn clear_losing_node_id(&mut self) {
        self.losing_node_id = ::std::option::Option::None;
    }

    pub fn has_losing_node_id(&self) -> bool {
        self.losing_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losing_node_id(&mut self, v: u32) {
        self.losing_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 incoming_node_id_1 = 6;

    pub fn incoming_node_id_1(&self) -> u32 {
        self.incoming_node_id_1.unwrap_or(0)
    }

    pub fn clear_incoming_node_id_1(&mut self) {
        self.incoming_node_id_1 = ::std::option::Option::None;
    }

    pub fn has_incoming_node_id_1(&self) -> bool {
        self.incoming_node_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incoming_node_id_1(&mut self, v: u32) {
        self.incoming_node_id_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 incoming_node_id_2 = 7;

    pub fn incoming_node_id_2(&self) -> u32 {
        self.incoming_node_id_2.unwrap_or(0)
    }

    pub fn clear_incoming_node_id_2(&mut self) {
        self.incoming_node_id_2 = ::std::option::Option::None;
    }

    pub fn has_incoming_node_id_2(&self) -> bool {
        self.incoming_node_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incoming_node_id_2(&mut self, v: u32) {
        self.incoming_node_id_2 = ::std::option::Option::Some(v);
    }

    // optional .dota.ELeagueNodeType node_type = 8;

    pub fn node_type(&self) -> ELeagueNodeType {
        match self.node_type {
            Some(e) => e.enum_value_or(ELeagueNodeType::INVALID_NODE_TYPE),
            None => ELeagueNodeType::INVALID_NODE_TYPE,
        }
    }

    pub fn clear_node_type(&mut self) {
        self.node_type = ::std::option::Option::None;
    }

    pub fn has_node_type(&self) -> bool {
        self.node_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_type(&mut self, v: ELeagueNodeType) {
        self.node_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 scheduled_time = 9;

    pub fn scheduled_time(&self) -> u32 {
        self.scheduled_time.unwrap_or(0)
    }

    pub fn clear_scheduled_time(&mut self) {
        self.scheduled_time = ::std::option::Option::None;
    }

    pub fn has_scheduled_time(&self) -> bool {
        self.scheduled_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduled_time(&mut self, v: u32) {
        self.scheduled_time = ::std::option::Option::Some(v);
    }

    // optional uint32 actual_time = 19;

    pub fn actual_time(&self) -> u32 {
        self.actual_time.unwrap_or(0)
    }

    pub fn clear_actual_time(&mut self) {
        self.actual_time = ::std::option::Option::None;
    }

    pub fn has_actual_time(&self) -> bool {
        self.actual_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actual_time(&mut self, v: u32) {
        self.actual_time = ::std::option::Option::Some(v);
    }

    // optional uint32 series_id = 10;

    pub fn series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id_1 = 11;

    pub fn team_id_1(&self) -> u32 {
        self.team_id_1.unwrap_or(0)
    }

    pub fn clear_team_id_1(&mut self) {
        self.team_id_1 = ::std::option::Option::None;
    }

    pub fn has_team_id_1(&self) -> bool {
        self.team_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_1(&mut self, v: u32) {
        self.team_id_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id_2 = 12;

    pub fn team_id_2(&self) -> u32 {
        self.team_id_2.unwrap_or(0)
    }

    pub fn clear_team_id_2(&mut self) {
        self.team_id_2 = ::std::option::Option::None;
    }

    pub fn has_team_id_2(&self) -> bool {
        self.team_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_2(&mut self, v: u32) {
        self.team_id_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 team_1_wins = 14;

    pub fn team_1_wins(&self) -> u32 {
        self.team_1_wins.unwrap_or(0)
    }

    pub fn clear_team_1_wins(&mut self) {
        self.team_1_wins = ::std::option::Option::None;
    }

    pub fn has_team_1_wins(&self) -> bool {
        self.team_1_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_1_wins(&mut self, v: u32) {
        self.team_1_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 team_2_wins = 15;

    pub fn team_2_wins(&self) -> u32 {
        self.team_2_wins.unwrap_or(0)
    }

    pub fn clear_team_2_wins(&mut self) {
        self.team_2_wins = ::std::option::Option::None;
    }

    pub fn has_team_2_wins(&self) -> bool {
        self.team_2_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_2_wins(&mut self, v: u32) {
        self.team_2_wins = ::std::option::Option::Some(v);
    }

    // optional bool has_started = 16;

    pub fn has_started(&self) -> bool {
        self.has_started.unwrap_or(false)
    }

    pub fn clear_has_started(&mut self) {
        self.has_started = ::std::option::Option::None;
    }

    pub fn has_has_started(&self) -> bool {
        self.has_started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_started(&mut self, v: bool) {
        self.has_started = ::std::option::Option::Some(v);
    }

    // optional bool is_completed = 17;

    pub fn is_completed(&self) -> bool {
        self.is_completed.unwrap_or(false)
    }

    pub fn clear_is_completed(&mut self) {
        self.is_completed = ::std::option::Option::None;
    }

    pub fn has_is_completed(&self) -> bool {
        self.is_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_completed(&mut self, v: bool) {
        self.is_completed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgDOTALeagueNode| { &m.name },
            |m: &mut CMsgDOTALeagueNode| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_id",
            |m: &CMsgDOTALeagueNode| { &m.node_id },
            |m: &mut CMsgDOTALeagueNode| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_group_id",
            |m: &CMsgDOTALeagueNode| { &m.node_group_id },
            |m: &mut CMsgDOTALeagueNode| { &mut m.node_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "winning_node_id",
            |m: &CMsgDOTALeagueNode| { &m.winning_node_id },
            |m: &mut CMsgDOTALeagueNode| { &mut m.winning_node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "losing_node_id",
            |m: &CMsgDOTALeagueNode| { &m.losing_node_id },
            |m: &mut CMsgDOTALeagueNode| { &mut m.losing_node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "incoming_node_id_1",
            |m: &CMsgDOTALeagueNode| { &m.incoming_node_id_1 },
            |m: &mut CMsgDOTALeagueNode| { &mut m.incoming_node_id_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "incoming_node_id_2",
            |m: &CMsgDOTALeagueNode| { &m.incoming_node_id_2 },
            |m: &mut CMsgDOTALeagueNode| { &mut m.incoming_node_id_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_type",
            |m: &CMsgDOTALeagueNode| { &m.node_type },
            |m: &mut CMsgDOTALeagueNode| { &mut m.node_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scheduled_time",
            |m: &CMsgDOTALeagueNode| { &m.scheduled_time },
            |m: &mut CMsgDOTALeagueNode| { &mut m.scheduled_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actual_time",
            |m: &CMsgDOTALeagueNode| { &m.actual_time },
            |m: &mut CMsgDOTALeagueNode| { &mut m.actual_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "series_id",
            |m: &CMsgDOTALeagueNode| { &m.series_id },
            |m: &mut CMsgDOTALeagueNode| { &mut m.series_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_1",
            |m: &CMsgDOTALeagueNode| { &m.team_id_1 },
            |m: &mut CMsgDOTALeagueNode| { &mut m.team_id_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_2",
            |m: &CMsgDOTALeagueNode| { &m.team_id_2 },
            |m: &mut CMsgDOTALeagueNode| { &mut m.team_id_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &CMsgDOTALeagueNode| { &m.matches },
            |m: &mut CMsgDOTALeagueNode| { &mut m.matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_1_wins",
            |m: &CMsgDOTALeagueNode| { &m.team_1_wins },
            |m: &mut CMsgDOTALeagueNode| { &mut m.team_1_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_2_wins",
            |m: &CMsgDOTALeagueNode| { &m.team_2_wins },
            |m: &mut CMsgDOTALeagueNode| { &mut m.team_2_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_started",
            |m: &CMsgDOTALeagueNode| { &m.has_started },
            |m: &mut CMsgDOTALeagueNode| { &mut m.has_started },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_completed",
            |m: &CMsgDOTALeagueNode| { &m.is_completed },
            |m: &mut CMsgDOTALeagueNode| { &mut m.is_completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stream_ids",
            |m: &CMsgDOTALeagueNode| { &m.stream_ids },
            |m: &mut CMsgDOTALeagueNode| { &mut m.stream_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vods",
            |m: &CMsgDOTALeagueNode| { &m.vods },
            |m: &mut CMsgDOTALeagueNode| { &mut m.vods },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueNode>(
            "CMsgDOTALeagueNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueNode {
    const NAME: &'static str = "CMsgDOTALeagueNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.winning_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.losing_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.incoming_node_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.incoming_node_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.node_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.scheduled_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.actual_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.team_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.team_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.matches.push(is.read_message()?);
                },
                112 => {
                    self.team_1_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.team_2_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.has_started = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.is_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    is.read_repeated_packed_uint32_into(&mut self.stream_ids)?;
                },
                144 => {
                    self.stream_ids.push(is.read_uint32()?);
                },
                162 => {
                    self.vods.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.node_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.node_group_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.winning_node_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.losing_node_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.incoming_node_id_1 {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.incoming_node_id_2 {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.node_type {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.scheduled_time {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.actual_time {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.team_id_1 {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.team_id_2 {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.team_1_wins {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.team_2_wins {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.has_started {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_completed {
            my_size += 2 + 1;
        }
        for value in &self.stream_ids {
            my_size += ::protobuf::rt::uint32_size(18, *value);
        };
        for value in &self.vods {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.node_group_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.winning_node_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.losing_node_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.incoming_node_id_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.incoming_node_id_2 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.node_type {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.scheduled_time {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.actual_time {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.team_id_1 {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.team_id_2 {
            os.write_uint32(12, v)?;
        }
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.team_1_wins {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.team_2_wins {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.has_started {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.is_completed {
            os.write_bool(17, v)?;
        }
        for v in &self.stream_ids {
            os.write_uint32(18, *v)?;
        };
        for v in &self.vods {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueNode {
        CMsgDOTALeagueNode::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.node_id = ::std::option::Option::None;
        self.node_group_id = ::std::option::Option::None;
        self.winning_node_id = ::std::option::Option::None;
        self.losing_node_id = ::std::option::Option::None;
        self.incoming_node_id_1 = ::std::option::Option::None;
        self.incoming_node_id_2 = ::std::option::Option::None;
        self.node_type = ::std::option::Option::None;
        self.scheduled_time = ::std::option::Option::None;
        self.actual_time = ::std::option::Option::None;
        self.series_id = ::std::option::Option::None;
        self.team_id_1 = ::std::option::Option::None;
        self.team_id_2 = ::std::option::Option::None;
        self.matches.clear();
        self.team_1_wins = ::std::option::Option::None;
        self.team_2_wins = ::std::option::Option::None;
        self.has_started = ::std::option::Option::None;
        self.is_completed = ::std::option::Option::None;
        self.stream_ids.clear();
        self.vods.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueNode {
        static instance: CMsgDOTALeagueNode = CMsgDOTALeagueNode {
            name: ::std::option::Option::None,
            node_id: ::std::option::Option::None,
            node_group_id: ::std::option::Option::None,
            winning_node_id: ::std::option::Option::None,
            losing_node_id: ::std::option::Option::None,
            incoming_node_id_1: ::std::option::Option::None,
            incoming_node_id_2: ::std::option::Option::None,
            node_type: ::std::option::Option::None,
            scheduled_time: ::std::option::Option::None,
            actual_time: ::std::option::Option::None,
            series_id: ::std::option::Option::None,
            team_id_1: ::std::option::Option::None,
            team_id_2: ::std::option::Option::None,
            matches: ::std::vec::Vec::new(),
            team_1_wins: ::std::option::Option::None,
            team_2_wins: ::std::option::Option::None,
            has_started: ::std::option::Option::None,
            is_completed: ::std::option::Option::None,
            stream_ids: ::std::vec::Vec::new(),
            vods: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTALeagueNode`
pub mod cmsg_dotaleague_node {
    // @@protoc_insertion_point(message:dota.CMsgDOTALeagueNode.MatchDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchDetails {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.MatchDetails.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.MatchDetails.winning_team_id)
        pub winning_team_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueNode.MatchDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchDetails {
        fn default() -> &'a MatchDetails {
            <MatchDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl MatchDetails {
        pub fn new() -> MatchDetails {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 winning_team_id = 2;

        pub fn winning_team_id(&self) -> u32 {
            self.winning_team_id.unwrap_or(0)
        }

        pub fn clear_winning_team_id(&mut self) {
            self.winning_team_id = ::std::option::Option::None;
        }

        pub fn has_winning_team_id(&self) -> bool {
            self.winning_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_winning_team_id(&mut self, v: u32) {
            self.winning_team_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &MatchDetails| { &m.match_id },
                |m: &mut MatchDetails| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "winning_team_id",
                |m: &MatchDetails| { &m.winning_team_id },
                |m: &mut MatchDetails| { &mut m.winning_team_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchDetails>(
                "CMsgDOTALeagueNode.MatchDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MatchDetails {
        const NAME: &'static str = "MatchDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.winning_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.winning_team_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.winning_team_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchDetails {
            MatchDetails::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.winning_team_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchDetails {
            static instance: MatchDetails = MatchDetails {
                match_id: ::std::option::Option::None,
                winning_team_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MatchDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeagueNode.MatchDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MatchDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MatchDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTALeagueNode.VOD)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct VOD {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.VOD.series_game)
        pub series_game: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.VOD.stream_id)
        pub stream_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNode.VOD.url)
        pub url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueNode.VOD.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a VOD {
        fn default() -> &'a VOD {
            <VOD as ::protobuf::Message>::default_instance()
        }
    }

    impl VOD {
        pub fn new() -> VOD {
            ::std::default::Default::default()
        }

        // optional uint32 series_game = 1;

        pub fn series_game(&self) -> u32 {
            self.series_game.unwrap_or(0)
        }

        pub fn clear_series_game(&mut self) {
            self.series_game = ::std::option::Option::None;
        }

        pub fn has_series_game(&self) -> bool {
            self.series_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_game(&mut self, v: u32) {
            self.series_game = ::std::option::Option::Some(v);
        }

        // optional uint32 stream_id = 2;

        pub fn stream_id(&self) -> u32 {
            self.stream_id.unwrap_or(0)
        }

        pub fn clear_stream_id(&mut self) {
            self.stream_id = ::std::option::Option::None;
        }

        pub fn has_stream_id(&self) -> bool {
            self.stream_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stream_id(&mut self, v: u32) {
            self.stream_id = ::std::option::Option::Some(v);
        }

        // optional string url = 3;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "series_game",
                |m: &VOD| { &m.series_game },
                |m: &mut VOD| { &mut m.series_game },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stream_id",
                |m: &VOD| { &m.stream_id },
                |m: &mut VOD| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "url",
                |m: &VOD| { &m.url },
                |m: &mut VOD| { &mut m.url },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VOD>(
                "CMsgDOTALeagueNode.VOD",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for VOD {
        const NAME: &'static str = "VOD";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.series_game = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stream_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.series_game {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stream_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.series_game {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stream_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> VOD {
            VOD::new()
        }

        fn clear(&mut self) {
            self.series_game = ::std::option::Option::None;
            self.stream_id = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static VOD {
            static instance: VOD = VOD {
                series_game: ::std::option::Option::None,
                stream_id: ::std::option::Option::None,
                url: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for VOD {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeagueNode.VOD").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for VOD {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for VOD {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueNodeGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueNodeGroup {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.node_group_id)
    pub node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.parent_node_group_id)
    pub parent_node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
    pub incoming_node_group_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.advancing_node_group_id)
    pub advancing_node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.advancing_team_count)
    pub advancing_team_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.team_count)
    pub team_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.node_group_type)
    pub node_group_type: ::std::option::Option<::protobuf::EnumOrUnknown<ELeagueNodeGroupType>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.default_node_type)
    pub default_node_type: ::std::option::Option<::protobuf::EnumOrUnknown<ELeagueNodeType>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.round)
    pub round: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.max_rounds)
    pub max_rounds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.is_tiebreaker)
    pub is_tiebreaker: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.is_final_group)
    pub is_final_group: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.is_completed)
    pub is_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.phase)
    pub phase: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::ELeaguePhase>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.region)
    pub region: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::ELeagueRegion>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.end_time)
    pub end_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.secondary_advancing_node_group_id)
    pub secondary_advancing_node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.secondary_advancing_team_count)
    pub secondary_advancing_team_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.tertiary_advancing_node_group_id)
    pub tertiary_advancing_node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.tertiary_advancing_team_count)
    pub tertiary_advancing_team_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.elimination_dpc_points)
    pub elimination_dpc_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.team_standings)
    pub team_standings: ::std::vec::Vec<cmsg_dotaleague_node_group::TeamStanding>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.nodes)
    pub nodes: ::std::vec::Vec<CMsgDOTALeagueNode>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.node_groups)
    pub node_groups: ::std::vec::Vec<CMsgDOTALeagueNodeGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueNodeGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueNodeGroup {
    fn default() -> &'a CMsgDOTALeagueNodeGroup {
        <CMsgDOTALeagueNodeGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueNodeGroup {
    pub fn new() -> CMsgDOTALeagueNodeGroup {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 node_group_id = 2;

    pub fn node_group_id(&self) -> u32 {
        self.node_group_id.unwrap_or(0)
    }

    pub fn clear_node_group_id(&mut self) {
        self.node_group_id = ::std::option::Option::None;
    }

    pub fn has_node_group_id(&self) -> bool {
        self.node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_group_id(&mut self, v: u32) {
        self.node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_node_group_id = 3;

    pub fn parent_node_group_id(&self) -> u32 {
        self.parent_node_group_id.unwrap_or(0)
    }

    pub fn clear_parent_node_group_id(&mut self) {
        self.parent_node_group_id = ::std::option::Option::None;
    }

    pub fn has_parent_node_group_id(&self) -> bool {
        self.parent_node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_node_group_id(&mut self, v: u32) {
        self.parent_node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 advancing_node_group_id = 5;

    pub fn advancing_node_group_id(&self) -> u32 {
        self.advancing_node_group_id.unwrap_or(0)
    }

    pub fn clear_advancing_node_group_id(&mut self) {
        self.advancing_node_group_id = ::std::option::Option::None;
    }

    pub fn has_advancing_node_group_id(&self) -> bool {
        self.advancing_node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_advancing_node_group_id(&mut self, v: u32) {
        self.advancing_node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 advancing_team_count = 6;

    pub fn advancing_team_count(&self) -> u32 {
        self.advancing_team_count.unwrap_or(0)
    }

    pub fn clear_advancing_team_count(&mut self) {
        self.advancing_team_count = ::std::option::Option::None;
    }

    pub fn has_advancing_team_count(&self) -> bool {
        self.advancing_team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_advancing_team_count(&mut self, v: u32) {
        self.advancing_team_count = ::std::option::Option::Some(v);
    }

    // optional uint32 team_count = 7;

    pub fn team_count(&self) -> u32 {
        self.team_count.unwrap_or(0)
    }

    pub fn clear_team_count(&mut self) {
        self.team_count = ::std::option::Option::None;
    }

    pub fn has_team_count(&self) -> bool {
        self.team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_count(&mut self, v: u32) {
        self.team_count = ::std::option::Option::Some(v);
    }

    // optional .dota.ELeagueNodeGroupType node_group_type = 8;

    pub fn node_group_type(&self) -> ELeagueNodeGroupType {
        match self.node_group_type {
            Some(e) => e.enum_value_or(ELeagueNodeGroupType::INVALID_GROUP_TYPE),
            None => ELeagueNodeGroupType::INVALID_GROUP_TYPE,
        }
    }

    pub fn clear_node_group_type(&mut self) {
        self.node_group_type = ::std::option::Option::None;
    }

    pub fn has_node_group_type(&self) -> bool {
        self.node_group_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_group_type(&mut self, v: ELeagueNodeGroupType) {
        self.node_group_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.ELeagueNodeType default_node_type = 9;

    pub fn default_node_type(&self) -> ELeagueNodeType {
        match self.default_node_type {
            Some(e) => e.enum_value_or(ELeagueNodeType::INVALID_NODE_TYPE),
            None => ELeagueNodeType::INVALID_NODE_TYPE,
        }
    }

    pub fn clear_default_node_type(&mut self) {
        self.default_node_type = ::std::option::Option::None;
    }

    pub fn has_default_node_type(&self) -> bool {
        self.default_node_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_node_type(&mut self, v: ELeagueNodeType) {
        self.default_node_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 round = 10;

    pub fn round(&self) -> u32 {
        self.round.unwrap_or(0)
    }

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u32) {
        self.round = ::std::option::Option::Some(v);
    }

    // optional uint32 max_rounds = 11;

    pub fn max_rounds(&self) -> u32 {
        self.max_rounds.unwrap_or(0)
    }

    pub fn clear_max_rounds(&mut self) {
        self.max_rounds = ::std::option::Option::None;
    }

    pub fn has_max_rounds(&self) -> bool {
        self.max_rounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_rounds(&mut self, v: u32) {
        self.max_rounds = ::std::option::Option::Some(v);
    }

    // optional bool is_tiebreaker = 12;

    pub fn is_tiebreaker(&self) -> bool {
        self.is_tiebreaker.unwrap_or(false)
    }

    pub fn clear_is_tiebreaker(&mut self) {
        self.is_tiebreaker = ::std::option::Option::None;
    }

    pub fn has_is_tiebreaker(&self) -> bool {
        self.is_tiebreaker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tiebreaker(&mut self, v: bool) {
        self.is_tiebreaker = ::std::option::Option::Some(v);
    }

    // optional bool is_final_group = 13;

    pub fn is_final_group(&self) -> bool {
        self.is_final_group.unwrap_or(false)
    }

    pub fn clear_is_final_group(&mut self) {
        self.is_final_group = ::std::option::Option::None;
    }

    pub fn has_is_final_group(&self) -> bool {
        self.is_final_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_final_group(&mut self, v: bool) {
        self.is_final_group = ::std::option::Option::Some(v);
    }

    // optional bool is_completed = 14;

    pub fn is_completed(&self) -> bool {
        self.is_completed.unwrap_or(false)
    }

    pub fn clear_is_completed(&mut self) {
        self.is_completed = ::std::option::Option::None;
    }

    pub fn has_is_completed(&self) -> bool {
        self.is_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_completed(&mut self, v: bool) {
        self.is_completed = ::std::option::Option::Some(v);
    }

    // optional .dota.ELeaguePhase phase = 18;

    pub fn phase(&self) -> super::dota_shared_enums::ELeaguePhase {
        match self.phase {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ELeaguePhase::LEAGUE_PHASE_UNSET),
            None => super::dota_shared_enums::ELeaguePhase::LEAGUE_PHASE_UNSET,
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: super::dota_shared_enums::ELeaguePhase) {
        self.phase = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.ELeagueRegion region = 19;

    pub fn region(&self) -> super::dota_shared_enums::ELeagueRegion {
        match self.region {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
            None => super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
        }
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: super::dota_shared_enums::ELeagueRegion) {
        self.region = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 start_time = 20;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 end_time = 21;

    pub fn end_time(&self) -> u32 {
        self.end_time.unwrap_or(0)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary_advancing_node_group_id = 22;

    pub fn secondary_advancing_node_group_id(&self) -> u32 {
        self.secondary_advancing_node_group_id.unwrap_or(0)
    }

    pub fn clear_secondary_advancing_node_group_id(&mut self) {
        self.secondary_advancing_node_group_id = ::std::option::Option::None;
    }

    pub fn has_secondary_advancing_node_group_id(&self) -> bool {
        self.secondary_advancing_node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_advancing_node_group_id(&mut self, v: u32) {
        self.secondary_advancing_node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary_advancing_team_count = 23;

    pub fn secondary_advancing_team_count(&self) -> u32 {
        self.secondary_advancing_team_count.unwrap_or(0)
    }

    pub fn clear_secondary_advancing_team_count(&mut self) {
        self.secondary_advancing_team_count = ::std::option::Option::None;
    }

    pub fn has_secondary_advancing_team_count(&self) -> bool {
        self.secondary_advancing_team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_advancing_team_count(&mut self, v: u32) {
        self.secondary_advancing_team_count = ::std::option::Option::Some(v);
    }

    // optional uint32 tertiary_advancing_node_group_id = 24;

    pub fn tertiary_advancing_node_group_id(&self) -> u32 {
        self.tertiary_advancing_node_group_id.unwrap_or(0)
    }

    pub fn clear_tertiary_advancing_node_group_id(&mut self) {
        self.tertiary_advancing_node_group_id = ::std::option::Option::None;
    }

    pub fn has_tertiary_advancing_node_group_id(&self) -> bool {
        self.tertiary_advancing_node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tertiary_advancing_node_group_id(&mut self, v: u32) {
        self.tertiary_advancing_node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tertiary_advancing_team_count = 25;

    pub fn tertiary_advancing_team_count(&self) -> u32 {
        self.tertiary_advancing_team_count.unwrap_or(0)
    }

    pub fn clear_tertiary_advancing_team_count(&mut self) {
        self.tertiary_advancing_team_count = ::std::option::Option::None;
    }

    pub fn has_tertiary_advancing_team_count(&self) -> bool {
        self.tertiary_advancing_team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tertiary_advancing_team_count(&mut self, v: u32) {
        self.tertiary_advancing_team_count = ::std::option::Option::Some(v);
    }

    // optional uint32 elimination_dpc_points = 26;

    pub fn elimination_dpc_points(&self) -> u32 {
        self.elimination_dpc_points.unwrap_or(0)
    }

    pub fn clear_elimination_dpc_points(&mut self) {
        self.elimination_dpc_points = ::std::option::Option::None;
    }

    pub fn has_elimination_dpc_points(&self) -> bool {
        self.elimination_dpc_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elimination_dpc_points(&mut self, v: u32) {
        self.elimination_dpc_points = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgDOTALeagueNodeGroup| { &m.name },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_group_id",
            |m: &CMsgDOTALeagueNodeGroup| { &m.node_group_id },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.node_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_node_group_id",
            |m: &CMsgDOTALeagueNodeGroup| { &m.parent_node_group_id },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.parent_node_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "incoming_node_group_ids",
            |m: &CMsgDOTALeagueNodeGroup| { &m.incoming_node_group_ids },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.incoming_node_group_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "advancing_node_group_id",
            |m: &CMsgDOTALeagueNodeGroup| { &m.advancing_node_group_id },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.advancing_node_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "advancing_team_count",
            |m: &CMsgDOTALeagueNodeGroup| { &m.advancing_team_count },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.advancing_team_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_count",
            |m: &CMsgDOTALeagueNodeGroup| { &m.team_count },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.team_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_group_type",
            |m: &CMsgDOTALeagueNodeGroup| { &m.node_group_type },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.node_group_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_node_type",
            |m: &CMsgDOTALeagueNodeGroup| { &m.default_node_type },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.default_node_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round",
            |m: &CMsgDOTALeagueNodeGroup| { &m.round },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_rounds",
            |m: &CMsgDOTALeagueNodeGroup| { &m.max_rounds },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.max_rounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_tiebreaker",
            |m: &CMsgDOTALeagueNodeGroup| { &m.is_tiebreaker },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.is_tiebreaker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_final_group",
            |m: &CMsgDOTALeagueNodeGroup| { &m.is_final_group },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.is_final_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_completed",
            |m: &CMsgDOTALeagueNodeGroup| { &m.is_completed },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.is_completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase",
            |m: &CMsgDOTALeagueNodeGroup| { &m.phase },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region",
            |m: &CMsgDOTALeagueNodeGroup| { &m.region },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgDOTALeagueNodeGroup| { &m.start_time },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_time",
            |m: &CMsgDOTALeagueNodeGroup| { &m.end_time },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secondary_advancing_node_group_id",
            |m: &CMsgDOTALeagueNodeGroup| { &m.secondary_advancing_node_group_id },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.secondary_advancing_node_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secondary_advancing_team_count",
            |m: &CMsgDOTALeagueNodeGroup| { &m.secondary_advancing_team_count },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.secondary_advancing_team_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tertiary_advancing_node_group_id",
            |m: &CMsgDOTALeagueNodeGroup| { &m.tertiary_advancing_node_group_id },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.tertiary_advancing_node_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tertiary_advancing_team_count",
            |m: &CMsgDOTALeagueNodeGroup| { &m.tertiary_advancing_team_count },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.tertiary_advancing_team_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elimination_dpc_points",
            |m: &CMsgDOTALeagueNodeGroup| { &m.elimination_dpc_points },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.elimination_dpc_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_standings",
            |m: &CMsgDOTALeagueNodeGroup| { &m.team_standings },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.team_standings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &CMsgDOTALeagueNodeGroup| { &m.nodes },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "node_groups",
            |m: &CMsgDOTALeagueNodeGroup| { &m.node_groups },
            |m: &mut CMsgDOTALeagueNodeGroup| { &mut m.node_groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueNodeGroup>(
            "CMsgDOTALeagueNodeGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueNodeGroup {
    const NAME: &'static str = "CMsgDOTALeagueNodeGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.parent_node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.incoming_node_group_ids)?;
                },
                32 => {
                    self.incoming_node_group_ids.push(is.read_uint32()?);
                },
                40 => {
                    self.advancing_node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.advancing_team_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.team_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.node_group_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.default_node_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.round = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.max_rounds = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.is_tiebreaker = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.is_final_group = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.phase = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                152 => {
                    self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.secondary_advancing_node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.secondary_advancing_team_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.tertiary_advancing_node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.tertiary_advancing_team_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.elimination_dpc_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.team_standings.push(is.read_message()?);
                },
                130 => {
                    self.nodes.push(is.read_message()?);
                },
                138 => {
                    self.node_groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.node_group_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.parent_node_group_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.incoming_node_group_ids {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.advancing_node_group_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.advancing_team_count {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.team_count {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.node_group_type {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.default_node_type {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.round {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.max_rounds {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.is_tiebreaker {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_final_group {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.phase {
            my_size += ::protobuf::rt::int32_size(18, v.value());
        }
        if let Some(v) = self.region {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.end_time {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.secondary_advancing_node_group_id {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.secondary_advancing_team_count {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.tertiary_advancing_node_group_id {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.tertiary_advancing_team_count {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.elimination_dpc_points {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        for value in &self.team_standings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.node_groups {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.node_group_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.parent_node_group_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.incoming_node_group_ids {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.advancing_node_group_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.advancing_team_count {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.team_count {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.node_group_type {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.default_node_type {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.round {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.max_rounds {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.is_tiebreaker {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_final_group {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_completed {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.phase {
            os.write_enum(18, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.region {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.secondary_advancing_node_group_id {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.secondary_advancing_team_count {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.tertiary_advancing_node_group_id {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.tertiary_advancing_team_count {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.elimination_dpc_points {
            os.write_uint32(26, v)?;
        }
        for v in &self.team_standings {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.node_groups {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueNodeGroup {
        CMsgDOTALeagueNodeGroup::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.node_group_id = ::std::option::Option::None;
        self.parent_node_group_id = ::std::option::Option::None;
        self.incoming_node_group_ids.clear();
        self.advancing_node_group_id = ::std::option::Option::None;
        self.advancing_team_count = ::std::option::Option::None;
        self.team_count = ::std::option::Option::None;
        self.node_group_type = ::std::option::Option::None;
        self.default_node_type = ::std::option::Option::None;
        self.round = ::std::option::Option::None;
        self.max_rounds = ::std::option::Option::None;
        self.is_tiebreaker = ::std::option::Option::None;
        self.is_final_group = ::std::option::Option::None;
        self.is_completed = ::std::option::Option::None;
        self.phase = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.secondary_advancing_node_group_id = ::std::option::Option::None;
        self.secondary_advancing_team_count = ::std::option::Option::None;
        self.tertiary_advancing_node_group_id = ::std::option::Option::None;
        self.tertiary_advancing_team_count = ::std::option::Option::None;
        self.elimination_dpc_points = ::std::option::Option::None;
        self.team_standings.clear();
        self.nodes.clear();
        self.node_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueNodeGroup {
        static instance: CMsgDOTALeagueNodeGroup = CMsgDOTALeagueNodeGroup {
            name: ::std::option::Option::None,
            node_group_id: ::std::option::Option::None,
            parent_node_group_id: ::std::option::Option::None,
            incoming_node_group_ids: ::std::vec::Vec::new(),
            advancing_node_group_id: ::std::option::Option::None,
            advancing_team_count: ::std::option::Option::None,
            team_count: ::std::option::Option::None,
            node_group_type: ::std::option::Option::None,
            default_node_type: ::std::option::Option::None,
            round: ::std::option::Option::None,
            max_rounds: ::std::option::Option::None,
            is_tiebreaker: ::std::option::Option::None,
            is_final_group: ::std::option::Option::None,
            is_completed: ::std::option::Option::None,
            phase: ::std::option::Option::None,
            region: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            secondary_advancing_node_group_id: ::std::option::Option::None,
            secondary_advancing_team_count: ::std::option::Option::None,
            tertiary_advancing_node_group_id: ::std::option::Option::None,
            tertiary_advancing_team_count: ::std::option::Option::None,
            elimination_dpc_points: ::std::option::Option::None,
            team_standings: ::std::vec::Vec::new(),
            nodes: ::std::vec::Vec::new(),
            node_groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueNodeGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueNodeGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueNodeGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueNodeGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTALeagueNodeGroup`
pub mod cmsg_dotaleague_node_group {
    // @@protoc_insertion_point(message:dota.CMsgDOTALeagueNodeGroup.TeamStanding)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamStanding {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.standing)
        pub standing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
        pub team_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.losses)
        pub losses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.score)
        pub score: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_abbreviation)
        pub team_abbreviation: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_group)
        pub score_tiebreak_group: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_below)
        pub score_tiebreak_below: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_random)
        pub score_tiebreak_random: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.is_pro)
        pub is_pro: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueNodeGroup.TeamStanding.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamStanding {
        fn default() -> &'a TeamStanding {
            <TeamStanding as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamStanding {
        pub fn new() -> TeamStanding {
            ::std::default::Default::default()
        }

        // optional uint32 standing = 1;

        pub fn standing(&self) -> u32 {
            self.standing.unwrap_or(0)
        }

        pub fn clear_standing(&mut self) {
            self.standing = ::std::option::Option::None;
        }

        pub fn has_standing(&self) -> bool {
            self.standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_standing(&mut self, v: u32) {
            self.standing = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 3;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_tag = 4;

        pub fn team_tag(&self) -> &str {
            match self.team_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_tag(&mut self) {
            self.team_tag = ::std::option::Option::None;
        }

        pub fn has_team_tag(&self) -> bool {
            self.team_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_tag(&mut self, v: ::std::string::String) {
            self.team_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
            if self.team_tag.is_none() {
                self.team_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_tag(&mut self) -> ::std::string::String {
            self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 team_logo = 5;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 6;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 wins = 7;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 losses = 8;

        pub fn losses(&self) -> u32 {
            self.losses.unwrap_or(0)
        }

        pub fn clear_losses(&mut self) {
            self.losses = ::std::option::Option::None;
        }

        pub fn has_losses(&self) -> bool {
            self.losses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losses(&mut self, v: u32) {
            self.losses = ::std::option::Option::Some(v);
        }

        // optional int64 score = 9;

        pub fn score(&self) -> i64 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: i64) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional string team_abbreviation = 10;

        pub fn team_abbreviation(&self) -> &str {
            match self.team_abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_abbreviation(&mut self) {
            self.team_abbreviation = ::std::option::Option::None;
        }

        pub fn has_team_abbreviation(&self) -> bool {
            self.team_abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
            self.team_abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.team_abbreviation.is_none() {
                self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
            self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int64 score_tiebreak_group = 11;

        pub fn score_tiebreak_group(&self) -> i64 {
            self.score_tiebreak_group.unwrap_or(0)
        }

        pub fn clear_score_tiebreak_group(&mut self) {
            self.score_tiebreak_group = ::std::option::Option::None;
        }

        pub fn has_score_tiebreak_group(&self) -> bool {
            self.score_tiebreak_group.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_tiebreak_group(&mut self, v: i64) {
            self.score_tiebreak_group = ::std::option::Option::Some(v);
        }

        // optional int64 score_tiebreak_below = 12;

        pub fn score_tiebreak_below(&self) -> i64 {
            self.score_tiebreak_below.unwrap_or(0)
        }

        pub fn clear_score_tiebreak_below(&mut self) {
            self.score_tiebreak_below = ::std::option::Option::None;
        }

        pub fn has_score_tiebreak_below(&self) -> bool {
            self.score_tiebreak_below.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_tiebreak_below(&mut self, v: i64) {
            self.score_tiebreak_below = ::std::option::Option::Some(v);
        }

        // optional int64 score_tiebreak_random = 13;

        pub fn score_tiebreak_random(&self) -> i64 {
            self.score_tiebreak_random.unwrap_or(0)
        }

        pub fn clear_score_tiebreak_random(&mut self) {
            self.score_tiebreak_random = ::std::option::Option::None;
        }

        pub fn has_score_tiebreak_random(&self) -> bool {
            self.score_tiebreak_random.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_tiebreak_random(&mut self, v: i64) {
            self.score_tiebreak_random = ::std::option::Option::Some(v);
        }

        // optional bool is_pro = 14;

        pub fn is_pro(&self) -> bool {
            self.is_pro.unwrap_or(false)
        }

        pub fn clear_is_pro(&mut self) {
            self.is_pro = ::std::option::Option::None;
        }

        pub fn has_is_pro(&self) -> bool {
            self.is_pro.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_pro(&mut self, v: bool) {
            self.is_pro = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(14);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "standing",
                |m: &TeamStanding| { &m.standing },
                |m: &mut TeamStanding| { &mut m.standing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &TeamStanding| { &m.team_id },
                |m: &mut TeamStanding| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_name",
                |m: &TeamStanding| { &m.team_name },
                |m: &mut TeamStanding| { &mut m.team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_tag",
                |m: &TeamStanding| { &m.team_tag },
                |m: &mut TeamStanding| { &mut m.team_tag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo",
                |m: &TeamStanding| { &m.team_logo },
                |m: &mut TeamStanding| { &mut m.team_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo_url",
                |m: &TeamStanding| { &m.team_logo_url },
                |m: &mut TeamStanding| { &mut m.team_logo_url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wins",
                |m: &TeamStanding| { &m.wins },
                |m: &mut TeamStanding| { &mut m.wins },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "losses",
                |m: &TeamStanding| { &m.losses },
                |m: &mut TeamStanding| { &mut m.losses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &TeamStanding| { &m.score },
                |m: &mut TeamStanding| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_abbreviation",
                |m: &TeamStanding| { &m.team_abbreviation },
                |m: &mut TeamStanding| { &mut m.team_abbreviation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score_tiebreak_group",
                |m: &TeamStanding| { &m.score_tiebreak_group },
                |m: &mut TeamStanding| { &mut m.score_tiebreak_group },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score_tiebreak_below",
                |m: &TeamStanding| { &m.score_tiebreak_below },
                |m: &mut TeamStanding| { &mut m.score_tiebreak_below },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score_tiebreak_random",
                |m: &TeamStanding| { &m.score_tiebreak_random },
                |m: &mut TeamStanding| { &mut m.score_tiebreak_random },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_pro",
                |m: &TeamStanding| { &m.is_pro },
                |m: &mut TeamStanding| { &mut m.is_pro },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamStanding>(
                "CMsgDOTALeagueNodeGroup.TeamStanding",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamStanding {
        const NAME: &'static str = "TeamStanding";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.standing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.team_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.team_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    50 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    56 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.losses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.score = ::std::option::Option::Some(is.read_int64()?);
                    },
                    82 => {
                        self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    88 => {
                        self.score_tiebreak_group = ::std::option::Option::Some(is.read_int64()?);
                    },
                    96 => {
                        self.score_tiebreak_below = ::std::option::Option::Some(is.read_int64()?);
                    },
                    104 => {
                        self.score_tiebreak_random = ::std::option::Option::Some(is.read_int64()?);
                    },
                    112 => {
                        self.is_pro = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.standing {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_tag.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += ::protobuf::rt::uint64_size(5, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.wins {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.losses {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::int64_size(9, v);
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.score_tiebreak_group {
                my_size += ::protobuf::rt::int64_size(11, v);
            }
            if let Some(v) = self.score_tiebreak_below {
                my_size += ::protobuf::rt::int64_size(12, v);
            }
            if let Some(v) = self.score_tiebreak_random {
                my_size += ::protobuf::rt::int64_size(13, v);
            }
            if let Some(v) = self.is_pro {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.standing {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_tag.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.wins {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.losses {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.score {
                os.write_int64(9, v)?;
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.score_tiebreak_group {
                os.write_int64(11, v)?;
            }
            if let Some(v) = self.score_tiebreak_below {
                os.write_int64(12, v)?;
            }
            if let Some(v) = self.score_tiebreak_random {
                os.write_int64(13, v)?;
            }
            if let Some(v) = self.is_pro {
                os.write_bool(14, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamStanding {
            TeamStanding::new()
        }

        fn clear(&mut self) {
            self.standing = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_tag = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.wins = ::std::option::Option::None;
            self.losses = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.team_abbreviation = ::std::option::Option::None;
            self.score_tiebreak_group = ::std::option::Option::None;
            self.score_tiebreak_below = ::std::option::Option::None;
            self.score_tiebreak_random = ::std::option::Option::None;
            self.is_pro = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamStanding {
            static instance: TeamStanding = TeamStanding {
                standing: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_tag: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                wins: ::std::option::Option::None,
                losses: ::std::option::Option::None,
                score: ::std::option::Option::None,
                team_abbreviation: ::std::option::Option::None,
                score_tiebreak_group: ::std::option::Option::None,
                score_tiebreak_below: ::std::option::Option::None,
                score_tiebreak_random: ::std::option::Option::None,
                is_pro: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamStanding {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeagueNodeGroup.TeamStanding").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamStanding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamStanding {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeague)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeague {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeague.info)
    pub info: ::protobuf::MessageField<cmsg_dotaleague::Info>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeague.prize_pool)
    pub prize_pool: ::protobuf::MessageField<cmsg_dotaleague::PrizePool>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeague.admins)
    pub admins: ::std::vec::Vec<cmsg_dotaleague::Admin>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeague.streams)
    pub streams: ::std::vec::Vec<cmsg_dotaleague::Stream>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeague.node_groups)
    pub node_groups: ::std::vec::Vec<CMsgDOTALeagueNodeGroup>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeague.series_infos)
    pub series_infos: ::std::vec::Vec<cmsg_dotaleague::SeriesInfo>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeague.registered_players)
    pub registered_players: ::std::vec::Vec<cmsg_dotaleague::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeague.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeague {
    fn default() -> &'a CMsgDOTALeague {
        <CMsgDOTALeague as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeague {
    pub fn new() -> CMsgDOTALeague {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotaleague::Info>(
            "info",
            |m: &CMsgDOTALeague| { &m.info },
            |m: &mut CMsgDOTALeague| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_dotaleague::PrizePool>(
            "prize_pool",
            |m: &CMsgDOTALeague| { &m.prize_pool },
            |m: &mut CMsgDOTALeague| { &mut m.prize_pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "admins",
            |m: &CMsgDOTALeague| { &m.admins },
            |m: &mut CMsgDOTALeague| { &mut m.admins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "streams",
            |m: &CMsgDOTALeague| { &m.streams },
            |m: &mut CMsgDOTALeague| { &mut m.streams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "node_groups",
            |m: &CMsgDOTALeague| { &m.node_groups },
            |m: &mut CMsgDOTALeague| { &mut m.node_groups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "series_infos",
            |m: &CMsgDOTALeague| { &m.series_infos },
            |m: &mut CMsgDOTALeague| { &mut m.series_infos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "registered_players",
            |m: &CMsgDOTALeague| { &m.registered_players },
            |m: &mut CMsgDOTALeague| { &mut m.registered_players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeague>(
            "CMsgDOTALeague",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeague {
    const NAME: &'static str = "CMsgDOTALeague";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.prize_pool)?;
                },
                26 => {
                    self.admins.push(is.read_message()?);
                },
                34 => {
                    self.streams.push(is.read_message()?);
                },
                42 => {
                    self.node_groups.push(is.read_message()?);
                },
                50 => {
                    self.series_infos.push(is.read_message()?);
                },
                58 => {
                    self.registered_players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.prize_pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.admins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.node_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.series_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.registered_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.prize_pool.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.admins {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.streams {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.node_groups {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.series_infos {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.registered_players {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeague {
        CMsgDOTALeague::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.prize_pool.clear();
        self.admins.clear();
        self.streams.clear();
        self.node_groups.clear();
        self.series_infos.clear();
        self.registered_players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeague {
        static instance: CMsgDOTALeague = CMsgDOTALeague {
            info: ::protobuf::MessageField::none(),
            prize_pool: ::protobuf::MessageField::none(),
            admins: ::std::vec::Vec::new(),
            streams: ::std::vec::Vec::new(),
            node_groups: ::std::vec::Vec::new(),
            series_infos: ::std::vec::Vec::new(),
            registered_players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeague {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeague").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeague {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeague {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTALeague`
pub mod cmsg_dotaleague {
    // @@protoc_insertion_point(message:dota.CMsgDOTALeague.Info)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Info {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.tier)
        pub tier: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueTier>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.region)
        pub region: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueRegion>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.url)
        pub url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.description)
        pub description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.notes)
        pub notes: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.start_timestamp)
        pub start_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.end_timestamp)
        pub end_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.pro_circuit_points)
        pub pro_circuit_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.image_bits)
        pub image_bits: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.status)
        pub status: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueStatus>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.most_recent_activity)
        pub most_recent_activity: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Info.registration_period)
        pub registration_period: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeague.Info.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Info {
        fn default() -> &'a Info {
            <Info as ::protobuf::Message>::default_instance()
        }
    }

    impl Info {
        pub fn new() -> Info {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .dota.ELeagueTier tier = 3;

        pub fn tier(&self) -> super::super::dota_shared_enums::ELeagueTier {
            match self.tier {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueTier::LEAGUE_TIER_UNSET),
                None => super::super::dota_shared_enums::ELeagueTier::LEAGUE_TIER_UNSET,
            }
        }

        pub fn clear_tier(&mut self) {
            self.tier = ::std::option::Option::None;
        }

        pub fn has_tier(&self) -> bool {
            self.tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tier(&mut self, v: super::super::dota_shared_enums::ELeagueTier) {
            self.tier = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .dota.ELeagueRegion region = 4;

        pub fn region(&self) -> super::super::dota_shared_enums::ELeagueRegion {
            match self.region {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
                None => super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
            }
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: super::super::dota_shared_enums::ELeagueRegion) {
            self.region = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string url = 5;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string description = 6;

        pub fn description(&self) -> &str {
            match self.description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_description(&mut self) {
            self.description = ::std::option::Option::None;
        }

        pub fn has_description(&self) -> bool {
            self.description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            if self.description.is_none() {
                self.description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.description.as_mut().unwrap()
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            self.description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string notes = 7;

        pub fn notes(&self) -> &str {
            match self.notes.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_notes(&mut self) {
            self.notes = ::std::option::Option::None;
        }

        pub fn has_notes(&self) -> bool {
            self.notes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notes(&mut self, v: ::std::string::String) {
            self.notes = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_notes(&mut self) -> &mut ::std::string::String {
            if self.notes.is_none() {
                self.notes = ::std::option::Option::Some(::std::string::String::new());
            }
            self.notes.as_mut().unwrap()
        }

        // Take field
        pub fn take_notes(&mut self) -> ::std::string::String {
            self.notes.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 start_timestamp = 8;

        pub fn start_timestamp(&self) -> u32 {
            self.start_timestamp.unwrap_or(0)
        }

        pub fn clear_start_timestamp(&mut self) {
            self.start_timestamp = ::std::option::Option::None;
        }

        pub fn has_start_timestamp(&self) -> bool {
            self.start_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_timestamp(&mut self, v: u32) {
            self.start_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 end_timestamp = 9;

        pub fn end_timestamp(&self) -> u32 {
            self.end_timestamp.unwrap_or(0)
        }

        pub fn clear_end_timestamp(&mut self) {
            self.end_timestamp = ::std::option::Option::None;
        }

        pub fn has_end_timestamp(&self) -> bool {
            self.end_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_timestamp(&mut self, v: u32) {
            self.end_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 pro_circuit_points = 10;

        pub fn pro_circuit_points(&self) -> u32 {
            self.pro_circuit_points.unwrap_or(0)
        }

        pub fn clear_pro_circuit_points(&mut self) {
            self.pro_circuit_points = ::std::option::Option::None;
        }

        pub fn has_pro_circuit_points(&self) -> bool {
            self.pro_circuit_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pro_circuit_points(&mut self, v: u32) {
            self.pro_circuit_points = ::std::option::Option::Some(v);
        }

        // optional uint32 image_bits = 11;

        pub fn image_bits(&self) -> u32 {
            self.image_bits.unwrap_or(0)
        }

        pub fn clear_image_bits(&mut self) {
            self.image_bits = ::std::option::Option::None;
        }

        pub fn has_image_bits(&self) -> bool {
            self.image_bits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_bits(&mut self, v: u32) {
            self.image_bits = ::std::option::Option::Some(v);
        }

        // optional .dota.ELeagueStatus status = 12;

        pub fn status(&self) -> super::super::dota_shared_enums::ELeagueStatus {
            match self.status {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueStatus::LEAGUE_STATUS_UNSET),
                None => super::super::dota_shared_enums::ELeagueStatus::LEAGUE_STATUS_UNSET,
            }
        }

        pub fn clear_status(&mut self) {
            self.status = ::std::option::Option::None;
        }

        pub fn has_status(&self) -> bool {
            self.status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_status(&mut self, v: super::super::dota_shared_enums::ELeagueStatus) {
            self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 most_recent_activity = 13;

        pub fn most_recent_activity(&self) -> u32 {
            self.most_recent_activity.unwrap_or(0)
        }

        pub fn clear_most_recent_activity(&mut self) {
            self.most_recent_activity = ::std::option::Option::None;
        }

        pub fn has_most_recent_activity(&self) -> bool {
            self.most_recent_activity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_most_recent_activity(&mut self, v: u32) {
            self.most_recent_activity = ::std::option::Option::Some(v);
        }

        // optional uint32 registration_period = 14;

        pub fn registration_period(&self) -> u32 {
            self.registration_period.unwrap_or(0)
        }

        pub fn clear_registration_period(&mut self) {
            self.registration_period = ::std::option::Option::None;
        }

        pub fn has_registration_period(&self) -> bool {
            self.registration_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_registration_period(&mut self, v: u32) {
            self.registration_period = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(14);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &Info| { &m.league_id },
                |m: &mut Info| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Info| { &m.name },
                |m: &mut Info| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tier",
                |m: &Info| { &m.tier },
                |m: &mut Info| { &mut m.tier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "region",
                |m: &Info| { &m.region },
                |m: &mut Info| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "url",
                |m: &Info| { &m.url },
                |m: &mut Info| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "description",
                |m: &Info| { &m.description },
                |m: &mut Info| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "notes",
                |m: &Info| { &m.notes },
                |m: &mut Info| { &mut m.notes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_timestamp",
                |m: &Info| { &m.start_timestamp },
                |m: &mut Info| { &mut m.start_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "end_timestamp",
                |m: &Info| { &m.end_timestamp },
                |m: &mut Info| { &mut m.end_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pro_circuit_points",
                |m: &Info| { &m.pro_circuit_points },
                |m: &mut Info| { &mut m.pro_circuit_points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_bits",
                |m: &Info| { &m.image_bits },
                |m: &mut Info| { &mut m.image_bits },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "status",
                |m: &Info| { &m.status },
                |m: &mut Info| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "most_recent_activity",
                |m: &Info| { &m.most_recent_activity },
                |m: &mut Info| { &mut m.most_recent_activity },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "registration_period",
                |m: &Info| { &m.registration_period },
                |m: &mut Info| { &mut m.registration_period },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Info>(
                "CMsgDOTALeague.Info",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Info {
        const NAME: &'static str = "Info";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.tier = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    42 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.description = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.notes = ::std::option::Option::Some(is.read_string()?);
                    },
                    64 => {
                        self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.end_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.pro_circuit_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.image_bits = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    104 => {
                        self.most_recent_activity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.registration_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.tier {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.region {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.description.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.notes.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.start_timestamp {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.end_timestamp {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.pro_circuit_points {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.image_bits {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.status {
                my_size += ::protobuf::rt::int32_size(12, v.value());
            }
            if let Some(v) = self.most_recent_activity {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.registration_period {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.tier {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.region {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.description.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.notes.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.start_timestamp {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.end_timestamp {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.pro_circuit_points {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.image_bits {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.status {
                os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.most_recent_activity {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.registration_period {
                os.write_uint32(14, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Info {
            Info::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.tier = ::std::option::Option::None;
            self.region = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.description = ::std::option::Option::None;
            self.notes = ::std::option::Option::None;
            self.start_timestamp = ::std::option::Option::None;
            self.end_timestamp = ::std::option::Option::None;
            self.pro_circuit_points = ::std::option::Option::None;
            self.image_bits = ::std::option::Option::None;
            self.status = ::std::option::Option::None;
            self.most_recent_activity = ::std::option::Option::None;
            self.registration_period = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Info {
            static instance: Info = Info {
                league_id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                tier: ::std::option::Option::None,
                region: ::std::option::Option::None,
                url: ::std::option::Option::None,
                description: ::std::option::Option::None,
                notes: ::std::option::Option::None,
                start_timestamp: ::std::option::Option::None,
                end_timestamp: ::std::option::Option::None,
                pro_circuit_points: ::std::option::Option::None,
                image_bits: ::std::option::Option::None,
                status: ::std::option::Option::None,
                most_recent_activity: ::std::option::Option::None,
                registration_period: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Info {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeague.Info").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Info {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Info {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTALeague.Admin)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Admin {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Admin.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Admin.is_primary)
        pub is_primary: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Admin.email_address)
        pub email_address: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeague.Admin.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Admin {
        fn default() -> &'a Admin {
            <Admin as ::protobuf::Message>::default_instance()
        }
    }

    impl Admin {
        pub fn new() -> Admin {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional bool is_primary = 2;

        pub fn is_primary(&self) -> bool {
            self.is_primary.unwrap_or(false)
        }

        pub fn clear_is_primary(&mut self) {
            self.is_primary = ::std::option::Option::None;
        }

        pub fn has_is_primary(&self) -> bool {
            self.is_primary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_primary(&mut self, v: bool) {
            self.is_primary = ::std::option::Option::Some(v);
        }

        // optional string email_address = 3;

        pub fn email_address(&self) -> &str {
            match self.email_address.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_email_address(&mut self) {
            self.email_address = ::std::option::Option::None;
        }

        pub fn has_email_address(&self) -> bool {
            self.email_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_email_address(&mut self, v: ::std::string::String) {
            self.email_address = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
            if self.email_address.is_none() {
                self.email_address = ::std::option::Option::Some(::std::string::String::new());
            }
            self.email_address.as_mut().unwrap()
        }

        // Take field
        pub fn take_email_address(&mut self) -> ::std::string::String {
            self.email_address.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Admin| { &m.account_id },
                |m: &mut Admin| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_primary",
                |m: &Admin| { &m.is_primary },
                |m: &mut Admin| { &mut m.is_primary },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "email_address",
                |m: &Admin| { &m.email_address },
                |m: &mut Admin| { &mut m.email_address },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Admin>(
                "CMsgDOTALeague.Admin",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Admin {
        const NAME: &'static str = "Admin";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.is_primary = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.email_address = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.is_primary {
                my_size += 1 + 1;
            }
            if let Some(v) = self.email_address.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.is_primary {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.email_address.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Admin {
            Admin::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.is_primary = ::std::option::Option::None;
            self.email_address = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Admin {
            static instance: Admin = Admin {
                account_id: ::std::option::Option::None,
                is_primary: ::std::option::Option::None,
                email_address: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Admin {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeague.Admin").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Admin {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Admin {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTALeague.PrizePoolItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PrizePoolItem {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.PrizePoolItem.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.PrizePoolItem.sales_stop_timestamp)
        pub sales_stop_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.PrizePoolItem.revenue_pct)
        pub revenue_pct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.PrizePoolItem.revenue_cents_per_sale)
        pub revenue_cents_per_sale: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeague.PrizePoolItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PrizePoolItem {
        fn default() -> &'a PrizePoolItem {
            <PrizePoolItem as ::protobuf::Message>::default_instance()
        }
    }

    impl PrizePoolItem {
        pub fn new() -> PrizePoolItem {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 sales_stop_timestamp = 2;

        pub fn sales_stop_timestamp(&self) -> u32 {
            self.sales_stop_timestamp.unwrap_or(0)
        }

        pub fn clear_sales_stop_timestamp(&mut self) {
            self.sales_stop_timestamp = ::std::option::Option::None;
        }

        pub fn has_sales_stop_timestamp(&self) -> bool {
            self.sales_stop_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sales_stop_timestamp(&mut self, v: u32) {
            self.sales_stop_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 revenue_pct = 3;

        pub fn revenue_pct(&self) -> u32 {
            self.revenue_pct.unwrap_or(0)
        }

        pub fn clear_revenue_pct(&mut self) {
            self.revenue_pct = ::std::option::Option::None;
        }

        pub fn has_revenue_pct(&self) -> bool {
            self.revenue_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_pct(&mut self, v: u32) {
            self.revenue_pct = ::std::option::Option::Some(v);
        }

        // optional uint32 revenue_cents_per_sale = 4;

        pub fn revenue_cents_per_sale(&self) -> u32 {
            self.revenue_cents_per_sale.unwrap_or(0)
        }

        pub fn clear_revenue_cents_per_sale(&mut self) {
            self.revenue_cents_per_sale = ::std::option::Option::None;
        }

        pub fn has_revenue_cents_per_sale(&self) -> bool {
            self.revenue_cents_per_sale.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_cents_per_sale(&mut self, v: u32) {
            self.revenue_cents_per_sale = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_def",
                |m: &PrizePoolItem| { &m.item_def },
                |m: &mut PrizePoolItem| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sales_stop_timestamp",
                |m: &PrizePoolItem| { &m.sales_stop_timestamp },
                |m: &mut PrizePoolItem| { &mut m.sales_stop_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_pct",
                |m: &PrizePoolItem| { &m.revenue_pct },
                |m: &mut PrizePoolItem| { &mut m.revenue_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_cents_per_sale",
                |m: &PrizePoolItem| { &m.revenue_cents_per_sale },
                |m: &mut PrizePoolItem| { &mut m.revenue_cents_per_sale },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrizePoolItem>(
                "CMsgDOTALeague.PrizePoolItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PrizePoolItem {
        const NAME: &'static str = "PrizePoolItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.sales_stop_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.revenue_pct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.revenue_cents_per_sale = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.sales_stop_timestamp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.revenue_pct {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.revenue_cents_per_sale {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.sales_stop_timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.revenue_pct {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.revenue_cents_per_sale {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PrizePoolItem {
            PrizePoolItem::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.sales_stop_timestamp = ::std::option::Option::None;
            self.revenue_pct = ::std::option::Option::None;
            self.revenue_cents_per_sale = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PrizePoolItem {
            static instance: PrizePoolItem = PrizePoolItem {
                item_def: ::std::option::Option::None,
                sales_stop_timestamp: ::std::option::Option::None,
                revenue_pct: ::std::option::Option::None,
                revenue_cents_per_sale: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PrizePoolItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeague.PrizePoolItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PrizePoolItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PrizePoolItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTALeague.PrizePool)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PrizePool {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.PrizePool.base_prize_pool)
        pub base_prize_pool: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.PrizePool.total_prize_pool)
        pub total_prize_pool: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.PrizePool.prize_split_pct_x100)
        pub prize_split_pct_x100: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.PrizePool.prize_pool_items)
        pub prize_pool_items: ::std::vec::Vec<PrizePoolItem>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeague.PrizePool.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PrizePool {
        fn default() -> &'a PrizePool {
            <PrizePool as ::protobuf::Message>::default_instance()
        }
    }

    impl PrizePool {
        pub fn new() -> PrizePool {
            ::std::default::Default::default()
        }

        // optional uint32 base_prize_pool = 1;

        pub fn base_prize_pool(&self) -> u32 {
            self.base_prize_pool.unwrap_or(0)
        }

        pub fn clear_base_prize_pool(&mut self) {
            self.base_prize_pool = ::std::option::Option::None;
        }

        pub fn has_base_prize_pool(&self) -> bool {
            self.base_prize_pool.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_prize_pool(&mut self, v: u32) {
            self.base_prize_pool = ::std::option::Option::Some(v);
        }

        // optional uint32 total_prize_pool = 2;

        pub fn total_prize_pool(&self) -> u32 {
            self.total_prize_pool.unwrap_or(0)
        }

        pub fn clear_total_prize_pool(&mut self) {
            self.total_prize_pool = ::std::option::Option::None;
        }

        pub fn has_total_prize_pool(&self) -> bool {
            self.total_prize_pool.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_prize_pool(&mut self, v: u32) {
            self.total_prize_pool = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_prize_pool",
                |m: &PrizePool| { &m.base_prize_pool },
                |m: &mut PrizePool| { &mut m.base_prize_pool },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_prize_pool",
                |m: &PrizePool| { &m.total_prize_pool },
                |m: &mut PrizePool| { &mut m.total_prize_pool },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "prize_split_pct_x100",
                |m: &PrizePool| { &m.prize_split_pct_x100 },
                |m: &mut PrizePool| { &mut m.prize_split_pct_x100 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "prize_pool_items",
                |m: &PrizePool| { &m.prize_pool_items },
                |m: &mut PrizePool| { &mut m.prize_pool_items },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrizePool>(
                "CMsgDOTALeague.PrizePool",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PrizePool {
        const NAME: &'static str = "PrizePool";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.base_prize_pool = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_prize_pool = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.prize_split_pct_x100)?;
                    },
                    24 => {
                        self.prize_split_pct_x100.push(is.read_uint32()?);
                    },
                    34 => {
                        self.prize_pool_items.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.base_prize_pool {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_prize_pool {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.prize_split_pct_x100 {
                my_size += ::protobuf::rt::uint32_size(3, *value);
            };
            for value in &self.prize_pool_items {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.base_prize_pool {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_prize_pool {
                os.write_uint32(2, v)?;
            }
            for v in &self.prize_split_pct_x100 {
                os.write_uint32(3, *v)?;
            };
            for v in &self.prize_pool_items {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PrizePool {
            PrizePool::new()
        }

        fn clear(&mut self) {
            self.base_prize_pool = ::std::option::Option::None;
            self.total_prize_pool = ::std::option::Option::None;
            self.prize_split_pct_x100.clear();
            self.prize_pool_items.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PrizePool {
            static instance: PrizePool = PrizePool {
                base_prize_pool: ::std::option::Option::None,
                total_prize_pool: ::std::option::Option::None,
                prize_split_pct_x100: ::std::vec::Vec::new(),
                prize_pool_items: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PrizePool {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeague.PrizePool").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PrizePool {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PrizePool {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTALeague.Stream)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stream {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Stream.stream_id)
        pub stream_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Stream.language)
        pub language: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Stream.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Stream.broadcast_provider)
        pub broadcast_provider: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueBroadcastProvider>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Stream.stream_url)
        pub stream_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Stream.vod_url)
        pub vod_url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeague.Stream.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stream {
        fn default() -> &'a Stream {
            <Stream as ::protobuf::Message>::default_instance()
        }
    }

    impl Stream {
        pub fn new() -> Stream {
            ::std::default::Default::default()
        }

        // optional uint32 stream_id = 1;

        pub fn stream_id(&self) -> u32 {
            self.stream_id.unwrap_or(0)
        }

        pub fn clear_stream_id(&mut self) {
            self.stream_id = ::std::option::Option::None;
        }

        pub fn has_stream_id(&self) -> bool {
            self.stream_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stream_id(&mut self, v: u32) {
            self.stream_id = ::std::option::Option::Some(v);
        }

        // optional uint32 language = 2;

        pub fn language(&self) -> u32 {
            self.language.unwrap_or(0)
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: u32) {
            self.language = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .dota.ELeagueBroadcastProvider broadcast_provider = 4;

        pub fn broadcast_provider(&self) -> super::super::dota_shared_enums::ELeagueBroadcastProvider {
            match self.broadcast_provider {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN),
                None => super::super::dota_shared_enums::ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN,
            }
        }

        pub fn clear_broadcast_provider(&mut self) {
            self.broadcast_provider = ::std::option::Option::None;
        }

        pub fn has_broadcast_provider(&self) -> bool {
            self.broadcast_provider.is_some()
        }

        // Param is passed by value, moved
        pub fn set_broadcast_provider(&mut self, v: super::super::dota_shared_enums::ELeagueBroadcastProvider) {
            self.broadcast_provider = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string stream_url = 5;

        pub fn stream_url(&self) -> &str {
            match self.stream_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_stream_url(&mut self) {
            self.stream_url = ::std::option::Option::None;
        }

        pub fn has_stream_url(&self) -> bool {
            self.stream_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stream_url(&mut self, v: ::std::string::String) {
            self.stream_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_stream_url(&mut self) -> &mut ::std::string::String {
            if self.stream_url.is_none() {
                self.stream_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.stream_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_stream_url(&mut self) -> ::std::string::String {
            self.stream_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vod_url = 6;

        pub fn vod_url(&self) -> &str {
            match self.vod_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vod_url(&mut self) {
            self.vod_url = ::std::option::Option::None;
        }

        pub fn has_vod_url(&self) -> bool {
            self.vod_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vod_url(&mut self, v: ::std::string::String) {
            self.vod_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vod_url(&mut self) -> &mut ::std::string::String {
            if self.vod_url.is_none() {
                self.vod_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vod_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_vod_url(&mut self) -> ::std::string::String {
            self.vod_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stream_id",
                |m: &Stream| { &m.stream_id },
                |m: &mut Stream| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language",
                |m: &Stream| { &m.language },
                |m: &mut Stream| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Stream| { &m.name },
                |m: &mut Stream| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "broadcast_provider",
                |m: &Stream| { &m.broadcast_provider },
                |m: &mut Stream| { &mut m.broadcast_provider },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stream_url",
                |m: &Stream| { &m.stream_url },
                |m: &mut Stream| { &mut m.stream_url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vod_url",
                |m: &Stream| { &m.vod_url },
                |m: &mut Stream| { &mut m.vod_url },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stream>(
                "CMsgDOTALeague.Stream",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stream {
        const NAME: &'static str = "Stream";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stream_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.language = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.broadcast_provider = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    42 => {
                        self.stream_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.vod_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stream_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.language {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.broadcast_provider {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.stream_url.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.vod_url.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stream_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.language {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.broadcast_provider {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.stream_url.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.vod_url.as_ref() {
                os.write_string(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stream {
            Stream::new()
        }

        fn clear(&mut self) {
            self.stream_id = ::std::option::Option::None;
            self.language = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.broadcast_provider = ::std::option::Option::None;
            self.stream_url = ::std::option::Option::None;
            self.vod_url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stream {
            static instance: Stream = Stream {
                stream_id: ::std::option::Option::None,
                language: ::std::option::Option::None,
                name: ::std::option::Option::None,
                broadcast_provider: ::std::option::Option::None,
                stream_url: ::std::option::Option::None,
                vod_url: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stream {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeague.Stream").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stream {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stream {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTALeague.SeriesInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SeriesInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.SeriesInfo.series_id)
        pub series_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.SeriesInfo.series_type)
        pub series_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.SeriesInfo.start_time)
        pub start_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.SeriesInfo.match_ids)
        pub match_ids: ::std::vec::Vec<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.SeriesInfo.team_id_1)
        pub team_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.SeriesInfo.team_id_2)
        pub team_id_2: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeague.SeriesInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SeriesInfo {
        fn default() -> &'a SeriesInfo {
            <SeriesInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl SeriesInfo {
        pub fn new() -> SeriesInfo {
            ::std::default::Default::default()
        }

        // optional uint32 series_id = 1;

        pub fn series_id(&self) -> u32 {
            self.series_id.unwrap_or(0)
        }

        pub fn clear_series_id(&mut self) {
            self.series_id = ::std::option::Option::None;
        }

        pub fn has_series_id(&self) -> bool {
            self.series_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_id(&mut self, v: u32) {
            self.series_id = ::std::option::Option::Some(v);
        }

        // optional uint32 series_type = 2;

        pub fn series_type(&self) -> u32 {
            self.series_type.unwrap_or(0)
        }

        pub fn clear_series_type(&mut self) {
            self.series_type = ::std::option::Option::None;
        }

        pub fn has_series_type(&self) -> bool {
            self.series_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_type(&mut self, v: u32) {
            self.series_type = ::std::option::Option::Some(v);
        }

        // optional uint32 start_time = 3;

        pub fn start_time(&self) -> u32 {
            self.start_time.unwrap_or(0)
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: u32) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_1 = 5;

        pub fn team_id_1(&self) -> u32 {
            self.team_id_1.unwrap_or(0)
        }

        pub fn clear_team_id_1(&mut self) {
            self.team_id_1 = ::std::option::Option::None;
        }

        pub fn has_team_id_1(&self) -> bool {
            self.team_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_1(&mut self, v: u32) {
            self.team_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_2 = 6;

        pub fn team_id_2(&self) -> u32 {
            self.team_id_2.unwrap_or(0)
        }

        pub fn clear_team_id_2(&mut self) {
            self.team_id_2 = ::std::option::Option::None;
        }

        pub fn has_team_id_2(&self) -> bool {
            self.team_id_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_2(&mut self, v: u32) {
            self.team_id_2 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "series_id",
                |m: &SeriesInfo| { &m.series_id },
                |m: &mut SeriesInfo| { &mut m.series_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "series_type",
                |m: &SeriesInfo| { &m.series_type },
                |m: &mut SeriesInfo| { &mut m.series_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_time",
                |m: &SeriesInfo| { &m.start_time },
                |m: &mut SeriesInfo| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "match_ids",
                |m: &SeriesInfo| { &m.match_ids },
                |m: &mut SeriesInfo| { &mut m.match_ids },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id_1",
                |m: &SeriesInfo| { &m.team_id_1 },
                |m: &mut SeriesInfo| { &mut m.team_id_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id_2",
                |m: &SeriesInfo| { &m.team_id_2 },
                |m: &mut SeriesInfo| { &mut m.team_id_2 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SeriesInfo>(
                "CMsgDOTALeague.SeriesInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SeriesInfo {
        const NAME: &'static str = "SeriesInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint64_into(&mut self.match_ids)?;
                    },
                    32 => {
                        self.match_ids.push(is.read_uint64()?);
                    },
                    40 => {
                        self.team_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.team_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.series_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.series_type {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.start_time {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            for value in &self.match_ids {
                my_size += ::protobuf::rt::uint64_size(4, *value);
            };
            if let Some(v) = self.team_id_1 {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.team_id_2 {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.series_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.series_type {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.start_time {
                os.write_uint32(3, v)?;
            }
            for v in &self.match_ids {
                os.write_uint64(4, *v)?;
            };
            if let Some(v) = self.team_id_1 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.team_id_2 {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SeriesInfo {
            SeriesInfo::new()
        }

        fn clear(&mut self) {
            self.series_id = ::std::option::Option::None;
            self.series_type = ::std::option::Option::None;
            self.start_time = ::std::option::Option::None;
            self.match_ids.clear();
            self.team_id_1 = ::std::option::Option::None;
            self.team_id_2 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SeriesInfo {
            static instance: SeriesInfo = SeriesInfo {
                series_id: ::std::option::Option::None,
                series_type: ::std::option::Option::None,
                start_time: ::std::option::Option::None,
                match_ids: ::std::vec::Vec::new(),
                team_id_1: ::std::option::Option::None,
                team_id_2: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SeriesInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeague.SeriesInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SeriesInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SeriesInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTALeague.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Player.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeague.Player.team_id)
        pub team_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeague.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 3;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &Player| { &m.account_id },
                |m: &mut Player| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Player| { &m.name },
                |m: &mut Player| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &Player| { &m.team_id },
                |m: &mut Player| { &mut m.team_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgDOTALeague.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeague.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueList.leagues)
    pub leagues: ::std::vec::Vec<CMsgDOTALeague>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueList {
    fn default() -> &'a CMsgDOTALeagueList {
        <CMsgDOTALeagueList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueList {
    pub fn new() -> CMsgDOTALeagueList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "leagues",
            |m: &CMsgDOTALeagueList| { &m.leagues },
            |m: &mut CMsgDOTALeagueList| { &mut m.leagues },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueList>(
            "CMsgDOTALeagueList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueList {
    const NAME: &'static str = "CMsgDOTALeagueList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.leagues.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.leagues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.leagues {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueList {
        CMsgDOTALeagueList::new()
    }

    fn clear(&mut self) {
        self.leagues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueList {
        static instance: CMsgDOTALeagueList = CMsgDOTALeagueList {
            leagues: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueInfo {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfo.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfo.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfo.tier)
    pub tier: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::ELeagueTier>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfo.region)
    pub region: ::std::option::Option<::protobuf::EnumOrUnknown<super::dota_shared_enums::ELeagueRegion>>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfo.most_recent_activity)
    pub most_recent_activity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfo.total_prize_pool)
    pub total_prize_pool: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfo.start_timestamp)
    pub start_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfo.end_timestamp)
    pub end_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfo.status)
    pub status: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueInfo {
    fn default() -> &'a CMsgDOTALeagueInfo {
        <CMsgDOTALeagueInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueInfo {
    pub fn new() -> CMsgDOTALeagueInfo {
        ::std::default::Default::default()
    }

    // optional uint32 league_id = 1;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .dota.ELeagueTier tier = 3;

    pub fn tier(&self) -> super::dota_shared_enums::ELeagueTier {
        match self.tier {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ELeagueTier::LEAGUE_TIER_UNSET),
            None => super::dota_shared_enums::ELeagueTier::LEAGUE_TIER_UNSET,
        }
    }

    pub fn clear_tier(&mut self) {
        self.tier = ::std::option::Option::None;
    }

    pub fn has_tier(&self) -> bool {
        self.tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: super::dota_shared_enums::ELeagueTier) {
        self.tier = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .dota.ELeagueRegion region = 4;

    pub fn region(&self) -> super::dota_shared_enums::ELeagueRegion {
        match self.region {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
            None => super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
        }
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: super::dota_shared_enums::ELeagueRegion) {
        self.region = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 most_recent_activity = 5;

    pub fn most_recent_activity(&self) -> u32 {
        self.most_recent_activity.unwrap_or(0)
    }

    pub fn clear_most_recent_activity(&mut self) {
        self.most_recent_activity = ::std::option::Option::None;
    }

    pub fn has_most_recent_activity(&self) -> bool {
        self.most_recent_activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_most_recent_activity(&mut self, v: u32) {
        self.most_recent_activity = ::std::option::Option::Some(v);
    }

    // optional uint32 total_prize_pool = 6;

    pub fn total_prize_pool(&self) -> u32 {
        self.total_prize_pool.unwrap_or(0)
    }

    pub fn clear_total_prize_pool(&mut self) {
        self.total_prize_pool = ::std::option::Option::None;
    }

    pub fn has_total_prize_pool(&self) -> bool {
        self.total_prize_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_prize_pool(&mut self, v: u32) {
        self.total_prize_pool = ::std::option::Option::Some(v);
    }

    // optional uint32 start_timestamp = 7;

    pub fn start_timestamp(&self) -> u32 {
        self.start_timestamp.unwrap_or(0)
    }

    pub fn clear_start_timestamp(&mut self) {
        self.start_timestamp = ::std::option::Option::None;
    }

    pub fn has_start_timestamp(&self) -> bool {
        self.start_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp(&mut self, v: u32) {
        self.start_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 end_timestamp = 8;

    pub fn end_timestamp(&self) -> u32 {
        self.end_timestamp.unwrap_or(0)
    }

    pub fn clear_end_timestamp(&mut self) {
        self.end_timestamp = ::std::option::Option::None;
    }

    pub fn has_end_timestamp(&self) -> bool {
        self.end_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_timestamp(&mut self, v: u32) {
        self.end_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 status = 9;

    pub fn status(&self) -> u32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgDOTALeagueInfo| { &m.league_id },
            |m: &mut CMsgDOTALeagueInfo| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgDOTALeagueInfo| { &m.name },
            |m: &mut CMsgDOTALeagueInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tier",
            |m: &CMsgDOTALeagueInfo| { &m.tier },
            |m: &mut CMsgDOTALeagueInfo| { &mut m.tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region",
            |m: &CMsgDOTALeagueInfo| { &m.region },
            |m: &mut CMsgDOTALeagueInfo| { &mut m.region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "most_recent_activity",
            |m: &CMsgDOTALeagueInfo| { &m.most_recent_activity },
            |m: &mut CMsgDOTALeagueInfo| { &mut m.most_recent_activity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_prize_pool",
            |m: &CMsgDOTALeagueInfo| { &m.total_prize_pool },
            |m: &mut CMsgDOTALeagueInfo| { &mut m.total_prize_pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_timestamp",
            |m: &CMsgDOTALeagueInfo| { &m.start_timestamp },
            |m: &mut CMsgDOTALeagueInfo| { &mut m.start_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_timestamp",
            |m: &CMsgDOTALeagueInfo| { &m.end_timestamp },
            |m: &mut CMsgDOTALeagueInfo| { &mut m.end_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CMsgDOTALeagueInfo| { &m.status },
            |m: &mut CMsgDOTALeagueInfo| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueInfo>(
            "CMsgDOTALeagueInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueInfo {
    const NAME: &'static str = "CMsgDOTALeagueInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.tier = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.most_recent_activity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.total_prize_pool = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.end_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.status = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.tier {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.region {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.most_recent_activity {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.total_prize_pool {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.start_timestamp {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.end_timestamp {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.tier {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.region {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.most_recent_activity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.total_prize_pool {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.start_timestamp {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.end_timestamp {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueInfo {
        CMsgDOTALeagueInfo::new()
    }

    fn clear(&mut self) {
        self.league_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.tier = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.most_recent_activity = ::std::option::Option::None;
        self.total_prize_pool = ::std::option::Option::None;
        self.start_timestamp = ::std::option::Option::None;
        self.end_timestamp = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueInfo {
        static instance: CMsgDOTALeagueInfo = CMsgDOTALeagueInfo {
            league_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            tier: ::std::option::Option::None,
            region: ::std::option::Option::None,
            most_recent_activity: ::std::option::Option::None,
            total_prize_pool: ::std::option::Option::None,
            start_timestamp: ::std::option::Option::None,
            end_timestamp: ::std::option::Option::None,
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueInfoList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueInfoList {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueInfoList.infos)
    pub infos: ::std::vec::Vec<CMsgDOTALeagueInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueInfoList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueInfoList {
    fn default() -> &'a CMsgDOTALeagueInfoList {
        <CMsgDOTALeagueInfoList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueInfoList {
    pub fn new() -> CMsgDOTALeagueInfoList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &CMsgDOTALeagueInfoList| { &m.infos },
            |m: &mut CMsgDOTALeagueInfoList| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueInfoList>(
            "CMsgDOTALeagueInfoList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueInfoList {
    const NAME: &'static str = "CMsgDOTALeagueInfoList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueInfoList {
        CMsgDOTALeagueInfoList::new()
    }

    fn clear(&mut self) {
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueInfoList {
        static instance: CMsgDOTALeagueInfoList = CMsgDOTALeagueInfoList {
            infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueInfoList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueInfoList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueInfoList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueInfoList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueLiveGames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueLiveGames {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.games)
    pub games: ::std::vec::Vec<cmsg_dotaleague_live_games::LiveGame>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueLiveGames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueLiveGames {
    fn default() -> &'a CMsgDOTALeagueLiveGames {
        <CMsgDOTALeagueLiveGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueLiveGames {
    pub fn new() -> CMsgDOTALeagueLiveGames {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "games",
            |m: &CMsgDOTALeagueLiveGames| { &m.games },
            |m: &mut CMsgDOTALeagueLiveGames| { &mut m.games },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueLiveGames>(
            "CMsgDOTALeagueLiveGames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueLiveGames {
    const NAME: &'static str = "CMsgDOTALeagueLiveGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.games.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.games {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueLiveGames {
        CMsgDOTALeagueLiveGames::new()
    }

    fn clear(&mut self) {
        self.games.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueLiveGames {
        static instance: CMsgDOTALeagueLiveGames = CMsgDOTALeagueLiveGames {
            games: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueLiveGames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueLiveGames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueLiveGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueLiveGames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTALeagueLiveGames`
pub mod cmsg_dotaleague_live_games {
    // @@protoc_insertion_point(message:dota.CMsgDOTALeagueLiveGames.LiveGame)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LiveGame {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.server_steam_id)
        pub server_steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
        pub radiant_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_logo)
        pub radiant_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_team_id)
        pub radiant_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.dire_name)
        pub dire_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.dire_logo)
        pub dire_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.dire_team_id)
        pub dire_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.time)
        pub time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.spectators)
        pub spectators: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.league_node_id)
        pub league_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.series_id)
        pub series_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueLiveGames.LiveGame.match_id)
        pub match_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueLiveGames.LiveGame.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LiveGame {
        fn default() -> &'a LiveGame {
            <LiveGame as ::protobuf::Message>::default_instance()
        }
    }

    impl LiveGame {
        pub fn new() -> LiveGame {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint64 server_steam_id = 2;

        pub fn server_steam_id(&self) -> u64 {
            self.server_steam_id.unwrap_or(0)
        }

        pub fn clear_server_steam_id(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
        }

        pub fn has_server_steam_id(&self) -> bool {
            self.server_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_steam_id(&mut self, v: u64) {
            self.server_steam_id = ::std::option::Option::Some(v);
        }

        // optional string radiant_name = 3;

        pub fn radiant_name(&self) -> &str {
            match self.radiant_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_radiant_name(&mut self) {
            self.radiant_name = ::std::option::Option::None;
        }

        pub fn has_radiant_name(&self) -> bool {
            self.radiant_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_name(&mut self, v: ::std::string::String) {
            self.radiant_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_radiant_name(&mut self) -> &mut ::std::string::String {
            if self.radiant_name.is_none() {
                self.radiant_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.radiant_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_radiant_name(&mut self) -> ::std::string::String {
            self.radiant_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 radiant_logo = 4;

        pub fn radiant_logo(&self) -> u64 {
            self.radiant_logo.unwrap_or(0)
        }

        pub fn clear_radiant_logo(&mut self) {
            self.radiant_logo = ::std::option::Option::None;
        }

        pub fn has_radiant_logo(&self) -> bool {
            self.radiant_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_logo(&mut self, v: u64) {
            self.radiant_logo = ::std::option::Option::Some(v);
        }

        // optional uint32 radiant_team_id = 9;

        pub fn radiant_team_id(&self) -> u32 {
            self.radiant_team_id.unwrap_or(0)
        }

        pub fn clear_radiant_team_id(&mut self) {
            self.radiant_team_id = ::std::option::Option::None;
        }

        pub fn has_radiant_team_id(&self) -> bool {
            self.radiant_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_id(&mut self, v: u32) {
            self.radiant_team_id = ::std::option::Option::Some(v);
        }

        // optional string dire_name = 5;

        pub fn dire_name(&self) -> &str {
            match self.dire_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dire_name(&mut self) {
            self.dire_name = ::std::option::Option::None;
        }

        pub fn has_dire_name(&self) -> bool {
            self.dire_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_name(&mut self, v: ::std::string::String) {
            self.dire_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dire_name(&mut self) -> &mut ::std::string::String {
            if self.dire_name.is_none() {
                self.dire_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dire_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_dire_name(&mut self) -> ::std::string::String {
            self.dire_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 dire_logo = 6;

        pub fn dire_logo(&self) -> u64 {
            self.dire_logo.unwrap_or(0)
        }

        pub fn clear_dire_logo(&mut self) {
            self.dire_logo = ::std::option::Option::None;
        }

        pub fn has_dire_logo(&self) -> bool {
            self.dire_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_logo(&mut self, v: u64) {
            self.dire_logo = ::std::option::Option::Some(v);
        }

        // optional uint32 dire_team_id = 10;

        pub fn dire_team_id(&self) -> u32 {
            self.dire_team_id.unwrap_or(0)
        }

        pub fn clear_dire_team_id(&mut self) {
            self.dire_team_id = ::std::option::Option::None;
        }

        pub fn has_dire_team_id(&self) -> bool {
            self.dire_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_id(&mut self, v: u32) {
            self.dire_team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time = 7;

        pub fn time(&self) -> u32 {
            self.time.unwrap_or(0)
        }

        pub fn clear_time(&mut self) {
            self.time = ::std::option::Option::None;
        }

        pub fn has_time(&self) -> bool {
            self.time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time(&mut self, v: u32) {
            self.time = ::std::option::Option::Some(v);
        }

        // optional uint32 spectators = 8;

        pub fn spectators(&self) -> u32 {
            self.spectators.unwrap_or(0)
        }

        pub fn clear_spectators(&mut self) {
            self.spectators = ::std::option::Option::None;
        }

        pub fn has_spectators(&self) -> bool {
            self.spectators.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spectators(&mut self, v: u32) {
            self.spectators = ::std::option::Option::Some(v);
        }

        // optional uint32 league_node_id = 11;

        pub fn league_node_id(&self) -> u32 {
            self.league_node_id.unwrap_or(0)
        }

        pub fn clear_league_node_id(&mut self) {
            self.league_node_id = ::std::option::Option::None;
        }

        pub fn has_league_node_id(&self) -> bool {
            self.league_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_node_id(&mut self, v: u32) {
            self.league_node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 series_id = 12;

        pub fn series_id(&self) -> u32 {
            self.series_id.unwrap_or(0)
        }

        pub fn clear_series_id(&mut self) {
            self.series_id = ::std::option::Option::None;
        }

        pub fn has_series_id(&self) -> bool {
            self.series_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_id(&mut self, v: u32) {
            self.series_id = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 13;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &LiveGame| { &m.league_id },
                |m: &mut LiveGame| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_steam_id",
                |m: &LiveGame| { &m.server_steam_id },
                |m: &mut LiveGame| { &mut m.server_steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radiant_name",
                |m: &LiveGame| { &m.radiant_name },
                |m: &mut LiveGame| { &mut m.radiant_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radiant_logo",
                |m: &LiveGame| { &m.radiant_logo },
                |m: &mut LiveGame| { &mut m.radiant_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radiant_team_id",
                |m: &LiveGame| { &m.radiant_team_id },
                |m: &mut LiveGame| { &mut m.radiant_team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dire_name",
                |m: &LiveGame| { &m.dire_name },
                |m: &mut LiveGame| { &mut m.dire_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dire_logo",
                |m: &LiveGame| { &m.dire_logo },
                |m: &mut LiveGame| { &mut m.dire_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dire_team_id",
                |m: &LiveGame| { &m.dire_team_id },
                |m: &mut LiveGame| { &mut m.dire_team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time",
                |m: &LiveGame| { &m.time },
                |m: &mut LiveGame| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "spectators",
                |m: &LiveGame| { &m.spectators },
                |m: &mut LiveGame| { &mut m.spectators },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_node_id",
                |m: &LiveGame| { &m.league_node_id },
                |m: &mut LiveGame| { &mut m.league_node_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "series_id",
                |m: &LiveGame| { &m.series_id },
                |m: &mut LiveGame| { &mut m.series_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &LiveGame| { &m.match_id },
                |m: &mut LiveGame| { &mut m.match_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LiveGame>(
                "CMsgDOTALeagueLiveGames.LiveGame",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LiveGame {
        const NAME: &'static str = "LiveGame";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.server_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.radiant_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.radiant_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.radiant_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.dire_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.dire_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    80 => {
                        self.dire_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.spectators = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.server_steam_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.radiant_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.radiant_logo {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.radiant_team_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.dire_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.dire_logo {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.dire_team_id {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.time {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.spectators {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.league_node_id {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.series_id {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint64_size(13, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_steam_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.radiant_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.radiant_logo {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.radiant_team_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.dire_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.dire_logo {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.dire_team_id {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.time {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.spectators {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.league_node_id {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.series_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(13, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LiveGame {
            LiveGame::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.server_steam_id = ::std::option::Option::None;
            self.radiant_name = ::std::option::Option::None;
            self.radiant_logo = ::std::option::Option::None;
            self.radiant_team_id = ::std::option::Option::None;
            self.dire_name = ::std::option::Option::None;
            self.dire_logo = ::std::option::Option::None;
            self.dire_team_id = ::std::option::Option::None;
            self.time = ::std::option::Option::None;
            self.spectators = ::std::option::Option::None;
            self.league_node_id = ::std::option::Option::None;
            self.series_id = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LiveGame {
            static instance: LiveGame = LiveGame {
                league_id: ::std::option::Option::None,
                server_steam_id: ::std::option::Option::None,
                radiant_name: ::std::option::Option::None,
                radiant_logo: ::std::option::Option::None,
                radiant_team_id: ::std::option::Option::None,
                dire_name: ::std::option::Option::None,
                dire_logo: ::std::option::Option::None,
                dire_team_id: ::std::option::Option::None,
                time: ::std::option::Option::None,
                spectators: ::std::option::Option::None,
                league_node_id: ::std::option::Option::None,
                series_id: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LiveGame {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeagueLiveGames.LiveGame").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LiveGame {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LiveGame {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueMessages)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueMessages {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueMessages.messages)
    pub messages: ::std::vec::Vec<cmsg_dotaleague_messages::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueMessages.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueMessages {
    fn default() -> &'a CMsgDOTALeagueMessages {
        <CMsgDOTALeagueMessages as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueMessages {
    pub fn new() -> CMsgDOTALeagueMessages {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CMsgDOTALeagueMessages| { &m.messages },
            |m: &mut CMsgDOTALeagueMessages| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueMessages>(
            "CMsgDOTALeagueMessages",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueMessages {
    const NAME: &'static str = "CMsgDOTALeagueMessages";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueMessages {
        CMsgDOTALeagueMessages::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueMessages {
        static instance: CMsgDOTALeagueMessages = CMsgDOTALeagueMessages {
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueMessages {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueMessages").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueMessages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueMessages {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTALeagueMessages`
pub mod cmsg_dotaleague_messages {
    // @@protoc_insertion_point(message:dota.CMsgDOTALeagueMessages.Message)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Message {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueMessages.Message.author_account_id)
        pub author_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueMessages.Message.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueMessages.Message.message)
        pub message: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueMessages.Message.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Message {
        fn default() -> &'a Message {
            <Message as ::protobuf::Message>::default_instance()
        }
    }

    impl Message {
        pub fn new() -> Message {
            ::std::default::Default::default()
        }

        // optional uint32 author_account_id = 1;

        pub fn author_account_id(&self) -> u32 {
            self.author_account_id.unwrap_or(0)
        }

        pub fn clear_author_account_id(&mut self) {
            self.author_account_id = ::std::option::Option::None;
        }

        pub fn has_author_account_id(&self) -> bool {
            self.author_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_author_account_id(&mut self, v: u32) {
            self.author_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string message = 3;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "author_account_id",
                |m: &Message| { &m.author_account_id },
                |m: &mut Message| { &mut m.author_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &Message| { &m.timestamp },
                |m: &mut Message| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message",
                |m: &Message| { &m.message },
                |m: &mut Message| { &mut m.message },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
                "CMsgDOTALeagueMessages.Message",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Message {
        const NAME: &'static str = "Message";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.author_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.author_account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.author_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Message {
            Message::new()
        }

        fn clear(&mut self) {
            self.author_account_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Message {
            static instance: Message = Message {
                author_account_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                message: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Message {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeagueMessages.Message").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Message {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Message {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeaguePrizePool)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeaguePrizePool {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeaguePrizePool.prize_pool)
    pub prize_pool: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTALeaguePrizePool.increment_per_second)
    pub increment_per_second: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeaguePrizePool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeaguePrizePool {
    fn default() -> &'a CMsgDOTALeaguePrizePool {
        <CMsgDOTALeaguePrizePool as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeaguePrizePool {
    pub fn new() -> CMsgDOTALeaguePrizePool {
        ::std::default::Default::default()
    }

    // optional uint32 prize_pool = 1;

    pub fn prize_pool(&self) -> u32 {
        self.prize_pool.unwrap_or(0)
    }

    pub fn clear_prize_pool(&mut self) {
        self.prize_pool = ::std::option::Option::None;
    }

    pub fn has_prize_pool(&self) -> bool {
        self.prize_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_pool(&mut self, v: u32) {
        self.prize_pool = ::std::option::Option::Some(v);
    }

    // optional float increment_per_second = 2;

    pub fn increment_per_second(&self) -> f32 {
        self.increment_per_second.unwrap_or(0.)
    }

    pub fn clear_increment_per_second(&mut self) {
        self.increment_per_second = ::std::option::Option::None;
    }

    pub fn has_increment_per_second(&self) -> bool {
        self.increment_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_increment_per_second(&mut self, v: f32) {
        self.increment_per_second = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prize_pool",
            |m: &CMsgDOTALeaguePrizePool| { &m.prize_pool },
            |m: &mut CMsgDOTALeaguePrizePool| { &mut m.prize_pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "increment_per_second",
            |m: &CMsgDOTALeaguePrizePool| { &m.increment_per_second },
            |m: &mut CMsgDOTALeaguePrizePool| { &mut m.increment_per_second },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeaguePrizePool>(
            "CMsgDOTALeaguePrizePool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeaguePrizePool {
    const NAME: &'static str = "CMsgDOTALeaguePrizePool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.prize_pool = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.increment_per_second = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.prize_pool {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.increment_per_second {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.prize_pool {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.increment_per_second {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeaguePrizePool {
        CMsgDOTALeaguePrizePool::new()
    }

    fn clear(&mut self) {
        self.prize_pool = ::std::option::Option::None;
        self.increment_per_second = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeaguePrizePool {
        static instance: CMsgDOTALeaguePrizePool = CMsgDOTALeaguePrizePool {
            prize_pool: ::std::option::Option::None,
            increment_per_second: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeaguePrizePool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeaguePrizePool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeaguePrizePool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeaguePrizePool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueInfoListAdminsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueInfoListAdminsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueInfoListAdminsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueInfoListAdminsRequest {
    fn default() -> &'a CMsgDOTALeagueInfoListAdminsRequest {
        <CMsgDOTALeagueInfoListAdminsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueInfoListAdminsRequest {
    pub fn new() -> CMsgDOTALeagueInfoListAdminsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueInfoListAdminsRequest>(
            "CMsgDOTALeagueInfoListAdminsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueInfoListAdminsRequest {
    const NAME: &'static str = "CMsgDOTALeagueInfoListAdminsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueInfoListAdminsRequest {
        CMsgDOTALeagueInfoListAdminsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueInfoListAdminsRequest {
        static instance: CMsgDOTALeagueInfoListAdminsRequest = CMsgDOTALeagueInfoListAdminsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueInfoListAdminsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueInfoListAdminsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueInfoListAdminsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueInfoListAdminsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueAvailableLobbyNodesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueAvailableLobbyNodesRequest {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueAvailableLobbyNodesRequest.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueAvailableLobbyNodesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueAvailableLobbyNodesRequest {
    fn default() -> &'a CMsgDOTALeagueAvailableLobbyNodesRequest {
        <CMsgDOTALeagueAvailableLobbyNodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueAvailableLobbyNodesRequest {
    pub fn new() -> CMsgDOTALeagueAvailableLobbyNodesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 league_id = 1;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgDOTALeagueAvailableLobbyNodesRequest| { &m.league_id },
            |m: &mut CMsgDOTALeagueAvailableLobbyNodesRequest| { &mut m.league_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueAvailableLobbyNodesRequest>(
            "CMsgDOTALeagueAvailableLobbyNodesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueAvailableLobbyNodesRequest {
    const NAME: &'static str = "CMsgDOTALeagueAvailableLobbyNodesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueAvailableLobbyNodesRequest {
        CMsgDOTALeagueAvailableLobbyNodesRequest::new()
    }

    fn clear(&mut self) {
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueAvailableLobbyNodesRequest {
        static instance: CMsgDOTALeagueAvailableLobbyNodesRequest = CMsgDOTALeagueAvailableLobbyNodesRequest {
            league_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueAvailableLobbyNodesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueAvailableLobbyNodesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueAvailableLobbyNodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueAvailableLobbyNodesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueAvailableLobbyNodes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueAvailableLobbyNodes {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueAvailableLobbyNodes.node_infos)
    pub node_infos: ::std::vec::Vec<cmsg_dotaleague_available_lobby_nodes::NodeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueAvailableLobbyNodes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueAvailableLobbyNodes {
    fn default() -> &'a CMsgDOTALeagueAvailableLobbyNodes {
        <CMsgDOTALeagueAvailableLobbyNodes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueAvailableLobbyNodes {
    pub fn new() -> CMsgDOTALeagueAvailableLobbyNodes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "node_infos",
            |m: &CMsgDOTALeagueAvailableLobbyNodes| { &m.node_infos },
            |m: &mut CMsgDOTALeagueAvailableLobbyNodes| { &mut m.node_infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueAvailableLobbyNodes>(
            "CMsgDOTALeagueAvailableLobbyNodes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueAvailableLobbyNodes {
    const NAME: &'static str = "CMsgDOTALeagueAvailableLobbyNodes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node_infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.node_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.node_infos {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueAvailableLobbyNodes {
        CMsgDOTALeagueAvailableLobbyNodes::new()
    }

    fn clear(&mut self) {
        self.node_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueAvailableLobbyNodes {
        static instance: CMsgDOTALeagueAvailableLobbyNodes = CMsgDOTALeagueAvailableLobbyNodes {
            node_infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueAvailableLobbyNodes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueAvailableLobbyNodes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueAvailableLobbyNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueAvailableLobbyNodes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTALeagueAvailableLobbyNodes`
pub mod cmsg_dotaleague_available_lobby_nodes {
    // @@protoc_insertion_point(message:dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NodeInfo {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_id)
        pub node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
        pub node_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
        pub node_group_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_1)
        pub team_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_2)
        pub team_id_2: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NodeInfo {
        fn default() -> &'a NodeInfo {
            <NodeInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl NodeInfo {
        pub fn new() -> NodeInfo {
            ::std::default::Default::default()
        }

        // optional uint32 node_id = 1;

        pub fn node_id(&self) -> u32 {
            self.node_id.unwrap_or(0)
        }

        pub fn clear_node_id(&mut self) {
            self.node_id = ::std::option::Option::None;
        }

        pub fn has_node_id(&self) -> bool {
            self.node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_id(&mut self, v: u32) {
            self.node_id = ::std::option::Option::Some(v);
        }

        // optional string node_name = 2;

        pub fn node_name(&self) -> &str {
            match self.node_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_node_name(&mut self) {
            self.node_name = ::std::option::Option::None;
        }

        pub fn has_node_name(&self) -> bool {
            self.node_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_name(&mut self, v: ::std::string::String) {
            self.node_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_node_name(&mut self) -> &mut ::std::string::String {
            if self.node_name.is_none() {
                self.node_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.node_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_node_name(&mut self) -> ::std::string::String {
            self.node_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string node_group_name = 3;

        pub fn node_group_name(&self) -> &str {
            match self.node_group_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_node_group_name(&mut self) {
            self.node_group_name = ::std::option::Option::None;
        }

        pub fn has_node_group_name(&self) -> bool {
            self.node_group_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_group_name(&mut self, v: ::std::string::String) {
            self.node_group_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_node_group_name(&mut self) -> &mut ::std::string::String {
            if self.node_group_name.is_none() {
                self.node_group_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.node_group_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_node_group_name(&mut self) -> ::std::string::String {
            self.node_group_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id_1 = 4;

        pub fn team_id_1(&self) -> u32 {
            self.team_id_1.unwrap_or(0)
        }

        pub fn clear_team_id_1(&mut self) {
            self.team_id_1 = ::std::option::Option::None;
        }

        pub fn has_team_id_1(&self) -> bool {
            self.team_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_1(&mut self, v: u32) {
            self.team_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_2 = 5;

        pub fn team_id_2(&self) -> u32 {
            self.team_id_2.unwrap_or(0)
        }

        pub fn clear_team_id_2(&mut self) {
            self.team_id_2 = ::std::option::Option::None;
        }

        pub fn has_team_id_2(&self) -> bool {
            self.team_id_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_2(&mut self, v: u32) {
            self.team_id_2 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "node_id",
                |m: &NodeInfo| { &m.node_id },
                |m: &mut NodeInfo| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "node_name",
                |m: &NodeInfo| { &m.node_name },
                |m: &mut NodeInfo| { &mut m.node_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "node_group_name",
                |m: &NodeInfo| { &m.node_group_name },
                |m: &mut NodeInfo| { &mut m.node_group_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id_1",
                |m: &NodeInfo| { &m.team_id_1 },
                |m: &mut NodeInfo| { &mut m.team_id_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id_2",
                |m: &NodeInfo| { &m.team_id_2 },
                |m: &mut NodeInfo| { &mut m.team_id_2 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeInfo>(
                "CMsgDOTALeagueAvailableLobbyNodes.NodeInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NodeInfo {
        const NAME: &'static str = "NodeInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.node_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.node_group_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.team_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.team_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.node_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.node_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.node_group_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_id_1 {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.team_id_2 {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.node_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.node_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.node_group_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_id_1 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.team_id_2 {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NodeInfo {
            NodeInfo::new()
        }

        fn clear(&mut self) {
            self.node_id = ::std::option::Option::None;
            self.node_name = ::std::option::Option::None;
            self.node_group_name = ::std::option::Option::None;
            self.team_id_1 = ::std::option::Option::None;
            self.team_id_2 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NodeInfo {
            static instance: NodeInfo = NodeInfo {
                node_id: ::std::option::Option::None,
                node_name: ::std::option::Option::None,
                node_group_name: ::std::option::Option::None,
                team_id_1: ::std::option::Option::None,
                team_id_2: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NodeInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeagueAvailableLobbyNodes.NodeInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NodeInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NodeInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTALeagueNodeResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueNodeResults {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.node_results)
    pub node_results: ::std::vec::Vec<cmsg_dotaleague_node_results::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueNodeResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueNodeResults {
    fn default() -> &'a CMsgDOTALeagueNodeResults {
        <CMsgDOTALeagueNodeResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueNodeResults {
    pub fn new() -> CMsgDOTALeagueNodeResults {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "node_results",
            |m: &CMsgDOTALeagueNodeResults| { &m.node_results },
            |m: &mut CMsgDOTALeagueNodeResults| { &mut m.node_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTALeagueNodeResults>(
            "CMsgDOTALeagueNodeResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTALeagueNodeResults {
    const NAME: &'static str = "CMsgDOTALeagueNodeResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node_results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.node_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.node_results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueNodeResults {
        CMsgDOTALeagueNodeResults::new()
    }

    fn clear(&mut self) {
        self.node_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueNodeResults {
        static instance: CMsgDOTALeagueNodeResults = CMsgDOTALeagueNodeResults {
            node_results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTALeagueNodeResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTALeagueNodeResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTALeagueNodeResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueNodeResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTALeagueNodeResults`
pub mod cmsg_dotaleague_node_results {
    // @@protoc_insertion_point(message:dota.CMsgDOTALeagueNodeResults.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.node_id)
        pub node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.winning_node_id)
        pub winning_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.losing_node_id)
        pub losing_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.incoming_node_id_1)
        pub incoming_node_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.incoming_node_id_2)
        pub incoming_node_id_2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.team_id_1)
        pub team_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.team_id_2)
        pub team_id_2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.team_1_name)
        pub team_1_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.team_2_name)
        pub team_2_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.team_1_wins)
        pub team_1_wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.team_2_wins)
        pub team_2_wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.winning_team_id)
        pub winning_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.losing_team_id)
        pub losing_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.has_started)
        pub has_started: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.is_completed)
        pub is_completed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.scheduled_time)
        pub scheduled_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTALeagueNodeResults.Result.match_ids)
        pub match_ids: ::std::vec::Vec<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTALeagueNodeResults.Result.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional uint32 node_id = 1;

        pub fn node_id(&self) -> u32 {
            self.node_id.unwrap_or(0)
        }

        pub fn clear_node_id(&mut self) {
            self.node_id = ::std::option::Option::None;
        }

        pub fn has_node_id(&self) -> bool {
            self.node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_id(&mut self, v: u32) {
            self.node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 winning_node_id = 2;

        pub fn winning_node_id(&self) -> u32 {
            self.winning_node_id.unwrap_or(0)
        }

        pub fn clear_winning_node_id(&mut self) {
            self.winning_node_id = ::std::option::Option::None;
        }

        pub fn has_winning_node_id(&self) -> bool {
            self.winning_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_winning_node_id(&mut self, v: u32) {
            self.winning_node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 losing_node_id = 3;

        pub fn losing_node_id(&self) -> u32 {
            self.losing_node_id.unwrap_or(0)
        }

        pub fn clear_losing_node_id(&mut self) {
            self.losing_node_id = ::std::option::Option::None;
        }

        pub fn has_losing_node_id(&self) -> bool {
            self.losing_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losing_node_id(&mut self, v: u32) {
            self.losing_node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 incoming_node_id_1 = 4;

        pub fn incoming_node_id_1(&self) -> u32 {
            self.incoming_node_id_1.unwrap_or(0)
        }

        pub fn clear_incoming_node_id_1(&mut self) {
            self.incoming_node_id_1 = ::std::option::Option::None;
        }

        pub fn has_incoming_node_id_1(&self) -> bool {
            self.incoming_node_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_incoming_node_id_1(&mut self, v: u32) {
            self.incoming_node_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 incoming_node_id_2 = 5;

        pub fn incoming_node_id_2(&self) -> u32 {
            self.incoming_node_id_2.unwrap_or(0)
        }

        pub fn clear_incoming_node_id_2(&mut self) {
            self.incoming_node_id_2 = ::std::option::Option::None;
        }

        pub fn has_incoming_node_id_2(&self) -> bool {
            self.incoming_node_id_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_incoming_node_id_2(&mut self, v: u32) {
            self.incoming_node_id_2 = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_1 = 6;

        pub fn team_id_1(&self) -> u32 {
            self.team_id_1.unwrap_or(0)
        }

        pub fn clear_team_id_1(&mut self) {
            self.team_id_1 = ::std::option::Option::None;
        }

        pub fn has_team_id_1(&self) -> bool {
            self.team_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_1(&mut self, v: u32) {
            self.team_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_2 = 7;

        pub fn team_id_2(&self) -> u32 {
            self.team_id_2.unwrap_or(0)
        }

        pub fn clear_team_id_2(&mut self) {
            self.team_id_2 = ::std::option::Option::None;
        }

        pub fn has_team_id_2(&self) -> bool {
            self.team_id_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_2(&mut self, v: u32) {
            self.team_id_2 = ::std::option::Option::Some(v);
        }

        // optional string team_1_name = 8;

        pub fn team_1_name(&self) -> &str {
            match self.team_1_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_1_name(&mut self) {
            self.team_1_name = ::std::option::Option::None;
        }

        pub fn has_team_1_name(&self) -> bool {
            self.team_1_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_1_name(&mut self, v: ::std::string::String) {
            self.team_1_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_1_name(&mut self) -> &mut ::std::string::String {
            if self.team_1_name.is_none() {
                self.team_1_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_1_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_1_name(&mut self) -> ::std::string::String {
            self.team_1_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_2_name = 9;

        pub fn team_2_name(&self) -> &str {
            match self.team_2_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_2_name(&mut self) {
            self.team_2_name = ::std::option::Option::None;
        }

        pub fn has_team_2_name(&self) -> bool {
            self.team_2_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_2_name(&mut self, v: ::std::string::String) {
            self.team_2_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_2_name(&mut self) -> &mut ::std::string::String {
            if self.team_2_name.is_none() {
                self.team_2_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_2_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_2_name(&mut self) -> ::std::string::String {
            self.team_2_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_1_wins = 10;

        pub fn team_1_wins(&self) -> u32 {
            self.team_1_wins.unwrap_or(0)
        }

        pub fn clear_team_1_wins(&mut self) {
            self.team_1_wins = ::std::option::Option::None;
        }

        pub fn has_team_1_wins(&self) -> bool {
            self.team_1_wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_1_wins(&mut self, v: u32) {
            self.team_1_wins = ::std::option::Option::Some(v);
        }

        // optional uint32 team_2_wins = 11;

        pub fn team_2_wins(&self) -> u32 {
            self.team_2_wins.unwrap_or(0)
        }

        pub fn clear_team_2_wins(&mut self) {
            self.team_2_wins = ::std::option::Option::None;
        }

        pub fn has_team_2_wins(&self) -> bool {
            self.team_2_wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_2_wins(&mut self, v: u32) {
            self.team_2_wins = ::std::option::Option::Some(v);
        }

        // optional uint32 winning_team_id = 12;

        pub fn winning_team_id(&self) -> u32 {
            self.winning_team_id.unwrap_or(0)
        }

        pub fn clear_winning_team_id(&mut self) {
            self.winning_team_id = ::std::option::Option::None;
        }

        pub fn has_winning_team_id(&self) -> bool {
            self.winning_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_winning_team_id(&mut self, v: u32) {
            self.winning_team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 losing_team_id = 13;

        pub fn losing_team_id(&self) -> u32 {
            self.losing_team_id.unwrap_or(0)
        }

        pub fn clear_losing_team_id(&mut self) {
            self.losing_team_id = ::std::option::Option::None;
        }

        pub fn has_losing_team_id(&self) -> bool {
            self.losing_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losing_team_id(&mut self, v: u32) {
            self.losing_team_id = ::std::option::Option::Some(v);
        }

        // optional bool has_started = 14;

        pub fn has_started(&self) -> bool {
            self.has_started.unwrap_or(false)
        }

        pub fn clear_has_started(&mut self) {
            self.has_started = ::std::option::Option::None;
        }

        pub fn has_has_started(&self) -> bool {
            self.has_started.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_started(&mut self, v: bool) {
            self.has_started = ::std::option::Option::Some(v);
        }

        // optional bool is_completed = 15;

        pub fn is_completed(&self) -> bool {
            self.is_completed.unwrap_or(false)
        }

        pub fn clear_is_completed(&mut self) {
            self.is_completed = ::std::option::Option::None;
        }

        pub fn has_is_completed(&self) -> bool {
            self.is_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_completed(&mut self, v: bool) {
            self.is_completed = ::std::option::Option::Some(v);
        }

        // optional uint32 scheduled_time = 16;

        pub fn scheduled_time(&self) -> u32 {
            self.scheduled_time.unwrap_or(0)
        }

        pub fn clear_scheduled_time(&mut self) {
            self.scheduled_time = ::std::option::Option::None;
        }

        pub fn has_scheduled_time(&self) -> bool {
            self.scheduled_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scheduled_time(&mut self, v: u32) {
            self.scheduled_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(17);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "node_id",
                |m: &Result| { &m.node_id },
                |m: &mut Result| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "winning_node_id",
                |m: &Result| { &m.winning_node_id },
                |m: &mut Result| { &mut m.winning_node_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "losing_node_id",
                |m: &Result| { &m.losing_node_id },
                |m: &mut Result| { &mut m.losing_node_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "incoming_node_id_1",
                |m: &Result| { &m.incoming_node_id_1 },
                |m: &mut Result| { &mut m.incoming_node_id_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "incoming_node_id_2",
                |m: &Result| { &m.incoming_node_id_2 },
                |m: &mut Result| { &mut m.incoming_node_id_2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id_1",
                |m: &Result| { &m.team_id_1 },
                |m: &mut Result| { &mut m.team_id_1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id_2",
                |m: &Result| { &m.team_id_2 },
                |m: &mut Result| { &mut m.team_id_2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_1_name",
                |m: &Result| { &m.team_1_name },
                |m: &mut Result| { &mut m.team_1_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_2_name",
                |m: &Result| { &m.team_2_name },
                |m: &mut Result| { &mut m.team_2_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_1_wins",
                |m: &Result| { &m.team_1_wins },
                |m: &mut Result| { &mut m.team_1_wins },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_2_wins",
                |m: &Result| { &m.team_2_wins },
                |m: &mut Result| { &mut m.team_2_wins },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "winning_team_id",
                |m: &Result| { &m.winning_team_id },
                |m: &mut Result| { &mut m.winning_team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "losing_team_id",
                |m: &Result| { &m.losing_team_id },
                |m: &mut Result| { &mut m.losing_team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "has_started",
                |m: &Result| { &m.has_started },
                |m: &mut Result| { &mut m.has_started },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_completed",
                |m: &Result| { &m.is_completed },
                |m: &mut Result| { &mut m.is_completed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scheduled_time",
                |m: &Result| { &m.scheduled_time },
                |m: &mut Result| { &mut m.scheduled_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "match_ids",
                |m: &Result| { &m.match_ids },
                |m: &mut Result| { &mut m.match_ids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Result>(
                "CMsgDOTALeagueNodeResults.Result",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.winning_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.losing_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.incoming_node_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.incoming_node_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.team_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.team_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.team_1_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.team_2_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.team_1_wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.team_2_wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.winning_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.losing_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.has_started = ::std::option::Option::Some(is.read_bool()?);
                    },
                    120 => {
                        self.is_completed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.scheduled_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    138 => {
                        is.read_repeated_packed_uint64_into(&mut self.match_ids)?;
                    },
                    136 => {
                        self.match_ids.push(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.node_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.winning_node_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.losing_node_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.incoming_node_id_1 {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.incoming_node_id_2 {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.team_id_1 {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.team_id_2 {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.team_1_name.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.team_2_name.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.team_1_wins {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.team_2_wins {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.winning_team_id {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.losing_team_id {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.has_started {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_completed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.scheduled_time {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            for value in &self.match_ids {
                my_size += ::protobuf::rt::uint64_size(17, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.node_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.winning_node_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.losing_node_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.incoming_node_id_1 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.incoming_node_id_2 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.team_id_1 {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.team_id_2 {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.team_1_name.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.team_2_name.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.team_1_wins {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.team_2_wins {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.winning_team_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.losing_team_id {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.has_started {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.is_completed {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.scheduled_time {
                os.write_uint32(16, v)?;
            }
            for v in &self.match_ids {
                os.write_uint64(17, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.node_id = ::std::option::Option::None;
            self.winning_node_id = ::std::option::Option::None;
            self.losing_node_id = ::std::option::Option::None;
            self.incoming_node_id_1 = ::std::option::Option::None;
            self.incoming_node_id_2 = ::std::option::Option::None;
            self.team_id_1 = ::std::option::Option::None;
            self.team_id_2 = ::std::option::Option::None;
            self.team_1_name = ::std::option::Option::None;
            self.team_2_name = ::std::option::Option::None;
            self.team_1_wins = ::std::option::Option::None;
            self.team_2_wins = ::std::option::Option::None;
            self.winning_team_id = ::std::option::Option::None;
            self.losing_team_id = ::std::option::Option::None;
            self.has_started = ::std::option::Option::None;
            self.is_completed = ::std::option::Option::None;
            self.scheduled_time = ::std::option::Option::None;
            self.match_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                node_id: ::std::option::Option::None,
                winning_node_id: ::std::option::Option::None,
                losing_node_id: ::std::option::Option::None,
                incoming_node_id_1: ::std::option::Option::None,
                incoming_node_id_2: ::std::option::Option::None,
                team_id_1: ::std::option::Option::None,
                team_id_2: ::std::option::Option::None,
                team_1_name: ::std::option::Option::None,
                team_2_name: ::std::option::Option::None,
                team_1_wins: ::std::option::Option::None,
                team_2_wins: ::std::option::Option::None,
                winning_team_id: ::std::option::Option::None,
                losing_team_id: ::std::option::Option::None,
                has_started: ::std::option::Option::None,
                is_completed: ::std::option::Option::None,
                scheduled_time: ::std::option::Option::None,
                match_ids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Result {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTALeagueNodeResults.Result").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Result {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Result {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTADPCLeagueResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCLeagueResults {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.results)
    pub results: ::std::vec::Vec<cmsg_dotadpcleague_results::Result>,
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.points)
    pub points: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.dollars)
    pub dollars: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCLeagueResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCLeagueResults {
    fn default() -> &'a CMsgDOTADPCLeagueResults {
        <CMsgDOTADPCLeagueResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCLeagueResults {
    pub fn new() -> CMsgDOTADPCLeagueResults {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CMsgDOTADPCLeagueResults| { &m.results },
            |m: &mut CMsgDOTADPCLeagueResults| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "points",
            |m: &CMsgDOTADPCLeagueResults| { &m.points },
            |m: &mut CMsgDOTADPCLeagueResults| { &mut m.points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dollars",
            |m: &CMsgDOTADPCLeagueResults| { &m.dollars },
            |m: &mut CMsgDOTADPCLeagueResults| { &mut m.dollars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTADPCLeagueResults>(
            "CMsgDOTADPCLeagueResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTADPCLeagueResults {
    const NAME: &'static str = "CMsgDOTADPCLeagueResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.points)?;
                },
                16 => {
                    self.points.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.dollars)?;
                },
                24 => {
                    self.dollars.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.points {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.dollars {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.points {
            os.write_uint32(2, *v)?;
        };
        for v in &self.dollars {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCLeagueResults {
        CMsgDOTADPCLeagueResults::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.points.clear();
        self.dollars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCLeagueResults {
        static instance: CMsgDOTADPCLeagueResults = CMsgDOTADPCLeagueResults {
            results: ::std::vec::Vec::new(),
            points: ::std::vec::Vec::new(),
            dollars: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTADPCLeagueResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTADPCLeagueResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTADPCLeagueResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTADPCLeagueResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTADPCLeagueResults`
pub mod cmsg_dotadpcleague_results {
    // @@protoc_insertion_point(message:dota.CMsgDOTADPCLeagueResults.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.standing)
        pub standing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.points)
        pub points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.earnings)
        pub earnings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.phase)
        pub phase: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeaguePhase>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCLeagueResults.Result.team_abbreviation)
        pub team_abbreviation: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCLeagueResults.Result.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional uint32 standing = 1;

        pub fn standing(&self) -> u32 {
            self.standing.unwrap_or(0)
        }

        pub fn clear_standing(&mut self) {
            self.standing = ::std::option::Option::None;
        }

        pub fn has_standing(&self) -> bool {
            self.standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_standing(&mut self, v: u32) {
            self.standing = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 3;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 team_logo = 4;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 5;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 points = 6;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }

        // optional uint32 earnings = 7;

        pub fn earnings(&self) -> u32 {
            self.earnings.unwrap_or(0)
        }

        pub fn clear_earnings(&mut self) {
            self.earnings = ::std::option::Option::None;
        }

        pub fn has_earnings(&self) -> bool {
            self.earnings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_earnings(&mut self, v: u32) {
            self.earnings = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 8;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional .dota.ELeaguePhase phase = 9;

        pub fn phase(&self) -> super::super::dota_shared_enums::ELeaguePhase {
            match self.phase {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeaguePhase::LEAGUE_PHASE_UNSET),
                None => super::super::dota_shared_enums::ELeaguePhase::LEAGUE_PHASE_UNSET,
            }
        }

        pub fn clear_phase(&mut self) {
            self.phase = ::std::option::Option::None;
        }

        pub fn has_phase(&self) -> bool {
            self.phase.is_some()
        }

        // Param is passed by value, moved
        pub fn set_phase(&mut self, v: super::super::dota_shared_enums::ELeaguePhase) {
            self.phase = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string team_abbreviation = 10;

        pub fn team_abbreviation(&self) -> &str {
            match self.team_abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_abbreviation(&mut self) {
            self.team_abbreviation = ::std::option::Option::None;
        }

        pub fn has_team_abbreviation(&self) -> bool {
            self.team_abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
            self.team_abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.team_abbreviation.is_none() {
                self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
            self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "standing",
                |m: &Result| { &m.standing },
                |m: &mut Result| { &mut m.standing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &Result| { &m.team_id },
                |m: &mut Result| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_name",
                |m: &Result| { &m.team_name },
                |m: &mut Result| { &mut m.team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo",
                |m: &Result| { &m.team_logo },
                |m: &mut Result| { &mut m.team_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo_url",
                |m: &Result| { &m.team_logo_url },
                |m: &mut Result| { &mut m.team_logo_url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "points",
                |m: &Result| { &m.points },
                |m: &mut Result| { &mut m.points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "earnings",
                |m: &Result| { &m.earnings },
                |m: &mut Result| { &mut m.earnings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &Result| { &m.timestamp },
                |m: &mut Result| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "phase",
                |m: &Result| { &m.phase },
                |m: &mut Result| { &mut m.phase },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_abbreviation",
                |m: &Result| { &m.team_abbreviation },
                |m: &mut Result| { &mut m.team_abbreviation },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Result>(
                "CMsgDOTADPCLeagueResults.Result",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.standing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.team_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    42 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.earnings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.phase = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    82 => {
                        self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.standing {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.points {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.earnings {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.phase {
                my_size += ::protobuf::rt::int32_size(9, v.value());
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.standing {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.earnings {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.phase {
                os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                os.write_string(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.standing = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.earnings = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.phase = ::std::option::Option::None;
            self.team_abbreviation = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                standing: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                points: ::std::option::Option::None,
                earnings: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                phase: ::std::option::Option::None,
                team_abbreviation: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Result {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTADPCLeagueResults.Result").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Result {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Result {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTADPCTeamResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCTeamResults {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCTeamResults.results)
    pub results: ::std::vec::Vec<cmsg_dotadpcteam_results::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCTeamResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCTeamResults {
    fn default() -> &'a CMsgDOTADPCTeamResults {
        <CMsgDOTADPCTeamResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCTeamResults {
    pub fn new() -> CMsgDOTADPCTeamResults {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CMsgDOTADPCTeamResults| { &m.results },
            |m: &mut CMsgDOTADPCTeamResults| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTADPCTeamResults>(
            "CMsgDOTADPCTeamResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTADPCTeamResults {
    const NAME: &'static str = "CMsgDOTADPCTeamResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCTeamResults {
        CMsgDOTADPCTeamResults::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCTeamResults {
        static instance: CMsgDOTADPCTeamResults = CMsgDOTADPCTeamResults {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTADPCTeamResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTADPCTeamResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTADPCTeamResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTADPCTeamResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTADPCTeamResults`
pub mod cmsg_dotadpcteam_results {
    // @@protoc_insertion_point(message:dota.CMsgDOTADPCTeamResults.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCTeamResults.Result.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCTeamResults.Result.standing)
        pub standing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCTeamResults.Result.points)
        pub points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCTeamResults.Result.earnings)
        pub earnings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCTeamResults.Result.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCTeamResults.Result.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 standing = 2;

        pub fn standing(&self) -> u32 {
            self.standing.unwrap_or(0)
        }

        pub fn clear_standing(&mut self) {
            self.standing = ::std::option::Option::None;
        }

        pub fn has_standing(&self) -> bool {
            self.standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_standing(&mut self, v: u32) {
            self.standing = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }

        // optional uint32 earnings = 4;

        pub fn earnings(&self) -> u32 {
            self.earnings.unwrap_or(0)
        }

        pub fn clear_earnings(&mut self) {
            self.earnings = ::std::option::Option::None;
        }

        pub fn has_earnings(&self) -> bool {
            self.earnings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_earnings(&mut self, v: u32) {
            self.earnings = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 5;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &Result| { &m.league_id },
                |m: &mut Result| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "standing",
                |m: &Result| { &m.standing },
                |m: &mut Result| { &mut m.standing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "points",
                |m: &Result| { &m.points },
                |m: &mut Result| { &mut m.points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "earnings",
                |m: &Result| { &m.earnings },
                |m: &mut Result| { &mut m.earnings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &Result| { &m.timestamp },
                |m: &mut Result| { &mut m.timestamp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Result>(
                "CMsgDOTADPCTeamResults.Result",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.standing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.earnings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.standing {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.earnings {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.standing {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.earnings {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.standing = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.earnings = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                league_id: ::std::option::Option::None,
                standing: ::std::option::Option::None,
                points: ::std::option::Option::None,
                earnings: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Result {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTADPCTeamResults.Result").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Result {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Result {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTADPCSeasonResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCSeasonResults {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.results)
    pub results: ::std::vec::Vec<cmsg_dotadpcseason_results::TeamResult>,
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.standings)
    pub standings: ::std::vec::Vec<cmsg_dotadpcseason_results::Standing>,
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.major_wildcard_standings)
    pub major_wildcard_standings: ::std::vec::Vec<cmsg_dotadpcseason_results::StandingEntry>,
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.major_group_standings)
    pub major_group_standings: ::std::vec::Vec<cmsg_dotadpcseason_results::StandingEntry>,
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.major_playoff_standings)
    pub major_playoff_standings: ::std::vec::Vec<cmsg_dotadpcseason_results::StandingEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCSeasonResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCSeasonResults {
    fn default() -> &'a CMsgDOTADPCSeasonResults {
        <CMsgDOTADPCSeasonResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCSeasonResults {
    pub fn new() -> CMsgDOTADPCSeasonResults {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CMsgDOTADPCSeasonResults| { &m.results },
            |m: &mut CMsgDOTADPCSeasonResults| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "standings",
            |m: &CMsgDOTADPCSeasonResults| { &m.standings },
            |m: &mut CMsgDOTADPCSeasonResults| { &mut m.standings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "major_wildcard_standings",
            |m: &CMsgDOTADPCSeasonResults| { &m.major_wildcard_standings },
            |m: &mut CMsgDOTADPCSeasonResults| { &mut m.major_wildcard_standings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "major_group_standings",
            |m: &CMsgDOTADPCSeasonResults| { &m.major_group_standings },
            |m: &mut CMsgDOTADPCSeasonResults| { &mut m.major_group_standings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "major_playoff_standings",
            |m: &CMsgDOTADPCSeasonResults| { &m.major_playoff_standings },
            |m: &mut CMsgDOTADPCSeasonResults| { &mut m.major_playoff_standings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTADPCSeasonResults>(
            "CMsgDOTADPCSeasonResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTADPCSeasonResults {
    const NAME: &'static str = "CMsgDOTADPCSeasonResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                18 => {
                    self.standings.push(is.read_message()?);
                },
                26 => {
                    self.major_wildcard_standings.push(is.read_message()?);
                },
                34 => {
                    self.major_group_standings.push(is.read_message()?);
                },
                42 => {
                    self.major_playoff_standings.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.standings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.major_wildcard_standings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.major_group_standings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.major_playoff_standings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.standings {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.major_wildcard_standings {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.major_group_standings {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.major_playoff_standings {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCSeasonResults {
        CMsgDOTADPCSeasonResults::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.standings.clear();
        self.major_wildcard_standings.clear();
        self.major_group_standings.clear();
        self.major_playoff_standings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCSeasonResults {
        static instance: CMsgDOTADPCSeasonResults = CMsgDOTADPCSeasonResults {
            results: ::std::vec::Vec::new(),
            standings: ::std::vec::Vec::new(),
            major_wildcard_standings: ::std::vec::Vec::new(),
            major_group_standings: ::std::vec::Vec::new(),
            major_playoff_standings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTADPCSeasonResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTADPCSeasonResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTADPCSeasonResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTADPCSeasonResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDOTADPCSeasonResults`
pub mod cmsg_dotadpcseason_results {
    // @@protoc_insertion_point(message:dota.CMsgDOTADPCSeasonResults.TeamLeagueResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamLeagueResult {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamLeagueResult.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamLeagueResult.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamLeagueResult.standing)
        pub standing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamLeagueResult.points)
        pub points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamLeagueResult.earnings)
        pub earnings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamLeagueResult.audit_action)
        pub audit_action: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamLeagueResult.audit_data)
        pub audit_data: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCSeasonResults.TeamLeagueResult.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamLeagueResult {
        fn default() -> &'a TeamLeagueResult {
            <TeamLeagueResult as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamLeagueResult {
        pub fn new() -> TeamLeagueResult {
            ::std::default::Default::default()
        }

        // optional uint32 timestamp = 1;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 league_id = 2;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 standing = 3;

        pub fn standing(&self) -> u32 {
            self.standing.unwrap_or(0)
        }

        pub fn clear_standing(&mut self) {
            self.standing = ::std::option::Option::None;
        }

        pub fn has_standing(&self) -> bool {
            self.standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_standing(&mut self, v: u32) {
            self.standing = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 4;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }

        // optional uint32 earnings = 5;

        pub fn earnings(&self) -> u32 {
            self.earnings.unwrap_or(0)
        }

        pub fn clear_earnings(&mut self) {
            self.earnings = ::std::option::Option::None;
        }

        pub fn has_earnings(&self) -> bool {
            self.earnings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_earnings(&mut self, v: u32) {
            self.earnings = ::std::option::Option::Some(v);
        }

        // optional uint32 audit_action = 6;

        pub fn audit_action(&self) -> u32 {
            self.audit_action.unwrap_or(0)
        }

        pub fn clear_audit_action(&mut self) {
            self.audit_action = ::std::option::Option::None;
        }

        pub fn has_audit_action(&self) -> bool {
            self.audit_action.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit_action(&mut self, v: u32) {
            self.audit_action = ::std::option::Option::Some(v);
        }

        // optional uint32 audit_data = 7;

        pub fn audit_data(&self) -> u32 {
            self.audit_data.unwrap_or(0)
        }

        pub fn clear_audit_data(&mut self) {
            self.audit_data = ::std::option::Option::None;
        }

        pub fn has_audit_data(&self) -> bool {
            self.audit_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit_data(&mut self, v: u32) {
            self.audit_data = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &TeamLeagueResult| { &m.timestamp },
                |m: &mut TeamLeagueResult| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "league_id",
                |m: &TeamLeagueResult| { &m.league_id },
                |m: &mut TeamLeagueResult| { &mut m.league_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "standing",
                |m: &TeamLeagueResult| { &m.standing },
                |m: &mut TeamLeagueResult| { &mut m.standing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "points",
                |m: &TeamLeagueResult| { &m.points },
                |m: &mut TeamLeagueResult| { &mut m.points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "earnings",
                |m: &TeamLeagueResult| { &m.earnings },
                |m: &mut TeamLeagueResult| { &mut m.earnings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "audit_action",
                |m: &TeamLeagueResult| { &m.audit_action },
                |m: &mut TeamLeagueResult| { &mut m.audit_action },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "audit_data",
                |m: &TeamLeagueResult| { &m.audit_data },
                |m: &mut TeamLeagueResult| { &mut m.audit_data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamLeagueResult>(
                "CMsgDOTADPCSeasonResults.TeamLeagueResult",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamLeagueResult {
        const NAME: &'static str = "TeamLeagueResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.standing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.earnings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.audit_data = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.league_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.standing {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.points {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.earnings {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.audit_action {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.audit_data {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.standing {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.earnings {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.audit_action {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.audit_data {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamLeagueResult {
            TeamLeagueResult::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.standing = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.earnings = ::std::option::Option::None;
            self.audit_action = ::std::option::Option::None;
            self.audit_data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamLeagueResult {
            static instance: TeamLeagueResult = TeamLeagueResult {
                timestamp: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                standing: ::std::option::Option::None,
                points: ::std::option::Option::None,
                earnings: ::std::option::Option::None,
                audit_action: ::std::option::Option::None,
                audit_data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamLeagueResult {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTADPCSeasonResults.TeamLeagueResult").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamLeagueResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamLeagueResult {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTADPCSeasonResults.TeamResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamResult {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamResult.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamResult.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamResult.team_abbreviation)
        pub team_abbreviation: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamResult.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamResult.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamResult.total_points)
        pub total_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamResult.total_earnings)
        pub total_earnings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.TeamResult.league_results)
        pub league_results: ::std::vec::Vec<TeamLeagueResult>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCSeasonResults.TeamResult.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamResult {
        fn default() -> &'a TeamResult {
            <TeamResult as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamResult {
        pub fn new() -> TeamResult {
            ::std::default::Default::default()
        }

        // optional uint32 team_id = 1;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 2;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_abbreviation = 8;

        pub fn team_abbreviation(&self) -> &str {
            match self.team_abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_abbreviation(&mut self) {
            self.team_abbreviation = ::std::option::Option::None;
        }

        pub fn has_team_abbreviation(&self) -> bool {
            self.team_abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
            self.team_abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.team_abbreviation.is_none() {
                self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
            self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 team_logo = 3;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 4;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 total_points = 5;

        pub fn total_points(&self) -> u32 {
            self.total_points.unwrap_or(0)
        }

        pub fn clear_total_points(&mut self) {
            self.total_points = ::std::option::Option::None;
        }

        pub fn has_total_points(&self) -> bool {
            self.total_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_points(&mut self, v: u32) {
            self.total_points = ::std::option::Option::Some(v);
        }

        // optional uint32 total_earnings = 6;

        pub fn total_earnings(&self) -> u32 {
            self.total_earnings.unwrap_or(0)
        }

        pub fn clear_total_earnings(&mut self) {
            self.total_earnings = ::std::option::Option::None;
        }

        pub fn has_total_earnings(&self) -> bool {
            self.total_earnings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_earnings(&mut self, v: u32) {
            self.total_earnings = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &TeamResult| { &m.team_id },
                |m: &mut TeamResult| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_name",
                |m: &TeamResult| { &m.team_name },
                |m: &mut TeamResult| { &mut m.team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_abbreviation",
                |m: &TeamResult| { &m.team_abbreviation },
                |m: &mut TeamResult| { &mut m.team_abbreviation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo",
                |m: &TeamResult| { &m.team_logo },
                |m: &mut TeamResult| { &mut m.team_logo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_logo_url",
                |m: &TeamResult| { &m.team_logo_url },
                |m: &mut TeamResult| { &mut m.team_logo_url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_points",
                |m: &TeamResult| { &m.total_points },
                |m: &mut TeamResult| { &mut m.total_points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_earnings",
                |m: &TeamResult| { &m.total_earnings },
                |m: &mut TeamResult| { &mut m.total_earnings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "league_results",
                |m: &TeamResult| { &m.league_results },
                |m: &mut TeamResult| { &mut m.league_results },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamResult>(
                "CMsgDOTADPCSeasonResults.TeamResult",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamResult {
        const NAME: &'static str = "TeamResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.total_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.total_earnings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    58 => {
                        self.league_results.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.total_points {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.total_earnings {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            for value in &self.league_results {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.total_points {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.total_earnings {
                os.write_uint32(6, v)?;
            }
            for v in &self.league_results {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamResult {
            TeamResult::new()
        }

        fn clear(&mut self) {
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_abbreviation = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.total_points = ::std::option::Option::None;
            self.total_earnings = ::std::option::Option::None;
            self.league_results.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamResult {
            static instance: TeamResult = TeamResult {
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_abbreviation: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                total_points: ::std::option::Option::None,
                total_earnings: ::std::option::Option::None,
                league_results: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamResult {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTADPCSeasonResults.TeamResult").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamResult {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTADPCSeasonResults.StandingEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StandingEntry {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.StandingEntry.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.StandingEntry.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.StandingEntry.losses)
        pub losses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.StandingEntry.team_url)
        pub team_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.StandingEntry.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.StandingEntry.team_abbreviation)
        pub team_abbreviation: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCSeasonResults.StandingEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StandingEntry {
        fn default() -> &'a StandingEntry {
            <StandingEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl StandingEntry {
        pub fn new() -> StandingEntry {
            ::std::default::Default::default()
        }

        // optional uint32 team_id = 1;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 wins = 2;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 losses = 3;

        pub fn losses(&self) -> u32 {
            self.losses.unwrap_or(0)
        }

        pub fn clear_losses(&mut self) {
            self.losses = ::std::option::Option::None;
        }

        pub fn has_losses(&self) -> bool {
            self.losses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losses(&mut self, v: u32) {
            self.losses = ::std::option::Option::Some(v);
        }

        // optional string team_url = 4;

        pub fn team_url(&self) -> &str {
            match self.team_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_url(&mut self) {
            self.team_url = ::std::option::Option::None;
        }

        pub fn has_team_url(&self) -> bool {
            self.team_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_url(&mut self, v: ::std::string::String) {
            self.team_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_url(&mut self) -> &mut ::std::string::String {
            if self.team_url.is_none() {
                self.team_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_url(&mut self) -> ::std::string::String {
            self.team_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_name = 5;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_abbreviation = 6;

        pub fn team_abbreviation(&self) -> &str {
            match self.team_abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_abbreviation(&mut self) {
            self.team_abbreviation = ::std::option::Option::None;
        }

        pub fn has_team_abbreviation(&self) -> bool {
            self.team_abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
            self.team_abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.team_abbreviation.is_none() {
                self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
            self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id",
                |m: &StandingEntry| { &m.team_id },
                |m: &mut StandingEntry| { &mut m.team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wins",
                |m: &StandingEntry| { &m.wins },
                |m: &mut StandingEntry| { &mut m.wins },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "losses",
                |m: &StandingEntry| { &m.losses },
                |m: &mut StandingEntry| { &mut m.losses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_url",
                |m: &StandingEntry| { &m.team_url },
                |m: &mut StandingEntry| { &mut m.team_url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_name",
                |m: &StandingEntry| { &m.team_name },
                |m: &mut StandingEntry| { &mut m.team_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_abbreviation",
                |m: &StandingEntry| { &m.team_abbreviation },
                |m: &mut StandingEntry| { &mut m.team_abbreviation },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandingEntry>(
                "CMsgDOTADPCSeasonResults.StandingEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StandingEntry {
        const NAME: &'static str = "StandingEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.losses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.team_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.wins {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.losses {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.team_url.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.team_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.wins {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.losses {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.team_url.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                os.write_string(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StandingEntry {
            StandingEntry::new()
        }

        fn clear(&mut self) {
            self.team_id = ::std::option::Option::None;
            self.wins = ::std::option::Option::None;
            self.losses = ::std::option::Option::None;
            self.team_url = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_abbreviation = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StandingEntry {
            static instance: StandingEntry = StandingEntry {
                team_id: ::std::option::Option::None,
                wins: ::std::option::Option::None,
                losses: ::std::option::Option::None,
                team_url: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_abbreviation: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StandingEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTADPCSeasonResults.StandingEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StandingEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StandingEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dota.CMsgDOTADPCSeasonResults.Standing)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Standing {
        // message fields
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.Standing.region)
        pub region: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueRegion>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.Standing.division)
        pub division: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueDivision>>,
        // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonResults.Standing.entries)
        pub entries: ::std::vec::Vec<StandingEntry>,
        // special fields
        // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCSeasonResults.Standing.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Standing {
        fn default() -> &'a Standing {
            <Standing as ::protobuf::Message>::default_instance()
        }
    }

    impl Standing {
        pub fn new() -> Standing {
            ::std::default::Default::default()
        }

        // optional .dota.ELeagueRegion region = 1;

        pub fn region(&self) -> super::super::dota_shared_enums::ELeagueRegion {
            match self.region {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
                None => super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
            }
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: super::super::dota_shared_enums::ELeagueRegion) {
            self.region = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .dota.ELeagueDivision division = 2;

        pub fn division(&self) -> super::super::dota_shared_enums::ELeagueDivision {
            match self.division {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueDivision::LEAGUE_DIVISION_UNSET),
                None => super::super::dota_shared_enums::ELeagueDivision::LEAGUE_DIVISION_UNSET,
            }
        }

        pub fn clear_division(&mut self) {
            self.division = ::std::option::Option::None;
        }

        pub fn has_division(&self) -> bool {
            self.division.is_some()
        }

        // Param is passed by value, moved
        pub fn set_division(&mut self, v: super::super::dota_shared_enums::ELeagueDivision) {
            self.division = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "region",
                |m: &Standing| { &m.region },
                |m: &mut Standing| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "division",
                |m: &Standing| { &m.division },
                |m: &mut Standing| { &mut m.division },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "entries",
                |m: &Standing| { &m.entries },
                |m: &mut Standing| { &mut m.entries },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Standing>(
                "CMsgDOTADPCSeasonResults.Standing",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Standing {
        const NAME: &'static str = "Standing";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.division = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    26 => {
                        self.entries.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.region {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.division {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            for value in &self.entries {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.region {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.division {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.entries {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Standing {
            Standing::new()
        }

        fn clear(&mut self) {
            self.region = ::std::option::Option::None;
            self.division = ::std::option::Option::None;
            self.entries.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Standing {
            static instance: Standing = Standing {
                region: ::std::option::Option::None,
                division: ::std::option::Option::None,
                entries: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Standing {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDOTADPCSeasonResults.Standing").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Standing {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Standing {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dota.CMsgDOTADPCSeasonSpoilerResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCSeasonSpoilerResults {
    // message fields
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonSpoilerResults.time_last_updated)
    pub time_last_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dota.CMsgDOTADPCSeasonSpoilerResults.saved_results)
    pub saved_results: ::protobuf::MessageField<CMsgDOTADPCSeasonResults>,
    // special fields
    // @@protoc_insertion_point(special_field:dota.CMsgDOTADPCSeasonSpoilerResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCSeasonSpoilerResults {
    fn default() -> &'a CMsgDOTADPCSeasonSpoilerResults {
        <CMsgDOTADPCSeasonSpoilerResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCSeasonSpoilerResults {
    pub fn new() -> CMsgDOTADPCSeasonSpoilerResults {
        ::std::default::Default::default()
    }

    // optional uint32 time_last_updated = 1;

    pub fn time_last_updated(&self) -> u32 {
        self.time_last_updated.unwrap_or(0)
    }

    pub fn clear_time_last_updated(&mut self) {
        self.time_last_updated = ::std::option::Option::None;
    }

    pub fn has_time_last_updated(&self) -> bool {
        self.time_last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_updated(&mut self, v: u32) {
        self.time_last_updated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_updated",
            |m: &CMsgDOTADPCSeasonSpoilerResults| { &m.time_last_updated },
            |m: &mut CMsgDOTADPCSeasonSpoilerResults| { &mut m.time_last_updated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgDOTADPCSeasonResults>(
            "saved_results",
            |m: &CMsgDOTADPCSeasonSpoilerResults| { &m.saved_results },
            |m: &mut CMsgDOTADPCSeasonSpoilerResults| { &mut m.saved_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDOTADPCSeasonSpoilerResults>(
            "CMsgDOTADPCSeasonSpoilerResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDOTADPCSeasonSpoilerResults {
    const NAME: &'static str = "CMsgDOTADPCSeasonSpoilerResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time_last_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.saved_results)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time_last_updated {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.saved_results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time_last_updated {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.saved_results.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCSeasonSpoilerResults {
        CMsgDOTADPCSeasonSpoilerResults::new()
    }

    fn clear(&mut self) {
        self.time_last_updated = ::std::option::Option::None;
        self.saved_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCSeasonSpoilerResults {
        static instance: CMsgDOTADPCSeasonSpoilerResults = CMsgDOTADPCSeasonSpoilerResults {
            time_last_updated: ::std::option::Option::None,
            saved_results: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDOTADPCSeasonSpoilerResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDOTADPCSeasonSpoilerResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDOTADPCSeasonSpoilerResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTADPCSeasonSpoilerResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeagueNodeGroupType)
pub enum ELeagueNodeGroupType {
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeGroupType.INVALID_GROUP_TYPE)
    INVALID_GROUP_TYPE = 0,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeGroupType.ORGANIZATIONAL)
    ORGANIZATIONAL = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeGroupType.ROUND_ROBIN)
    ROUND_ROBIN = 2,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeGroupType.SWISS)
    SWISS = 3,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeGroupType.BRACKET_SINGLE)
    BRACKET_SINGLE = 4,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeGroupType.BRACKET_DOUBLE_SEED_LOSER)
    BRACKET_DOUBLE_SEED_LOSER = 5,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeGroupType.BRACKET_DOUBLE_ALL_WINNER)
    BRACKET_DOUBLE_ALL_WINNER = 6,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeGroupType.SHOWMATCH)
    SHOWMATCH = 7,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeGroupType.GSL)
    GSL = 8,
}

impl ::protobuf::Enum for ELeagueNodeGroupType {
    const NAME: &'static str = "ELeagueNodeGroupType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueNodeGroupType> {
        match value {
            0 => ::std::option::Option::Some(ELeagueNodeGroupType::INVALID_GROUP_TYPE),
            1 => ::std::option::Option::Some(ELeagueNodeGroupType::ORGANIZATIONAL),
            2 => ::std::option::Option::Some(ELeagueNodeGroupType::ROUND_ROBIN),
            3 => ::std::option::Option::Some(ELeagueNodeGroupType::SWISS),
            4 => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_SINGLE),
            5 => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_DOUBLE_SEED_LOSER),
            6 => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_DOUBLE_ALL_WINNER),
            7 => ::std::option::Option::Some(ELeagueNodeGroupType::SHOWMATCH),
            8 => ::std::option::Option::Some(ELeagueNodeGroupType::GSL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueNodeGroupType> {
        match str {
            "INVALID_GROUP_TYPE" => ::std::option::Option::Some(ELeagueNodeGroupType::INVALID_GROUP_TYPE),
            "ORGANIZATIONAL" => ::std::option::Option::Some(ELeagueNodeGroupType::ORGANIZATIONAL),
            "ROUND_ROBIN" => ::std::option::Option::Some(ELeagueNodeGroupType::ROUND_ROBIN),
            "SWISS" => ::std::option::Option::Some(ELeagueNodeGroupType::SWISS),
            "BRACKET_SINGLE" => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_SINGLE),
            "BRACKET_DOUBLE_SEED_LOSER" => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_DOUBLE_SEED_LOSER),
            "BRACKET_DOUBLE_ALL_WINNER" => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_DOUBLE_ALL_WINNER),
            "SHOWMATCH" => ::std::option::Option::Some(ELeagueNodeGroupType::SHOWMATCH),
            "GSL" => ::std::option::Option::Some(ELeagueNodeGroupType::GSL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueNodeGroupType] = &[
        ELeagueNodeGroupType::INVALID_GROUP_TYPE,
        ELeagueNodeGroupType::ORGANIZATIONAL,
        ELeagueNodeGroupType::ROUND_ROBIN,
        ELeagueNodeGroupType::SWISS,
        ELeagueNodeGroupType::BRACKET_SINGLE,
        ELeagueNodeGroupType::BRACKET_DOUBLE_SEED_LOSER,
        ELeagueNodeGroupType::BRACKET_DOUBLE_ALL_WINNER,
        ELeagueNodeGroupType::SHOWMATCH,
        ELeagueNodeGroupType::GSL,
    ];
}

impl ::protobuf::EnumFull for ELeagueNodeGroupType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeagueNodeGroupType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELeagueNodeGroupType {
    fn default() -> Self {
        ELeagueNodeGroupType::INVALID_GROUP_TYPE
    }
}

impl ELeagueNodeGroupType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueNodeGroupType>("ELeagueNodeGroupType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dota.ELeagueNodeType)
pub enum ELeagueNodeType {
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeType.INVALID_NODE_TYPE)
    INVALID_NODE_TYPE = 0,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeType.BEST_OF_ONE)
    BEST_OF_ONE = 1,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeType.BEST_OF_THREE)
    BEST_OF_THREE = 2,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeType.BEST_OF_FIVE)
    BEST_OF_FIVE = 3,
    // @@protoc_insertion_point(enum_value:dota.ELeagueNodeType.BEST_OF_TWO)
    BEST_OF_TWO = 4,
}

impl ::protobuf::Enum for ELeagueNodeType {
    const NAME: &'static str = "ELeagueNodeType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueNodeType> {
        match value {
            0 => ::std::option::Option::Some(ELeagueNodeType::INVALID_NODE_TYPE),
            1 => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_ONE),
            2 => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_THREE),
            3 => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_FIVE),
            4 => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_TWO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueNodeType> {
        match str {
            "INVALID_NODE_TYPE" => ::std::option::Option::Some(ELeagueNodeType::INVALID_NODE_TYPE),
            "BEST_OF_ONE" => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_ONE),
            "BEST_OF_THREE" => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_THREE),
            "BEST_OF_FIVE" => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_FIVE),
            "BEST_OF_TWO" => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_TWO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueNodeType] = &[
        ELeagueNodeType::INVALID_NODE_TYPE,
        ELeagueNodeType::BEST_OF_ONE,
        ELeagueNodeType::BEST_OF_THREE,
        ELeagueNodeType::BEST_OF_FIVE,
        ELeagueNodeType::BEST_OF_TWO,
    ];
}

impl ::protobuf::EnumFull for ELeagueNodeType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELeagueNodeType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELeagueNodeType {
    fn default() -> Self {
        ELeagueNodeType::INVALID_NODE_TYPE
    }
}

impl ELeagueNodeType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ELeagueNodeType>("ELeagueNodeType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n#dota_gcmessages_common_league.proto\x12\x04dota\x1a\x17dota_shared_en\
    ums.proto\"\x9e\x07\n\x12CMsgDOTALeagueNode\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x17\n\x07node_id\x18\x02\x20\x01(\rR\x06nodeId\
    \x12\"\n\rnode_group_id\x18\x03\x20\x01(\rR\x0bnodeGroupId\x12&\n\x0fwin\
    ning_node_id\x18\x04\x20\x01(\rR\rwinningNodeId\x12$\n\x0elosing_node_id\
    \x18\x05\x20\x01(\rR\x0closingNodeId\x12+\n\x12incoming_node_id_1\x18\
    \x06\x20\x01(\rR\x0fincomingNodeId1\x12+\n\x12incoming_node_id_2\x18\x07\
    \x20\x01(\rR\x0fincomingNodeId2\x122\n\tnode_type\x18\x08\x20\x01(\x0e2\
    \x15.dota.ELeagueNodeTypeR\x08nodeType\x12%\n\x0escheduled_time\x18\t\
    \x20\x01(\rR\rscheduledTime\x12\x1f\n\x0bactual_time\x18\x13\x20\x01(\rR\
    \nactualTime\x12\x1b\n\tseries_id\x18\n\x20\x01(\rR\x08seriesId\x12\x1a\
    \n\tteam_id_1\x18\x0b\x20\x01(\rR\x07teamId1\x12\x1a\n\tteam_id_2\x18\
    \x0c\x20\x01(\rR\x07teamId2\x12?\n\x07matches\x18\r\x20\x03(\x0b2%.dota.\
    CMsgDOTALeagueNode.MatchDetailsR\x07matches\x12\x1e\n\x0bteam_1_wins\x18\
    \x0e\x20\x01(\rR\tteam1Wins\x12\x1e\n\x0bteam_2_wins\x18\x0f\x20\x01(\rR\
    \tteam2Wins\x12\x1f\n\x0bhas_started\x18\x10\x20\x01(\x08R\nhasStarted\
    \x12!\n\x0cis_completed\x18\x11\x20\x01(\x08R\x0bisCompleted\x12\x1d\n\n\
    stream_ids\x18\x12\x20\x03(\rR\tstreamIds\x120\n\x04vods\x18\x14\x20\x03\
    (\x0b2\x1c.dota.CMsgDOTALeagueNode.VODR\x04vods\x1aQ\n\x0cMatchDetails\
    \x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12&\n\x0fwinnin\
    g_team_id\x18\x02\x20\x01(\rR\rwinningTeamId\x1aU\n\x03VOD\x12\x1f\n\x0b\
    series_game\x18\x01\x20\x01(\rR\nseriesGame\x12\x1b\n\tstream_id\x18\x02\
    \x20\x01(\rR\x08streamId\x12\x10\n\x03url\x18\x03\x20\x01(\tR\x03url\"\
    \xec\r\n\x17CMsgDOTALeagueNodeGroup\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12\"\n\rnode_group_id\x18\x02\x20\x01(\rR\x0bnodeGroupId\x12/\
    \n\x14parent_node_group_id\x18\x03\x20\x01(\rR\x11parentNodeGroupId\x125\
    \n\x17incoming_node_group_ids\x18\x04\x20\x03(\rR\x14incomingNodeGroupId\
    s\x125\n\x17advancing_node_group_id\x18\x05\x20\x01(\rR\x14advancingNode\
    GroupId\x120\n\x14advancing_team_count\x18\x06\x20\x01(\rR\x12advancingT\
    eamCount\x12\x1d\n\nteam_count\x18\x07\x20\x01(\rR\tteamCount\x12B\n\x0f\
    node_group_type\x18\x08\x20\x01(\x0e2\x1a.dota.ELeagueNodeGroupTypeR\rno\
    deGroupType\x12A\n\x11default_node_type\x18\t\x20\x01(\x0e2\x15.dota.ELe\
    agueNodeTypeR\x0fdefaultNodeType\x12\x14\n\x05round\x18\n\x20\x01(\rR\
    \x05round\x12\x1d\n\nmax_rounds\x18\x0b\x20\x01(\rR\tmaxRounds\x12#\n\ri\
    s_tiebreaker\x18\x0c\x20\x01(\x08R\x0cisTiebreaker\x12$\n\x0eis_final_gr\
    oup\x18\r\x20\x01(\x08R\x0cisFinalGroup\x12!\n\x0cis_completed\x18\x0e\
    \x20\x01(\x08R\x0bisCompleted\x12(\n\x05phase\x18\x12\x20\x01(\x0e2\x12.\
    dota.ELeaguePhaseR\x05phase\x12+\n\x06region\x18\x13\x20\x01(\x0e2\x13.d\
    ota.ELeagueRegionR\x06region\x12\x1d\n\nstart_time\x18\x14\x20\x01(\rR\t\
    startTime\x12\x19\n\x08end_time\x18\x15\x20\x01(\rR\x07endTime\x12H\n!se\
    condary_advancing_node_group_id\x18\x16\x20\x01(\rR\x1dsecondaryAdvancin\
    gNodeGroupId\x12C\n\x1esecondary_advancing_team_count\x18\x17\x20\x01(\r\
    R\x1bsecondaryAdvancingTeamCount\x12F\n\x20tertiary_advancing_node_group\
    _id\x18\x18\x20\x01(\rR\x1ctertiaryAdvancingNodeGroupId\x12A\n\x1dtertia\
    ry_advancing_team_count\x18\x19\x20\x01(\rR\x1atertiaryAdvancingTeamCoun\
    t\x124\n\x16elimination_dpc_points\x18\x1a\x20\x01(\rR\x14eliminationDpc\
    Points\x12Q\n\x0eteam_standings\x18\x0f\x20\x03(\x0b2*.dota.CMsgDOTALeag\
    ueNodeGroup.TeamStandingR\rteamStandings\x12.\n\x05nodes\x18\x10\x20\x03\
    (\x0b2\x18.dota.CMsgDOTALeagueNodeR\x05nodes\x12>\n\x0bnode_groups\x18\
    \x11\x20\x03(\x0b2\x1d.dota.CMsgDOTALeagueNodeGroupR\nnodeGroups\x1a\xda\
    \x03\n\x0cTeamStanding\x12\x1a\n\x08standing\x18\x01\x20\x01(\rR\x08stan\
    ding\x12\x17\n\x07team_id\x18\x02\x20\x01(\rR\x06teamId\x12\x1b\n\tteam_\
    name\x18\x03\x20\x01(\tR\x08teamName\x12\x19\n\x08team_tag\x18\x04\x20\
    \x01(\tR\x07teamTag\x12\x1b\n\tteam_logo\x18\x05\x20\x01(\x04R\x08teamLo\
    go\x12\"\n\rteam_logo_url\x18\x06\x20\x01(\tR\x0bteamLogoUrl\x12\x12\n\
    \x04wins\x18\x07\x20\x01(\rR\x04wins\x12\x16\n\x06losses\x18\x08\x20\x01\
    (\rR\x06losses\x12\x14\n\x05score\x18\t\x20\x01(\x03R\x05score\x12+\n\
    \x11team_abbreviation\x18\n\x20\x01(\tR\x10teamAbbreviation\x120\n\x14sc\
    ore_tiebreak_group\x18\x0b\x20\x01(\x03R\x12scoreTiebreakGroup\x120\n\
    \x14score_tiebreak_below\x18\x0c\x20\x01(\x03R\x12scoreTiebreakBelow\x12\
    2\n\x15score_tiebreak_random\x18\r\x20\x01(\x03R\x13scoreTiebreakRandom\
    \x12\x15\n\x06is_pro\x18\x0e\x20\x01(\x08R\x05isPro\"\xb2\x0f\n\x0eCMsgD\
    OTALeague\x12-\n\x04info\x18\x01\x20\x01(\x0b2\x19.dota.CMsgDOTALeague.I\
    nfoR\x04info\x12=\n\nprize_pool\x18\x02\x20\x01(\x0b2\x1e.dota.CMsgDOTAL\
    eague.PrizePoolR\tprizePool\x122\n\x06admins\x18\x03\x20\x03(\x0b2\x1a.d\
    ota.CMsgDOTALeague.AdminR\x06admins\x125\n\x07streams\x18\x04\x20\x03(\
    \x0b2\x1b.dota.CMsgDOTALeague.StreamR\x07streams\x12>\n\x0bnode_groups\
    \x18\x05\x20\x03(\x0b2\x1d.dota.CMsgDOTALeagueNodeGroupR\nnodeGroups\x12\
    B\n\x0cseries_infos\x18\x06\x20\x03(\x0b2\x1f.dota.CMsgDOTALeague.Series\
    InfoR\x0bseriesInfos\x12J\n\x12registered_players\x18\x07\x20\x03(\x0b2\
    \x1b.dota.CMsgDOTALeague.PlayerR\x11registeredPlayers\x1a\x80\x04\n\x04I\
    nfo\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\x12\x12\n\x04na\
    me\x18\x02\x20\x01(\tR\x04name\x12%\n\x04tier\x18\x03\x20\x01(\x0e2\x11.\
    dota.ELeagueTierR\x04tier\x12+\n\x06region\x18\x04\x20\x01(\x0e2\x13.dot\
    a.ELeagueRegionR\x06region\x12\x10\n\x03url\x18\x05\x20\x01(\tR\x03url\
    \x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\x12\x14\n\
    \x05notes\x18\x07\x20\x01(\tR\x05notes\x12'\n\x0fstart_timestamp\x18\x08\
    \x20\x01(\rR\x0estartTimestamp\x12#\n\rend_timestamp\x18\t\x20\x01(\rR\
    \x0cendTimestamp\x12,\n\x12pro_circuit_points\x18\n\x20\x01(\rR\x10proCi\
    rcuitPoints\x12\x1d\n\nimage_bits\x18\x0b\x20\x01(\rR\timageBits\x12+\n\
    \x06status\x18\x0c\x20\x01(\x0e2\x13.dota.ELeagueStatusR\x06status\x120\
    \n\x14most_recent_activity\x18\r\x20\x01(\rR\x12mostRecentActivity\x12/\
    \n\x13registration_period\x18\x0e\x20\x01(\rR\x12registrationPeriod\x1aj\
    \n\x05Admin\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1d\
    \n\nis_primary\x18\x02\x20\x01(\x08R\tisPrimary\x12#\n\remail_address\
    \x18\x03\x20\x01(\tR\x0cemailAddress\x1a\xb2\x01\n\rPrizePoolItem\x12\
    \x19\n\x08item_def\x18\x01\x20\x01(\rR\x07itemDef\x120\n\x14sales_stop_t\
    imestamp\x18\x02\x20\x01(\rR\x12salesStopTimestamp\x12\x1f\n\x0brevenue_\
    pct\x18\x03\x20\x01(\rR\nrevenuePct\x123\n\x16revenue_cents_per_sale\x18\
    \x04\x20\x01(\rR\x13revenueCentsPerSale\x1a\xdc\x01\n\tPrizePool\x12&\n\
    \x0fbase_prize_pool\x18\x01\x20\x01(\rR\rbasePrizePool\x12(\n\x10total_p\
    rize_pool\x18\x02\x20\x01(\rR\x0etotalPrizePool\x12/\n\x14prize_split_pc\
    t_x100\x18\x03\x20\x03(\rR\x11prizeSplitPctX100\x12L\n\x10prize_pool_ite\
    ms\x18\x04\x20\x03(\x0b2\".dota.CMsgDOTALeague.PrizePoolItemR\x0eprizePo\
    olItems\x1a\xdc\x01\n\x06Stream\x12\x1b\n\tstream_id\x18\x01\x20\x01(\rR\
    \x08streamId\x12\x1a\n\x08language\x18\x02\x20\x01(\rR\x08language\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12M\n\x12broadcast_provider\
    \x18\x04\x20\x01(\x0e2\x1e.dota.ELeagueBroadcastProviderR\x11broadcastPr\
    ovider\x12\x1d\n\nstream_url\x18\x05\x20\x01(\tR\tstreamUrl\x12\x17\n\
    \x07vod_url\x18\x06\x20\x01(\tR\x06vodUrl\x1a\xbe\x01\n\nSeriesInfo\x12\
    \x1b\n\tseries_id\x18\x01\x20\x01(\rR\x08seriesId\x12\x1f\n\x0bseries_ty\
    pe\x18\x02\x20\x01(\rR\nseriesType\x12\x1d\n\nstart_time\x18\x03\x20\x01\
    (\rR\tstartTime\x12\x1b\n\tmatch_ids\x18\x04\x20\x03(\x04R\x08matchIds\
    \x12\x1a\n\tteam_id_1\x18\x05\x20\x01(\rR\x07teamId1\x12\x1a\n\tteam_id_\
    2\x18\x06\x20\x01(\rR\x07teamId2\x1aT\n\x06Player\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x17\n\x07team_id\x18\x03\x20\x01(\rR\x06teamId\"D\n\x12CMsg\
    DOTALeagueList\x12.\n\x07leagues\x18\x01\x20\x03(\x0b2\x14.dota.CMsgDOTA\
    LeagueR\x07leagues\"\xdb\x02\n\x12CMsgDOTALeagueInfo\x12\x1b\n\tleague_i\
    d\x18\x01\x20\x01(\rR\x08leagueId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12%\n\x04tier\x18\x03\x20\x01(\x0e2\x11.dota.ELeagueTierR\x04t\
    ier\x12+\n\x06region\x18\x04\x20\x01(\x0e2\x13.dota.ELeagueRegionR\x06re\
    gion\x120\n\x14most_recent_activity\x18\x05\x20\x01(\rR\x12mostRecentAct\
    ivity\x12(\n\x10total_prize_pool\x18\x06\x20\x01(\rR\x0etotalPrizePool\
    \x12'\n\x0fstart_timestamp\x18\x07\x20\x01(\rR\x0estartTimestamp\x12#\n\
    \rend_timestamp\x18\x08\x20\x01(\rR\x0cendTimestamp\x12\x16\n\x06status\
    \x18\t\x20\x01(\rR\x06status\"H\n\x16CMsgDOTALeagueInfoList\x12.\n\x05in\
    fos\x18\x01\x20\x03(\x0b2\x18.dota.CMsgDOTALeagueInfoR\x05infos\"\x85\
    \x04\n\x17CMsgDOTALeagueLiveGames\x12<\n\x05games\x18\x01\x20\x03(\x0b2&\
    .dota.CMsgDOTALeagueLiveGames.LiveGameR\x05games\x1a\xab\x03\n\x08LiveGa\
    me\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\x12&\n\x0fserver\
    _steam_id\x18\x02\x20\x01(\x04R\rserverSteamId\x12!\n\x0cradiant_name\
    \x18\x03\x20\x01(\tR\x0bradiantName\x12!\n\x0cradiant_logo\x18\x04\x20\
    \x01(\x04R\x0bradiantLogo\x12&\n\x0fradiant_team_id\x18\t\x20\x01(\rR\rr\
    adiantTeamId\x12\x1b\n\tdire_name\x18\x05\x20\x01(\tR\x08direName\x12\
    \x1b\n\tdire_logo\x18\x06\x20\x01(\x04R\x08direLogo\x12\x20\n\x0cdire_te\
    am_id\x18\n\x20\x01(\rR\ndireTeamId\x12\x12\n\x04time\x18\x07\x20\x01(\r\
    R\x04time\x12\x1e\n\nspectators\x18\x08\x20\x01(\rR\nspectators\x12$\n\
    \x0eleague_node_id\x18\x0b\x20\x01(\rR\x0cleagueNodeId\x12\x1b\n\tseries\
    _id\x18\x0c\x20\x01(\rR\x08seriesId\x12\x19\n\x08match_id\x18\r\x20\x01(\
    \x04R\x07matchId\"\xc9\x01\n\x16CMsgDOTALeagueMessages\x12@\n\x08message\
    s\x18\x01\x20\x03(\x0b2$.dota.CMsgDOTALeagueMessages.MessageR\x08message\
    s\x1am\n\x07Message\x12*\n\x11author_account_id\x18\x01\x20\x01(\rR\x0fa\
    uthorAccountId\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\
    \x18\n\x07message\x18\x03\x20\x01(\tR\x07message\"j\n\x17CMsgDOTALeagueP\
    rizePool\x12\x1d\n\nprize_pool\x18\x01\x20\x01(\rR\tprizePool\x120\n\x14\
    increment_per_second\x18\x02\x20\x01(\x02R\x12incrementPerSecond\"%\n#CM\
    sgDOTALeagueInfoListAdminsRequest\"G\n(CMsgDOTALeagueAvailableLobbyNodes\
    Request\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\"\x97\x02\n\
    !CMsgDOTALeagueAvailableLobbyNodes\x12O\n\nnode_infos\x18\x01\x20\x03(\
    \x0b20.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfoR\tnodeInfos\x1a\
    \xa0\x01\n\x08NodeInfo\x12\x17\n\x07node_id\x18\x01\x20\x01(\rR\x06nodeI\
    d\x12\x1b\n\tnode_name\x18\x02\x20\x01(\tR\x08nodeName\x12&\n\x0fnode_gr\
    oup_name\x18\x03\x20\x01(\tR\rnodeGroupName\x12\x1a\n\tteam_id_1\x18\x04\
    \x20\x01(\rR\x07teamId1\x12\x1a\n\tteam_id_2\x18\x05\x20\x01(\rR\x07team\
    Id2\"\xc0\x05\n\x19CMsgDOTALeagueNodeResults\x12I\n\x0cnode_results\x18\
    \x01\x20\x03(\x0b2&.dota.CMsgDOTALeagueNodeResults.ResultR\x0bnodeResult\
    s\x1a\xd7\x04\n\x06Result\x12\x17\n\x07node_id\x18\x01\x20\x01(\rR\x06no\
    deId\x12&\n\x0fwinning_node_id\x18\x02\x20\x01(\rR\rwinningNodeId\x12$\n\
    \x0elosing_node_id\x18\x03\x20\x01(\rR\x0closingNodeId\x12+\n\x12incomin\
    g_node_id_1\x18\x04\x20\x01(\rR\x0fincomingNodeId1\x12+\n\x12incoming_no\
    de_id_2\x18\x05\x20\x01(\rR\x0fincomingNodeId2\x12\x1a\n\tteam_id_1\x18\
    \x06\x20\x01(\rR\x07teamId1\x12\x1a\n\tteam_id_2\x18\x07\x20\x01(\rR\x07\
    teamId2\x12\x1e\n\x0bteam_1_name\x18\x08\x20\x01(\tR\tteam1Name\x12\x1e\
    \n\x0bteam_2_name\x18\t\x20\x01(\tR\tteam2Name\x12\x1e\n\x0bteam_1_wins\
    \x18\n\x20\x01(\rR\tteam1Wins\x12\x1e\n\x0bteam_2_wins\x18\x0b\x20\x01(\
    \rR\tteam2Wins\x12&\n\x0fwinning_team_id\x18\x0c\x20\x01(\rR\rwinningTea\
    mId\x12$\n\x0elosing_team_id\x18\r\x20\x01(\rR\x0closingTeamId\x12\x1f\n\
    \x0bhas_started\x18\x0e\x20\x01(\x08R\nhasStarted\x12!\n\x0cis_completed\
    \x18\x0f\x20\x01(\x08R\x0bisCompleted\x12%\n\x0escheduled_time\x18\x10\
    \x20\x01(\rR\rscheduledTime\x12\x1b\n\tmatch_ids\x18\x11\x20\x03(\x04R\
    \x08matchIds\"\xd4\x03\n\x18CMsgDOTADPCLeagueResults\x12?\n\x07results\
    \x18\x01\x20\x03(\x0b2%.dota.CMsgDOTADPCLeagueResults.ResultR\x07results\
    \x12\x16\n\x06points\x18\x02\x20\x03(\rR\x06points\x12\x18\n\x07dollars\
    \x18\x03\x20\x03(\rR\x07dollars\x1a\xc4\x02\n\x06Result\x12\x1a\n\x08sta\
    nding\x18\x01\x20\x01(\rR\x08standing\x12\x17\n\x07team_id\x18\x02\x20\
    \x01(\rR\x06teamId\x12\x1b\n\tteam_name\x18\x03\x20\x01(\tR\x08teamName\
    \x12\x1b\n\tteam_logo\x18\x04\x20\x01(\x04R\x08teamLogo\x12\"\n\rteam_lo\
    go_url\x18\x05\x20\x01(\tR\x0bteamLogoUrl\x12\x16\n\x06points\x18\x06\
    \x20\x01(\rR\x06points\x12\x1a\n\x08earnings\x18\x07\x20\x01(\rR\x08earn\
    ings\x12\x1c\n\ttimestamp\x18\x08\x20\x01(\rR\ttimestamp\x12(\n\x05phase\
    \x18\t\x20\x01(\x0e2\x12.dota.ELeaguePhaseR\x05phase\x12+\n\x11team_abbr\
    eviation\x18\n\x20\x01(\tR\x10teamAbbreviation\"\xed\x01\n\x16CMsgDOTADP\
    CTeamResults\x12=\n\x07results\x18\x01\x20\x03(\x0b2#.dota.CMsgDOTADPCTe\
    amResults.ResultR\x07results\x1a\x93\x01\n\x06Result\x12\x1b\n\tleague_i\
    d\x18\x01\x20\x01(\rR\x08leagueId\x12\x1a\n\x08standing\x18\x02\x20\x01(\
    \rR\x08standing\x12\x16\n\x06points\x18\x03\x20\x01(\rR\x06points\x12\
    \x1a\n\x08earnings\x18\x04\x20\x01(\rR\x08earnings\x12\x1c\n\ttimestamp\
    \x18\x05\x20\x01(\rR\ttimestamp\"\xfe\n\n\x18CMsgDOTADPCSeasonResults\
    \x12C\n\x07results\x18\x01\x20\x03(\x0b2).dota.CMsgDOTADPCSeasonResults.\
    TeamResultR\x07results\x12E\n\tstandings\x18\x02\x20\x03(\x0b2'.dota.CMs\
    gDOTADPCSeasonResults.StandingR\tstandings\x12f\n\x18major_wildcard_stan\
    dings\x18\x03\x20\x03(\x0b2,.dota.CMsgDOTADPCSeasonResults.StandingEntry\
    R\x16majorWildcardStandings\x12`\n\x15major_group_standings\x18\x04\x20\
    \x03(\x0b2,.dota.CMsgDOTADPCSeasonResults.StandingEntryR\x13majorGroupSt\
    andings\x12d\n\x17major_playoff_standings\x18\x05\x20\x03(\x0b2,.dota.CM\
    sgDOTADPCSeasonResults.StandingEntryR\x15majorPlayoffStandings\x1a\xdf\
    \x01\n\x10TeamLeagueResult\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\ttim\
    estamp\x12\x1b\n\tleague_id\x18\x02\x20\x01(\rR\x08leagueId\x12\x1a\n\
    \x08standing\x18\x03\x20\x01(\rR\x08standing\x12\x16\n\x06points\x18\x04\
    \x20\x01(\rR\x06points\x12\x1a\n\x08earnings\x18\x05\x20\x01(\rR\x08earn\
    ings\x12!\n\x0caudit_action\x18\x06\x20\x01(\rR\x0bauditAction\x12\x1d\n\
    \naudit_data\x18\x07\x20\x01(\rR\tauditData\x1a\xd2\x02\n\nTeamResult\
    \x12\x17\n\x07team_id\x18\x01\x20\x01(\rR\x06teamId\x12\x1b\n\tteam_name\
    \x18\x02\x20\x01(\tR\x08teamName\x12+\n\x11team_abbreviation\x18\x08\x20\
    \x01(\tR\x10teamAbbreviation\x12\x1b\n\tteam_logo\x18\x03\x20\x01(\x04R\
    \x08teamLogo\x12\"\n\rteam_logo_url\x18\x04\x20\x01(\tR\x0bteamLogoUrl\
    \x12!\n\x0ctotal_points\x18\x05\x20\x01(\rR\x0btotalPoints\x12%\n\x0etot\
    al_earnings\x18\x06\x20\x01(\rR\rtotalEarnings\x12V\n\x0eleague_results\
    \x18\x07\x20\x03(\x0b2/.dota.CMsgDOTADPCSeasonResults.TeamLeagueResultR\
    \rleagueResults\x1a\xb9\x01\n\rStandingEntry\x12\x17\n\x07team_id\x18\
    \x01\x20\x01(\rR\x06teamId\x12\x12\n\x04wins\x18\x02\x20\x01(\rR\x04wins\
    \x12\x16\n\x06losses\x18\x03\x20\x01(\rR\x06losses\x12\x19\n\x08team_url\
    \x18\x04\x20\x01(\tR\x07teamUrl\x12\x1b\n\tteam_name\x18\x05\x20\x01(\tR\
    \x08teamName\x12+\n\x11team_abbreviation\x18\x06\x20\x01(\tR\x10teamAbbr\
    eviation\x1a\xb2\x01\n\x08Standing\x12+\n\x06region\x18\x01\x20\x01(\x0e\
    2\x13.dota.ELeagueRegionR\x06region\x121\n\x08division\x18\x02\x20\x01(\
    \x0e2\x15.dota.ELeagueDivisionR\x08division\x12F\n\x07entries\x18\x03\
    \x20\x03(\x0b2,.dota.CMsgDOTADPCSeasonResults.StandingEntryR\x07entries\
    \"\x92\x01\n\x1fCMsgDOTADPCSeasonSpoilerResults\x12*\n\x11time_last_upda\
    ted\x18\x01\x20\x01(\rR\x0ftimeLastUpdated\x12C\n\rsaved_results\x18\x02\
    \x20\x01(\x0b2\x1e.dota.CMsgDOTADPCSeasonResultsR\x0csavedResults*\xc8\
    \x01\n\x14ELeagueNodeGroupType\x12\x16\n\x12INVALID_GROUP_TYPE\x10\0\x12\
    \x12\n\x0eORGANIZATIONAL\x10\x01\x12\x0f\n\x0bROUND_ROBIN\x10\x02\x12\t\
    \n\x05SWISS\x10\x03\x12\x12\n\x0eBRACKET_SINGLE\x10\x04\x12\x1d\n\x19BRA\
    CKET_DOUBLE_SEED_LOSER\x10\x05\x12\x1d\n\x19BRACKET_DOUBLE_ALL_WINNER\
    \x10\x06\x12\r\n\tSHOWMATCH\x10\x07\x12\x07\n\x03GSL\x10\x08*o\n\x0fELea\
    gueNodeType\x12\x15\n\x11INVALID_NODE_TYPE\x10\0\x12\x0f\n\x0bBEST_OF_ON\
    E\x10\x01\x12\x11\n\rBEST_OF_THREE\x10\x02\x12\x10\n\x0cBEST_OF_FIVE\x10\
    \x03\x12\x0f\n\x0bBEST_OF_TWO\x10\x04B%Z#github.com/dotabuff/manta/dota;\
    dotaJ\x8b\x93\x01\n\x07\x12\x05\0\0\xe2\x02\x01\n\x08\n\x01\x0c\x12\x03\
    \0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0c\n\x08\n\x01\x08\x12\x03\x03\
    \0:\n\t\n\x02\x08\x0b\x12\x03\x03\0:\n\t\n\x02\x03\0\x12\x03\x05\x07\x20\
    \n\n\n\x02\x05\0\x12\x04\x07\0\x11\x01\n\n\n\x03\x05\0\x01\x12\x03\x07\
    \x05\x19\n\x0b\n\x04\x05\0\x02\0\x12\x03\x08\x08\x1f\n\x0c\n\x05\x05\0\
    \x02\0\x01\x12\x03\x08\x08\x1a\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x08\
    \x1d\x1e\n\x0b\n\x04\x05\0\x02\x01\x12\x03\t\x08\x1b\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\t\x08\x16\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\t\
    \x19\x1a\n\x0b\n\x04\x05\0\x02\x02\x12\x03\n\x08\x18\n\x0c\n\x05\x05\0\
    \x02\x02\x01\x12\x03\n\x08\x13\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\n\
    \x16\x17\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x0b\x08\x12\n\x0c\n\x05\x05\0\
    \x02\x03\x01\x12\x03\x0b\x08\r\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x0b\
    \x10\x11\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x0c\x08\x1b\n\x0c\n\x05\x05\0\
    \x02\x04\x01\x12\x03\x0c\x08\x16\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\
    \x0c\x19\x1a\n\x0b\n\x04\x05\0\x02\x05\x12\x03\r\x08&\n\x0c\n\x05\x05\0\
    \x02\x05\x01\x12\x03\r\x08!\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\r$%\n\
    \x0b\n\x04\x05\0\x02\x06\x12\x03\x0e\x08&\n\x0c\n\x05\x05\0\x02\x06\x01\
    \x12\x03\x0e\x08!\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0e$%\n\x0b\n\
    \x04\x05\0\x02\x07\x12\x03\x0f\x08\x16\n\x0c\n\x05\x05\0\x02\x07\x01\x12\
    \x03\x0f\x08\x11\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x0f\x14\x15\n\x0b\
    \n\x04\x05\0\x02\x08\x12\x03\x10\x08\x10\n\x0c\n\x05\x05\0\x02\x08\x01\
    \x12\x03\x10\x08\x0b\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\x10\x0e\x0f\n\
    \n\n\x02\x05\x01\x12\x04\x13\0\x19\x01\n\n\n\x03\x05\x01\x01\x12\x03\x13\
    \x05\x14\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x14\x08\x1e\n\x0c\n\x05\x05\
    \x01\x02\0\x01\x12\x03\x14\x08\x19\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\
    \x14\x1c\x1d\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x15\x08\x18\n\x0c\n\x05\
    \x05\x01\x02\x01\x01\x12\x03\x15\x08\x13\n\x0c\n\x05\x05\x01\x02\x01\x02\
    \x12\x03\x15\x16\x17\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\x16\x08\x1a\n\
    \x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x16\x08\x15\n\x0c\n\x05\x05\x01\
    \x02\x02\x02\x12\x03\x16\x18\x19\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\x17\
    \x08\x19\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x17\x08\x14\n\x0c\n\x05\
    \x05\x01\x02\x03\x02\x12\x03\x17\x17\x18\n\x0b\n\x04\x05\x01\x02\x04\x12\
    \x03\x18\x08\x18\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x18\x08\x13\n\
    \x0c\n\x05\x05\x01\x02\x04\x02\x12\x03\x18\x16\x17\n\n\n\x02\x04\0\x12\
    \x04\x1b\0;\x01\n\n\n\x03\x04\0\x01\x12\x03\x1b\x08\x1a\n\x0c\n\x04\x04\
    \0\x03\0\x12\x04\x1c\x08\x1f\t\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03\x1c\
    \x10\x1c\n\r\n\x06\x04\0\x03\0\x02\0\x12\x03\x1d\x10-\n\x0e\n\x07\x04\0\
    \x03\0\x02\0\x04\x12\x03\x1d\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\
    \x12\x03\x1d\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03\x1d\x20(\
    \n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03\x1d+,\n\r\n\x06\x04\0\x03\0\
    \x02\x01\x12\x03\x1e\x104\n\x0e\n\x07\x04\0\x03\0\x02\x01\x04\x12\x03\
    \x1e\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03\x1e\x19\x1f\n\
    \x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03\x1e\x20/\n\x0e\n\x07\x04\0\
    \x03\0\x02\x01\x03\x12\x03\x1e23\n\x0c\n\x04\x04\0\x03\x01\x12\x04!\x08%\
    \t\n\x0c\n\x05\x04\0\x03\x01\x01\x12\x03!\x10\x13\n\r\n\x06\x04\0\x03\
    \x01\x02\0\x12\x03\"\x100\n\x0e\n\x07\x04\0\x03\x01\x02\0\x04\x12\x03\"\
    \x10\x18\n\x0e\n\x07\x04\0\x03\x01\x02\0\x05\x12\x03\"\x19\x1f\n\x0e\n\
    \x07\x04\0\x03\x01\x02\0\x01\x12\x03\"\x20+\n\x0e\n\x07\x04\0\x03\x01\
    \x02\0\x03\x12\x03\"./\n\r\n\x06\x04\0\x03\x01\x02\x01\x12\x03#\x10.\n\
    \x0e\n\x07\x04\0\x03\x01\x02\x01\x04\x12\x03#\x10\x18\n\x0e\n\x07\x04\0\
    \x03\x01\x02\x01\x05\x12\x03#\x19\x1f\n\x0e\n\x07\x04\0\x03\x01\x02\x01\
    \x01\x12\x03#\x20)\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x03\x12\x03#,-\n\r\
    \n\x06\x04\0\x03\x01\x02\x02\x12\x03$\x10(\n\x0e\n\x07\x04\0\x03\x01\x02\
    \x02\x04\x12\x03$\x10\x18\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x05\x12\x03$\
    \x19\x1f\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x01\x12\x03$\x20#\n\x0e\n\x07\
    \x04\0\x03\x01\x02\x02\x03\x12\x03$&'\n\x0b\n\x04\x04\0\x02\0\x12\x03'\
    \x08!\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03'\x08\x10\n\x0c\n\x05\x04\0\x02\
    \0\x05\x12\x03'\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03'\x18\x1c\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03'\x1f\x20\n\x0b\n\x04\x04\0\x02\x01\
    \x12\x03(\x08$\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03(\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x03(\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03(\x18\x1f\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03(\"#\n\x0b\n\x04\
    \x04\0\x02\x02\x12\x03)\x08*\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03)\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03)\x11\x17\n\x0c\n\x05\x04\0\
    \x02\x02\x01\x12\x03)\x18%\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03)()\n\
    \x0b\n\x04\x04\0\x02\x03\x12\x03*\x08,\n\x0c\n\x05\x04\0\x02\x03\x04\x12\
    \x03*\x08\x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03*\x11\x17\n\x0c\n\x05\
    \x04\0\x02\x03\x01\x12\x03*\x18'\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03**\
    +\n\x0b\n\x04\x04\0\x02\x04\x12\x03+\x08+\n\x0c\n\x05\x04\0\x02\x04\x04\
    \x12\x03+\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03+\x11\x17\n\x0c\n\
    \x05\x04\0\x02\x04\x01\x12\x03+\x18&\n\x0c\n\x05\x04\0\x02\x04\x03\x12\
    \x03+)*\n\x0b\n\x04\x04\0\x02\x05\x12\x03,\x08/\n\x0c\n\x05\x04\0\x02\
    \x05\x04\x12\x03,\x08\x10\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03,\x11\x17\
    \n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03,\x18*\n\x0c\n\x05\x04\0\x02\x05\
    \x03\x12\x03,-.\n\x0b\n\x04\x04\0\x02\x06\x12\x03-\x08/\n\x0c\n\x05\x04\
    \0\x02\x06\x04\x12\x03-\x08\x10\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03-\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03-\x18*\n\x0c\n\x05\x04\0\
    \x02\x06\x03\x12\x03--.\n\x0b\n\x04\x04\0\x02\x07\x12\x03.\x08/\n\x0c\n\
    \x05\x04\0\x02\x07\x04\x12\x03.\x08\x10\n\x0c\n\x05\x04\0\x02\x07\x06\
    \x12\x03.\x11\x20\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03.!*\n\x0c\n\x05\
    \x04\0\x02\x07\x03\x12\x03.-.\n\x0b\n\x04\x04\0\x02\x08\x12\x03/\x08+\n\
    \x0c\n\x05\x04\0\x02\x08\x04\x12\x03/\x08\x10\n\x0c\n\x05\x04\0\x02\x08\
    \x05\x12\x03/\x11\x17\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03/\x18&\n\x0c\
    \n\x05\x04\0\x02\x08\x03\x12\x03/)*\n\x0b\n\x04\x04\0\x02\t\x12\x030\x08\
    )\n\x0c\n\x05\x04\0\x02\t\x04\x12\x030\x08\x10\n\x0c\n\x05\x04\0\x02\t\
    \x05\x12\x030\x11\x17\n\x0c\n\x05\x04\0\x02\t\x01\x12\x030\x18#\n\x0c\n\
    \x05\x04\0\x02\t\x03\x12\x030&(\n\x0b\n\x04\x04\0\x02\n\x12\x031\x08'\n\
    \x0c\n\x05\x04\0\x02\n\x04\x12\x031\x08\x10\n\x0c\n\x05\x04\0\x02\n\x05\
    \x12\x031\x11\x17\n\x0c\n\x05\x04\0\x02\n\x01\x12\x031\x18!\n\x0c\n\x05\
    \x04\0\x02\n\x03\x12\x031$&\n\x0b\n\x04\x04\0\x02\x0b\x12\x032\x08'\n\
    \x0c\n\x05\x04\0\x02\x0b\x04\x12\x032\x08\x10\n\x0c\n\x05\x04\0\x02\x0b\
    \x05\x12\x032\x11\x17\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x032\x18!\n\x0c\
    \n\x05\x04\0\x02\x0b\x03\x12\x032$&\n\x0b\n\x04\x04\0\x02\x0c\x12\x033\
    \x08'\n\x0c\n\x05\x04\0\x02\x0c\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\0\
    \x02\x0c\x05\x12\x033\x11\x17\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x033\x18\
    !\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x033$&\n\x0b\n\x04\x04\0\x02\r\x12\
    \x034\x08>\n\x0c\n\x05\x04\0\x02\r\x04\x12\x034\x08\x10\n\x0c\n\x05\x04\
    \0\x02\r\x06\x12\x034\x110\n\x0c\n\x05\x04\0\x02\r\x01\x12\x03418\n\x0c\
    \n\x05\x04\0\x02\r\x03\x12\x034;=\n\x0b\n\x04\x04\0\x02\x0e\x12\x035\x08\
    )\n\x0c\n\x05\x04\0\x02\x0e\x04\x12\x035\x08\x10\n\x0c\n\x05\x04\0\x02\
    \x0e\x05\x12\x035\x11\x17\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x035\x18#\n\
    \x0c\n\x05\x04\0\x02\x0e\x03\x12\x035&(\n\x0b\n\x04\x04\0\x02\x0f\x12\
    \x036\x08)\n\x0c\n\x05\x04\0\x02\x0f\x04\x12\x036\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x0f\x05\x12\x036\x11\x17\n\x0c\n\x05\x04\0\x02\x0f\x01\x12\
    \x036\x18#\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x036&(\n\x0b\n\x04\x04\0\
    \x02\x10\x12\x037\x08'\n\x0c\n\x05\x04\0\x02\x10\x04\x12\x037\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x10\x05\x12\x037\x11\x15\n\x0c\n\x05\x04\0\x02\x10\
    \x01\x12\x037\x16!\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x037$&\n\x0b\n\x04\
    \x04\0\x02\x11\x12\x038\x08(\n\x0c\n\x05\x04\0\x02\x11\x04\x12\x038\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x11\x05\x12\x038\x11\x15\n\x0c\n\x05\x04\0\
    \x02\x11\x01\x12\x038\x16\"\n\x0c\n\x05\x04\0\x02\x11\x03\x12\x038%'\n\
    \x0b\n\x04\x04\0\x02\x12\x12\x039\x08(\n\x0c\n\x05\x04\0\x02\x12\x04\x12\
    \x039\x08\x10\n\x0c\n\x05\x04\0\x02\x12\x05\x12\x039\x11\x17\n\x0c\n\x05\
    \x04\0\x02\x12\x01\x12\x039\x18\"\n\x0c\n\x05\x04\0\x02\x12\x03\x12\x039\
    %'\n\x0b\n\x04\x04\0\x02\x13\x12\x03:\x082\n\x0c\n\x05\x04\0\x02\x13\x04\
    \x12\x03:\x08\x10\n\x0c\n\x05\x04\0\x02\x13\x06\x12\x03:\x11'\n\x0c\n\
    \x05\x04\0\x02\x13\x01\x12\x03:(,\n\x0c\n\x05\x04\0\x02\x13\x03\x12\x03:\
    /1\n\n\n\x02\x04\x01\x12\x04=\0i\x01\n\n\n\x03\x04\x01\x01\x12\x03=\x08\
    \x1f\n\x0c\n\x04\x04\x01\x03\0\x12\x04>\x08M\t\n\x0c\n\x05\x04\x01\x03\0\
    \x01\x12\x03>\x10\x1c\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x03?\x10-\n\x0e\
    \n\x07\x04\x01\x03\0\x02\0\x04\x12\x03?\x10\x18\n\x0e\n\x07\x04\x01\x03\
    \0\x02\0\x05\x12\x03?\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\0\x01\x12\
    \x03?\x20(\n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\x12\x03?+,\n\r\n\x06\x04\
    \x01\x03\0\x02\x01\x12\x03@\x10,\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x04\
    \x12\x03@\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x05\x12\x03@\x19\x1f\
    \n\x0e\n\x07\x04\x01\x03\0\x02\x01\x01\x12\x03@\x20'\n\x0e\n\x07\x04\x01\
    \x03\0\x02\x01\x03\x12\x03@*+\n\r\n\x06\x04\x01\x03\0\x02\x02\x12\x03A\
    \x10.\n\x0e\n\x07\x04\x01\x03\0\x02\x02\x04\x12\x03A\x10\x18\n\x0e\n\x07\
    \x04\x01\x03\0\x02\x02\x05\x12\x03A\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\
    \x02\x02\x01\x12\x03A\x20)\n\x0e\n\x07\x04\x01\x03\0\x02\x02\x03\x12\x03\
    A,-\n\r\n\x06\x04\x01\x03\0\x02\x03\x12\x03B\x10-\n\x0e\n\x07\x04\x01\
    \x03\0\x02\x03\x04\x12\x03B\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x03\
    \x05\x12\x03B\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x03\x01\x12\x03B\x20\
    (\n\x0e\n\x07\x04\x01\x03\0\x02\x03\x03\x12\x03B+,\n\r\n\x06\x04\x01\x03\
    \0\x02\x04\x12\x03C\x10.\n\x0e\n\x07\x04\x01\x03\0\x02\x04\x04\x12\x03C\
    \x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x04\x05\x12\x03C\x19\x1f\n\x0e\n\
    \x07\x04\x01\x03\0\x02\x04\x01\x12\x03C\x20)\n\x0e\n\x07\x04\x01\x03\0\
    \x02\x04\x03\x12\x03C,-\n\r\n\x06\x04\x01\x03\0\x02\x05\x12\x03D\x102\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x05\x04\x12\x03D\x10\x18\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x05\x05\x12\x03D\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x05\x01\x12\x03D\x20-\n\x0e\n\x07\x04\x01\x03\0\x02\x05\x03\x12\x03D01\
    \n\r\n\x06\x04\x01\x03\0\x02\x06\x12\x03E\x10)\n\x0e\n\x07\x04\x01\x03\0\
    \x02\x06\x04\x12\x03E\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x06\x05\x12\
    \x03E\x19\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\x06\x01\x12\x03E\x20$\n\x0e\
    \n\x07\x04\x01\x03\0\x02\x06\x03\x12\x03E'(\n\r\n\x06\x04\x01\x03\0\x02\
    \x07\x12\x03F\x10+\n\x0e\n\x07\x04\x01\x03\0\x02\x07\x04\x12\x03F\x10\
    \x18\n\x0e\n\x07\x04\x01\x03\0\x02\x07\x05\x12\x03F\x19\x1f\n\x0e\n\x07\
    \x04\x01\x03\0\x02\x07\x01\x12\x03F\x20&\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x07\x03\x12\x03F)*\n\r\n\x06\x04\x01\x03\0\x02\x08\x12\x03G\x10)\n\x0e\
    \n\x07\x04\x01\x03\0\x02\x08\x04\x12\x03G\x10\x18\n\x0e\n\x07\x04\x01\
    \x03\0\x02\x08\x05\x12\x03G\x19\x1e\n\x0e\n\x07\x04\x01\x03\0\x02\x08\
    \x01\x12\x03G\x1f$\n\x0e\n\x07\x04\x01\x03\0\x02\x08\x03\x12\x03G'(\n\r\
    \n\x06\x04\x01\x03\0\x02\t\x12\x03H\x107\n\x0e\n\x07\x04\x01\x03\0\x02\t\
    \x04\x12\x03H\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\t\x05\x12\x03H\x19\
    \x1f\n\x0e\n\x07\x04\x01\x03\0\x02\t\x01\x12\x03H\x201\n\x0e\n\x07\x04\
    \x01\x03\0\x02\t\x03\x12\x03H46\n\r\n\x06\x04\x01\x03\0\x02\n\x12\x03I\
    \x109\n\x0e\n\x07\x04\x01\x03\0\x02\n\x04\x12\x03I\x10\x18\n\x0e\n\x07\
    \x04\x01\x03\0\x02\n\x05\x12\x03I\x19\x1e\n\x0e\n\x07\x04\x01\x03\0\x02\
    \n\x01\x12\x03I\x1f3\n\x0e\n\x07\x04\x01\x03\0\x02\n\x03\x12\x03I68\n\r\
    \n\x06\x04\x01\x03\0\x02\x0b\x12\x03J\x109\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x0b\x04\x12\x03J\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x0b\x05\x12\x03J\
    \x19\x1e\n\x0e\n\x07\x04\x01\x03\0\x02\x0b\x01\x12\x03J\x1f3\n\x0e\n\x07\
    \x04\x01\x03\0\x02\x0b\x03\x12\x03J68\n\r\n\x06\x04\x01\x03\0\x02\x0c\
    \x12\x03K\x10:\n\x0e\n\x07\x04\x01\x03\0\x02\x0c\x04\x12\x03K\x10\x18\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x0c\x05\x12\x03K\x19\x1e\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x0c\x01\x12\x03K\x1f4\n\x0e\n\x07\x04\x01\x03\0\x02\x0c\
    \x03\x12\x03K79\n\r\n\x06\x04\x01\x03\0\x02\r\x12\x03L\x10*\n\x0e\n\x07\
    \x04\x01\x03\0\x02\r\x04\x12\x03L\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\
    \r\x05\x12\x03L\x19\x1d\n\x0e\n\x07\x04\x01\x03\0\x02\r\x01\x12\x03L\x1e\
    $\n\x0e\n\x07\x04\x01\x03\0\x02\r\x03\x12\x03L')\n\x0b\n\x04\x04\x01\x02\
    \0\x12\x03O\x08!\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03O\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\0\x05\x12\x03O\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03O\x18\x1c\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03O\x1f\x20\n\x0b\n\
    \x04\x04\x01\x02\x01\x12\x03P\x08*\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03P\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03P\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03P\x18%\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03P()\n\x0b\n\x04\x04\x01\x02\x02\x12\x03Q\x081\n\x0c\n\x05\x04\
    \x01\x02\x02\x04\x12\x03Q\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\
    \x03Q\x11\x17\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03Q\x18,\n\x0c\n\x05\
    \x04\x01\x02\x02\x03\x12\x03Q/0\n\x0b\n\x04\x04\x01\x02\x03\x12\x03R\x08\
    4\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03R\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x03\x05\x12\x03R\x11\x17\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03R\
    \x18/\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03R23\n\x0b\n\x04\x04\x01\x02\
    \x04\x12\x03S\x084\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03S\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x04\x05\x12\x03S\x11\x17\n\x0c\n\x05\x04\x01\x02\
    \x04\x01\x12\x03S\x18/\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03S23\n\x0b\
    \n\x04\x04\x01\x02\x05\x12\x03T\x081\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\
    \x03T\x08\x10\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03T\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\x05\x01\x12\x03T\x18,\n\x0c\n\x05\x04\x01\x02\x05\x03\
    \x12\x03T/0\n\x0b\n\x04\x04\x01\x02\x06\x12\x03U\x08'\n\x0c\n\x05\x04\
    \x01\x02\x06\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\x01\x02\x06\x05\x12\
    \x03U\x11\x17\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03U\x18\"\n\x0c\n\x05\
    \x04\x01\x02\x06\x03\x12\x03U%&\n\x0b\n\x04\x04\x01\x02\x07\x12\x03V\x08\
    :\n\x0c\n\x05\x04\x01\x02\x07\x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x07\x06\x12\x03V\x11%\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03V&5\n\
    \x0c\n\x05\x04\x01\x02\x07\x03\x12\x03V89\n\x0b\n\x04\x04\x01\x02\x08\
    \x12\x03W\x087\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\x03W\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x08\x06\x12\x03W\x11\x20\n\x0c\n\x05\x04\x01\x02\x08\
    \x01\x12\x03W!2\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03W56\n\x0b\n\x04\
    \x04\x01\x02\t\x12\x03X\x08#\n\x0c\n\x05\x04\x01\x02\t\x04\x12\x03X\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03X\x11\x17\n\x0c\n\x05\x04\x01\
    \x02\t\x01\x12\x03X\x18\x1d\n\x0c\n\x05\x04\x01\x02\t\x03\x12\x03X\x20\"\
    \n\x0b\n\x04\x04\x01\x02\n\x12\x03Y\x08(\n\x0c\n\x05\x04\x01\x02\n\x04\
    \x12\x03Y\x08\x10\n\x0c\n\x05\x04\x01\x02\n\x05\x12\x03Y\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\n\x01\x12\x03Y\x18\"\n\x0c\n\x05\x04\x01\x02\n\x03\x12\
    \x03Y%'\n\x0b\n\x04\x04\x01\x02\x0b\x12\x03Z\x08)\n\x0c\n\x05\x04\x01\
    \x02\x0b\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\x01\x02\x0b\x05\x12\x03Z\
    \x11\x15\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03Z\x16#\n\x0c\n\x05\x04\
    \x01\x02\x0b\x03\x12\x03Z&(\n\x0b\n\x04\x04\x01\x02\x0c\x12\x03[\x08*\n\
    \x0c\n\x05\x04\x01\x02\x0c\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\x01\x02\
    \x0c\x05\x12\x03[\x11\x15\n\x0c\n\x05\x04\x01\x02\x0c\x01\x12\x03[\x16$\
    \n\x0c\n\x05\x04\x01\x02\x0c\x03\x12\x03[')\n\x0b\n\x04\x04\x01\x02\r\
    \x12\x03\\\x08(\n\x0c\n\x05\x04\x01\x02\r\x04\x12\x03\\\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\r\x05\x12\x03\\\x11\x15\n\x0c\n\x05\x04\x01\x02\r\x01\
    \x12\x03\\\x16\"\n\x0c\n\x05\x04\x01\x02\r\x03\x12\x03\\%'\n\x0b\n\x04\
    \x04\x01\x02\x0e\x12\x03]\x08)\n\x0c\n\x05\x04\x01\x02\x0e\x04\x12\x03]\
    \x08\x10\n\x0c\n\x05\x04\x01\x02\x0e\x06\x12\x03]\x11\x1d\n\x0c\n\x05\
    \x04\x01\x02\x0e\x01\x12\x03]\x1e#\n\x0c\n\x05\x04\x01\x02\x0e\x03\x12\
    \x03]&(\n\x0b\n\x04\x04\x01\x02\x0f\x12\x03^\x08+\n\x0c\n\x05\x04\x01\
    \x02\x0f\x04\x12\x03^\x08\x10\n\x0c\n\x05\x04\x01\x02\x0f\x06\x12\x03^\
    \x11\x1e\n\x0c\n\x05\x04\x01\x02\x0f\x01\x12\x03^\x1f%\n\x0c\n\x05\x04\
    \x01\x02\x0f\x03\x12\x03^(*\n\x0b\n\x04\x04\x01\x02\x10\x12\x03_\x08(\n\
    \x0c\n\x05\x04\x01\x02\x10\x04\x12\x03_\x08\x10\n\x0c\n\x05\x04\x01\x02\
    \x10\x05\x12\x03_\x11\x17\n\x0c\n\x05\x04\x01\x02\x10\x01\x12\x03_\x18\"\
    \n\x0c\n\x05\x04\x01\x02\x10\x03\x12\x03_%'\n\x0b\n\x04\x04\x01\x02\x11\
    \x12\x03`\x08&\n\x0c\n\x05\x04\x01\x02\x11\x04\x12\x03`\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x11\x05\x12\x03`\x11\x17\n\x0c\n\x05\x04\x01\x02\x11\
    \x01\x12\x03`\x18\x20\n\x0c\n\x05\x04\x01\x02\x11\x03\x12\x03`#%\n\x0b\n\
    \x04\x04\x01\x02\x12\x12\x03a\x08?\n\x0c\n\x05\x04\x01\x02\x12\x04\x12\
    \x03a\x08\x10\n\x0c\n\x05\x04\x01\x02\x12\x05\x12\x03a\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\x12\x01\x12\x03a\x189\n\x0c\n\x05\x04\x01\x02\x12\x03\
    \x12\x03a<>\n\x0b\n\x04\x04\x01\x02\x13\x12\x03b\x08<\n\x0c\n\x05\x04\
    \x01\x02\x13\x04\x12\x03b\x08\x10\n\x0c\n\x05\x04\x01\x02\x13\x05\x12\
    \x03b\x11\x17\n\x0c\n\x05\x04\x01\x02\x13\x01\x12\x03b\x186\n\x0c\n\x05\
    \x04\x01\x02\x13\x03\x12\x03b9;\n\x0b\n\x04\x04\x01\x02\x14\x12\x03c\x08\
    >\n\x0c\n\x05\x04\x01\x02\x14\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x14\x05\x12\x03c\x11\x17\n\x0c\n\x05\x04\x01\x02\x14\x01\x12\x03c\
    \x188\n\x0c\n\x05\x04\x01\x02\x14\x03\x12\x03c;=\n\x0b\n\x04\x04\x01\x02\
    \x15\x12\x03d\x08;\n\x0c\n\x05\x04\x01\x02\x15\x04\x12\x03d\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x15\x05\x12\x03d\x11\x17\n\x0c\n\x05\x04\x01\x02\
    \x15\x01\x12\x03d\x185\n\x0c\n\x05\x04\x01\x02\x15\x03\x12\x03d8:\n\x0b\
    \n\x04\x04\x01\x02\x16\x12\x03e\x084\n\x0c\n\x05\x04\x01\x02\x16\x04\x12\
    \x03e\x08\x10\n\x0c\n\x05\x04\x01\x02\x16\x05\x12\x03e\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\x16\x01\x12\x03e\x18.\n\x0c\n\x05\x04\x01\x02\x16\x03\
    \x12\x03e13\n\x0b\n\x04\x04\x01\x02\x17\x12\x03f\x08J\n\x0c\n\x05\x04\
    \x01\x02\x17\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\x01\x02\x17\x06\x12\
    \x03f\x115\n\x0c\n\x05\x04\x01\x02\x17\x01\x12\x03f6D\n\x0c\n\x05\x04\
    \x01\x02\x17\x03\x12\x03fGI\n\x0b\n\x04\x04\x01\x02\x18\x12\x03g\x08/\n\
    \x0c\n\x05\x04\x01\x02\x18\x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\x01\x02\
    \x18\x06\x12\x03g\x11#\n\x0c\n\x05\x04\x01\x02\x18\x01\x12\x03g$)\n\x0c\
    \n\x05\x04\x01\x02\x18\x03\x12\x03g,.\n\x0b\n\x04\x04\x01\x02\x19\x12\
    \x03h\x08:\n\x0c\n\x05\x04\x01\x02\x19\x04\x12\x03h\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\x19\x06\x12\x03h\x11(\n\x0c\n\x05\x04\x01\x02\x19\x01\x12\
    \x03h)4\n\x0c\n\x05\x04\x01\x02\x19\x03\x12\x03h79\n\x0b\n\x02\x04\x02\
    \x12\x05k\0\xb0\x01\x01\n\n\n\x03\x04\x02\x01\x12\x03k\x08\x16\n\x0c\n\
    \x04\x04\x02\x03\0\x12\x04l\x08{\t\n\x0c\n\x05\x04\x02\x03\0\x01\x12\x03\
    l\x10\x14\n\r\n\x06\x04\x02\x03\0\x02\0\x12\x03m\x10.\n\x0e\n\x07\x04\
    \x02\x03\0\x02\0\x04\x12\x03m\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\0\
    \x05\x12\x03m\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\0\x01\x12\x03m\x20)\
    \n\x0e\n\x07\x04\x02\x03\0\x02\0\x03\x12\x03m,-\n\r\n\x06\x04\x02\x03\0\
    \x02\x01\x12\x03n\x10)\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x04\x12\x03n\
    \x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x05\x12\x03n\x19\x1f\n\x0e\n\
    \x07\x04\x02\x03\0\x02\x01\x01\x12\x03n\x20$\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x01\x03\x12\x03n'(\n\r\n\x06\x04\x02\x03\0\x02\x02\x12\x03o\x10.\n\
    \x0e\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x03o\x10\x18\n\x0e\n\x07\x04\
    \x02\x03\0\x02\x02\x06\x12\x03o\x19$\n\x0e\n\x07\x04\x02\x03\0\x02\x02\
    \x01\x12\x03o%)\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x03\x12\x03o,-\n\r\n\
    \x06\x04\x02\x03\0\x02\x03\x12\x03p\x102\n\x0e\n\x07\x04\x02\x03\0\x02\
    \x03\x04\x12\x03p\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x03\x06\x12\x03p\
    \x19&\n\x0e\n\x07\x04\x02\x03\0\x02\x03\x01\x12\x03p'-\n\x0e\n\x07\x04\
    \x02\x03\0\x02\x03\x03\x12\x03p01\n\r\n\x06\x04\x02\x03\0\x02\x04\x12\
    \x03q\x10(\n\x0e\n\x07\x04\x02\x03\0\x02\x04\x04\x12\x03q\x10\x18\n\x0e\
    \n\x07\x04\x02\x03\0\x02\x04\x05\x12\x03q\x19\x1f\n\x0e\n\x07\x04\x02\
    \x03\0\x02\x04\x01\x12\x03q\x20#\n\x0e\n\x07\x04\x02\x03\0\x02\x04\x03\
    \x12\x03q&'\n\r\n\x06\x04\x02\x03\0\x02\x05\x12\x03r\x100\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x05\x04\x12\x03r\x10\x18\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x05\x05\x12\x03r\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\x05\x01\x12\
    \x03r\x20+\n\x0e\n\x07\x04\x02\x03\0\x02\x05\x03\x12\x03r./\n\r\n\x06\
    \x04\x02\x03\0\x02\x06\x12\x03s\x10*\n\x0e\n\x07\x04\x02\x03\0\x02\x06\
    \x04\x12\x03s\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x06\x05\x12\x03s\x19\
    \x1f\n\x0e\n\x07\x04\x02\x03\0\x02\x06\x01\x12\x03s\x20%\n\x0e\n\x07\x04\
    \x02\x03\0\x02\x06\x03\x12\x03s()\n\r\n\x06\x04\x02\x03\0\x02\x07\x12\
    \x03t\x104\n\x0e\n\x07\x04\x02\x03\0\x02\x07\x04\x12\x03t\x10\x18\n\x0e\
    \n\x07\x04\x02\x03\0\x02\x07\x05\x12\x03t\x19\x1f\n\x0e\n\x07\x04\x02\
    \x03\0\x02\x07\x01\x12\x03t\x20/\n\x0e\n\x07\x04\x02\x03\0\x02\x07\x03\
    \x12\x03t23\n\r\n\x06\x04\x02\x03\0\x02\x08\x12\x03u\x102\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x08\x04\x12\x03u\x10\x18\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x08\x05\x12\x03u\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\x08\x01\x12\
    \x03u\x20-\n\x0e\n\x07\x04\x02\x03\0\x02\x08\x03\x12\x03u01\n\r\n\x06\
    \x04\x02\x03\0\x02\t\x12\x03v\x108\n\x0e\n\x07\x04\x02\x03\0\x02\t\x04\
    \x12\x03v\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\t\x05\x12\x03v\x19\x1f\n\
    \x0e\n\x07\x04\x02\x03\0\x02\t\x01\x12\x03v\x202\n\x0e\n\x07\x04\x02\x03\
    \0\x02\t\x03\x12\x03v57\n\r\n\x06\x04\x02\x03\0\x02\n\x12\x03w\x100\n\
    \x0e\n\x07\x04\x02\x03\0\x02\n\x04\x12\x03w\x10\x18\n\x0e\n\x07\x04\x02\
    \x03\0\x02\n\x05\x12\x03w\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\n\x01\
    \x12\x03w\x20*\n\x0e\n\x07\x04\x02\x03\0\x02\n\x03\x12\x03w-/\n\r\n\x06\
    \x04\x02\x03\0\x02\x0b\x12\x03x\x103\n\x0e\n\x07\x04\x02\x03\0\x02\x0b\
    \x04\x12\x03x\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x0b\x06\x12\x03x\x19\
    &\n\x0e\n\x07\x04\x02\x03\0\x02\x0b\x01\x12\x03x'-\n\x0e\n\x07\x04\x02\
    \x03\0\x02\x0b\x03\x12\x03x02\n\r\n\x06\x04\x02\x03\0\x02\x0c\x12\x03y\
    \x10:\n\x0e\n\x07\x04\x02\x03\0\x02\x0c\x04\x12\x03y\x10\x18\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x0c\x05\x12\x03y\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x0c\x01\x12\x03y\x204\n\x0e\n\x07\x04\x02\x03\0\x02\x0c\x03\x12\x03\
    y79\n\r\n\x06\x04\x02\x03\0\x02\r\x12\x03z\x109\n\x0e\n\x07\x04\x02\x03\
    \0\x02\r\x04\x12\x03z\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\r\x05\x12\
    \x03z\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\r\x01\x12\x03z\x203\n\x0e\n\
    \x07\x04\x02\x03\0\x02\r\x03\x12\x03z68\n\r\n\x04\x04\x02\x03\x01\x12\
    \x05}\x08\x81\x01\t\n\x0c\n\x05\x04\x02\x03\x01\x01\x12\x03}\x10\x15\n\r\
    \n\x06\x04\x02\x03\x01\x02\0\x12\x03~\x10/\n\x0e\n\x07\x04\x02\x03\x01\
    \x02\0\x04\x12\x03~\x10\x18\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x05\x12\
    \x03~\x19\x1f\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x01\x12\x03~\x20*\n\x0e\
    \n\x07\x04\x02\x03\x01\x02\0\x03\x12\x03~-.\n\r\n\x06\x04\x02\x03\x01\
    \x02\x01\x12\x03\x7f\x10-\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x04\x12\
    \x03\x7f\x10\x18\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x05\x12\x03\x7f\x19\
    \x1d\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x01\x12\x03\x7f\x1e(\n\x0e\n\
    \x07\x04\x02\x03\x01\x02\x01\x03\x12\x03\x7f+,\n\x0e\n\x06\x04\x02\x03\
    \x01\x02\x02\x12\x04\x80\x01\x102\n\x0f\n\x07\x04\x02\x03\x01\x02\x02\
    \x04\x12\x04\x80\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x01\x02\x02\x05\x12\
    \x04\x80\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x01\x02\x02\x01\x12\x04\x80\
    \x01\x20-\n\x0f\n\x07\x04\x02\x03\x01\x02\x02\x03\x12\x04\x80\x0101\n\
    \x0e\n\x04\x04\x02\x03\x02\x12\x06\x83\x01\x08\x88\x01\t\n\r\n\x05\x04\
    \x02\x03\x02\x01\x12\x04\x83\x01\x10\x1d\n\x0e\n\x06\x04\x02\x03\x02\x02\
    \0\x12\x04\x84\x01\x10-\n\x0f\n\x07\x04\x02\x03\x02\x02\0\x04\x12\x04\
    \x84\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x02\x02\0\x05\x12\x04\x84\x01\
    \x19\x1f\n\x0f\n\x07\x04\x02\x03\x02\x02\0\x01\x12\x04\x84\x01\x20(\n\
    \x0f\n\x07\x04\x02\x03\x02\x02\0\x03\x12\x04\x84\x01+,\n\x0e\n\x06\x04\
    \x02\x03\x02\x02\x01\x12\x04\x85\x01\x109\n\x0f\n\x07\x04\x02\x03\x02\
    \x02\x01\x04\x12\x04\x85\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x02\x02\x01\
    \x05\x12\x04\x85\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x02\x02\x01\x01\x12\
    \x04\x85\x01\x204\n\x0f\n\x07\x04\x02\x03\x02\x02\x01\x03\x12\x04\x85\
    \x0178\n\x0e\n\x06\x04\x02\x03\x02\x02\x02\x12\x04\x86\x01\x100\n\x0f\n\
    \x07\x04\x02\x03\x02\x02\x02\x04\x12\x04\x86\x01\x10\x18\n\x0f\n\x07\x04\
    \x02\x03\x02\x02\x02\x05\x12\x04\x86\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\
    \x02\x02\x02\x01\x12\x04\x86\x01\x20+\n\x0f\n\x07\x04\x02\x03\x02\x02\
    \x02\x03\x12\x04\x86\x01./\n\x0e\n\x06\x04\x02\x03\x02\x02\x03\x12\x04\
    \x87\x01\x10;\n\x0f\n\x07\x04\x02\x03\x02\x02\x03\x04\x12\x04\x87\x01\
    \x10\x18\n\x0f\n\x07\x04\x02\x03\x02\x02\x03\x05\x12\x04\x87\x01\x19\x1f\
    \n\x0f\n\x07\x04\x02\x03\x02\x02\x03\x01\x12\x04\x87\x01\x206\n\x0f\n\
    \x07\x04\x02\x03\x02\x02\x03\x03\x12\x04\x87\x019:\n\x0e\n\x04\x04\x02\
    \x03\x03\x12\x06\x8a\x01\x08\x8f\x01\t\n\r\n\x05\x04\x02\x03\x03\x01\x12\
    \x04\x8a\x01\x10\x19\n\x0e\n\x06\x04\x02\x03\x03\x02\0\x12\x04\x8b\x01\
    \x104\n\x0f\n\x07\x04\x02\x03\x03\x02\0\x04\x12\x04\x8b\x01\x10\x18\n\
    \x0f\n\x07\x04\x02\x03\x03\x02\0\x05\x12\x04\x8b\x01\x19\x1f\n\x0f\n\x07\
    \x04\x02\x03\x03\x02\0\x01\x12\x04\x8b\x01\x20/\n\x0f\n\x07\x04\x02\x03\
    \x03\x02\0\x03\x12\x04\x8b\x0123\n\x0e\n\x06\x04\x02\x03\x03\x02\x01\x12\
    \x04\x8c\x01\x105\n\x0f\n\x07\x04\x02\x03\x03\x02\x01\x04\x12\x04\x8c\
    \x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x03\x02\x01\x05\x12\x04\x8c\x01\x19\
    \x1f\n\x0f\n\x07\x04\x02\x03\x03\x02\x01\x01\x12\x04\x8c\x01\x200\n\x0f\
    \n\x07\x04\x02\x03\x03\x02\x01\x03\x12\x04\x8c\x0134\n\x0e\n\x06\x04\x02\
    \x03\x03\x02\x02\x12\x04\x8d\x01\x109\n\x0f\n\x07\x04\x02\x03\x03\x02\
    \x02\x04\x12\x04\x8d\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x03\x02\x02\x05\
    \x12\x04\x8d\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x03\x02\x02\x01\x12\x04\
    \x8d\x01\x204\n\x0f\n\x07\x04\x02\x03\x03\x02\x02\x03\x12\x04\x8d\x0178\
    \n\x0e\n\x06\x04\x02\x03\x03\x02\x03\x12\x04\x8e\x01\x10K\n\x0f\n\x07\
    \x04\x02\x03\x03\x02\x03\x04\x12\x04\x8e\x01\x10\x18\n\x0f\n\x07\x04\x02\
    \x03\x03\x02\x03\x06\x12\x04\x8e\x01\x195\n\x0f\n\x07\x04\x02\x03\x03\
    \x02\x03\x01\x12\x04\x8e\x016F\n\x0f\n\x07\x04\x02\x03\x03\x02\x03\x03\
    \x12\x04\x8e\x01IJ\n\x0e\n\x04\x04\x02\x03\x04\x12\x06\x91\x01\x08\x98\
    \x01\t\n\r\n\x05\x04\x02\x03\x04\x01\x12\x04\x91\x01\x10\x16\n\x0e\n\x06\
    \x04\x02\x03\x04\x02\0\x12\x04\x92\x01\x10.\n\x0f\n\x07\x04\x02\x03\x04\
    \x02\0\x04\x12\x04\x92\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x04\x02\0\x05\
    \x12\x04\x92\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x04\x02\0\x01\x12\x04\
    \x92\x01\x20)\n\x0f\n\x07\x04\x02\x03\x04\x02\0\x03\x12\x04\x92\x01,-\n\
    \x0e\n\x06\x04\x02\x03\x04\x02\x01\x12\x04\x93\x01\x10-\n\x0f\n\x07\x04\
    \x02\x03\x04\x02\x01\x04\x12\x04\x93\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\
    \x04\x02\x01\x05\x12\x04\x93\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x04\x02\
    \x01\x01\x12\x04\x93\x01\x20(\n\x0f\n\x07\x04\x02\x03\x04\x02\x01\x03\
    \x12\x04\x93\x01+,\n\x0e\n\x06\x04\x02\x03\x04\x02\x02\x12\x04\x94\x01\
    \x10)\n\x0f\n\x07\x04\x02\x03\x04\x02\x02\x04\x12\x04\x94\x01\x10\x18\n\
    \x0f\n\x07\x04\x02\x03\x04\x02\x02\x05\x12\x04\x94\x01\x19\x1f\n\x0f\n\
    \x07\x04\x02\x03\x04\x02\x02\x01\x12\x04\x94\x01\x20$\n\x0f\n\x07\x04\
    \x02\x03\x04\x02\x02\x03\x12\x04\x94\x01'(\n\x0e\n\x06\x04\x02\x03\x04\
    \x02\x03\x12\x04\x95\x01\x10I\n\x0f\n\x07\x04\x02\x03\x04\x02\x03\x04\
    \x12\x04\x95\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x04\x02\x03\x06\x12\x04\
    \x95\x01\x191\n\x0f\n\x07\x04\x02\x03\x04\x02\x03\x01\x12\x04\x95\x012D\
    \n\x0f\n\x07\x04\x02\x03\x04\x02\x03\x03\x12\x04\x95\x01GH\n\x0e\n\x06\
    \x04\x02\x03\x04\x02\x04\x12\x04\x96\x01\x10/\n\x0f\n\x07\x04\x02\x03\
    \x04\x02\x04\x04\x12\x04\x96\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x04\x02\
    \x04\x05\x12\x04\x96\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x04\x02\x04\x01\
    \x12\x04\x96\x01\x20*\n\x0f\n\x07\x04\x02\x03\x04\x02\x04\x03\x12\x04\
    \x96\x01-.\n\x0e\n\x06\x04\x02\x03\x04\x02\x05\x12\x04\x97\x01\x10,\n\
    \x0f\n\x07\x04\x02\x03\x04\x02\x05\x04\x12\x04\x97\x01\x10\x18\n\x0f\n\
    \x07\x04\x02\x03\x04\x02\x05\x05\x12\x04\x97\x01\x19\x1f\n\x0f\n\x07\x04\
    \x02\x03\x04\x02\x05\x01\x12\x04\x97\x01\x20'\n\x0f\n\x07\x04\x02\x03\
    \x04\x02\x05\x03\x12\x04\x97\x01*+\n\x0e\n\x04\x04\x02\x03\x05\x12\x06\
    \x9a\x01\x08\xa1\x01\t\n\r\n\x05\x04\x02\x03\x05\x01\x12\x04\x9a\x01\x10\
    \x1a\n\x0e\n\x06\x04\x02\x03\x05\x02\0\x12\x04\x9b\x01\x10.\n\x0f\n\x07\
    \x04\x02\x03\x05\x02\0\x04\x12\x04\x9b\x01\x10\x18\n\x0f\n\x07\x04\x02\
    \x03\x05\x02\0\x05\x12\x04\x9b\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x05\
    \x02\0\x01\x12\x04\x9b\x01\x20)\n\x0f\n\x07\x04\x02\x03\x05\x02\0\x03\
    \x12\x04\x9b\x01,-\n\x0e\n\x06\x04\x02\x03\x05\x02\x01\x12\x04\x9c\x01\
    \x100\n\x0f\n\x07\x04\x02\x03\x05\x02\x01\x04\x12\x04\x9c\x01\x10\x18\n\
    \x0f\n\x07\x04\x02\x03\x05\x02\x01\x05\x12\x04\x9c\x01\x19\x1f\n\x0f\n\
    \x07\x04\x02\x03\x05\x02\x01\x01\x12\x04\x9c\x01\x20+\n\x0f\n\x07\x04\
    \x02\x03\x05\x02\x01\x03\x12\x04\x9c\x01./\n\x0e\n\x06\x04\x02\x03\x05\
    \x02\x02\x12\x04\x9d\x01\x10/\n\x0f\n\x07\x04\x02\x03\x05\x02\x02\x04\
    \x12\x04\x9d\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x05\x02\x02\x05\x12\x04\
    \x9d\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x05\x02\x02\x01\x12\x04\x9d\x01\
    \x20*\n\x0f\n\x07\x04\x02\x03\x05\x02\x02\x03\x12\x04\x9d\x01-.\n\x0e\n\
    \x06\x04\x02\x03\x05\x02\x03\x12\x04\x9e\x01\x10.\n\x0f\n\x07\x04\x02\
    \x03\x05\x02\x03\x04\x12\x04\x9e\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x05\
    \x02\x03\x05\x12\x04\x9e\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x05\x02\x03\
    \x01\x12\x04\x9e\x01\x20)\n\x0f\n\x07\x04\x02\x03\x05\x02\x03\x03\x12\
    \x04\x9e\x01,-\n\x0e\n\x06\x04\x02\x03\x05\x02\x04\x12\x04\x9f\x01\x10.\
    \n\x0f\n\x07\x04\x02\x03\x05\x02\x04\x04\x12\x04\x9f\x01\x10\x18\n\x0f\n\
    \x07\x04\x02\x03\x05\x02\x04\x05\x12\x04\x9f\x01\x19\x1f\n\x0f\n\x07\x04\
    \x02\x03\x05\x02\x04\x01\x12\x04\x9f\x01\x20)\n\x0f\n\x07\x04\x02\x03\
    \x05\x02\x04\x03\x12\x04\x9f\x01,-\n\x0e\n\x06\x04\x02\x03\x05\x02\x05\
    \x12\x04\xa0\x01\x10.\n\x0f\n\x07\x04\x02\x03\x05\x02\x05\x04\x12\x04\
    \xa0\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x05\x02\x05\x05\x12\x04\xa0\x01\
    \x19\x1f\n\x0f\n\x07\x04\x02\x03\x05\x02\x05\x01\x12\x04\xa0\x01\x20)\n\
    \x0f\n\x07\x04\x02\x03\x05\x02\x05\x03\x12\x04\xa0\x01,-\n\x0e\n\x04\x04\
    \x02\x03\x06\x12\x06\xa3\x01\x08\xa7\x01\t\n\r\n\x05\x04\x02\x03\x06\x01\
    \x12\x04\xa3\x01\x10\x16\n\x0e\n\x06\x04\x02\x03\x06\x02\0\x12\x04\xa4\
    \x01\x10/\n\x0f\n\x07\x04\x02\x03\x06\x02\0\x04\x12\x04\xa4\x01\x10\x18\
    \n\x0f\n\x07\x04\x02\x03\x06\x02\0\x05\x12\x04\xa4\x01\x19\x1f\n\x0f\n\
    \x07\x04\x02\x03\x06\x02\0\x01\x12\x04\xa4\x01\x20*\n\x0f\n\x07\x04\x02\
    \x03\x06\x02\0\x03\x12\x04\xa4\x01-.\n\x0e\n\x06\x04\x02\x03\x06\x02\x01\
    \x12\x04\xa5\x01\x10)\n\x0f\n\x07\x04\x02\x03\x06\x02\x01\x04\x12\x04\
    \xa5\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x06\x02\x01\x05\x12\x04\xa5\x01\
    \x19\x1f\n\x0f\n\x07\x04\x02\x03\x06\x02\x01\x01\x12\x04\xa5\x01\x20$\n\
    \x0f\n\x07\x04\x02\x03\x06\x02\x01\x03\x12\x04\xa5\x01'(\n\x0e\n\x06\x04\
    \x02\x03\x06\x02\x02\x12\x04\xa6\x01\x10,\n\x0f\n\x07\x04\x02\x03\x06\
    \x02\x02\x04\x12\x04\xa6\x01\x10\x18\n\x0f\n\x07\x04\x02\x03\x06\x02\x02\
    \x05\x12\x04\xa6\x01\x19\x1f\n\x0f\n\x07\x04\x02\x03\x06\x02\x02\x01\x12\
    \x04\xa6\x01\x20'\n\x0f\n\x07\x04\x02\x03\x06\x02\x02\x03\x12\x04\xa6\
    \x01*+\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xa9\x01\x08.\n\r\n\x05\x04\x02\
    \x02\0\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\
    \xa9\x01\x11$\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xa9\x01%)\n\r\n\x05\
    \x04\x02\x02\0\x03\x12\x04\xa9\x01,-\n\x0c\n\x04\x04\x02\x02\x01\x12\x04\
    \xaa\x01\x089\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\xaa\x01\x08\x10\n\r\
    \n\x05\x04\x02\x02\x01\x06\x12\x04\xaa\x01\x11)\n\r\n\x05\x04\x02\x02\
    \x01\x01\x12\x04\xaa\x01*4\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xaa\x01\
    78\n\x0c\n\x04\x04\x02\x02\x02\x12\x04\xab\x01\x081\n\r\n\x05\x04\x02\
    \x02\x02\x04\x12\x04\xab\x01\x08\x10\n\r\n\x05\x04\x02\x02\x02\x06\x12\
    \x04\xab\x01\x11%\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xab\x01&,\n\r\n\
    \x05\x04\x02\x02\x02\x03\x12\x04\xab\x01/0\n\x0c\n\x04\x04\x02\x02\x03\
    \x12\x04\xac\x01\x083\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04\xac\x01\x08\
    \x10\n\r\n\x05\x04\x02\x02\x03\x06\x12\x04\xac\x01\x11&\n\r\n\x05\x04\
    \x02\x02\x03\x01\x12\x04\xac\x01'.\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\
    \xac\x0112\n\x0c\n\x04\x04\x02\x02\x04\x12\x04\xad\x01\x089\n\r\n\x05\
    \x04\x02\x02\x04\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x02\x02\x04\
    \x06\x12\x04\xad\x01\x11(\n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\xad\x01)\
    4\n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\xad\x0178\n\x0c\n\x04\x04\x02\
    \x02\x05\x12\x04\xae\x01\x08<\n\r\n\x05\x04\x02\x02\x05\x04\x12\x04\xae\
    \x01\x08\x10\n\r\n\x05\x04\x02\x02\x05\x06\x12\x04\xae\x01\x11*\n\r\n\
    \x05\x04\x02\x02\x05\x01\x12\x04\xae\x01+7\n\r\n\x05\x04\x02\x02\x05\x03\
    \x12\x04\xae\x01:;\n\x0c\n\x04\x04\x02\x02\x06\x12\x04\xaf\x01\x08>\n\r\
    \n\x05\x04\x02\x02\x06\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\x02\x02\
    \x06\x06\x12\x04\xaf\x01\x11&\n\r\n\x05\x04\x02\x02\x06\x01\x12\x04\xaf\
    \x01'9\n\r\n\x05\x04\x02\x02\x06\x03\x12\x04\xaf\x01<=\n\x0c\n\x02\x04\
    \x03\x12\x06\xb2\x01\0\xb4\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xb2\
    \x01\x08\x1a\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xb3\x01\x08,\n\r\n\x05\
    \x04\x03\x02\0\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x03\x02\0\x06\
    \x12\x04\xb3\x01\x11\x1f\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xb3\x01\x20\
    '\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xb3\x01*+\n\x0c\n\x02\x04\x04\x12\
    \x06\xb6\x01\0\xc0\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xb6\x01\x08\
    \x1a\n\x0c\n\x04\x04\x04\x02\0\x12\x04\xb7\x01\x08&\n\r\n\x05\x04\x04\
    \x02\0\x04\x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\
    \xb7\x01\x11\x17\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xb7\x01\x18!\n\r\n\
    \x05\x04\x04\x02\0\x03\x12\x04\xb7\x01$%\n\x0c\n\x04\x04\x04\x02\x01\x12\
    \x04\xb8\x01\x08!\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xb8\x01\x08\x10\
    \n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xb8\x01\x11\x17\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\xb8\x01\x18\x1c\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\xb8\x01\x1f\x20\n\x0c\n\x04\x04\x04\x02\x02\x12\x04\xb9\x01\x08&\n\
    \r\n\x05\x04\x04\x02\x02\x04\x12\x04\xb9\x01\x08\x10\n\r\n\x05\x04\x04\
    \x02\x02\x06\x12\x04\xb9\x01\x11\x1c\n\r\n\x05\x04\x04\x02\x02\x01\x12\
    \x04\xb9\x01\x1d!\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xb9\x01$%\n\x0c\
    \n\x04\x04\x04\x02\x03\x12\x04\xba\x01\x08*\n\r\n\x05\x04\x04\x02\x03\
    \x04\x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\x04\x02\x03\x06\x12\x04\xba\
    \x01\x11\x1e\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xba\x01\x1f%\n\r\n\
    \x05\x04\x04\x02\x03\x03\x12\x04\xba\x01()\n\x0c\n\x04\x04\x04\x02\x04\
    \x12\x04\xbb\x01\x081\n\r\n\x05\x04\x04\x02\x04\x04\x12\x04\xbb\x01\x08\
    \x10\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\xbb\x01\x11\x17\n\r\n\x05\x04\
    \x04\x02\x04\x01\x12\x04\xbb\x01\x18,\n\r\n\x05\x04\x04\x02\x04\x03\x12\
    \x04\xbb\x01/0\n\x0c\n\x04\x04\x04\x02\x05\x12\x04\xbc\x01\x08-\n\r\n\
    \x05\x04\x04\x02\x05\x04\x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\x04\x02\
    \x05\x05\x12\x04\xbc\x01\x11\x17\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\
    \xbc\x01\x18(\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\xbc\x01+,\n\x0c\n\
    \x04\x04\x04\x02\x06\x12\x04\xbd\x01\x08,\n\r\n\x05\x04\x04\x02\x06\x04\
    \x12\x04\xbd\x01\x08\x10\n\r\n\x05\x04\x04\x02\x06\x05\x12\x04\xbd\x01\
    \x11\x17\n\r\n\x05\x04\x04\x02\x06\x01\x12\x04\xbd\x01\x18'\n\r\n\x05\
    \x04\x04\x02\x06\x03\x12\x04\xbd\x01*+\n\x0c\n\x04\x04\x04\x02\x07\x12\
    \x04\xbe\x01\x08*\n\r\n\x05\x04\x04\x02\x07\x04\x12\x04\xbe\x01\x08\x10\
    \n\r\n\x05\x04\x04\x02\x07\x05\x12\x04\xbe\x01\x11\x17\n\r\n\x05\x04\x04\
    \x02\x07\x01\x12\x04\xbe\x01\x18%\n\r\n\x05\x04\x04\x02\x07\x03\x12\x04\
    \xbe\x01()\n\x0c\n\x04\x04\x04\x02\x08\x12\x04\xbf\x01\x08#\n\r\n\x05\
    \x04\x04\x02\x08\x04\x12\x04\xbf\x01\x08\x10\n\r\n\x05\x04\x04\x02\x08\
    \x05\x12\x04\xbf\x01\x11\x17\n\r\n\x05\x04\x04\x02\x08\x01\x12\x04\xbf\
    \x01\x18\x1e\n\r\n\x05\x04\x04\x02\x08\x03\x12\x04\xbf\x01!\"\n\x0c\n\
    \x02\x04\x05\x12\x06\xc2\x01\0\xc4\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\
    \x04\xc2\x01\x08\x1e\n\x0c\n\x04\x04\x05\x02\0\x12\x04\xc3\x01\x08.\n\r\
    \n\x05\x04\x05\x02\0\x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\
    \x06\x12\x04\xc3\x01\x11#\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xc3\x01$)\
    \n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xc3\x01,-\n\x0c\n\x02\x04\x06\x12\
    \x06\xc6\x01\0\xd8\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xc6\x01\x08\
    \x1f\n\x0e\n\x04\x04\x06\x03\0\x12\x06\xc7\x01\x08\xd5\x01\t\n\r\n\x05\
    \x04\x06\x03\0\x01\x12\x04\xc7\x01\x10\x18\n\x0e\n\x06\x04\x06\x03\0\x02\
    \0\x12\x04\xc8\x01\x10.\n\x0f\n\x07\x04\x06\x03\0\x02\0\x04\x12\x04\xc8\
    \x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\0\x05\x12\x04\xc8\x01\x19\x1f\
    \n\x0f\n\x07\x04\x06\x03\0\x02\0\x01\x12\x04\xc8\x01\x20)\n\x0f\n\x07\
    \x04\x06\x03\0\x02\0\x03\x12\x04\xc8\x01,-\n\x0e\n\x06\x04\x06\x03\0\x02\
    \x01\x12\x04\xc9\x01\x104\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x04\x12\x04\
    \xc9\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x05\x12\x04\xc9\x01\
    \x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x01\x12\x04\xc9\x01\x20/\n\
    \x0f\n\x07\x04\x06\x03\0\x02\x01\x03\x12\x04\xc9\x0123\n\x0e\n\x06\x04\
    \x06\x03\0\x02\x02\x12\x04\xca\x01\x101\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x02\x04\x12\x04\xca\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x02\x05\
    \x12\x04\xca\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x02\x01\x12\x04\
    \xca\x01\x20,\n\x0f\n\x07\x04\x06\x03\0\x02\x02\x03\x12\x04\xca\x01/0\n\
    \x0e\n\x06\x04\x06\x03\0\x02\x03\x12\x04\xcb\x01\x101\n\x0f\n\x07\x04\
    \x06\x03\0\x02\x03\x04\x12\x04\xcb\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\
    \x02\x03\x05\x12\x04\xcb\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x03\
    \x01\x12\x04\xcb\x01\x20,\n\x0f\n\x07\x04\x06\x03\0\x02\x03\x03\x12\x04\
    \xcb\x01/0\n\x0e\n\x06\x04\x06\x03\0\x02\x04\x12\x04\xcc\x01\x104\n\x0f\
    \n\x07\x04\x06\x03\0\x02\x04\x04\x12\x04\xcc\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\0\x02\x04\x05\x12\x04\xcc\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\
    \x02\x04\x01\x12\x04\xcc\x01\x20/\n\x0f\n\x07\x04\x06\x03\0\x02\x04\x03\
    \x12\x04\xcc\x0123\n\x0e\n\x06\x04\x06\x03\0\x02\x05\x12\x04\xcd\x01\x10\
    .\n\x0f\n\x07\x04\x06\x03\0\x02\x05\x04\x12\x04\xcd\x01\x10\x18\n\x0f\n\
    \x07\x04\x06\x03\0\x02\x05\x05\x12\x04\xcd\x01\x19\x1f\n\x0f\n\x07\x04\
    \x06\x03\0\x02\x05\x01\x12\x04\xcd\x01\x20)\n\x0f\n\x07\x04\x06\x03\0\
    \x02\x05\x03\x12\x04\xcd\x01,-\n\x0e\n\x06\x04\x06\x03\0\x02\x06\x12\x04\
    \xce\x01\x10.\n\x0f\n\x07\x04\x06\x03\0\x02\x06\x04\x12\x04\xce\x01\x10\
    \x18\n\x0f\n\x07\x04\x06\x03\0\x02\x06\x05\x12\x04\xce\x01\x19\x1f\n\x0f\
    \n\x07\x04\x06\x03\0\x02\x06\x01\x12\x04\xce\x01\x20)\n\x0f\n\x07\x04\
    \x06\x03\0\x02\x06\x03\x12\x04\xce\x01,-\n\x0e\n\x06\x04\x06\x03\0\x02\
    \x07\x12\x04\xcf\x01\x102\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x04\x12\x04\
    \xcf\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x05\x12\x04\xcf\x01\
    \x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x01\x12\x04\xcf\x01\x20,\n\
    \x0f\n\x07\x04\x06\x03\0\x02\x07\x03\x12\x04\xcf\x01/1\n\x0e\n\x06\x04\
    \x06\x03\0\x02\x08\x12\x04\xd0\x01\x10)\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x08\x04\x12\x04\xd0\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x05\
    \x12\x04\xd0\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x01\x12\x04\
    \xd0\x01\x20$\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x03\x12\x04\xd0\x01'(\n\
    \x0e\n\x06\x04\x06\x03\0\x02\t\x12\x04\xd1\x01\x10/\n\x0f\n\x07\x04\x06\
    \x03\0\x02\t\x04\x12\x04\xd1\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\t\
    \x05\x12\x04\xd1\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\t\x01\x12\x04\
    \xd1\x01\x20*\n\x0f\n\x07\x04\x06\x03\0\x02\t\x03\x12\x04\xd1\x01-.\n\
    \x0e\n\x06\x04\x06\x03\0\x02\n\x12\x04\xd2\x01\x104\n\x0f\n\x07\x04\x06\
    \x03\0\x02\n\x04\x12\x04\xd2\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\n\
    \x05\x12\x04\xd2\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\n\x01\x12\x04\
    \xd2\x01\x20.\n\x0f\n\x07\x04\x06\x03\0\x02\n\x03\x12\x04\xd2\x0113\n\
    \x0e\n\x06\x04\x06\x03\0\x02\x0b\x12\x04\xd3\x01\x10/\n\x0f\n\x07\x04\
    \x06\x03\0\x02\x0b\x04\x12\x04\xd3\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\
    \x02\x0b\x05\x12\x04\xd3\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x0b\
    \x01\x12\x04\xd3\x01\x20)\n\x0f\n\x07\x04\x06\x03\0\x02\x0b\x03\x12\x04\
    \xd3\x01,.\n\x0e\n\x06\x04\x06\x03\0\x02\x0c\x12\x04\xd4\x01\x10.\n\x0f\
    \n\x07\x04\x06\x03\0\x02\x0c\x04\x12\x04\xd4\x01\x10\x18\n\x0f\n\x07\x04\
    \x06\x03\0\x02\x0c\x05\x12\x04\xd4\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\
    \x02\x0c\x01\x12\x04\xd4\x01\x20(\n\x0f\n\x07\x04\x06\x03\0\x02\x0c\x03\
    \x12\x04\xd4\x01+-\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xd7\x01\x08<\n\r\n\
    \x05\x04\x06\x02\0\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\
    \x06\x12\x04\xd7\x01\x111\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xd7\x0127\
    \n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xd7\x01:;\n\x0c\n\x02\x04\x07\x12\
    \x06\xda\x01\0\xe2\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xda\x01\x08\
    \x1e\n\x0e\n\x04\x04\x07\x03\0\x12\x06\xdb\x01\x08\xdf\x01\t\n\r\n\x05\
    \x04\x07\x03\0\x01\x12\x04\xdb\x01\x10\x17\n\x0e\n\x06\x04\x07\x03\0\x02\
    \0\x12\x04\xdc\x01\x106\n\x0f\n\x07\x04\x07\x03\0\x02\0\x04\x12\x04\xdc\
    \x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\0\x05\x12\x04\xdc\x01\x19\x1f\
    \n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\x12\x04\xdc\x01\x201\n\x0f\n\x07\
    \x04\x07\x03\0\x02\0\x03\x12\x04\xdc\x0145\n\x0e\n\x06\x04\x07\x03\0\x02\
    \x01\x12\x04\xdd\x01\x10.\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x04\x12\x04\
    \xdd\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x05\x12\x04\xdd\x01\
    \x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x01\x12\x04\xdd\x01\x20)\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x01\x03\x12\x04\xdd\x01,-\n\x0e\n\x06\x04\
    \x07\x03\0\x02\x02\x12\x04\xde\x01\x10,\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x02\x04\x12\x04\xde\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x05\
    \x12\x04\xde\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x01\x12\x04\
    \xde\x01\x20'\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x03\x12\x04\xde\x01*+\n\
    \x0c\n\x04\x04\x07\x02\0\x12\x04\xe1\x01\x08=\n\r\n\x05\x04\x07\x02\0\
    \x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xe1\x01\
    \x11/\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xe1\x0108\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\xe1\x01;<\n\x0c\n\x02\x04\x08\x12\x06\xe4\x01\0\xe7\
    \x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\xe4\x01\x08\x1f\n\x0c\n\x04\x04\
    \x08\x02\0\x12\x04\xe5\x01\x08'\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xe5\
    \x01\x08\x10\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xe5\x01\x11\x17\n\r\n\
    \x05\x04\x08\x02\0\x01\x12\x04\xe5\x01\x18\"\n\r\n\x05\x04\x08\x02\0\x03\
    \x12\x04\xe5\x01%&\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xe6\x01\x080\n\r\
    \n\x05\x04\x08\x02\x01\x04\x12\x04\xe6\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x01\x05\x12\x04\xe6\x01\x11\x16\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\
    \xe6\x01\x17+\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xe6\x01./\n\x0c\n\
    \x02\x04\t\x12\x06\xe9\x01\0\xea\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xe9\x01\x08+\n\x0c\n\x02\x04\n\x12\x06\xec\x01\0\xee\x01\x01\n\x0b\n\
    \x03\x04\n\x01\x12\x04\xec\x01\x080\n\x0c\n\x04\x04\n\x02\0\x12\x04\xed\
    \x01\x08&\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xed\x01\x08\x10\n\r\n\x05\
    \x04\n\x02\0\x05\x12\x04\xed\x01\x11\x17\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\xed\x01\x18!\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xed\x01$%\n\x0c\n\
    \x02\x04\x0b\x12\x06\xf0\x01\0\xfa\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\xf0\x01\x08)\n\x0e\n\x04\x04\x0b\x03\0\x12\x06\xf1\x01\x08\xf7\x01\
    \t\n\r\n\x05\x04\x0b\x03\0\x01\x12\x04\xf1\x01\x10\x18\n\x0e\n\x06\x04\
    \x0b\x03\0\x02\0\x12\x04\xf2\x01\x10,\n\x0f\n\x07\x04\x0b\x03\0\x02\0\
    \x04\x12\x04\xf2\x01\x10\x18\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x05\x12\x04\
    \xf2\x01\x19\x1f\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x01\x12\x04\xf2\x01\x20\
    '\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x03\x12\x04\xf2\x01*+\n\x0e\n\x06\x04\
    \x0b\x03\0\x02\x01\x12\x04\xf3\x01\x10.\n\x0f\n\x07\x04\x0b\x03\0\x02\
    \x01\x04\x12\x04\xf3\x01\x10\x18\n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x05\
    \x12\x04\xf3\x01\x19\x1f\n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x01\x12\x04\
    \xf3\x01\x20)\n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x03\x12\x04\xf3\x01,-\n\
    \x0e\n\x06\x04\x0b\x03\0\x02\x02\x12\x04\xf4\x01\x104\n\x0f\n\x07\x04\
    \x0b\x03\0\x02\x02\x04\x12\x04\xf4\x01\x10\x18\n\x0f\n\x07\x04\x0b\x03\0\
    \x02\x02\x05\x12\x04\xf4\x01\x19\x1f\n\x0f\n\x07\x04\x0b\x03\0\x02\x02\
    \x01\x12\x04\xf4\x01\x20/\n\x0f\n\x07\x04\x0b\x03\0\x02\x02\x03\x12\x04\
    \xf4\x0123\n\x0e\n\x06\x04\x0b\x03\0\x02\x03\x12\x04\xf5\x01\x10.\n\x0f\
    \n\x07\x04\x0b\x03\0\x02\x03\x04\x12\x04\xf5\x01\x10\x18\n\x0f\n\x07\x04\
    \x0b\x03\0\x02\x03\x05\x12\x04\xf5\x01\x19\x1f\n\x0f\n\x07\x04\x0b\x03\0\
    \x02\x03\x01\x12\x04\xf5\x01\x20)\n\x0f\n\x07\x04\x0b\x03\0\x02\x03\x03\
    \x12\x04\xf5\x01,-\n\x0e\n\x06\x04\x0b\x03\0\x02\x04\x12\x04\xf6\x01\x10\
    .\n\x0f\n\x07\x04\x0b\x03\0\x02\x04\x04\x12\x04\xf6\x01\x10\x18\n\x0f\n\
    \x07\x04\x0b\x03\0\x02\x04\x05\x12\x04\xf6\x01\x19\x1f\n\x0f\n\x07\x04\
    \x0b\x03\0\x02\x04\x01\x12\x04\xf6\x01\x20)\n\x0f\n\x07\x04\x0b\x03\0\
    \x02\x04\x03\x12\x04\xf6\x01,-\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xf9\x01\
    \x08K\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xf9\x01\x08\x10\n\r\n\x05\x04\
    \x0b\x02\0\x06\x12\x04\xf9\x01\x11;\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\
    \xf9\x01<F\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xf9\x01IJ\n\x0c\n\x02\x04\
    \x0c\x12\x06\xfc\x01\0\x92\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xfc\
    \x01\x08!\n\x0e\n\x04\x04\x0c\x03\0\x12\x06\xfd\x01\x08\x8f\x02\t\n\r\n\
    \x05\x04\x0c\x03\0\x01\x12\x04\xfd\x01\x10\x16\n\x0e\n\x06\x04\x0c\x03\0\
    \x02\0\x12\x04\xfe\x01\x10,\n\x0f\n\x07\x04\x0c\x03\0\x02\0\x04\x12\x04\
    \xfe\x01\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\x02\0\x05\x12\x04\xfe\x01\x19\
    \x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\0\x01\x12\x04\xfe\x01\x20'\n\x0f\n\
    \x07\x04\x0c\x03\0\x02\0\x03\x12\x04\xfe\x01*+\n\x0e\n\x06\x04\x0c\x03\0\
    \x02\x01\x12\x04\xff\x01\x104\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x04\x12\
    \x04\xff\x01\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x05\x12\x04\xff\
    \x01\x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x01\x12\x04\xff\x01\x20/\
    \n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x03\x12\x04\xff\x0123\n\x0e\n\x06\x04\
    \x0c\x03\0\x02\x02\x12\x04\x80\x02\x103\n\x0f\n\x07\x04\x0c\x03\0\x02\
    \x02\x04\x12\x04\x80\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\x02\x02\x05\
    \x12\x04\x80\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\x02\x01\x12\x04\
    \x80\x02\x20.\n\x0f\n\x07\x04\x0c\x03\0\x02\x02\x03\x12\x04\x80\x0212\n\
    \x0e\n\x06\x04\x0c\x03\0\x02\x03\x12\x04\x81\x02\x107\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\x03\x04\x12\x04\x81\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\
    \x02\x03\x05\x12\x04\x81\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\x03\
    \x01\x12\x04\x81\x02\x202\n\x0f\n\x07\x04\x0c\x03\0\x02\x03\x03\x12\x04\
    \x81\x0256\n\x0e\n\x06\x04\x0c\x03\0\x02\x04\x12\x04\x82\x02\x107\n\x0f\
    \n\x07\x04\x0c\x03\0\x02\x04\x04\x12\x04\x82\x02\x10\x18\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\x04\x05\x12\x04\x82\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\
    \x02\x04\x01\x12\x04\x82\x02\x202\n\x0f\n\x07\x04\x0c\x03\0\x02\x04\x03\
    \x12\x04\x82\x0256\n\x0e\n\x06\x04\x0c\x03\0\x02\x05\x12\x04\x83\x02\x10\
    .\n\x0f\n\x07\x04\x0c\x03\0\x02\x05\x04\x12\x04\x83\x02\x10\x18\n\x0f\n\
    \x07\x04\x0c\x03\0\x02\x05\x05\x12\x04\x83\x02\x19\x1f\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\x05\x01\x12\x04\x83\x02\x20)\n\x0f\n\x07\x04\x0c\x03\0\
    \x02\x05\x03\x12\x04\x83\x02,-\n\x0e\n\x06\x04\x0c\x03\0\x02\x06\x12\x04\
    \x84\x02\x10.\n\x0f\n\x07\x04\x0c\x03\0\x02\x06\x04\x12\x04\x84\x02\x10\
    \x18\n\x0f\n\x07\x04\x0c\x03\0\x02\x06\x05\x12\x04\x84\x02\x19\x1f\n\x0f\
    \n\x07\x04\x0c\x03\0\x02\x06\x01\x12\x04\x84\x02\x20)\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\x06\x03\x12\x04\x84\x02,-\n\x0e\n\x06\x04\x0c\x03\0\x02\
    \x07\x12\x04\x85\x02\x100\n\x0f\n\x07\x04\x0c\x03\0\x02\x07\x04\x12\x04\
    \x85\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\x02\x07\x05\x12\x04\x85\x02\
    \x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\x07\x01\x12\x04\x85\x02\x20+\n\
    \x0f\n\x07\x04\x0c\x03\0\x02\x07\x03\x12\x04\x85\x02./\n\x0e\n\x06\x04\
    \x0c\x03\0\x02\x08\x12\x04\x86\x02\x100\n\x0f\n\x07\x04\x0c\x03\0\x02\
    \x08\x04\x12\x04\x86\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\x02\x08\x05\
    \x12\x04\x86\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\x08\x01\x12\x04\
    \x86\x02\x20+\n\x0f\n\x07\x04\x0c\x03\0\x02\x08\x03\x12\x04\x86\x02./\n\
    \x0e\n\x06\x04\x0c\x03\0\x02\t\x12\x04\x87\x02\x101\n\x0f\n\x07\x04\x0c\
    \x03\0\x02\t\x04\x12\x04\x87\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\x02\t\
    \x05\x12\x04\x87\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\t\x01\x12\x04\
    \x87\x02\x20+\n\x0f\n\x07\x04\x0c\x03\0\x02\t\x03\x12\x04\x87\x02.0\n\
    \x0e\n\x06\x04\x0c\x03\0\x02\n\x12\x04\x88\x02\x101\n\x0f\n\x07\x04\x0c\
    \x03\0\x02\n\x04\x12\x04\x88\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\x02\n\
    \x05\x12\x04\x88\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\n\x01\x12\x04\
    \x88\x02\x20+\n\x0f\n\x07\x04\x0c\x03\0\x02\n\x03\x12\x04\x88\x02.0\n\
    \x0e\n\x06\x04\x0c\x03\0\x02\x0b\x12\x04\x89\x02\x105\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\x0b\x04\x12\x04\x89\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\
    \x02\x0b\x05\x12\x04\x89\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\x0b\
    \x01\x12\x04\x89\x02\x20/\n\x0f\n\x07\x04\x0c\x03\0\x02\x0b\x03\x12\x04\
    \x89\x0224\n\x0e\n\x06\x04\x0c\x03\0\x02\x0c\x12\x04\x8a\x02\x104\n\x0f\
    \n\x07\x04\x0c\x03\0\x02\x0c\x04\x12\x04\x8a\x02\x10\x18\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\x0c\x05\x12\x04\x8a\x02\x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\
    \x02\x0c\x01\x12\x04\x8a\x02\x20.\n\x0f\n\x07\x04\x0c\x03\0\x02\x0c\x03\
    \x12\x04\x8a\x0213\n\x0e\n\x06\x04\x0c\x03\0\x02\r\x12\x04\x8b\x02\x10/\
    \n\x0f\n\x07\x04\x0c\x03\0\x02\r\x04\x12\x04\x8b\x02\x10\x18\n\x0f\n\x07\
    \x04\x0c\x03\0\x02\r\x05\x12\x04\x8b\x02\x19\x1d\n\x0f\n\x07\x04\x0c\x03\
    \0\x02\r\x01\x12\x04\x8b\x02\x1e)\n\x0f\n\x07\x04\x0c\x03\0\x02\r\x03\
    \x12\x04\x8b\x02,.\n\x0e\n\x06\x04\x0c\x03\0\x02\x0e\x12\x04\x8c\x02\x10\
    0\n\x0f\n\x07\x04\x0c\x03\0\x02\x0e\x04\x12\x04\x8c\x02\x10\x18\n\x0f\n\
    \x07\x04\x0c\x03\0\x02\x0e\x05\x12\x04\x8c\x02\x19\x1d\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\x0e\x01\x12\x04\x8c\x02\x1e*\n\x0f\n\x07\x04\x0c\x03\0\
    \x02\x0e\x03\x12\x04\x8c\x02-/\n\x0e\n\x06\x04\x0c\x03\0\x02\x0f\x12\x04\
    \x8d\x02\x104\n\x0f\n\x07\x04\x0c\x03\0\x02\x0f\x04\x12\x04\x8d\x02\x10\
    \x18\n\x0f\n\x07\x04\x0c\x03\0\x02\x0f\x05\x12\x04\x8d\x02\x19\x1f\n\x0f\
    \n\x07\x04\x0c\x03\0\x02\x0f\x01\x12\x04\x8d\x02\x20.\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\x0f\x03\x12\x04\x8d\x0213\n\x0e\n\x06\x04\x0c\x03\0\x02\
    \x10\x12\x04\x8e\x02\x10/\n\x0f\n\x07\x04\x0c\x03\0\x02\x10\x04\x12\x04\
    \x8e\x02\x10\x18\n\x0f\n\x07\x04\x0c\x03\0\x02\x10\x05\x12\x04\x8e\x02\
    \x19\x1f\n\x0f\n\x07\x04\x0c\x03\0\x02\x10\x01\x12\x04\x8e\x02\x20)\n\
    \x0f\n\x07\x04\x0c\x03\0\x02\x10\x03\x12\x04\x8e\x02,.\n\x0c\n\x04\x04\
    \x0c\x02\0\x12\x04\x91\x02\x08C\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\x91\
    \x02\x08\x10\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\x91\x02\x111\n\r\n\x05\
    \x04\x0c\x02\0\x01\x12\x04\x91\x022>\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\
    \x91\x02AB\n\x0c\n\x02\x04\r\x12\x06\x94\x02\0\xa5\x02\x01\n\x0b\n\x03\
    \x04\r\x01\x12\x04\x94\x02\x08\x20\n\x0e\n\x04\x04\r\x03\0\x12\x06\x95\
    \x02\x08\xa0\x02\t\n\r\n\x05\x04\r\x03\0\x01\x12\x04\x95\x02\x10\x16\n\
    \x0e\n\x06\x04\r\x03\0\x02\0\x12\x04\x96\x02\x10-\n\x0f\n\x07\x04\r\x03\
    \0\x02\0\x04\x12\x04\x96\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\0\x05\
    \x12\x04\x96\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\x02\0\x01\x12\x04\x96\
    \x02\x20(\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\x12\x04\x96\x02+,\n\x0e\n\
    \x06\x04\r\x03\0\x02\x01\x12\x04\x97\x02\x10,\n\x0f\n\x07\x04\r\x03\0\
    \x02\x01\x04\x12\x04\x97\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\x01\x05\
    \x12\x04\x97\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\x02\x01\x01\x12\x04\x97\
    \x02\x20'\n\x0f\n\x07\x04\r\x03\0\x02\x01\x03\x12\x04\x97\x02*+\n\x0e\n\
    \x06\x04\r\x03\0\x02\x02\x12\x04\x98\x02\x10.\n\x0f\n\x07\x04\r\x03\0\
    \x02\x02\x04\x12\x04\x98\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\x02\x05\
    \x12\x04\x98\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\x02\x02\x01\x12\x04\x98\
    \x02\x20)\n\x0f\n\x07\x04\r\x03\0\x02\x02\x03\x12\x04\x98\x02,-\n\x0e\n\
    \x06\x04\r\x03\0\x02\x03\x12\x04\x99\x02\x10.\n\x0f\n\x07\x04\r\x03\0\
    \x02\x03\x04\x12\x04\x99\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\x03\x05\
    \x12\x04\x99\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\x02\x03\x01\x12\x04\x99\
    \x02\x20)\n\x0f\n\x07\x04\r\x03\0\x02\x03\x03\x12\x04\x99\x02,-\n\x0e\n\
    \x06\x04\r\x03\0\x02\x04\x12\x04\x9a\x02\x102\n\x0f\n\x07\x04\r\x03\0\
    \x02\x04\x04\x12\x04\x9a\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\x04\x05\
    \x12\x04\x9a\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\x02\x04\x01\x12\x04\x9a\
    \x02\x20-\n\x0f\n\x07\x04\r\x03\0\x02\x04\x03\x12\x04\x9a\x0201\n\x0e\n\
    \x06\x04\r\x03\0\x02\x05\x12\x04\x9b\x02\x10+\n\x0f\n\x07\x04\r\x03\0\
    \x02\x05\x04\x12\x04\x9b\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\x05\x05\
    \x12\x04\x9b\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\x02\x05\x01\x12\x04\x9b\
    \x02\x20&\n\x0f\n\x07\x04\r\x03\0\x02\x05\x03\x12\x04\x9b\x02)*\n\x0e\n\
    \x06\x04\r\x03\0\x02\x06\x12\x04\x9c\x02\x10-\n\x0f\n\x07\x04\r\x03\0\
    \x02\x06\x04\x12\x04\x9c\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\x06\x05\
    \x12\x04\x9c\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\x02\x06\x01\x12\x04\x9c\
    \x02\x20(\n\x0f\n\x07\x04\r\x03\0\x02\x06\x03\x12\x04\x9c\x02+,\n\x0e\n\
    \x06\x04\r\x03\0\x02\x07\x12\x04\x9d\x02\x10.\n\x0f\n\x07\x04\r\x03\0\
    \x02\x07\x04\x12\x04\x9d\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\x07\x05\
    \x12\x04\x9d\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\x02\x07\x01\x12\x04\x9d\
    \x02\x20)\n\x0f\n\x07\x04\r\x03\0\x02\x07\x03\x12\x04\x9d\x02,-\n\x0e\n\
    \x06\x04\r\x03\0\x02\x08\x12\x04\x9e\x02\x100\n\x0f\n\x07\x04\r\x03\0\
    \x02\x08\x04\x12\x04\x9e\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\x08\x06\
    \x12\x04\x9e\x02\x19%\n\x0f\n\x07\x04\r\x03\0\x02\x08\x01\x12\x04\x9e\
    \x02&+\n\x0f\n\x07\x04\r\x03\0\x02\x08\x03\x12\x04\x9e\x02./\n\x0e\n\x06\
    \x04\r\x03\0\x02\t\x12\x04\x9f\x02\x107\n\x0f\n\x07\x04\r\x03\0\x02\t\
    \x04\x12\x04\x9f\x02\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\t\x05\x12\x04\
    \x9f\x02\x19\x1f\n\x0f\n\x07\x04\r\x03\0\x02\t\x01\x12\x04\x9f\x02\x201\
    \n\x0f\n\x07\x04\r\x03\0\x02\t\x03\x12\x04\x9f\x0246\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\xa2\x02\x08=\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xa2\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xa2\x02\x110\n\r\n\x05\x04\r\
    \x02\0\x01\x12\x04\xa2\x0218\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xa2\x02;<\
    \n\x0c\n\x04\x04\r\x02\x01\x12\x04\xa3\x02\x08#\n\r\n\x05\x04\r\x02\x01\
    \x04\x12\x04\xa3\x02\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xa3\x02\
    \x11\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xa3\x02\x18\x1e\n\r\n\x05\
    \x04\r\x02\x01\x03\x12\x04\xa3\x02!\"\n\x0c\n\x04\x04\r\x02\x02\x12\x04\
    \xa4\x02\x08$\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xa4\x02\x08\x10\n\r\n\
    \x05\x04\r\x02\x02\x05\x12\x04\xa4\x02\x11\x17\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\xa4\x02\x18\x1f\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xa4\x02\
    \"#\n\x0c\n\x02\x04\x0e\x12\x06\xa7\x02\0\xb1\x02\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xa7\x02\x08\x1e\n\x0e\n\x04\x04\x0e\x03\0\x12\x06\xa8\
    \x02\x08\xae\x02\t\n\r\n\x05\x04\x0e\x03\0\x01\x12\x04\xa8\x02\x10\x16\n\
    \x0e\n\x06\x04\x0e\x03\0\x02\0\x12\x04\xa9\x02\x10.\n\x0f\n\x07\x04\x0e\
    \x03\0\x02\0\x04\x12\x04\xa9\x02\x10\x18\n\x0f\n\x07\x04\x0e\x03\0\x02\0\
    \x05\x12\x04\xa9\x02\x19\x1f\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x01\x12\x04\
    \xa9\x02\x20)\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x03\x12\x04\xa9\x02,-\n\
    \x0e\n\x06\x04\x0e\x03\0\x02\x01\x12\x04\xaa\x02\x10-\n\x0f\n\x07\x04\
    \x0e\x03\0\x02\x01\x04\x12\x04\xaa\x02\x10\x18\n\x0f\n\x07\x04\x0e\x03\0\
    \x02\x01\x05\x12\x04\xaa\x02\x19\x1f\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\
    \x01\x12\x04\xaa\x02\x20(\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x03\x12\x04\
    \xaa\x02+,\n\x0e\n\x06\x04\x0e\x03\0\x02\x02\x12\x04\xab\x02\x10+\n\x0f\
    \n\x07\x04\x0e\x03\0\x02\x02\x04\x12\x04\xab\x02\x10\x18\n\x0f\n\x07\x04\
    \x0e\x03\0\x02\x02\x05\x12\x04\xab\x02\x19\x1f\n\x0f\n\x07\x04\x0e\x03\0\
    \x02\x02\x01\x12\x04\xab\x02\x20&\n\x0f\n\x07\x04\x0e\x03\0\x02\x02\x03\
    \x12\x04\xab\x02)*\n\x0e\n\x06\x04\x0e\x03\0\x02\x03\x12\x04\xac\x02\x10\
    -\n\x0f\n\x07\x04\x0e\x03\0\x02\x03\x04\x12\x04\xac\x02\x10\x18\n\x0f\n\
    \x07\x04\x0e\x03\0\x02\x03\x05\x12\x04\xac\x02\x19\x1f\n\x0f\n\x07\x04\
    \x0e\x03\0\x02\x03\x01\x12\x04\xac\x02\x20(\n\x0f\n\x07\x04\x0e\x03\0\
    \x02\x03\x03\x12\x04\xac\x02+,\n\x0e\n\x06\x04\x0e\x03\0\x02\x04\x12\x04\
    \xad\x02\x10.\n\x0f\n\x07\x04\x0e\x03\0\x02\x04\x04\x12\x04\xad\x02\x10\
    \x18\n\x0f\n\x07\x04\x0e\x03\0\x02\x04\x05\x12\x04\xad\x02\x19\x1f\n\x0f\
    \n\x07\x04\x0e\x03\0\x02\x04\x01\x12\x04\xad\x02\x20)\n\x0f\n\x07\x04\
    \x0e\x03\0\x02\x04\x03\x12\x04\xad\x02,-\n\x0c\n\x04\x04\x0e\x02\0\x12\
    \x04\xb0\x02\x08;\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xb0\x02\x08\x10\n\
    \r\n\x05\x04\x0e\x02\0\x06\x12\x04\xb0\x02\x11.\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\xb0\x02/6\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xb0\x029:\n\
    \x0c\n\x02\x04\x0f\x12\x06\xb3\x02\0\xdd\x02\x01\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xb3\x02\x08\x20\n\x0e\n\x04\x04\x0f\x03\0\x12\x06\xb4\x02\x08\
    \xbc\x02\t\n\r\n\x05\x04\x0f\x03\0\x01\x12\x04\xb4\x02\x10\x20\n\x0e\n\
    \x06\x04\x0f\x03\0\x02\0\x12\x04\xb5\x02\x10.\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\0\x04\x12\x04\xb5\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x05\
    \x12\x04\xb5\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x01\x12\x04\xb5\
    \x02\x20)\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x03\x12\x04\xb5\x02,-\n\x0e\n\
    \x06\x04\x0f\x03\0\x02\x01\x12\x04\xb6\x02\x10.\n\x0f\n\x07\x04\x0f\x03\
    \0\x02\x01\x04\x12\x04\xb6\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\
    \x05\x12\x04\xb6\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x01\x12\
    \x04\xb6\x02\x20)\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x03\x12\x04\xb6\x02,\
    -\n\x0e\n\x06\x04\x0f\x03\0\x02\x02\x12\x04\xb7\x02\x10-\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\x02\x04\x12\x04\xb7\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\x02\x05\x12\x04\xb7\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\
    \x01\x12\x04\xb7\x02\x20(\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x03\x12\x04\
    \xb7\x02+,\n\x0e\n\x06\x04\x0f\x03\0\x02\x03\x12\x04\xb8\x02\x10+\n\x0f\
    \n\x07\x04\x0f\x03\0\x02\x03\x04\x12\x04\xb8\x02\x10\x18\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\x03\x05\x12\x04\xb8\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\x03\x01\x12\x04\xb8\x02\x20&\n\x0f\n\x07\x04\x0f\x03\0\x02\x03\x03\
    \x12\x04\xb8\x02)*\n\x0e\n\x06\x04\x0f\x03\0\x02\x04\x12\x04\xb9\x02\x10\
    -\n\x0f\n\x07\x04\x0f\x03\0\x02\x04\x04\x12\x04\xb9\x02\x10\x18\n\x0f\n\
    \x07\x04\x0f\x03\0\x02\x04\x05\x12\x04\xb9\x02\x19\x1f\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\x04\x01\x12\x04\xb9\x02\x20(\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\x04\x03\x12\x04\xb9\x02+,\n\x0e\n\x06\x04\x0f\x03\0\x02\x05\x12\x04\
    \xba\x02\x101\n\x0f\n\x07\x04\x0f\x03\0\x02\x05\x04\x12\x04\xba\x02\x10\
    \x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x05\x05\x12\x04\xba\x02\x19\x1f\n\x0f\
    \n\x07\x04\x0f\x03\0\x02\x05\x01\x12\x04\xba\x02\x20,\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\x05\x03\x12\x04\xba\x02/0\n\x0e\n\x06\x04\x0f\x03\0\x02\
    \x06\x12\x04\xbb\x02\x10/\n\x0f\n\x07\x04\x0f\x03\0\x02\x06\x04\x12\x04\
    \xbb\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x06\x05\x12\x04\xbb\x02\
    \x19\x1f\n\x0f\n\x07\x04\x0f\x03\0\x02\x06\x01\x12\x04\xbb\x02\x20*\n\
    \x0f\n\x07\x04\x0f\x03\0\x02\x06\x03\x12\x04\xbb\x02-.\n\x0e\n\x04\x04\
    \x0f\x03\x01\x12\x06\xbe\x02\x08\xc7\x02\t\n\r\n\x05\x04\x0f\x03\x01\x01\
    \x12\x04\xbe\x02\x10\x1a\n\x0e\n\x06\x04\x0f\x03\x01\x02\0\x12\x04\xbf\
    \x02\x10,\n\x0f\n\x07\x04\x0f\x03\x01\x02\0\x04\x12\x04\xbf\x02\x10\x18\
    \n\x0f\n\x07\x04\x0f\x03\x01\x02\0\x05\x12\x04\xbf\x02\x19\x1f\n\x0f\n\
    \x07\x04\x0f\x03\x01\x02\0\x01\x12\x04\xbf\x02\x20'\n\x0f\n\x07\x04\x0f\
    \x03\x01\x02\0\x03\x12\x04\xbf\x02*+\n\x0e\n\x06\x04\x0f\x03\x01\x02\x01\
    \x12\x04\xc0\x02\x10.\n\x0f\n\x07\x04\x0f\x03\x01\x02\x01\x04\x12\x04\
    \xc0\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\x01\x02\x01\x05\x12\x04\xc0\x02\
    \x19\x1f\n\x0f\n\x07\x04\x0f\x03\x01\x02\x01\x01\x12\x04\xc0\x02\x20)\n\
    \x0f\n\x07\x04\x0f\x03\x01\x02\x01\x03\x12\x04\xc0\x02,-\n\x0e\n\x06\x04\
    \x0f\x03\x01\x02\x02\x12\x04\xc1\x02\x106\n\x0f\n\x07\x04\x0f\x03\x01\
    \x02\x02\x04\x12\x04\xc1\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\x01\x02\x02\
    \x05\x12\x04\xc1\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\x01\x02\x02\x01\x12\
    \x04\xc1\x02\x201\n\x0f\n\x07\x04\x0f\x03\x01\x02\x02\x03\x12\x04\xc1\
    \x0245\n\x0e\n\x06\x04\x0f\x03\x01\x02\x03\x12\x04\xc2\x02\x10.\n\x0f\n\
    \x07\x04\x0f\x03\x01\x02\x03\x04\x12\x04\xc2\x02\x10\x18\n\x0f\n\x07\x04\
    \x0f\x03\x01\x02\x03\x05\x12\x04\xc2\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\
    \x01\x02\x03\x01\x12\x04\xc2\x02\x20)\n\x0f\n\x07\x04\x0f\x03\x01\x02\
    \x03\x03\x12\x04\xc2\x02,-\n\x0e\n\x06\x04\x0f\x03\x01\x02\x04\x12\x04\
    \xc3\x02\x102\n\x0f\n\x07\x04\x0f\x03\x01\x02\x04\x04\x12\x04\xc3\x02\
    \x10\x18\n\x0f\n\x07\x04\x0f\x03\x01\x02\x04\x05\x12\x04\xc3\x02\x19\x1f\
    \n\x0f\n\x07\x04\x0f\x03\x01\x02\x04\x01\x12\x04\xc3\x02\x20-\n\x0f\n\
    \x07\x04\x0f\x03\x01\x02\x04\x03\x12\x04\xc3\x0201\n\x0e\n\x06\x04\x0f\
    \x03\x01\x02\x05\x12\x04\xc4\x02\x101\n\x0f\n\x07\x04\x0f\x03\x01\x02\
    \x05\x04\x12\x04\xc4\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\x01\x02\x05\x05\
    \x12\x04\xc4\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\x01\x02\x05\x01\x12\x04\
    \xc4\x02\x20,\n\x0f\n\x07\x04\x0f\x03\x01\x02\x05\x03\x12\x04\xc4\x02/0\
    \n\x0e\n\x06\x04\x0f\x03\x01\x02\x06\x12\x04\xc5\x02\x103\n\x0f\n\x07\
    \x04\x0f\x03\x01\x02\x06\x04\x12\x04\xc5\x02\x10\x18\n\x0f\n\x07\x04\x0f\
    \x03\x01\x02\x06\x05\x12\x04\xc5\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\x01\
    \x02\x06\x01\x12\x04\xc5\x02\x20.\n\x0f\n\x07\x04\x0f\x03\x01\x02\x06\
    \x03\x12\x04\xc5\x0212\n\x0e\n\x06\x04\x0f\x03\x01\x02\x07\x12\x04\xc6\
    \x02\x10V\n\x0f\n\x07\x04\x0f\x03\x01\x02\x07\x04\x12\x04\xc6\x02\x10\
    \x18\n\x0f\n\x07\x04\x0f\x03\x01\x02\x07\x06\x12\x04\xc6\x02\x19B\n\x0f\
    \n\x07\x04\x0f\x03\x01\x02\x07\x01\x12\x04\xc6\x02CQ\n\x0f\n\x07\x04\x0f\
    \x03\x01\x02\x07\x03\x12\x04\xc6\x02TU\n\x0e\n\x04\x04\x0f\x03\x02\x12\
    \x06\xc9\x02\x08\xd0\x02\t\n\r\n\x05\x04\x0f\x03\x02\x01\x12\x04\xc9\x02\
    \x10\x1d\n\x0e\n\x06\x04\x0f\x03\x02\x02\0\x12\x04\xca\x02\x10,\n\x0f\n\
    \x07\x04\x0f\x03\x02\x02\0\x04\x12\x04\xca\x02\x10\x18\n\x0f\n\x07\x04\
    \x0f\x03\x02\x02\0\x05\x12\x04\xca\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\
    \x02\x02\0\x01\x12\x04\xca\x02\x20'\n\x0f\n\x07\x04\x0f\x03\x02\x02\0\
    \x03\x12\x04\xca\x02*+\n\x0e\n\x06\x04\x0f\x03\x02\x02\x01\x12\x04\xcb\
    \x02\x10)\n\x0f\n\x07\x04\x0f\x03\x02\x02\x01\x04\x12\x04\xcb\x02\x10\
    \x18\n\x0f\n\x07\x04\x0f\x03\x02\x02\x01\x05\x12\x04\xcb\x02\x19\x1f\n\
    \x0f\n\x07\x04\x0f\x03\x02\x02\x01\x01\x12\x04\xcb\x02\x20$\n\x0f\n\x07\
    \x04\x0f\x03\x02\x02\x01\x03\x12\x04\xcb\x02'(\n\x0e\n\x06\x04\x0f\x03\
    \x02\x02\x02\x12\x04\xcc\x02\x10+\n\x0f\n\x07\x04\x0f\x03\x02\x02\x02\
    \x04\x12\x04\xcc\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\x02\x02\x02\x05\x12\
    \x04\xcc\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\x02\x02\x02\x01\x12\x04\xcc\
    \x02\x20&\n\x0f\n\x07\x04\x0f\x03\x02\x02\x02\x03\x12\x04\xcc\x02)*\n\
    \x0e\n\x06\x04\x0f\x03\x02\x02\x03\x12\x04\xcd\x02\x10-\n\x0f\n\x07\x04\
    \x0f\x03\x02\x02\x03\x04\x12\x04\xcd\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\
    \x02\x02\x03\x05\x12\x04\xcd\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\x02\x02\
    \x03\x01\x12\x04\xcd\x02\x20(\n\x0f\n\x07\x04\x0f\x03\x02\x02\x03\x03\
    \x12\x04\xcd\x02+,\n\x0e\n\x06\x04\x0f\x03\x02\x02\x04\x12\x04\xce\x02\
    \x10.\n\x0f\n\x07\x04\x0f\x03\x02\x02\x04\x04\x12\x04\xce\x02\x10\x18\n\
    \x0f\n\x07\x04\x0f\x03\x02\x02\x04\x05\x12\x04\xce\x02\x19\x1f\n\x0f\n\
    \x07\x04\x0f\x03\x02\x02\x04\x01\x12\x04\xce\x02\x20)\n\x0f\n\x07\x04\
    \x0f\x03\x02\x02\x04\x03\x12\x04\xce\x02,-\n\x0e\n\x06\x04\x0f\x03\x02\
    \x02\x05\x12\x04\xcf\x02\x106\n\x0f\n\x07\x04\x0f\x03\x02\x02\x05\x04\
    \x12\x04\xcf\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\x02\x02\x05\x05\x12\x04\
    \xcf\x02\x19\x1f\n\x0f\n\x07\x04\x0f\x03\x02\x02\x05\x01\x12\x04\xcf\x02\
    \x201\n\x0f\n\x07\x04\x0f\x03\x02\x02\x05\x03\x12\x04\xcf\x0245\n\x0e\n\
    \x04\x04\x0f\x03\x03\x12\x06\xd2\x02\x08\xd6\x02\t\n\r\n\x05\x04\x0f\x03\
    \x03\x01\x12\x04\xd2\x02\x10\x18\n\x0e\n\x06\x04\x0f\x03\x03\x02\0\x12\
    \x04\xd3\x02\x102\n\x0f\n\x07\x04\x0f\x03\x03\x02\0\x04\x12\x04\xd3\x02\
    \x10\x18\n\x0f\n\x07\x04\x0f\x03\x03\x02\0\x06\x12\x04\xd3\x02\x19&\n\
    \x0f\n\x07\x04\x0f\x03\x03\x02\0\x01\x12\x04\xd3\x02'-\n\x0f\n\x07\x04\
    \x0f\x03\x03\x02\0\x03\x12\x04\xd3\x0201\n\x0e\n\x06\x04\x0f\x03\x03\x02\
    \x01\x12\x04\xd4\x02\x106\n\x0f\n\x07\x04\x0f\x03\x03\x02\x01\x04\x12\
    \x04\xd4\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\x03\x02\x01\x06\x12\x04\xd4\
    \x02\x19(\n\x0f\n\x07\x04\x0f\x03\x03\x02\x01\x01\x12\x04\xd4\x02)1\n\
    \x0f\n\x07\x04\x0f\x03\x03\x02\x01\x03\x12\x04\xd4\x0245\n\x0e\n\x06\x04\
    \x0f\x03\x03\x02\x02\x12\x04\xd5\x02\x10L\n\x0f\n\x07\x04\x0f\x03\x03\
    \x02\x02\x04\x12\x04\xd5\x02\x10\x18\n\x0f\n\x07\x04\x0f\x03\x03\x02\x02\
    \x06\x12\x04\xd5\x02\x19?\n\x0f\n\x07\x04\x0f\x03\x03\x02\x02\x01\x12\
    \x04\xd5\x02@G\n\x0f\n\x07\x04\x0f\x03\x03\x02\x02\x03\x12\x04\xd5\x02JK\
    \n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xd8\x02\x08A\n\r\n\x05\x04\x0f\x02\0\
    \x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xd8\x02\
    \x114\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xd8\x025<\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\xd8\x02?@\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xd9\x02\
    \x08A\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xd9\x02\x08\x10\n\r\n\x05\
    \x04\x0f\x02\x01\x06\x12\x04\xd9\x02\x112\n\r\n\x05\x04\x0f\x02\x01\x01\
    \x12\x04\xd9\x023<\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xd9\x02?@\n\x0c\
    \n\x04\x04\x0f\x02\x02\x12\x04\xda\x02\x08U\n\r\n\x05\x04\x0f\x02\x02\
    \x04\x12\x04\xda\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\xda\
    \x02\x117\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xda\x028P\n\r\n\x05\x04\
    \x0f\x02\x02\x03\x12\x04\xda\x02ST\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\
    \xdb\x02\x08R\n\r\n\x05\x04\x0f\x02\x03\x04\x12\x04\xdb\x02\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x03\x06\x12\x04\xdb\x02\x117\n\r\n\x05\x04\x0f\x02\
    \x03\x01\x12\x04\xdb\x028M\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xdb\x02\
    PQ\n\x0c\n\x04\x04\x0f\x02\x04\x12\x04\xdc\x02\x08T\n\r\n\x05\x04\x0f\
    \x02\x04\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x04\x06\x12\
    \x04\xdc\x02\x117\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xdc\x028O\n\r\n\
    \x05\x04\x0f\x02\x04\x03\x12\x04\xdc\x02RS\n\x0c\n\x02\x04\x10\x12\x06\
    \xdf\x02\0\xe2\x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xdf\x02\x08'\n\
    \x0c\n\x04\x04\x10\x02\0\x12\x04\xe0\x02\x08.\n\r\n\x05\x04\x10\x02\0\
    \x04\x12\x04\xe0\x02\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xe0\x02\
    \x11\x17\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xe0\x02\x18)\n\r\n\x05\x04\
    \x10\x02\0\x03\x12\x04\xe0\x02,-\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xe1\
    \x02\x08<\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xe1\x02\x08\x10\n\r\n\
    \x05\x04\x10\x02\x01\x06\x12\x04\xe1\x02\x11)\n\r\n\x05\x04\x10\x02\x01\
    \x01\x12\x04\xe1\x02*7\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xe1\x02:;\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::dota_shared_enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(37);
            messages.push(CMsgDOTALeagueNode::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueNodeGroup::generated_message_descriptor_data());
            messages.push(CMsgDOTALeague::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueList::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueInfo::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueInfoList::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueLiveGames::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueMessages::generated_message_descriptor_data());
            messages.push(CMsgDOTALeaguePrizePool::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueInfoListAdminsRequest::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueAvailableLobbyNodesRequest::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueAvailableLobbyNodes::generated_message_descriptor_data());
            messages.push(CMsgDOTALeagueNodeResults::generated_message_descriptor_data());
            messages.push(CMsgDOTADPCLeagueResults::generated_message_descriptor_data());
            messages.push(CMsgDOTADPCTeamResults::generated_message_descriptor_data());
            messages.push(CMsgDOTADPCSeasonResults::generated_message_descriptor_data());
            messages.push(CMsgDOTADPCSeasonSpoilerResults::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague_node::MatchDetails::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague_node::VOD::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague_node_group::TeamStanding::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague::Info::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague::Admin::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague::PrizePoolItem::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague::PrizePool::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague::Stream::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague::SeriesInfo::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague::Player::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague_live_games::LiveGame::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague_messages::Message::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague_available_lobby_nodes::NodeInfo::generated_message_descriptor_data());
            messages.push(cmsg_dotaleague_node_results::Result::generated_message_descriptor_data());
            messages.push(cmsg_dotadpcleague_results::Result::generated_message_descriptor_data());
            messages.push(cmsg_dotadpcteam_results::Result::generated_message_descriptor_data());
            messages.push(cmsg_dotadpcseason_results::TeamLeagueResult::generated_message_descriptor_data());
            messages.push(cmsg_dotadpcseason_results::TeamResult::generated_message_descriptor_data());
            messages.push(cmsg_dotadpcseason_results::StandingEntry::generated_message_descriptor_data());
            messages.push(cmsg_dotadpcseason_results::Standing::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(ELeagueNodeGroupType::generated_enum_descriptor_data());
            enums.push(ELeagueNodeType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
